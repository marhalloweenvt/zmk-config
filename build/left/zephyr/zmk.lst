
zmk.elf:     file format elf32-littlearm


Disassembly of section rom_start:

00026000 <_vector_table>:
   26000:	e8 9d 00 20 f5 d1 02 00 95 ab 04 00 c9 d1 02 00     ... ............
   26010:	c9 d1 02 00 c9 d1 02 00 c9 d1 02 00 00 00 00 00     ................
	...
   2602c:	2d cf 02 00 c9 d1 02 00 00 00 00 00 e5 ce 02 00     -...............
   2603c:	c9 d1 02 00                                         ....

00026040 <_irq_vector_table>:
   26040:	a9 cf 02 00 bd f0 03 00 a9 cf 02 00 a9 cf 02 00     ................
   26050:	a9 cf 02 00 a9 cf 02 00 a9 cf 02 00 a9 cf 02 00     ................
   26060:	a9 cf 02 00 a9 cf 02 00 a9 cf 02 00 a9 cf 02 00     ................
   26070:	a9 cf 02 00 a9 cf 02 00 a9 cf 02 00 a9 cf 02 00     ................
   26080:	a9 cf 02 00 a9 cf 02 00 a9 cf 02 00 a9 cf 02 00     ................
   26090:	a9 cf 02 00 a9 cf 02 00 a9 cf 02 00 a9 cf 02 00     ................
   260a0:	a9 cf 02 00 a9 cf 02 00 a9 cf 02 00 a9 cf 02 00     ................
   260b0:	a9 cf 02 00 a9 cf 02 00 a9 cf 02 00 a9 cf 02 00     ................
   260c0:	a9 cf 02 00 a9 cf 02 00 a9 cf 02 00 a9 cf 02 00     ................
   260d0:	a9 cf 02 00 a9 cf 02 00 a9 cf 02 00 a9 cf 02 00     ................
   260e0:	a9 cf 02 00 a9 cf 02 00 a9 cf 02 00 a9 cf 02 00     ................
   260f0:	a9 cf 02 00 a9 cf 02 00 a9 cf 02 00 a9 cf 02 00     ................

Disassembly of section text:

00026100 <__aeabi_uldivmod>:
   26100:	b953      	cbnz	r3, 26118 <__aeabi_uldivmod+0x18>
   26102:	b94a      	cbnz	r2, 26118 <__aeabi_uldivmod+0x18>
   26104:	2900      	cmp	r1, #0
   26106:	bf08      	it	eq
   26108:	2800      	cmpeq	r0, #0
   2610a:	bf1c      	itt	ne
   2610c:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
   26110:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
   26114:	f000 b80c 	b.w	26130 <__aeabi_idiv0>
   26118:	f1ad 0c08 	sub.w	ip, sp, #8
   2611c:	e96d ce04 	strd	ip, lr, [sp, #-16]!
   26120:	f000 f808 	bl	26134 <__udivmoddi4>
   26124:	f8dd e004 	ldr.w	lr, [sp, #4]
   26128:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   2612c:	b004      	add	sp, #16
   2612e:	4770      	bx	lr

00026130 <__aeabi_idiv0>:
   26130:	4770      	bx	lr
   26132:	bf00      	nop

00026134 <__udivmoddi4>:
   26134:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   26138:	4686      	mov	lr, r0
   2613a:	468c      	mov	ip, r1
   2613c:	4608      	mov	r0, r1
   2613e:	9e08      	ldr	r6, [sp, #32]
   26140:	4615      	mov	r5, r2
   26142:	4674      	mov	r4, lr
   26144:	4619      	mov	r1, r3
   26146:	2b00      	cmp	r3, #0
   26148:	f040 80c2 	bne.w	262d0 <__udivmoddi4+0x19c>
   2614c:	4285      	cmp	r5, r0
   2614e:	fab2 f282 	clz	r2, r2
   26152:	d945      	bls.n	261e0 <__udivmoddi4+0xac>
   26154:	b14a      	cbz	r2, 2616a <__udivmoddi4+0x36>
   26156:	f1c2 0320 	rsb	r3, r2, #32
   2615a:	fa00 fc02 	lsl.w	ip, r0, r2
   2615e:	fa2e f303 	lsr.w	r3, lr, r3
   26162:	4095      	lsls	r5, r2
   26164:	ea43 0c0c 	orr.w	ip, r3, ip
   26168:	4094      	lsls	r4, r2
   2616a:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   2616e:	b2a8      	uxth	r0, r5
   26170:	fbbc f8fe 	udiv	r8, ip, lr
   26174:	0c23      	lsrs	r3, r4, #16
   26176:	fb0e cc18 	mls	ip, lr, r8, ip
   2617a:	fb08 f900 	mul.w	r9, r8, r0
   2617e:	ea43 430c 	orr.w	r3, r3, ip, lsl #16
   26182:	4599      	cmp	r9, r3
   26184:	d928      	bls.n	261d8 <__udivmoddi4+0xa4>
   26186:	18eb      	adds	r3, r5, r3
   26188:	f108 37ff 	add.w	r7, r8, #4294967295	; 0xffffffff
   2618c:	d204      	bcs.n	26198 <__udivmoddi4+0x64>
   2618e:	4599      	cmp	r9, r3
   26190:	d902      	bls.n	26198 <__udivmoddi4+0x64>
   26192:	f1a8 0702 	sub.w	r7, r8, #2
   26196:	442b      	add	r3, r5
   26198:	eba3 0309 	sub.w	r3, r3, r9
   2619c:	b2a4      	uxth	r4, r4
   2619e:	fbb3 fcfe 	udiv	ip, r3, lr
   261a2:	fb0e 331c 	mls	r3, lr, ip, r3
   261a6:	fb0c f000 	mul.w	r0, ip, r0
   261aa:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
   261ae:	42a0      	cmp	r0, r4
   261b0:	d914      	bls.n	261dc <__udivmoddi4+0xa8>
   261b2:	192c      	adds	r4, r5, r4
   261b4:	f10c 33ff 	add.w	r3, ip, #4294967295	; 0xffffffff
   261b8:	d204      	bcs.n	261c4 <__udivmoddi4+0x90>
   261ba:	42a0      	cmp	r0, r4
   261bc:	d902      	bls.n	261c4 <__udivmoddi4+0x90>
   261be:	f1ac 0302 	sub.w	r3, ip, #2
   261c2:	442c      	add	r4, r5
   261c4:	1a24      	subs	r4, r4, r0
   261c6:	ea43 4007 	orr.w	r0, r3, r7, lsl #16
   261ca:	b11e      	cbz	r6, 261d4 <__udivmoddi4+0xa0>
   261cc:	40d4      	lsrs	r4, r2
   261ce:	2300      	movs	r3, #0
   261d0:	6034      	str	r4, [r6, #0]
   261d2:	6073      	str	r3, [r6, #4]
   261d4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   261d8:	4647      	mov	r7, r8
   261da:	e7dd      	b.n	26198 <__udivmoddi4+0x64>
   261dc:	4663      	mov	r3, ip
   261de:	e7f1      	b.n	261c4 <__udivmoddi4+0x90>
   261e0:	bb92      	cbnz	r2, 26248 <__udivmoddi4+0x114>
   261e2:	1b43      	subs	r3, r0, r5
   261e4:	2101      	movs	r1, #1
   261e6:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   261ea:	b2af      	uxth	r7, r5
   261ec:	fbb3 fcfe 	udiv	ip, r3, lr
   261f0:	0c20      	lsrs	r0, r4, #16
   261f2:	fb0e 331c 	mls	r3, lr, ip, r3
   261f6:	fb0c f807 	mul.w	r8, ip, r7
   261fa:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
   261fe:	4598      	cmp	r8, r3
   26200:	d962      	bls.n	262c8 <__udivmoddi4+0x194>
   26202:	18eb      	adds	r3, r5, r3
   26204:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
   26208:	d204      	bcs.n	26214 <__udivmoddi4+0xe0>
   2620a:	4598      	cmp	r8, r3
   2620c:	d902      	bls.n	26214 <__udivmoddi4+0xe0>
   2620e:	f1ac 0002 	sub.w	r0, ip, #2
   26212:	442b      	add	r3, r5
   26214:	eba3 0308 	sub.w	r3, r3, r8
   26218:	b2a4      	uxth	r4, r4
   2621a:	fbb3 fcfe 	udiv	ip, r3, lr
   2621e:	fb0e 331c 	mls	r3, lr, ip, r3
   26222:	fb0c f707 	mul.w	r7, ip, r7
   26226:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
   2622a:	42a7      	cmp	r7, r4
   2622c:	d94e      	bls.n	262cc <__udivmoddi4+0x198>
   2622e:	192c      	adds	r4, r5, r4
   26230:	f10c 33ff 	add.w	r3, ip, #4294967295	; 0xffffffff
   26234:	d204      	bcs.n	26240 <__udivmoddi4+0x10c>
   26236:	42a7      	cmp	r7, r4
   26238:	d902      	bls.n	26240 <__udivmoddi4+0x10c>
   2623a:	f1ac 0302 	sub.w	r3, ip, #2
   2623e:	442c      	add	r4, r5
   26240:	1be4      	subs	r4, r4, r7
   26242:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
   26246:	e7c0      	b.n	261ca <__udivmoddi4+0x96>
   26248:	f1c2 0320 	rsb	r3, r2, #32
   2624c:	fa20 f103 	lsr.w	r1, r0, r3
   26250:	4095      	lsls	r5, r2
   26252:	4090      	lsls	r0, r2
   26254:	fa2e f303 	lsr.w	r3, lr, r3
   26258:	4303      	orrs	r3, r0
   2625a:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   2625e:	b2af      	uxth	r7, r5
   26260:	fbb1 fcfe 	udiv	ip, r1, lr
   26264:	fb0e 101c 	mls	r0, lr, ip, r1
   26268:	0c19      	lsrs	r1, r3, #16
   2626a:	fb0c f807 	mul.w	r8, ip, r7
   2626e:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
   26272:	4588      	cmp	r8, r1
   26274:	fa04 f402 	lsl.w	r4, r4, r2
   26278:	d922      	bls.n	262c0 <__udivmoddi4+0x18c>
   2627a:	1869      	adds	r1, r5, r1
   2627c:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
   26280:	d204      	bcs.n	2628c <__udivmoddi4+0x158>
   26282:	4588      	cmp	r8, r1
   26284:	d902      	bls.n	2628c <__udivmoddi4+0x158>
   26286:	f1ac 0002 	sub.w	r0, ip, #2
   2628a:	4429      	add	r1, r5
   2628c:	eba1 0108 	sub.w	r1, r1, r8
   26290:	b29b      	uxth	r3, r3
   26292:	fbb1 fcfe 	udiv	ip, r1, lr
   26296:	fb0e 111c 	mls	r1, lr, ip, r1
   2629a:	fb0c f707 	mul.w	r7, ip, r7
   2629e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
   262a2:	429f      	cmp	r7, r3
   262a4:	d90e      	bls.n	262c4 <__udivmoddi4+0x190>
   262a6:	18eb      	adds	r3, r5, r3
   262a8:	f10c 31ff 	add.w	r1, ip, #4294967295	; 0xffffffff
   262ac:	d204      	bcs.n	262b8 <__udivmoddi4+0x184>
   262ae:	429f      	cmp	r7, r3
   262b0:	d902      	bls.n	262b8 <__udivmoddi4+0x184>
   262b2:	f1ac 0102 	sub.w	r1, ip, #2
   262b6:	442b      	add	r3, r5
   262b8:	1bdb      	subs	r3, r3, r7
   262ba:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
   262be:	e792      	b.n	261e6 <__udivmoddi4+0xb2>
   262c0:	4660      	mov	r0, ip
   262c2:	e7e3      	b.n	2628c <__udivmoddi4+0x158>
   262c4:	4661      	mov	r1, ip
   262c6:	e7f7      	b.n	262b8 <__udivmoddi4+0x184>
   262c8:	4660      	mov	r0, ip
   262ca:	e7a3      	b.n	26214 <__udivmoddi4+0xe0>
   262cc:	4663      	mov	r3, ip
   262ce:	e7b7      	b.n	26240 <__udivmoddi4+0x10c>
   262d0:	4283      	cmp	r3, r0
   262d2:	d906      	bls.n	262e2 <__udivmoddi4+0x1ae>
   262d4:	b916      	cbnz	r6, 262dc <__udivmoddi4+0x1a8>
   262d6:	2100      	movs	r1, #0
   262d8:	4608      	mov	r0, r1
   262da:	e77b      	b.n	261d4 <__udivmoddi4+0xa0>
   262dc:	e9c6 e000 	strd	lr, r0, [r6]
   262e0:	e7f9      	b.n	262d6 <__udivmoddi4+0x1a2>
   262e2:	fab3 f783 	clz	r7, r3
   262e6:	b98f      	cbnz	r7, 2630c <__udivmoddi4+0x1d8>
   262e8:	4283      	cmp	r3, r0
   262ea:	d301      	bcc.n	262f0 <__udivmoddi4+0x1bc>
   262ec:	4572      	cmp	r2, lr
   262ee:	d808      	bhi.n	26302 <__udivmoddi4+0x1ce>
   262f0:	ebbe 0402 	subs.w	r4, lr, r2
   262f4:	eb60 0303 	sbc.w	r3, r0, r3
   262f8:	2001      	movs	r0, #1
   262fa:	469c      	mov	ip, r3
   262fc:	b91e      	cbnz	r6, 26306 <__udivmoddi4+0x1d2>
   262fe:	2100      	movs	r1, #0
   26300:	e768      	b.n	261d4 <__udivmoddi4+0xa0>
   26302:	4638      	mov	r0, r7
   26304:	e7fa      	b.n	262fc <__udivmoddi4+0x1c8>
   26306:	e9c6 4c00 	strd	r4, ip, [r6]
   2630a:	e7f8      	b.n	262fe <__udivmoddi4+0x1ca>
   2630c:	f1c7 0c20 	rsb	ip, r7, #32
   26310:	40bb      	lsls	r3, r7
   26312:	fa22 f40c 	lsr.w	r4, r2, ip
   26316:	431c      	orrs	r4, r3
   26318:	fa2e f10c 	lsr.w	r1, lr, ip
   2631c:	fa20 f30c 	lsr.w	r3, r0, ip
   26320:	40b8      	lsls	r0, r7
   26322:	4301      	orrs	r1, r0
   26324:	ea4f 4914 	mov.w	r9, r4, lsr #16
   26328:	fa0e f507 	lsl.w	r5, lr, r7
   2632c:	fbb3 f8f9 	udiv	r8, r3, r9
   26330:	fa1f fe84 	uxth.w	lr, r4
   26334:	fb09 3018 	mls	r0, r9, r8, r3
   26338:	0c0b      	lsrs	r3, r1, #16
   2633a:	fb08 fa0e 	mul.w	sl, r8, lr
   2633e:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
   26342:	459a      	cmp	sl, r3
   26344:	fa02 f207 	lsl.w	r2, r2, r7
   26348:	d940      	bls.n	263cc <__udivmoddi4+0x298>
   2634a:	18e3      	adds	r3, r4, r3
   2634c:	f108 30ff 	add.w	r0, r8, #4294967295	; 0xffffffff
   26350:	d204      	bcs.n	2635c <__udivmoddi4+0x228>
   26352:	459a      	cmp	sl, r3
   26354:	d902      	bls.n	2635c <__udivmoddi4+0x228>
   26356:	f1a8 0002 	sub.w	r0, r8, #2
   2635a:	4423      	add	r3, r4
   2635c:	eba3 030a 	sub.w	r3, r3, sl
   26360:	b289      	uxth	r1, r1
   26362:	fbb3 f8f9 	udiv	r8, r3, r9
   26366:	fb09 3318 	mls	r3, r9, r8, r3
   2636a:	fb08 fe0e 	mul.w	lr, r8, lr
   2636e:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
   26372:	458e      	cmp	lr, r1
   26374:	d92c      	bls.n	263d0 <__udivmoddi4+0x29c>
   26376:	1861      	adds	r1, r4, r1
   26378:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
   2637c:	d204      	bcs.n	26388 <__udivmoddi4+0x254>
   2637e:	458e      	cmp	lr, r1
   26380:	d902      	bls.n	26388 <__udivmoddi4+0x254>
   26382:	f1a8 0302 	sub.w	r3, r8, #2
   26386:	4421      	add	r1, r4
   26388:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
   2638c:	fba0 9802 	umull	r9, r8, r0, r2
   26390:	eba1 010e 	sub.w	r1, r1, lr
   26394:	4541      	cmp	r1, r8
   26396:	46ce      	mov	lr, r9
   26398:	4643      	mov	r3, r8
   2639a:	d302      	bcc.n	263a2 <__udivmoddi4+0x26e>
   2639c:	d106      	bne.n	263ac <__udivmoddi4+0x278>
   2639e:	454d      	cmp	r5, r9
   263a0:	d204      	bcs.n	263ac <__udivmoddi4+0x278>
   263a2:	ebb9 0e02 	subs.w	lr, r9, r2
   263a6:	eb68 0304 	sbc.w	r3, r8, r4
   263aa:	3801      	subs	r0, #1
   263ac:	2e00      	cmp	r6, #0
   263ae:	d0a6      	beq.n	262fe <__udivmoddi4+0x1ca>
   263b0:	ebb5 020e 	subs.w	r2, r5, lr
   263b4:	eb61 0103 	sbc.w	r1, r1, r3
   263b8:	fa01 fc0c 	lsl.w	ip, r1, ip
   263bc:	fa22 f307 	lsr.w	r3, r2, r7
   263c0:	ea4c 0303 	orr.w	r3, ip, r3
   263c4:	40f9      	lsrs	r1, r7
   263c6:	e9c6 3100 	strd	r3, r1, [r6]
   263ca:	e798      	b.n	262fe <__udivmoddi4+0x1ca>
   263cc:	4640      	mov	r0, r8
   263ce:	e7c5      	b.n	2635c <__udivmoddi4+0x228>
   263d0:	4643      	mov	r3, r8
   263d2:	e7d9      	b.n	26388 <__udivmoddi4+0x254>
   263d4:	0000      	movs	r0, r0
	...

000263d8 <bt_init>:

	bt_dev_show_info();
}

static int bt_init(void)
{
   263d8:	b573      	push	{r0, r1, r4, r5, r6, lr}
	if (!(bt_dev.drv->quirks & BT_QUIRK_NO_RESET)) {
   263da:	4dc1      	ldr	r5, [pc, #772]	; (266e0 <bt_init+0x308>)
   263dc:	f8d5 3154 	ldr.w	r3, [r5, #340]	; 0x154
   263e0:	6899      	ldr	r1, [r3, #8]
   263e2:	f011 0101 	ands.w	r1, r1, #1
   263e6:	d124      	bne.n	26432 <bt_init+0x5a>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_RESET, NULL, &rsp);
   263e8:	aa01      	add	r2, sp, #4
   263ea:	f640 4003 	movw	r0, #3075	; 0xc03
   263ee:	f007 fd99 	bl	2df24 <bt_hci_cmd_send_sync>
		if (err) {
   263f2:	4604      	mov	r4, r0
   263f4:	2800      	cmp	r0, #0
   263f6:	d167      	bne.n	264c8 <bt_init+0xf0>
		hci_reset_complete(rsp);
   263f8:	9c01      	ldr	r4, [sp, #4]
	uint8_t status = buf->data[0];
   263fa:	68a3      	ldr	r3, [r4, #8]
	if (status) {
   263fc:	781b      	ldrb	r3, [r3, #0]
   263fe:	b9ab      	cbnz	r3, 2642c <bt_init+0x54>
		bt_scan_reset();
   26400:	f009 f818 	bl	2f434 <bt_scan_reset>
 *
 * @return Value of @a target.
 */
static inline atomic_val_t atomic_get(const atomic_t *target)
{
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   26404:	f3bf 8f5b 	dmb	ish
   26408:	f8d5 30cc 	ldr.w	r3, [r5, #204]	; 0xcc
   2640c:	f3bf 8f5b 	dmb	ish
   26410:	f105 02cc 	add.w	r2, r5, #204	; 0xcc
{
	/* This builtin, as described by Intel, is not a traditional
	 * test-and-set operation, but rather an atomic exchange operation. It
	 * writes value into *ptr, and returns the previous contents of *ptr.
	 */
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   26414:	f003 0309 	and.w	r3, r3, #9
   26418:	f3bf 8f5b 	dmb	ish
   2641c:	e852 1f00 	ldrex	r1, [r2]
   26420:	e842 3000 	strex	r0, r3, [r2]
   26424:	2800      	cmp	r0, #0
   26426:	d1f9      	bne.n	2641c <bt_init+0x44>
   26428:	f3bf 8f5b 	dmb	ish
		net_buf_unref(rsp);
   2642c:	4620      	mov	r0, r4
   2642e:	f01c fa0b 	bl	42848 <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_LOCAL_FEATURES, NULL, &rsp);
   26432:	aa01      	add	r2, sp, #4
   26434:	2100      	movs	r1, #0
   26436:	f241 0003 	movw	r0, #4099	; 0x1003
   2643a:	f007 fd73 	bl	2df24 <bt_hci_cmd_send_sync>
	if (err) {
   2643e:	4604      	mov	r4, r0
   26440:	2800      	cmp	r0, #0
   26442:	d141      	bne.n	264c8 <bt_init+0xf0>
	read_local_features_complete(rsp);
   26444:	9e01      	ldr	r6, [sp, #4]
	memcpy(bt_dev.features[0], rp->features, sizeof(bt_dev.features[0]));
   26446:	48a7      	ldr	r0, [pc, #668]	; (266e4 <bt_init+0x30c>)
   26448:	68b1      	ldr	r1, [r6, #8]
   2644a:	2208      	movs	r2, #8
   2644c:	3101      	adds	r1, #1
   2644e:	f024 fd14 	bl	4ae7a <memcpy>
	net_buf_unref(rsp);
   26452:	4630      	mov	r0, r6
   26454:	f01c f9f8 	bl	42848 <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_LOCAL_VERSION_INFO, NULL,
   26458:	4621      	mov	r1, r4
   2645a:	aa01      	add	r2, sp, #4
   2645c:	f241 0001 	movw	r0, #4097	; 0x1001
   26460:	f007 fd60 	bl	2df24 <bt_hci_cmd_send_sync>
	if (err) {
   26464:	4604      	mov	r4, r0
   26466:	bb78      	cbnz	r0, 264c8 <bt_init+0xf0>
	read_local_ver_complete(rsp);
   26468:	9801      	ldr	r0, [sp, #4]
	struct bt_hci_rp_read_local_version_info *rp = (void *)buf->data;
   2646a:	6883      	ldr	r3, [r0, #8]
	bt_dev.hci_version = rp->hci_version;
   2646c:	785a      	ldrb	r2, [r3, #1]
   2646e:	f885 2068 	strb.w	r2, [r5, #104]	; 0x68
	bt_dev.hci_revision = sys_le16_to_cpu(rp->hci_revision);
   26472:	885a      	ldrh	r2, [r3, #2]
   26474:	f8a5 206a 	strh.w	r2, [r5, #106]	; 0x6a
	bt_dev.lmp_version = rp->lmp_version;
   26478:	791a      	ldrb	r2, [r3, #4]
   2647a:	f885 2069 	strb.w	r2, [r5, #105]	; 0x69
	bt_dev.lmp_subversion = sys_le16_to_cpu(rp->lmp_subversion);
   2647e:	f8b3 2007 	ldrh.w	r2, [r3, #7]
   26482:	f8a5 206c 	strh.w	r2, [r5, #108]	; 0x6c
	bt_dev.manufacturer = sys_le16_to_cpu(rp->manufacturer);
   26486:	f8b3 3005 	ldrh.w	r3, [r3, #5]
   2648a:	f8a5 306e 	strh.w	r3, [r5, #110]	; 0x6e
	net_buf_unref(rsp);
   2648e:	f01c f9db 	bl	42848 <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_SUPPORTED_COMMANDS, NULL,
   26492:	4621      	mov	r1, r4
   26494:	aa01      	add	r2, sp, #4
   26496:	f241 0002 	movw	r0, #4098	; 0x1002
   2649a:	f007 fd43 	bl	2df24 <bt_hci_cmd_send_sync>
	if (err) {
   2649e:	4604      	mov	r4, r0
   264a0:	b990      	cbnz	r0, 264c8 <bt_init+0xf0>
	read_supported_commands_complete(rsp);
   264a2:	9e01      	ldr	r6, [sp, #4]
	memcpy(bt_dev.supported_commands, rp->commands,
   264a4:	4890      	ldr	r0, [pc, #576]	; (266e8 <bt_init+0x310>)
   264a6:	68b1      	ldr	r1, [r6, #8]
   264a8:	2240      	movs	r2, #64	; 0x40
   264aa:	3101      	adds	r1, #1
   264ac:	f024 fce5 	bl	4ae7a <memcpy>
		bt_hci_ecc_supported_commands(bt_dev.supported_commands);
   264b0:	488d      	ldr	r0, [pc, #564]	; (266e8 <bt_init+0x310>)
   264b2:	f024 fd69 	bl	4af88 <bt_hci_ecc_supported_commands>
	net_buf_unref(rsp);
   264b6:	4630      	mov	r0, r6
   264b8:	f01c f9c6 	bl	42848 <net_buf_unref>
	if (!BT_FEAT_LE(bt_dev.features)) {
   264bc:	f895 3074 	ldrb.w	r3, [r5, #116]	; 0x74
   264c0:	065a      	lsls	r2, r3, #25
   264c2:	d404      	bmi.n	264ce <bt_init+0xf6>
		return -ENODEV;
   264c4:	f06f 0412 	mvn.w	r4, #18
		atomic_set_bit(bt_dev.flags, BT_DEV_PRESET_ID);
	}

	bt_finalize_init();
	return 0;
}
   264c8:	4620      	mov	r0, r4
   264ca:	b002      	add	sp, #8
   264cc:	bd70      	pop	{r4, r5, r6, pc}
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_LOCAL_FEATURES, NULL,
   264ce:	4621      	mov	r1, r4
   264d0:	aa01      	add	r2, sp, #4
   264d2:	f242 0003 	movw	r0, #8195	; 0x2003
   264d6:	f007 fd25 	bl	2df24 <bt_hci_cmd_send_sync>
	if (err) {
   264da:	4604      	mov	r4, r0
   264dc:	2800      	cmp	r0, #0
   264de:	d1f3      	bne.n	264c8 <bt_init+0xf0>
	read_le_features_complete(rsp);
   264e0:	9e01      	ldr	r6, [sp, #4]
	memcpy(bt_dev.le.features, rp->features, sizeof(bt_dev.le.features));
   264e2:	4882      	ldr	r0, [pc, #520]	; (266ec <bt_init+0x314>)
   264e4:	68b1      	ldr	r1, [r6, #8]
   264e6:	2208      	movs	r2, #8
   264e8:	3101      	adds	r1, #1
   264ea:	f024 fcc6 	bl	4ae7a <memcpy>
	net_buf_unref(rsp);
   264ee:	4630      	mov	r0, r6
   264f0:	f01c f9aa 	bl	42848 <net_buf_unref>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_BUFFER_SIZE,
   264f4:	4621      	mov	r1, r4
   264f6:	aa01      	add	r2, sp, #4
   264f8:	f242 0002 	movw	r0, #8194	; 0x2002
   264fc:	f007 fd12 	bl	2df24 <bt_hci_cmd_send_sync>
		if (err) {
   26500:	4604      	mov	r4, r0
   26502:	2800      	cmp	r0, #0
   26504:	d1e0      	bne.n	264c8 <bt_init+0xf0>
		le_read_buffer_size_complete(rsp);
   26506:	9c01      	ldr	r4, [sp, #4]
	struct bt_hci_rp_le_read_buffer_size *rp = (void *)buf->data;
   26508:	68a3      	ldr	r3, [r4, #8]
	bt_dev.le.acl_mtu = sys_le16_to_cpu(rp->le_max_len);
   2650a:	f8b3 2001 	ldrh.w	r2, [r3, #1]
   2650e:	f8a5 20fc 	strh.w	r2, [r5, #252]	; 0xfc
   26512:	b291      	uxth	r1, r2
	if (!bt_dev.le.acl_mtu) {
   26514:	b121      	cbz	r1, 26520 <bt_init+0x148>
	k_sem_init(&bt_dev.le.acl_pkts, rp->le_max_num, rp->le_max_num);
   26516:	78da      	ldrb	r2, [r3, #3]
		union { uintptr_t x; unsigned int val; } parm2 = { .val = limit };
		return (int) arch_syscall_invoke3(parm0.x, parm1.x, parm2.x, K_SYSCALL_K_SEM_INIT);
	}
#endif
	compiler_barrier();
	return z_impl_k_sem_init(sem, initial_count, limit);
   26518:	4875      	ldr	r0, [pc, #468]	; (266f0 <bt_init+0x318>)
   2651a:	4611      	mov	r1, r2
   2651c:	f029 fcac 	bl	4fe78 <z_impl_k_sem_init>
		net_buf_unref(rsp);
   26520:	4620      	mov	r0, r4
   26522:	f01c f991 	bl	42848 <net_buf_unref>
	if (BT_FEAT_BREDR(bt_dev.features)) {
   26526:	f895 6074 	ldrb.w	r6, [r5, #116]	; 0x74
   2652a:	f016 0620 	ands.w	r6, r6, #32
   2652e:	d118      	bne.n	26562 <bt_init+0x18a>
		buf = bt_hci_cmd_create(BT_HCI_OP_LE_WRITE_LE_HOST_SUPP,
   26530:	2102      	movs	r1, #2
   26532:	f640 406d 	movw	r0, #3181	; 0xc6d
   26536:	f007 fc99 	bl	2de6c <bt_hci_cmd_create>
		if (!buf) {
   2653a:	4604      	mov	r4, r0
   2653c:	2800      	cmp	r0, #0
   2653e:	f000 80cc 	beq.w	266da <bt_init+0x302>
 *
 * @return The original tail of the buffer.
 */
static inline void *net_buf_add(struct net_buf *buf, size_t len)
{
	return net_buf_simple_add(&buf->b, len);
   26542:	2102      	movs	r1, #2
   26544:	3008      	adds	r0, #8
   26546:	f028 fc35 	bl	4edb4 <net_buf_simple_add>
		cp_le->le = 0x01;
   2654a:	2301      	movs	r3, #1
   2654c:	7003      	strb	r3, [r0, #0]
		cp_le->simul = 0x00;
   2654e:	7046      	strb	r6, [r0, #1]
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_WRITE_LE_HOST_SUPP, buf,
   26550:	4621      	mov	r1, r4
   26552:	4632      	mov	r2, r6
   26554:	f640 406d 	movw	r0, #3181	; 0xc6d
   26558:	f007 fce4 	bl	2df24 <bt_hci_cmd_send_sync>
		if (err) {
   2655c:	4604      	mov	r4, r0
   2655e:	2800      	cmp	r0, #0
   26560:	d1b2      	bne.n	264c8 <bt_init+0xf0>
	if (BT_CMD_LE_STATES(bt_dev.supported_commands)) {
   26562:	f895 3094 	ldrb.w	r3, [r5, #148]	; 0x94
   26566:	071b      	lsls	r3, r3, #28
   26568:	d512      	bpl.n	26590 <bt_init+0x1b8>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_SUPP_STATES, NULL,
   2656a:	aa01      	add	r2, sp, #4
   2656c:	2100      	movs	r1, #0
   2656e:	f242 001c 	movw	r0, #8220	; 0x201c
   26572:	f007 fcd7 	bl	2df24 <bt_hci_cmd_send_sync>
		if (err) {
   26576:	4604      	mov	r4, r0
   26578:	2800      	cmp	r0, #0
   2657a:	d1a5      	bne.n	264c8 <bt_init+0xf0>
		le_read_supp_states_complete(rsp);
   2657c:	9801      	ldr	r0, [sp, #4]
 *
 *  @return 64-bit integer in host endianness.
 */
static inline uint64_t sys_get_le64(const uint8_t src[8])
{
	return ((uint64_t)sys_get_le32(&src[4]) << 32) | sys_get_le32(&src[0]);
   2657e:	6883      	ldr	r3, [r0, #8]
   26580:	f8d3 2001 	ldr.w	r2, [r3, #1]
   26584:	f8d3 3005 	ldr.w	r3, [r3, #5]
	bt_dev.le.states = sys_get_le64(rp->le_states);
   26588:	e9c5 2336 	strd	r2, r3, [r5, #216]	; 0xd8
		net_buf_unref(rsp);
   2658c:	f01c f95c 	bl	42848 <net_buf_unref>
	if (IS_ENABLED(CONFIG_BT_CONN) &&
   26590:	f895 30d0 	ldrb.w	r3, [r5, #208]	; 0xd0
   26594:	069e      	lsls	r6, r3, #26
   26596:	d524      	bpl.n	265e2 <bt_init+0x20a>
		err = hci_le_read_max_data_len(&tx_octets, &tx_time);
   26598:	f10d 0102 	add.w	r1, sp, #2
   2659c:	4668      	mov	r0, sp
   2659e:	f024 ff91 	bl	4b4c4 <hci_le_read_max_data_len>
		if (err) {
   265a2:	4604      	mov	r4, r0
   265a4:	2800      	cmp	r0, #0
   265a6:	d18f      	bne.n	264c8 <bt_init+0xf0>
		buf = bt_hci_cmd_create(BT_HCI_OP_LE_WRITE_DEFAULT_DATA_LEN,
   265a8:	2104      	movs	r1, #4
   265aa:	f242 0024 	movw	r0, #8228	; 0x2024
   265ae:	f007 fc5d 	bl	2de6c <bt_hci_cmd_create>
		if (!buf) {
   265b2:	4606      	mov	r6, r0
   265b4:	2800      	cmp	r0, #0
   265b6:	f000 8090 	beq.w	266da <bt_init+0x302>
   265ba:	2104      	movs	r1, #4
   265bc:	3008      	adds	r0, #8
   265be:	f028 fbf9 	bl	4edb4 <net_buf_simple_add>
		cp->max_tx_octets = sys_cpu_to_le16(tx_octets);
   265c2:	f8bd 3000 	ldrh.w	r3, [sp]
   265c6:	8003      	strh	r3, [r0, #0]
		cp->max_tx_time = sys_cpu_to_le16(tx_time);
   265c8:	f8bd 3002 	ldrh.w	r3, [sp, #2]
   265cc:	8043      	strh	r3, [r0, #2]
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_WRITE_DEFAULT_DATA_LEN,
   265ce:	4622      	mov	r2, r4
   265d0:	4631      	mov	r1, r6
   265d2:	f242 0024 	movw	r0, #8228	; 0x2024
   265d6:	f007 fca5 	bl	2df24 <bt_hci_cmd_send_sync>
		if (err) {
   265da:	4604      	mov	r4, r0
   265dc:	2800      	cmp	r0, #0
   265de:	f47f af73 	bne.w	264c8 <bt_init+0xf0>
	if (BT_FEAT_LE_PRIVACY(bt_dev.le.features)) {
   265e2:	f895 30d0 	ldrb.w	r3, [r5, #208]	; 0xd0
   265e6:	065c      	lsls	r4, r3, #25
   265e8:	d510      	bpl.n	2660c <bt_init+0x234>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_RL_SIZE, NULL,
   265ea:	aa01      	add	r2, sp, #4
   265ec:	2100      	movs	r1, #0
   265ee:	f242 002a 	movw	r0, #8234	; 0x202a
   265f2:	f007 fc97 	bl	2df24 <bt_hci_cmd_send_sync>
		if (err) {
   265f6:	4604      	mov	r4, r0
   265f8:	2800      	cmp	r0, #0
   265fa:	f47f af65 	bne.w	264c8 <bt_init+0xf0>
		le_read_resolving_list_size_complete(rsp);
   265fe:	9801      	ldr	r0, [sp, #4]
	bt_dev.le.rl_size = rp->rl_size;
   26600:	6883      	ldr	r3, [r0, #8]
   26602:	785b      	ldrb	r3, [r3, #1]
   26604:	f885 3118 	strb.w	r3, [r5, #280]	; 0x118
		net_buf_unref(rsp);
   26608:	f01c f91e 	bl	42848 <net_buf_unref>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_EVENT_MASK, sizeof(*cp_mask));
   2660c:	2108      	movs	r1, #8
   2660e:	f242 0001 	movw	r0, #8193	; 0x2001
   26612:	f007 fc2b 	bl	2de6c <bt_hci_cmd_create>
	if (!buf) {
   26616:	4604      	mov	r4, r0
   26618:	2800      	cmp	r0, #0
   2661a:	d05e      	beq.n	266da <bt_init+0x302>
   2661c:	2108      	movs	r1, #8
   2661e:	4408      	add	r0, r1
   26620:	f028 fbc8 	bl	4edb4 <net_buf_simple_add>
		     BT_FEAT_LE_PRIVACY(bt_dev.le.features)) ||
   26624:	f895 10d0 	ldrb.w	r1, [r5, #208]	; 0xd0
			mask |= BT_EVT_MASK_LE_CONN_COMPLETE;
   26628:	f011 0f40 	tst.w	r1, #64	; 0x40
   2662c:	4602      	mov	r2, r0
   2662e:	f240 2302 	movw	r3, #514	; 0x202
   26632:	bf08      	it	eq
   26634:	2303      	moveq	r3, #3
		if (BT_FEAT_LE_CONN_PARAM_REQ_PROC(bt_dev.le.features)) {
   26636:	0788      	lsls	r0, r1, #30
			mask |= BT_EVT_MASK_LE_CONN_PARAM_REQ;
   26638:	bf4c      	ite	mi
   2663a:	f043 002c 	orrmi.w	r0, r3, #44	; 0x2c
		mask |= BT_EVT_MASK_LE_REMOTE_FEAT_COMPLETE;
   2663e:	f043 000c 	orrpl.w	r0, r3, #12
		if (IS_ENABLED(CONFIG_BT_DATA_LEN_UPDATE) &&
   26642:	068b      	lsls	r3, r1, #26
		if (IS_ENABLED(CONFIG_BT_PHY_UPDATE) &&
   26644:	f895 30d1 	ldrb.w	r3, [r5, #209]	; 0xd1
			mask |= BT_EVT_MASK_LE_DATA_LEN_CHANGE;
   26648:	bf48      	it	mi
   2664a:	f040 0040 	orrmi.w	r0, r0, #64	; 0x40
		if (IS_ENABLED(CONFIG_BT_PHY_UPDATE) &&
   2664e:	f013 0f09 	tst.w	r3, #9
	if (IS_ENABLED(CONFIG_BT_ECC) &&
   26652:	f895 309a 	ldrb.w	r3, [r5, #154]	; 0x9a
			mask |= BT_EVT_MASK_LE_PHY_UPDATE_COMPLETE;
   26656:	bf18      	it	ne
   26658:	f440 6000 	orrne.w	r0, r0, #2048	; 0x800
	if (IS_ENABLED(CONFIG_BT_ECC) &&
   2665c:	f003 0306 	and.w	r3, r3, #6
	if (IS_ENABLED(CONFIG_BT_SMP) &&
   26660:	07ce      	lsls	r6, r1, #31
		mask |= BT_EVT_MASK_LE_LTK_REQUEST;
   26662:	bf48      	it	mi
   26664:	f040 0010 	orrmi.w	r0, r0, #16
	if (IS_ENABLED(CONFIG_BT_ECC) &&
   26668:	2b06      	cmp	r3, #6
		mask |= BT_EVT_MASK_LE_GENERATE_DHKEY_COMPLETE;
   2666a:	bf08      	it	eq
   2666c:	f440 70c0 	orreq.w	r0, r0, #384	; 0x180
	sys_put_le64(mask, cp_mask->events);
   26670:	2100      	movs	r1, #0
   26672:	f024 fe07 	bl	4b284 <sys_put_le64>
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_EVENT_MASK, buf, NULL);
   26676:	4621      	mov	r1, r4
   26678:	2200      	movs	r2, #0
   2667a:	f242 0001 	movw	r0, #8193	; 0x2001
   2667e:	f007 fc51 	bl	2df24 <bt_hci_cmd_send_sync>
	if (err) {
   26682:	4604      	mov	r4, r0
   26684:	2800      	cmp	r0, #0
   26686:	f47f af1f 	bne.w	264c8 <bt_init+0xf0>
	if (BT_FEAT_BREDR(bt_dev.features)) {
   2668a:	f895 3074 	ldrb.w	r3, [r5, #116]	; 0x74
	if (bt_dev.le.acl_mtu) {
   2668e:	f8b5 10fc 	ldrh.w	r1, [r5, #252]	; 0xfc
	if (BT_FEAT_BREDR(bt_dev.features)) {
   26692:	0698      	lsls	r0, r3, #26
   26694:	d42e      	bmi.n	266f4 <bt_init+0x31c>
	if (bt_dev.le.acl_mtu) {
   26696:	b9c9      	cbnz	r1, 266cc <bt_init+0x2f4>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_BUFFER_SIZE, NULL, &rsp);
   26698:	aa01      	add	r2, sp, #4
   2669a:	f241 0005 	movw	r0, #4101	; 0x1005
   2669e:	f007 fc41 	bl	2df24 <bt_hci_cmd_send_sync>
	if (err) {
   266a2:	4604      	mov	r4, r0
   266a4:	2800      	cmp	r0, #0
   266a6:	f47f af0f 	bne.w	264c8 <bt_init+0xf0>
	if (bt_dev.le.acl_mtu) {
   266aa:	f8b5 30fc 	ldrh.w	r3, [r5, #252]	; 0xfc
	read_buffer_size_complete(rsp);
   266ae:	9c01      	ldr	r4, [sp, #4]
	if (bt_dev.le.acl_mtu) {
   266b0:	b94b      	cbnz	r3, 266c6 <bt_init+0x2ee>
	struct bt_hci_rp_read_buffer_size *rp = (void *)buf->data;
   266b2:	68a3      	ldr	r3, [r4, #8]
	bt_dev.le.acl_mtu = sys_le16_to_cpu(rp->acl_max_len);
   266b4:	f8b3 2001 	ldrh.w	r2, [r3, #1]
   266b8:	f8a5 20fc 	strh.w	r2, [r5, #252]	; 0xfc
	k_sem_init(&bt_dev.le.acl_pkts, pkts, pkts);
   266bc:	889a      	ldrh	r2, [r3, #4]
   266be:	480c      	ldr	r0, [pc, #48]	; (266f0 <bt_init+0x318>)
   266c0:	4611      	mov	r1, r2
   266c2:	f029 fbd9 	bl	4fe78 <z_impl_k_sem_init>
	net_buf_unref(rsp);
   266c6:	4620      	mov	r0, r4
   266c8:	f01c f8be 	bl	42848 <net_buf_unref>
	buf = bt_hci_cmd_create(BT_HCI_OP_SET_EVENT_MASK, sizeof(*ev));
   266cc:	2108      	movs	r1, #8
   266ce:	f640 4001 	movw	r0, #3073	; 0xc01
   266d2:	f007 fbcb 	bl	2de6c <bt_hci_cmd_create>
	if (!buf) {
   266d6:	4604      	mov	r4, r0
   266d8:	b988      	cbnz	r0, 266fe <bt_init+0x326>
		return -ENOBUFS;
   266da:	f06f 0468 	mvn.w	r4, #104	; 0x68
   266de:	e6f3      	b.n	264c8 <bt_init+0xf0>
   266e0:	20000030 	.word	0x20000030
   266e4:	200000a0 	.word	0x200000a0
   266e8:	200000a8 	.word	0x200000a8
   266ec:	20000100 	.word	0x20000100
   266f0:	20000130 	.word	0x20000130
	else if (!bt_dev.le.acl_mtu) {
   266f4:	2900      	cmp	r1, #0
   266f6:	d1e9      	bne.n	266cc <bt_init+0x2f4>
		return -EIO;
   266f8:	f06f 0404 	mvn.w	r4, #4
   266fc:	e6e4      	b.n	264c8 <bt_init+0xf0>
   266fe:	2108      	movs	r1, #8
   26700:	4408      	add	r0, r1
   26702:	f028 fb57 	bl	4edb4 <net_buf_simple_add>
	if (IS_ENABLED(CONFIG_BT_SMP) &&
   26706:	f895 30d0 	ldrb.w	r3, [r5, #208]	; 0xd0
   2670a:	07d9      	lsls	r1, r3, #31
   2670c:	4602      	mov	r2, r0
   2670e:	d457      	bmi.n	267c0 <bt_init+0x3e8>
		mask |= BT_EVT_MASK_REMOTE_VERSION_INFO;
   26710:	482f      	ldr	r0, [pc, #188]	; (267d0 <bt_init+0x3f8>)
   26712:	f04f 5100 	mov.w	r1, #536870912	; 0x20000000
	sys_put_le64(mask, ev->events);
   26716:	f024 fdb5 	bl	4b284 <sys_put_le64>
	return bt_hci_cmd_send_sync(BT_HCI_OP_SET_EVENT_MASK, buf, NULL);
   2671a:	4621      	mov	r1, r4
   2671c:	2200      	movs	r2, #0
   2671e:	f640 4001 	movw	r0, #3073	; 0xc01
   26722:	f007 fbff 	bl	2df24 <bt_hci_cmd_send_sync>
	if (err) {
   26726:	4604      	mov	r4, r0
   26728:	2800      	cmp	r0, #0
   2672a:	f47f aecd 	bne.w	264c8 <bt_init+0xf0>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_VERSION_INFO, NULL, &rsp);
   2672e:	4601      	mov	r1, r0
   26730:	aa01      	add	r2, sp, #4
   26732:	f64f 4001 	movw	r0, #64513	; 0xfc01
   26736:	f007 fbf5 	bl	2df24 <bt_hci_cmd_send_sync>
	if (err) {
   2673a:	4604      	mov	r4, r0
   2673c:	bb48      	cbnz	r0, 26792 <bt_init+0x3ba>
	net_buf_unref(rsp);
   2673e:	9801      	ldr	r0, [sp, #4]
   26740:	f01c f882 	bl	42848 <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_SUPPORTED_COMMANDS,
   26744:	4621      	mov	r1, r4
   26746:	aa01      	add	r2, sp, #4
   26748:	f64f 4002 	movw	r0, #64514	; 0xfc02
   2674c:	f007 fbea 	bl	2df24 <bt_hci_cmd_send_sync>
	if (err) {
   26750:	4604      	mov	r4, r0
   26752:	b9f0      	cbnz	r0, 26792 <bt_init+0x3ba>
	rp.cmds = (void *)rsp->data;
   26754:	9e01      	ldr	r6, [sp, #4]
	memcpy(bt_dev.vs_commands, rp.cmds->commands, BT_DEV_VS_CMDS_MAX);
   26756:	481f      	ldr	r0, [pc, #124]	; (267d4 <bt_init+0x3fc>)
   26758:	68b1      	ldr	r1, [r6, #8]
   2675a:	2202      	movs	r2, #2
   2675c:	3101      	adds	r1, #1
   2675e:	f024 fb8c 	bl	4ae7a <memcpy>
	net_buf_unref(rsp);
   26762:	4630      	mov	r0, r6
   26764:	f01c f870 	bl	42848 <net_buf_unref>
	if (BT_VS_CMD_SUP_FEAT(bt_dev.vs_commands)) {
   26768:	f895 30b9 	ldrb.w	r3, [r5, #185]	; 0xb9
   2676c:	075b      	lsls	r3, r3, #29
   2676e:	d510      	bpl.n	26792 <bt_init+0x3ba>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_SUPPORTED_FEATURES,
   26770:	aa01      	add	r2, sp, #4
   26772:	4621      	mov	r1, r4
   26774:	f64f 4003 	movw	r0, #64515	; 0xfc03
   26778:	f007 fbd4 	bl	2df24 <bt_hci_cmd_send_sync>
		if (err) {
   2677c:	b948      	cbnz	r0, 26792 <bt_init+0x3ba>
		rp.feat = (void *)rsp->data;
   2677e:	9c01      	ldr	r4, [sp, #4]
		memcpy(bt_dev.vs_features, rp.feat->features,
   26780:	4815      	ldr	r0, [pc, #84]	; (267d8 <bt_init+0x400>)
   26782:	68a1      	ldr	r1, [r4, #8]
   26784:	2201      	movs	r2, #1
   26786:	4411      	add	r1, r2
   26788:	f024 fb77 	bl	4ae7a <memcpy>
		net_buf_unref(rsp);
   2678c:	4620      	mov	r0, r4
   2678e:	f01c f85b 	bl	42848 <net_buf_unref>
	err = bt_id_init();
   26792:	f025 f8e2 	bl	4b95a <bt_id_init>
	if (err) {
   26796:	4604      	mov	r4, r0
   26798:	2800      	cmp	r0, #0
   2679a:	f47f ae95 	bne.w	264c8 <bt_init+0xf0>
		err = bt_conn_init();
   2679e:	f009 ffef 	bl	30780 <bt_conn_init>
		if (err) {
   267a2:	4604      	mov	r4, r0
   267a4:	2800      	cmp	r0, #0
   267a6:	f47f ae8f 	bne.w	264c8 <bt_init+0xf0>
		if (!bt_dev.id_count) {
   267aa:	79eb      	ldrb	r3, [r5, #7]
   267ac:	2b00      	cmp	r3, #0
   267ae:	f43f ae8b 	beq.w	264c8 <bt_init+0xf0>
 */
static inline void atomic_set_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);

	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
   267b2:	2108      	movs	r1, #8
   267b4:	4809      	ldr	r0, [pc, #36]	; (267dc <bt_init+0x404>)
   267b6:	f024 fca6 	bl	4b106 <atomic_or>
	bt_finalize_init();
   267ba:	f007 ff77 	bl	2e6ac <bt_finalize_init>
	return 0;
   267be:	e683      	b.n	264c8 <bt_init+0xf0>
		mask |= BT_EVT_MASK_ENCRYPT_KEY_REFRESH_COMPLETE;
   267c0:	a101      	add	r1, pc, #4	; (adr r1, 267c8 <bt_init+0x3f0>)
   267c2:	e9d1 0100 	ldrd	r0, r1, [r1]
   267c6:	e7a6      	b.n	26716 <bt_init+0x33e>
   267c8:	02008890 	.word	0x02008890
   267cc:	20008000 	.word	0x20008000
   267d0:	02008810 	.word	0x02008810
   267d4:	200000e9 	.word	0x200000e9
   267d8:	200000e8 	.word	0x200000e8
   267dc:	200000fc 	.word	0x200000fc

000267e0 <ull_drift_ticks_get>:
 * @param ticks_drift_minus[out] Negative part of drift uncertainty window
 */
void ull_drift_ticks_get(struct node_rx_event_done *done,
			 uint32_t *ticks_drift_plus,
			 uint32_t *ticks_drift_minus)
{
   267e0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}

	start_to_address_actual_us =
		done->extra.drift.start_to_address_actual_us;
	window_widening_event_us =
		done->extra.drift.window_widening_event_us;
	preamble_to_addr_us =
   267e4:	e9d0 350b 	ldrd	r3, r5, [r0, #44]	; 0x2c
	start_to_address_actual_us =
   267e8:	f8d0 8028 	ldr.w	r8, [r0, #40]	; 0x28
		done->extra.drift.preamble_to_addr_us;

	start_to_address_expected_us = EVENT_JITTER_US +
				       EVENT_TICKER_RES_MARGIN_US +
				       window_widening_event_us +
   267ec:	195c      	adds	r4, r3, r5
	start_to_address_expected_us = EVENT_JITTER_US +
   267ee:	3430      	adds	r4, #48	; 0x30
				       preamble_to_addr_us;

	if (start_to_address_actual_us <= start_to_address_expected_us) {
   267f0:	45a0      	cmp	r8, r4
{
   267f2:	460f      	mov	r7, r1
   267f4:	4616      	mov	r6, r2
	if (start_to_address_actual_us <= start_to_address_expected_us) {
   267f6:	d819      	bhi.n	2682c <ull_drift_ticks_get+0x4c>
		*ticks_drift_plus =
			HAL_TICKER_US_TO_TICKS(window_widening_event_us);
   267f8:	4d1d      	ldr	r5, [pc, #116]	; (26870 <ull_drift_ticks_get+0x90>)
   267fa:	fba3 0105 	umull	r0, r1, r3, r5
   267fe:	a31a      	add	r3, pc, #104	; (adr r3, 26868 <ull_drift_ticks_get+0x88>)
   26800:	e9d3 2300 	ldrd	r2, r3, [r3]
   26804:	f7ff fc7c 	bl	26100 <__aeabi_uldivmod>
   26808:	4603      	mov	r3, r0
		*ticks_drift_minus =
			HAL_TICKER_US_TO_TICKS((start_to_address_expected_us -
   2680a:	eba4 0008 	sub.w	r0, r4, r8
   2680e:	fba0 0105 	umull	r0, r1, r0, r5
			HAL_TICKER_US_TO_TICKS(window_widening_event_us);
   26812:	f023 447f 	bic.w	r4, r3, #4278190080	; 0xff000000
			HAL_TICKER_US_TO_TICKS((start_to_address_expected_us -
   26816:	a314      	add	r3, pc, #80	; (adr r3, 26868 <ull_drift_ticks_get+0x88>)
   26818:	e9d3 2300 	ldrd	r2, r3, [r3]
   2681c:	f7ff fc70 	bl	26100 <__aeabi_uldivmod>
   26820:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
		*ticks_drift_plus =
   26824:	603c      	str	r4, [r7, #0]
		*ticks_drift_minus =
   26826:	6030      	str	r0, [r6, #0]
		*ticks_drift_minus =
			HAL_TICKER_US_TO_TICKS(EVENT_JITTER_US +
					       EVENT_TICKER_RES_MARGIN_US +
					       preamble_to_addr_us);
	}
}
   26828:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			HAL_TICKER_US_TO_TICKS(start_to_address_actual_us);
   2682c:	f8df 9040 	ldr.w	r9, [pc, #64]	; 26870 <ull_drift_ticks_get+0x90>
   26830:	a30d      	add	r3, pc, #52	; (adr r3, 26868 <ull_drift_ticks_get+0x88>)
   26832:	e9d3 2300 	ldrd	r2, r3, [r3]
   26836:	fba8 0109 	umull	r0, r1, r8, r9
   2683a:	f7ff fc61 	bl	26100 <__aeabi_uldivmod>
   2683e:	4604      	mov	r4, r0
			HAL_TICKER_US_TO_TICKS(EVENT_JITTER_US +
   26840:	f105 0030 	add.w	r0, r5, #48	; 0x30
   26844:	a308      	add	r3, pc, #32	; (adr r3, 26868 <ull_drift_ticks_get+0x88>)
   26846:	e9d3 2300 	ldrd	r2, r3, [r3]
   2684a:	fba0 0109 	umull	r0, r1, r0, r9
   2684e:	f7ff fc57 	bl	26100 <__aeabi_uldivmod>
			HAL_TICKER_US_TO_TICKS(start_to_address_actual_us);
   26852:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
			HAL_TICKER_US_TO_TICKS(EVENT_JITTER_US +
   26856:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
		*ticks_drift_plus =
   2685a:	603c      	str	r4, [r7, #0]
		*ticks_drift_minus =
   2685c:	6030      	str	r0, [r6, #0]
}
   2685e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   26862:	bf00      	nop
   26864:	f3af 8000 	nop.w
   26868:	1afd498d 	.word	0x1afd498d
   2686c:	00000007 	.word	0x00000007
   26870:	3b9aca00 	.word	0x3b9aca00
   26874:	00000000 	.word	0x00000000

00026878 <ll_adv_enable>:
	struct ll_adv_set *adv;
	struct lll_adv *lll;
	uint8_t hci_err;
	uint32_t ret;

	if (!enable) {
   26878:	2800      	cmp	r0, #0
   2687a:	f000 81bc 	beq.w	26bf6 <ll_adv_enable+0x37e>
{
   2687e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
static inline struct ll_adv_set *is_disabled_get(uint8_t handle)
{
	struct ll_adv_set *adv;

	adv = ull_adv_set_get(handle);
	if (!adv || adv->is_enabled) {
   26882:	4d26      	ldr	r5, [pc, #152]	; (2691c <ll_adv_enable+0xa4>)
   26884:	f895 306a 	ldrb.w	r3, [r5, #106]	; 0x6a
   26888:	07d9      	lsls	r1, r3, #31
{
   2688a:	b08f      	sub	sp, #60	; 0x3c
	if (!adv || adv->is_enabled) {
   2688c:	f100 81ed 	bmi.w	26c6a <ll_adv_enable+0x3f2>
	lll_adv_pdu_enqueue(&lll->adv_data, idx);
}

static inline struct pdu_adv *lll_adv_data_peek(struct lll_adv *lll)
{
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
   26890:	f895 2029 	ldrb.w	r2, [r5, #41]	; 0x29
	lll_adv_pdu_enqueue(&lll->scan_rsp, idx);
}

static inline struct pdu_adv *lll_adv_scan_rsp_peek(struct lll_adv *lll)
{
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
   26894:	f895 3035 	ldrb.w	r3, [r5, #53]	; 0x35
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
   26898:	eb05 0282 	add.w	r2, r5, r2, lsl #2
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
   2689c:	eb05 0383 	add.w	r3, r5, r3, lsl #2
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
   268a0:	6ad7      	ldr	r7, [r2, #44]	; 0x2c
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
   268a2:	f8d3 8038 	ldr.w	r8, [r3, #56]	; 0x38
#endif /* CONFIG_BT_CTLR_ADV_EXT */
	} else {
		pdu_adv_to_update = pdu;
	}

	if (pdu_adv_to_update) {
   268a6:	b377      	cbz	r7, 26906 <ll_adv_enable+0x8e>
#if defined(CONFIG_BT_CTLR_ADV_EXT)
		} else if (ll_adv_cmds_is_ext() && pdu->tx_addr) {
			own_id_addr = adv->rnd_addr;
#endif
		} else {
			own_id_addr = ll_addr_get(pdu->tx_addr);
   268a8:	463e      	mov	r6, r7
   268aa:	f816 0b02 	ldrb.w	r0, [r6], #2
   268ae:	f3c0 1080 	ubfx	r0, r0, #6, #1
   268b2:	f00f f9d3 	bl	35c5c <ll_addr_get>
		}
	}

#if defined(CONFIG_BT_CTLR_CHECK_SAME_PEER_CONN)
	(void)memcpy(adv->own_id_addr, own_id_addr, BDADDR_SIZE);
   268b6:	2206      	movs	r2, #6
   268b8:	4601      	mov	r1, r0
			own_id_addr = ll_addr_get(pdu->tx_addr);
   268ba:	4604      	mov	r4, r0
	(void)memcpy(adv->own_id_addr, own_id_addr, BDADDR_SIZE);
   268bc:	f105 006b 	add.w	r0, r5, #107	; 0x6b
   268c0:	f024 fadb 	bl	4ae7a <memcpy>
	} else {
		tx_addr = own_id_addr;
	}

	adv_addr = adv_pdu_adva_get(pdu);
	memcpy(adv_addr, tx_addr, BDADDR_SIZE);
   268c4:	2206      	movs	r2, #6
   268c6:	4621      	mov	r1, r4
   268c8:	4630      	mov	r0, r6
   268ca:	f024 fad6 	bl	4ae7a <memcpy>
		if (pdu_adv_to_update->tx_addr &&
   268ce:	783b      	ldrb	r3, [r7, #0]
   268d0:	065a      	lsls	r2, r3, #25
   268d2:	d506      	bpl.n	268e2 <ll_adv_enable+0x6a>
		    !mem_nz((void *)adv_addr, BDADDR_SIZE)) {
   268d4:	2106      	movs	r1, #6
   268d6:	4630      	mov	r0, r6
   268d8:	f00d fe3a 	bl	34550 <mem_nz>
		if (pdu_adv_to_update->tx_addr &&
   268dc:	2800      	cmp	r0, #0
   268de:	f000 81c6 	beq.w	26c6e <ll_adv_enable+0x3f6>
			own_id_addr = ll_addr_get(pdu->tx_addr);
   268e2:	4646      	mov	r6, r8
   268e4:	f816 0b02 	ldrb.w	r0, [r6], #2
   268e8:	f3c0 1080 	ubfx	r0, r0, #6, #1
   268ec:	f00f f9b6 	bl	35c5c <ll_addr_get>
	(void)memcpy(adv->own_id_addr, own_id_addr, BDADDR_SIZE);
   268f0:	2206      	movs	r2, #6
   268f2:	4601      	mov	r1, r0
			own_id_addr = ll_addr_get(pdu->tx_addr);
   268f4:	4604      	mov	r4, r0
	(void)memcpy(adv->own_id_addr, own_id_addr, BDADDR_SIZE);
   268f6:	480a      	ldr	r0, [pc, #40]	; (26920 <ll_adv_enable+0xa8>)
   268f8:	f024 fabf 	bl	4ae7a <memcpy>
	memcpy(adv_addr, tx_addr, BDADDR_SIZE);
   268fc:	4621      	mov	r1, r4
   268fe:	4630      	mov	r0, r6
   26900:	2206      	movs	r2, #6
   26902:	f024 faba 	bl	4ae7a <memcpy>
	if ((pdu_adv->type == PDU_ADV_TYPE_ADV_IND) ||
   26906:	783b      	ldrb	r3, [r7, #0]
   26908:	f013 0f0e 	tst.w	r3, #14
   2690c:	f040 810c 	bne.w	26b28 <ll_adv_enable+0x2b0>
		if (lll->conn) {
   26910:	6a2b      	ldr	r3, [r5, #32]
   26912:	b13b      	cbz	r3, 26924 <ll_adv_enable+0xac>
	return BT_HCI_ERR_CMD_DISALLOWED;
   26914:	200c      	movs	r0, #12
}
   26916:	b00f      	add	sp, #60	; 0x3c
   26918:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2691c:	20005174 	.word	0x20005174
   26920:	200051df 	.word	0x200051df
		link = ll_rx_link_alloc();
   26924:	f011 fa16 	bl	37d54 <ll_rx_link_alloc>
		if (!link) {
   26928:	4681      	mov	r9, r0
   2692a:	2800      	cmp	r0, #0
   2692c:	f000 81ac 	beq.w	26c88 <ll_adv_enable+0x410>
		node_rx = ll_rx_alloc();
   26930:	f011 fa1c 	bl	37d6c <ll_rx_alloc>
		if (!node_rx) {
   26934:	4682      	mov	sl, r0
   26936:	2800      	cmp	r0, #0
   26938:	f000 81a3 	beq.w	26c82 <ll_adv_enable+0x40a>
		conn = ll_conn_acquire();
   2693c:	f013 fbba 	bl	3a0b4 <ll_conn_acquire>
		if (!conn) {
   26940:	4604      	mov	r4, r0
   26942:	2800      	cmp	r0, #0
   26944:	f000 81a2 	beq.w	26c8c <ll_adv_enable+0x414>
		conn_lll->handle = 0xFFFF;
   26948:	f64f 73ff 	movw	r3, #65535	; 0xffff
		if (!conn_lll->link_tx_free) {
   2694c:	6f40      	ldr	r0, [r0, #116]	; 0x74
		conn_lll->handle = 0xFFFF;
   2694e:	8523      	strh	r3, [r4, #40]	; 0x28
		conn_lll = &conn->lll;
   26950:	f104 031c 	add.w	r3, r4, #28
   26954:	930b      	str	r3, [sp, #44]	; 0x2c
		if (!conn_lll->link_tx_free) {
   26956:	2800      	cmp	r0, #0
   26958:	f000 818f 	beq.w	26c7a <ll_adv_enable+0x402>
		memq_init(conn_lll->link_tx_free, &conn_lll->memq_tx.head,
   2695c:	f104 0268 	add.w	r2, r4, #104	; 0x68
   26960:	f104 0164 	add.w	r1, r4, #100	; 0x64
   26964:	f00d fe00 	bl	34568 <memq_init>
			conn_lll->phy_tx = PHY_1M;
   26968:	f8b4 3060 	ldrh.w	r3, [r4, #96]	; 0x60
		conn_lll->sn = 0;
   2696c:	f894 207a 	ldrb.w	r2, [r4, #122]	; 0x7a
		conn->own_id_addr_type = BT_ADDR_LE_NONE->type;
   26970:	f8df b334 	ldr.w	fp, [pc, #820]	; 26ca8 <ll_adv_enable+0x430>
			conn_lll->phy_tx = PHY_1M;
   26974:	f423 63ef 	bic.w	r3, r3, #1912	; 0x778
   26978:	f023 0307 	bic.w	r3, r3, #7
   2697c:	f443 7388 	orr.w	r3, r3, #272	; 0x110
   26980:	f043 0301 	orr.w	r3, r3, #1
   26984:	f8a4 3060 	strh.w	r3, [r4, #96]	; 0x60
		conn_lll->data_chan_sel = 0;
   26988:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
		conn_lll->sn = 0;
   2698c:	f022 0207 	bic.w	r2, r2, #7
		conn->own_id_addr_type = BT_ADDR_LE_NONE->type;
   26990:	4659      	mov	r1, fp
		conn_lll->sn = 0;
   26992:	f884 207a 	strb.w	r2, [r4, #122]	; 0x7a
		conn_lll->data_chan_sel = 0;
   26996:	f003 033f 	and.w	r3, r3, #63	; 0x3f
		conn_lll->periph.initiated = 0;
   2699a:	f894 203c 	ldrb.w	r2, [r4, #60]	; 0x3c
		conn_lll->data_chan_sel = 0;
   2699e:	f063 037f 	orn	r3, r3, #127	; 0x7f
   269a2:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
		conn_lll->periph.initiated = 0;
   269a6:	f022 0207 	bic.w	r2, r2, #7
		conn->own_id_addr_type = BT_ADDR_LE_NONE->type;
   269aa:	f811 3b01 	ldrb.w	r3, [r1], #1
		conn_lll->periph.initiated = 0;
   269ae:	f884 203c 	strb.w	r2, [r4, #60]	; 0x3c
		conn->own_id_addr_type = BT_ADDR_LE_NONE->type;
   269b2:	f894 20d6 	ldrb.w	r2, [r4, #214]	; 0xd6
   269b6:	f003 0301 	and.w	r3, r3, #1
   269ba:	f363 0200 	bfi	r2, r3, #0, #1
   269be:	930b      	str	r3, [sp, #44]	; 0x2c
		conn_lll->max_tx_octets = PDU_DC_PAYLOAD_SIZE_MIN;
   269c0:	4bba      	ldr	r3, [pc, #744]	; (26cac <ll_adv_enable+0x434>)
		conn->own_id_addr_type = BT_ADDR_LE_NONE->type;
   269c2:	f884 20d6 	strb.w	r2, [r4, #214]	; 0xd6
		conn_lll->link_tx_free = NULL;
   269c6:	2600      	movs	r6, #0
		conn->connect_expire = 6;
   269c8:	2206      	movs	r2, #6
		conn_lll->max_tx_octets = PDU_DC_PAYLOAD_SIZE_MIN;
   269ca:	f04f 101b 	mov.w	r0, #1769499	; 0x1b001b
   269ce:	e9c4 0316 	strd	r0, r3, [r4, #88]	; 0x58
		conn->connect_expire = 6;
   269d2:	f8a4 20c0 	strh.w	r2, [r4, #192]	; 0xc0
		conn_lll->periph.window_widening_event_us = 0;
   269d6:	e9c4 6612 	strd	r6, r6, [r4, #72]	; 0x48
		conn_lll->link_tx_free = NULL;
   269da:	6766      	str	r6, [r4, #116]	; 0x74
		conn_lll->packet_tx_head_len = 0;
   269dc:	f8a4 6078 	strh.w	r6, [r4, #120]	; 0x78
		conn_lll->event_counter = 0;
   269e0:	8666      	strh	r6, [r4, #50]	; 0x32
		conn_lll->latency_prepare = 0;
   269e2:	f8c4 602e 	str.w	r6, [r4, #46]	; 0x2e
		conn_lll->data_chan_use = 0;
   269e6:	f884 603b 	strb.w	r6, [r4, #59]	; 0x3b
		conn_lll->periph.window_size_prepare_us = 0;
   269ea:	6526      	str	r6, [r4, #80]	; 0x50
		conn->supervision_expire = 0;
   269ec:	f8a4 60c4 	strh.w	r6, [r4, #196]	; 0xc4
		conn->procedure_expire = 0;
   269f0:	f8a4 60c8 	strh.w	r6, [r4, #200]	; 0xc8
		conn->apto_expire = 0U;
   269f4:	f8a4 60d0 	strh.w	r6, [r4, #208]	; 0xd0
		conn->appto_expire = 0U;
   269f8:	f8a4 60cc 	strh.w	r6, [r4, #204]	; 0xcc
		(void)memcpy(conn->own_id_addr, BT_ADDR_LE_NONE->a.val,
   269fc:	f104 00d7 	add.w	r0, r4, #215	; 0xd7
   26a00:	f024 fa3b 	bl	4ae7a <memcpy>
		conn->peer_id_addr_type = BT_ADDR_LE_NONE->type;
   26a04:	f894 00d6 	ldrb.w	r0, [r4, #214]	; 0xd6
   26a08:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   26a0a:	f363 0041 	bfi	r0, r3, #1, #1
		(void)memcpy(conn->peer_id_addr, BT_ADDR_LE_NONE->a.val,
   26a0e:	2206      	movs	r2, #6
   26a10:	f10b 0101 	add.w	r1, fp, #1
		conn->peer_id_addr_type = BT_ADDR_LE_NONE->type;
   26a14:	f884 00d6 	strb.w	r0, [r4, #214]	; 0xd6
		(void)memcpy(conn->peer_id_addr, BT_ADDR_LE_NONE->a.val,
   26a18:	f104 00dd 	add.w	r0, r4, #221	; 0xdd
   26a1c:	f024 fa2d 	bl	4ae7a <memcpy>
		conn->common.fex_valid = 0;
   26a20:	f894 30e4 	ldrb.w	r3, [r4, #228]	; 0xe4
		conn->llcp_req = conn->llcp_ack = conn->llcp_type = 0;
   26a24:	f884 60f2 	strb.w	r6, [r4, #242]	; 0xf2
		conn->common.fex_valid = 0;
   26a28:	f023 0307 	bic.w	r3, r3, #7
   26a2c:	f884 30e4 	strb.w	r3, [r4, #228]	; 0xe4
		conn->llcp_cu.pause_tx = 0U;
   26a30:	f894 311a 	ldrb.w	r3, [r4, #282]	; 0x11a
		conn->llcp_req = conn->llcp_ack = conn->llcp_type = 0;
   26a34:	f8a4 60f0 	strh.w	r6, [r4, #240]	; 0xf0
		conn->llcp_cu.pause_tx = 0U;
   26a38:	f366 1304 	bfi	r3, r6, #4, #1
   26a3c:	f884 311a 	strb.w	r3, [r4, #282]	; 0x11a
		conn->llcp_rx = NULL;
   26a40:	f8c4 6114 	str.w	r6, [r4, #276]	; 0x114
		conn->llcp_cu.req = conn->llcp_cu.ack = 0;
   26a44:	f8a4 6118 	strh.w	r6, [r4, #280]	; 0x118
		conn->llcp_feature.req = conn->llcp_feature.ack = 0;
   26a48:	f8a4 6130 	strh.w	r6, [r4, #304]	; 0x130
		conn->llcp_feature.features_conn = ll_feat_get();
   26a4c:	f010 fcc2 	bl	373d4 <ll_feat_get>
		conn->llcp_version.tx = conn->llcp_version.rx = 0;
   26a50:	f894 314a 	ldrb.w	r3, [r4, #330]	; 0x14a
		conn->llcp_version.req = conn->llcp_version.ack = 0;
   26a54:	f8a4 6148 	strh.w	r6, [r4, #328]	; 0x148
		conn->llcp_version.tx = conn->llcp_version.rx = 0;
   26a58:	f023 0303 	bic.w	r3, r3, #3
   26a5c:	f884 314a 	strb.w	r3, [r4, #330]	; 0x14a
		conn_lll->enc_rx = conn_lll->enc_tx = 0U;
   26a60:	f894 307a 	ldrb.w	r3, [r4, #122]	; 0x7a
		conn->llcp_terminate.req = conn->llcp_terminate.ack = 0;
   26a64:	f8a4 6150 	strh.w	r6, [r4, #336]	; 0x150
		conn_lll->enc_rx = conn_lll->enc_tx = 0U;
   26a68:	f023 0318 	bic.w	r3, r3, #24
   26a6c:	f884 307a 	strb.w	r3, [r4, #122]	; 0x7a
		conn->llcp_enc.pause_tx = conn->llcp_enc.pause_rx = 0U;
   26a70:	f894 3176 	ldrb.w	r3, [r4, #374]	; 0x176
		conn->llcp_terminate.reason_final = 0;
   26a74:	f884 6153 	strb.w	r6, [r4, #339]	; 0x153
		conn->llcp_enc.pause_tx = conn->llcp_enc.pause_rx = 0U;
   26a78:	f023 0307 	bic.w	r3, r3, #7
   26a7c:	f884 3176 	strb.w	r3, [r4, #374]	; 0x176
		conn->llcp_conn_param.disabled = 0U;
   26a80:	f894 3196 	ldrb.w	r3, [r4, #406]	; 0x196
		conn->llcp_terminate.node_rx.hdr.link = link;
   26a84:	f8c4 9154 	str.w	r9, [r4, #340]	; 0x154
		conn->llcp_conn_param.disabled = 0U;
   26a88:	f366 1386 	bfi	r3, r6, #6, #1
   26a8c:	f884 3196 	strb.w	r3, [r4, #406]	; 0x196
		conn->llcp_length.disabled = 0U;
   26a90:	f894 31c6 	ldrb.w	r3, [r4, #454]	; 0x1c6
		conn->llcp_enc.req = conn->llcp_enc.ack = 0U;
   26a94:	f8a4 6174 	strh.w	r6, [r4, #372]	; 0x174
		conn->llcp_length.disabled = 0U;
   26a98:	f366 03c3 	bfi	r3, r6, #3, #1
		conn->llcp_feature.features_peer = 0;
   26a9c:	2200      	movs	r2, #0
		conn->llcp_length.disabled = 0U;
   26a9e:	f884 31c6 	strb.w	r3, [r4, #454]	; 0x1c6
		conn->llcp_feature.features_peer = 0;
   26aa2:	2300      	movs	r3, #0
		conn->llcp_feature.features_conn = ll_feat_get();
   26aa4:	e9c4 014e 	strd	r0, r1, [r4, #312]	; 0x138
		conn->llcp_feature.features_peer = 0;
   26aa8:	e9c4 2350 	strd	r2, r3, [r4, #320]	; 0x140
		conn->periph.llcp_type = 0U;
   26aac:	f884 60e5 	strb.w	r6, [r4, #229]	; 0xe5
		conn->llcp_conn_param.req = 0U;
   26ab0:	f8a4 6194 	strh.w	r6, [r4, #404]	; 0x194
		conn->llcp_conn_param.cache.timeout = 0U;
   26ab4:	f8a4 61a6 	strh.w	r6, [r4, #422]	; 0x1a6
		conn->periph.ticks_to_offset = 0U;
   26ab8:	f8c4 60ec 	str.w	r6, [r4, #236]	; 0xec
		conn->llcp_length.req = conn->llcp_length.ack = 0U;
   26abc:	f8a4 61c4 	strh.w	r6, [r4, #452]	; 0x1c4
		conn->llcp_length.cache.tx_octets = 0U;
   26ac0:	f8a4 61d0 	strh.w	r6, [r4, #464]	; 0x1d0
		conn->default_tx_octets = ull_conn_default_tx_octets_get();
   26ac4:	f013 fe5e 	bl	3a784 <ull_conn_default_tx_octets_get>
   26ac8:	f8a4 00d2 	strh.w	r0, [r4, #210]	; 0xd2
		conn->default_tx_time = ull_conn_default_tx_time_get();
   26acc:	f013 fe60 	bl	3a790 <ull_conn_default_tx_time_get>
		conn->llcp_phy.req = conn->llcp_phy.ack = 0;
   26ad0:	f8d4 21d4 	ldr.w	r2, [r4, #468]	; 0x1d4
   26ad4:	4b76      	ldr	r3, [pc, #472]	; (26cb0 <ll_adv_enable+0x438>)
		conn->default_tx_time = ull_conn_default_tx_time_get();
   26ad6:	f8a4 00d4 	strh.w	r0, [r4, #212]	; 0xd4
		conn->llcp_phy.req = conn->llcp_phy.ack = 0;
   26ada:	4013      	ands	r3, r2
   26adc:	f8c4 31d4 	str.w	r3, [r4, #468]	; 0x1d4
		conn->phy_pref_tx = ull_conn_default_phy_tx_get();
   26ae0:	f013 fe5c 	bl	3a79c <ull_conn_default_phy_tx_get>
   26ae4:	f894 31d8 	ldrb.w	r3, [r4, #472]	; 0x1d8
   26ae8:	f360 0302 	bfi	r3, r0, #0, #3
   26aec:	f884 31d8 	strb.w	r3, [r4, #472]	; 0x1d8
		conn->phy_pref_rx = ull_conn_default_phy_rx_get();
   26af0:	f013 fe5a 	bl	3a7a8 <ull_conn_default_phy_rx_get>
		lll->conn = conn_lll;
   26af4:	f104 031c 	add.w	r3, r4, #28
   26af8:	622b      	str	r3, [r5, #32]
		conn->phy_pref_rx = ull_conn_default_phy_rx_get();
   26afa:	f894 31d8 	ldrb.w	r3, [r4, #472]	; 0x1d8
		conn->tx_head = conn->tx_ctrl = conn->tx_ctrl_last =
   26afe:	f8c4 61dc 	str.w	r6, [r4, #476]	; 0x1dc
		conn->phy_pref_rx = ull_conn_default_phy_rx_get();
   26b02:	f360 03c5 	bfi	r3, r0, #3, #3
		adv->node_rx_cc_free = node_rx;
   26b06:	e9c5 9a18 	strd	r9, sl, [r5, #96]	; 0x60
		conn->tx_data = conn->tx_data_last = 0;
   26b0a:	e9c4 667a 	strd	r6, r6, [r4, #488]	; 0x1e8
		conn->tx_head = conn->tx_ctrl = conn->tx_ctrl_last =
   26b0e:	e9c4 6678 	strd	r6, r6, [r4, #480]	; 0x1e0
}

static inline void ull_hdr_init(struct ull_hdr *hdr)
{
	hdr->ref = 0U;
	hdr->disabled_cb = hdr->disabled_param = NULL;
   26b12:	e9c4 6605 	strd	r6, r6, [r4, #20]
	hdr->ref = 0U;
   26b16:	7026      	strb	r6, [r4, #0]

static inline void lll_hdr_init(void *lll, void *parent)
{
	struct lll_hdr *hdr = lll;

	hdr->parent = parent;
   26b18:	61e4      	str	r4, [r4, #28]
		conn->phy_pref_rx = ull_conn_default_phy_rx_get();
   26b1a:	f884 31d8 	strb.w	r3, [r4, #472]	; 0x1d8
		err = lll_clock_wait();
   26b1e:	f019 f843 	bl	3fba8 <lll_clock_wait>
		if (err) {
   26b22:	2800      	cmp	r0, #0
   26b24:	f040 80a5 	bne.w	26c72 <ll_adv_enable+0x3fa>
	uint8_t ch_map = lll->chan_map;
   26b28:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
	const uint8_t adv_chn_cnt = util_ones_count_get(&ch_map, sizeof(ch_map));
   26b2c:	2101      	movs	r1, #1
	uint8_t ch_map = lll->chan_map;
   26b2e:	f3c3 0342 	ubfx	r3, r3, #1, #3
	const uint8_t adv_chn_cnt = util_ones_count_get(&ch_map, sizeof(ch_map));
   26b32:	f10d 0033 	add.w	r0, sp, #51	; 0x33
	uint8_t ch_map = lll->chan_map;
   26b36:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
	const uint8_t adv_chn_cnt = util_ones_count_get(&ch_map, sizeof(ch_map));
   26b3a:	f00d fe9f 	bl	3487c <util_ones_count_get>
	if (adv_chn_cnt == 0) {
   26b3e:	4602      	mov	r2, r0
   26b40:	2800      	cmp	r0, #0
   26b42:	d05a      	beq.n	26bfa <ll_adv_enable+0x382>
	uint16_t time_us = adv_time_get(pdu_adv, pdu_scan, adv_chn_cnt, phy,
   26b44:	f898 1001 	ldrb.w	r1, [r8, #1]
   26b48:	4638      	mov	r0, r7
   26b4a:	f012 f843 	bl	38bd4 <adv_time_get.constprop.0.isra.0>
	adv->ull.ticks_slot = HAL_TICKER_US_TO_TICKS(time_us);
   26b4e:	4959      	ldr	r1, [pc, #356]	; (26cb4 <ll_adv_enable+0x43c>)
	uint16_t interval = adv->interval;
   26b50:	f8b5 6068 	ldrh.w	r6, [r5, #104]	; 0x68
   26b54:	2400      	movs	r4, #0
	adv->ull.ticks_prepare_to_start =
   26b56:	2331      	movs	r3, #49	; 0x31
   26b58:	60ab      	str	r3, [r5, #8]
	hdr->disabled_cb = hdr->disabled_param = NULL;
   26b5a:	e9c5 4405 	strd	r4, r4, [r5, #20]
	adv->ull.ticks_slot = HAL_TICKER_US_TO_TICKS(time_us);
   26b5e:	a350      	add	r3, pc, #320	; (adr r3, 26ca0 <ll_adv_enable+0x428>)
   26b60:	e9d3 2300 	ldrd	r2, r3, [r3]
	hdr->ref = 0U;
   26b64:	702c      	strb	r4, [r5, #0]
	adv->ull.ticks_active_to_start = 0;
   26b66:	606c      	str	r4, [r5, #4]
	adv->ull.ticks_preempt_to_start =
   26b68:	60ec      	str	r4, [r5, #12]
	adv->ull.ticks_slot = HAL_TICKER_US_TO_TICKS(time_us);
   26b6a:	fba0 0101 	umull	r0, r1, r0, r1
   26b6e:	f7ff fac7 	bl	26100 <__aeabi_uldivmod>
   26b72:	6128      	str	r0, [r5, #16]
	ticks_anchor = ticker_ticks_now_get();
   26b74:	f00f f842 	bl	35bfc <ticker_ticks_now_get>
   26b78:	4680      	mov	r8, r0
	lll->is_hdcd = !interval && (pdu_adv->type == PDU_ADV_TYPE_DIRECT_IND);
   26b7a:	b93e      	cbnz	r6, 26b8c <ll_adv_enable+0x314>
   26b7c:	783c      	ldrb	r4, [r7, #0]
   26b7e:	f004 040f 	and.w	r4, r4, #15
   26b82:	f1a4 0401 	sub.w	r4, r4, #1
   26b86:	fab4 f484 	clz	r4, r4
   26b8a:	0964      	lsrs	r4, r4, #5
   26b8c:	f895 0024 	ldrb.w	r0, [r5, #36]	; 0x24
				   (adv->ull.ticks_slot + ticks_slot_overhead),
   26b90:	692b      	ldr	r3, [r5, #16]
	lll->is_hdcd = !interval && (pdu_adv->type == PDU_ADV_TYPE_DIRECT_IND);
   26b92:	f364 0000 	bfi	r0, r4, #0, #1
	if (lll->is_hdcd) {
   26b96:	f010 0401 	ands.w	r4, r0, #1
	lll->is_hdcd = !interval && (pdu_adv->type == PDU_ADV_TYPE_DIRECT_IND);
   26b9a:	f885 0024 	strb.w	r0, [r5, #36]	; 0x24
	if (lll->is_hdcd) {
   26b9e:	d033      	beq.n	26c08 <ll_adv_enable+0x390>
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
   26ba0:	2000      	movs	r0, #0
   26ba2:	4a45      	ldr	r2, [pc, #276]	; (26cb8 <ll_adv_enable+0x440>)
   26ba4:	4f45      	ldr	r7, [pc, #276]	; (26cbc <ll_adv_enable+0x444>)
   26ba6:	9304      	str	r3, [sp, #16]
		ret_cb = TICKER_STATUS_BUSY;
   26ba8:	2402      	movs	r4, #2
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
   26baa:	ae0d      	add	r6, sp, #52	; 0x34
   26bac:	9301      	str	r3, [sp, #4]
   26bae:	9205      	str	r2, [sp, #20]
   26bb0:	2103      	movs	r1, #3
   26bb2:	e9cd 0002 	strd	r0, r0, [sp, #8]
   26bb6:	9608      	str	r6, [sp, #32]
   26bb8:	9506      	str	r5, [sp, #24]
   26bba:	4643      	mov	r3, r8
   26bbc:	9000      	str	r0, [sp, #0]
   26bbe:	9707      	str	r7, [sp, #28]
   26bc0:	4622      	mov	r2, r4
		ret_cb = TICKER_STATUS_BUSY;
   26bc2:	940d      	str	r4, [sp, #52]	; 0x34
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
   26bc4:	f00e feee 	bl	359a4 <ticker_start>
		ret = ull_ticker_status_take(ret, &ret_cb);
   26bc8:	4631      	mov	r1, r6
   26bca:	f011 f97b 	bl	37ec4 <ull_ticker_status_take>
		if (ret != TICKER_STATUS_SUCCESS) {
   26bce:	b9a0      	cbnz	r0, 26bfa <ll_adv_enable+0x382>
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
   26bd0:	493b      	ldr	r1, [pc, #236]	; (26cc0 <ll_adv_enable+0x448>)
   26bd2:	9105      	str	r1, [sp, #20]
   26bd4:	f24a 33d8 	movw	r3, #41944	; 0xa3d8
   26bd8:	9300      	str	r3, [sp, #0]
   26bda:	e9cd 0003 	strd	r0, r0, [sp, #12]
   26bde:	e9cd 0001 	strd	r0, r0, [sp, #4]
   26be2:	9707      	str	r7, [sp, #28]
   26be4:	9608      	str	r6, [sp, #32]
   26be6:	9506      	str	r5, [sp, #24]
   26be8:	4643      	mov	r3, r8
   26bea:	2201      	movs	r2, #1
   26bec:	2103      	movs	r1, #3
		ret_cb = TICKER_STATUS_BUSY;
   26bee:	940d      	str	r4, [sp, #52]	; 0x34
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
   26bf0:	f00e fed8 	bl	359a4 <ticker_start>
   26bf4:	e02e      	b.n	26c54 <ll_adv_enable+0x3dc>
		return disable(handle);
   26bf6:	f011 bf3f 	b.w	38a78 <disable.constprop.0>
	if (adv->lll.conn) {
   26bfa:	6a2b      	ldr	r3, [r5, #32]
   26bfc:	2b00      	cmp	r3, #0
   26bfe:	f43f ae89 	beq.w	26914 <ll_adv_enable+0x9c>
		conn_release(adv);
   26c02:	f011 fef7 	bl	389f4 <conn_release.constprop.0>
   26c06:	e685      	b.n	26914 <ll_adv_enable+0x9c>
		ll_adv_ticker_ext[handle].ticks_slot_window =
   26c08:	4a2e      	ldr	r2, [pc, #184]	; (26cc4 <ll_adv_enable+0x44c>)
				   HAL_TICKER_US_TO_TICKS((uint64_t)interval *
   26c0a:	482f      	ldr	r0, [pc, #188]	; (26cc8 <ll_adv_enable+0x450>)
		ret = ticker_start_ext(
   26c0c:	9304      	str	r3, [sp, #16]
			ULL_ADV_RANDOM_DELAY + ticks_slot;
   26c0e:	f203 1347 	addw	r3, r3, #327	; 0x147
		ret = ticker_start_ext(
   26c12:	9506      	str	r5, [sp, #24]
   26c14:	9402      	str	r4, [sp, #8]
				   HAL_TICKER_US_TO_TICKS((uint64_t)interval *
   26c16:	2191      	movs	r1, #145	; 0x91
		ll_adv_ticker_ext[handle].ticks_slot_window =
   26c18:	6013      	str	r3, [r2, #0]
				   HAL_TICKER_US_TO_TICKS((uint64_t)interval *
   26c1a:	fba6 0300 	umull	r0, r3, r6, r0
   26c1e:	fb01 3106 	mla	r1, r1, r6, r3
		ret = ticker_start_ext(
   26c22:	4b26      	ldr	r3, [pc, #152]	; (26cbc <ll_adv_enable+0x444>)
   26c24:	9307      	str	r3, [sp, #28]
   26c26:	4b24      	ldr	r3, [pc, #144]	; (26cb8 <ll_adv_enable+0x440>)
   26c28:	9305      	str	r3, [sp, #20]
   26c2a:	f64f 73ff 	movw	r3, #65535	; 0xffff
   26c2e:	9209      	str	r2, [sp, #36]	; 0x24
		ret_cb = TICKER_STATUS_BUSY;
   26c30:	2702      	movs	r7, #2
		ret = ticker_start_ext(
   26c32:	9303      	str	r3, [sp, #12]
   26c34:	ae0d      	add	r6, sp, #52	; 0x34
				   HAL_TICKER_US_TO_TICKS((uint64_t)interval *
   26c36:	a31a      	add	r3, pc, #104	; (adr r3, 26ca0 <ll_adv_enable+0x428>)
   26c38:	e9d3 2300 	ldrd	r2, r3, [r3]
		ret_cb = TICKER_STATUS_BUSY;
   26c3c:	970d      	str	r7, [sp, #52]	; 0x34
		ret = ticker_start_ext(
   26c3e:	9608      	str	r6, [sp, #32]
				   HAL_TICKER_US_TO_TICKS((uint64_t)interval *
   26c40:	f7ff fa5e 	bl	26100 <__aeabi_uldivmod>
		ret = ticker_start_ext(
   26c44:	4643      	mov	r3, r8
   26c46:	e9cd 4000 	strd	r4, r0, [sp]
   26c4a:	463a      	mov	r2, r7
   26c4c:	4620      	mov	r0, r4
   26c4e:	2103      	movs	r1, #3
   26c50:	f00e fe52 	bl	358f8 <ticker_start_ext>
	ret = ull_ticker_status_take(ret, &ret_cb);
   26c54:	4631      	mov	r1, r6
   26c56:	f011 f935 	bl	37ec4 <ull_ticker_status_take>
	if (ret != TICKER_STATUS_SUCCESS) {
   26c5a:	2800      	cmp	r0, #0
   26c5c:	d1cd      	bne.n	26bfa <ll_adv_enable+0x382>
	adv->is_enabled = 1;
   26c5e:	f895 306a 	ldrb.w	r3, [r5, #106]	; 0x6a
   26c62:	f043 0301 	orr.w	r3, r3, #1
   26c66:	f885 306a 	strb.w	r3, [r5, #106]	; 0x6a
			return 0;
   26c6a:	2000      	movs	r0, #0
   26c6c:	e653      	b.n	26916 <ll_adv_enable+0x9e>
			return BT_HCI_ERR_INVALID_PARAM;
   26c6e:	2012      	movs	r0, #18
   26c70:	e651      	b.n	26916 <ll_adv_enable+0x9e>
			conn_release(adv);
   26c72:	f011 febf 	bl	389f4 <conn_release.constprop.0>
			return BT_HCI_ERR_HW_FAILURE;
   26c76:	2003      	movs	r0, #3
   26c78:	e64d      	b.n	26916 <ll_adv_enable+0x9e>
			conn_lll->link_tx_free = &conn_lll->link_tx;
   26c7a:	f104 006c 	add.w	r0, r4, #108	; 0x6c
   26c7e:	6760      	str	r0, [r4, #116]	; 0x74
   26c80:	e66c      	b.n	2695c <ll_adv_enable+0xe4>
			ll_rx_link_release(link);
   26c82:	4648      	mov	r0, r9
   26c84:	f011 f86c 	bl	37d60 <ll_rx_link_release>
			return BT_HCI_ERR_MEM_CAPACITY_EXCEEDED;
   26c88:	2007      	movs	r0, #7
   26c8a:	e644      	b.n	26916 <ll_adv_enable+0x9e>
			ll_rx_release(node_rx);
   26c8c:	4650      	mov	r0, sl
   26c8e:	f011 f873 	bl	37d78 <ll_rx_release>
			ll_rx_link_release(link);
   26c92:	4648      	mov	r0, r9
   26c94:	f011 f864 	bl	37d60 <ll_rx_link_release>
			return BT_HCI_ERR_MEM_CAPACITY_EXCEEDED;
   26c98:	e7f6      	b.n	26c88 <ll_adv_enable+0x410>
   26c9a:	bf00      	nop
   26c9c:	f3af 8000 	nop.w
   26ca0:	1afd498d 	.word	0x1afd498d
   26ca4:	00000007 	.word	0x00000007
   26ca8:	00053510 	.word	0x00053510
   26cac:	01480148 	.word	0x01480148
   26cb0:	f6ff0000 	.word	0xf6ff0000
   26cb4:	3b9aca00 	.word	0x3b9aca00
   26cb8:	00038c45 	.word	0x00038c45
   26cbc:	000374a1 	.word	0x000374a1
   26cc0:	00038795 	.word	0x00038795
   26cc4:	20005168 	.word	0x20005168
   26cc8:	84e72a00 	.word	0x84e72a00
   26ccc:	00000000 	.word	0x00000000

00026cd0 <ull_adv_time_update>:
{
   26cd0:	b570      	push	{r4, r5, r6, lr}
	chan_map = lll->chan_map;
   26cd2:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
{
   26cd6:	b08a      	sub	sp, #40	; 0x28
	chan_map = lll->chan_map;
   26cd8:	f3c3 0342 	ubfx	r3, r3, #1, #3
{
   26cdc:	460d      	mov	r5, r1
   26cde:	4604      	mov	r4, r0
	chan_cnt = util_ones_count_get(&chan_map, sizeof(chan_map));
   26ce0:	2101      	movs	r1, #1
   26ce2:	f10d 0023 	add.w	r0, sp, #35	; 0x23
{
   26ce6:	4616      	mov	r6, r2
	chan_map = lll->chan_map;
   26ce8:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
	chan_cnt = util_ones_count_get(&chan_map, sizeof(chan_map));
   26cec:	f00d fdc6 	bl	3487c <util_ones_count_get>
	time_us = adv_time_get(pdu, pdu_scan, chan_cnt, phy, phy_flags);
   26cf0:	7871      	ldrb	r1, [r6, #1]
	chan_cnt = util_ones_count_get(&chan_map, sizeof(chan_map));
   26cf2:	4602      	mov	r2, r0
	time_us = adv_time_get(pdu, pdu_scan, chan_cnt, phy, phy_flags);
   26cf4:	4628      	mov	r0, r5
   26cf6:	f011 ff6d 	bl	38bd4 <adv_time_get.constprop.0.isra.0>
	time_ticks = HAL_TICKER_US_TO_TICKS(time_us);
   26cfa:	491d      	ldr	r1, [pc, #116]	; (26d70 <ull_adv_time_update+0xa0>)
   26cfc:	a31a      	add	r3, pc, #104	; (adr r3, 26d68 <ull_adv_time_update+0x98>)
   26cfe:	e9d3 2300 	ldrd	r2, r3, [r3]
   26d02:	fba0 0101 	umull	r0, r1, r0, r1
   26d06:	f7ff f9fb 	bl	26100 <__aeabi_uldivmod>
	if (adv->ull.ticks_slot > time_ticks) {
   26d0a:	6923      	ldr	r3, [r4, #16]
   26d0c:	4298      	cmp	r0, r3
	time_ticks = HAL_TICKER_US_TO_TICKS(time_us);
   26d0e:	4605      	mov	r5, r0
	if (adv->ull.ticks_slot > time_ticks) {
   26d10:	d221      	bcs.n	26d56 <ull_adv_time_update+0x86>
		ticks_minus = adv->ull.ticks_slot - time_ticks;
   26d12:	1a1b      	subs	r3, r3, r0
		ticks_plus = 0U;
   26d14:	2200      	movs	r2, #0
	ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
   26d16:	9201      	str	r2, [sp, #4]
	return ((uint8_t *)adv - (uint8_t *)ll_adv) / sizeof(*adv);
   26d18:	4a16      	ldr	r2, [pc, #88]	; (26d74 <ull_adv_time_update+0xa4>)
	ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
   26d1a:	9302      	str	r3, [sp, #8]
	return ((uint8_t *)adv - (uint8_t *)ll_adv) / sizeof(*adv);
   26d1c:	4b16      	ldr	r3, [pc, #88]	; (26d78 <ull_adv_time_update+0xa8>)
   26d1e:	1aa2      	subs	r2, r4, r2
   26d20:	fba3 3202 	umull	r3, r2, r3, r2
	ret_cb = TICKER_STATUS_BUSY;
   26d24:	2102      	movs	r1, #2
	return ((uint8_t *)adv - (uint8_t *)ll_adv) / sizeof(*adv);
   26d26:	0992      	lsrs	r2, r2, #6
	ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
   26d28:	2300      	movs	r3, #0
   26d2a:	440a      	add	r2, r1
   26d2c:	ae09      	add	r6, sp, #36	; 0x24
	ret_cb = TICKER_STATUS_BUSY;
   26d2e:	9109      	str	r1, [sp, #36]	; 0x24
	ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
   26d30:	4912      	ldr	r1, [pc, #72]	; (26d7c <ull_adv_time_update+0xac>)
   26d32:	9105      	str	r1, [sp, #20]
   26d34:	e9cd 3303 	strd	r3, r3, [sp, #12]
   26d38:	2103      	movs	r1, #3
   26d3a:	b2d2      	uxtb	r2, r2
   26d3c:	9606      	str	r6, [sp, #24]
   26d3e:	9300      	str	r3, [sp, #0]
   26d40:	4618      	mov	r0, r3
   26d42:	f00e fea3 	bl	35a8c <ticker_update>
	ret = ull_ticker_status_take(ret, &ret_cb);
   26d46:	4631      	mov	r1, r6
   26d48:	f011 f8bc 	bl	37ec4 <ull_ticker_status_take>
	if (ret != TICKER_STATUS_SUCCESS) {
   26d4c:	b938      	cbnz	r0, 26d5e <ull_adv_time_update+0x8e>
	adv->ull.ticks_slot = time_ticks;
   26d4e:	6125      	str	r5, [r4, #16]
		return BT_HCI_ERR_SUCCESS;
   26d50:	2000      	movs	r0, #0
}
   26d52:	b00a      	add	sp, #40	; 0x28
   26d54:	bd70      	pop	{r4, r5, r6, pc}
	} else if (adv->ull.ticks_slot < time_ticks) {
   26d56:	d9fb      	bls.n	26d50 <ull_adv_time_update+0x80>
		ticks_plus = time_ticks - adv->ull.ticks_slot;
   26d58:	1ac2      	subs	r2, r0, r3
		ticks_minus = 0U;
   26d5a:	2300      	movs	r3, #0
   26d5c:	e7db      	b.n	26d16 <ull_adv_time_update+0x46>
		return BT_HCI_ERR_CMD_DISALLOWED;
   26d5e:	200c      	movs	r0, #12
}
   26d60:	b00a      	add	sp, #40	; 0x28
   26d62:	bd70      	pop	{r4, r5, r6, pc}
   26d64:	f3af 8000 	nop.w
   26d68:	1afd498d 	.word	0x1afd498d
   26d6c:	00000007 	.word	0x00000007
   26d70:	3b9aca00 	.word	0x3b9aca00
   26d74:	20005174 	.word	0x20005174
   26d78:	8d3dcb09 	.word	0x8d3dcb09
   26d7c:	000374a1 	.word	0x000374a1

00026d80 <ll_scan_params_set>:

static struct ll_scan_set ll_scan[BT_CTLR_SCAN_SET];

uint8_t ll_scan_params_set(uint8_t type, uint16_t interval, uint16_t window,
			uint8_t own_addr_type, uint8_t filter_policy)
{
   26d80:	b538      	push	{r3, r4, r5, lr}
struct ll_scan_set *ull_scan_is_disabled_get(uint8_t handle)
{
	struct ll_scan_set *scan;

	scan = ull_scan_set_get(handle);
	if (!scan || scan->is_enabled) {
   26d82:	4c19      	ldr	r4, [pc, #100]	; (26de8 <ll_scan_params_set+0x68>)
{
   26d84:	f89d e010 	ldrb.w	lr, [sp, #16]
	if (!scan || scan->is_enabled) {
   26d88:	f894 c040 	ldrb.w	ip, [r4, #64]	; 0x40
   26d8c:	f01c 0501 	ands.w	r5, ip, #1
   26d90:	d122      	bne.n	26dd8 <ll_scan_params_set+0x58>
	scan->own_addr_type = own_addr_type;
   26d92:	f363 0c42 	bfi	ip, r3, #1, #2
	lll->filter_policy = filter_policy;
   26d96:	0140      	lsls	r0, r0, #5
   26d98:	f894 3032 	ldrb.w	r3, [r4, #50]	; 0x32
	lll->interval = interval;
   26d9c:	8761      	strh	r1, [r4, #58]	; 0x3a
	lll->filter_policy = filter_policy;
   26d9e:	ea4f 0ece 	mov.w	lr, lr, lsl #3
   26da2:	f00e 0e18 	and.w	lr, lr, #24
   26da6:	f000 0020 	and.w	r0, r0, #32
   26daa:	ea40 000e 	orr.w	r0, r0, lr
   26dae:	f023 0338 	bic.w	r3, r3, #56	; 0x38
   26db2:	4303      	orrs	r3, r0
	lll->ticks_window = HAL_TICKER_US_TO_TICKS((uint64_t)window *
   26db4:	480d      	ldr	r0, [pc, #52]	; (26dec <ll_scan_params_set+0x6c>)
	lll->filter_policy = filter_policy;
   26db6:	f884 3032 	strb.w	r3, [r4, #50]	; 0x32
	lll->ticks_window = HAL_TICKER_US_TO_TICKS((uint64_t)window *
   26dba:	2191      	movs	r1, #145	; 0x91
   26dbc:	fba2 0300 	umull	r0, r3, r2, r0
	scan->own_addr_type = own_addr_type;
   26dc0:	f884 c040 	strb.w	ip, [r4, #64]	; 0x40
	lll->ticks_window = HAL_TICKER_US_TO_TICKS((uint64_t)window *
   26dc4:	fb01 3102 	mla	r1, r1, r2, r3
   26dc8:	a305      	add	r3, pc, #20	; (adr r3, 26de0 <ll_scan_params_set+0x60>)
   26dca:	e9d3 2300 	ldrd	r2, r3, [r3]
   26dce:	f7ff f997 	bl	26100 <__aeabi_uldivmod>
   26dd2:	63e0      	str	r0, [r4, #60]	; 0x3c
}
   26dd4:	4628      	mov	r0, r5
   26dd6:	bd38      	pop	{r3, r4, r5, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
   26dd8:	250c      	movs	r5, #12
}
   26dda:	4628      	mov	r0, r5
   26ddc:	bd38      	pop	{r3, r4, r5, pc}
   26dde:	bf00      	nop
   26de0:	1afd498d 	.word	0x1afd498d
   26de4:	00000007 	.word	0x00000007
   26de8:	20005200 	.word	0x20005200
   26dec:	84e72a00 	.word	0x84e72a00

00026df0 <ull_scan_params_set>:
{
   26df0:	b510      	push	{r4, lr}
   26df2:	4604      	mov	r4, r0
   26df4:	f89d 0008 	ldrb.w	r0, [sp, #8]
	lll->interval = interval;
   26df8:	83e2      	strh	r2, [r4, #30]
	lll->filter_policy = filter_policy;
   26dfa:	ea4f 1c41 	mov.w	ip, r1, lsl #5
   26dfe:	00c0      	lsls	r0, r0, #3
   26e00:	7da1      	ldrb	r1, [r4, #22]
   26e02:	f000 0018 	and.w	r0, r0, #24
   26e06:	f00c 0c20 	and.w	ip, ip, #32
   26e0a:	ea4c 0c00 	orr.w	ip, ip, r0
	lll->ticks_window = HAL_TICKER_US_TO_TICKS((uint64_t)window *
   26e0e:	480c      	ldr	r0, [pc, #48]	; (26e40 <ull_scan_params_set+0x50>)
	lll->filter_policy = filter_policy;
   26e10:	f021 0138 	bic.w	r1, r1, #56	; 0x38
   26e14:	ea4c 0c01 	orr.w	ip, ip, r1
	lll->ticks_window = HAL_TICKER_US_TO_TICKS((uint64_t)window *
   26e18:	fba3 0200 	umull	r0, r2, r3, r0
   26e1c:	2191      	movs	r1, #145	; 0x91
   26e1e:	fb01 2103 	mla	r1, r1, r3, r2
	lll->filter_policy = filter_policy;
   26e22:	f884 c016 	strb.w	ip, [r4, #22]
	lll->ticks_window = HAL_TICKER_US_TO_TICKS((uint64_t)window *
   26e26:	a304      	add	r3, pc, #16	; (adr r3, 26e38 <ull_scan_params_set+0x48>)
   26e28:	e9d3 2300 	ldrd	r2, r3, [r3]
   26e2c:	f7ff f968 	bl	26100 <__aeabi_uldivmod>
   26e30:	6220      	str	r0, [r4, #32]
}
   26e32:	bd10      	pop	{r4, pc}
   26e34:	f3af 8000 	nop.w
   26e38:	1afd498d 	.word	0x1afd498d
   26e3c:	00000007 	.word	0x00000007
   26e40:	84e72a00 	.word	0x84e72a00
   26e44:	00000000 	.word	0x00000000

00026e48 <ull_scan_enable>:
{
   26e48:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   26e4c:	4604      	mov	r4, r0
	(void)ll_addr_read(lll->init_addr_type, lll->init_addr);
   26e4e:	f100 0134 	add.w	r1, r0, #52	; 0x34
	lll->init_addr_type = scan->own_addr_type;
   26e52:	f890 0040 	ldrb.w	r0, [r0, #64]	; 0x40
   26e56:	f894 3032 	ldrb.w	r3, [r4, #50]	; 0x32
   26e5a:	f3c0 0040 	ubfx	r0, r0, #1, #1
   26e5e:	f360 1386 	bfi	r3, r0, #6, #1
{
   26e62:	b08d      	sub	sp, #52	; 0x34
	lll->init_addr_type = scan->own_addr_type;
   26e64:	f884 3032 	strb.w	r3, [r4, #50]	; 0x32
	(void)ll_addr_read(lll->init_addr_type, lll->init_addr);
   26e68:	f00e ff08 	bl	35c7c <ll_addr_read>
	lll->chan = 0U;
   26e6c:	f894 2032 	ldrb.w	r2, [r4, #50]	; 0x32
	ticks_interval = HAL_TICKER_US_TO_TICKS((uint64_t)lll->interval *
   26e70:	8f63      	ldrh	r3, [r4, #58]	; 0x3a
   26e72:	4847      	ldr	r0, [pc, #284]	; (26f90 <ull_scan_enable+0x148>)
   26e74:	61e4      	str	r4, [r4, #28]
	lll->chan = 0U;
   26e76:	f002 0279 	and.w	r2, r2, #121	; 0x79
   26e7a:	2500      	movs	r5, #0
   26e7c:	f884 2032 	strb.w	r2, [r4, #50]	; 0x32
	ticks_interval = HAL_TICKER_US_TO_TICKS((uint64_t)lll->interval *
   26e80:	2191      	movs	r1, #145	; 0x91
   26e82:	fba3 0200 	umull	r0, r2, r3, r0
	hdr->disabled_cb = hdr->disabled_param = NULL;
   26e86:	e9c4 5505 	strd	r5, r5, [r4, #20]
	hdr->ref = 0U;
   26e8a:	7025      	strb	r5, [r4, #0]
   26e8c:	fb01 2103 	mla	r1, r1, r3, r2
   26e90:	a33d      	add	r3, pc, #244	; (adr r3, 26f88 <ull_scan_enable+0x140>)
   26e92:	e9d3 2300 	ldrd	r2, r3, [r3]
   26e96:	f7ff f933 	bl	26100 <__aeabi_uldivmod>
	scan->ull.ticks_active_to_start = 0U;
   26e9a:	2331      	movs	r3, #49	; 0x31
   26e9c:	60a3      	str	r3, [r4, #8]
	if ((lll->ticks_window +
   26e9e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
	scan->ull.ticks_active_to_start = 0U;
   26ea0:	6065      	str	r5, [r4, #4]
	if ((lll->ticks_window +
   26ea2:	3318      	adds	r3, #24
   26ea4:	4298      	cmp	r0, r3
	scan->ull.ticks_preempt_to_start =
   26ea6:	60e5      	str	r5, [r4, #12]
		lll->ticks_window = 0U;
   26ea8:	bf98      	it	ls
   26eaa:	63e5      	strls	r5, [r4, #60]	; 0x3c
	return ((uint8_t *)scan - (uint8_t *)ll_scan) / sizeof(*scan);
   26eac:	4d39      	ldr	r5, [pc, #228]	; (26f94 <ull_scan_enable+0x14c>)
   26eae:	4a3a      	ldr	r2, [pc, #232]	; (26f98 <ull_scan_enable+0x150>)
			scan->ull.ticks_slot = ticks_interval -
   26eb0:	bf98      	it	ls
   26eb2:	4603      	movls	r3, r0
   26eb4:	6123      	str	r3, [r4, #16]
	return ((uint8_t *)scan - (uint8_t *)ll_scan) / sizeof(*scan);
   26eb6:	1b65      	subs	r5, r4, r5
   26eb8:	fba2 2505 	umull	r2, r5, r2, r5
	ticks_interval = HAL_TICKER_US_TO_TICKS((uint64_t)lll->interval *
   26ebc:	4606      	mov	r6, r0
	ticks_anchor = ticker_ticks_now_get();
   26ebe:	f00e fe9d 	bl	35bfc <ticker_ticks_now_get>
	if (!lll->conn) {
   26ec2:	6a23      	ldr	r3, [r4, #32]
	return ((uint8_t *)scan - (uint8_t *)ll_scan) / sizeof(*scan);
   26ec4:	f3c5 1587 	ubfx	r5, r5, #6, #8
	ticks_anchor = ticker_ticks_now_get();
   26ec8:	4607      	mov	r7, r0
	if (!lll->conn) {
   26eca:	2b00      	cmp	r3, #0
   26ecc:	d040      	beq.n	26f50 <ull_scan_enable+0x108>
   26ece:	f10d 082c 	add.w	r8, sp, #44	; 0x2c
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
   26ed2:	f8cd 8020 	str.w	r8, [sp, #32]
   26ed6:	9406      	str	r4, [sp, #24]
			   HAL_TICKER_REMAINDER((uint64_t)lll->interval *
   26ed8:	8f63      	ldrh	r3, [r4, #58]	; 0x3a
   26eda:	4a2d      	ldr	r2, [pc, #180]	; (26f90 <ull_scan_enable+0x148>)
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
   26edc:	f04f 0900 	mov.w	r9, #0
			   HAL_TICKER_REMAINDER((uint64_t)lll->interval *
   26ee0:	fba3 0202 	umull	r0, r2, r3, r2
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
   26ee4:	f8cd 900c 	str.w	r9, [sp, #12]
			   HAL_TICKER_REMAINDER((uint64_t)lll->interval *
   26ee8:	2191      	movs	r1, #145	; 0x91
   26eea:	fb01 2103 	mla	r1, r1, r3, r2
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
   26eee:	6923      	ldr	r3, [r4, #16]
   26ef0:	9304      	str	r3, [sp, #16]
   26ef2:	4b2a      	ldr	r3, [pc, #168]	; (26f9c <ull_scan_enable+0x154>)
   26ef4:	9307      	str	r3, [sp, #28]
   26ef6:	4b2a      	ldr	r3, [pc, #168]	; (26fa0 <ull_scan_enable+0x158>)
   26ef8:	9305      	str	r3, [sp, #20]
	ret_cb = TICKER_STATUS_BUSY;
   26efa:	2302      	movs	r3, #2
   26efc:	930b      	str	r3, [sp, #44]	; 0x2c
			   HAL_TICKER_REMAINDER((uint64_t)lll->interval *
   26efe:	a322      	add	r3, pc, #136	; (adr r3, 26f88 <ull_scan_enable+0x140>)
   26f00:	e9d3 2300 	ldrd	r2, r3, [r3]
   26f04:	f7ff f8fc 	bl	26100 <__aeabi_uldivmod>
   26f08:	4610      	mov	r0, r2
   26f0a:	4619      	mov	r1, r3
   26f0c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   26f10:	2300      	movs	r3, #0
   26f12:	f7ff f8f5 	bl	26100 <__aeabi_uldivmod>
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
   26f16:	3504      	adds	r5, #4
   26f18:	b2ed      	uxtb	r5, r5
   26f1a:	e9cd 6001 	strd	r6, r0, [sp, #4]
   26f1e:	2103      	movs	r1, #3
   26f20:	463b      	mov	r3, r7
   26f22:	462a      	mov	r2, r5
   26f24:	f8cd 9000 	str.w	r9, [sp]
   26f28:	4648      	mov	r0, r9
   26f2a:	f00e fd3b 	bl	359a4 <ticker_start>
	ret = ull_ticker_status_take(ret, &ret_cb);
   26f2e:	4641      	mov	r1, r8
   26f30:	f010 ffc8 	bl	37ec4 <ull_ticker_status_take>
	if (ret != TICKER_STATUS_SUCCESS) {
   26f34:	b940      	cbnz	r0, 26f48 <ull_scan_enable+0x100>
	scan->is_enabled = 1U;
   26f36:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
   26f3a:	f043 0301 	orr.w	r3, r3, #1
   26f3e:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
}
   26f42:	b00d      	add	sp, #52	; 0x34
   26f44:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
   26f48:	200c      	movs	r0, #12
}
   26f4a:	b00d      	add	sp, #52	; 0x34
   26f4c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		err = ull_sched_after_cen_slot_get(TICKER_USER_ID_THREAD,
   26f50:	f10d 082c 	add.w	r8, sp, #44	; 0x2c
		uint32_t offset_us = 0U;
   26f54:	e9cd 330a 	strd	r3, r3, [sp, #40]	; 0x28
		err = ull_sched_after_cen_slot_get(TICKER_USER_ID_THREAD,
   26f58:	6921      	ldr	r1, [r4, #16]
   26f5a:	4643      	mov	r3, r8
   26f5c:	aa0a      	add	r2, sp, #40	; 0x28
   26f5e:	2003      	movs	r0, #3
   26f60:	f001 f9de 	bl	28320 <ull_sched_after_cen_slot_get>
		if (!err) {
   26f64:	2800      	cmp	r0, #0
   26f66:	d1b4      	bne.n	26ed2 <ull_scan_enable+0x8a>
				       HAL_TICKER_US_TO_TICKS(offset_us);
   26f68:	990b      	ldr	r1, [sp, #44]	; 0x2c
   26f6a:	480e      	ldr	r0, [pc, #56]	; (26fa4 <ull_scan_enable+0x15c>)
   26f6c:	a306      	add	r3, pc, #24	; (adr r3, 26f88 <ull_scan_enable+0x140>)
   26f6e:	e9d3 2300 	ldrd	r2, r3, [r3]
   26f72:	fba1 0100 	umull	r0, r1, r1, r0
   26f76:	f7ff f8c3 	bl	26100 <__aeabi_uldivmod>
			ticks_anchor = ticks_ref +
   26f7a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
				       HAL_TICKER_US_TO_TICKS(offset_us);
   26f7c:	f020 477f 	bic.w	r7, r0, #4278190080	; 0xff000000
			ticks_anchor = ticks_ref +
   26f80:	441f      	add	r7, r3
   26f82:	e7a6      	b.n	26ed2 <ull_scan_enable+0x8a>
   26f84:	f3af 8000 	nop.w
   26f88:	1afd498d 	.word	0x1afd498d
   26f8c:	00000007 	.word	0x00000007
   26f90:	84e72a00 	.word	0x84e72a00
   26f94:	20005200 	.word	0x20005200
   26f98:	f0f0f0f1 	.word	0xf0f0f0f1
   26f9c:	000374a1 	.word	0x000374a1
   26fa0:	0003917d 	.word	0x0003917d
   26fa4:	3b9aca00 	.word	0x3b9aca00

00026fa8 <event_conn_upd_prep>:
#endif /* !CONFIG_BT_CTLR_SCHED_ADVANCED */
}

static inline int event_conn_upd_prep(struct ll_conn *conn, uint16_t lazy,
				      uint32_t ticks_at_expire)
{
   26fa8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	struct lll_conn *lll = &conn->lll;
	uint16_t instant_latency;
	uint16_t event_counter;

	/* Calculate current event counter */
	event_counter = lll->event_counter + lll->latency_prepare + lazy;
   26fac:	8dc3      	ldrh	r3, [r0, #46]	; 0x2e
   26fae:	8e45      	ldrh	r5, [r0, #50]	; 0x32

	instant_latency = (event_counter - conn->llcp.conn_upd.instant) &
   26fb0:	f8b0 60f4 	ldrh.w	r6, [r0, #244]	; 0xf4
	event_counter = lll->event_counter + lll->latency_prepare + lazy;
   26fb4:	441d      	add	r5, r3
			  0xffff;
	if (conn->llcp_cu.state != LLCP_CUI_STATE_INPROG) {
   26fb6:	f890 311a 	ldrb.w	r3, [r0, #282]	; 0x11a
	event_counter = lll->event_counter + lll->latency_prepare + lazy;
   26fba:	b2ad      	uxth	r5, r5
   26fbc:	4429      	add	r1, r5
{
   26fbe:	4617      	mov	r7, r2
	if (conn->llcp_cu.state != LLCP_CUI_STATE_INPROG) {
   26fc0:	f013 0207 	ands.w	r2, r3, #7
{
   26fc4:	b08b      	sub	sp, #44	; 0x2c
   26fc6:	4604      	mov	r4, r0
	event_counter = lll->event_counter + lll->latency_prepare + lazy;
   26fc8:	b289      	uxth	r1, r1
	if (conn->llcp_cu.state != LLCP_CUI_STATE_INPROG) {
   26fca:	d00a      	beq.n	26fe2 <event_conn_upd_prep+0x3a>
		static memq_link_t s_link;
		static struct mayfly s_mfy_sched_offset = {0, 0,
			&s_link, 0, 0 };
		void (*fp_mfy_select_or_use)(void *) = NULL;

		switch (conn->llcp_cu.state) {
   26fcc:	3a01      	subs	r2, #1
   26fce:	2a04      	cmp	r2, #4
   26fd0:	f200 837e 	bhi.w	276d0 <event_conn_upd_prep+0x728>
   26fd4:	e8df f012 	tbh	[pc, r2, lsl #1]
   26fd8:	02090172 	.word	0x02090172
   26fdc:	02520204 	.word	0x02520204
   26fe0:	020c      	.short	0x020c
	instant_latency = (event_counter - conn->llcp.conn_upd.instant) &
   26fe2:	1b89      	subs	r1, r1, r6
   26fe4:	fa1f f881 	uxth.w	r8, r1
		conn->llcp_cu.pause_tx = 1U;

		/* enqueue control PDU */
		ctrl_tx_enqueue(conn, tx);
#endif /* !CONFIG_BT_CTLR_SCHED_ADVANCED */
	} else if (instant_latency <= 0x7FFF) {
   26fe8:	0409      	lsls	r1, r1, #16
   26fea:	f100 81d3 	bmi.w	27394 <event_conn_upd_prep+0x3ec>
		uint32_t ticker_status;
		uint32_t periodic_us;
		uint16_t latency;

#if defined(CONFIG_BT_PERIPHERAL) && defined(CONFIG_BT_CTLR_LE_ENC)
		if (conn->lll.role && (conn->periph.llcp_type != LLCP_NONE)) {
   26fee:	f990 3039 	ldrsb.w	r3, [r0, #57]	; 0x39
   26ff2:	2b00      	cmp	r3, #0
   26ff4:	f2c0 828c 	blt.w	27510 <event_conn_upd_prep+0x568>
			conn->periph.llcp_type = LLCP_NONE;
		} else
#endif /* CONFIG_BT_PERIPHERAL && CONFIG_BT_CTLR_LE_ENC */
		{
			/* procedure request acked */
			conn->llcp_ack = conn->llcp_req;
   26ff8:	f894 30f0 	ldrb.w	r3, [r4, #240]	; 0xf0
   26ffc:	f884 30f1 	strb.w	r3, [r4, #241]	; 0xf1

		/* procedure request acked */
		conn->llcp_cu.ack = conn->llcp_cu.req;

#if defined(CONFIG_BT_CTLR_CONN_PARAM_REQ)
		if ((conn->llcp_conn_param.req != conn->llcp_conn_param.ack) &&
   27000:	f894 2194 	ldrb.w	r2, [r4, #404]	; 0x194
   27004:	f894 3195 	ldrb.w	r3, [r4, #405]	; 0x195
		conn->llcp_cu.ack = conn->llcp_cu.req;
   27008:	f894 1118 	ldrb.w	r1, [r4, #280]	; 0x118
   2700c:	f884 1119 	strb.w	r1, [r4, #281]	; 0x119
		if ((conn->llcp_conn_param.req != conn->llcp_conn_param.ack) &&
   27010:	4293      	cmp	r3, r2
   27012:	d006      	beq.n	27022 <event_conn_upd_prep+0x7a>
		    (conn->llcp_conn_param.state == LLCP_CPR_STATE_UPD)) {
   27014:	f894 3196 	ldrb.w	r3, [r4, #406]	; 0x196
		if ((conn->llcp_conn_param.req != conn->llcp_conn_param.ack) &&
   27018:	f003 030f 	and.w	r3, r3, #15
   2701c:	2b06      	cmp	r3, #6
   2701e:	f000 82d1 	beq.w	275c4 <event_conn_upd_prep+0x61c>
	return conn_upd_curr && (conn_upd_curr != conn);
}

static inline void cpr_active_check_and_reset(struct ll_conn *conn)
{
	if (conn == conn_upd_curr) {
   27022:	4b99      	ldr	r3, [pc, #612]	; (27288 <event_conn_upd_prep+0x2e0>)
#endif /* CONFIG_BT_CTLR_CONN_PARAM_REQ */

		lll = &conn->lll;

		/* Acquire Rx node */
		rx = conn->llcp_rx;
   27024:	f8d4 9114 	ldr.w	r9, [r4, #276]	; 0x114
   27028:	681a      	ldr	r2, [r3, #0]
   2702a:	4294      	cmp	r4, r2
		conn_upd_curr = NULL;
   2702c:	bf04      	itt	eq
   2702e:	2200      	moveq	r2, #0
   27030:	601a      	streq	r2, [r3, #0]
		LL_ASSERT(rx && rx->hdr.link);
   27032:	f1b9 0f00 	cmp.w	r9, #0
   27036:	f000 81c3 	beq.w	273c0 <event_conn_upd_prep+0x418>
   2703a:	f8d9 3000 	ldr.w	r3, [r9]
   2703e:	2b00      	cmp	r3, #0
   27040:	f000 81be 	beq.w	273c0 <event_conn_upd_prep+0x418>
		conn->llcp_rx = rx->hdr.link->mem;
   27044:	685b      	ldr	r3, [r3, #4]

		/* Prepare the rx packet structure */
		if ((conn->llcp_cu.interval != lll->interval) ||
   27046:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
		conn->llcp_rx = rx->hdr.link->mem;
   27048:	f8c4 3114 	str.w	r3, [r4, #276]	; 0x114
		if ((conn->llcp_cu.interval != lll->interval) ||
   2704c:	f8b4 311c 	ldrh.w	r3, [r4, #284]	; 0x11c
   27050:	4293      	cmp	r3, r2
   27052:	d105      	bne.n	27060 <event_conn_upd_prep+0xb8>
   27054:	f8b4 111e 	ldrh.w	r1, [r4, #286]	; 0x11e
   27058:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
   2705a:	4291      	cmp	r1, r2
   2705c:	f000 823a 	beq.w	274d4 <event_conn_upd_prep+0x52c>
		    (RADIO_CONN_EVENTS(conn->llcp_cu.timeout * 10000U,
				       lll->interval * CONN_INT_UNIT_US) !=
		     conn->supervision_reload)) {
			struct node_rx_cu *cu;

			rx->hdr.handle = lll->handle;
   27060:	8d23      	ldrh	r3, [r4, #40]	; 0x28
   27062:	f8a9 3006 	strh.w	r3, [r9, #6]
			rx->hdr.type = NODE_RX_TYPE_CONN_UPDATE;
   27066:	2319      	movs	r3, #25
   27068:	f889 3004 	strb.w	r3, [r9, #4]

			/* prepare connection update complete structure */
			cu = (void *)rx->pdu;
			cu->status = 0x00;
   2706c:	2300      	movs	r3, #0
   2706e:	f889 301c 	strb.w	r3, [r9, #28]
			cu->interval = conn->llcp_cu.interval;
   27072:	f8b4 311c 	ldrh.w	r3, [r4, #284]	; 0x11c
   27076:	f8a9 301e 	strh.w	r3, [r9, #30]
			cu->latency = conn->llcp_cu.latency;
   2707a:	f8b4 311e 	ldrh.w	r3, [r4, #286]	; 0x11e
   2707e:	f8a9 3020 	strh.w	r3, [r9, #32]
			cu->timeout = conn->llcp_cu.timeout;
   27082:	f8b4 3120 	ldrh.w	r3, [r4, #288]	; 0x120
#if defined(CONFIG_BT_CTLR_RX_ENQUEUE_HOLD)
			/* hold node rx until the instant's anchor point sync */
			rx_hold_put(conn, rx->hdr.link, rx);
#else /* !CONFIG_BT_CTLR_RX_ENQUEUE_HOLD */
			/* enqueue rx node towards Thread */
			ll_rx_put(rx->hdr.link, rx);
   27086:	f8d9 0000 	ldr.w	r0, [r9]
			cu->timeout = conn->llcp_cu.timeout;
   2708a:	f8a9 3022 	strh.w	r3, [r9, #34]	; 0x22
			ll_rx_put(rx->hdr.link, rx);
   2708e:	4649      	mov	r1, r9
   27090:	f010 fe78 	bl	37d84 <ll_rx_put>
			ll_rx_sched();
   27094:	f010 fe80 	bl	37d98 <ll_rx_sched>
			ll_rx_sched();
		}

#if defined(CONFIG_BT_CTLR_XTAL_ADVANCED)
		/* restore to normal prepare */
		if (conn->ull.ticks_prepare_to_start & XON_BITMASK) {
   27098:	68a3      	ldr	r3, [r4, #8]
   2709a:	2b00      	cmp	r3, #0
   2709c:	da09      	bge.n	270b2 <event_conn_upd_prep+0x10a>
			uint32_t ticks_prepare_to_start =
   2709e:	68e1      	ldr	r1, [r4, #12]
   270a0:	6862      	ldr	r2, [r4, #4]
				MAX(conn->ull.ticks_active_to_start,
				    conn->ull.ticks_preempt_to_start);

			conn->ull.ticks_prepare_to_start &= ~XON_BITMASK;
   270a2:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   270a6:	4291      	cmp	r1, r2
   270a8:	bf2c      	ite	cs
   270aa:	187f      	addcs	r7, r7, r1
   270ac:	18bf      	addcc	r7, r7, r2
   270ae:	60a3      	str	r3, [r4, #8]
			ticks_at_expire -= (conn->ull.ticks_prepare_to_start -
   270b0:	1aff      	subs	r7, r7, r3
					    ticks_prepare_to_start);
		}
#endif /* CONFIG_BT_CTLR_XTAL_ADVANCED */

		/* compensate for instant_latency due to laziness */
		conn_interval_old = instant_latency * lll->interval;
   270b2:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
		latency = conn_interval_old / conn->llcp_cu.interval;
   270b4:	f8b4 911c 	ldrh.w	r9, [r4, #284]	; 0x11c
		conn_interval_old = instant_latency * lll->interval;
   270b8:	fb11 f108 	smulbb	r1, r1, r8
   270bc:	b289      	uxth	r1, r1
		latency = conn_interval_old / conn->llcp_cu.interval;
   270be:	fbb1 f3f9 	udiv	r3, r1, r9
		conn_interval_new = latency * conn->llcp_cu.interval;
   270c2:	fb19 f003 	smulbb	r0, r9, r3
   270c6:	b280      	uxth	r0, r0
		if (conn_interval_new > conn_interval_old) {
   270c8:	4281      	cmp	r1, r0
		latency = conn_interval_old / conn->llcp_cu.interval;
   270ca:	fa1f fa83 	uxth.w	sl, r3
		if (conn_interval_new > conn_interval_old) {
   270ce:	f080 8166 	bcs.w	2739e <event_conn_upd_prep+0x3f6>
			ticks_at_expire += HAL_TICKER_US_TO_TICKS(
   270d2:	1a40      	subs	r0, r0, r1
   270d4:	f240 42e2 	movw	r2, #1250	; 0x4e2
   270d8:	496c      	ldr	r1, [pc, #432]	; (2728c <event_conn_upd_prep+0x2e4>)
   270da:	fb02 f000 	mul.w	r0, r2, r0
   270de:	fba0 0101 	umull	r0, r1, r0, r1
   270e2:	a367      	add	r3, pc, #412	; (adr r3, 27280 <event_conn_upd_prep+0x2d8>)
   270e4:	e9d3 2300 	ldrd	r2, r3, [r3]
   270e8:	f7ff f80a 	bl	26100 <__aeabi_uldivmod>
   270ec:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
   270f0:	4407      	add	r7, r0
			ticks_at_expire -= HAL_TICKER_US_TO_TICKS(
				(conn_interval_old - conn_interval_new) *
				CONN_INT_UNIT_US);
		}
		lll->latency_prepare += lazy;
		lll->latency_prepare -= (instant_latency - latency);
   270f2:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
   270f4:	441e      	add	r6, r3
			CONN_INT_UNIT_US;
		periodic_us = conn_interval_us;

		if (0) {
#if defined(CONFIG_BT_PERIPHERAL)
		} else if (lll->role) {
   270f6:	f994 3039 	ldrsb.w	r3, [r4, #57]	; 0x39
		lll->latency_prepare -= (instant_latency - latency);
   270fa:	1b76      	subs	r6, r6, r5
   270fc:	4456      	add	r6, sl
		conn_interval_us = conn->llcp_cu.interval *
   270fe:	f240 4be2 	movw	fp, #1250	; 0x4e2
		} else if (lll->role) {
   27102:	2b00      	cmp	r3, #0
		lll->latency_prepare -= (instant_latency - latency);
   27104:	85e6      	strh	r6, [r4, #46]	; 0x2e
		conn_interval_us = conn->llcp_cu.interval *
   27106:	fb0b f609 	mul.w	r6, fp, r9
		} else if (lll->role) {
   2710a:	f2c0 820f 	blt.w	2752c <event_conn_upd_prep+0x584>
			periodic_us -= lll->periph.window_widening_periodic_us;
#endif /* CONFIG_BT_PERIPHERAL */

#if defined(CONFIG_BT_CENTRAL)
		} else if (!lll->role) {
			ticks_win_offset = HAL_TICKER_US_TO_TICKS(
   2710e:	f8d4 1124 	ldr.w	r1, [r4, #292]	; 0x124
   27112:	485e      	ldr	r0, [pc, #376]	; (2728c <event_conn_upd_prep+0x2e4>)
   27114:	a35a      	add	r3, pc, #360	; (adr r3, 27280 <event_conn_upd_prep+0x2d8>)
   27116:	e9d3 2300 	ldrd	r2, r3, [r3]
   2711a:	fba1 0100 	umull	r0, r1, r1, r0
   2711e:	f7fe ffef 	bl	26100 <__aeabi_uldivmod>
   27122:	f020 487f 	bic.w	r8, r0, #4278190080	; 0xff000000
		periodic_us = conn_interval_us;
   27126:	4635      	mov	r5, r6

			/* Workaround: Due to the missing remainder param in
			 * ticker_start function for first interval; add a
			 * tick so as to use the ceiled value.
			 */
			ticks_win_offset += 1U;
   27128:	f108 0801 	add.w	r8, r8, #1

		conn->supervision_reload =
			RADIO_CONN_EVENTS((conn->llcp_cu.timeout * 10U * 1000U),
					  conn_interval_us);
		conn->procedure_reload =
			RADIO_CONN_EVENTS((40 * 1000 * 1000), conn_interval_us);
   2712c:	4a58      	ldr	r2, [pc, #352]	; (27290 <event_conn_upd_prep+0x2e8>)
			RADIO_CONN_EVENTS((conn->llcp_cu.timeout * 10U * 1000U),
   2712e:	f8b4 3120 	ldrh.w	r3, [r4, #288]	; 0x120
		lll->latency = conn->llcp_cu.latency;
   27132:	f8b4 011e 	ldrh.w	r0, [r4, #286]	; 0x11e

#if defined(CONFIG_BT_CTLR_LE_PING)
		/* APTO in no. of connection events */
		conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
   27136:	4957      	ldr	r1, [pc, #348]	; (27294 <event_conn_upd_prep+0x2ec>)
		lll->interval = conn->llcp_cu.interval;
   27138:	f8a4 902a 	strh.w	r9, [r4, #42]	; 0x2a
			RADIO_CONN_EVENTS((40 * 1000 * 1000), conn_interval_us);
   2713c:	4432      	add	r2, r6
   2713e:	fbb2 f2f6 	udiv	r2, r2, r6
   27142:	f8a4 20c6 	strh.w	r2, [r4, #198]	; 0xc6
			RADIO_CONN_EVENTS((conn->llcp_cu.timeout * 10U * 1000U),
   27146:	f242 7210 	movw	r2, #10000	; 0x2710
   2714a:	fb02 6303 	mla	r3, r2, r3, r6
		conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
   2714e:	4431      	add	r1, r6
			RADIO_CONN_EVENTS((conn->llcp_cu.timeout * 10U * 1000U),
   27150:	3b01      	subs	r3, #1
		conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
   27152:	fbb1 f1f6 	udiv	r1, r1, r6
			RADIO_CONN_EVENTS((conn->llcp_cu.timeout * 10U * 1000U),
   27156:	fbb3 f3f6 	udiv	r3, r3, r6
		conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
   2715a:	b28a      	uxth	r2, r1
			RADIO_CONN_EVENTS((conn->llcp_cu.timeout * 10U * 1000U),
   2715c:	f8a4 30c2 	strh.w	r3, [r4, #194]	; 0xc2
						      conn_interval_us);
		/* Dispatch LE Ping PDU 6 connection events (that peer would
		 * listen to) before 30s timeout
		 * TODO: "peer listens to" is greater than 30s due to latency
		 */
		conn->appto_reload = (conn->apto_reload > (lll->latency + 6)) ?
   27160:	1d83      	adds	r3, r0, #6
   27162:	429a      	cmp	r2, r3
		lll->latency = conn->llcp_cu.latency;
   27164:	85a0      	strh	r0, [r4, #44]	; 0x2c
		conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
   27166:	f8a4 20ce 	strh.w	r2, [r4, #206]	; 0xce
		conn->appto_reload = (conn->apto_reload > (lll->latency + 6)) ?
   2716a:	dd04      	ble.n	27176 <event_conn_upd_prep+0x1ce>
   2716c:	f5c0 437f 	rsb	r3, r0, #65280	; 0xff00
   27170:	33fa      	adds	r3, #250	; 0xfa
   27172:	441a      	add	r2, r3
   27174:	b292      	uxth	r2, r2
				     (conn->apto_reload - (lll->latency + 6)) :
				     conn->apto_reload;
#endif /* CONFIG_BT_CTLR_LE_PING */

		if (conn->llcp_cu.cmd) {
   27176:	f894 311a 	ldrb.w	r3, [r4, #282]	; 0x11a
		conn->appto_reload = (conn->apto_reload > (lll->latency + 6)) ?
   2717a:	f8a4 20ca 	strh.w	r2, [r4, #202]	; 0xca
		if (conn->llcp_cu.cmd) {
   2717e:	071b      	lsls	r3, r3, #28
			conn->supervision_expire = 0U;
   27180:	bf44      	itt	mi
   27182:	2300      	movmi	r3, #0
   27184:	f8a4 30c4 	strhmi.w	r3, [r4, #196]	; 0xc4
#if (CONFIG_BT_CTLR_ULL_HIGH_PRIO == CONFIG_BT_CTLR_ULL_LOW_PRIO)
		/* disable ticker job, in order to chain stop and start
		 * to avoid RTC being stopped if no tickers active.
		 */
		uint32_t mayfly_was_enabled =
			mayfly_is_enabled(TICKER_USER_ID_ULL_HIGH,
   27188:	2102      	movs	r1, #2
   2718a:	2001      	movs	r0, #1
   2718c:	f01b f8e2 	bl	42354 <mayfly_is_enabled>
					  TICKER_USER_ID_ULL_LOW);
		mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW,
   27190:	2200      	movs	r2, #0
   27192:	2102      	movs	r1, #2
			mayfly_is_enabled(TICKER_USER_ID_ULL_HIGH,
   27194:	4682      	mov	sl, r0
		mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW,
   27196:	2001      	movs	r0, #1
   27198:	f00d fa36 	bl	34608 <mayfly_enable>
	return mem_index_get(conn, conn_pool, sizeof(struct ll_conn));
   2719c:	493e      	ldr	r1, [pc, #248]	; (27298 <event_conn_upd_prep+0x2f0>)
   2719e:	f44f 72fc 	mov.w	r2, #504	; 0x1f8
   271a2:	4620      	mov	r0, r4
   271a4:	f00d f9c0 	bl	34528 <mem_index_get>
			      0);
#endif

		/* start peripheral/central with new timings */
		ticker_id_conn = TICKER_ID_CONN_BASE + ll_conn_handle_get(conn);
   271a8:	f100 0905 	add.w	r9, r0, #5
   271ac:	fa5f f989 	uxtb.w	r9, r9
		ticker_status =	ticker_stop(TICKER_INSTANCE_ID_CTLR,
   271b0:	4b3a      	ldr	r3, [pc, #232]	; (2729c <event_conn_upd_prep+0x2f4>)
   271b2:	9400      	str	r4, [sp, #0]
   271b4:	464a      	mov	r2, r9
   271b6:	2101      	movs	r1, #1
   271b8:	2000      	movs	r0, #0
   271ba:	f00e fc7f 	bl	35abc <ticker_stop>
					    TICKER_USER_ID_ULL_HIGH,
					    ticker_id_conn,
					    ticker_stop_conn_op_cb,
					    (void *)conn);
		LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
   271be:	f030 0302 	bics.w	r3, r0, #2
   271c2:	d00c      	beq.n	271de <event_conn_upd_prep+0x236>
   271c4:	4a36      	ldr	r2, [pc, #216]	; (272a0 <event_conn_upd_prep+0x2f8>)
   271c6:	4937      	ldr	r1, [pc, #220]	; (272a4 <event_conn_upd_prep+0x2fc>)
   271c8:	4837      	ldr	r0, [pc, #220]	; (272a8 <event_conn_upd_prep+0x300>)
   271ca:	f640 53af 	movw	r3, #3503	; 0xdaf
   271ce:	f021 ff59 	bl	49084 <assert_print>
   271d2:	4040      	eors	r0, r0
   271d4:	f380 8811 	msr	BASEPRI, r0
   271d8:	f04f 0003 	mov.w	r0, #3
   271dc:	df02      	svc	2
		ticker_status =
			ticker_start(TICKER_INSTANCE_ID_CTLR,
				     TICKER_USER_ID_ULL_HIGH,
				     ticker_id_conn,
				     ticks_at_expire, ticks_win_offset,
				     HAL_TICKER_US_TO_TICKS(periodic_us),
   271de:	4e2b      	ldr	r6, [pc, #172]	; (2728c <event_conn_upd_prep+0x2e4>)
   271e0:	fba5 6b06 	umull	r6, fp, r5, r6
   271e4:	a326      	add	r3, pc, #152	; (adr r3, 27280 <event_conn_upd_prep+0x2d8>)
   271e6:	e9d3 2300 	ldrd	r2, r3, [r3]
   271ea:	4630      	mov	r0, r6
   271ec:	4659      	mov	r1, fp
   271ee:	f7fe ff87 	bl	26100 <__aeabi_uldivmod>
				     HAL_TICKER_REMAINDER(periodic_us),
   271f2:	4b2e      	ldr	r3, [pc, #184]	; (272ac <event_conn_upd_prep+0x304>)
			ticker_start(TICKER_INSTANCE_ID_CTLR,
   271f4:	f020 457f 	bic.w	r5, r0, #4278190080	; 0xff000000
				     HAL_TICKER_REMAINDER(periodic_us),
   271f8:	fba5 3103 	umull	r3, r1, r5, r3
   271fc:	2207      	movs	r2, #7
   271fe:	1af0      	subs	r0, r6, r3
   27200:	fb02 1105 	mla	r1, r2, r5, r1
   27204:	eb6b 0101 	sbc.w	r1, fp, r1
   27208:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   2720c:	2300      	movs	r3, #0
   2720e:	f7fe ff77 	bl	26100 <__aeabi_uldivmod>
			ticker_start(TICKER_INSTANCE_ID_CTLR,
   27212:	e9cd 5001 	strd	r5, r0, [sp, #4]
   27216:	9408      	str	r4, [sp, #32]
   27218:	9406      	str	r4, [sp, #24]
   2721a:	f8cd 8000 	str.w	r8, [sp]
				     TICKER_NULL_LAZY,
#else
				     TICKER_LAZY_MUST_EXPIRE_KEEP,
#endif /* CONFIG_BT_TICKER_LOW_LAT */
				     (ticks_slot_overhead +
				      conn->ull.ticks_slot),
   2721e:	6921      	ldr	r1, [r4, #16]
			ticker_start(TICKER_INSTANCE_ID_CTLR,
   27220:	f994 5039 	ldrsb.w	r5, [r4, #57]	; 0x39
   27224:	4822      	ldr	r0, [pc, #136]	; (272b0 <event_conn_upd_prep+0x308>)
   27226:	9104      	str	r1, [sp, #16]
   27228:	4922      	ldr	r1, [pc, #136]	; (272b4 <event_conn_upd_prep+0x30c>)
   2722a:	4c23      	ldr	r4, [pc, #140]	; (272b8 <event_conn_upd_prep+0x310>)
   2722c:	9407      	str	r4, [sp, #28]
   2722e:	ea31 0125 	bics.w	r1, r1, r5, asr #32
   27232:	bf28      	it	cs
   27234:	4601      	movcs	r1, r0
   27236:	9105      	str	r1, [sp, #20]
   27238:	f64f 71fe 	movw	r1, #65534	; 0xfffe
   2723c:	463b      	mov	r3, r7
   2723e:	9103      	str	r1, [sp, #12]
   27240:	464a      	mov	r2, r9
   27242:	2101      	movs	r1, #1
   27244:	2000      	movs	r0, #0
   27246:	f00e fbad 	bl	359a4 <ticker_start>
#else
				     ull_central_ticker_cb,
#endif
				     conn, ticker_start_conn_op_cb,
				     (void *)conn);
		LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
   2724a:	f030 0302 	bics.w	r3, r0, #2
   2724e:	d00c      	beq.n	2726a <event_conn_upd_prep+0x2c2>
   27250:	4a13      	ldr	r2, [pc, #76]	; (272a0 <event_conn_upd_prep+0x2f8>)
   27252:	4914      	ldr	r1, [pc, #80]	; (272a4 <event_conn_upd_prep+0x2fc>)
   27254:	4814      	ldr	r0, [pc, #80]	; (272a8 <event_conn_upd_prep+0x300>)
   27256:	f640 53c9 	movw	r3, #3529	; 0xdc9
   2725a:	f021 ff13 	bl	49084 <assert_print>
   2725e:	4040      	eors	r0, r0
   27260:	f380 8811 	msr	BASEPRI, r0
   27264:	f04f 0003 	mov.w	r0, #3
   27268:	df02      	svc	2
			  (ticker_status == TICKER_STATUS_BUSY));

#if (CONFIG_BT_CTLR_ULL_HIGH_PRIO == CONFIG_BT_CTLR_ULL_LOW_PRIO)
		/* enable ticker job, if disabled in this function */
		if (mayfly_was_enabled) {
   2726a:	f1ba 0f00 	cmp.w	sl, #0
   2726e:	f040 8157 	bne.w	27520 <event_conn_upd_prep+0x578>
			mayfly_enable(TICKER_USER_ID_ULL_HIGH,
				      TICKER_USER_ID_ULL_LOW, 1);
		}
#endif

		return 0;
   27272:	2000      	movs	r0, #0
	}

	return -EINPROGRESS;
}
   27274:	b00b      	add	sp, #44	; 0x2c
   27276:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2727a:	bf00      	nop
   2727c:	f3af 8000 	nop.w
   27280:	1afd498d 	.word	0x1afd498d
   27284:	00000007 	.word	0x00000007
   27288:	200058f0 	.word	0x200058f0
   2728c:	3b9aca00 	.word	0x3b9aca00
   27290:	026259ff 	.word	0x026259ff
   27294:	01c9c37f 	.word	0x01c9c37f
   27298:	200028e8 	.word	0x200028e8
   2729c:	000397fd 	.word	0x000397fd
   272a0:	0005269c 	.word	0x0005269c
   272a4:	0005277c 	.word	0x0005277c
   272a8:	0005214c 	.word	0x0005214c
   272ac:	1afd498d 	.word	0x1afd498d
   272b0:	0003e4ed 	.word	0x0003e4ed
   272b4:	0003e6d9 	.word	0x0003e6d9
   272b8:	000397a5 	.word	0x000397a5
			fp_mfy_select_or_use = ull_sched_mfy_win_offset_use;
   272bc:	f8df 8328 	ldr.w	r8, [pc, #808]	; 275e8 <event_conn_upd_prep+0x640>
		rx = ll_pdu_rx_alloc_peek(1);
   272c0:	2001      	movs	r0, #1
   272c2:	f010 fd6f 	bl	37da4 <ll_pdu_rx_alloc_peek>
		if (!rx) {
   272c6:	4606      	mov	r6, r0
   272c8:	2800      	cmp	r0, #0
   272ca:	f000 81d9 	beq.w	27680 <event_conn_upd_prep+0x6d8>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
   272ce:	48c7      	ldr	r0, [pc, #796]	; (275ec <event_conn_upd_prep+0x644>)
   272d0:	f00d f8f2 	bl	344b8 <mem_acquire>
		if (!tx) {
   272d4:	4605      	mov	r5, r0
   272d6:	2800      	cmp	r0, #0
   272d8:	f000 81d2 	beq.w	27680 <event_conn_upd_prep+0x6d8>
	if (!conn_upd_curr) {
   272dc:	4bc4      	ldr	r3, [pc, #784]	; (275f0 <event_conn_upd_prep+0x648>)
   272de:	681a      	ldr	r2, [r3, #0]
   272e0:	2a00      	cmp	r2, #0
   272e2:	f000 8178 	beq.w	275d6 <event_conn_upd_prep+0x62e>
		(void)ll_pdu_rx_alloc();
   272e6:	f010 fd7f 	bl	37de8 <ll_pdu_rx_alloc>
		rx->hdr.link->mem = conn->llcp_rx;
   272ea:	6833      	ldr	r3, [r6, #0]
   272ec:	f8d4 2114 	ldr.w	r2, [r4, #276]	; 0x114
   272f0:	605a      	str	r2, [r3, #4]
		conn->llcp_rx = rx;
   272f2:	f8c4 6114 	str.w	r6, [r4, #276]	; 0x114
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   272f6:	792b      	ldrb	r3, [r5, #4]
		sys_cpu_to_le16(conn->llcp_cu.win_offset_us /
   272f8:	4abe      	ldr	r2, [pc, #760]	; (275f4 <event_conn_upd_prep+0x64c>)
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   272fa:	f043 0303 	orr.w	r3, r3, #3
   272fe:	712b      	strb	r3, [r5, #4]
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, conn_update_ind) +
   27300:	230c      	movs	r3, #12
   27302:	716b      	strb	r3, [r5, #5]
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_CONN_UPDATE_IND;
   27304:	2300      	movs	r3, #0
   27306:	71eb      	strb	r3, [r5, #7]
	pdu_ctrl_tx->llctrl.conn_update_ind.win_size = conn->llcp_cu.win_size;
   27308:	f894 3128 	ldrb.w	r3, [r4, #296]	; 0x128
   2730c:	722b      	strb	r3, [r5, #8]
		sys_cpu_to_le16(conn->llcp_cu.win_offset_us /
   2730e:	f8d4 3124 	ldr.w	r3, [r4, #292]	; 0x124
   27312:	fba2 2303 	umull	r2, r3, r2, r3
   27316:	0a9b      	lsrs	r3, r3, #10
	pdu_ctrl_tx->llctrl.conn_update_ind.win_offset =
   27318:	f8a5 3009 	strh.w	r3, [r5, #9]
		sys_cpu_to_le16(conn->llcp_cu.interval);
   2731c:	f8b4 311c 	ldrh.w	r3, [r4, #284]	; 0x11c
	pdu_ctrl_tx->llctrl.conn_update_ind.interval =
   27320:	f8a5 300b 	strh.w	r3, [r5, #11]
		sys_cpu_to_le16(conn->llcp_cu.latency);
   27324:	f8b4 311e 	ldrh.w	r3, [r4, #286]	; 0x11e
	pdu_ctrl_tx->llctrl.conn_update_ind.latency =
   27328:	f8a5 300d 	strh.w	r3, [r5, #13]
		sys_cpu_to_le16(conn->llcp_cu.timeout);
   2732c:	f8b4 3120 	ldrh.w	r3, [r4, #288]	; 0x120
	pdu_ctrl_tx->llctrl.conn_update_ind.timeout =
   27330:	f8a5 300f 	strh.w	r3, [r5, #15]
	conn->llcp_cu.state = LLCP_CUI_STATE_OFFS_REQ;
   27334:	f894 311a 	ldrb.w	r3, [r4, #282]	; 0x11a
		conn->llcp.conn_upd.ticks_anchor = ticks_at_expire;
   27338:	f8c4 70fc 	str.w	r7, [r4, #252]	; 0xfc
	conn->llcp_cu.state = LLCP_CUI_STATE_OFFS_REQ;
   2733c:	2203      	movs	r2, #3
   2733e:	f362 0302 	bfi	r3, r2, #0, #3
   27342:	f884 311a 	strb.w	r3, [r4, #282]	; 0x11a
		if (conn->ull.ticks_prepare_to_start & XON_BITMASK) {
   27346:	68a3      	ldr	r3, [r4, #8]
   27348:	2b00      	cmp	r3, #0
   2734a:	da0a      	bge.n	27362 <event_conn_upd_prep+0x3ba>
			uint32_t ticks_prepare_to_start =
   2734c:	68e1      	ldr	r1, [r4, #12]
   2734e:	6862      	ldr	r2, [r4, #4]
				(conn->ull.ticks_prepare_to_start &
   27350:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
			conn->llcp.conn_upd.ticks_anchor -=
   27354:	4291      	cmp	r1, r2
   27356:	bf2c      	ite	cs
   27358:	187f      	addcs	r7, r7, r1
   2735a:	18bf      	addcc	r7, r7, r2
   2735c:	1aff      	subs	r7, r7, r3
   2735e:	f8c4 70fc 	str.w	r7, [r4, #252]	; 0xfc
		mfy_sched_offset->fp = fp_mfy_select_or_use;
   27362:	4ba5      	ldr	r3, [pc, #660]	; (275f8 <event_conn_upd_prep+0x650>)
		retval = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
   27364:	2201      	movs	r2, #1
		win_offs = &pdu_ctrl_tx->llctrl.conn_update_ind.win_offset;
   27366:	3509      	adds	r5, #9
		conn->llcp.conn_upd.pdu_win_offset = win_offs;
   27368:	f8c4 50f8 	str.w	r5, [r4, #248]	; 0xf8
		retval = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
   2736c:	2102      	movs	r1, #2
   2736e:	4610      	mov	r0, r2
		mfy_sched_offset->param = (void *)conn;
   27370:	e9c3 4802 	strd	r4, r8, [r3, #8]
		retval = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
   27374:	f00d f97c 	bl	34670 <mayfly_enqueue>
		LL_ASSERT(!retval);
   27378:	b160      	cbz	r0, 27394 <event_conn_upd_prep+0x3ec>
   2737a:	4aa0      	ldr	r2, [pc, #640]	; (275fc <event_conn_upd_prep+0x654>)
   2737c:	49a0      	ldr	r1, [pc, #640]	; (27600 <event_conn_upd_prep+0x658>)
   2737e:	48a1      	ldr	r0, [pc, #644]	; (27604 <event_conn_upd_prep+0x65c>)
   27380:	f640 433d 	movw	r3, #3133	; 0xc3d
   27384:	f021 fe7e 	bl	49084 <assert_print>
   27388:	4040      	eors	r0, r0
   2738a:	f380 8811 	msr	BASEPRI, r0
   2738e:	f04f 0003 	mov.w	r0, #3
   27392:	df02      	svc	2
			return -EINPROGRESS;
   27394:	f06f 0076 	mvn.w	r0, #118	; 0x76
}
   27398:	b00b      	add	sp, #44	; 0x2c
   2739a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			ticks_at_expire -= HAL_TICKER_US_TO_TICKS(
   2739e:	fb09 1113 	mls	r1, r9, r3, r1
   273a2:	4899      	ldr	r0, [pc, #612]	; (27608 <event_conn_upd_prep+0x660>)
   273a4:	f240 43e2 	movw	r3, #1250	; 0x4e2
   273a8:	b289      	uxth	r1, r1
   273aa:	fb03 f101 	mul.w	r1, r3, r1
   273ae:	fba1 0100 	umull	r0, r1, r1, r0
   273b2:	a38b      	add	r3, pc, #556	; (adr r3, 275e0 <event_conn_upd_prep+0x638>)
   273b4:	e9d3 2300 	ldrd	r2, r3, [r3]
   273b8:	f7fe fea2 	bl	26100 <__aeabi_uldivmod>
   273bc:	1a3f      	subs	r7, r7, r0
   273be:	e698      	b.n	270f2 <event_conn_upd_prep+0x14a>
		LL_ASSERT(rx && rx->hdr.link);
   273c0:	4a8e      	ldr	r2, [pc, #568]	; (275fc <event_conn_upd_prep+0x654>)
   273c2:	4992      	ldr	r1, [pc, #584]	; (2760c <event_conn_upd_prep+0x664>)
   273c4:	488f      	ldr	r0, [pc, #572]	; (27604 <event_conn_upd_prep+0x65c>)
   273c6:	f640 43fa 	movw	r3, #3322	; 0xcfa
   273ca:	f021 fe5b 	bl	49084 <assert_print>
   273ce:	4040      	eors	r0, r0
   273d0:	f380 8811 	msr	BASEPRI, r0
   273d4:	f04f 0003 	mov.w	r0, #3
   273d8:	df02      	svc	2
		conn->llcp_rx = rx->hdr.link->mem;
   273da:	f8d9 3000 	ldr.w	r3, [r9]
   273de:	e631      	b.n	27044 <event_conn_upd_prep+0x9c>
		switch (conn->llcp_cu.state) {
   273e0:	f06f 000f 	mvn.w	r0, #15
}
   273e4:	b00b      	add	sp, #44	; 0x2c
   273e6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		switch (conn->llcp_cu.state) {
   273ea:	f8df 8224 	ldr.w	r8, [pc, #548]	; 27610 <event_conn_upd_prep+0x668>
   273ee:	e767      	b.n	272c0 <event_conn_upd_prep+0x318>
	return 0;
}

static void cpr_cache_initiate_or_complete(struct ll_conn *conn)
{
	if (conn->llcp_conn_param.cache.timeout) {
   273f0:	f8b4 11a6 	ldrh.w	r1, [r4, #422]	; 0x1a6
			conn->llcp_ack = conn->llcp_req;
   273f4:	f894 00f0 	ldrb.w	r0, [r4, #240]	; 0xf0
			conn->llcp_cu.ack = conn->llcp_cu.req;
   273f8:	f894 2118 	ldrb.w	r2, [r4, #280]	; 0x118
			conn->llcp_ack = conn->llcp_req;
   273fc:	f884 00f1 	strb.w	r0, [r4, #241]	; 0xf1
			conn->llcp_cu.ack = conn->llcp_cu.req;
   27400:	f884 2119 	strb.w	r2, [r4, #281]	; 0x119
	if (conn->llcp_conn_param.cache.timeout) {
   27404:	2900      	cmp	r1, #0
   27406:	f040 8107 	bne.w	27618 <event_conn_upd_prep+0x670>
		conn->llcp_conn_param.remote = 0U;

		/* Invalidate cache */
		conn->llcp_conn_param.cache.timeout = 0U;
	} else {
		conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
   2740a:	f894 2194 	ldrb.w	r2, [r4, #404]	; 0x194
   2740e:	f884 2195 	strb.w	r2, [r4, #405]	; 0x195
	}
}

static inline void cpr_active_reset(void)
{
	conn_upd_curr = NULL;
   27412:	4977      	ldr	r1, [pc, #476]	; (275f0 <event_conn_upd_prep+0x648>)
				CONTAINER_OF(conn->llcp.conn_upd.pdu_win_offset,
   27414:	f8d4 20f8 	ldr.w	r2, [r4, #248]	; 0xf8
	    conn->tx_head &&
   27418:	f8d4 01dc 	ldr.w	r0, [r4, #476]	; 0x1dc
   2741c:	2500      	movs	r5, #0
   2741e:	600d      	str	r5, [r1, #0]
		if (!conn->tx_ctrl) {
   27420:	f8d4 51e0 	ldr.w	r5, [r4, #480]	; 0x1e0
			tx = CONTAINER_OF(pdu_ctrl_tx, struct node_tx, pdu);
   27424:	f1a2 0109 	sub.w	r1, r2, #9
	if (
   27428:	2800      	cmp	r0, #0
   2742a:	f000 8121 	beq.w	27670 <event_conn_upd_prep+0x6c8>
	    conn->tx_head &&
   2742e:	06db      	lsls	r3, r3, #27
   27430:	f100 811e 	bmi.w	27670 <event_conn_upd_prep+0x6c8>
	    !conn->llcp_enc.pause_tx &&
   27434:	f894 3176 	ldrb.w	r3, [r4, #374]	; 0x176
	    !conn->llcp_cu.pause_tx &&
   27438:	079f      	lsls	r7, r3, #30
   2743a:	f100 8119 	bmi.w	27670 <event_conn_upd_prep+0x6c8>
	    !conn->llcp_phy.pause_tx &&
   2743e:	f894 31d7 	ldrb.w	r3, [r4, #471]	; 0x1d7
   27442:	07de      	lsls	r6, r3, #31
   27444:	f100 8114 	bmi.w	27670 <event_conn_upd_prep+0x6c8>
		if (conn->tx_head == conn->tx_data) {
   27448:	f8d4 31e8 	ldr.w	r3, [r4, #488]	; 0x1e8
   2744c:	4298      	cmp	r0, r3
   2744e:	f000 8122 	beq.w	27696 <event_conn_upd_prep+0x6ee>
		} else if (!conn->tx_ctrl) {
   27452:	2d00      	cmp	r5, #0
   27454:	f000 812e 	beq.w	276b4 <event_conn_upd_prep+0x70c>
	tx->next = conn->tx_ctrl_last->next;
   27458:	f8d4 31e4 	ldr.w	r3, [r4, #484]	; 0x1e4
   2745c:	681b      	ldr	r3, [r3, #0]
   2745e:	f842 3c09 	str.w	r3, [r2, #-9]
	conn->tx_ctrl_last->next = tx;
   27462:	f8d4 31e4 	ldr.w	r3, [r4, #484]	; 0x1e4
   27466:	6019      	str	r1, [r3, #0]
	conn->tx_ctrl_last = tx;
   27468:	f8c4 11e4 	str.w	r1, [r4, #484]	; 0x1e4
	if (!tx->next) {
   2746c:	f852 3c09 	ldr.w	r3, [r2, #-9]
   27470:	2b00      	cmp	r3, #0
   27472:	f000 8108 	beq.w	27686 <event_conn_upd_prep+0x6de>
			return -ECANCELED;
   27476:	f06f 008b 	mvn.w	r0, #139	; 0x8b
   2747a:	e6fb      	b.n	27274 <event_conn_upd_prep+0x2cc>
						      conn->lll.latency + 6;
   2747c:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
				CONTAINER_OF(conn->llcp.conn_upd.pdu_win_offset,
   2747e:	f8d4 20f8 	ldr.w	r2, [r4, #248]	; 0xf8
						      conn->lll.latency + 6;
   27482:	3306      	adds	r3, #6
   27484:	4419      	add	r1, r3
   27486:	b289      	uxth	r1, r1
			conn->llcp.conn_upd.instant = event_counter +
   27488:	f8a4 10f4 	strh.w	r1, [r4, #244]	; 0xf4
			pdu_ctrl_tx->llctrl.conn_update_ind.instant =
   2748c:	8111      	strh	r1, [r2, #8]
			conn->llcp_cu.state = LLCP_CUI_STATE_INPROG;
   2748e:	f894 311a 	ldrb.w	r3, [r4, #282]	; 0x11a
		if (!conn->tx_ctrl) {
   27492:	f8d4 11e0 	ldr.w	r1, [r4, #480]	; 0x1e0
	    conn->tx_head &&
   27496:	f8d4 01dc 	ldr.w	r0, [r4, #476]	; 0x1dc
			conn->llcp_cu.state = LLCP_CUI_STATE_INPROG;
   2749a:	f023 0317 	bic.w	r3, r3, #23
   2749e:	f043 0310 	orr.w	r3, r3, #16
   274a2:	f884 311a 	strb.w	r3, [r4, #282]	; 0x11a
			tx = CONTAINER_OF(pdu_ctrl_tx, struct node_tx, pdu);
   274a6:	f1a2 0309 	sub.w	r3, r2, #9
		if (!conn->tx_ctrl) {
   274aa:	2900      	cmp	r1, #0
   274ac:	f000 80ee 	beq.w	2768c <event_conn_upd_prep+0x6e4>
	tx->next = conn->tx_ctrl_last->next;
   274b0:	f8d4 11e4 	ldr.w	r1, [r4, #484]	; 0x1e4
   274b4:	6809      	ldr	r1, [r1, #0]
   274b6:	f842 1c09 	str.w	r1, [r2, #-9]
	conn->tx_ctrl_last->next = tx;
   274ba:	f8d4 11e4 	ldr.w	r1, [r4, #484]	; 0x1e4
   274be:	600b      	str	r3, [r1, #0]
	conn->tx_ctrl_last = tx;
   274c0:	f8c4 31e4 	str.w	r3, [r4, #484]	; 0x1e4
	if (!tx->next) {
   274c4:	f852 2c09 	ldr.w	r2, [r2, #-9]
   274c8:	2a00      	cmp	r2, #0
   274ca:	f47f af63 	bne.w	27394 <event_conn_upd_prep+0x3ec>
		conn->tx_data_last = tx;
   274ce:	f8c4 31ec 	str.w	r3, [r4, #492]	; 0x1ec
   274d2:	e75f      	b.n	27394 <event_conn_upd_prep+0x3ec>
		    (RADIO_CONN_EVENTS(conn->llcp_cu.timeout * 10000U,
   274d4:	f240 41e2 	movw	r1, #1250	; 0x4e2
   274d8:	f8b4 2120 	ldrh.w	r2, [r4, #288]	; 0x120
   274dc:	fb01 f303 	mul.w	r3, r1, r3
   274e0:	f242 7110 	movw	r1, #10000	; 0x2710
   274e4:	fb01 3202 	mla	r2, r1, r2, r3
   274e8:	3a01      	subs	r2, #1
   274ea:	fbb2 f3f3 	udiv	r3, r2, r3
		    (conn->llcp_cu.latency != lll->latency) ||
   274ee:	f8b4 20c2 	ldrh.w	r2, [r4, #194]	; 0xc2
   274f2:	b29b      	uxth	r3, r3
   274f4:	429a      	cmp	r2, r3
   274f6:	f47f adb3 	bne.w	27060 <event_conn_upd_prep+0xb8>
			rx->hdr.type = NODE_RX_TYPE_RELEASE;
   274fa:	2301      	movs	r3, #1
			ll_rx_put(rx->hdr.link, rx);
   274fc:	f8d9 0000 	ldr.w	r0, [r9]
			rx->hdr.type = NODE_RX_TYPE_RELEASE;
   27500:	f889 3004 	strb.w	r3, [r9, #4]
			ll_rx_put(rx->hdr.link, rx);
   27504:	4649      	mov	r1, r9
   27506:	f010 fc3d 	bl	37d84 <ll_rx_put>
			ll_rx_sched();
   2750a:	f010 fc45 	bl	37d98 <ll_rx_sched>
   2750e:	e5c3      	b.n	27098 <event_conn_upd_prep+0xf0>
		if (conn->lll.role && (conn->periph.llcp_type != LLCP_NONE)) {
   27510:	f890 30e5 	ldrb.w	r3, [r0, #229]	; 0xe5
   27514:	2b00      	cmp	r3, #0
   27516:	f43f ad6f 	beq.w	26ff8 <event_conn_upd_prep+0x50>
			conn->periph.llcp_type = LLCP_NONE;
   2751a:	f880 20e5 	strb.w	r2, [r0, #229]	; 0xe5
   2751e:	e56f      	b.n	27000 <event_conn_upd_prep+0x58>
			mayfly_enable(TICKER_USER_ID_ULL_HIGH,
   27520:	2201      	movs	r2, #1
   27522:	2102      	movs	r1, #2
   27524:	4610      	mov	r0, r2
   27526:	f00d f86f 	bl	34608 <mayfly_enable>
   2752a:	e6a2      	b.n	27272 <event_conn_upd_prep+0x2ca>
				lll->periph.window_widening_periodic_us *
   2752c:	6c22      	ldr	r2, [r4, #64]	; 0x40
			lll->periph.window_widening_prepare_us -=
   2752e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   27530:	fb02 3318 	mls	r3, r2, r8, r3
   27534:	64a3      	str	r3, [r4, #72]	; 0x48
				ceiling_fraction(((lll_clock_ppm_local_get() +
   27536:	f018 fb89 	bl	3fc4c <lll_clock_ppm_local_get>
   2753a:	4605      	mov	r5, r0
   2753c:	f894 00e4 	ldrb.w	r0, [r4, #228]	; 0xe4
			ticks_at_expire -= HAL_TICKER_US_TO_TICKS(
   27540:	f8df 80c4 	ldr.w	r8, [pc, #196]	; 27608 <event_conn_upd_prep+0x660>
				ceiling_fraction(((lll_clock_ppm_local_get() +
   27544:	f3c0 00c2 	ubfx	r0, r0, #3, #3
   27548:	f018 fb82 	bl	3fc50 <lll_clock_ppm_get>
   2754c:	4405      	add	r5, r0
   2754e:	fb06 f505 	mul.w	r5, r6, r5
   27552:	4b30      	ldr	r3, [pc, #192]	; (27614 <event_conn_upd_prep+0x66c>)
				conn->llcp_cu.win_size * CONN_INT_UNIT_US;
   27554:	f894 2128 	ldrb.w	r2, [r4, #296]	; 0x128
				ceiling_fraction(((lll_clock_ppm_local_get() +
   27558:	f505 2574 	add.w	r5, r5, #999424	; 0xf4000
   2755c:	f205 253f 	addw	r5, r5, #575	; 0x23f
   27560:	fba3 3505 	umull	r3, r5, r3, r5
   27564:	0cad      	lsrs	r5, r5, #18
			lll->periph.window_widening_prepare_us +=
   27566:	6ca3      	ldr	r3, [r4, #72]	; 0x48
			lll->periph.window_widening_periodic_us =
   27568:	6425      	str	r5, [r4, #64]	; 0x40
				conn->llcp_cu.win_size * CONN_INT_UNIT_US;
   2756a:	fb0b f202 	mul.w	r2, fp, r2
				lll->periph.window_widening_periodic_us *
   2756e:	fb05 f00a 	mul.w	r0, r5, sl
			lll->periph.window_size_prepare_us =
   27572:	6522      	str	r2, [r4, #80]	; 0x50
				(conn_interval_us >> 1) - EVENT_IFS_US;
   27574:	0872      	lsrs	r2, r6, #1
			lll->periph.window_widening_prepare_us +=
   27576:	4403      	add	r3, r0
				(conn_interval_us >> 1) - EVENT_IFS_US;
   27578:	3a96      	subs	r2, #150	; 0x96
   2757a:	4293      	cmp	r3, r2
   2757c:	bf28      	it	cs
   2757e:	4613      	movcs	r3, r2
   27580:	e9c4 2311 	strd	r2, r3, [r4, #68]	; 0x44
			conn->periph.ticks_to_offset = 0U;
   27584:	2300      	movs	r3, #0
			ticks_at_expire -= HAL_TICKER_US_TO_TICKS(
   27586:	fba0 0108 	umull	r0, r1, r0, r8
			conn->periph.ticks_to_offset = 0U;
   2758a:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
			ticks_at_expire -= HAL_TICKER_US_TO_TICKS(
   2758e:	a314      	add	r3, pc, #80	; (adr r3, 275e0 <event_conn_upd_prep+0x638>)
   27590:	e9d3 2300 	ldrd	r2, r3, [r3]
   27594:	f7fe fdb4 	bl	26100 <__aeabi_uldivmod>
			ticks_win_offset = HAL_TICKER_US_TO_TICKS(
   27598:	4b16      	ldr	r3, [pc, #88]	; (275f4 <event_conn_upd_prep+0x64c>)
			ticks_at_expire -= HAL_TICKER_US_TO_TICKS(
   2759a:	1a3f      	subs	r7, r7, r0
			ticks_win_offset = HAL_TICKER_US_TO_TICKS(
   2759c:	f8d4 0124 	ldr.w	r0, [r4, #292]	; 0x124
   275a0:	fba3 3000 	umull	r3, r0, r3, r0
   275a4:	0a80      	lsrs	r0, r0, #10
   275a6:	fb0b f000 	mul.w	r0, fp, r0
   275aa:	fba0 0108 	umull	r0, r1, r0, r8
   275ae:	a30c      	add	r3, pc, #48	; (adr r3, 275e0 <event_conn_upd_prep+0x638>)
   275b0:	e9d3 2300 	ldrd	r2, r3, [r3]
   275b4:	f7fe fda4 	bl	26100 <__aeabi_uldivmod>
			periodic_us -= lll->periph.window_widening_periodic_us;
   275b8:	1b75      	subs	r5, r6, r5
		lll->interval = conn->llcp_cu.interval;
   275ba:	f8b4 911c 	ldrh.w	r9, [r4, #284]	; 0x11c
			ticks_win_offset = HAL_TICKER_US_TO_TICKS(
   275be:	f020 487f 	bic.w	r8, r0, #4278190080	; 0xff000000
			periodic_us -= lll->periph.window_widening_periodic_us;
   275c2:	e5b3      	b.n	2712c <event_conn_upd_prep+0x184>
	if (conn->llcp_conn_param.cache.timeout) {
   275c4:	f8b4 31a6 	ldrh.w	r3, [r4, #422]	; 0x1a6
   275c8:	bbe3      	cbnz	r3, 27644 <event_conn_upd_prep+0x69c>
		conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
   275ca:	f884 2195 	strb.w	r2, [r4, #405]	; 0x195
			conn->procedure_expire = 0U;
   275ce:	2300      	movs	r3, #0
   275d0:	f8a4 30c8 	strh.w	r3, [r4, #200]	; 0xc8
   275d4:	e525      	b.n	27022 <event_conn_upd_prep+0x7a>
		conn_upd_curr = conn;
   275d6:	601c      	str	r4, [r3, #0]
   275d8:	e685      	b.n	272e6 <event_conn_upd_prep+0x33e>
   275da:	bf00      	nop
   275dc:	f3af 8000 	nop.w
   275e0:	1afd498d 	.word	0x1afd498d
   275e4:	00000007 	.word	0x00000007
   275e8:	0003ee69 	.word	0x0003ee69
   275ec:	20005384 	.word	0x20005384
   275f0:	200058f0 	.word	0x200058f0
   275f4:	d1b71759 	.word	0xd1b71759
   275f8:	20000abc 	.word	0x20000abc
   275fc:	0005269c 	.word	0x0005269c
   27600:	00052458 	.word	0x00052458
   27604:	0005214c 	.word	0x0005214c
   27608:	3b9aca00 	.word	0x3b9aca00
   2760c:	00052768 	.word	0x00052768
   27610:	00028379 	.word	0x00028379
   27614:	431bde83 	.word	0x431bde83
		conn->llcp_conn_param.state = LLCP_CPR_STATE_REQ;
   27618:	f8b4 2196 	ldrh.w	r2, [r4, #406]	; 0x196
		conn->llcp_conn_param.interval_min =
   2761c:	f8d4 01a0 	ldr.w	r0, [r4, #416]	; 0x1a0
   27620:	f8c4 0198 	str.w	r0, [r4, #408]	; 0x198
		conn->llcp_conn_param.state = LLCP_CPR_STATE_REQ;
   27624:	f002 02c0 	and.w	r2, r2, #192	; 0xc0
		conn->llcp_conn_param.latency =
   27628:	f8b4 01a4 	ldrh.w	r0, [r4, #420]	; 0x1a4
   2762c:	f8a4 019c 	strh.w	r0, [r4, #412]	; 0x19c
		conn->llcp_conn_param.state = LLCP_CPR_STATE_REQ;
   27630:	f042 0210 	orr.w	r2, r2, #16
		conn->llcp_conn_param.cache.timeout = 0U;
   27634:	2000      	movs	r0, #0
		conn->llcp_conn_param.timeout =
   27636:	f8a4 119e 	strh.w	r1, [r4, #414]	; 0x19e
		conn->llcp_conn_param.state = LLCP_CPR_STATE_REQ;
   2763a:	f8a4 2196 	strh.w	r2, [r4, #406]	; 0x196
		conn->llcp_conn_param.cache.timeout = 0U;
   2763e:	f8a4 01a6 	strh.w	r0, [r4, #422]	; 0x1a6
   27642:	e6e6      	b.n	27412 <event_conn_upd_prep+0x46a>
		conn->llcp_conn_param.timeout =
   27644:	f8a4 319e 	strh.w	r3, [r4, #414]	; 0x19e
		conn->llcp_conn_param.state = LLCP_CPR_STATE_REQ;
   27648:	f8b4 3196 	ldrh.w	r3, [r4, #406]	; 0x196
   2764c:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   27650:	f043 0310 	orr.w	r3, r3, #16
   27654:	f8a4 3196 	strh.w	r3, [r4, #406]	; 0x196
		conn->llcp_conn_param.interval_min =
   27658:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
   2765c:	f8c4 3198 	str.w	r3, [r4, #408]	; 0x198
		conn->llcp_conn_param.latency =
   27660:	f8b4 31a4 	ldrh.w	r3, [r4, #420]	; 0x1a4
   27664:	f8a4 319c 	strh.w	r3, [r4, #412]	; 0x19c
		conn->llcp_conn_param.cache.timeout = 0U;
   27668:	2300      	movs	r3, #0
   2766a:	f8a4 31a6 	strh.w	r3, [r4, #422]	; 0x1a6
   2766e:	e7ae      	b.n	275ce <event_conn_upd_prep+0x626>
		if (!conn->tx_ctrl) {
   27670:	2d00      	cmp	r5, #0
   27672:	f47f aef1 	bne.w	27458 <event_conn_upd_prep+0x4b0>
			tx->next = conn->tx_head;
   27676:	f842 0c09 	str.w	r0, [r2, #-9]
				conn->tx_ctrl = tx;
   2767a:	e9c4 1177 	strd	r1, r1, [r4, #476]	; 0x1dc
				conn->tx_ctrl_last = tx;
   2767e:	e6f3      	b.n	27468 <event_conn_upd_prep+0x4c0>
			return -ENOBUFS;
   27680:	f06f 0068 	mvn.w	r0, #104	; 0x68
   27684:	e5f6      	b.n	27274 <event_conn_upd_prep+0x2cc>
		conn->tx_data_last = tx;
   27686:	f8c4 11ec 	str.w	r1, [r4, #492]	; 0x1ec
   2768a:	e6f4      	b.n	27476 <event_conn_upd_prep+0x4ce>
			tx->next = conn->tx_head;
   2768c:	f842 0c09 	str.w	r0, [r2, #-9]
				conn->tx_ctrl = tx;
   27690:	e9c4 3377 	strd	r3, r3, [r4, #476]	; 0x1dc
				conn->tx_ctrl_last = tx;
   27694:	e714      	b.n	274c0 <event_conn_upd_prep+0x518>
			conn->tx_data = conn->tx_data->next;
   27696:	6803      	ldr	r3, [r0, #0]
   27698:	f8c4 31e8 	str.w	r3, [r4, #488]	; 0x1e8
		if (!conn->tx_ctrl) {
   2769c:	2d00      	cmp	r5, #0
   2769e:	f47f aedb 	bne.w	27458 <event_conn_upd_prep+0x4b0>
			tx->next = conn->tx_head->next;
   276a2:	6803      	ldr	r3, [r0, #0]
   276a4:	f842 3c09 	str.w	r3, [r2, #-9]
			conn->tx_head->next = tx;
   276a8:	f8d4 31dc 	ldr.w	r3, [r4, #476]	; 0x1dc
   276ac:	6019      	str	r1, [r3, #0]
				conn->tx_ctrl = tx;
   276ae:	f8c4 11e0 	str.w	r1, [r4, #480]	; 0x1e0
				conn->tx_ctrl_last = tx;
   276b2:	e6d9      	b.n	27468 <event_conn_upd_prep+0x4c0>
	if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   276b4:	7903      	ldrb	r3, [r0, #4]
   276b6:	f003 0303 	and.w	r3, r3, #3
   276ba:	2b03      	cmp	r3, #3
   276bc:	d002      	beq.n	276c4 <event_conn_upd_prep+0x71c>
		conn->tx_ctrl = conn->tx_ctrl_last = conn->tx_head;
   276be:	e9c4 0078 	strd	r0, r0, [r4, #480]	; 0x1e0
   276c2:	e6c9      	b.n	27458 <event_conn_upd_prep+0x4b0>
	    ((pdu_data_tx->llctrl.opcode !=
   276c4:	79c3      	ldrb	r3, [r0, #7]
	if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   276c6:	2b03      	cmp	r3, #3
   276c8:	d0eb      	beq.n	276a2 <event_conn_upd_prep+0x6fa>
	      PDU_DATA_LLCTRL_TYPE_ENC_REQ) &&
   276ca:	2b0a      	cmp	r3, #10
   276cc:	d1f7      	bne.n	276be <event_conn_upd_prep+0x716>
   276ce:	e7e8      	b.n	276a2 <event_conn_upd_prep+0x6fa>
			LL_ASSERT(0);
   276d0:	4a07      	ldr	r2, [pc, #28]	; (276f0 <event_conn_upd_prep+0x748>)
   276d2:	4908      	ldr	r1, [pc, #32]	; (276f4 <event_conn_upd_prep+0x74c>)
   276d4:	4808      	ldr	r0, [pc, #32]	; (276f8 <event_conn_upd_prep+0x750>)
   276d6:	f640 439a 	movw	r3, #3226	; 0xc9a
   276da:	f021 fcd3 	bl	49084 <assert_print>
   276de:	4040      	eors	r0, r0
   276e0:	f380 8811 	msr	BASEPRI, r0
   276e4:	f04f 0003 	mov.w	r0, #3
   276e8:	df02      	svc	2
		void (*fp_mfy_select_or_use)(void *) = NULL;
   276ea:	f04f 0800 	mov.w	r8, #0
			break;
   276ee:	e5e7      	b.n	272c0 <event_conn_upd_prep+0x318>
   276f0:	0005269c 	.word	0x0005269c
   276f4:	000521ac 	.word	0x000521ac
   276f8:	0005214c 	.word	0x0005214c
   276fc:	00000000 	.word	0x00000000

00027700 <ull_periph_setup>:
static void ticker_update_latency_cancel_op_cb(uint32_t ticker_status,
					       void *param);

void ull_periph_setup(struct node_rx_hdr *rx, struct node_rx_ftr *ftr,
		     struct lll_conn *lll)
{
   27700:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	memq_link_t *link;
	uint16_t timeout;
	uint8_t chan_sel;
	void *node;

	adv = ((struct lll_adv *)ftr->param)->hdr.parent;
   27704:	680b      	ldr	r3, [r1, #0]
	conn = lll->hdr.parent;
   27706:	6814      	ldr	r4, [r2, #0]
	adv = ((struct lll_adv *)ftr->param)->hdr.parent;
   27708:	f8d3 9000 	ldr.w	r9, [r3]

	/* Populate the peripheral context */
	pdu_adv = (void *)((struct node_rx_pdu *)rx)->pdu;

	peer_addr_type = pdu_adv->tx_addr;
   2770c:	7f03      	ldrb	r3, [r0, #28]
{
   2770e:	b093      	sub	sp, #76	; 0x4c
	peer_addr_type = pdu_adv->tx_addr;
   27710:	f3c3 1b80 	ubfx	fp, r3, #6, #1
{
   27714:	4605      	mov	r5, r0
   27716:	460f      	mov	r7, r1
   27718:	4616      	mov	r6, r2
	memcpy(peer_addr, pdu_adv->connect_ind.init_addr, BDADDR_SIZE);
   2771a:	f100 011e 	add.w	r1, r0, #30
   2771e:	2206      	movs	r2, #6
   27720:	a810      	add	r0, sp, #64	; 0x40
	peer_addr_type = pdu_adv->tx_addr;
   27722:	f8cd b02c 	str.w	fp, [sp, #44]	; 0x2c
	memcpy(peer_addr, pdu_adv->connect_ind.init_addr, BDADDR_SIZE);
   27726:	f023 fba8 	bl	4ae7a <memcpy>
		peer_addr_type += 2;
	} else {
#else /* CONFIG_BT_CTLR_PRIVACY */
	if (1) {
#endif /* CONFIG_BT_CTLR_PRIVACY */
		memcpy(peer_id_addr, peer_addr, BDADDR_SIZE);
   2772a:	a910      	add	r1, sp, #64	; 0x40
   2772c:	2206      	movs	r2, #6
   2772e:	a80e      	add	r0, sp, #56	; 0x38
   27730:	f023 fba3 	bl	4ae7a <memcpy>
	 */
	link = rx->link;

#if defined(CONFIG_BT_CTLR_CHECK_SAME_PEER_CONN)
	const uint8_t peer_id_addr_type = (peer_addr_type & 0x01);
	const uint8_t own_id_addr_type = pdu_adv->rx_addr;
   27734:	f895 801c 	ldrb.w	r8, [r5, #28]
	link = rx->link;
   27738:	f8d5 c000 	ldr.w	ip, [r5]
   2773c:	f8cd c028 	str.w	ip, [sp, #40]	; 0x28
	const uint8_t own_id_addr_type = pdu_adv->rx_addr;
   27740:	ea4f 18d8 	mov.w	r8, r8, lsr #7
	const uint8_t *own_id_addr = adv->own_id_addr;
   27744:	f109 0a6b 	add.w	sl, r9, #107	; 0x6b

	/* Do not connect twice to the same peer */
	if (ull_conn_peer_connected(own_id_addr_type, own_id_addr,
   27748:	ab0e      	add	r3, sp, #56	; 0x38
   2774a:	465a      	mov	r2, fp
   2774c:	4651      	mov	r1, sl
   2774e:	4640      	mov	r0, r8
   27750:	f013 f830 	bl	3a7b4 <ull_conn_peer_connected>
   27754:	2800      	cmp	r0, #0
   27756:	d14c      	bne.n	277f2 <ull_periph_setup+0xf2>

		return;
	}

	/* Remember peer and own identity address */
	conn->peer_id_addr_type = peer_id_addr_type;
   27758:	f894 20d6 	ldrb.w	r2, [r4, #214]	; 0xd6
   2775c:	900c      	str	r0, [sp, #48]	; 0x30
   2775e:	f36b 0241 	bfi	r2, fp, #1, #1
   27762:	f884 20d6 	strb.w	r2, [r4, #214]	; 0xd6
	(void)memcpy(conn->peer_id_addr, peer_id_addr,
   27766:	a90e      	add	r1, sp, #56	; 0x38
   27768:	2206      	movs	r2, #6
   2776a:	f104 00dd 	add.w	r0, r4, #221	; 0xdd
   2776e:	f023 fb84 	bl	4ae7a <memcpy>
		     sizeof(conn->peer_id_addr));
	conn->own_id_addr_type = own_id_addr_type;
   27772:	f894 20d6 	ldrb.w	r2, [r4, #214]	; 0xd6
   27776:	f368 0200 	bfi	r2, r8, #0, #1
	(void)memcpy(conn->own_id_addr, own_id_addr,
   2777a:	4651      	mov	r1, sl
	conn->own_id_addr_type = own_id_addr_type;
   2777c:	f884 20d6 	strb.w	r2, [r4, #214]	; 0xd6
	(void)memcpy(conn->own_id_addr, own_id_addr,
   27780:	f104 00d7 	add.w	r0, r4, #215	; 0xd7
   27784:	2206      	movs	r2, #6
   27786:	f023 fb78 	bl	4ae7a <memcpy>
		     sizeof(conn->own_id_addr));
#endif /* CONFIG_BT_CTLR_CHECK_SAME_PEER_CONN */

	memcpy(&lll->crc_init[0], &pdu_adv->connect_ind.crc_init[0], 3);
	memcpy(&lll->access_addr[0], &pdu_adv->connect_ind.access_addr[0], 4);
   2778a:	f106 0804 	add.w	r8, r6, #4
	memcpy(&lll->crc_init[0], &pdu_adv->connect_ind.crc_init[0], 3);
   2778e:	2203      	movs	r2, #3
   27790:	f105 012e 	add.w	r1, r5, #46	; 0x2e
   27794:	f106 0008 	add.w	r0, r6, #8
   27798:	f023 fb6f 	bl	4ae7a <memcpy>
	memcpy(&lll->data_chan_map[0], &pdu_adv->connect_ind.chan_map[0],
   2779c:	f106 0a18 	add.w	sl, r6, #24
	memcpy(&lll->access_addr[0], &pdu_adv->connect_ind.access_addr[0], 4);
   277a0:	2204      	movs	r2, #4
   277a2:	f105 012a 	add.w	r1, r5, #42	; 0x2a
   277a6:	4640      	mov	r0, r8
   277a8:	f023 fb67 	bl	4ae7a <memcpy>
	memcpy(&lll->data_chan_map[0], &pdu_adv->connect_ind.chan_map[0],
   277ac:	2205      	movs	r2, #5
   277ae:	f105 013a 	add.w	r1, r5, #58	; 0x3a
   277b2:	4650      	mov	r0, sl
   277b4:	f023 fb61 	bl	4ae7a <memcpy>
	       sizeof(lll->data_chan_map));
	lll->data_chan_count = util_ones_count_get(&lll->data_chan_map[0],
   277b8:	2105      	movs	r1, #5
   277ba:	4650      	mov	r0, sl
   277bc:	f00d f85e 	bl	3487c <util_ones_count_get>
   277c0:	7f72      	ldrb	r2, [r6, #29]
   277c2:	f000 003f 	and.w	r0, r0, #63	; 0x3f
   277c6:	f360 0205 	bfi	r2, r0, #0, #6
   277ca:	7772      	strb	r2, [r6, #29]
			       sizeof(lll->data_chan_map));
	lll->data_chan_hop = pdu_adv->connect_ind.hop;
   277cc:	f895 203f 	ldrb.w	r2, [r5, #63]	; 0x3f
   277d0:	f3c2 0104 	ubfx	r1, r2, #0, #5
   277d4:	77b1      	strb	r1, [r6, #30]
	lll->interval = sys_le16_to_cpu(pdu_adv->connect_ind.interval);
   277d6:	8ea9      	ldrh	r1, [r5, #52]	; 0x34
   277d8:	81f1      	strh	r1, [r6, #14]
	if ((lll->data_chan_count < CHM_USED_COUNT_MIN) ||
   277da:	2801      	cmp	r0, #1
	lll->data_chan_hop = pdu_adv->connect_ind.hop;
   277dc:	f002 021f 	and.w	r2, r2, #31
	lll->interval = sys_le16_to_cpu(pdu_adv->connect_ind.interval);
   277e0:	b289      	uxth	r1, r1
	if ((lll->data_chan_count < CHM_USED_COUNT_MIN) ||
   277e2:	d906      	bls.n	277f2 <ull_periph_setup+0xf2>
   277e4:	321b      	adds	r2, #27
   277e6:	f002 021f 	and.w	r2, r2, #31
   277ea:	2a0b      	cmp	r2, #11
   277ec:	d801      	bhi.n	277f2 <ull_periph_setup+0xf2>
	    (lll->data_chan_hop < CHM_HOP_COUNT_MIN) ||
	    (lll->data_chan_hop > CHM_HOP_COUNT_MAX) ||
   277ee:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   277f0:	b9c9      	cbnz	r1, 27826 <ull_periph_setup+0x126>

static void invalid_release(struct ull_hdr *hdr, struct lll_conn *lll,
			    memq_link_t *link, struct node_rx_hdr *rx)
{
	/* Reset the advertising disabled callback */
	hdr->disabled_cb = NULL;
   277f2:	2200      	movs	r2, #0
   277f4:	f8c9 2014 	str.w	r2, [r9, #20]

	/* Let the advertiser continue with connectable advertising */
	lll->periph.initiated = 0U;
   277f8:	f896 3020 	ldrb.w	r3, [r6, #32]
		 * connection rx node.
		 */
		rx_csa = rx->rx_ftr.extra;

		/* Enqueue the connection event to be release */
		ll_rx_put(link, rx);
   277fc:	980a      	ldr	r0, [sp, #40]	; 0x28
	lll->periph.initiated = 0U;
   277fe:	f362 0300 	bfi	r3, r2, #0, #1
   27802:	f886 3020 	strb.w	r3, [r6, #32]
		rx_csa = rx->rx_ftr.extra;
   27806:	68ec      	ldr	r4, [r5, #12]
	rx->type = NODE_RX_TYPE_RELEASE;
   27808:	2601      	movs	r6, #1
		ll_rx_put(link, rx);
   2780a:	4629      	mov	r1, r5
	rx->type = NODE_RX_TYPE_RELEASE;
   2780c:	712e      	strb	r6, [r5, #4]
		ll_rx_put(link, rx);
   2780e:	f010 fab9 	bl	37d84 <ll_rx_put>
		/* Mark for buffer for release */
		rx->type = NODE_RX_TYPE_RELEASE;
	}

	/* Enqueue connection or CSA event to be release */
	ll_rx_put(link, rx);
   27812:	6820      	ldr	r0, [r4, #0]
		rx->type = NODE_RX_TYPE_RELEASE;
   27814:	7126      	strb	r6, [r4, #4]
	ll_rx_put(link, rx);
   27816:	4621      	mov	r1, r4
   27818:	f010 fab4 	bl	37d84 <ll_rx_put>
	ll_rx_sched();
   2781c:	f010 fabc 	bl	37d98 <ll_rx_sched>
}
   27820:	b013      	add	sp, #76	; 0x4c
   27822:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	((struct lll_adv *)ftr->param)->conn = NULL;
   27826:	683a      	ldr	r2, [r7, #0]
   27828:	6053      	str	r3, [r2, #4]
	lll->latency = sys_le16_to_cpu(pdu_adv->connect_ind.latency);
   2782a:	8eeb      	ldrh	r3, [r5, #54]	; 0x36
   2782c:	8233      	strh	r3, [r6, #16]
	conn->periph.sca = pdu_adv->connect_ind.sca;
   2782e:	f895 303f 	ldrb.w	r3, [r5, #63]	; 0x3f
   27832:	f894 20e4 	ldrb.w	r2, [r4, #228]	; 0xe4
	conn_interval_us = lll->interval * CONN_INT_UNIT_US;
   27836:	f8b6 a00e 	ldrh.w	sl, [r6, #14]
	conn->periph.sca = pdu_adv->connect_ind.sca;
   2783a:	095b      	lsrs	r3, r3, #5
   2783c:	f363 02c5 	bfi	r2, r3, #3, #3
	win_offset = sys_le16_to_cpu(pdu_adv->connect_ind.win_offset);
   27840:	8e6b      	ldrh	r3, [r5, #50]	; 0x32
	conn->periph.sca = pdu_adv->connect_ind.sca;
   27842:	f884 20e4 	strb.w	r2, [r4, #228]	; 0xe4
	conn_interval_us = lll->interval * CONN_INT_UNIT_US;
   27846:	f240 42e2 	movw	r2, #1250	; 0x4e2
   2784a:	fb02 fa0a 	mul.w	sl, r2, sl
	win_offset = sys_le16_to_cpu(pdu_adv->connect_ind.win_offset);
   2784e:	930d      	str	r3, [sp, #52]	; 0x34
		ceiling_fraction(((lll_clock_ppm_local_get() +
   27850:	f018 f9fc 	bl	3fc4c <lll_clock_ppm_local_get>
   27854:	4683      	mov	fp, r0
   27856:	f894 00e4 	ldrb.w	r0, [r4, #228]	; 0xe4
   2785a:	f3c0 00c2 	ubfx	r0, r0, #3, #3
   2785e:	f018 f9f7 	bl	3fc50 <lll_clock_ppm_get>
   27862:	eb0b 0300 	add.w	r3, fp, r0
   27866:	fb0a f303 	mul.w	r3, sl, r3
   2786a:	49af      	ldr	r1, [pc, #700]	; (27b28 <ull_periph_setup+0x428>)
   2786c:	f503 2374 	add.w	r3, r3, #999424	; 0xf4000
   27870:	f203 233f 	addw	r3, r3, #575	; 0x23f
   27874:	fba1 1303 	umull	r1, r3, r1, r3
   27878:	0c9b      	lsrs	r3, r3, #18
	lll->periph.window_widening_periodic_us =
   2787a:	6273      	str	r3, [r6, #36]	; 0x24
	lll->periph.window_widening_max_us = (conn_interval_us >> 1) -
   2787c:	ea4f 035a 	mov.w	r3, sl, lsr #1
   27880:	3b96      	subs	r3, #150	; 0x96
   27882:	62b3      	str	r3, [r6, #40]	; 0x28
	lll->periph.window_size_event_us = pdu_adv->connect_ind.win_size *
   27884:	f895 3031 	ldrb.w	r3, [r5, #49]	; 0x31
   27888:	f240 42e2 	movw	r2, #1250	; 0x4e2
   2788c:	fb02 f303 	mul.w	r3, r2, r3
   27890:	63b3      	str	r3, [r6, #56]	; 0x38
	timeout = sys_le16_to_cpu(pdu_adv->connect_ind.timeout);
   27892:	f8b5 b038 	ldrh.w	fp, [r5, #56]	; 0x38
		RADIO_CONN_EVENTS((40 * 1000 * 1000), conn_interval_us);
   27896:	4aa5      	ldr	r2, [pc, #660]	; (27b2c <ull_periph_setup+0x42c>)
	conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
   27898:	4ba5      	ldr	r3, [pc, #660]	; (27b30 <ull_periph_setup+0x430>)
		RADIO_CONN_EVENTS((timeout * 10U * 1000U), conn_interval_us);
   2789a:	f242 7110 	movw	r1, #10000	; 0x2710
		RADIO_CONN_EVENTS((40 * 1000 * 1000), conn_interval_us);
   2789e:	4452      	add	r2, sl
   278a0:	fbb2 f2fa 	udiv	r2, r2, sl
   278a4:	f8a4 20c6 	strh.w	r2, [r4, #198]	; 0xc6
	timeout = sys_le16_to_cpu(pdu_adv->connect_ind.timeout);
   278a8:	fa1f f28b 	uxth.w	r2, fp
		RADIO_CONN_EVENTS((timeout * 10U * 1000U), conn_interval_us);
   278ac:	fb01 a202 	mla	r2, r1, r2, sl
	conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
   278b0:	4453      	add	r3, sl
		RADIO_CONN_EVENTS((timeout * 10U * 1000U), conn_interval_us);
   278b2:	3a01      	subs	r2, #1
	conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
   278b4:	fbb3 f3fa 	udiv	r3, r3, sl
		RADIO_CONN_EVENTS((timeout * 10U * 1000U), conn_interval_us);
   278b8:	fbb2 f2fa 	udiv	r2, r2, sl
   278bc:	f8a4 20c2 	strh.w	r2, [r4, #194]	; 0xc2
	conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
   278c0:	b29a      	uxth	r2, r3
   278c2:	f8a4 20ce 	strh.w	r2, [r4, #206]	; 0xce
	conn->appto_reload = (conn->apto_reload > (lll->latency + 6)) ?
   278c6:	8a31      	ldrh	r1, [r6, #16]
   278c8:	1d88      	adds	r0, r1, #6
   278ca:	4282      	cmp	r2, r0
   278cc:	dd04      	ble.n	278d8 <ull_periph_setup+0x1d8>
   278ce:	f5c1 417f 	rsb	r1, r1, #65280	; 0xff00
   278d2:	31fa      	adds	r1, #250	; 0xfa
   278d4:	440a      	add	r2, r1
   278d6:	b292      	uxth	r2, r2
   278d8:	f8a4 20ca 	strh.w	r2, [r4, #202]	; 0xca
	memcpy((void *)&conn->periph.force, &lll->access_addr[0],
   278dc:	4641      	mov	r1, r8
   278de:	2204      	movs	r2, #4
   278e0:	f104 00e8 	add.w	r0, r4, #232	; 0xe8
   278e4:	f023 fac9 	bl	4ae7a <memcpy>
		chan_sel = pdu_adv->chan_sel;
   278e8:	462b      	mov	r3, r5
   278ea:	f813 2f1c 	ldrb.w	r2, [r3, #28]!
   278ee:	f3c2 1240 	ubfx	r2, r2, #5, #1
   278f2:	920c      	str	r2, [sp, #48]	; 0x30
	LL_ASSERT(IS_PTR_ALIGNED(node, struct node_rx_cc));
   278f4:	07da      	lsls	r2, r3, #31
   278f6:	f100 80dd 	bmi.w	27ab4 <ull_periph_setup+0x3b4>
	cc->peer_addr_type = peer_addr_type;
   278fa:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
   278fe:	77ab      	strb	r3, [r5, #30]
	cc->status = 0U;
   27900:	f44f 7380 	mov.w	r3, #256	; 0x100
	memcpy(cc->peer_addr, peer_id_addr, BDADDR_SIZE);
   27904:	2206      	movs	r2, #6
   27906:	a90e      	add	r1, sp, #56	; 0x38
	cc->status = 0U;
   27908:	83ab      	strh	r3, [r5, #28]
	memcpy(cc->peer_addr, peer_id_addr, BDADDR_SIZE);
   2790a:	f105 001f 	add.w	r0, r5, #31
   2790e:	f023 fab4 	bl	4ae7a <memcpy>
	cc->interval = lll->interval;
   27912:	89f3      	ldrh	r3, [r6, #14]
   27914:	84eb      	strh	r3, [r5, #38]	; 0x26
	cc->latency = lll->latency;
   27916:	8a33      	ldrh	r3, [r6, #16]
   27918:	852b      	strh	r3, [r5, #40]	; 0x28
	cc->timeout = timeout;
   2791a:	f8a5 b02a 	strh.w	fp, [r5, #42]	; 0x2a
	cc->sca = conn->periph.sca;
   2791e:	f894 30e4 	ldrb.w	r3, [r4, #228]	; 0xe4
   27922:	f3c3 03c2 	ubfx	r3, r3, #3, #3
   27926:	f885 302c 	strb.w	r3, [r5, #44]	; 0x2c
	lll->handle = ll_conn_handle_get(conn);
   2792a:	4620      	mov	r0, r4
   2792c:	f012 fbce 	bl	3a0cc <ll_conn_handle_get>
   27930:	81b0      	strh	r0, [r6, #12]
	rx->handle = lll->handle;
   27932:	80e8      	strh	r0, [r5, #6]
		ll_rx_put(link, rx);
   27934:	4629      	mov	r1, r5
   27936:	980a      	ldr	r0, [sp, #40]	; 0x28
		rx_csa = (void *)ftr->extra;
   27938:	687d      	ldr	r5, [r7, #4]
		ll_rx_put(link, rx);
   2793a:	f010 fa23 	bl	37d84 <ll_rx_put>
		rx->handle = lll->handle;
   2793e:	89b3      	ldrh	r3, [r6, #12]
		if (chan_sel) {
   27940:	9a0c      	ldr	r2, [sp, #48]	; 0x30
		rx->handle = lll->handle;
   27942:	80eb      	strh	r3, [r5, #6]
		rx->type = NODE_RX_TYPE_CHAN_SEL_ALGO;
   27944:	231c      	movs	r3, #28
   27946:	712b      	strb	r3, [r5, #4]
		link = rx->link;
   27948:	682b      	ldr	r3, [r5, #0]
		if (chan_sel) {
   2794a:	2a00      	cmp	r2, #0
   2794c:	f040 80c7 	bne.w	27ade <ull_periph_setup+0x3de>
   27950:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
			cs->csa = 0x00;
   27954:	f885 b01c 	strb.w	fp, [r5, #28]
	ll_rx_put(link, rx);
   27958:	4618      	mov	r0, r3
   2795a:	4629      	mov	r1, r5
   2795c:	f010 fa12 	bl	37d84 <ll_rx_put>
	ll_rx_sched();
   27960:	f010 fa1a 	bl	37d98 <ll_rx_sched>
	ready_delay_us = lll_radio_rx_ready_delay_get(lll->phy_rx, 1);
   27964:	f896 0045 	ldrb.w	r0, [r6, #69]	; 0x45
	max_tx_time = lll->max_tx_time;
   27968:	f8b6 8040 	ldrh.w	r8, [r6, #64]	; 0x40
	max_rx_time = lll->max_rx_time;
   2796c:	f8b6 5042 	ldrh.w	r5, [r6, #66]	; 0x42
	ready_delay_us = lll_radio_rx_ready_delay_get(lll->phy_rx, 1);
   27970:	2101      	movs	r1, #1
   27972:	f000 0007 	and.w	r0, r0, #7
   27976:	f017 ff7b 	bl	3f870 <lll_radio_rx_ready_delay_get>
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
   2797a:	4445      	add	r5, r8
   2797c:	f505 7561 	add.w	r5, r5, #900	; 0x384
   27980:	1829      	adds	r1, r5, r0
	ready_delay_us = lll_radio_rx_ready_delay_get(lll->phy_rx, 1);
   27982:	4683      	mov	fp, r0
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
   27984:	486b      	ldr	r0, [pc, #428]	; (27b34 <ull_periph_setup+0x434>)
	conn->ull.ticks_active_to_start = 0U;
   27986:	f04f 0800 	mov.w	r8, #0
	conn->ull.ticks_prepare_to_start =
   2798a:	2331      	movs	r3, #49	; 0x31
   2798c:	60a3      	str	r3, [r4, #8]
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
   2798e:	fba1 0100 	umull	r0, r1, r1, r0
   27992:	a363      	add	r3, pc, #396	; (adr r3, 27b20 <ull_periph_setup+0x420>)
   27994:	e9d3 2300 	ldrd	r2, r3, [r3]
	conn->ull.ticks_active_to_start = 0U;
   27998:	f8c4 8004 	str.w	r8, [r4, #4]
	conn->ull.ticks_preempt_to_start =
   2799c:	f8c4 800c 	str.w	r8, [r4, #12]
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
   279a0:	f7fe fbae 	bl	26100 <__aeabi_uldivmod>
   279a4:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	conn->ull.ticks_slot =
   279a8:	6120      	str	r0, [r4, #16]
	conn_offset_us += win_offset * CONN_INT_UNIT_US;
   279aa:	990d      	ldr	r1, [sp, #52]	; 0x34
	conn_offset_us = ftr->radio_end_us;
   279ac:	68fb      	ldr	r3, [r7, #12]
	conn_interval_us -= lll->periph.window_widening_periodic_us;
   279ae:	6a75      	ldr	r5, [r6, #36]	; 0x24
	conn_offset_us += win_offset * CONN_INT_UNIT_US;
   279b0:	f240 42e2 	movw	r2, #1250	; 0x4e2
   279b4:	fb02 3301 	mla	r3, r2, r1, r3
	conn_offset_us -= EVENT_JITTER_US;
   279b8:	f203 43b2 	addw	r3, r3, #1202	; 0x4b2
	conn_offset_us -= ready_delay_us;
   279bc:	eba3 030b 	sub.w	r3, r3, fp
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 0);
   279c0:	4642      	mov	r2, r8
   279c2:	2102      	movs	r1, #2
   279c4:	2001      	movs	r0, #1
	conn_offset_us -= ready_delay_us;
   279c6:	930a      	str	r3, [sp, #40]	; 0x28
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 0);
   279c8:	f00c fe1e 	bl	34608 <mayfly_enable>
	ticker_id_adv = TICKER_ID_ADV_BASE + ull_adv_handle_get(adv);
   279cc:	4648      	mov	r0, r9
   279ce:	f011 fae9 	bl	38fa4 <ull_adv_handle_get>
   279d2:	1c82      	adds	r2, r0, #2
	ticker_status = ticker_stop(TICKER_INSTANCE_ID_CTLR,
   279d4:	4b58      	ldr	r3, [pc, #352]	; (27b38 <ull_periph_setup+0x438>)
   279d6:	f8cd 9000 	str.w	r9, [sp]
   279da:	b2d2      	uxtb	r2, r2
   279dc:	4640      	mov	r0, r8
   279de:	2101      	movs	r1, #1
   279e0:	f00e f86c 	bl	35abc <ticker_stop>
}

static void ticker_op_stop_adv_cb(uint32_t status, void *param)
{
	LL_ASSERT(status != TICKER_STATUS_FAILURE ||
   279e4:	2801      	cmp	r0, #1
	conn_interval_us -= lll->periph.window_widening_periodic_us;
   279e6:	ebaa 0505 	sub.w	r5, sl, r5
	LL_ASSERT(status != TICKER_STATUS_FAILURE ||
   279ea:	f000 8085 	beq.w	27af8 <ull_periph_setup+0x3f8>
	if (adv->lll.is_hdcd) {
   279ee:	f899 3024 	ldrb.w	r3, [r9, #36]	; 0x24
   279f2:	07db      	lsls	r3, r3, #31
   279f4:	d46b      	bmi.n	27ace <ull_periph_setup+0x3ce>
	ticker_id_conn = TICKER_ID_CONN_BASE + ll_conn_handle_get(conn);
   279f6:	4620      	mov	r0, r4
   279f8:	f012 fb68 	bl	3a0cc <ll_conn_handle_get>
				     HAL_TICKER_US_TO_TICKS(conn_interval_us),
   279fc:	f8df 9134 	ldr.w	r9, [pc, #308]	; 27b34 <ull_periph_setup+0x434>
   27a00:	fba5 8509 	umull	r8, r5, r5, r9
   27a04:	a346      	add	r3, pc, #280	; (adr r3, 27b20 <ull_periph_setup+0x420>)
   27a06:	e9d3 2300 	ldrd	r2, r3, [r3]
	ticker_id_conn = TICKER_ID_CONN_BASE + ll_conn_handle_get(conn);
   27a0a:	4682      	mov	sl, r0
				     HAL_TICKER_US_TO_TICKS(conn_interval_us),
   27a0c:	4629      	mov	r1, r5
   27a0e:	4640      	mov	r0, r8
   27a10:	f7fe fb76 	bl	26100 <__aeabi_uldivmod>
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
   27a14:	68bb      	ldr	r3, [r7, #8]
   27a16:	4a49      	ldr	r2, [pc, #292]	; (27b3c <ull_periph_setup+0x43c>)
   27a18:	9207      	str	r2, [sp, #28]
	ticker_id_conn = TICKER_ID_CONN_BASE + ll_conn_handle_get(conn);
   27a1a:	f10a 0705 	add.w	r7, sl, #5
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
   27a1e:	f1a3 0a49 	sub.w	sl, r3, #73	; 0x49
				     HAL_TICKER_REMAINDER(conn_interval_us),
   27a22:	4b47      	ldr	r3, [pc, #284]	; (27b40 <ull_periph_setup+0x440>)
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
   27a24:	9406      	str	r4, [sp, #24]
				     HAL_TICKER_REMAINDER(conn_interval_us),
   27a26:	f020 467f 	bic.w	r6, r0, #4278190080	; 0xff000000
   27a2a:	fba6 3103 	umull	r3, r1, r6, r3
   27a2e:	ebb8 0003 	subs.w	r0, r8, r3
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
   27a32:	4b44      	ldr	r3, [pc, #272]	; (27b44 <ull_periph_setup+0x444>)
   27a34:	9305      	str	r3, [sp, #20]
   27a36:	f44f 73eb 	mov.w	r3, #470	; 0x1d6
   27a3a:	9308      	str	r3, [sp, #32]
   27a3c:	6923      	ldr	r3, [r4, #16]
   27a3e:	f04f 0b00 	mov.w	fp, #0
   27a42:	e9cd b303 	strd	fp, r3, [sp, #12]
				     HAL_TICKER_REMAINDER(conn_interval_us),
   27a46:	f04f 0307 	mov.w	r3, #7
   27a4a:	fb03 1106 	mla	r1, r3, r6, r1
   27a4e:	eb65 0101 	sbc.w	r1, r5, r1
   27a52:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   27a56:	2300      	movs	r3, #0
   27a58:	f7fe fb52 	bl	26100 <__aeabi_uldivmod>
				     HAL_TICKER_US_TO_TICKS(conn_offset_us),
   27a5c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
   27a5e:	e9cd 6001 	strd	r6, r0, [sp, #4]
				     HAL_TICKER_US_TO_TICKS(conn_offset_us),
   27a62:	fba3 0109 	umull	r0, r1, r3, r9
   27a66:	a32e      	add	r3, pc, #184	; (adr r3, 27b20 <ull_periph_setup+0x420>)
   27a68:	e9d3 2300 	ldrd	r2, r3, [r3]
   27a6c:	f7fe fb48 	bl	26100 <__aeabi_uldivmod>
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
   27a70:	b2ff      	uxtb	r7, r7
   27a72:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
   27a76:	9000      	str	r0, [sp, #0]
   27a78:	4653      	mov	r3, sl
   27a7a:	463a      	mov	r2, r7
   27a7c:	2101      	movs	r1, #1
   27a7e:	4658      	mov	r0, fp
   27a80:	f00d ff90 	bl	359a4 <ticker_start>
	LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
   27a84:	f030 0302 	bics.w	r3, r0, #2
   27a88:	d00c      	beq.n	27aa4 <ull_periph_setup+0x3a4>
   27a8a:	4a2f      	ldr	r2, [pc, #188]	; (27b48 <ull_periph_setup+0x448>)
   27a8c:	492f      	ldr	r1, [pc, #188]	; (27b4c <ull_periph_setup+0x44c>)
   27a8e:	4830      	ldr	r0, [pc, #192]	; (27b50 <ull_periph_setup+0x450>)
   27a90:	f240 13d7 	movw	r3, #471	; 0x1d7
   27a94:	f021 faf6 	bl	49084 <assert_print>
   27a98:	4040      	eors	r0, r0
   27a9a:	f380 8811 	msr	BASEPRI, r0
   27a9e:	f04f 0003 	mov.w	r0, #3
   27aa2:	df02      	svc	2
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 1);
   27aa4:	2201      	movs	r2, #1
   27aa6:	2102      	movs	r1, #2
   27aa8:	4610      	mov	r0, r2
   27aaa:	f00c fdad 	bl	34608 <mayfly_enable>
}
   27aae:	b013      	add	sp, #76	; 0x4c
   27ab0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	LL_ASSERT(IS_PTR_ALIGNED(node, struct node_rx_cc));
   27ab4:	4a24      	ldr	r2, [pc, #144]	; (27b48 <ull_periph_setup+0x448>)
   27ab6:	4927      	ldr	r1, [pc, #156]	; (27b54 <ull_periph_setup+0x454>)
   27ab8:	4825      	ldr	r0, [pc, #148]	; (27b50 <ull_periph_setup+0x450>)
   27aba:	23ff      	movs	r3, #255	; 0xff
   27abc:	f021 fae2 	bl	49084 <assert_print>
   27ac0:	4040      	eors	r0, r0
   27ac2:	f380 8811 	msr	BASEPRI, r0
   27ac6:	f04f 0003 	mov.w	r0, #3
   27aca:	df02      	svc	2
   27acc:	e715      	b.n	278fa <ull_periph_setup+0x1fa>
		ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_ULL_HIGH,
   27ace:	2300      	movs	r3, #0
   27ad0:	2201      	movs	r2, #1
   27ad2:	9300      	str	r3, [sp, #0]
   27ad4:	4618      	mov	r0, r3
   27ad6:	4611      	mov	r1, r2
   27ad8:	f00d fff0 	bl	35abc <ticker_stop>
   27adc:	e78b      	b.n	279f6 <ull_periph_setup+0x2f6>
			lll->data_chan_sel = 1;
   27ade:	7f72      	ldrb	r2, [r6, #29]
   27ae0:	930a      	str	r3, [sp, #40]	; 0x28
   27ae2:	f042 0240 	orr.w	r2, r2, #64	; 0x40
			lll->data_chan_id = lll_chan_id(lll->access_addr);
   27ae6:	4640      	mov	r0, r8
			lll->data_chan_sel = 1;
   27ae8:	7772      	strb	r2, [r6, #29]
			lll->data_chan_id = lll_chan_id(lll->access_addr);
   27aea:	f017 fa73 	bl	3efd4 <lll_chan_id>
   27aee:	f04f 0b01 	mov.w	fp, #1
   27af2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   27af4:	83f0      	strh	r0, [r6, #30]
			cs->csa = 0x01;
   27af6:	e72d      	b.n	27954 <ull_periph_setup+0x254>
	LL_ASSERT(status != TICKER_STATUS_FAILURE ||
   27af8:	f010 fa24 	bl	37f44 <ull_disable_mark_get>
   27afc:	4581      	cmp	r9, r0
   27afe:	f43f af76 	beq.w	279ee <ull_periph_setup+0x2ee>
   27b02:	4a11      	ldr	r2, [pc, #68]	; (27b48 <ull_periph_setup+0x448>)
   27b04:	4914      	ldr	r1, [pc, #80]	; (27b58 <ull_periph_setup+0x458>)
   27b06:	4812      	ldr	r0, [pc, #72]	; (27b50 <ull_periph_setup+0x450>)
   27b08:	f240 23a1 	movw	r3, #673	; 0x2a1
   27b0c:	f021 faba 	bl	49084 <assert_print>
   27b10:	4040      	eors	r0, r0
   27b12:	f380 8811 	msr	BASEPRI, r0
   27b16:	f04f 0003 	mov.w	r0, #3
   27b1a:	df02      	svc	2
		  param == ull_disable_mark_get());
}
   27b1c:	e767      	b.n	279ee <ull_periph_setup+0x2ee>
   27b1e:	bf00      	nop
   27b20:	1afd498d 	.word	0x1afd498d
   27b24:	00000007 	.word	0x00000007
   27b28:	431bde83 	.word	0x431bde83
   27b2c:	026259ff 	.word	0x026259ff
   27b30:	01c9c37f 	.word	0x01c9c37f
   27b34:	3b9aca00 	.word	0x3b9aca00
   27b38:	0003e4b1 	.word	0x0003e4b1
   27b3c:	0003e481 	.word	0x0003e481
   27b40:	1afd498d 	.word	0x1afd498d
   27b44:	0003e4ed 	.word	0x0003e4ed
   27b48:	000528b4 	.word	0x000528b4
   27b4c:	0005277c 	.word	0x0005277c
   27b50:	0005214c 	.word	0x0005214c
   27b54:	00052260 	.word	0x00052260
   27b58:	00052910 	.word	0x00052910
   27b5c:	00000000 	.word	0x00000000

00027b60 <ll_create_connection>:
uint8_t ll_create_connection(uint16_t scan_interval, uint16_t scan_window,
			  uint8_t filter_policy, uint8_t peer_addr_type,
			  uint8_t const *const peer_addr, uint8_t own_addr_type,
			  uint16_t interval, uint16_t latency, uint16_t timeout)
#endif /* !CONFIG_BT_CTLR_ADV_EXT */
{
   27b60:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   27b64:	b08b      	sub	sp, #44	; 0x2c
   27b66:	e9cd 0104 	strd	r0, r1, [sp, #16]
	uint16_t max_rx_time;
	memq_link_t *link;
	uint8_t hop;
	int err;

	scan = ull_scan_is_disabled_get(SCAN_HANDLE_1M);
   27b6a:	2000      	movs	r0, #0
{
   27b6c:	f89d 9054 	ldrb.w	r9, [sp, #84]	; 0x54
   27b70:	f8bd a058 	ldrh.w	sl, [sp, #88]	; 0x58
   27b74:	f8bd b05c 	ldrh.w	fp, [sp, #92]	; 0x5c
   27b78:	f8bd 7060 	ldrh.w	r7, [sp, #96]	; 0x60
   27b7c:	9206      	str	r2, [sp, #24]
   27b7e:	461e      	mov	r6, r3
	scan = ull_scan_is_disabled_get(SCAN_HANDLE_1M);
   27b80:	f011 fbda 	bl	39338 <ull_scan_is_disabled_get>
	if (!scan) {
   27b84:	2800      	cmp	r0, #0
   27b86:	f000 81a7 	beq.w	27ed8 <ll_create_connection+0x378>
		return BT_HCI_ERR_CMD_DISALLOWED;
	}

	/* Check if random address has been set */
	own_id_addr_type = (own_addr_type & 0x01);
   27b8a:	f009 0401 	and.w	r4, r9, #1
	own_id_addr = ll_addr_get(own_id_addr_type);
   27b8e:	4605      	mov	r5, r0
   27b90:	4620      	mov	r0, r4
   27b92:	f00e f863 	bl	35c5c <ll_addr_get>
   27b96:	9003      	str	r0, [sp, #12]
	if (own_id_addr_type && !mem_nz((void *)own_id_addr, BDADDR_SIZE)) {
   27b98:	2c00      	cmp	r4, #0
   27b9a:	d156      	bne.n	27c4a <ll_create_connection+0xea>
		return BT_HCI_ERR_INVALID_PARAM;
	}

#if defined(CONFIG_BT_CTLR_CHECK_SAME_PEER_CONN)
	/* Do not connect twice to the same peer */
	if (ull_conn_peer_connected(own_id_addr_type, own_id_addr,
   27b9c:	9b14      	ldr	r3, [sp, #80]	; 0x50
   27b9e:	9903      	ldr	r1, [sp, #12]
   27ba0:	4620      	mov	r0, r4
   27ba2:	4632      	mov	r2, r6
   27ba4:	f012 fe06 	bl	3a7b4 <ull_conn_peer_connected>
   27ba8:	2800      	cmp	r0, #0
   27baa:	f040 8199 	bne.w	27ee0 <ll_create_connection+0x380>

#else /* !CONFIG_BT_CTLR_ADV_EXT */
	lll = &scan->lll;
#endif /* !CONFIG_BT_CTLR_ADV_EXT */

	if (lll->conn) {
   27bae:	6a2b      	ldr	r3, [r5, #32]
	lll = &scan->lll;
   27bb0:	f105 021c 	add.w	r2, r5, #28
   27bb4:	9207      	str	r2, [sp, #28]
	if (lll->conn) {
   27bb6:	2b00      	cmp	r3, #0
   27bb8:	d04e      	beq.n	27c58 <ll_create_connection+0xf8>
		conn_lll = lll->conn;
   27bba:	f8d5 8020 	ldr.w	r8, [r5, #32]
		conn = HDR_LLL2ULL(conn_lll);
   27bbe:	f8d8 4000 	ldr.w	r4, [r8]
	conn->ull.ticks_preempt_to_start =
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_PREEMPT_MIN_US);

#if defined(CONFIG_BT_CTLR_CHECK_SAME_PEER_CONN)
	/* Remember peer and own identity address */
	conn->peer_id_addr_type = peer_addr_type;
   27bc2:	f006 0601 	and.w	r6, r6, #1
	lll_hdr_init(&conn->lll, conn);

conn_is_valid:
#if defined(CONFIG_BT_CTLR_PHY)
	ready_delay_us = lll_radio_tx_ready_delay_get(conn_lll->phy_tx,
						      conn_lll->phy_flags);
   27bc6:	f898 0044 	ldrb.w	r0, [r8, #68]	; 0x44
	ready_delay_us = lll_radio_tx_ready_delay_get(conn_lll->phy_tx,
   27bca:	f3c0 01c0 	ubfx	r1, r0, #3, #1
   27bce:	f000 0007 	and.w	r0, r0, #7
   27bd2:	f017 fe4b 	bl	3f86c <lll_radio_tx_ready_delay_get>
	max_rx_time = PDU_DC_MAX_US(PDU_DC_PAYLOAD_SIZE_MIN, PHY_1M);
#endif /* !CONFIG_BT_CTLR_DATA_LENGTH */
#endif /* CONFIG_BT_LL_SW_LLCP_LEGACY */

	conn->ull.ticks_slot =
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
   27bd6:	f8b8 1040 	ldrh.w	r1, [r8, #64]	; 0x40
   27bda:	f8b8 3042 	ldrh.w	r3, [r8, #66]	; 0x42
   27bde:	f500 7061 	add.w	r0, r0, #900	; 0x384
   27be2:	4401      	add	r1, r0
   27be4:	48d8      	ldr	r0, [pc, #864]	; (27f48 <ll_create_connection+0x3e8>)
   27be6:	4419      	add	r1, r3
   27be8:	fba1 0100 	umull	r0, r1, r1, r0
   27bec:	a3d4      	add	r3, pc, #848	; (adr r3, 27f40 <ll_create_connection+0x3e0>)
   27bee:	e9d3 2300 	ldrd	r2, r3, [r3]
   27bf2:	f7fe fa85 	bl	26100 <__aeabi_uldivmod>
   27bf6:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	conn->ull.ticks_slot =
   27bfa:	6120      	str	r0, [r4, #16]
		own_addr_type &= 0x1;
		lll->rpa_gen = 1;
	}
#endif

	scan->own_addr_type = own_addr_type;
   27bfc:	f895 3040 	ldrb.w	r3, [r5, #64]	; 0x40
	lll->adv_addr_type = peer_addr_type;
	memcpy(lll->adv_addr, peer_addr, BDADDR_SIZE);
   27c00:	9914      	ldr	r1, [sp, #80]	; 0x50
	scan->own_addr_type = own_addr_type;
   27c02:	f369 0342 	bfi	r3, r9, #1, #2
   27c06:	f885 3040 	strb.w	r3, [r5, #64]	; 0x40
	lll->adv_addr_type = peer_addr_type;
   27c0a:	f895 3033 	ldrb.w	r3, [r5, #51]	; 0x33
   27c0e:	f366 0300 	bfi	r3, r6, #0, #1
   27c12:	f885 3033 	strb.w	r3, [r5, #51]	; 0x33
	memcpy(lll->adv_addr, peer_addr, BDADDR_SIZE);
   27c16:	2206      	movs	r2, #6
   27c18:	f105 0024 	add.w	r0, r5, #36	; 0x24
   27c1c:	f023 f92d 	bl	4ae7a <memcpy>
	lll->conn_timeout = timeout;

	ull_scan_params_set(lll, 0, scan_interval, scan_window, filter_policy);
   27c20:	9906      	ldr	r1, [sp, #24]
	lll->conn_timeout = timeout;
   27c22:	862f      	strh	r7, [r5, #48]	; 0x30
	ull_scan_params_set(lll, 0, scan_interval, scan_window, filter_policy);
   27c24:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   27c28:	f105 001c 	add.w	r0, r5, #28
   27c2c:	9100      	str	r1, [sp, #0]
   27c2e:	2100      	movs	r1, #0
   27c30:	f7ff f8de 	bl	26df0 <ull_scan_params_set>

#if defined(CONFIG_BT_CTLR_ADV_EXT)
	return 0;
#else /* !CONFIG_BT_CTLR_ADV_EXT */
	/* wait for stable clocks */
	err = lll_clock_wait();
   27c34:	f017 ffb8 	bl	3fba8 <lll_clock_wait>
	if (err) {
   27c38:	2800      	cmp	r0, #0
   27c3a:	f040 8155 	bne.w	27ee8 <ll_create_connection+0x388>
		conn_release(scan);

		return BT_HCI_ERR_HW_FAILURE;
	}

	return ull_scan_enable(scan);
   27c3e:	4628      	mov	r0, r5
   27c40:	f7ff f902 	bl	26e48 <ull_scan_enable>
#endif /* !CONFIG_BT_CTLR_ADV_EXT */
}
   27c44:	b00b      	add	sp, #44	; 0x2c
   27c46:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (own_id_addr_type && !mem_nz((void *)own_id_addr, BDADDR_SIZE)) {
   27c4a:	2106      	movs	r1, #6
   27c4c:	f00c fc80 	bl	34550 <mem_nz>
   27c50:	2800      	cmp	r0, #0
   27c52:	d1a3      	bne.n	27b9c <ll_create_connection+0x3c>
		return BT_HCI_ERR_INVALID_PARAM;
   27c54:	2012      	movs	r0, #18
   27c56:	e7f5      	b.n	27c44 <ll_create_connection+0xe4>
	link = ll_rx_link_alloc();
   27c58:	f010 f87c 	bl	37d54 <ll_rx_link_alloc>
	if (!link) {
   27c5c:	9007      	str	r0, [sp, #28]
   27c5e:	2800      	cmp	r0, #0
   27c60:	f000 81b4 	beq.w	27fcc <ll_create_connection+0x46c>
	conn = ll_conn_acquire();
   27c64:	f012 fa26 	bl	3a0b4 <ll_conn_acquire>
	if (!conn) {
   27c68:	4604      	mov	r4, r0
   27c6a:	2800      	cmp	r0, #0
   27c6c:	f000 81ab 	beq.w	27fc6 <ll_create_connection+0x466>
	err = util_aa_le32(conn_lll->access_addr);
   27c70:	3020      	adds	r0, #32
   27c72:	f00c fe17 	bl	348a4 <util_aa_le32>
	conn_lll = &conn->lll;
   27c76:	f104 081c 	add.w	r8, r4, #28
	LL_ASSERT(!err);
   27c7a:	2800      	cmp	r0, #0
   27c7c:	f040 8176 	bne.w	27f6c <ll_create_connection+0x40c>
	lll_csrand_get(conn_lll->crc_init, sizeof(conn_lll->crc_init));
   27c80:	2103      	movs	r1, #3
   27c82:	f104 0024 	add.w	r0, r4, #36	; 0x24
   27c86:	f017 fca7 	bl	3f5d8 <lll_csrand_get>
	if (!conn_lll->link_tx_free) {
   27c8a:	6f60      	ldr	r0, [r4, #116]	; 0x74
	conn_lll->latency = latency;
   27c8c:	f8a4 b02c 	strh.w	fp, [r4, #44]	; 0x2c
	conn_lll->handle = 0xFFFF;
   27c90:	f64f 73ff 	movw	r3, #65535	; 0xffff
	conn_lll->interval = interval;
   27c94:	f8a4 a02a 	strh.w	sl, [r4, #42]	; 0x2a
	conn_lll->handle = 0xFFFF;
   27c98:	8523      	strh	r3, [r4, #40]	; 0x28
	if (!conn_lll->link_tx_free) {
   27c9a:	2800      	cmp	r0, #0
   27c9c:	f000 8173 	beq.w	27f86 <ll_create_connection+0x426>
	memq_init(conn_lll->link_tx_free, &conn_lll->memq_tx.head,
   27ca0:	f104 0164 	add.w	r1, r4, #100	; 0x64
   27ca4:	f104 0268 	add.w	r2, r4, #104	; 0x68
   27ca8:	f00c fc5e 	bl	34568 <memq_init>
	conn_lll->phy_tx = PHY_1M;
   27cac:	f8b4 3060 	ldrh.w	r3, [r4, #96]	; 0x60
	conn_lll->max_tx_octets = PDU_DC_PAYLOAD_SIZE_MIN;
   27cb0:	4aa6      	ldr	r2, [pc, #664]	; (27f4c <ll_create_connection+0x3ec>)
	conn_lll->phy_tx = PHY_1M;
   27cb2:	f423 63ef 	bic.w	r3, r3, #1912	; 0x778
   27cb6:	f023 0307 	bic.w	r3, r3, #7
   27cba:	f443 7388 	orr.w	r3, r3, #272	; 0x110
   27cbe:	f043 0301 	orr.w	r3, r3, #1
   27cc2:	f8a4 3060 	strh.w	r3, [r4, #96]	; 0x60
	conn_lll->sn = 0;
   27cc6:	f894 307a 	ldrb.w	r3, [r4, #122]	; 0x7a
   27cca:	f023 0307 	bic.w	r3, r3, #7
	conn_lll->link_tx_free = NULL;
   27cce:	f04f 0b00 	mov.w	fp, #0
	conn_lll->sn = 0;
   27cd2:	f884 307a 	strb.w	r3, [r4, #122]	; 0x7a
	conn_lll->max_tx_octets = PDU_DC_PAYLOAD_SIZE_MIN;
   27cd6:	f04f 131b 	mov.w	r3, #1769499	; 0x1b001b
   27cda:	e9c4 3216 	strd	r3, r2, [r4, #88]	; 0x58
	conn_lll->link_tx_free = NULL;
   27cde:	f8c4 b074 	str.w	fp, [r4, #116]	; 0x74
	conn_lll->packet_tx_head_len = 0;
   27ce2:	f8a4 b078 	strh.w	fp, [r4, #120]	; 0x78
	conn_lll->latency_prepare = 0;
   27ce6:	f8c4 b02e 	str.w	fp, [r4, #46]	; 0x2e
	conn_lll->event_counter = 0;
   27cea:	f8a4 b032 	strh.w	fp, [r4, #50]	; 0x32
	conn_lll->data_chan_count = ull_chan_map_get(conn_lll->data_chan_map);
   27cee:	f104 0034 	add.w	r0, r4, #52	; 0x34
   27cf2:	f017 f91b 	bl	3ef2c <ull_chan_map_get>
   27cf6:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
   27cfa:	f360 0305 	bfi	r3, r0, #0, #6
	lll_csrand_get(&hop, sizeof(uint8_t));
   27cfe:	2101      	movs	r1, #1
	conn_lll->data_chan_count = ull_chan_map_get(conn_lll->data_chan_map);
   27d00:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
	lll_csrand_get(&hop, sizeof(uint8_t));
   27d04:	f10d 0027 	add.w	r0, sp, #39	; 0x27
   27d08:	f017 fc66 	bl	3f5d8 <lll_csrand_get>
	conn_lll->data_chan_hop = 5 + (hop % 12);
   27d0c:	f89d 2027 	ldrb.w	r2, [sp, #39]	; 0x27
   27d10:	4b8f      	ldr	r3, [pc, #572]	; (27f50 <ll_create_connection+0x3f0>)
	conn->appto_reload = (conn->apto_reload > (conn_lll->latency + 6)) ?
   27d12:	8da0      	ldrh	r0, [r4, #44]	; 0x2c
	conn_lll->data_chan_use = 0;
   27d14:	f884 b03b 	strb.w	fp, [r4, #59]	; 0x3b
	conn_lll->data_chan_hop = 5 + (hop % 12);
   27d18:	fba3 1302 	umull	r1, r3, r3, r2
   27d1c:	08db      	lsrs	r3, r3, #3
   27d1e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   27d22:	eba2 0283 	sub.w	r2, r2, r3, lsl #2
	conn_lll->data_chan_sel = 0;
   27d26:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
	conn->procedure_reload = RADIO_CONN_EVENTS(40000000,
   27d2a:	498a      	ldr	r1, [pc, #552]	; (27f54 <ll_create_connection+0x3f4>)
	conn->supervision_expire = 0U;
   27d2c:	f8a4 b0c4 	strh.w	fp, [r4, #196]	; 0xc4
	conn_lll->data_chan_sel = 0;
   27d30:	f003 033f 	and.w	r3, r3, #63	; 0x3f
	conn_lll->data_chan_hop = 5 + (hop % 12);
   27d34:	3205      	adds	r2, #5
	conn_lll->data_chan_sel = 0;
   27d36:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
	conn_lll->central.initiated = 0;
   27d3a:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
	conn_lll->data_chan_hop = 5 + (hop % 12);
   27d3e:	f884 203a 	strb.w	r2, [r4, #58]	; 0x3a
	conn_interval_us = (uint32_t)interval * CONN_INT_UNIT_US;
   27d42:	f240 42e2 	movw	r2, #1250	; 0x4e2
   27d46:	fb02 f20a 	mul.w	r2, r2, sl
	conn_lll->central.initiated = 0;
   27d4a:	f023 0303 	bic.w	r3, r3, #3
	conn->procedure_reload = RADIO_CONN_EVENTS(40000000,
   27d4e:	4411      	add	r1, r2
	conn_lll->central.initiated = 0;
   27d50:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
	conn->procedure_reload = RADIO_CONN_EVENTS(40000000,
   27d54:	fbb1 f1f2 	udiv	r1, r1, r2
	conn->apto_reload = RADIO_CONN_EVENTS((30000000), conn_interval_us);
   27d58:	4b7f      	ldr	r3, [pc, #508]	; (27f58 <ll_create_connection+0x3f8>)
	conn->procedure_reload = RADIO_CONN_EVENTS(40000000,
   27d5a:	f8a4 10c6 	strh.w	r1, [r4, #198]	; 0xc6
	conn->supervision_reload = RADIO_CONN_EVENTS(timeout * 10000U,
   27d5e:	f242 7110 	movw	r1, #10000	; 0x2710
   27d62:	fb01 2107 	mla	r1, r1, r7, r2
	conn->apto_reload = RADIO_CONN_EVENTS((30000000), conn_interval_us);
   27d66:	4413      	add	r3, r2
	conn->supervision_reload = RADIO_CONN_EVENTS(timeout * 10000U,
   27d68:	3901      	subs	r1, #1
	conn->apto_reload = RADIO_CONN_EVENTS((30000000), conn_interval_us);
   27d6a:	fbb3 f3f2 	udiv	r3, r3, r2
	conn->supervision_reload = RADIO_CONN_EVENTS(timeout * 10000U,
   27d6e:	fbb1 f2f2 	udiv	r2, r1, r2
   27d72:	f8a4 20c2 	strh.w	r2, [r4, #194]	; 0xc2
	conn->connect_expire = CONN_ESTAB_COUNTDOWN;
   27d76:	2206      	movs	r2, #6
   27d78:	f8a4 20c0 	strh.w	r2, [r4, #192]	; 0xc0
	conn->appto_reload = (conn->apto_reload > (conn_lll->latency + 6)) ?
   27d7c:	1d81      	adds	r1, r0, #6
	conn->apto_reload = RADIO_CONN_EVENTS((30000000), conn_interval_us);
   27d7e:	b29a      	uxth	r2, r3
	conn->appto_reload = (conn->apto_reload > (conn_lll->latency + 6)) ?
   27d80:	428a      	cmp	r2, r1
	conn->procedure_expire = 0U;
   27d82:	f8a4 b0c8 	strh.w	fp, [r4, #200]	; 0xc8
	conn->apto_expire = 0U;
   27d86:	f8a4 b0d0 	strh.w	fp, [r4, #208]	; 0xd0
	conn->appto_expire = 0U;
   27d8a:	f8a4 b0cc 	strh.w	fp, [r4, #204]	; 0xcc
	conn->apto_reload = RADIO_CONN_EVENTS((30000000), conn_interval_us);
   27d8e:	f8a4 20ce 	strh.w	r2, [r4, #206]	; 0xce
	conn->appto_reload = (conn->apto_reload > (conn_lll->latency + 6)) ?
   27d92:	dd02      	ble.n	27d9a <ll_create_connection+0x23a>
   27d94:	3a06      	subs	r2, #6
   27d96:	1a12      	subs	r2, r2, r0
   27d98:	b292      	uxth	r2, r2
	conn->common.fex_valid = 0U;
   27d9a:	f894 30e4 	ldrb.w	r3, [r4, #228]	; 0xe4
	conn->appto_reload = (conn->apto_reload > (conn_lll->latency + 6)) ?
   27d9e:	f8a4 20ca 	strh.w	r2, [r4, #202]	; 0xca
	conn->common.fex_valid = 0U;
   27da2:	f023 0307 	bic.w	r3, r3, #7
   27da6:	f884 30e4 	strb.w	r3, [r4, #228]	; 0xe4
	conn->llcp_cu.pause_tx = 0U;
   27daa:	f894 311a 	ldrb.w	r3, [r4, #282]	; 0x11a
	conn->llcp_req = conn->llcp_ack = conn->llcp_type = 0U;
   27dae:	f04f 0a00 	mov.w	sl, #0
	conn->llcp_cu.pause_tx = 0U;
   27db2:	f36a 1304 	bfi	r3, sl, #4, #1
   27db6:	f884 311a 	strb.w	r3, [r4, #282]	; 0x11a
	conn->llcp_req = conn->llcp_ack = conn->llcp_type = 0U;
   27dba:	f884 a0f2 	strb.w	sl, [r4, #242]	; 0xf2
   27dbe:	f8a4 a0f0 	strh.w	sl, [r4, #240]	; 0xf0
	conn->llcp_rx = NULL;
   27dc2:	f8c4 a114 	str.w	sl, [r4, #276]	; 0x114
	conn->llcp_cu.req = conn->llcp_cu.ack = 0;
   27dc6:	f8a4 a118 	strh.w	sl, [r4, #280]	; 0x118
	conn->llcp_feature.req = conn->llcp_feature.ack = 0;
   27dca:	f8a4 a130 	strh.w	sl, [r4, #304]	; 0x130
	conn->llcp_feature.features_conn = ll_feat_get();
   27dce:	f00f fb01 	bl	373d4 <ll_feat_get>
	conn->llcp_terminate.node_rx.hdr.link = link;
   27dd2:	9b07      	ldr	r3, [sp, #28]
   27dd4:	f8c4 3154 	str.w	r3, [r4, #340]	; 0x154
	conn->llcp_version.tx = conn->llcp_version.rx = 0U;
   27dd8:	f894 314a 	ldrb.w	r3, [r4, #330]	; 0x14a
	conn->llcp_version.req = conn->llcp_version.ack = 0;
   27ddc:	f8a4 a148 	strh.w	sl, [r4, #328]	; 0x148
	conn->llcp_version.tx = conn->llcp_version.rx = 0U;
   27de0:	f023 0303 	bic.w	r3, r3, #3
   27de4:	f884 314a 	strb.w	r3, [r4, #330]	; 0x14a
	conn_lll->enc_rx = conn_lll->enc_tx = 0U;
   27de8:	f894 307a 	ldrb.w	r3, [r4, #122]	; 0x7a
	conn->llcp_terminate.req = conn->llcp_terminate.ack = 0U;
   27dec:	f8a4 a150 	strh.w	sl, [r4, #336]	; 0x150
	conn_lll->enc_rx = conn_lll->enc_tx = 0U;
   27df0:	f023 0318 	bic.w	r3, r3, #24
   27df4:	f884 307a 	strb.w	r3, [r4, #122]	; 0x7a
	conn->llcp_enc.pause_tx = conn->llcp_enc.pause_rx = 0U;
   27df8:	f894 3176 	ldrb.w	r3, [r4, #374]	; 0x176
	conn->llcp_terminate.reason_final = 0U;
   27dfc:	f884 a153 	strb.w	sl, [r4, #339]	; 0x153
	conn->llcp_enc.pause_tx = conn->llcp_enc.pause_rx = 0U;
   27e00:	f023 0307 	bic.w	r3, r3, #7
   27e04:	f884 3176 	strb.w	r3, [r4, #374]	; 0x176
	conn->llcp_conn_param.disabled = 0U;
   27e08:	f894 3196 	ldrb.w	r3, [r4, #406]	; 0x196
	conn->llcp_enc.req = conn->llcp_enc.ack = 0U;
   27e0c:	f8a4 a174 	strh.w	sl, [r4, #372]	; 0x174
	conn->llcp_conn_param.disabled = 0U;
   27e10:	f36a 1386 	bfi	r3, sl, #6, #1
   27e14:	f884 3196 	strb.w	r3, [r4, #406]	; 0x196
	conn->llcp_length.disabled = 0U;
   27e18:	f894 31c6 	ldrb.w	r3, [r4, #454]	; 0x1c6
	conn->llcp_conn_param.req = 0U;
   27e1c:	f8a4 a194 	strh.w	sl, [r4, #404]	; 0x194
	conn->llcp_length.disabled = 0U;
   27e20:	f36a 03c3 	bfi	r3, sl, #3, #1
	conn->llcp_feature.features_peer = 0;
   27e24:	2200      	movs	r2, #0
	conn->llcp_length.disabled = 0U;
   27e26:	f884 31c6 	strb.w	r3, [r4, #454]	; 0x1c6
	conn->llcp_feature.features_peer = 0;
   27e2a:	2300      	movs	r3, #0
	conn->llcp_feature.features_conn = ll_feat_get();
   27e2c:	e9c4 014e 	strd	r0, r1, [r4, #312]	; 0x138
	conn->llcp_feature.features_peer = 0;
   27e30:	e9c4 2350 	strd	r2, r3, [r4, #320]	; 0x140
	conn->llcp_conn_param.cache.timeout = 0U;
   27e34:	f8a4 a1a6 	strh.w	sl, [r4, #422]	; 0x1a6
	conn->llcp_length.req = conn->llcp_length.ack = 0U;
   27e38:	f8a4 a1c4 	strh.w	sl, [r4, #452]	; 0x1c4
	conn->llcp_length.cache.tx_octets = 0U;
   27e3c:	f8a4 a1d0 	strh.w	sl, [r4, #464]	; 0x1d0
	conn->default_tx_octets = ull_conn_default_tx_octets_get();
   27e40:	f012 fca0 	bl	3a784 <ull_conn_default_tx_octets_get>
   27e44:	f8a4 00d2 	strh.w	r0, [r4, #210]	; 0xd2
	conn->default_tx_time = ull_conn_default_tx_time_get();
   27e48:	f012 fca2 	bl	3a790 <ull_conn_default_tx_time_get>
	conn->llcp_phy.req = conn->llcp_phy.ack = 0U;
   27e4c:	f8d4 21d4 	ldr.w	r2, [r4, #468]	; 0x1d4
   27e50:	4b42      	ldr	r3, [pc, #264]	; (27f5c <ll_create_connection+0x3fc>)
	conn->default_tx_time = ull_conn_default_tx_time_get();
   27e52:	f8a4 00d4 	strh.w	r0, [r4, #212]	; 0xd4
	conn->llcp_phy.req = conn->llcp_phy.ack = 0U;
   27e56:	4013      	ands	r3, r2
   27e58:	f8c4 31d4 	str.w	r3, [r4, #468]	; 0x1d4
	conn->phy_pref_tx = ull_conn_default_phy_tx_get();
   27e5c:	f012 fc9e 	bl	3a79c <ull_conn_default_phy_tx_get>
   27e60:	f894 31d8 	ldrb.w	r3, [r4, #472]	; 0x1d8
   27e64:	f360 0302 	bfi	r3, r0, #0, #3
   27e68:	f884 31d8 	strb.w	r3, [r4, #472]	; 0x1d8
	conn->phy_pref_rx = ull_conn_default_phy_rx_get();
   27e6c:	f012 fc9c 	bl	3a7a8 <ull_conn_default_phy_rx_get>
   27e70:	f894 31d8 	ldrb.w	r3, [r4, #472]	; 0x1d8
	(void)memcpy(conn->peer_id_addr, peer_addr, sizeof(conn->peer_id_addr));
   27e74:	9914      	ldr	r1, [sp, #80]	; 0x50
	conn->tx_head = conn->tx_ctrl = conn->tx_ctrl_last =
   27e76:	f8c4 a1dc 	str.w	sl, [r4, #476]	; 0x1dc
	conn->phy_pref_rx = ull_conn_default_phy_rx_get();
   27e7a:	f360 03c5 	bfi	r3, r0, #3, #3
   27e7e:	f884 31d8 	strb.w	r3, [r4, #472]	; 0x1d8
	conn->peer_id_addr_type = peer_addr_type;
   27e82:	f894 30d6 	ldrb.w	r3, [r4, #214]	; 0xd6
	conn->ull.ticks_active_to_start = 0U;
   27e86:	f8c4 a004 	str.w	sl, [r4, #4]
	conn->peer_id_addr_type = peer_addr_type;
   27e8a:	f006 0601 	and.w	r6, r6, #1
   27e8e:	f366 0341 	bfi	r3, r6, #1, #1
   27e92:	f884 30d6 	strb.w	r3, [r4, #214]	; 0xd6
	conn->ull.ticks_prepare_to_start =
   27e96:	2331      	movs	r3, #49	; 0x31
   27e98:	60a3      	str	r3, [r4, #8]
	(void)memcpy(conn->peer_id_addr, peer_addr, sizeof(conn->peer_id_addr));
   27e9a:	2206      	movs	r2, #6
	conn->tx_data = conn->tx_data_last = 0;
   27e9c:	e9c4 aa7a 	strd	sl, sl, [r4, #488]	; 0x1e8
	conn->tx_head = conn->tx_ctrl = conn->tx_ctrl_last =
   27ea0:	e9c4 aa78 	strd	sl, sl, [r4, #480]	; 0x1e0
	conn->ull.ticks_preempt_to_start =
   27ea4:	f8c4 a00c 	str.w	sl, [r4, #12]
	(void)memcpy(conn->peer_id_addr, peer_addr, sizeof(conn->peer_id_addr));
   27ea8:	f104 00dd 	add.w	r0, r4, #221	; 0xdd
   27eac:	f022 ffe5 	bl	4ae7a <memcpy>
	conn->own_id_addr_type = own_id_addr_type;
   27eb0:	f894 30d6 	ldrb.w	r3, [r4, #214]	; 0xd6
	(void)memcpy(conn->own_id_addr, own_id_addr, sizeof(conn->own_id_addr));
   27eb4:	9903      	ldr	r1, [sp, #12]
	conn->own_id_addr_type = own_id_addr_type;
   27eb6:	f369 0300 	bfi	r3, r9, #0, #1
   27eba:	f884 30d6 	strb.w	r3, [r4, #214]	; 0xd6
	(void)memcpy(conn->own_id_addr, own_id_addr, sizeof(conn->own_id_addr));
   27ebe:	2206      	movs	r2, #6
   27ec0:	f104 00d7 	add.w	r0, r4, #215	; 0xd7
   27ec4:	f022 ffd9 	bl	4ae7a <memcpy>
	lll->conn = conn_lll;
   27ec8:	f8c5 8020 	str.w	r8, [r5, #32]
	hdr->disabled_cb = hdr->disabled_param = NULL;
   27ecc:	e9c4 aa05 	strd	sl, sl, [r4, #20]
	hdr->ref = 0U;
   27ed0:	f884 a000 	strb.w	sl, [r4]
   27ed4:	61e4      	str	r4, [r4, #28]

#if defined(CONFIG_BT_CTLR_JIT_SCHEDULING)
	hdr->score = 0U;
	hdr->latency = 0U;
#endif /* CONFIG_BT_CTLR_JIT_SCHEDULING */
}
   27ed6:	e676      	b.n	27bc6 <ll_create_connection+0x66>
		return BT_HCI_ERR_CMD_DISALLOWED;
   27ed8:	200c      	movs	r0, #12
}
   27eda:	b00b      	add	sp, #44	; 0x2c
   27edc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return BT_HCI_ERR_CONN_ALREADY_EXISTS;
   27ee0:	200b      	movs	r0, #11
}
   27ee2:	b00b      	add	sp, #44	; 0x2c
   27ee4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	struct node_rx_pdu *cc;
	struct lll_conn *lll;
	struct ll_conn *conn;
	memq_link_t *link;

	lll = scan->lll.conn;
   27ee8:	6a2c      	ldr	r4, [r5, #32]
	LL_ASSERT(!lll->link_tx_free);
   27eea:	6da3      	ldr	r3, [r4, #88]	; 0x58
   27eec:	b163      	cbz	r3, 27f08 <ll_create_connection+0x3a8>
   27eee:	4a1c      	ldr	r2, [pc, #112]	; (27f60 <ll_create_connection+0x400>)
   27ef0:	491c      	ldr	r1, [pc, #112]	; (27f64 <ll_create_connection+0x404>)
   27ef2:	481d      	ldr	r0, [pc, #116]	; (27f68 <ll_create_connection+0x408>)
   27ef4:	f240 43d4 	movw	r3, #1236	; 0x4d4
   27ef8:	f021 f8c4 	bl	49084 <assert_print>
   27efc:	4040      	eors	r0, r0
   27efe:	f380 8811 	msr	BASEPRI, r0
   27f02:	f04f 0003 	mov.w	r0, #3
   27f06:	df02      	svc	2
	link = memq_deinit(&lll->memq_tx.head, &lll->memq_tx.tail);
   27f08:	f104 014c 	add.w	r1, r4, #76	; 0x4c
   27f0c:	f104 0048 	add.w	r0, r4, #72	; 0x48
   27f10:	f00c fb2e 	bl	34570 <memq_deinit>
	LL_ASSERT(link);
   27f14:	4606      	mov	r6, r0
   27f16:	2800      	cmp	r0, #0
   27f18:	d039      	beq.n	27f8e <ll_create_connection+0x42e>
	lll->link_tx_free = link;

	conn = HDR_LLL2ULL(lll);
   27f1a:	6827      	ldr	r7, [r4, #0]
	lll->link_tx_free = link;
   27f1c:	65a6      	str	r6, [r4, #88]	; 0x58

	cc = (void *)&conn->llcp_terminate.node_rx;
	link = cc->hdr.link;
   27f1e:	f8d7 4154 	ldr.w	r4, [r7, #340]	; 0x154
	LL_ASSERT(link);
   27f22:	2c00      	cmp	r4, #0
   27f24:	d041      	beq.n	27faa <ll_create_connection+0x44a>

	ll_rx_link_release(link);
   27f26:	4620      	mov	r0, r4
   27f28:	f00f ff1a 	bl	37d60 <ll_rx_link_release>

	ll_conn_release(conn);
   27f2c:	4638      	mov	r0, r7
   27f2e:	f012 f8c7 	bl	3a0c0 <ll_conn_release>
	scan->lll.conn = NULL;
   27f32:	2300      	movs	r3, #0
		return BT_HCI_ERR_HW_FAILURE;
   27f34:	2003      	movs	r0, #3
	scan->lll.conn = NULL;
   27f36:	622b      	str	r3, [r5, #32]
}
   27f38:	b00b      	add	sp, #44	; 0x2c
   27f3a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   27f3e:	bf00      	nop
   27f40:	1afd498d 	.word	0x1afd498d
   27f44:	00000007 	.word	0x00000007
   27f48:	3b9aca00 	.word	0x3b9aca00
   27f4c:	01480148 	.word	0x01480148
   27f50:	aaaaaaab 	.word	0xaaaaaaab
   27f54:	026259ff 	.word	0x026259ff
   27f58:	01c9c37f 	.word	0x01c9c37f
   27f5c:	f6ff0000 	.word	0xf6ff0000
   27f60:	00052940 	.word	0x00052940
   27f64:	00052590 	.word	0x00052590
   27f68:	0005214c 	.word	0x0005214c
	LL_ASSERT(!err);
   27f6c:	4a18      	ldr	r2, [pc, #96]	; (27fd0 <ll_create_connection+0x470>)
   27f6e:	4919      	ldr	r1, [pc, #100]	; (27fd4 <ll_create_connection+0x474>)
   27f70:	4819      	ldr	r0, [pc, #100]	; (27fd8 <ll_create_connection+0x478>)
   27f72:	23c4      	movs	r3, #196	; 0xc4
   27f74:	f021 f886 	bl	49084 <assert_print>
   27f78:	4040      	eors	r0, r0
   27f7a:	f380 8811 	msr	BASEPRI, r0
   27f7e:	f04f 0003 	mov.w	r0, #3
   27f82:	df02      	svc	2
   27f84:	e67c      	b.n	27c80 <ll_create_connection+0x120>
		conn_lll->link_tx_free = &conn_lll->link_tx;
   27f86:	f104 006c 	add.w	r0, r4, #108	; 0x6c
   27f8a:	6760      	str	r0, [r4, #116]	; 0x74
   27f8c:	e688      	b.n	27ca0 <ll_create_connection+0x140>
	LL_ASSERT(link);
   27f8e:	4a10      	ldr	r2, [pc, #64]	; (27fd0 <ll_create_connection+0x470>)
   27f90:	4912      	ldr	r1, [pc, #72]	; (27fdc <ll_create_connection+0x47c>)
   27f92:	4811      	ldr	r0, [pc, #68]	; (27fd8 <ll_create_connection+0x478>)
   27f94:	f240 43d6 	movw	r3, #1238	; 0x4d6
   27f98:	f021 f874 	bl	49084 <assert_print>
   27f9c:	4040      	eors	r0, r0
   27f9e:	f380 8811 	msr	BASEPRI, r0
   27fa2:	f04f 0003 	mov.w	r0, #3
   27fa6:	df02      	svc	2
   27fa8:	e7b7      	b.n	27f1a <ll_create_connection+0x3ba>
	LL_ASSERT(link);
   27faa:	4a09      	ldr	r2, [pc, #36]	; (27fd0 <ll_create_connection+0x470>)
   27fac:	490b      	ldr	r1, [pc, #44]	; (27fdc <ll_create_connection+0x47c>)
   27fae:	480a      	ldr	r0, [pc, #40]	; (27fd8 <ll_create_connection+0x478>)
   27fb0:	f240 43dd 	movw	r3, #1245	; 0x4dd
   27fb4:	f021 f866 	bl	49084 <assert_print>
   27fb8:	4040      	eors	r0, r0
   27fba:	f380 8811 	msr	BASEPRI, r0
   27fbe:	f04f 0003 	mov.w	r0, #3
   27fc2:	df02      	svc	2
   27fc4:	e7af      	b.n	27f26 <ll_create_connection+0x3c6>
		ll_rx_link_release(link);
   27fc6:	9807      	ldr	r0, [sp, #28]
   27fc8:	f00f feca 	bl	37d60 <ll_rx_link_release>
		return BT_HCI_ERR_MEM_CAPACITY_EXCEEDED;
   27fcc:	2007      	movs	r0, #7
   27fce:	e639      	b.n	27c44 <ll_create_connection+0xe4>
   27fd0:	00052940 	.word	0x00052940
   27fd4:	00052330 	.word	0x00052330
   27fd8:	0005214c 	.word	0x0005214c
   27fdc:	000526f4 	.word	0x000526f4

00027fe0 <ull_central_setup>:
{
   27fe0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	peer_addr_type = pdu_tx->rx_addr;
   27fe4:	4681      	mov	r9, r0
{
   27fe6:	b08c      	sub	sp, #48	; 0x30
   27fe8:	4604      	mov	r4, r0
	peer_addr_type = pdu_tx->rx_addr;
   27fea:	f819 6f1c 	ldrb.w	r6, [r9, #28]!
{
   27fee:	4688      	mov	r8, r1
   27ff0:	4615      	mov	r5, r2
	memcpy(peer_addr, &pdu_tx->connect_ind.adv_addr[0], BDADDR_SIZE);
   27ff2:	f100 0124 	add.w	r1, r0, #36	; 0x24
   27ff6:	2206      	movs	r2, #6
   27ff8:	a80a      	add	r0, sp, #40	; 0x28
   27ffa:	f022 ff3e 	bl	4ae7a <memcpy>
	chan_sel = pdu_tx->chan_sel;
   27ffe:	7f27      	ldrb	r7, [r4, #28]
	LL_ASSERT(IS_PTR_ALIGNED(node, struct node_rx_cc));
   28000:	f019 0f01 	tst.w	r9, #1
	peer_addr_type = pdu_tx->rx_addr;
   28004:	f3c6 16c0 	ubfx	r6, r6, #7, #1
	chan_sel = pdu_tx->chan_sel;
   28008:	f3c7 1740 	ubfx	r7, r7, #5, #1
	LL_ASSERT(IS_PTR_ALIGNED(node, struct node_rx_cc));
   2800c:	f040 80cb 	bne.w	281a6 <ull_central_setup+0x1c6>
	cc->status = 0U;
   28010:	2300      	movs	r3, #0
		memcpy(cc->peer_addr, &peer_addr[0], BDADDR_SIZE);
   28012:	a90a      	add	r1, sp, #40	; 0x28
   28014:	2206      	movs	r2, #6
		cc->peer_addr_type = peer_addr_type;
   28016:	77a6      	strb	r6, [r4, #30]
	cc->status = 0U;
   28018:	83a3      	strh	r3, [r4, #28]
		memcpy(cc->peer_addr, &peer_addr[0], BDADDR_SIZE);
   2801a:	f104 001f 	add.w	r0, r4, #31
   2801e:	f022 ff2c 	bl	4ae7a <memcpy>
	scan = HDR_LLL2ULL(ftr->param);
   28022:	f8d8 3000 	ldr.w	r3, [r8]
   28026:	f8d3 9000 	ldr.w	r9, [r3]
	cc->interval = lll->interval;
   2802a:	89eb      	ldrh	r3, [r5, #14]
   2802c:	84e3      	strh	r3, [r4, #38]	; 0x26
	cc->latency = lll->latency;
   2802e:	8a2b      	ldrh	r3, [r5, #16]
   28030:	8523      	strh	r3, [r4, #40]	; 0x28
	cc->timeout = scan->lll.conn_timeout;
   28032:	f8b9 3030 	ldrh.w	r3, [r9, #48]	; 0x30
   28036:	8563      	strh	r3, [r4, #42]	; 0x2a
	cc->sca = lll_clock_sca_local_get();
   28038:	f017 fe06 	bl	3fc48 <lll_clock_sca_local_get>
   2803c:	f884 002c 	strb.w	r0, [r4, #44]	; 0x2c
	conn = lll->hdr.parent;
   28040:	682e      	ldr	r6, [r5, #0]
	lll->handle = ll_conn_handle_get(conn);
   28042:	4630      	mov	r0, r6
   28044:	f012 f842 	bl	3a0cc <ll_conn_handle_get>
   28048:	81a8      	strh	r0, [r5, #12]
	rx->handle = lll->handle;
   2804a:	80e0      	strh	r0, [r4, #6]
		rx_csa = (void *)ftr->extra;
   2804c:	f8d8 a004 	ldr.w	sl, [r8, #4]
		ll_rx_put(link, rx);
   28050:	6820      	ldr	r0, [r4, #0]
   28052:	4621      	mov	r1, r4
   28054:	f00f fe96 	bl	37d84 <ll_rx_put>
		rx->handle = lll->handle;
   28058:	89ab      	ldrh	r3, [r5, #12]
   2805a:	f8aa 3006 	strh.w	r3, [sl, #6]
		rx->type = NODE_RX_TYPE_CHAN_SEL_ALGO;
   2805e:	231c      	movs	r3, #28
		link = rx->link;
   28060:	f8da 4000 	ldr.w	r4, [sl]
		rx->type = NODE_RX_TYPE_CHAN_SEL_ALGO;
   28064:	f88a 3004 	strb.w	r3, [sl, #4]
		if (chan_sel) {
   28068:	2f00      	cmp	r7, #0
   2806a:	f040 80aa 	bne.w	281c2 <ull_central_setup+0x1e2>
	ll_rx_put(link, rx);
   2806e:	4651      	mov	r1, sl
   28070:	4620      	mov	r0, r4
			cs->csa = 0x00;
   28072:	f88a 701c 	strb.w	r7, [sl, #28]
	ll_rx_put(link, rx);
   28076:	f00f fe85 	bl	37d84 <ll_rx_put>
	ll_rx_sched();
   2807a:	f00f fe8d 	bl	37d98 <ll_rx_sched>
	ticks_slot_offset = MAX(conn->ull.ticks_active_to_start,
   2807e:	68b2      	ldr	r2, [r6, #8]
   28080:	6873      	ldr	r3, [r6, #4]
						      lll->phy_flags);
   28082:	f895 0044 	ldrb.w	r0, [r5, #68]	; 0x44
	conn_interval_us = lll->interval * CONN_INT_UNIT_US;
   28086:	89ef      	ldrh	r7, [r5, #14]
	conn_offset_us = ftr->radio_end_us;
   28088:	f8d8 400c 	ldr.w	r4, [r8, #12]
	ticks_slot_offset = MAX(conn->ull.ticks_active_to_start,
   2808c:	429a      	cmp	r2, r3
   2808e:	bf38      	it	cc
   28090:	461a      	movcc	r2, r3
	conn_offset_us -= lll_radio_tx_ready_delay_get(lll->phy_tx,
   28092:	f3c0 01c0 	ubfx	r1, r0, #3, #1
	conn_interval_us = lll->interval * CONN_INT_UNIT_US;
   28096:	f240 43e2 	movw	r3, #1250	; 0x4e2
	conn_offset_us -= lll_radio_tx_ready_delay_get(lll->phy_tx,
   2809a:	f000 0007 	and.w	r0, r0, #7
	conn_interval_us = lll->interval * CONN_INT_UNIT_US;
   2809e:	fb03 f707 	mul.w	r7, r3, r7
	ticks_slot_offset = MAX(conn->ull.ticks_active_to_start,
   280a2:	4692      	mov	sl, r2
	conn_offset_us -= lll_radio_tx_ready_delay_get(lll->phy_tx,
   280a4:	f017 fbe2 	bl	3f86c <lll_radio_tx_ready_delay_get>
	conn_offset_us += EVENT_TICKER_RES_MARGIN_US;
   280a8:	3420      	adds	r4, #32
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 0);
   280aa:	2200      	movs	r2, #0
   280ac:	2102      	movs	r1, #2
	conn_offset_us -= lll_radio_tx_ready_delay_get(lll->phy_tx,
   280ae:	1a24      	subs	r4, r4, r0
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 0);
   280b0:	2001      	movs	r0, #1
   280b2:	f00c faa9 	bl	34608 <mayfly_enable>
	ticker_id_scan = TICKER_ID_SCAN_BASE + ull_scan_handle_get(scan);
   280b6:	4648      	mov	r0, r9
   280b8:	f011 f916 	bl	392e8 <ull_scan_handle_get>
   280bc:	1d02      	adds	r2, r0, #4
	ticker_status = ticker_stop(TICKER_INSTANCE_ID_CTLR,
   280be:	4b48      	ldr	r3, [pc, #288]	; (281e0 <ull_central_setup+0x200>)
   280c0:	f8cd 9000 	str.w	r9, [sp]
   280c4:	b2d2      	uxtb	r2, r2
   280c6:	2101      	movs	r1, #1
   280c8:	2000      	movs	r0, #0
   280ca:	f00d fcf7 	bl	35abc <ticker_stop>
	LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
   280ce:	f030 0302 	bics.w	r3, r0, #2
   280d2:	d00c      	beq.n	280ee <ull_central_setup+0x10e>
   280d4:	4a43      	ldr	r2, [pc, #268]	; (281e4 <ull_central_setup+0x204>)
   280d6:	4944      	ldr	r1, [pc, #272]	; (281e8 <ull_central_setup+0x208>)
   280d8:	4844      	ldr	r0, [pc, #272]	; (281ec <ull_central_setup+0x20c>)
   280da:	f240 33e5 	movw	r3, #997	; 0x3e5
   280de:	f020 ffd1 	bl	49084 <assert_print>
   280e2:	4040      	eors	r0, r0
   280e4:	f380 8811 	msr	BASEPRI, r0
   280e8:	f04f 0003 	mov.w	r0, #3
   280ec:	df02      	svc	2
	ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_ULL_HIGH,
   280ee:	f04f 0900 	mov.w	r9, #0
   280f2:	464b      	mov	r3, r9
   280f4:	2203      	movs	r2, #3
   280f6:	2101      	movs	r1, #1
   280f8:	f8cd 9000 	str.w	r9, [sp]
   280fc:	4648      	mov	r0, r9
   280fe:	f00d fcdd 	bl	35abc <ticker_stop>
	ticker_id_conn = TICKER_ID_CONN_BASE + ll_conn_handle_get(conn);
   28102:	4630      	mov	r0, r6
   28104:	f011 ffe2 	bl	3a0cc <ll_conn_handle_get>
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
   28108:	f8d8 3008 	ldr.w	r3, [r8, #8]
   2810c:	f1a3 0818 	sub.w	r8, r3, #24
   28110:	eba8 080a 	sub.w	r8, r8, sl
				     HAL_TICKER_US_TO_TICKS(conn_interval_us),
   28114:	f8df a0d8 	ldr.w	sl, [pc, #216]	; 281f0 <ull_central_setup+0x210>
	ticker_id_conn = TICKER_ID_CONN_BASE + ll_conn_handle_get(conn);
   28118:	4605      	mov	r5, r0
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
   2811a:	a32f      	add	r3, pc, #188	; (adr r3, 281d8 <ull_central_setup+0x1f8>)
   2811c:	e9d3 2300 	ldrd	r2, r3, [r3]
   28120:	fba7 010a 	umull	r0, r1, r7, sl
   28124:	f7fd ffec 	bl	26100 <__aeabi_uldivmod>
				     HAL_TICKER_REMAINDER(conn_interval_us),
   28128:	4619      	mov	r1, r3
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
   2812a:	4b32      	ldr	r3, [pc, #200]	; (281f4 <ull_central_setup+0x214>)
   2812c:	9307      	str	r3, [sp, #28]
   2812e:	4b32      	ldr	r3, [pc, #200]	; (281f8 <ull_central_setup+0x218>)
   28130:	9305      	str	r3, [sp, #20]
   28132:	f240 4315 	movw	r3, #1045	; 0x415
   28136:	9606      	str	r6, [sp, #24]
   28138:	9308      	str	r3, [sp, #32]
   2813a:	6933      	ldr	r3, [r6, #16]
   2813c:	4607      	mov	r7, r0
   2813e:	e9cd 9303 	strd	r9, r3, [sp, #12]
				     HAL_TICKER_REMAINDER(conn_interval_us),
   28142:	4610      	mov	r0, r2
   28144:	2300      	movs	r3, #0
   28146:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   2814a:	f7fd ffd9 	bl	26100 <__aeabi_uldivmod>
				     HAL_TICKER_US_TO_TICKS(conn_offset_us),
   2814e:	a322      	add	r3, pc, #136	; (adr r3, 281d8 <ull_central_setup+0x1f8>)
   28150:	e9d3 2300 	ldrd	r2, r3, [r3]
				     HAL_TICKER_US_TO_TICKS(conn_interval_us),
   28154:	e9cd 7001 	strd	r7, r0, [sp, #4]
				     HAL_TICKER_US_TO_TICKS(conn_offset_us),
   28158:	fba4 010a 	umull	r0, r1, r4, sl
   2815c:	f7fd ffd0 	bl	26100 <__aeabi_uldivmod>
	ticker_id_conn = TICKER_ID_CONN_BASE + ll_conn_handle_get(conn);
   28160:	3505      	adds	r5, #5
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
   28162:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
   28166:	b2ed      	uxtb	r5, r5
   28168:	9000      	str	r0, [sp, #0]
   2816a:	4643      	mov	r3, r8
   2816c:	462a      	mov	r2, r5
   2816e:	2101      	movs	r1, #1
   28170:	4648      	mov	r0, r9
   28172:	f00d fc17 	bl	359a4 <ticker_start>
	LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
   28176:	f030 0302 	bics.w	r3, r0, #2
   2817a:	d00c      	beq.n	28196 <ull_central_setup+0x1b6>
   2817c:	4a19      	ldr	r2, [pc, #100]	; (281e4 <ull_central_setup+0x204>)
   2817e:	491a      	ldr	r1, [pc, #104]	; (281e8 <ull_central_setup+0x208>)
   28180:	481a      	ldr	r0, [pc, #104]	; (281ec <ull_central_setup+0x20c>)
   28182:	f240 4316 	movw	r3, #1046	; 0x416
   28186:	f020 ff7d 	bl	49084 <assert_print>
   2818a:	4040      	eors	r0, r0
   2818c:	f380 8811 	msr	BASEPRI, r0
   28190:	f04f 0003 	mov.w	r0, #3
   28194:	df02      	svc	2
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 1);
   28196:	2201      	movs	r2, #1
   28198:	2102      	movs	r1, #2
   2819a:	4610      	mov	r0, r2
   2819c:	f00c fa34 	bl	34608 <mayfly_enable>
}
   281a0:	b00c      	add	sp, #48	; 0x30
   281a2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	LL_ASSERT(IS_PTR_ALIGNED(node, struct node_rx_cc));
   281a6:	4a0f      	ldr	r2, [pc, #60]	; (281e4 <ull_central_setup+0x204>)
   281a8:	4914      	ldr	r1, [pc, #80]	; (281fc <ull_central_setup+0x21c>)
   281aa:	4810      	ldr	r0, [pc, #64]	; (281ec <ull_central_setup+0x20c>)
   281ac:	f44f 7359 	mov.w	r3, #868	; 0x364
   281b0:	f020 ff68 	bl	49084 <assert_print>
   281b4:	4040      	eors	r0, r0
   281b6:	f380 8811 	msr	BASEPRI, r0
   281ba:	f04f 0003 	mov.w	r0, #3
   281be:	df02      	svc	2
   281c0:	e726      	b.n	28010 <ull_central_setup+0x30>
			lll->data_chan_sel = 1;
   281c2:	7f6b      	ldrb	r3, [r5, #29]
   281c4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   281c8:	776b      	strb	r3, [r5, #29]
			lll->data_chan_id = lll_chan_id(lll->access_addr);
   281ca:	1d28      	adds	r0, r5, #4
   281cc:	f016 ff02 	bl	3efd4 <lll_chan_id>
   281d0:	2701      	movs	r7, #1
   281d2:	83e8      	strh	r0, [r5, #30]
			cs->csa = 0x01;
   281d4:	e74b      	b.n	2806e <ull_central_setup+0x8e>
   281d6:	bf00      	nop
   281d8:	1afd498d 	.word	0x1afd498d
   281dc:	00000007 	.word	0x00000007
   281e0:	0003e6a5 	.word	0x0003e6a5
   281e4:	00052940 	.word	0x00052940
   281e8:	0005277c 	.word	0x0005277c
   281ec:	0005214c 	.word	0x0005214c
   281f0:	3b9aca00 	.word	0x3b9aca00
   281f4:	0003e6a9 	.word	0x0003e6a9
   281f8:	0003e6d9 	.word	0x0003e6d9
   281fc:	00052260 	.word	0x00052260

00028200 <ull_hdr_get_cb>:
		}
#endif /* CONFIG_BT_CTLR_ADV_PERIODIC */
#endif /* CONFIG_BT_CTLR_ADV_EXT && CONFIG_BT_BROADCASTER */

#if defined(CONFIG_BT_CONN)
	} else if (IN_RANGE(ticker_id, TICKER_ID_CONN_BASE,
   28200:	3805      	subs	r0, #5
{
   28202:	b538      	push	{r3, r4, r5, lr}
	} else if (IN_RANGE(ticker_id, TICKER_ID_CONN_BASE,
   28204:	b2c3      	uxtb	r3, r0
   28206:	2b05      	cmp	r3, #5
   28208:	d820      	bhi.n	2824c <ull_hdr_get_cb+0x4c>
			    TICKER_ID_CONN_LAST)) {
		struct ll_conn *conn;

		conn = ll_conn_get(ticker_id - TICKER_ID_CONN_BASE);
   2820a:	b280      	uxth	r0, r0
   2820c:	460d      	mov	r5, r1
   2820e:	f011 ff65 	bl	3a0dc <ll_conn_get>
		if (conn && !conn->lll.role) {
   28212:	4604      	mov	r4, r0
   28214:	b1d0      	cbz	r0, 2824c <ull_hdr_get_cb+0x4c>
   28216:	f990 3039 	ldrsb.w	r3, [r0, #57]	; 0x39
   2821a:	2b00      	cmp	r3, #0
   2821c:	db16      	blt.n	2824c <ull_hdr_get_cb+0x4c>
				uint32_t time_us;

#if defined(CONFIG_BT_CTLR_PHY)
				ready_delay_us =
					lll_radio_tx_ready_delay_get(conn->lll.phy_tx,
								     conn->lll.phy_flags);
   2821e:	f890 0060 	ldrb.w	r0, [r0, #96]	; 0x60
					lll_radio_tx_ready_delay_get(conn->lll.phy_tx,
   28222:	f3c0 01c0 	ubfx	r1, r0, #3, #1
   28226:	f000 0007 	and.w	r0, r0, #7
   2822a:	f017 fb1f 	bl	3f86c <lll_radio_tx_ready_delay_get>

				time_us = EVENT_OVERHEAD_START_US +
					  ready_delay_us +  max_rx_time +
					  EVENT_IFS_US + max_tx_time;
				ticks_slot_conn =
					HAL_TICKER_US_TO_TICKS(time_us);
   2822e:	490a      	ldr	r1, [pc, #40]	; (28258 <ull_hdr_get_cb+0x58>)
				time_us = EVENT_OVERHEAD_START_US +
   28230:	f200 6014 	addw	r0, r0, #1556	; 0x614
					HAL_TICKER_US_TO_TICKS(time_us);
   28234:	a306      	add	r3, pc, #24	; (adr r3, 28250 <ull_hdr_get_cb+0x50>)
   28236:	e9d3 2300 	ldrd	r2, r3, [r3]
   2823a:	fba0 0101 	umull	r0, r1, r0, r1
   2823e:	f7fd ff5f 	bl	26100 <__aeabi_uldivmod>
				ticks_slot_conn =
   28242:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
			} else {
				ticks_slot_conn = conn->ull.ticks_slot;
			}

			*ticks_slot = MAX(ticks_slot_conn,
   28246:	6028      	str	r0, [r5, #0]
				    HAL_TICKER_US_TO_TICKS(
					    CONFIG_BT_CTLR_SCHED_ADVANCED_CENTRAL_CONN_SPACING));

			return &conn->ull;
   28248:	4620      	mov	r0, r4
#endif /* CONFIG_BT_CONN */

	}

	return NULL;
}
   2824a:	bd38      	pop	{r3, r4, r5, pc}
	return NULL;
   2824c:	2000      	movs	r0, #0
}
   2824e:	bd38      	pop	{r3, r4, r5, pc}
   28250:	1afd498d 	.word	0x1afd498d
   28254:	00000007 	.word	0x00000007
   28258:	3b9aca00 	.word	0x3b9aca00
   2825c:	00000000 	.word	0x00000000

00028260 <after_cen_offset_get>:
{
   28260:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   28264:	b086      	sub	sp, #24
	ticker_id = after_match_slot_get(user_id, ticks_slot_abs,
   28266:	ac05      	add	r4, sp, #20
   28268:	9400      	str	r4, [sp, #0]
	uint32_t ticks_anchor_offset = ticks_anchor;
   2826a:	9203      	str	r2, [sp, #12]
{
   2826c:	4616      	mov	r6, r2
   2826e:	461d      	mov	r5, r3
   28270:	4604      	mov	r4, r0
	ticker_id = after_match_slot_get(user_id, ticks_slot_abs,
   28272:	ab04      	add	r3, sp, #16
   28274:	aa03      	add	r2, sp, #12
   28276:	2002      	movs	r0, #2
   28278:	f016 fd56 	bl	3ed28 <after_match_slot_get.constprop.0>
	if (ticker_id != TICKER_NULL) {
   2827c:	28ff      	cmp	r0, #255	; 0xff
   2827e:	d030      	beq.n	282e2 <after_cen_offset_get+0x82>
		*us_offset = HAL_TICKER_TICKS_TO_US(ticks_to_expire +
   28280:	e9dd 1304 	ldrd	r1, r3, [sp, #16]
   28284:	4f24      	ldr	r7, [pc, #144]	; (28318 <after_cen_offset_get+0xb8>)
   28286:	440b      	add	r3, r1
   28288:	fba3 0107 	umull	r0, r1, r3, r7
   2828c:	f04f 0807 	mov.w	r8, #7
   28290:	fb08 1103 	mla	r1, r8, r3, r1
   28294:	a31e      	add	r3, pc, #120	; (adr r3, 28310 <after_cen_offset_get+0xb0>)
   28296:	e9d3 2300 	ldrd	r2, r3, [r3]
   2829a:	f7fd ff31 	bl	26100 <__aeabi_uldivmod>
						    ticks_slot) +
   2829e:	3080      	adds	r0, #128	; 0x80
		*us_offset = HAL_TICKER_TICKS_TO_US(ticks_to_expire +
   282a0:	6028      	str	r0, [r5, #0]
	if ((ticks_anchor_offset - ticks_anchor) & BIT(HAL_TICKER_CNTR_MSBIT)) {
   282a2:	9803      	ldr	r0, [sp, #12]
   282a4:	1b83      	subs	r3, r0, r6
   282a6:	021b      	lsls	r3, r3, #8
   282a8:	d41e      	bmi.n	282e8 <after_cen_offset_get+0x88>
		*win_offset_us += HAL_TICKER_TICKS_TO_US(
   282aa:	4631      	mov	r1, r6
   282ac:	f00d fca8 	bl	35c00 <ticker_ticks_diff_get>
   282b0:	4601      	mov	r1, r0
   282b2:	fba0 0707 	umull	r0, r7, r0, r7
   282b6:	a316      	add	r3, pc, #88	; (adr r3, 28310 <after_cen_offset_get+0xb0>)
   282b8:	e9d3 2300 	ldrd	r2, r3, [r3]
   282bc:	fb08 7101 	mla	r1, r8, r1, r7
   282c0:	f7fd ff1e 	bl	26100 <__aeabi_uldivmod>
   282c4:	682a      	ldr	r2, [r5, #0]
   282c6:	4402      	add	r2, r0
	if ((*win_offset_us & BIT(31)) == 0) {
   282c8:	2a00      	cmp	r2, #0
		*win_offset_us -= HAL_TICKER_TICKS_TO_US(
   282ca:	602a      	str	r2, [r5, #0]
	if ((*win_offset_us & BIT(31)) == 0) {
   282cc:	db09      	blt.n	282e2 <after_cen_offset_get+0x82>
		uint32_t conn_interval_us = conn_interval * CONN_INT_UNIT_US;
   282ce:	f240 43e2 	movw	r3, #1250	; 0x4e2
   282d2:	fb03 f004 	mul.w	r0, r3, r4
		while (*win_offset_us > conn_interval_us) {
   282d6:	4290      	cmp	r0, r2
   282d8:	d203      	bcs.n	282e2 <after_cen_offset_get+0x82>
			*win_offset_us -= conn_interval_us;
   282da:	1a12      	subs	r2, r2, r0
		while (*win_offset_us > conn_interval_us) {
   282dc:	4282      	cmp	r2, r0
   282de:	d8fc      	bhi.n	282da <after_cen_offset_get+0x7a>
   282e0:	602a      	str	r2, [r5, #0]
}
   282e2:	b006      	add	sp, #24
   282e4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		*win_offset_us -= HAL_TICKER_TICKS_TO_US(
   282e8:	4601      	mov	r1, r0
   282ea:	4630      	mov	r0, r6
   282ec:	f00d fc88 	bl	35c00 <ticker_ticks_diff_get>
   282f0:	4601      	mov	r1, r0
   282f2:	fba0 0707 	umull	r0, r7, r0, r7
   282f6:	a306      	add	r3, pc, #24	; (adr r3, 28310 <after_cen_offset_get+0xb0>)
   282f8:	e9d3 2300 	ldrd	r2, r3, [r3]
   282fc:	fb08 7101 	mla	r1, r8, r1, r7
   28300:	f7fd fefe 	bl	26100 <__aeabi_uldivmod>
   28304:	682a      	ldr	r2, [r5, #0]
   28306:	1a12      	subs	r2, r2, r0
   28308:	e7de      	b.n	282c8 <after_cen_offset_get+0x68>
   2830a:	bf00      	nop
   2830c:	f3af 8000 	nop.w
   28310:	3b9aca00 	.word	0x3b9aca00
   28314:	00000000 	.word	0x00000000
   28318:	1afd498d 	.word	0x1afd498d
   2831c:	00000000 	.word	0x00000000

00028320 <ull_sched_after_cen_slot_get>:
{
   28320:	b510      	push	{r4, lr}
   28322:	b084      	sub	sp, #16
	ticker_id = after_match_slot_get(user_id, ticks_slot_abs,
   28324:	ac03      	add	r4, sp, #12
{
   28326:	469c      	mov	ip, r3
	ticker_id = after_match_slot_get(user_id, ticks_slot_abs,
   28328:	9400      	str	r4, [sp, #0]
   2832a:	ab02      	add	r3, sp, #8
{
   2832c:	4664      	mov	r4, ip
	ticker_id = after_match_slot_get(user_id, ticks_slot_abs,
   2832e:	f016 fcfb 	bl	3ed28 <after_match_slot_get.constprop.0>
	if (ticker_id != TICKER_NULL) {
   28332:	28ff      	cmp	r0, #255	; 0xff
   28334:	d012      	beq.n	2835c <ull_sched_after_cen_slot_get+0x3c>
		*us_offset = HAL_TICKER_TICKS_TO_US(ticks_to_expire +
   28336:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   2833a:	480d      	ldr	r0, [pc, #52]	; (28370 <ull_sched_after_cen_slot_get+0x50>)
   2833c:	441a      	add	r2, r3
   2833e:	fba2 0300 	umull	r0, r3, r2, r0
   28342:	2107      	movs	r1, #7
   28344:	fb01 3102 	mla	r1, r1, r2, r3
   28348:	a307      	add	r3, pc, #28	; (adr r3, 28368 <ull_sched_after_cen_slot_get+0x48>)
   2834a:	e9d3 2300 	ldrd	r2, r3, [r3]
   2834e:	f7fd fed7 	bl	26100 <__aeabi_uldivmod>
						    ticks_slot) +
   28352:	3080      	adds	r0, #128	; 0x80
		*us_offset = HAL_TICKER_TICKS_TO_US(ticks_to_expire +
   28354:	6020      	str	r0, [r4, #0]
		return 0;
   28356:	2000      	movs	r0, #0
}
   28358:	b004      	add	sp, #16
   2835a:	bd10      	pop	{r4, pc}
	return -ECHILD;
   2835c:	f06f 0009 	mvn.w	r0, #9
   28360:	e7fa      	b.n	28358 <ull_sched_after_cen_slot_get+0x38>
   28362:	bf00      	nop
   28364:	f3af 8000 	nop.w
   28368:	3b9aca00 	.word	0x3b9aca00
   2836c:	00000000 	.word	0x00000000
   28370:	1afd498d 	.word	0x1afd498d
   28374:	00000000 	.word	0x00000000

00028378 <ull_sched_mfy_win_offset_select>:
{
   28378:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	ticks_to_offset = HAL_TICKER_US_TO_TICKS(conn->llcp_conn_param.offset0 *
   2837c:	f8b0 11ac 	ldrh.w	r1, [r0, #428]	; 0x1ac
{
   28380:	b089      	sub	sp, #36	; 0x24
   28382:	4604      	mov	r4, r0
	ticks_to_offset = HAL_TICKER_US_TO_TICKS(conn->llcp_conn_param.offset0 *
   28384:	f240 43e2 	movw	r3, #1250	; 0x4e2
   28388:	483d      	ldr	r0, [pc, #244]	; (28480 <ull_sched_mfy_win_offset_select+0x108>)
	uint16_t win_offset_m[OFFSET_M_MAX] = {0, };
   2838a:	2600      	movs	r6, #0
	ticks_to_offset = HAL_TICKER_US_TO_TICKS(conn->llcp_conn_param.offset0 *
   2838c:	fb03 f101 	mul.w	r1, r3, r1
	uint16_t win_offset_m[OFFSET_M_MAX] = {0, };
   28390:	ad05      	add	r5, sp, #20
	uint8_t offset_m_max = OFFSET_M_MAX;
   28392:	2306      	movs	r3, #6
	uint16_t win_offset_m[OFFSET_M_MAX] = {0, };
   28394:	e9c5 6601 	strd	r6, r6, [r5, #4]
	uint8_t offset_m_max = OFFSET_M_MAX;
   28398:	f88d 300f 	strb.w	r3, [sp, #15]
	ticks_to_offset = HAL_TICKER_US_TO_TICKS(conn->llcp_conn_param.offset0 *
   2839c:	fba1 0100 	umull	r0, r1, r1, r0
   283a0:	a335      	add	r3, pc, #212	; (adr r3, 28478 <ull_sched_mfy_win_offset_select+0x100>)
   283a2:	e9d3 2300 	ldrd	r2, r3, [r3]
	uint16_t win_offset_m[OFFSET_M_MAX] = {0, };
   283a6:	9605      	str	r6, [sp, #20]
	ticks_to_offset = HAL_TICKER_US_TO_TICKS(conn->llcp_conn_param.offset0 *
   283a8:	f7fd feaa 	bl	26100 <__aeabi_uldivmod>
	win_offset_calc(conn, 1, &ticks_to_offset,
   283ac:	f10d 030f 	add.w	r3, sp, #15
   283b0:	9501      	str	r5, [sp, #4]
   283b2:	9300      	str	r3, [sp, #0]
	ticks_to_offset = HAL_TICKER_US_TO_TICKS(conn->llcp_conn_param.offset0 *
   283b4:	9004      	str	r0, [sp, #16]
	win_offset_calc(conn, 1, &ticks_to_offset,
   283b6:	f8b4 319a 	ldrh.w	r3, [r4, #410]	; 0x19a
   283ba:	4620      	mov	r0, r4
   283bc:	aa04      	add	r2, sp, #16
   283be:	2101      	movs	r1, #1
   283c0:	f016 fb5e 	bl	3ea80 <win_offset_calc.constprop.0>
		while (offset_index_m < offset_m_max) {
   283c4:	f89d 000f 	ldrb.w	r0, [sp, #15]
   283c8:	46b0      	mov	r8, r6
	uint8_t has_offset_s = 0U;
   283ca:	4637      	mov	r7, r6
   283cc:	f504 79d6 	add.w	r9, r4, #428	; 0x1ac
			if (win_offset_s != 0xffff) {
   283d0:	f64f 76ff 	movw	r6, #65535	; 0xffff
		win_offset_s =
   283d4:	f8b9 c000 	ldrh.w	ip, [r9]
		while (offset_index_m < offset_m_max) {
   283d8:	b178      	cbz	r0, 283fa <ull_sched_mfy_win_offset_select+0x82>
   283da:	462a      	mov	r2, r5
		uint8_t offset_index_m = 0U;
   283dc:	2300      	movs	r3, #0
			if (win_offset_s != 0xffff) {
   283de:	45b4      	cmp	ip, r6
			offset_index_m++;
   283e0:	f103 0101 	add.w	r1, r3, #1
			if (win_offset_s != 0xffff) {
   283e4:	d004      	beq.n	283f0 <ull_sched_mfy_win_offset_select+0x78>
				if (win_offset_s ==
   283e6:	f8b2 e000 	ldrh.w	lr, [r2]
   283ea:	45e6      	cmp	lr, ip
   283ec:	d01b      	beq.n	28426 <ull_sched_mfy_win_offset_select+0xae>
				has_offset_s = 1U;
   283ee:	2701      	movs	r7, #1
			offset_index_m++;
   283f0:	b2cb      	uxtb	r3, r1
		while (offset_index_m < offset_m_max) {
   283f2:	4283      	cmp	r3, r0
   283f4:	f102 0202 	add.w	r2, r2, #2
   283f8:	d1f1      	bne.n	283de <ull_sched_mfy_win_offset_select+0x66>
	while (offset_index_s < OFFSET_S_MAX) {
   283fa:	f108 0801 	add.w	r8, r8, #1
   283fe:	f1b8 0f06 	cmp.w	r8, #6
   28402:	f109 0902 	add.w	r9, r9, #2
   28406:	d1e5      	bne.n	283d4 <ull_sched_mfy_win_offset_select+0x5c>
			     (void *)conn->llcp.conn_upd.pdu_win_offset);
   28408:	f8d4 30f8 	ldr.w	r3, [r4, #248]	; 0xf8
	} else if (!has_offset_s) {
   2840c:	bb27      	cbnz	r7, 28458 <ull_sched_mfy_win_offset_select+0xe0>
		conn->llcp_cu.win_offset_us = win_offset_m[0] *
   2840e:	f8bd 2014 	ldrh.w	r2, [sp, #20]
   28412:	f240 41e2 	movw	r1, #1250	; 0x4e2
   28416:	fb02 f101 	mul.w	r1, r2, r1
	dst[1] = val >> 8;
   2841a:	0a10      	lsrs	r0, r2, #8
   2841c:	f8c4 1124 	str.w	r1, [r4, #292]	; 0x124
	dst[0] = val;
   28420:	701a      	strb	r2, [r3, #0]
	dst[1] = val >> 8;
   28422:	7058      	strb	r0, [r3, #1]
		conn->llcp_cu.state = LLCP_CUI_STATE_OFFS_RDY;
   28424:	e00e      	b.n	28444 <ull_sched_mfy_win_offset_select+0xcc>
		if (offset_index_m < offset_m_max) {
   28426:	4283      	cmp	r3, r0
   28428:	d2e7      	bcs.n	283fa <ull_sched_mfy_win_offset_select+0x82>
			     (void *)conn->llcp.conn_upd.pdu_win_offset);
   2842a:	f8d4 20f8 	ldr.w	r2, [r4, #248]	; 0xf8
		conn->llcp_cu.win_offset_us = win_offset_s * CONN_INT_UNIT_US;
   2842e:	f240 43e2 	movw	r3, #1250	; 0x4e2
   28432:	fb03 f30c 	mul.w	r3, r3, ip
   28436:	ea4f 211c 	mov.w	r1, ip, lsr #8
   2843a:	f8c4 3124 	str.w	r3, [r4, #292]	; 0x124
	dst[0] = val;
   2843e:	f882 c000 	strb.w	ip, [r2]
	dst[1] = val >> 8;
   28442:	7051      	strb	r1, [r2, #1]
				has_offset_s = 1U;
   28444:	2204      	movs	r2, #4
		conn->llcp_cu.state = LLCP_CUI_STATE_OFFS_RDY;
   28446:	f894 311a 	ldrb.w	r3, [r4, #282]	; 0x11a
   2844a:	f362 0302 	bfi	r3, r2, #0, #3
   2844e:	f884 311a 	strb.w	r3, [r4, #282]	; 0x11a
}
   28452:	b009      	add	sp, #36	; 0x24
   28454:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   28458:	f813 2c05 	ldrb.w	r2, [r3, #-5]
		pdu_ctrl_tx->len =
   2845c:	2003      	movs	r0, #3
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   2845e:	4302      	orrs	r2, r0
		pdu_ctrl_tx->llctrl.opcode =
   28460:	f640 7111 	movw	r1, #3857	; 0xf11
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   28464:	f803 2c05 	strb.w	r2, [r3, #-5]
		pdu_ctrl_tx->llctrl.reject_ext_ind.error_code =
   28468:	2220      	movs	r2, #32
   2846a:	701a      	strb	r2, [r3, #0]
		pdu_ctrl_tx->len =
   2846c:	f803 0c04 	strb.w	r0, [r3, #-4]
		pdu_ctrl_tx->llctrl.opcode =
   28470:	f823 1c02 	strh.w	r1, [r3, #-2]
		pdu_ctrl_tx->llctrl.reject_ext_ind.error_code =
   28474:	2205      	movs	r2, #5
   28476:	e7e6      	b.n	28446 <ull_sched_mfy_win_offset_select+0xce>
   28478:	1afd498d 	.word	0x1afd498d
   2847c:	00000007 	.word	0x00000007
   28480:	3b9aca00 	.word	0x3b9aca00
   28484:	00000000 	.word	0x00000000

00028488 <isr_window>:
	 */
	radio_tmr_end_capture();
}

static void isr_window(void *param)
{
   28488:	b538      	push	{r3, r4, r5, lr}
   2848a:	4604      	mov	r4, r0
	uint32_t remainder_us;
	struct lll_scan *lll;

	isr_common_done(param);
   2848c:	f018 f9b2 	bl	407f4 <isr_common_done>

	lll = param;

	/* Next radio channel to scan, round-robin 37, 38, and 39. */
	if (++lll->chan == ADV_CHAN_MAX) {
   28490:	7da3      	ldrb	r3, [r4, #22]
   28492:	7da2      	ldrb	r2, [r4, #22]
   28494:	f3c3 0341 	ubfx	r3, r3, #1, #2
   28498:	3301      	adds	r3, #1
   2849a:	f003 0303 	and.w	r3, r3, #3
   2849e:	2b03      	cmp	r3, #3
		lll->chan = 0U;
   284a0:	bf08      	it	eq
   284a2:	2300      	moveq	r3, #0
   284a4:	f363 0242 	bfi	r2, r3, #1, #2
	}
	lll_chan_set(37 + lll->chan);
   284a8:	bf14      	ite	ne
   284aa:	f103 0025 	addne.w	r0, r3, #37	; 0x25
   284ae:	2025      	moveq	r0, #37	; 0x25
   284b0:	75a2      	strb	r2, [r4, #22]
   284b2:	f017 f999 	bl	3f7e8 <lll_chan_set>

#if defined(CONFIG_BT_CENTRAL)
	bool is_sched_advanced = IS_ENABLED(CONFIG_BT_CTLR_SCHED_ADVANCED) &&
				 lll->conn && lll->conn_win_offset_us;
   284b6:	6863      	ldr	r3, [r4, #4]
   284b8:	b10b      	cbz	r3, 284be <isr_window+0x36>
   284ba:	6923      	ldr	r3, [r4, #16]
   284bc:	b94b      	cbnz	r3, 284d2 <isr_window+0x4a>
		ticks_anchor_prev = radio_tmr_start_get();
	} else {
		ticks_anchor_prev = 0U;
	}

	ticks_at_start = ticker_ticks_now_get() +
   284be:	f00d fb9d 	bl	35bfc <ticker_ticks_now_get>
			 HAL_TICKER_CNTR_CMP_OFFSET_MIN;
	remainder_us = radio_tmr_start_tick(0, ticks_at_start);
   284c2:	1cc1      	adds	r1, r0, #3
   284c4:	2000      	movs	r0, #0
   284c6:	f019 fdf5 	bl	420b4 <radio_tmr_start_tick>
		 * interval units until it is in the future.
		 */
		lll->conn_win_offset_us -= ticks_delta_us;
	}
#endif /* CONFIG_BT_CENTRAL */
}
   284ca:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	radio_tmr_end_capture();
   284ce:	f019 be6f 	b.w	421b0 <radio_tmr_end_capture>
		ticks_anchor_prev = radio_tmr_start_get();
   284d2:	f019 fe21 	bl	42118 <radio_tmr_start_get>
   284d6:	4605      	mov	r5, r0
	ticks_at_start = ticker_ticks_now_get() +
   284d8:	f00d fb90 	bl	35bfc <ticker_ticks_now_get>
	remainder_us = radio_tmr_start_tick(0, ticks_at_start);
   284dc:	1cc1      	adds	r1, r0, #3
   284de:	2000      	movs	r0, #0
   284e0:	f019 fde8 	bl	420b4 <radio_tmr_start_tick>
	radio_tmr_end_capture();
   284e4:	f019 fe64 	bl	421b0 <radio_tmr_end_capture>
		ticks_anchor_new = radio_tmr_start_get();
   284e8:	f019 fe16 	bl	42118 <radio_tmr_start_get>
		ticks_delta = ticker_ticks_diff_get(ticks_anchor_new,
   284ec:	4629      	mov	r1, r5
   284ee:	f00d fb87 	bl	35c00 <ticker_ticks_diff_get>
		ticks_delta_us = HAL_TICKER_TICKS_TO_US(ticks_delta);
   284f2:	4a0b      	ldr	r2, [pc, #44]	; (28520 <isr_window+0x98>)
		ticks_delta = ticker_ticks_diff_get(ticks_anchor_new,
   284f4:	4603      	mov	r3, r0
		ticks_delta_us = HAL_TICKER_TICKS_TO_US(ticks_delta);
   284f6:	2107      	movs	r1, #7
   284f8:	fba0 0202 	umull	r0, r2, r0, r2
   284fc:	fb01 2103 	mla	r1, r1, r3, r2
   28500:	a305      	add	r3, pc, #20	; (adr r3, 28518 <isr_window+0x90>)
   28502:	e9d3 2300 	ldrd	r2, r3, [r3]
   28506:	f7fd fdfb 	bl	26100 <__aeabi_uldivmod>
		lll->conn_win_offset_us -= ticks_delta_us;
   2850a:	6923      	ldr	r3, [r4, #16]
   2850c:	1a1b      	subs	r3, r3, r0
   2850e:	6123      	str	r3, [r4, #16]
}
   28510:	bd38      	pop	{r3, r4, r5, pc}
   28512:	bf00      	nop
   28514:	f3af 8000 	nop.w
   28518:	3b9aca00 	.word	0x3b9aca00
   2851c:	00000000 	.word	0x00000000
   28520:	1afd498d 	.word	0x1afd498d
   28524:	00000000 	.word	0x00000000

00028528 <isr_rx>:
{
   28528:	b5f0      	push	{r4, r5, r6, r7, lr}
   2852a:	b087      	sub	sp, #28
   2852c:	4604      	mov	r4, r0
	trx_done = radio_is_done();
   2852e:	f019 fbf5 	bl	41d1c <radio_is_done>
	if (trx_done) {
   28532:	b2c0      	uxtb	r0, r0
   28534:	b950      	cbnz	r0, 2854c <isr_rx+0x24>
	lll_isr_status_reset();
   28536:	f017 f9af 	bl	3f898 <lll_isr_status_reset>
	radio_isr_set(isr_done, lll);
   2853a:	48c3      	ldr	r0, [pc, #780]	; (28848 <isr_rx+0x320>)
   2853c:	4621      	mov	r1, r4
   2853e:	f019 fad1 	bl	41ae4 <radio_isr_set>
}
   28542:	b007      	add	sp, #28
   28544:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	radio_disable();
   28548:	f019 bbbe 	b.w	41cc8 <radio_disable>
		crc_ok = radio_crc_is_valid();
   2854c:	f019 fc06 	bl	41d5c <radio_crc_is_valid>
   28550:	4605      	mov	r5, r0
		devmatch_ok = radio_filter_has_match();
   28552:	f019 fd01 	bl	41f58 <radio_filter_has_match>
   28556:	4607      	mov	r7, r0
		devmatch_id = radio_filter_match_get();
   28558:	f019 fd08 	bl	41f6c <radio_filter_match_get>
		rssi_ready = radio_rssi_is_ready();
   2855c:	f019 fce0 	bl	41f20 <radio_rssi_is_ready>
	if (!trx_done || !crc_ok) {
   28560:	b2ed      	uxtb	r5, r5
		rssi_ready = radio_rssi_is_ready();
   28562:	4606      	mov	r6, r0
		phy_flags_rx = radio_phy_flags_rx_get();
   28564:	f019 fcc2 	bl	41eec <radio_phy_flags_rx_get>
	lll_isr_status_reset();
   28568:	f017 f996 	bl	3f898 <lll_isr_status_reset>
	if (!trx_done || !crc_ok) {
   2856c:	2d00      	cmp	r5, #0
   2856e:	d0e4      	beq.n	2853a <isr_rx+0x12>
	node_rx = ull_pdu_rx_alloc_peek(1);
   28570:	2001      	movs	r0, #1
   28572:	f00f fd8b 	bl	3808c <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
   28576:	4605      	mov	r5, r0
   28578:	2800      	cmp	r0, #0
   2857a:	f000 80ee 	beq.w	2875a <isr_rx+0x232>
	return ((lll->filter_policy & SCAN_FP_FILTER) == 0U) ||
   2857e:	7da3      	ldrb	r3, [r4, #22]
   28580:	f3c3 00c0 	ubfx	r0, r3, #3, #1
   28584:	071b      	lsls	r3, r3, #28
   28586:	f100 8099 	bmi.w	286bc <isr_rx+0x194>
	/* Initiator */
	/* Note: connectable ADV_EXT_IND is handled as any other ADV_EXT_IND
	 *       because we need to receive AUX_ADV_IND anyway.
	 */
	} else if (lll->conn && !lll->conn->central.cancelled &&
		   (pdu_adv_rx->type != PDU_ADV_TYPE_EXT_IND) &&
   2858a:	7f2b      	ldrb	r3, [r5, #28]
	} else if (lll->conn && !lll->conn->central.cancelled &&
   2858c:	6861      	ldr	r1, [r4, #4]
		rssi_ready = radio_rssi_is_ready();
   2858e:	b2f6      	uxtb	r6, r6
		   (pdu_adv_rx->type != PDU_ADV_TYPE_EXT_IND) &&
   28590:	f003 020f 	and.w	r2, r3, #15
	} else if (lll->conn && !lll->conn->central.cancelled &&
   28594:	2900      	cmp	r1, #0
   28596:	f000 80aa 	beq.w	286ee <isr_rx+0x1c6>
   2859a:	6861      	ldr	r1, [r4, #4]
   2859c:	f891 1020 	ldrb.w	r1, [r1, #32]
   285a0:	078f      	lsls	r7, r1, #30
   285a2:	f100 80a4 	bmi.w	286ee <isr_rx+0x1c6>
   285a6:	2a07      	cmp	r2, #7
   285a8:	d0c7      	beq.n	2853a <isr_rx+0x12>
				       const struct pdu_adv *pdu,
				       uint8_t rl_idx)
{
	return ((((lll->filter_policy & SCAN_FP_FILTER) != 0U) ||
		lll_scan_adva_check(lll, pdu->tx_addr, pdu->adv_ind.addr,
				    rl_idx)) &&
   285aa:	2800      	cmp	r0, #0
   285ac:	f000 808b 	beq.w	286c6 <isr_rx+0x19e>
   285b0:	2a00      	cmp	r2, #0
   285b2:	f040 819d 	bne.w	288f0 <isr_rx+0x3c8>
		(((pdu->type == PDU_ADV_TYPE_ADV_IND) &&
   285b6:	7f6b      	ldrb	r3, [r5, #29]
   285b8:	2b25      	cmp	r3, #37	; 0x25
   285ba:	d8be      	bhi.n	2853a <isr_rx+0x12>
			rx = ull_pdu_rx_alloc_peek(4);
   285bc:	2004      	movs	r0, #4
   285be:	f00f fd65 	bl	3808c <ull_pdu_rx_alloc_peek>
		if (!rx) {
   285c2:	2800      	cmp	r0, #0
   285c4:	d0b9      	beq.n	2853a <isr_rx+0x12>
		pdu_end_us = radio_tmr_end_get();
   285c6:	f019 fdfb 	bl	421c0 <radio_tmr_end_get>
		if (!lll->ticks_window) {
   285ca:	6a23      	ldr	r3, [r4, #32]
		pdu_end_us = radio_tmr_end_get();
   285cc:	4606      	mov	r6, r0
		if (!lll->ticks_window) {
   285ce:	b943      	cbnz	r3, 285e2 <isr_rx+0xba>
			scan_interval_us = lll->interval * SCAN_INT_UNIT_US;
   285d0:	8be3      	ldrh	r3, [r4, #30]
   285d2:	f240 2271 	movw	r2, #625	; 0x271
   285d6:	fb02 f303 	mul.w	r3, r2, r3
			pdu_end_us %= scan_interval_us;
   285da:	fbb0 f2f3 	udiv	r2, r0, r3
   285de:	fb03 0612 	mls	r6, r3, r2, r0
		if (pdu_end_us > (HAL_TICKER_TICKS_TO_US(ull->ticks_slot) -
   285e2:	6822      	ldr	r2, [r4, #0]
   285e4:	4b99      	ldr	r3, [pc, #612]	; (2884c <isr_rx+0x324>)
   285e6:	6912      	ldr	r2, [r2, #16]
   285e8:	2107      	movs	r1, #7
   285ea:	fba2 0303 	umull	r0, r3, r2, r3
   285ee:	fb01 3102 	mla	r1, r1, r2, r3
   285f2:	a393      	add	r3, pc, #588	; (adr r3, 28840 <isr_rx+0x318>)
   285f4:	e9d3 2300 	ldrd	r2, r3, [r3]
   285f8:	f7fd fd82 	bl	26100 <__aeabi_uldivmod>
				  EVENT_IFS_US - 352 - EVENT_OVERHEAD_START_US -
   285fc:	f2a0 5304 	subw	r3, r0, #1284	; 0x504
		if (pdu_end_us > (HAL_TICKER_TICKS_TO_US(ull->ticks_slot) -
   28600:	42b3      	cmp	r3, r6
   28602:	d39a      	bcc.n	2853a <isr_rx+0x12>
		radio_switch_complete_and_disable();
   28604:	f019 fc64 	bl	41ed0 <radio_switch_complete_and_disable>
			init_tx_addr = lll->init_addr_type;
   28608:	7da6      	ldrb	r6, [r4, #22]
		lll_conn = lll->conn;
   2860a:	6863      	ldr	r3, [r4, #4]
		pdu_tx = (void *)radio_pkt_scratch_get();
   2860c:	f019 fbb4 	bl	41d78 <radio_pkt_scratch_get>
					     pdu_adv_rx->tx_addr,
   28610:	7f2b      	ldrb	r3, [r5, #28]
		lll_scan_prepare_connect_req(lll, pdu_tx, PHY_LEGACY,
   28612:	a905      	add	r1, sp, #20
					     pdu_adv_rx->adv_ind.addr,
   28614:	f105 021e 	add.w	r2, r5, #30
		lll_scan_prepare_connect_req(lll, pdu_tx, PHY_LEGACY,
   28618:	9103      	str	r1, [sp, #12]
			init_tx_addr = lll->init_addr_type;
   2861a:	f3c6 1680 	ubfx	r6, r6, #6, #1
			init_addr = lll->init_addr;
   2861e:	f104 0118 	add.w	r1, r4, #24
		pdu_tx = (void *)radio_pkt_scratch_get();
   28622:	4607      	mov	r7, r0
		lll_scan_prepare_connect_req(lll, pdu_tx, PHY_LEGACY,
   28624:	f3c3 1380 	ubfx	r3, r3, #6, #1
   28628:	9200      	str	r2, [sp, #0]
   2862a:	9102      	str	r1, [sp, #8]
   2862c:	2200      	movs	r2, #0
   2862e:	4601      	mov	r1, r0
   28630:	9601      	str	r6, [sp, #4]
   28632:	4620      	mov	r0, r4
   28634:	f018 faa2 	bl	40b7c <lll_scan_prepare_connect_req>
		radio_pkt_tx_set(pdu_tx);
   28638:	4638      	mov	r0, r7
   2863a:	f019 fb23 	bl	41c84 <radio_pkt_tx_set>
		LL_ASSERT(!radio_is_ready());
   2863e:	f019 fb63 	bl	41d08 <radio_is_ready>
   28642:	2800      	cmp	r0, #0
   28644:	f040 818a 	bne.w	2895c <isr_rx+0x434>
		radio_isr_set(isr_done_cleanup, lll);
   28648:	4621      	mov	r1, r4
   2864a:	4881      	ldr	r0, [pc, #516]	; (28850 <isr_rx+0x328>)
   2864c:	f019 fa4a 	bl	41ae4 <radio_isr_set>
		lll->conn->central.initiated = 1U;
   28650:	6862      	ldr	r2, [r4, #4]
   28652:	f892 3020 	ldrb.w	r3, [r2, #32]
   28656:	f043 0301 	orr.w	r3, r3, #1
   2865a:	f882 3020 	strb.w	r3, [r2, #32]
		lll->is_stop = 1U;
   2865e:	7da3      	ldrb	r3, [r4, #22]
   28660:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   28664:	75a3      	strb	r3, [r4, #22]
		rx = ull_pdu_rx_alloc();
   28666:	f00f fd33 	bl	380d0 <ull_pdu_rx_alloc>
		rx->hdr.type = NODE_RX_TYPE_CONNECTION;
   2866a:	2317      	movs	r3, #23
   2866c:	7103      	strb	r3, [r0, #4]
		rx->hdr.handle = 0xffff;
   2866e:	f64f 73ff 	movw	r3, #65535	; 0xffff
		rx = ull_pdu_rx_alloc();
   28672:	4606      	mov	r6, r0
		rx->hdr.handle = 0xffff;
   28674:	80c3      	strh	r3, [r0, #6]
		memcpy(rx->pdu, pdu_tx, (offsetof(struct pdu_adv, connect_ind) +
   28676:	2224      	movs	r2, #36	; 0x24
   28678:	4639      	mov	r1, r7
		uint8_t pdu_adv_rx_chan_sel = pdu_adv_rx->chan_sel;
   2867a:	7f2d      	ldrb	r5, [r5, #28]
		memcpy(rx->pdu, pdu_tx, (offsetof(struct pdu_adv, connect_ind) +
   2867c:	301c      	adds	r0, #28
   2867e:	f022 fbfc 	bl	4ae7a <memcpy>
		pdu_adv_rx->chan_sel = pdu_adv_rx_chan_sel;
   28682:	7f33      	ldrb	r3, [r6, #28]
		ftr->param = lll;
   28684:	60b4      	str	r4, [r6, #8]
		uint8_t pdu_adv_rx_chan_sel = pdu_adv_rx->chan_sel;
   28686:	f3c5 1540 	ubfx	r5, r5, #5, #1
		pdu_adv_rx->chan_sel = pdu_adv_rx_chan_sel;
   2868a:	f365 1345 	bfi	r3, r5, #5, #1
   2868e:	7733      	strb	r3, [r6, #28]
		ftr->ticks_anchor = radio_tmr_start_get();
   28690:	f019 fd42 	bl	42118 <radio_tmr_start_get>
				    radio_rx_chain_delay_get(PHY_1M, 0);
   28694:	2100      	movs	r1, #0
		ftr->ticks_anchor = radio_tmr_start_get();
   28696:	6130      	str	r0, [r6, #16]
				    radio_rx_chain_delay_get(PHY_1M, 0);
   28698:	2001      	movs	r0, #1
		ftr->radio_end_us = conn_space_us -
   2869a:	9c05      	ldr	r4, [sp, #20]
				    radio_rx_chain_delay_get(PHY_1M, 0);
   2869c:	f019 fb02 	bl	41ca4 <radio_rx_chain_delay_get>
		ftr->radio_end_us = conn_space_us -
   286a0:	1a24      	subs	r4, r4, r0
   286a2:	6174      	str	r4, [r6, #20]
			ftr->extra = ull_pdu_rx_alloc();
   286a4:	f00f fd14 	bl	380d0 <ull_pdu_rx_alloc>
		ull_rx_put(rx->hdr.link, rx);
   286a8:	4631      	mov	r1, r6
			ftr->extra = ull_pdu_rx_alloc();
   286aa:	60f0      	str	r0, [r6, #12]
		ull_rx_put(rx->hdr.link, rx);
   286ac:	6830      	ldr	r0, [r6, #0]
   286ae:	f00f fd25 	bl	380fc <ull_rx_put>
}
   286b2:	b007      	add	sp, #28
   286b4:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		ull_rx_sched();
   286b8:	f00f bd30 	b.w	3811c <ull_rx_sched>
	return ((lll->filter_policy & SCAN_FP_FILTER) == 0U) ||
   286bc:	b2ff      	uxtb	r7, r7
   286be:	2f00      	cmp	r7, #0
   286c0:	f43f af3b 	beq.w	2853a <isr_rx+0x12>
   286c4:	e761      	b.n	2858a <isr_rx+0x62>
	return ((lll->adv_addr_type == addr_type) &&
   286c6:	7de1      	ldrb	r1, [r4, #23]
   286c8:	f3c3 1080 	ubfx	r0, r3, #6, #1
   286cc:	f001 0101 	and.w	r1, r1, #1
   286d0:	4288      	cmp	r0, r1
   286d2:	d10c      	bne.n	286ee <isr_rx+0x1c6>
		!memcmp(lll->adv_addr, addr, BDADDR_SIZE));
   286d4:	2206      	movs	r2, #6
   286d6:	f105 011e 	add.w	r1, r5, #30
   286da:	f104 0008 	add.w	r0, r4, #8
   286de:	f022 fbbc 	bl	4ae5a <memcmp>
	} else if (((pdu_adv_rx->type == PDU_ADV_TYPE_ADV_IND) ||
   286e2:	7f2b      	ldrb	r3, [r5, #28]
   286e4:	f003 020f 	and.w	r2, r3, #15
	return ((lll->adv_addr_type == addr_type) &&
   286e8:	2800      	cmp	r0, #0
   286ea:	f43f af61 	beq.w	285b0 <isr_rx+0x88>
	} else if (((pdu_adv_rx->type == PDU_ADV_TYPE_ADV_IND) ||
   286ee:	2a00      	cmp	r2, #0
   286f0:	f040 80b8 	bne.w	28864 <isr_rx+0x33c>
		   (pdu_adv_rx->len <= sizeof(struct pdu_adv_adv_ind)) &&
   286f4:	7f6a      	ldrb	r2, [r5, #29]
		    (pdu_adv_rx->type == PDU_ADV_TYPE_SCAN_IND)) &&
   286f6:	2a25      	cmp	r2, #37	; 0x25
		   (pdu_adv_rx->len <= sizeof(struct pdu_adv_adv_ind)) &&
   286f8:	4613      	mov	r3, r2
		    (pdu_adv_rx->type == PDU_ADV_TYPE_SCAN_IND)) &&
   286fa:	f63f af1e 	bhi.w	2853a <isr_rx+0x12>
		   lll->type && !lll->state &&
   286fe:	7da1      	ldrb	r1, [r4, #22]
   28700:	f001 0121 	and.w	r1, r1, #33	; 0x21
   28704:	2920      	cmp	r1, #32
   28706:	d036      	beq.n	28776 <isr_rx+0x24e>
	bool dir_report = false;
   28708:	2700      	movs	r7, #0
		   isr_scan_rsp_adva_matches(pdu_adv_rx))) &&
   2870a:	2b00      	cmp	r3, #0
   2870c:	f43f af15 	beq.w	2853a <isr_rx+0x12>
		   (!lll->conn || (pdu_adv_rx->type == PDU_ADV_TYPE_EXT_IND))) {
   28710:	6863      	ldr	r3, [r4, #4]
		 (pdu_adv_rx->len != 0) &&
   28712:	b12b      	cbz	r3, 28720 <isr_rx+0x1f8>
		   (!lll->conn || (pdu_adv_rx->type == PDU_ADV_TYPE_EXT_IND))) {
   28714:	7f2b      	ldrb	r3, [r5, #28]
   28716:	f003 030f 	and.w	r3, r3, #15
   2871a:	2b07      	cmp	r3, #7
   2871c:	f47f af0d 	bne.w	2853a <isr_rx+0x12>
			      bool dir_report)
{
	struct node_rx_pdu *node_rx;
	int err = 0;

	node_rx = ull_pdu_rx_alloc_peek(3);
   28720:	2003      	movs	r0, #3
   28722:	f00f fcb3 	bl	3808c <ull_pdu_rx_alloc_peek>
	if (!node_rx) {
   28726:	4605      	mov	r5, r0
   28728:	2800      	cmp	r0, #0
   2872a:	f43f af06 	beq.w	2853a <isr_rx+0x12>
		return -ENOBUFS;
	}
	ull_pdu_rx_alloc();
   2872e:	f00f fccf 	bl	380d0 <ull_pdu_rx_alloc>

	/* Prepare the report (adv or scan resp) */
	node_rx->hdr.handle = 0xffff;
   28732:	f64f 73ff 	movw	r3, #65535	; 0xffff
   28736:	80eb      	strh	r3, [r5, #6]
			}
			break;
		}
#endif /* CONFIG_BT_CTLR_ADV_EXT */
	} else {
		node_rx->hdr.type = NODE_RX_TYPE_REPORT;
   28738:	2305      	movs	r3, #5
   2873a:	712b      	strb	r3, [r5, #4]
	}

	node_rx->hdr.rx_ftr.rssi = (rssi_ready) ? radio_rssi_get() :
   2873c:	2e00      	cmp	r6, #0
   2873e:	d17b      	bne.n	28838 <isr_rx+0x310>
   28740:	207f      	movs	r0, #127	; 0x7f
#endif /* CONFIG_BT_CTLR_ADV_EXT */
#endif /* CONFIG_BT_CTLR_PRIVACY */

#if defined(CONFIG_BT_CTLR_EXT_SCAN_FP)
	/* save the directed adv report flag */
	node_rx->hdr.rx_ftr.direct = dir_report;
   28742:	7e6b      	ldrb	r3, [r5, #25]
	node_rx->hdr.rx_ftr.rssi = (rssi_ready) ? radio_rssi_get() :
   28744:	7628      	strb	r0, [r5, #24]
	node_rx->hdr.rx_ftr.direct = dir_report;
   28746:	f367 0300 	bfi	r3, r7, #0, #1
		node_rx->hdr.rx_ftr.chan = _radio.scanner.chan - 1;
		node_rx->hdr.rx_ftr.ticks_anchor = _radio.ticks_anchor;
	}
#endif /* CONFIG_BT_CTLR_EXT_SCAN_FP */

	ull_rx_put(node_rx->hdr.link, node_rx);
   2874a:	6828      	ldr	r0, [r5, #0]
	node_rx->hdr.rx_ftr.direct = dir_report;
   2874c:	766b      	strb	r3, [r5, #25]
	ull_rx_put(node_rx->hdr.link, node_rx);
   2874e:	4629      	mov	r1, r5
   28750:	f00f fcd4 	bl	380fc <ull_rx_put>
	ull_rx_sched();
   28754:	f00f fce2 	bl	3811c <ull_rx_sched>
	if (!err) {
   28758:	e6ef      	b.n	2853a <isr_rx+0x12>
	LL_ASSERT(node_rx);
   2875a:	4a3e      	ldr	r2, [pc, #248]	; (28854 <isr_rx+0x32c>)
   2875c:	493e      	ldr	r1, [pc, #248]	; (28858 <isr_rx+0x330>)
   2875e:	483f      	ldr	r0, [pc, #252]	; (2885c <isr_rx+0x334>)
   28760:	f240 23d2 	movw	r3, #722	; 0x2d2
   28764:	f020 fc8e 	bl	49084 <assert_print>
   28768:	4040      	eors	r0, r0
   2876a:	f380 8811 	msr	BASEPRI, r0
   2876e:	f04f 0003 	mov.w	r0, #3
   28772:	df02      	svc	2
   28774:	e703      	b.n	2857e <isr_rx+0x56>
		   !lll->conn) {
   28776:	6867      	ldr	r7, [r4, #4]
		   lll->type && !lll->state &&
   28778:	2f00      	cmp	r7, #0
   2877a:	f040 80d7 	bne.w	2892c <isr_rx+0x404>
		radio_tmr_tifs_set(EVENT_IFS_US);
   2877e:	2096      	movs	r0, #150	; 0x96
   28780:	f019 fc0a 	bl	41f98 <radio_tmr_tifs_set>
		radio_switch_complete_and_rx(0);
   28784:	4638      	mov	r0, r7
   28786:	f019 fafb 	bl	41d80 <radio_switch_complete_and_rx>
	node_rx = ull_pdu_rx_alloc_peek(3);
   2878a:	2003      	movs	r0, #3
   2878c:	f00f fc7e 	bl	3808c <ull_pdu_rx_alloc_peek>
	if (!node_rx) {
   28790:	4607      	mov	r7, r0
   28792:	2800      	cmp	r0, #0
   28794:	f43f aed1 	beq.w	2853a <isr_rx+0x12>
	ull_pdu_rx_alloc();
   28798:	f00f fc9a 	bl	380d0 <ull_pdu_rx_alloc>
	node_rx->hdr.handle = 0xffff;
   2879c:	f64f 73ff 	movw	r3, #65535	; 0xffff
   287a0:	80fb      	strh	r3, [r7, #6]
		node_rx->hdr.type = NODE_RX_TYPE_REPORT;
   287a2:	2305      	movs	r3, #5
   287a4:	713b      	strb	r3, [r7, #4]
	node_rx->hdr.rx_ftr.rssi = (rssi_ready) ? radio_rssi_get() :
   287a6:	2e00      	cmp	r6, #0
   287a8:	f040 80ce 	bne.w	28948 <isr_rx+0x420>
   287ac:	237f      	movs	r3, #127	; 0x7f
	node_rx->hdr.rx_ftr.direct = dir_report;
   287ae:	7e7a      	ldrb	r2, [r7, #25]
	node_rx->hdr.rx_ftr.rssi = (rssi_ready) ? radio_rssi_get() :
   287b0:	763b      	strb	r3, [r7, #24]
	node_rx->hdr.rx_ftr.direct = dir_report;
   287b2:	f36f 0200 	bfc	r2, #0, #1
   287b6:	767a      	strb	r2, [r7, #25]
	ull_rx_put(node_rx->hdr.link, node_rx);
   287b8:	4639      	mov	r1, r7
   287ba:	6838      	ldr	r0, [r7, #0]
   287bc:	f00f fc9e 	bl	380fc <ull_rx_put>
	ull_rx_sched();
   287c0:	f00f fcac 	bl	3811c <ull_rx_sched>
		pdu_tx = (void *)radio_pkt_scratch_get();
   287c4:	f019 fad8 	bl	41d78 <radio_pkt_scratch_get>
		pdu_tx->type = PDU_ADV_TYPE_SCAN_REQ;
   287c8:	7803      	ldrb	r3, [r0, #0]
   287ca:	2203      	movs	r2, #3
   287cc:	f362 0303 	bfi	r3, r2, #0, #4
   287d0:	7003      	strb	r3, [r0, #0]
		pdu_tx->rx_addr = pdu_adv_rx->tx_addr;
   287d2:	7f2b      	ldrb	r3, [r5, #28]
   287d4:	7802      	ldrb	r2, [r0, #0]
   287d6:	f3c3 1380 	ubfx	r3, r3, #6, #1
   287da:	f363 12c7 	bfi	r2, r3, #7, #1
		pdu_tx->len = sizeof(struct pdu_adv_scan_req);
   287de:	230c      	movs	r3, #12
		pdu_tx->rx_addr = pdu_adv_rx->tx_addr;
   287e0:	7002      	strb	r2, [r0, #0]
		pdu_tx->len = sizeof(struct pdu_adv_scan_req);
   287e2:	7043      	strb	r3, [r0, #1]
			pdu_tx->tx_addr = lll->init_addr_type;
   287e4:	7da3      	ldrb	r3, [r4, #22]
   287e6:	b2d2      	uxtb	r2, r2
   287e8:	f3c3 1380 	ubfx	r3, r3, #6, #1
   287ec:	f363 1286 	bfi	r2, r3, #6, #1
		pdu_tx = (void *)radio_pkt_scratch_get();
   287f0:	4606      	mov	r6, r0
			memcpy(&pdu_tx->scan_req.scan_addr[0],
   287f2:	f104 0118 	add.w	r1, r4, #24
			pdu_tx->tx_addr = lll->init_addr_type;
   287f6:	f800 2b02 	strb.w	r2, [r0], #2
			memcpy(&pdu_tx->scan_req.scan_addr[0],
   287fa:	2206      	movs	r2, #6
   287fc:	f022 fb3d 	bl	4ae7a <memcpy>
		memcpy(&pdu_tx->scan_req.adv_addr[0],
   28800:	2206      	movs	r2, #6
   28802:	f105 011e 	add.w	r1, r5, #30
   28806:	f106 0008 	add.w	r0, r6, #8
   2880a:	f022 fb36 	bl	4ae7a <memcpy>
		radio_pkt_tx_set(pdu_tx);
   2880e:	4630      	mov	r0, r6
   28810:	f019 fa38 	bl	41c84 <radio_pkt_tx_set>
		LL_ASSERT(!radio_is_ready());
   28814:	f019 fa78 	bl	41d08 <radio_is_ready>
   28818:	2800      	cmp	r0, #0
   2881a:	f040 80b0 	bne.w	2897e <isr_rx+0x456>
		radio_tmr_end_capture();
   2881e:	f019 fcc7 	bl	421b0 <radio_tmr_end_capture>
		lll->state = 1U;
   28822:	7da3      	ldrb	r3, [r4, #22]
		radio_isr_set(isr_tx, lll);
   28824:	480e      	ldr	r0, [pc, #56]	; (28860 <isr_rx+0x338>)
		lll->state = 1U;
   28826:	f043 0301 	orr.w	r3, r3, #1
		radio_isr_set(isr_tx, lll);
   2882a:	4621      	mov	r1, r4
		lll->state = 1U;
   2882c:	75a3      	strb	r3, [r4, #22]
}
   2882e:	b007      	add	sp, #28
   28830:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		radio_isr_set(isr_tx, lll);
   28834:	f019 b956 	b.w	41ae4 <radio_isr_set>
	node_rx->hdr.rx_ftr.rssi = (rssi_ready) ? radio_rssi_get() :
   28838:	f019 fb64 	bl	41f04 <radio_rssi_get>
   2883c:	b2c0      	uxtb	r0, r0
   2883e:	e780      	b.n	28742 <isr_rx+0x21a>
   28840:	3b9aca00 	.word	0x3b9aca00
   28844:	00000000 	.word	0x00000000
   28848:	0004088d 	.word	0x0004088d
   2884c:	1afd498d 	.word	0x1afd498d
   28850:	00040a55 	.word	0x00040a55
   28854:	00052be0 	.word	0x00052be0
   28858:	00052b94 	.word	0x00052b94
   2885c:	0005214c 	.word	0x0005214c
   28860:	000408a1 	.word	0x000408a1
	} else if (((pdu_adv_rx->type == PDU_ADV_TYPE_ADV_IND) ||
   28864:	2a06      	cmp	r2, #6
   28866:	f43f af45 	beq.w	286f4 <isr_rx+0x1cc>
	else if (((((pdu_adv_rx->type == PDU_ADV_TYPE_ADV_IND) ||
   2886a:	2145      	movs	r1, #69	; 0x45
   2886c:	40d1      	lsrs	r1, r2
   2886e:	07c9      	lsls	r1, r1, #31
   28870:	f100 80a3 	bmi.w	289ba <isr_rx+0x492>
		   (pdu_adv_rx->len <= sizeof(struct pdu_adv_adv_ind))) ||
   28874:	2a01      	cmp	r2, #1
   28876:	d118      	bne.n	288aa <isr_rx+0x382>
   28878:	7f6a      	ldrb	r2, [r5, #29]
		  ((pdu_adv_rx->type == PDU_ADV_TYPE_DIRECT_IND) &&
   2887a:	2a0c      	cmp	r2, #12
   2887c:	f47f ae5d 	bne.w	2853a <isr_rx+0x12>
	return (((lll->init_addr_type == addr_type) &&
   28880:	7da2      	ldrb	r2, [r4, #22]
		 !memcmp(lll->init_addr, addr, BDADDR_SIZE))) ||
   28882:	f3c2 1180 	ubfx	r1, r2, #6, #1
   28886:	ebb1 1fd3 	cmp.w	r1, r3, lsr #7
		    isr_scan_tgta_check(lll, false, pdu_adv_rx->rx_addr,
   2888a:	ea4f 17d3 	mov.w	r7, r3, lsr #7
		 !memcmp(lll->init_addr, addr, BDADDR_SIZE))) ||
   2888e:	d050      	beq.n	28932 <isr_rx+0x40a>
	if (((lll->filter_policy & SCAN_FP_EXT) != 0U) && (addr_type != 0U) &&
   28890:	f3c2 02c1 	ubfx	r2, r2, #3, #2
   28894:	2a01      	cmp	r2, #1
   28896:	f67f ae50 	bls.w	2853a <isr_rx+0x12>
   2889a:	b12f      	cbz	r7, 288a8 <isr_rx+0x380>
   2889c:	f895 3029 	ldrb.w	r3, [r5, #41]	; 0x29
   288a0:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   288a4:	2b40      	cmp	r3, #64	; 0x40
   288a6:	d067      	beq.n	28978 <isr_rx+0x450>
   288a8:	7f2b      	ldrb	r3, [r5, #28]
					rl_idx, &dir_report))) ||
   288aa:	f003 030f 	and.w	r3, r3, #15
   288ae:	2b04      	cmp	r3, #4
   288b0:	f47f ae43 	bne.w	2853a <isr_rx+0x12>
		  ((pdu_adv_rx->type == PDU_ADV_TYPE_SCAN_RSP) &&
   288b4:	7f6b      	ldrb	r3, [r5, #29]
   288b6:	2b25      	cmp	r3, #37	; 0x25
   288b8:	f63f ae3f 	bhi.w	2853a <isr_rx+0x12>
		   (lll->state != 0U) &&
   288bc:	7da3      	ldrb	r3, [r4, #22]
		   (pdu_adv_rx->len <= sizeof(struct pdu_adv_scan_rsp)) &&
   288be:	07db      	lsls	r3, r3, #31
   288c0:	f57f ae3b 	bpl.w	2853a <isr_rx+0x12>
	struct pdu_adv *sreq = (void *)radio_pkt_scratch_get();
   288c4:	f019 fa58 	bl	41d78 <radio_pkt_scratch_get>
	return ((sreq->rx_addr == srsp->tx_addr) &&
   288c8:	7f2b      	ldrb	r3, [r5, #28]
   288ca:	7802      	ldrb	r2, [r0, #0]
   288cc:	f3c3 1380 	ubfx	r3, r3, #6, #1
   288d0:	ebb3 1fd2 	cmp.w	r3, r2, lsr #7
   288d4:	f47f ae31 	bne.w	2853a <isr_rx+0x12>
		(memcmp(&sreq->scan_req.adv_addr[0],
   288d8:	2206      	movs	r2, #6
   288da:	3008      	adds	r0, #8
   288dc:	f105 011e 	add.w	r1, r5, #30
   288e0:	f022 fabb 	bl	4ae5a <memcmp>
	return ((sreq->rx_addr == srsp->tx_addr) &&
   288e4:	4607      	mov	r7, r0
   288e6:	2800      	cmp	r0, #0
   288e8:	f47f ae27 	bne.w	2853a <isr_rx+0x12>
		 (pdu_adv_rx->len != 0) &&
   288ec:	7f6b      	ldrb	r3, [r5, #29]
   288ee:	e70c      	b.n	2870a <isr_rx+0x1e2>
		  (pdu->len <= sizeof(struct pdu_adv_adv_ind))) ||
   288f0:	2a01      	cmp	r2, #1
   288f2:	d1b7      	bne.n	28864 <isr_rx+0x33c>
		 ((pdu->type == PDU_ADV_TYPE_DIRECT_IND) &&
   288f4:	7f6a      	ldrb	r2, [r5, #29]
   288f6:	2a0c      	cmp	r2, #12
   288f8:	f47f ae1f 	bne.w	2853a <isr_rx+0x12>
	return (((lll->init_addr_type == addr_type) &&
   288fc:	7da2      	ldrb	r2, [r4, #22]
		 !memcmp(lll->init_addr, addr, BDADDR_SIZE))) ||
   288fe:	f3c2 1180 	ubfx	r1, r2, #6, #1
   28902:	ebb1 1fd3 	cmp.w	r1, r3, lsr #7
			  isr_scan_tgta_check(lll, true, pdu->rx_addr,
   28906:	ea4f 17d3 	mov.w	r7, r3, lsr #7
		 !memcmp(lll->init_addr, addr, BDADDR_SIZE))) ||
   2890a:	d046      	beq.n	2899a <isr_rx+0x472>
	if (((lll->filter_policy & SCAN_FP_EXT) != 0U) && (addr_type != 0U) &&
   2890c:	f3c2 02c1 	ubfx	r2, r2, #3, #2
   28910:	2a01      	cmp	r2, #1
   28912:	d9b5      	bls.n	28880 <isr_rx+0x358>
   28914:	b137      	cbz	r7, 28924 <isr_rx+0x3fc>
   28916:	f895 3029 	ldrb.w	r3, [r5, #41]	; 0x29
   2891a:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   2891e:	2b40      	cmp	r3, #64	; 0x40
   28920:	f43f ae4c 	beq.w	285bc <isr_rx+0x94>
	} else if (((pdu_adv_rx->type == PDU_ADV_TYPE_ADV_IND) ||
   28924:	7f2b      	ldrb	r3, [r5, #28]
   28926:	f003 020f 	and.w	r2, r3, #15
   2892a:	e6e0      	b.n	286ee <isr_rx+0x1c6>
		   (pdu_adv_rx->len <= sizeof(struct pdu_adv_adv_ind))) ||
   2892c:	4613      	mov	r3, r2
	bool dir_report = false;
   2892e:	2700      	movs	r7, #0
   28930:	e6eb      	b.n	2870a <isr_rx+0x1e2>
		 !memcmp(lll->init_addr, addr, BDADDR_SIZE))) ||
   28932:	2206      	movs	r2, #6
   28934:	f105 0124 	add.w	r1, r5, #36	; 0x24
   28938:	f104 0018 	add.w	r0, r4, #24
   2893c:	f022 fa8d 	bl	4ae5a <memcmp>
	return (((lll->init_addr_type == addr_type) &&
   28940:	b930      	cbnz	r0, 28950 <isr_rx+0x428>
		 (pdu_adv_rx->len != 0) &&
   28942:	7f6b      	ldrb	r3, [r5, #29]
	bool dir_report = false;
   28944:	4607      	mov	r7, r0
   28946:	e6e0      	b.n	2870a <isr_rx+0x1e2>
	node_rx->hdr.rx_ftr.rssi = (rssi_ready) ? radio_rssi_get() :
   28948:	f019 fadc 	bl	41f04 <radio_rssi_get>
   2894c:	b2c3      	uxtb	r3, r0
   2894e:	e72e      	b.n	287ae <isr_rx+0x286>
	if (((lll->filter_policy & SCAN_FP_EXT) != 0U) && (addr_type != 0U) &&
   28950:	7da3      	ldrb	r3, [r4, #22]
   28952:	f3c3 03c1 	ubfx	r3, r3, #3, #2
   28956:	2b01      	cmp	r3, #1
   28958:	d9a6      	bls.n	288a8 <isr_rx+0x380>
   2895a:	e79e      	b.n	2889a <isr_rx+0x372>
		LL_ASSERT(!radio_is_ready());
   2895c:	4a19      	ldr	r2, [pc, #100]	; (289c4 <isr_rx+0x49c>)
   2895e:	491a      	ldr	r1, [pc, #104]	; (289c8 <isr_rx+0x4a0>)
   28960:	481a      	ldr	r0, [pc, #104]	; (289cc <isr_rx+0x4a4>)
   28962:	f240 43ac 	movw	r3, #1196	; 0x4ac
   28966:	f020 fb8d 	bl	49084 <assert_print>
   2896a:	4040      	eors	r0, r0
   2896c:	f380 8811 	msr	BASEPRI, r0
   28970:	f04f 0003 	mov.w	r0, #3
   28974:	df02      	svc	2
   28976:	e667      	b.n	28648 <isr_rx+0x120>
		 (pdu_adv_rx->len != 0) &&
   28978:	7f6b      	ldrb	r3, [r5, #29]
			*dir_report = true;
   2897a:	2701      	movs	r7, #1
   2897c:	e6c5      	b.n	2870a <isr_rx+0x1e2>
		LL_ASSERT(!radio_is_ready());
   2897e:	4a11      	ldr	r2, [pc, #68]	; (289c4 <isr_rx+0x49c>)
   28980:	4911      	ldr	r1, [pc, #68]	; (289c8 <isr_rx+0x4a0>)
   28982:	4812      	ldr	r0, [pc, #72]	; (289cc <isr_rx+0x4a4>)
   28984:	f240 5331 	movw	r3, #1329	; 0x531
   28988:	f020 fb7c 	bl	49084 <assert_print>
   2898c:	4040      	eors	r0, r0
   2898e:	f380 8811 	msr	BASEPRI, r0
   28992:	f04f 0003 	mov.w	r0, #3
   28996:	df02      	svc	2
   28998:	e741      	b.n	2881e <isr_rx+0x2f6>
		 !memcmp(lll->init_addr, addr, BDADDR_SIZE))) ||
   2899a:	2206      	movs	r2, #6
   2899c:	f105 0124 	add.w	r1, r5, #36	; 0x24
   289a0:	f104 0018 	add.w	r0, r4, #24
   289a4:	f022 fa59 	bl	4ae5a <memcmp>
	return (((lll->init_addr_type == addr_type) &&
   289a8:	2800      	cmp	r0, #0
   289aa:	f43f ae07 	beq.w	285bc <isr_rx+0x94>
	if (((lll->filter_policy & SCAN_FP_EXT) != 0U) && (addr_type != 0U) &&
   289ae:	7da3      	ldrb	r3, [r4, #22]
   289b0:	f3c3 03c1 	ubfx	r3, r3, #3, #2
   289b4:	2b01      	cmp	r3, #1
   289b6:	d8ad      	bhi.n	28914 <isr_rx+0x3ec>
   289b8:	e7b4      	b.n	28924 <isr_rx+0x3fc>
		   (pdu_adv_rx->len <= sizeof(struct pdu_adv_adv_ind))) ||
   289ba:	7f6b      	ldrb	r3, [r5, #29]
		    (pdu_adv_rx->type == PDU_ADV_TYPE_SCAN_IND)) &&
   289bc:	2b25      	cmp	r3, #37	; 0x25
   289be:	f67f aea3 	bls.w	28708 <isr_rx+0x1e0>
   289c2:	e5ba      	b.n	2853a <isr_rx+0x12>
   289c4:	00052be0 	.word	0x00052be0
   289c8:	00052b9c 	.word	0x00052b9c
   289cc:	0005214c 	.word	0x0005214c

000289d0 <nrf_flash_sync_exe>:
	_ticker_sync_context.interval = duration - FLASH_SYNC_SWITCHING_TIME;
	_ticker_sync_context.slot = duration;
}

int nrf_flash_sync_exe(struct flash_op_desc *op_desc)
{
   289d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   289d4:	b08f      	sub	sp, #60	; 0x3c
			      /* (MAYFLY_CALL_ID_PROGRAM) */
			   ticker_id, /* flash ticker id */
			   ticker_ticks_now_get(), /* current tick */
			   0, /* first int. immediately */
			   /* period */
			   HAL_TICKER_US_TO_TICKS(
   289d6:	f8df 80d8 	ldr.w	r8, [pc, #216]	; 28ab0 <nrf_flash_sync_exe+0xe0>
{
   289da:	900b      	str	r0, [sp, #44]	; 0x2c
	ll_timeslice_ticker_id_get(&instance_index, &ticker_id);
   289dc:	f10d 0137 	add.w	r1, sp, #55	; 0x37
   289e0:	f10d 0036 	add.w	r0, sp, #54	; 0x36
   289e4:	f00f fa48 	bl	37e78 <ll_timeslice_ticker_id_get>
			   HAL_TICKER_US_TO_TICKS(
   289e8:	4f32      	ldr	r7, [pc, #200]	; (28ab4 <nrf_flash_sync_exe+0xe4>)
	ret = ticker_start(instance_index,
   289ea:	f89d a036 	ldrb.w	sl, [sp, #54]	; 0x36
   289ee:	f89d b037 	ldrb.w	fp, [sp, #55]	; 0x37
   289f2:	f00d f903 	bl	35bfc <ticker_ticks_now_get>
			   HAL_TICKER_US_TO_TICKS(
   289f6:	f8d8 4000 	ldr.w	r4, [r8]
	ret = ticker_start(instance_index,
   289fa:	900a      	str	r0, [sp, #40]	; 0x28
			   HAL_TICKER_US_TO_TICKS(
   289fc:	fba4 5407 	umull	r5, r4, r4, r7
   28a00:	a329      	add	r3, pc, #164	; (adr r3, 28aa8 <nrf_flash_sync_exe+0xd8>)
   28a02:	e9d3 2300 	ldrd	r2, r3, [r3]
	ret = ticker_start(instance_index,
   28a06:	2600      	movs	r6, #0
			   HAL_TICKER_US_TO_TICKS(
   28a08:	4621      	mov	r1, r4
   28a0a:	4628      	mov	r0, r5
   28a0c:	f7fd fb78 	bl	26100 <__aeabi_uldivmod>
	ret = ticker_start(instance_index,
   28a10:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   28a12:	9306      	str	r3, [sp, #24]
   28a14:	e9cd 6607 	strd	r6, r6, [sp, #28]
   28a18:	4b27      	ldr	r3, [pc, #156]	; (28ab8 <nrf_flash_sync_exe+0xe8>)
   28a1a:	9305      	str	r3, [sp, #20]
			   HAL_TICKER_US_TO_TICKS(
   28a1c:	4681      	mov	r9, r0
				_ticker_sync_context.interval),
			   /* period remainder */
			   HAL_TICKER_REMAINDER(_ticker_sync_context.interval),
			   0, /* lazy, voluntary skips */
			   HAL_TICKER_US_TO_TICKS(_ticker_sync_context.slot),
   28a1e:	f8d8 0004 	ldr.w	r0, [r8, #4]
   28a22:	a321      	add	r3, pc, #132	; (adr r3, 28aa8 <nrf_flash_sync_exe+0xd8>)
   28a24:	e9d3 2300 	ldrd	r2, r3, [r3]
   28a28:	fba0 0107 	umull	r0, r1, r0, r7
   28a2c:	f7fd fb68 	bl	26100 <__aeabi_uldivmod>
			   HAL_TICKER_REMAINDER(_ticker_sync_context.interval),
   28a30:	4b22      	ldr	r3, [pc, #136]	; (28abc <nrf_flash_sync_exe+0xec>)
   28a32:	f029 477f 	bic.w	r7, r9, #4278190080	; 0xff000000
   28a36:	fba7 3103 	umull	r3, r1, r7, r3
	ret = ticker_start(instance_index,
   28a3a:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
			   HAL_TICKER_REMAINDER(_ticker_sync_context.interval),
   28a3e:	2207      	movs	r2, #7
	ret = ticker_start(instance_index,
   28a40:	e9cd 6003 	strd	r6, r0, [sp, #12]
			   HAL_TICKER_REMAINDER(_ticker_sync_context.interval),
   28a44:	fb02 1107 	mla	r1, r2, r7, r1
   28a48:	1ae8      	subs	r0, r5, r3
   28a4a:	eb64 0101 	sbc.w	r1, r4, r1
   28a4e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   28a52:	2300      	movs	r3, #0
   28a54:	f7fd fb54 	bl	26100 <__aeabi_uldivmod>
	ret = ticker_start(instance_index,
   28a58:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   28a5a:	9600      	str	r6, [sp, #0]
   28a5c:	e9cd 7001 	strd	r7, r0, [sp, #4]
   28a60:	465a      	mov	r2, fp
   28a62:	2103      	movs	r1, #3
   28a64:	4650      	mov	r0, sl
   28a66:	f00c ff9d 	bl	359a4 <ticker_start>
			   time_slot_callback_prepare,
			   op_desc,
			   NULL, /* no op callback */
			   NULL);

	if (ret != TICKER_STATUS_SUCCESS && ret != TICKER_STATUS_BUSY) {
   28a6a:	f030 0402 	bics.w	r4, r0, #2
   28a6e:	d116      	bne.n	28a9e <nrf_flash_sync_exe+0xce>
		union { struct { uintptr_t lo, hi; } split; k_timeout_t val; } parm1 = { .val = timeout };
		return (int) arch_syscall_invoke3(parm0.x, parm1.split.lo, parm1.split.hi, K_SYSCALL_K_SEM_TAKE);
	}
#endif
	compiler_barrier();
	return z_impl_k_sem_take(sem, timeout);
   28a70:	4a13      	ldr	r2, [pc, #76]	; (28ac0 <nrf_flash_sync_exe+0xf0>)
   28a72:	4814      	ldr	r0, [pc, #80]	; (28ac4 <nrf_flash_sync_exe+0xf4>)
   28a74:	2300      	movs	r3, #0
   28a76:	f01e fba5 	bl	471c4 <z_impl_k_sem_take>
		/* Failed to enqueue the ticker start operation request */
		result = -ECANCELED;
	} else if (k_sem_take(&sem_sync, K_MSEC(FLASH_TIMEOUT_MS)) != 0) {
   28a7a:	b168      	cbz	r0, 28a98 <nrf_flash_sync_exe+0xc8>
		/* Stop any scheduled jobs, from thread context */
		ret = ticker_stop(instance_index, 3U, ticker_id, NULL, NULL);
   28a7c:	f89d 2037 	ldrb.w	r2, [sp, #55]	; 0x37
   28a80:	f89d 0036 	ldrb.w	r0, [sp, #54]	; 0x36
   28a84:	9400      	str	r4, [sp, #0]
   28a86:	4623      	mov	r3, r4
   28a88:	2103      	movs	r1, #3
   28a8a:	f00d f817 	bl	35abc <ticker_stop>
		__ASSERT((ret == TICKER_STATUS_SUCCESS ||
			  ret == TICKER_STATUS_BUSY),
			 "Failed to stop ticker.\n");

		/* wait for operation's complete overrun*/
		result = -ETIMEDOUT;
   28a8e:	f06f 0073 	mvn.w	r0, #115	; 0x73
	} else {
		result = _ticker_sync_context.result;
	}

	return result;
}
   28a92:	b00f      	add	sp, #60	; 0x3c
   28a94:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		result = _ticker_sync_context.result;
   28a98:	f8d8 000c 	ldr.w	r0, [r8, #12]
   28a9c:	e7f9      	b.n	28a92 <nrf_flash_sync_exe+0xc2>
		result = -ECANCELED;
   28a9e:	f06f 008b 	mvn.w	r0, #139	; 0x8b
	return result;
   28aa2:	e7f6      	b.n	28a92 <nrf_flash_sync_exe+0xc2>
   28aa4:	f3af 8000 	nop.w
   28aa8:	1afd498d 	.word	0x1afd498d
   28aac:	00000007 	.word	0x00000007
   28ab0:	20006610 	.word	0x20006610
   28ab4:	3b9aca00 	.word	0x3b9aca00
   28ab8:	0004444d 	.word	0x0004444d
   28abc:	1afd498d 	.word	0x1afd498d
   28ac0:	000b7b44 	.word	0x000b7b44
   28ac4:	200065f8 	.word	0x200065f8

00028ac8 <nrf_flash_sync_check_time_limit>:
{
	_ticker_sync_context.ticks_begin = ticker_ticks_now_get();
}

bool nrf_flash_sync_check_time_limit(uint32_t iteration)
{
   28ac8:	b538      	push	{r3, r4, r5, lr}
	uint32_t ticks_diff;

	ticks_diff = ticker_ticks_diff_get(ticker_ticks_now_get(),
   28aca:	4d0f      	ldr	r5, [pc, #60]	; (28b08 <nrf_flash_sync_check_time_limit+0x40>)
{
   28acc:	4604      	mov	r4, r0
	ticks_diff = ticker_ticks_diff_get(ticker_ticks_now_get(),
   28ace:	f00d f895 	bl	35bfc <ticker_ticks_now_get>
   28ad2:	68a9      	ldr	r1, [r5, #8]
   28ad4:	f00d f894 	bl	35c00 <ticker_ticks_diff_get>
					   _ticker_sync_context.ticks_begin);
	if (ticks_diff + ticks_diff/iteration >
	    HAL_TICKER_US_TO_TICKS(_ticker_sync_context.slot)) {
   28ad8:	6869      	ldr	r1, [r5, #4]
	if (ticks_diff + ticks_diff/iteration >
   28ada:	fbb0 f4f4 	udiv	r4, r0, r4
   28ade:	4404      	add	r4, r0
	    HAL_TICKER_US_TO_TICKS(_ticker_sync_context.slot)) {
   28ae0:	480a      	ldr	r0, [pc, #40]	; (28b0c <nrf_flash_sync_check_time_limit+0x44>)
   28ae2:	a307      	add	r3, pc, #28	; (adr r3, 28b00 <nrf_flash_sync_check_time_limit+0x38>)
   28ae4:	e9d3 2300 	ldrd	r2, r3, [r3]
   28ae8:	fba1 0100 	umull	r0, r1, r1, r0
   28aec:	f7fd fb08 	bl	26100 <__aeabi_uldivmod>
   28af0:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
		return true;
	}

	return false;
}
   28af4:	4284      	cmp	r4, r0
   28af6:	bf94      	ite	ls
   28af8:	2000      	movls	r0, #0
   28afa:	2001      	movhi	r0, #1
   28afc:	bd38      	pop	{r3, r4, r5, pc}
   28afe:	bf00      	nop
   28b00:	1afd498d 	.word	0x1afd498d
   28b04:	00000007 	.word	0x00000007
   28b08:	20006610 	.word	0x20006610
   28b0c:	3b9aca00 	.word	0x3b9aca00

00028b10 <activity_expiry_function>:
        }
}

K_WORK_DEFINE(activity_work, activity_work_handler);

void activity_expiry_function() { k_work_submit(&activity_work); }
   28b10:	4801      	ldr	r0, [pc, #4]	; (28b18 <activity_expiry_function+0x8>)
   28b12:	f01e bccf 	b.w	474b4 <k_work_submit>
   28b16:	bf00      	nop
   28b18:	20000298 	.word	0x20000298

00028b1c <activity_init>:

K_TIMER_DEFINE(activity_timer, activity_expiry_function, NULL);

int activity_init() {
   28b1c:	b507      	push	{r0, r1, r2, lr}
	return z_impl_k_uptime_ticks();
   28b1e:	f027 fc1f 	bl	50360 <z_impl_k_uptime_ticks>
			/* Faster algorithm but source is first multiplied by target frequency
			 * and it can overflow even though final result would not overflow.
			 * Kconfig option shall prevent use of this algorithm when there is a
			 * risk of overflow.
			 */
			return ((t * to_hz + off) / from_hz);
   28b22:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   28b26:	fba0 0302 	umull	r0, r3, r0, r2
   28b2a:	fb02 3101 	mla	r1, r2, r1, r3
   28b2e:	0bc0      	lsrs	r0, r0, #15
    activity_last_uptime = k_uptime_get();
   28b30:	4a07      	ldr	r2, [pc, #28]	; (28b50 <activity_init+0x34>)
   28b32:	ea40 4041 	orr.w	r0, r0, r1, lsl #17
   28b36:	6010      	str	r0, [r2, #0]

    k_timer_start(&activity_timer, K_SECONDS(1), K_SECONDS(1));
   28b38:	2300      	movs	r3, #0
	compiler_barrier();
   28b3a:	f44f 4200 	mov.w	r2, #32768	; 0x8000
	z_impl_k_timer_start(timer, duration, period);
   28b3e:	4805      	ldr	r0, [pc, #20]	; (28b54 <activity_init+0x38>)
   28b40:	e9cd 2300 	strd	r2, r3, [sp]
   28b44:	f01f fa7a 	bl	4803c <z_impl_k_timer_start>
    return 0;
}
   28b48:	2000      	movs	r0, #0
   28b4a:	b003      	add	sp, #12
   28b4c:	f85d fb04 	ldr.w	pc, [sp], #4
   28b50:	20003720 	.word	0x20003720
   28b54:	20001000 	.word	0x20001000

00028b58 <raise_event>:
int raise_event() {
   28b58:	b508      	push	{r3, lr}
    return ZMK_EVENT_RAISE(new_zmk_activity_state_changed(
   28b5a:	4b04      	ldr	r3, [pc, #16]	; (28b6c <raise_event+0x14>)
   28b5c:	7818      	ldrb	r0, [r3, #0]
   28b5e:	f000 fa43 	bl	28fe8 <new_zmk_activity_state_changed>
}
   28b62:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    return ZMK_EVENT_RAISE(new_zmk_activity_state_changed(
   28b66:	f01f bb8b 	b.w	48280 <zmk_event_manager_raise>
   28b6a:	bf00      	nop
   28b6c:	20006a72 	.word	0x20006a72

00028b70 <set_state>:
    if (activity_state == state)
   28b70:	4b04      	ldr	r3, [pc, #16]	; (28b84 <set_state+0x14>)
   28b72:	781a      	ldrb	r2, [r3, #0]
   28b74:	4282      	cmp	r2, r0
   28b76:	d002      	beq.n	28b7e <set_state+0xe>
    activity_state = state;
   28b78:	7018      	strb	r0, [r3, #0]
    return raise_event();
   28b7a:	f7ff bfed 	b.w	28b58 <raise_event>
}
   28b7e:	2000      	movs	r0, #0
   28b80:	4770      	bx	lr
   28b82:	bf00      	nop
   28b84:	20006a72 	.word	0x20006a72

00028b88 <activity_event_listener>:
int activity_event_listener(const zmk_event_t *eh) {
   28b88:	b508      	push	{r3, lr}
	return z_impl_k_uptime_ticks();
   28b8a:	f027 fbe9 	bl	50360 <z_impl_k_uptime_ticks>
   28b8e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   28b92:	fba0 0302 	umull	r0, r3, r0, r2
   28b96:	fb02 3101 	mla	r1, r2, r1, r3
   28b9a:	0bc0      	lsrs	r0, r0, #15
    activity_last_uptime = k_uptime_get();
   28b9c:	4a04      	ldr	r2, [pc, #16]	; (28bb0 <activity_event_listener+0x28>)
   28b9e:	ea40 4041 	orr.w	r0, r0, r1, lsl #17
   28ba2:	6010      	str	r0, [r2, #0]
}
   28ba4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    return set_state(ZMK_ACTIVITY_ACTIVE);
   28ba8:	2000      	movs	r0, #0
   28baa:	f7ff bfe1 	b.w	28b70 <set_state>
   28bae:	bf00      	nop
   28bb0:	20003720 	.word	0x20003720

00028bb4 <activity_work_handler>:
void activity_work_handler(struct k_work *work) {
   28bb4:	b508      	push	{r3, lr}
   28bb6:	f027 fbd3 	bl	50360 <z_impl_k_uptime_ticks>
   28bba:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   28bbe:	fba0 0302 	umull	r0, r3, r0, r2
   28bc2:	fb02 3101 	mla	r1, r2, r1, r3
    int32_t inactive_time = current - activity_last_uptime;
   28bc6:	4a08      	ldr	r2, [pc, #32]	; (28be8 <activity_work_handler+0x34>)
   28bc8:	0bc3      	lsrs	r3, r0, #15
   28bca:	6812      	ldr	r2, [r2, #0]
   28bcc:	ea43 4341 	orr.w	r3, r3, r1, lsl #17
   28bd0:	1a9b      	subs	r3, r3, r2
        if (inactive_time > MAX_IDLE_MS) {
   28bd2:	f247 5230 	movw	r2, #30000	; 0x7530
   28bd6:	4293      	cmp	r3, r2
   28bd8:	dd04      	ble.n	28be4 <activity_work_handler+0x30>
}
   28bda:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            set_state(ZMK_ACTIVITY_IDLE);
   28bde:	2001      	movs	r0, #1
   28be0:	f7ff bfc6 	b.w	28b70 <set_state>
}
   28be4:	bd08      	pop	{r3, pc}
   28be6:	bf00      	nop
   28be8:	20003720 	.word	0x20003720

00028bec <zmk_kscan_process_msgq>:

    k_msgq_put(&zmk_kscan_msgq, &ev, K_NO_WAIT);
    k_work_submit(&msg_processor.work);
}

void zmk_kscan_process_msgq(struct k_work *item) {
   28bec:	b530      	push	{r4, r5, lr}
		union { struct { uintptr_t lo, hi; } split; k_timeout_t val; } parm2 = { .val = timeout };
		return (int) arch_syscall_invoke4(parm0.x, parm1.x, parm2.split.lo, parm2.split.hi, K_SYSCALL_K_MSGQ_GET);
	}
#endif
	compiler_barrier();
	return z_impl_k_msgq_get(msgq, data, timeout);
   28bee:	4c19      	ldr	r4, [pc, #100]	; (28c54 <zmk_kscan_process_msgq+0x68>)
   28bf0:	b08d      	sub	sp, #52	; 0x34
   28bf2:	2200      	movs	r2, #0
   28bf4:	2300      	movs	r3, #0
   28bf6:	a903      	add	r1, sp, #12
   28bf8:	4620      	mov	r0, r4
   28bfa:	f01e f979 	bl	46ef0 <z_impl_k_msgq_get>
    struct zmk_kscan_event ev;

    while (k_msgq_get(&zmk_kscan_msgq, &ev, K_NO_WAIT) == 0) {
   28bfe:	b108      	cbz	r0, 28c04 <zmk_kscan_process_msgq+0x18>
            (struct zmk_position_state_changed){.source = ZMK_POSITION_STATE_CHANGE_SOURCE_LOCAL,
                                                .state = pressed,
                                                .position = position,
                                                .timestamp = k_uptime_get()}));
    }
}
   28c00:	b00d      	add	sp, #52	; 0x34
   28c02:	bd30      	pop	{r4, r5, pc}
        int32_t position = zmk_matrix_transform_row_column_to_position(ev.row, ev.column);
   28c04:	e9dd 1504 	ldrd	r1, r5, [sp, #16]
   28c08:	9803      	ldr	r0, [sp, #12]
   28c0a:	f000 f857 	bl	28cbc <zmk_matrix_transform_row_column_to_position>
        if (position < 0) {
   28c0e:	2800      	cmp	r0, #0
   28c10:	dbef      	blt.n	28bf2 <zmk_kscan_process_msgq+0x6>
        ZMK_EVENT_RAISE(new_zmk_position_state_changed(
   28c12:	23ff      	movs	r3, #255	; 0xff
   28c14:	f88d 3018 	strb.w	r3, [sp, #24]
        bool pressed = (ev.state == ZMK_KSCAN_EVENT_STATE_PRESSED);
   28c18:	fab5 f385 	clz	r3, r5
   28c1c:	095b      	lsrs	r3, r3, #5
        ZMK_EVENT_RAISE(new_zmk_position_state_changed(
   28c1e:	9007      	str	r0, [sp, #28]
        bool pressed = (ev.state == ZMK_KSCAN_EVENT_STATE_PRESSED);
   28c20:	f88d 3020 	strb.w	r3, [sp, #32]
	return z_impl_k_uptime_ticks();
   28c24:	f027 fb9c 	bl	50360 <z_impl_k_uptime_ticks>
   28c28:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   28c2c:	fba0 0302 	umull	r0, r3, r0, r2
   28c30:	fb02 3101 	mla	r1, r2, r1, r3
   28c34:	0bc0      	lsrs	r0, r0, #15
   28c36:	ea40 4041 	orr.w	r0, r0, r1, lsl #17
   28c3a:	0bc9      	lsrs	r1, r1, #15
        ZMK_EVENT_RAISE(new_zmk_position_state_changed(
   28c3c:	e88d 0003 	stmia.w	sp, {r0, r1}
   28c40:	ab06      	add	r3, sp, #24
   28c42:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
   28c46:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
   28c48:	f000 f9da 	bl	29000 <new_zmk_position_state_changed>
   28c4c:	f01f fb18 	bl	48280 <zmk_event_manager_raise>
                                                .timestamp = k_uptime_get()}));
   28c50:	e7cf      	b.n	28bf2 <zmk_kscan_process_msgq+0x6>
   28c52:	bf00      	nop
   28c54:	2000120c 	.word	0x2000120c

00028c58 <zmk_kscan_callback>:
                               bool pressed) {
   28c58:	b51f      	push	{r0, r1, r2, r3, r4, lr}
        .state = (pressed ? ZMK_KSCAN_EVENT_STATE_PRESSED : ZMK_KSCAN_EVENT_STATE_RELEASED)};
   28c5a:	f083 0301 	eor.w	r3, r3, #1
    struct zmk_kscan_event ev = {
   28c5e:	e9cd 1201 	strd	r1, r2, [sp, #4]
        .state = (pressed ? ZMK_KSCAN_EVENT_STATE_PRESSED : ZMK_KSCAN_EVENT_STATE_RELEASED)};
   28c62:	9303      	str	r3, [sp, #12]
	return z_impl_k_msgq_put(msgq, data, timeout);
   28c64:	2200      	movs	r2, #0
   28c66:	2300      	movs	r3, #0
   28c68:	a901      	add	r1, sp, #4
   28c6a:	4804      	ldr	r0, [pc, #16]	; (28c7c <zmk_kscan_callback+0x24>)
   28c6c:	f01e f8ea 	bl	46e44 <z_impl_k_msgq_put>
    k_work_submit(&msg_processor.work);
   28c70:	4803      	ldr	r0, [pc, #12]	; (28c80 <zmk_kscan_callback+0x28>)
   28c72:	f01e fc1f 	bl	474b4 <k_work_submit>
}
   28c76:	b005      	add	sp, #20
   28c78:	f85d fb04 	ldr.w	pc, [sp], #4
   28c7c:	2000120c 	.word	0x2000120c
   28c80:	20003724 	.word	0x20003724

00028c84 <zmk_kscan_init>:

int zmk_kscan_init(const struct device *dev) {
   28c84:	b510      	push	{r4, lr}
    if (dev == NULL) {
   28c86:	4604      	mov	r4, r0
   28c88:	b178      	cbz	r0, 28caa <zmk_kscan_init+0x26>
        LOG_ERR("Failed to get the KSCAN device");
        return -EINVAL;
    }

    k_work_init(&msg_processor.work, zmk_kscan_process_msgq);
   28c8a:	4909      	ldr	r1, [pc, #36]	; (28cb0 <zmk_kscan_init+0x2c>)
   28c8c:	4809      	ldr	r0, [pc, #36]	; (28cb4 <zmk_kscan_init+0x30>)
   28c8e:	f027 f975 	bl	4ff7c <k_work_init>
					kscan_callback_t callback)
{
	const struct kscan_driver_api *api =
				(struct kscan_driver_api *)dev->api;

	return api->config(dev, callback);
   28c92:	68a3      	ldr	r3, [r4, #8]
   28c94:	4908      	ldr	r1, [pc, #32]	; (28cb8 <zmk_kscan_init+0x34>)
   28c96:	681b      	ldr	r3, [r3, #0]
   28c98:	4620      	mov	r0, r4
   28c9a:	4798      	blx	r3
static inline int z_impl_kscan_enable_callback(const struct device *dev)
{
	const struct kscan_driver_api *api =
			(const struct kscan_driver_api *)dev->api;

	if (api->enable_callback == NULL) {
   28c9c:	68a3      	ldr	r3, [r4, #8]
   28c9e:	689b      	ldr	r3, [r3, #8]
   28ca0:	b10b      	cbz	r3, 28ca6 <zmk_kscan_init+0x22>
		return -ENOSYS;
	}

	return api->enable_callback(dev);
   28ca2:	4620      	mov	r0, r4
   28ca4:	4798      	blx	r3

    kscan_config(dev, zmk_kscan_callback);
    kscan_enable_callback(dev);

    return 0;
   28ca6:	2000      	movs	r0, #0
}
   28ca8:	bd10      	pop	{r4, pc}
        return -EINVAL;
   28caa:	f06f 0015 	mvn.w	r0, #21
   28cae:	e7fb      	b.n	28ca8 <zmk_kscan_init+0x24>
   28cb0:	00028bed 	.word	0x00028bed
   28cb4:	20003724 	.word	0x20003724
   28cb8:	00028c59 	.word	0x00028c59

00028cbc <zmk_matrix_transform_row_column_to_position>:

#if DT_NODE_HAS_PROP(ZMK_KEYMAP_TRANSFORM_NODE, row_offset)
    row += DT_PROP(ZMK_KEYMAP_TRANSFORM_NODE, row_offset);
#endif

    const uint32_t matrix_index = (row * ZMK_MATRIX_COLS) + column;
   28cbc:	eb01 1100 	add.w	r1, r1, r0, lsl #4

#ifdef ZMK_KEYMAP_TRANSFORM_NODE
    if (matrix_index >= ARRAY_SIZE(transform)) {
   28cc0:	294b      	cmp	r1, #75	; 0x4b
   28cc2:	d805      	bhi.n	28cd0 <zmk_matrix_transform_row_column_to_position+0x14>
        return -EINVAL;
    }

    const uint32_t value = transform[matrix_index];
   28cc4:	4b04      	ldr	r3, [pc, #16]	; (28cd8 <zmk_matrix_transform_row_column_to_position+0x1c>)
   28cc6:	f853 0021 	ldr.w	r0, [r3, r1, lsl #2]

    if (!value) {
   28cca:	b108      	cbz	r0, 28cd0 <zmk_matrix_transform_row_column_to_position+0x14>
        return -EINVAL;
    }

    return value - INDEX_OFFSET;
   28ccc:	3801      	subs	r0, #1
   28cce:	4770      	bx	lr
        return -EINVAL;
   28cd0:	f06f 0015 	mvn.w	r0, #21
#else
    return matrix_index;
#endif /* ZMK_KEYMAP_TRANSFORM_NODE */
};
   28cd4:	4770      	bx	lr
   28cd6:	bf00      	nop
   28cd8:	00050e2c 	.word	0x00050e2c

00028cdc <trigger_sensor_data_for_position>:
    }

    return &configs[sensor_index];
}

static void trigger_sensor_data_for_position(uint32_t sensor_index) {
   28cdc:	b530      	push	{r4, r5, lr}
    int err;
    const struct sensors_item_cfg *item = &sensors[sensor_index];

    err = sensor_sample_fetch(item->dev);
   28cde:	4c1d      	ldr	r4, [pc, #116]	; (28d54 <trigger_sensor_data_for_position+0x78>)
   28ce0:	eb04 1400 	add.w	r4, r4, r0, lsl #4
static void trigger_sensor_data_for_position(uint32_t sensor_index) {
   28ce4:	b08f      	sub	sp, #60	; 0x3c
    err = sensor_sample_fetch(item->dev);
   28ce6:	6860      	ldr	r0, [r4, #4]
static inline int z_impl_sensor_sample_fetch(const struct device *dev)
{
	const struct sensor_driver_api *api =
		(const struct sensor_driver_api *)dev->api;

	return api->sample_fetch(dev, SENSOR_CHAN_ALL);
   28ce8:	6883      	ldr	r3, [r0, #8]
   28cea:	2139      	movs	r1, #57	; 0x39
   28cec:	68db      	ldr	r3, [r3, #12]
   28cee:	4798      	blx	r3
    if (err) {
   28cf0:	bb68      	cbnz	r0, 28d4e <trigger_sensor_data_for_position+0x72>
        LOG_WRN("Failed to fetch sample from device %d", err);
        return;
    }

    struct sensor_value value;
    err = sensor_channel_get(item->dev, item->trigger.chan, &value);
   28cf2:	6860      	ldr	r0, [r4, #4]
   28cf4:	8961      	ldrh	r1, [r4, #10]
					    struct sensor_value *val)
{
	const struct sensor_driver_api *api =
		(const struct sensor_driver_api *)dev->api;

	return api->channel_get(dev, chan, val);
   28cf6:	6883      	ldr	r3, [r0, #8]
   28cf8:	ad04      	add	r5, sp, #16
   28cfa:	691b      	ldr	r3, [r3, #16]
   28cfc:	462a      	mov	r2, r5
   28cfe:	4798      	blx	r3

    if (err) {
   28d00:	bb28      	cbnz	r0, 28d4e <trigger_sensor_data_for_position+0x72>
        LOG_WRN("Failed to get channel data from device %d", err);
        return;
    }

    ZMK_EVENT_RAISE(new_zmk_sensor_event(
   28d02:	e895 0003 	ldmia.w	r5, {r0, r1}
   28d06:	2301      	movs	r3, #1
   28d08:	9306      	str	r3, [sp, #24]
   28d0a:	ab07      	add	r3, sp, #28
   28d0c:	e883 0003 	stmia.w	r3, {r0, r1}
   28d10:	8963      	ldrh	r3, [r4, #10]
   28d12:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
	return z_impl_k_uptime_ticks();
   28d16:	f027 fb23 	bl	50360 <z_impl_k_uptime_ticks>
   28d1a:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
   28d1e:	fba0 3205 	umull	r3, r2, r0, r5
   28d22:	fb05 2101 	mla	r1, r5, r1, r2
   28d26:	0bdb      	lsrs	r3, r3, #15
   28d28:	ea43 4341 	orr.w	r3, r3, r1, lsl #17
   28d2c:	0bc9      	lsrs	r1, r1, #15
   28d2e:	e9cd 310a 	strd	r3, r1, [sp, #40]	; 0x28
   28d32:	7b23      	ldrb	r3, [r4, #12]
   28d34:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
   28d38:	ab0e      	add	r3, sp, #56	; 0x38
   28d3a:	e913 000f 	ldmdb	r3, {r0, r1, r2, r3}
   28d3e:	e88d 000f 	stmia.w	sp, {r0, r1, r2, r3}
   28d42:	ab06      	add	r3, sp, #24
   28d44:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
   28d46:	f000 f981 	bl	2904c <new_zmk_sensor_event>
   28d4a:	f01f fa99 	bl	48280 <zmk_event_manager_raise>
        (struct zmk_sensor_event){.sensor_index = item->sensor_index,
                                  .channel_data_size = 1,
                                  .channel_data = {(struct zmk_sensor_channel_data){
                                      .value = value, .channel = item->trigger.chan}},
                                  .timestamp = k_uptime_get()}));
}
   28d4e:	b00f      	add	sp, #60	; 0x3c
   28d50:	bd30      	pop	{r4, r5, pc}
   28d52:	bf00      	nop
   28d54:	200002b8 	.word	0x200002b8

00028d58 <run_sensors_data_trigger>:

static void run_sensors_data_trigger(struct k_work *work) {
   28d58:	b510      	push	{r4, lr}
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_and(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   28d5a:	4c13      	ldr	r4, [pc, #76]	; (28da8 <run_sensors_data_trigger+0x50>)
   28d5c:	f3bf 8f5b 	dmb	ish
   28d60:	e854 2f00 	ldrex	r2, [r4]
   28d64:	f022 0101 	bic.w	r1, r2, #1
   28d68:	e844 1000 	strex	r0, r1, [r4]
   28d6c:	2800      	cmp	r0, #0
   28d6e:	d1f7      	bne.n	28d60 <run_sensors_data_trigger+0x8>
   28d70:	f3bf 8f5b 	dmb	ish
    for (int i = 0; i < ARRAY_SIZE(sensors); i++) {
        if (atomic_test_and_clear_bit(pending_sensors, i)) {
   28d74:	07d2      	lsls	r2, r2, #31
   28d76:	d502      	bpl.n	28d7e <run_sensors_data_trigger+0x26>
            trigger_sensor_data_for_position(i);
   28d78:	2000      	movs	r0, #0
   28d7a:	f7ff ffaf 	bl	28cdc <trigger_sensor_data_for_position>
   28d7e:	f3bf 8f5b 	dmb	ish
   28d82:	e854 3f00 	ldrex	r3, [r4]
   28d86:	f023 0202 	bic.w	r2, r3, #2
   28d8a:	e844 2100 	strex	r1, r2, [r4]
   28d8e:	2900      	cmp	r1, #0
   28d90:	d1f7      	bne.n	28d82 <run_sensors_data_trigger+0x2a>
   28d92:	f3bf 8f5b 	dmb	ish
        if (atomic_test_and_clear_bit(pending_sensors, i)) {
   28d96:	079b      	lsls	r3, r3, #30
   28d98:	d504      	bpl.n	28da4 <run_sensors_data_trigger+0x4c>
        }
    }
}
   28d9a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            trigger_sensor_data_for_position(i);
   28d9e:	2001      	movs	r0, #1
   28da0:	f7ff bf9c 	b.w	28cdc <trigger_sensor_data_for_position>
}
   28da4:	bd10      	pop	{r4, pc}
   28da6:	bf00      	nop
   28da8:	20003734 	.word	0x20003734

00028dac <zmk_sensors_init_item>:
}

static void zmk_sensors_init_item(uint8_t i) {
    LOG_DBG("Init sensor at index %d", i);

    if (!sensors[i].dev) {
   28dac:	4906      	ldr	r1, [pc, #24]	; (28dc8 <zmk_sensors_init_item+0x1c>)
   28dae:	eb01 1200 	add.w	r2, r1, r0, lsl #4
   28db2:	6850      	ldr	r0, [r2, #4]
   28db4:	b130      	cbz	r0, 28dc4 <zmk_sensors_init_item+0x18>
	if (api->trigger_set == NULL) {
   28db6:	6883      	ldr	r3, [r0, #8]
   28db8:	689b      	ldr	r3, [r3, #8]
        LOG_DBG("No local device for %d", i);
        return;
    }

    int err = sensor_trigger_set(sensors[i].dev, &sensors[i].trigger, zmk_sensors_trigger_handler);
   28dba:	4611      	mov	r1, r2
   28dbc:	3108      	adds	r1, #8
   28dbe:	b10b      	cbz	r3, 28dc4 <zmk_sensors_init_item+0x18>
	return api->trigger_set(dev, trig, handler);
   28dc0:	4a02      	ldr	r2, [pc, #8]	; (28dcc <zmk_sensors_init_item+0x20>)
   28dc2:	4718      	bx	r3
    if (err) {
        LOG_WRN("Failed to set sensor trigger (%d)", err);
    }
}
   28dc4:	4770      	bx	lr
   28dc6:	bf00      	nop
   28dc8:	200002b8 	.word	0x200002b8
   28dcc:	00028dd1 	.word	0x00028dd1

00028dd0 <zmk_sensors_trigger_handler>:
                                        const struct sensor_trigger *trigger) {
   28dd0:	b510      	push	{r4, lr}
    int sensor_index = test_item - sensors;
   28dd2:	4c10      	ldr	r4, [pc, #64]	; (28e14 <zmk_sensors_trigger_handler+0x44>)
   28dd4:	1b0c      	subs	r4, r1, r4
    if (sensor_index < 0 || sensor_index >= ARRAY_SIZE(sensors)) {
   28dd6:	2c10      	cmp	r4, #16
   28dd8:	d81b      	bhi.n	28e12 <zmk_sensors_trigger_handler+0x42>
    int sensor_index = test_item - sensors;
   28dda:	1124      	asrs	r4, r4, #4
    if (k_is_in_isr()) {
   28ddc:	f026 ff39 	bl	4fc52 <k_is_in_isr>
   28de0:	b190      	cbz	r0, 28e08 <zmk_sensors_trigger_handler+0x38>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   28de2:	f3bf 8f5b 	dmb	ish
	atomic_val_t mask = ATOMIC_MASK(bit);
   28de6:	2301      	movs	r3, #1
   28de8:	4a0b      	ldr	r2, [pc, #44]	; (28e18 <zmk_sensors_trigger_handler+0x48>)
   28dea:	40a3      	lsls	r3, r4
   28dec:	e852 0f00 	ldrex	r0, [r2]
   28df0:	4318      	orrs	r0, r3
   28df2:	e842 0100 	strex	r1, r0, [r2]
   28df6:	2900      	cmp	r1, #0
   28df8:	d1f8      	bne.n	28dec <zmk_sensors_trigger_handler+0x1c>
   28dfa:	f3bf 8f5b 	dmb	ish
        k_work_submit(&sensor_data_work);
   28dfe:	4807      	ldr	r0, [pc, #28]	; (28e1c <zmk_sensors_trigger_handler+0x4c>)
}
   28e00:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        k_work_submit(&sensor_data_work);
   28e04:	f01e bb56 	b.w	474b4 <k_work_submit>
        trigger_sensor_data_for_position(sensor_index);
   28e08:	4620      	mov	r0, r4
}
   28e0a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        trigger_sensor_data_for_position(sensor_index);
   28e0e:	f7ff bf65 	b.w	28cdc <trigger_sensor_data_for_position>
}
   28e12:	bd10      	pop	{r4, pc}
   28e14:	200002c0 	.word	0x200002c0
   28e18:	20003734 	.word	0x20003734
   28e1c:	200002a8 	.word	0x200002a8

00028e20 <zmk_sensors_get_config_at_index>:
    if (sensor_index > ARRAY_SIZE(configs)) {
   28e20:	2802      	cmp	r0, #2
    return &configs[sensor_index];
   28e22:	bf9a      	itte	ls
   28e24:	4b02      	ldrls	r3, [pc, #8]	; (28e30 <zmk_sensors_get_config_at_index+0x10>)
   28e26:	eb03 0040 	addls.w	r0, r3, r0, lsl #1
        return NULL;
   28e2a:	2000      	movhi	r0, #0
}
   28e2c:	4770      	bx	lr
   28e2e:	bf00      	nop
   28e30:	20000e78 	.word	0x20000e78

00028e34 <zmk_event_manager_handle_from>:
extern struct zmk_event_type *__event_type_end[];

extern struct zmk_event_subscription __event_subscriptions_start[];
extern struct zmk_event_subscription __event_subscriptions_end[];

int zmk_event_manager_handle_from(zmk_event_t *event, uint8_t start_index) {
   28e34:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    int ret = 0;
    uint8_t len = __event_subscriptions_end - __event_subscriptions_start;
   28e38:	4b13      	ldr	r3, [pc, #76]	; (28e88 <zmk_event_manager_handle_from+0x54>)
   28e3a:	4e14      	ldr	r6, [pc, #80]	; (28e8c <zmk_event_manager_handle_from+0x58>)
   28e3c:	eba3 0806 	sub.w	r8, r3, r6
int zmk_event_manager_handle_from(zmk_event_t *event, uint8_t start_index) {
   28e40:	4607      	mov	r7, r0
    for (int i = start_index; i < len; i++) {
   28e42:	460d      	mov	r5, r1
   28e44:	eb06 06c1 	add.w	r6, r6, r1, lsl #3
   28e48:	f3c8 08c7 	ubfx	r8, r8, #3, #8
   28e4c:	45a8      	cmp	r8, r5
   28e4e:	dc06      	bgt.n	28e5e <zmk_event_manager_handle_from+0x2a>
        switch (ret) {
        case ZMK_EV_EVENT_BUBBLE:
            continue;
        case ZMK_EV_EVENT_HANDLED:
            LOG_DBG("Listener handled the event");
            ret = 0;
   28e50:	2400      	movs	r4, #0
            goto release;
        }
    }

release:
    k_free(event);
   28e52:	4638      	mov	r0, r7
   28e54:	f027 fc2f 	bl	506b6 <k_free>
    return ret;
}
   28e58:	4620      	mov	r0, r4
   28e5a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if (ev_sub->event_type != event->event) {
   28e5e:	6832      	ldr	r2, [r6, #0]
   28e60:	683b      	ldr	r3, [r7, #0]
   28e62:	429a      	cmp	r2, r3
   28e64:	d10b      	bne.n	28e7e <zmk_event_manager_handle_from+0x4a>
        event->last_listener_index = i;
   28e66:	713d      	strb	r5, [r7, #4]
        ret = ev_sub->listener->callback(event);
   28e68:	6873      	ldr	r3, [r6, #4]
   28e6a:	4638      	mov	r0, r7
   28e6c:	681b      	ldr	r3, [r3, #0]
   28e6e:	4798      	blx	r3
        switch (ret) {
   28e70:	2801      	cmp	r0, #1
        ret = ev_sub->listener->callback(event);
   28e72:	4604      	mov	r4, r0
        switch (ret) {
   28e74:	d0ec      	beq.n	28e50 <zmk_event_manager_handle_from+0x1c>
   28e76:	2802      	cmp	r0, #2
   28e78:	d004      	beq.n	28e84 <zmk_event_manager_handle_from+0x50>
   28e7a:	2800      	cmp	r0, #0
   28e7c:	d1e9      	bne.n	28e52 <zmk_event_manager_handle_from+0x1e>
    for (int i = start_index; i < len; i++) {
   28e7e:	3501      	adds	r5, #1
   28e80:	3608      	adds	r6, #8
   28e82:	e7e3      	b.n	28e4c <zmk_event_manager_handle_from+0x18>
        switch (ret) {
   28e84:	2400      	movs	r4, #0
   28e86:	e7e7      	b.n	28e58 <zmk_event_manager_handle_from+0x24>
   28e88:	00053984 	.word	0x00053984
   28e8c:	0005394c 	.word	0x0005394c

00028e90 <ext_power_save_state_work>:
    bool settings_init;
#endif
};

#if IS_ENABLED(CONFIG_SETTINGS)
static void ext_power_save_state_work(struct k_work *work) {
   28e90:	b500      	push	{lr}
   28e92:	b08b      	sub	sp, #44	; 0x2c
    char setting_path[40];
    const struct device *ext_power = DEVICE_DT_GET(DT_DRV_INST(0));
    struct ext_power_generic_data *data = ext_power->data;

    snprintf(setting_path, 40, "ext_power/state/%s", DT_INST_PROP(0, label));
   28e94:	4b06      	ldr	r3, [pc, #24]	; (28eb0 <ext_power_save_state_work+0x20>)
   28e96:	4a07      	ldr	r2, [pc, #28]	; (28eb4 <ext_power_save_state_work+0x24>)
   28e98:	2128      	movs	r1, #40	; 0x28
   28e9a:	4668      	mov	r0, sp
   28e9c:	f004 fa78 	bl	2d390 <snprintf>
    settings_save_one(setting_path, &data->status, sizeof(data->status));
   28ea0:	4905      	ldr	r1, [pc, #20]	; (28eb8 <ext_power_save_state_work+0x28>)
   28ea2:	2201      	movs	r2, #1
   28ea4:	4668      	mov	r0, sp
   28ea6:	f003 faf9 	bl	2c49c <settings_save_one>
}
   28eaa:	b00b      	add	sp, #44	; 0x2c
   28eac:	f85d fb04 	ldr.w	pc, [sp], #4
   28eb0:	0005303c 	.word	0x0005303c
   28eb4:	00053046 	.word	0x00053046
   28eb8:	20006a73 	.word	0x20006a73

00028ebc <ext_power_generic_init>:

struct settings_handler ext_power_conf = {.name = "ext_power/state",
                                          .h_set = ext_power_settings_set};
#endif

static int ext_power_generic_init(const struct device *dev) {
   28ebc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    struct ext_power_generic_data *data = dev->data;
    const struct ext_power_generic_config *config = dev->config;
   28ec0:	6846      	ldr	r6, [r0, #4]
    struct ext_power_generic_data *data = dev->data;
   28ec2:	6907      	ldr	r7, [r0, #16]
 */
static inline int gpio_pin_configure_dt(const struct gpio_dt_spec *spec,
					gpio_flags_t extra_flags)
{
	return gpio_pin_configure(spec->port,
				  spec->pin,
   28ec4:	7931      	ldrb	r1, [r6, #4]
				  spec->dt_flags | extra_flags);
   28ec6:	88f3      	ldrh	r3, [r6, #6]
static int ext_power_generic_init(const struct device *dev) {
   28ec8:	4604      	mov	r4, r0
	return gpio_pin_configure(spec->port,
   28eca:	6830      	ldr	r0, [r6, #0]
	struct gpio_driver_data *data =
   28ecc:	f8d0 e010 	ldr.w	lr, [r0, #16]
	const struct gpio_driver_api *api =
   28ed0:	f8d0 8008 	ldr.w	r8, [r0, #8]
		data->invert |= (gpio_port_pins_t)BIT(pin);
   28ed4:	f8de 5000 	ldr.w	r5, [lr]
	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
   28ed8:	07da      	lsls	r2, r3, #31
	return gpio_pin_configure(spec->port,
   28eda:	bf54      	ite	pl
   28edc:	f443 13b0 	orrpl.w	r3, r3, #1441792	; 0x160000
		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
   28ee0:	f483 13d0 	eormi.w	r3, r3, #1703936	; 0x1a0000
		data->invert |= (gpio_port_pins_t)BIT(pin);
   28ee4:	f04f 0c01 	mov.w	ip, #1
	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;
   28ee8:	f423 1280 	bic.w	r2, r3, #1048576	; 0x100000
		data->invert |= (gpio_port_pins_t)BIT(pin);
   28eec:	fa0c fc01 	lsl.w	ip, ip, r1
	if ((flags & GPIO_ACTIVE_LOW) != 0) {
   28ef0:	07db      	lsls	r3, r3, #31
		data->invert |= (gpio_port_pins_t)BIT(pin);
   28ef2:	bf4c      	ite	mi
   28ef4:	ea45 050c 	orrmi.w	r5, r5, ip
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
   28ef8:	ea25 050c 	bicpl.w	r5, r5, ip
   28efc:	f8ce 5000 	str.w	r5, [lr]
	return api->pin_configure(port, pin, flags);
   28f00:	f8d8 3000 	ldr.w	r3, [r8]
   28f04:	4798      	blx	r3

    if (gpio_pin_configure_dt(&config->control, GPIO_OUTPUT_INACTIVE)) {
   28f06:	bb60      	cbnz	r0, 28f62 <ext_power_generic_init+0xa6>
        LOG_ERR("Failed to configure ext-power control pin");
        return -EIO;
    }

#if IS_ENABLED(CONFIG_SETTINGS)
    settings_subsys_init();
   28f08:	f003 fc1c 	bl	2c744 <settings_subsys_init>

    int err = settings_register(&ext_power_conf);
   28f0c:	4816      	ldr	r0, [pc, #88]	; (28f68 <ext_power_generic_init+0xac>)
   28f0e:	f003 fb55 	bl	2c5bc <settings_register>
    if (err) {
   28f12:	4605      	mov	r5, r0
   28f14:	bb10      	cbnz	r0, 28f5c <ext_power_generic_init+0xa0>
        LOG_ERR("Failed to register the ext_power settings handler (err %d)", err);
        return err;
    }

    k_work_init_delayable(&ext_power_save_work, ext_power_save_state_work);
   28f16:	4915      	ldr	r1, [pc, #84]	; (28f6c <ext_power_generic_init+0xb0>)
   28f18:	4815      	ldr	r0, [pc, #84]	; (28f70 <ext_power_generic_init+0xb4>)
   28f1a:	f027 f873 	bl	50004 <k_work_init_delayable>

    // Set default value (on) if settings isn't set
    settings_load_subtree("ext_power");
   28f1e:	4815      	ldr	r0, [pc, #84]	; (28f74 <ext_power_generic_init+0xb8>)
   28f20:	f003 faf6 	bl	2c510 <settings_load_subtree>
    if (!data->settings_init) {
   28f24:	787b      	ldrb	r3, [r7, #1]
   28f26:	b95b      	cbnz	r3, 28f40 <ext_power_generic_init+0x84>

        data->status = true;
   28f28:	2301      	movs	r3, #1
   28f2a:	703b      	strb	r3, [r7, #0]
        k_work_schedule(&ext_power_save_work, K_NO_WAIT);
   28f2c:	2200      	movs	r2, #0
   28f2e:	2300      	movs	r3, #0
   28f30:	480f      	ldr	r0, [pc, #60]	; (28f70 <ext_power_generic_init+0xb4>)
   28f32:	f01e fb27 	bl	47584 <k_work_schedule>
__syscall int ext_power_enable(const struct device *dev);

static inline int z_impl_ext_power_enable(const struct device *dev) {
    const struct ext_power_api *api = (const struct ext_power_api *)dev->api;

    if (api->enable == NULL) {
   28f36:	68a3      	ldr	r3, [r4, #8]
   28f38:	681b      	ldr	r3, [r3, #0]
   28f3a:	b10b      	cbz	r3, 28f40 <ext_power_generic_init+0x84>
        return -ENOTSUP;
    }

    return api->enable(dev);
   28f3c:	4620      	mov	r0, r4
   28f3e:	4798      	blx	r3
#else
    // Default to the ext_power being open when no settings
    ext_power_enable(dev);
#endif

    if (config->init_delay_ms) {
   28f40:	8931      	ldrh	r1, [r6, #8]
   28f42:	b159      	cbz	r1, 28f5c <ext_power_generic_init+0xa0>
   28f44:	f240 30e7 	movw	r0, #999	; 0x3e7
   28f48:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   28f4c:	2300      	movs	r3, #0
   28f4e:	eb00 30c1 	add.w	r0, r0, r1, lsl #15
   28f52:	2100      	movs	r1, #0
   28f54:	f7fd f8d4 	bl	26100 <__aeabi_uldivmod>
	return z_impl_k_sleep(timeout);
   28f58:	f01e fe1a 	bl	47b90 <z_impl_k_sleep>
        k_msleep(config->init_delay_ms);
    }

    return 0;
}
   28f5c:	4628      	mov	r0, r5
   28f5e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return -EIO;
   28f62:	f06f 0504 	mvn.w	r5, #4
   28f66:	e7f9      	b.n	28f5c <ext_power_generic_init+0xa0>
   28f68:	200002d8 	.word	0x200002d8
   28f6c:	00028e91 	.word	0x00028e91
   28f70:	20001498 	.word	0x20001498
   28f74:	00053059 	.word	0x00053059

00028f78 <ext_power_save_state>:
int ext_power_save_state() {
   28f78:	b508      	push	{r3, lr}
    int ret = k_work_reschedule(&ext_power_save_work, K_MSEC(CONFIG_ZMK_SETTINGS_SAVE_DEBOUNCE));
   28f7a:	f44f 12f0 	mov.w	r2, #1966080	; 0x1e0000
   28f7e:	2300      	movs	r3, #0
   28f80:	4802      	ldr	r0, [pc, #8]	; (28f8c <ext_power_save_state+0x14>)
   28f82:	f01e fb33 	bl	475ec <k_work_reschedule>
}
   28f86:	ea00 70e0 	and.w	r0, r0, r0, asr #31
   28f8a:	bd08      	pop	{r3, pc}
   28f8c:	20001498 	.word	0x20001498

00028f90 <ext_power_settings_set>:
                                  void *cb_arg) {
   28f90:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   28f92:	460c      	mov	r4, r1
   28f94:	4616      	mov	r6, r2
    if (settings_name_steq(name, DT_INST_PROP(0, label), &next) && !next) {
   28f96:	4911      	ldr	r1, [pc, #68]	; (28fdc <ext_power_settings_set+0x4c>)
   28f98:	aa01      	add	r2, sp, #4
                                  void *cb_arg) {
   28f9a:	461f      	mov	r7, r3
    if (settings_name_steq(name, DT_INST_PROP(0, label), &next) && !next) {
   28f9c:	f020 fbbd 	bl	4971a <settings_name_steq>
   28fa0:	b1b0      	cbz	r0, 28fd0 <ext_power_settings_set+0x40>
   28fa2:	9b01      	ldr	r3, [sp, #4]
   28fa4:	b9a3      	cbnz	r3, 28fd0 <ext_power_settings_set+0x40>
        if (len != sizeof(data->status)) {
   28fa6:	2c01      	cmp	r4, #1
   28fa8:	d115      	bne.n	28fd6 <ext_power_settings_set+0x46>
        rc = read_cb(cb_arg, &data->status, sizeof(data->status));
   28faa:	4d0d      	ldr	r5, [pc, #52]	; (28fe0 <ext_power_settings_set+0x50>)
   28fac:	4622      	mov	r2, r4
   28fae:	4629      	mov	r1, r5
   28fb0:	4638      	mov	r0, r7
   28fb2:	47b0      	blx	r6
        if (rc >= 0) {
   28fb4:	2800      	cmp	r0, #0
   28fb6:	db06      	blt.n	28fc6 <ext_power_settings_set+0x36>
            if (data->status) {
   28fb8:	782b      	ldrb	r3, [r5, #0]
                ext_power_generic_enable(ext_power);
   28fba:	480a      	ldr	r0, [pc, #40]	; (28fe4 <ext_power_settings_set+0x54>)
            data->settings_init = true;
   28fbc:	706c      	strb	r4, [r5, #1]
            if (data->status) {
   28fbe:	b123      	cbz	r3, 28fca <ext_power_settings_set+0x3a>
                ext_power_generic_enable(ext_power);
   28fc0:	f01f f974 	bl	482ac <ext_power_generic_enable>
    return -ENOENT;
   28fc4:	2000      	movs	r0, #0
}
   28fc6:	b003      	add	sp, #12
   28fc8:	bdf0      	pop	{r4, r5, r6, r7, pc}
                ext_power_generic_disable(ext_power);
   28fca:	f01f f981 	bl	482d0 <ext_power_generic_disable>
   28fce:	e7f9      	b.n	28fc4 <ext_power_settings_set+0x34>
    return -ENOENT;
   28fd0:	f06f 0001 	mvn.w	r0, #1
   28fd4:	e7f7      	b.n	28fc6 <ext_power_settings_set+0x36>
            return -EINVAL;
   28fd6:	f06f 0015 	mvn.w	r0, #21
   28fda:	e7f4      	b.n	28fc6 <ext_power_settings_set+0x36>
   28fdc:	0005303c 	.word	0x0005303c
   28fe0:	20006a73 	.word	0x20006a73
   28fe4:	000508ec 	.word	0x000508ec

00028fe8 <new_zmk_activity_state_changed>:
 */

#include <zephyr/kernel.h>
#include <zmk/events/activity_state_changed.h>

   28fe8:	b510      	push	{r4, lr}
   28fea:	4604      	mov	r4, r0
   28fec:	200c      	movs	r0, #12
   28fee:	f027 fb69 	bl	506c4 <k_malloc>
   28ff2:	4a02      	ldr	r2, [pc, #8]	; (28ffc <new_zmk_activity_state_changed+0x14>)
   28ff4:	6002      	str	r2, [r0, #0]
   28ff6:	7204      	strb	r4, [r0, #8]
   28ff8:	bd10      	pop	{r4, pc}
   28ffa:	bf00      	nop
   28ffc:	00050f74 	.word	0x00050f74

00029000 <new_zmk_position_state_changed>:
 */

#include <zephyr/kernel.h>
#include <zmk/events/position_state_changed.h>

   29000:	b084      	sub	sp, #16
   29002:	b570      	push	{r4, r5, r6, lr}
   29004:	ac04      	add	r4, sp, #16
   29006:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
   2900a:	2020      	movs	r0, #32
   2900c:	f027 fb5a 	bl	506c4 <k_malloc>
   29010:	4604      	mov	r4, r0
   29012:	4b08      	ldr	r3, [pc, #32]	; (29034 <new_zmk_position_state_changed+0x34>)
   29014:	f844 3b08 	str.w	r3, [r4], #8
   29018:	ad04      	add	r5, sp, #16
   2901a:	4606      	mov	r6, r0
   2901c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   2901e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   29020:	e895 0003 	ldmia.w	r5, {r0, r1}
   29024:	e884 0003 	stmia.w	r4, {r0, r1}
   29028:	4630      	mov	r0, r6
   2902a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   2902e:	b004      	add	sp, #16
   29030:	4770      	bx	lr
   29032:	bf00      	nop
   29034:	00050f78 	.word	0x00050f78

00029038 <as_zmk_position_state_changed>:
   29038:	6802      	ldr	r2, [r0, #0]
   2903a:	4b03      	ldr	r3, [pc, #12]	; (29048 <as_zmk_position_state_changed+0x10>)
   2903c:	429a      	cmp	r2, r3
   2903e:	bf0c      	ite	eq
   29040:	3008      	addeq	r0, #8
   29042:	2000      	movne	r0, #0
   29044:	4770      	bx	lr
   29046:	bf00      	nop
   29048:	00050f78 	.word	0x00050f78

0002904c <new_zmk_sensor_event>:
 */

#include <zephyr/kernel.h>
#include <zmk/events/sensor_event.h>

   2904c:	b084      	sub	sp, #16
   2904e:	b570      	push	{r4, r5, r6, lr}
   29050:	ac04      	add	r4, sp, #16
   29052:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
   29056:	2028      	movs	r0, #40	; 0x28
   29058:	f027 fb34 	bl	506c4 <k_malloc>
   2905c:	4604      	mov	r4, r0
   2905e:	4b08      	ldr	r3, [pc, #32]	; (29080 <new_zmk_sensor_event+0x34>)
   29060:	f844 3b08 	str.w	r3, [r4], #8
   29064:	ad04      	add	r5, sp, #16
   29066:	4606      	mov	r6, r0
   29068:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   2906a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   2906c:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
   29070:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
   29074:	4630      	mov	r0, r6
   29076:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   2907a:	b004      	add	sp, #16
   2907c:	4770      	bx	lr
   2907e:	bf00      	nop
   29080:	00050f7c 	.word	0x00050f7c

00029084 <as_zmk_sensor_event>:
   29084:	6802      	ldr	r2, [r0, #0]
   29086:	4b03      	ldr	r3, [pc, #12]	; (29094 <as_zmk_sensor_event+0x10>)
   29088:	429a      	cmp	r2, r3
   2908a:	bf0c      	ite	eq
   2908c:	3008      	addeq	r0, #8
   2908e:	2000      	movne	r0, #0
   29090:	4770      	bx	lr
   29092:	bf00      	nop
   29094:	00050f7c 	.word	0x00050f7c

00029098 <new_zmk_usb_conn_state_changed>:
 */

#include <zephyr/kernel.h>
#include <zmk/events/usb_conn_state_changed.h>

   29098:	b510      	push	{r4, lr}
   2909a:	4604      	mov	r4, r0
   2909c:	200c      	movs	r0, #12
   2909e:	f027 fb11 	bl	506c4 <k_malloc>
   290a2:	4a02      	ldr	r2, [pc, #8]	; (290ac <new_zmk_usb_conn_state_changed+0x14>)
   290a4:	6002      	str	r2, [r0, #0]
   290a6:	7204      	strb	r4, [r0, #8]
   290a8:	bd10      	pop	{r4, pc}
   290aa:	bf00      	nop
   290ac:	00050f80 	.word	0x00050f80

000290b0 <on_keymap_binding_pressed>:

    return 0;
}

static int on_keymap_binding_pressed(struct zmk_behavior_binding *binding,
                                     struct zmk_behavior_binding_event event) {
   290b0:	b082      	sub	sp, #8
   290b2:	b538      	push	{r3, r4, r5, lr}
   290b4:	a904      	add	r1, sp, #16
   290b6:	e881 000c 	stmia.w	r1, {r2, r3}
   290ba:	4605      	mov	r5, r0
		union { uintptr_t x; const char * val; } parm0 = { .val = name };
		return (const struct device *) arch_syscall_invoke1(parm0.x, K_SYSCALL_DEVICE_GET_BINDING);
	}
#endif
	compiler_barrier();
	return z_impl_device_get_binding(name);
   290bc:	4811      	ldr	r0, [pc, #68]	; (29104 <on_keymap_binding_pressed+0x54>)
   290be:	f01d fca5 	bl	46a0c <z_impl_device_get_binding>
   290c2:	4604      	mov	r4, r0
    const struct device *ext_power = device_get_binding("EXT_POWER");
    if (ext_power == NULL) {
   290c4:	b1a0      	cbz	r0, 290f0 <on_keymap_binding_pressed+0x40>
        LOG_ERR("Unable to retrieve ext_power device: %d", binding->param1);
        return -EIO;
    }

    switch (binding->param1) {
   290c6:	686b      	ldr	r3, [r5, #4]
   290c8:	2b01      	cmp	r3, #1
   290ca:	d00c      	beq.n	290e6 <on_keymap_binding_pressed+0x36>
   290cc:	2b02      	cmp	r3, #2
   290ce:	d005      	beq.n	290dc <on_keymap_binding_pressed+0x2c>
   290d0:	b9a3      	cbnz	r3, 290fc <on_keymap_binding_pressed+0x4c>
    default:
        LOG_ERR("Unknown ext_power command: %d", binding->param1);
    }

    return -ENOTSUP;
}
   290d2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   290d6:	b002      	add	sp, #8
            return ext_power_disable(ext_power);
   290d8:	f01f b920 	b.w	4831c <ext_power_disable>
        if (ext_power_get(ext_power) > 0)
   290dc:	f01f f925 	bl	4832a <ext_power_get>
   290e0:	2800      	cmp	r0, #0
            return ext_power_disable(ext_power);
   290e2:	4620      	mov	r0, r4
        if (ext_power_get(ext_power) > 0)
   290e4:	dcf5      	bgt.n	290d2 <on_keymap_binding_pressed+0x22>
}
   290e6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   290ea:	b002      	add	sp, #8
            return ext_power_enable(ext_power);
   290ec:	f01f b90f 	b.w	4830e <ext_power_enable>
        return -EIO;
   290f0:	f06f 0004 	mvn.w	r0, #4
}
   290f4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   290f8:	b002      	add	sp, #8
   290fa:	4770      	bx	lr
    switch (binding->param1) {
   290fc:	f06f 0085 	mvn.w	r0, #133	; 0x85
   29100:	e7f8      	b.n	290f4 <on_keymap_binding_pressed+0x44>
   29102:	bf00      	nop
   29104:	0005303c 	.word	0x0005303c

00029108 <on_keymap_binding_convert_central_state_dependent_params>:
                                                         struct zmk_behavior_binding_event event) {
   29108:	b082      	sub	sp, #8
   2910a:	b510      	push	{r4, lr}
   2910c:	a902      	add	r1, sp, #8
   2910e:	e881 000c 	stmia.w	r1, {r2, r3}
   29112:	4604      	mov	r4, r0
   29114:	480b      	ldr	r0, [pc, #44]	; (29144 <on_keymap_binding_convert_central_state_dependent_params+0x3c>)
   29116:	f01d fc79 	bl	46a0c <z_impl_device_get_binding>
    if (ext_power == NULL) {
   2911a:	b178      	cbz	r0, 2913c <on_keymap_binding_convert_central_state_dependent_params+0x34>
    if (binding->param1 == EXT_POWER_TOGGLE_CMD) {
   2911c:	6863      	ldr	r3, [r4, #4]
   2911e:	2b02      	cmp	r3, #2
   29120:	d004      	beq.n	2912c <on_keymap_binding_convert_central_state_dependent_params+0x24>
    return 0;
   29122:	2000      	movs	r0, #0
}
   29124:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   29128:	b002      	add	sp, #8
   2912a:	4770      	bx	lr
        binding->param1 = ext_power_get(ext_power) > 0 ? EXT_POWER_OFF_CMD : EXT_POWER_ON_CMD;
   2912c:	f01f f8fd 	bl	4832a <ext_power_get>
   29130:	2800      	cmp	r0, #0
   29132:	bfcc      	ite	gt
   29134:	2000      	movgt	r0, #0
   29136:	2001      	movle	r0, #1
   29138:	6060      	str	r0, [r4, #4]
   2913a:	e7f2      	b.n	29122 <on_keymap_binding_convert_central_state_dependent_params+0x1a>
        return -EIO;
   2913c:	f06f 0004 	mvn.w	r0, #4
   29140:	e7f0      	b.n	29124 <on_keymap_binding_convert_central_state_dependent_params+0x1c>
   29142:	bf00      	nop
   29144:	0005303c 	.word	0x0005303c

00029148 <zmk_hid_register_mod>:
#define GET_MODIFIERS (keyboard_report.body.modifiers)

zmk_mod_flags_t zmk_hid_get_explicit_mods() { return explicit_modifiers; }

int zmk_hid_register_mod(zmk_mod_t modifier) {
    explicit_modifier_counts[modifier]++;
   29148:	4a0d      	ldr	r2, [pc, #52]	; (29180 <zmk_hid_register_mod+0x38>)
   2914a:	f852 3020 	ldr.w	r3, [r2, r0, lsl #2]
   2914e:	3301      	adds	r3, #1
   29150:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
    LOG_DBG("Modifier %d count %d", modifier, explicit_modifier_counts[modifier]);
    WRITE_BIT(explicit_modifiers, modifier, true);
   29154:	4a0b      	ldr	r2, [pc, #44]	; (29184 <zmk_hid_register_mod+0x3c>)
   29156:	2301      	movs	r3, #1
   29158:	7811      	ldrb	r1, [r2, #0]
   2915a:	4083      	lsls	r3, r0
   2915c:	430b      	orrs	r3, r1
    zmk_mod_flags_t current = GET_MODIFIERS;
    SET_MODIFIERS(explicit_modifiers);
   2915e:	490a      	ldr	r1, [pc, #40]	; (29188 <zmk_hid_register_mod+0x40>)
   29160:	7809      	ldrb	r1, [r1, #0]
    WRITE_BIT(explicit_modifiers, modifier, true);
   29162:	b2db      	uxtb	r3, r3
   29164:	7013      	strb	r3, [r2, #0]
    SET_MODIFIERS(explicit_modifiers);
   29166:	ea23 0301 	bic.w	r3, r3, r1
   2916a:	4908      	ldr	r1, [pc, #32]	; (2918c <zmk_hid_register_mod+0x44>)
    zmk_mod_flags_t current = GET_MODIFIERS;
   2916c:	4a08      	ldr	r2, [pc, #32]	; (29190 <zmk_hid_register_mod+0x48>)
    SET_MODIFIERS(explicit_modifiers);
   2916e:	7809      	ldrb	r1, [r1, #0]
    zmk_mod_flags_t current = GET_MODIFIERS;
   29170:	7850      	ldrb	r0, [r2, #1]
    SET_MODIFIERS(explicit_modifiers);
   29172:	430b      	orrs	r3, r1
    return current == GET_MODIFIERS ? 0 : 1;
}
   29174:	1a18      	subs	r0, r3, r0
    SET_MODIFIERS(explicit_modifiers);
   29176:	7053      	strb	r3, [r2, #1]
}
   29178:	bf18      	it	ne
   2917a:	2001      	movne	r0, #1
   2917c:	4770      	bx	lr
   2917e:	bf00      	nop
   29180:	20003738 	.word	0x20003738
   29184:	20006a77 	.word	0x20006a77
   29188:	20006a75 	.word	0x20006a75
   2918c:	20006a76 	.word	0x20006a76
   29190:	20000f7d 	.word	0x20000f7d

00029194 <zmk_hid_unregister_mod>:

int zmk_hid_unregister_mod(zmk_mod_t modifier) {
   29194:	b510      	push	{r4, lr}
    if (explicit_modifier_counts[modifier] <= 0) {
   29196:	4a11      	ldr	r2, [pc, #68]	; (291dc <zmk_hid_unregister_mod+0x48>)
   29198:	f852 3020 	ldr.w	r3, [r2, r0, lsl #2]
   2919c:	2b00      	cmp	r3, #0
   2919e:	dd19      	ble.n	291d4 <zmk_hid_unregister_mod+0x40>
        LOG_ERR("Tried to unregister modifier %d too often", modifier);
        return -EINVAL;
    }
    explicit_modifier_counts[modifier]--;
   291a0:	3b01      	subs	r3, #1
   291a2:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
    LOG_DBG("Modifier %d count: %d", modifier, explicit_modifier_counts[modifier]);
    if (explicit_modifier_counts[modifier] == 0) {
   291a6:	4a0e      	ldr	r2, [pc, #56]	; (291e0 <zmk_hid_unregister_mod+0x4c>)
   291a8:	b92b      	cbnz	r3, 291b6 <zmk_hid_unregister_mod+0x22>
        LOG_DBG("Modifier %d released", modifier);
        WRITE_BIT(explicit_modifiers, modifier, false);
   291aa:	7813      	ldrb	r3, [r2, #0]
   291ac:	2101      	movs	r1, #1
   291ae:	4081      	lsls	r1, r0
   291b0:	ea23 0301 	bic.w	r3, r3, r1
   291b4:	7013      	strb	r3, [r2, #0]
    }
    zmk_mod_flags_t current = GET_MODIFIERS;
    SET_MODIFIERS(explicit_modifiers);
   291b6:	480b      	ldr	r0, [pc, #44]	; (291e4 <zmk_hid_unregister_mod+0x50>)
    zmk_mod_flags_t current = GET_MODIFIERS;
   291b8:	4b0b      	ldr	r3, [pc, #44]	; (291e8 <zmk_hid_unregister_mod+0x54>)
    SET_MODIFIERS(explicit_modifiers);
   291ba:	7804      	ldrb	r4, [r0, #0]
   291bc:	7810      	ldrb	r0, [r2, #0]
   291be:	4a0b      	ldr	r2, [pc, #44]	; (291ec <zmk_hid_unregister_mod+0x58>)
    zmk_mod_flags_t current = GET_MODIFIERS;
   291c0:	7859      	ldrb	r1, [r3, #1]
    SET_MODIFIERS(explicit_modifiers);
   291c2:	7812      	ldrb	r2, [r2, #0]
   291c4:	ea20 0004 	bic.w	r0, r0, r4
   291c8:	4310      	orrs	r0, r2
   291ca:	7058      	strb	r0, [r3, #1]
    return current == GET_MODIFIERS ? 0 : 1;
   291cc:	1a40      	subs	r0, r0, r1
   291ce:	bf18      	it	ne
   291d0:	2001      	movne	r0, #1
}
   291d2:	bd10      	pop	{r4, pc}
        return -EINVAL;
   291d4:	f06f 0015 	mvn.w	r0, #21
   291d8:	e7fb      	b.n	291d2 <zmk_hid_unregister_mod+0x3e>
   291da:	bf00      	nop
   291dc:	20003738 	.word	0x20003738
   291e0:	20006a77 	.word	0x20006a77
   291e4:	20006a75 	.word	0x20006a75
   291e8:	20000f7d 	.word	0x20000f7d
   291ec:	20006a76 	.word	0x20006a76

000291f0 <zmk_hid_implicit_modifiers_press>:
        if (val) {                                                                                 \
            break;                                                                                 \
        }                                                                                          \
    }

int zmk_hid_implicit_modifiers_press(zmk_mod_flags_t new_implicit_modifiers) {
   291f0:	b510      	push	{r4, lr}
    implicit_modifiers = new_implicit_modifiers;
   291f2:	4b08      	ldr	r3, [pc, #32]	; (29214 <zmk_hid_implicit_modifiers_press+0x24>)
    zmk_mod_flags_t current = GET_MODIFIERS;
   291f4:	4a08      	ldr	r2, [pc, #32]	; (29218 <zmk_hid_implicit_modifiers_press+0x28>)
    implicit_modifiers = new_implicit_modifiers;
   291f6:	7018      	strb	r0, [r3, #0]
    SET_MODIFIERS(explicit_modifiers);
   291f8:	4b08      	ldr	r3, [pc, #32]	; (2921c <zmk_hid_implicit_modifiers_press+0x2c>)
    zmk_mod_flags_t current = GET_MODIFIERS;
   291fa:	7851      	ldrb	r1, [r2, #1]
    SET_MODIFIERS(explicit_modifiers);
   291fc:	781c      	ldrb	r4, [r3, #0]
   291fe:	4b08      	ldr	r3, [pc, #32]	; (29220 <zmk_hid_implicit_modifiers_press+0x30>)
   29200:	781b      	ldrb	r3, [r3, #0]
   29202:	ea23 0304 	bic.w	r3, r3, r4
   29206:	4318      	orrs	r0, r3
   29208:	7050      	strb	r0, [r2, #1]
    return current == GET_MODIFIERS ? 0 : 1;
}
   2920a:	1a40      	subs	r0, r0, r1
   2920c:	bf18      	it	ne
   2920e:	2001      	movne	r0, #1
   29210:	bd10      	pop	{r4, pc}
   29212:	bf00      	nop
   29214:	20006a76 	.word	0x20006a76
   29218:	20000f7d 	.word	0x20000f7d
   2921c:	20006a75 	.word	0x20006a75
   29220:	20006a77 	.word	0x20006a77

00029224 <zmk_hid_implicit_modifiers_release>:

int zmk_hid_implicit_modifiers_release() {
    implicit_modifiers = 0;
   29224:	4b07      	ldr	r3, [pc, #28]	; (29244 <zmk_hid_implicit_modifiers_release+0x20>)
   29226:	2200      	movs	r2, #0
   29228:	701a      	strb	r2, [r3, #0]
    zmk_mod_flags_t current = GET_MODIFIERS;
    SET_MODIFIERS(explicit_modifiers);
   2922a:	4b07      	ldr	r3, [pc, #28]	; (29248 <zmk_hid_implicit_modifiers_release+0x24>)
    zmk_mod_flags_t current = GET_MODIFIERS;
   2922c:	4a07      	ldr	r2, [pc, #28]	; (2924c <zmk_hid_implicit_modifiers_release+0x28>)
    SET_MODIFIERS(explicit_modifiers);
   2922e:	7819      	ldrb	r1, [r3, #0]
   29230:	4b07      	ldr	r3, [pc, #28]	; (29250 <zmk_hid_implicit_modifiers_release+0x2c>)
    zmk_mod_flags_t current = GET_MODIFIERS;
   29232:	7850      	ldrb	r0, [r2, #1]
    SET_MODIFIERS(explicit_modifiers);
   29234:	781b      	ldrb	r3, [r3, #0]
   29236:	ea23 0301 	bic.w	r3, r3, r1
    return current == GET_MODIFIERS ? 0 : 1;
}
   2923a:	1a18      	subs	r0, r3, r0
    SET_MODIFIERS(explicit_modifiers);
   2923c:	7053      	strb	r3, [r2, #1]
}
   2923e:	bf18      	it	ne
   29240:	2001      	movne	r0, #1
   29242:	4770      	bx	lr
   29244:	20006a76 	.word	0x20006a76
   29248:	20006a75 	.word	0x20006a75
   2924c:	20000f7d 	.word	0x20000f7d
   29250:	20006a77 	.word	0x20006a77

00029254 <zmk_hid_keyboard_press>:
    SET_MODIFIERS(explicit_modifiers);
    return current == GET_MODIFIERS ? 0 : 1;
}

int zmk_hid_keyboard_press(zmk_key_t code) {
    if (code >= HID_USAGE_KEY_KEYBOARD_LEFTCONTROL && code <= HID_USAGE_KEY_KEYBOARD_RIGHT_GUI) {
   29254:	f1a0 03e0 	sub.w	r3, r0, #224	; 0xe0
   29258:	2b07      	cmp	r3, #7
   2925a:	d803      	bhi.n	29264 <zmk_hid_keyboard_press+0x10>
        return zmk_hid_register_mod(code - HID_USAGE_KEY_KEYBOARD_LEFTCONTROL);
   2925c:	3020      	adds	r0, #32
   2925e:	b2c0      	uxtb	r0, r0
   29260:	f7ff bf72 	b.w	29148 <zmk_hid_register_mod>
   29264:	4b06      	ldr	r3, [pc, #24]	; (29280 <zmk_hid_keyboard_press+0x2c>)
    if (code >= HID_USAGE_KEY_KEYBOARD_LEFTCONTROL && code <= HID_USAGE_KEY_KEYBOARD_RIGHT_GUI) {
   29266:	2206      	movs	r2, #6
    TOGGLE_KEYBOARD(0U, usage);
   29268:	f813 1f01 	ldrb.w	r1, [r3, #1]!
   2926c:	b119      	cbz	r1, 29276 <zmk_hid_keyboard_press+0x22>
   2926e:	3a01      	subs	r2, #1
   29270:	d1fa      	bne.n	29268 <zmk_hid_keyboard_press+0x14>
    }
    select_keyboard_usage(code);
    return 0;
};
   29272:	2000      	movs	r0, #0
   29274:	4770      	bx	lr
    TOGGLE_KEYBOARD(0U, usage);
   29276:	7018      	strb	r0, [r3, #0]
   29278:	2800      	cmp	r0, #0
   2927a:	d0f8      	beq.n	2926e <zmk_hid_keyboard_press+0x1a>
   2927c:	e7f9      	b.n	29272 <zmk_hid_keyboard_press+0x1e>
   2927e:	bf00      	nop
   29280:	20000f7f 	.word	0x20000f7f

00029284 <zmk_hid_keyboard_release>:

int zmk_hid_keyboard_release(zmk_key_t code) {
    if (code >= HID_USAGE_KEY_KEYBOARD_LEFTCONTROL && code <= HID_USAGE_KEY_KEYBOARD_RIGHT_GUI) {
   29284:	f1a0 03e0 	sub.w	r3, r0, #224	; 0xe0
   29288:	2b07      	cmp	r3, #7
int zmk_hid_keyboard_release(zmk_key_t code) {
   2928a:	b410      	push	{r4}
    if (code >= HID_USAGE_KEY_KEYBOARD_LEFTCONTROL && code <= HID_USAGE_KEY_KEYBOARD_RIGHT_GUI) {
   2928c:	d804      	bhi.n	29298 <zmk_hid_keyboard_release+0x14>
        return zmk_hid_unregister_mod(code - HID_USAGE_KEY_KEYBOARD_LEFTCONTROL);
   2928e:	3020      	adds	r0, #32
    }
    deselect_keyboard_usage(code);
    return 0;
};
   29290:	bc10      	pop	{r4}
        return zmk_hid_unregister_mod(code - HID_USAGE_KEY_KEYBOARD_LEFTCONTROL);
   29292:	b2c0      	uxtb	r0, r0
   29294:	f7ff bf7e 	b.w	29194 <zmk_hid_unregister_mod>
    TOGGLE_KEYBOARD(usage, 0U);
   29298:	2300      	movs	r3, #0
   2929a:	4a06      	ldr	r2, [pc, #24]	; (292b4 <zmk_hid_keyboard_release+0x30>)
   2929c:	4619      	mov	r1, r3
   2929e:	f812 4f01 	ldrb.w	r4, [r2, #1]!
   292a2:	3301      	adds	r3, #1
   292a4:	42a0      	cmp	r0, r4
   292a6:	bf08      	it	eq
   292a8:	7011      	strbeq	r1, [r2, #0]
   292aa:	2b06      	cmp	r3, #6
   292ac:	d1f7      	bne.n	2929e <zmk_hid_keyboard_release+0x1a>
};
   292ae:	2000      	movs	r0, #0
   292b0:	bc10      	pop	{r4}
   292b2:	4770      	bx	lr
   292b4:	20000f7f 	.word	0x20000f7f

000292b8 <zmk_hid_keyboard_clear>:
        return zmk_hid_mod_is_pressed(code - HID_USAGE_KEY_KEYBOARD_LEFTCONTROL);
    }
    return check_keyboard_usage(code);
}

void zmk_hid_keyboard_clear() { memset(&keyboard_report.body, 0, sizeof(keyboard_report.body)); }
   292b8:	4802      	ldr	r0, [pc, #8]	; (292c4 <zmk_hid_keyboard_clear+0xc>)
   292ba:	2208      	movs	r2, #8
   292bc:	2100      	movs	r1, #0
   292be:	f021 bde7 	b.w	4ae90 <memset>
   292c2:	bf00      	nop
   292c4:	20000f7e 	.word	0x20000f7e

000292c8 <zmk_hid_consumer_press>:

int zmk_hid_consumer_press(zmk_key_t code) {
   292c8:	b510      	push	{r4, lr}
    TOGGLE_CONSUMER(0U, code);
   292ca:	4908      	ldr	r1, [pc, #32]	; (292ec <zmk_hid_consumer_press+0x24>)
   292cc:	2300      	movs	r3, #0
   292ce:	eb01 0243 	add.w	r2, r1, r3, lsl #1
   292d2:	f8b2 4001 	ldrh.w	r4, [r2, #1]
   292d6:	b124      	cbz	r4, 292e2 <zmk_hid_consumer_press+0x1a>
   292d8:	3301      	adds	r3, #1
   292da:	2b06      	cmp	r3, #6
   292dc:	d1f7      	bne.n	292ce <zmk_hid_consumer_press+0x6>
    return 0;
};
   292de:	2000      	movs	r0, #0
   292e0:	bd10      	pop	{r4, pc}
    TOGGLE_CONSUMER(0U, code);
   292e2:	f8a2 0001 	strh.w	r0, [r2, #1]
   292e6:	2800      	cmp	r0, #0
   292e8:	d0f6      	beq.n	292d8 <zmk_hid_consumer_press+0x10>
   292ea:	e7f8      	b.n	292de <zmk_hid_consumer_press+0x16>
   292ec:	20000f70 	.word	0x20000f70

000292f0 <zmk_hid_consumer_release>:

int zmk_hid_consumer_release(zmk_key_t code) {
   292f0:	b530      	push	{r4, r5, lr}
    TOGGLE_CONSUMER(code, 0U);
   292f2:	2300      	movs	r3, #0
   292f4:	4c07      	ldr	r4, [pc, #28]	; (29314 <zmk_hid_consumer_release+0x24>)
   292f6:	4619      	mov	r1, r3
   292f8:	eb04 0243 	add.w	r2, r4, r3, lsl #1
   292fc:	3301      	adds	r3, #1
   292fe:	f8b2 5001 	ldrh.w	r5, [r2, #1]
   29302:	4285      	cmp	r5, r0
   29304:	bf04      	itt	eq
   29306:	7051      	strbeq	r1, [r2, #1]
   29308:	7091      	strbeq	r1, [r2, #2]
   2930a:	2b06      	cmp	r3, #6
   2930c:	d1f4      	bne.n	292f8 <zmk_hid_consumer_release+0x8>
    return 0;
};
   2930e:	2000      	movs	r0, #0
   29310:	bd30      	pop	{r4, r5, pc}
   29312:	bf00      	nop
   29314:	20000f70 	.word	0x20000f70

00029318 <zmk_hid_consumer_clear>:

void zmk_hid_consumer_clear() { memset(&consumer_report.body, 0, sizeof(consumer_report.body)); }
   29318:	4802      	ldr	r0, [pc, #8]	; (29324 <zmk_hid_consumer_clear+0xc>)
   2931a:	220c      	movs	r2, #12
   2931c:	2100      	movs	r1, #0
   2931e:	f021 bdb7 	b.w	4ae90 <memset>
   29322:	bf00      	nop
   29324:	20000f71 	.word	0x20000f71

00029328 <zmk_hid_get_keyboard_report>:
    return false;
}

struct zmk_hid_keyboard_report *zmk_hid_get_keyboard_report() {
    return &keyboard_report;
}
   29328:	4800      	ldr	r0, [pc, #0]	; (2932c <zmk_hid_get_keyboard_report+0x4>)
   2932a:	4770      	bx	lr
   2932c:	20000f7d 	.word	0x20000f7d

00029330 <zmk_hid_get_consumer_report>:

struct zmk_hid_consumer_report *zmk_hid_get_consumer_report() {
    return &consumer_report;
}
   29330:	4800      	ldr	r0, [pc, #0]	; (29334 <zmk_hid_get_consumer_report+0x4>)
   29332:	4770      	bx	lr
   29334:	20000f70 	.word	0x20000f70

00029338 <zmk_behavior_sensor_rotate_common_accept_data>:
LOG_MODULE_DECLARE(zmk, CONFIG_ZMK_LOG_LEVEL);

int zmk_behavior_sensor_rotate_common_accept_data(
    struct zmk_behavior_binding *binding, struct zmk_behavior_binding_event event,
    const struct zmk_sensor_config *sensor_config, size_t channel_data_size,
    const struct zmk_sensor_channel_data *channel_data) {
   29338:	b082      	sub	sp, #8
   2933a:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   2933e:	a908      	add	r1, sp, #32
   29340:	e881 000c 	stmia.w	r1, {r2, r3}
   29344:	9c0e      	ldr	r4, [sp, #56]	; 0x38
    const struct device *dev = device_get_binding(binding->behavior_dev);
   29346:	6800      	ldr	r0, [r0, #0]
   29348:	4617      	mov	r7, r2
   2934a:	f01d fb5f 	bl	46a0c <z_impl_device_get_binding>
    struct behavior_sensor_rotate_data *data = dev->data;
   2934e:	6905      	ldr	r5, [r0, #16]

    const struct sensor_value value = channel_data[0].value;
    int triggers;
    int sensor_index = ZMK_SENSOR_POSITION_FROM_VIRTUAL_KEY_POSITION(event.position);
   29350:	9809      	ldr	r0, [sp, #36]	; 0x24
    const struct sensor_value value = channel_data[0].value;
   29352:	6823      	ldr	r3, [r4, #0]
   29354:	6866      	ldr	r6, [r4, #4]
    int sensor_index = ZMK_SENSOR_POSITION_FROM_VIRTUAL_KEY_POSITION(event.position);
   29356:	383c      	subs	r0, #60	; 0x3c

    // Some funky special casing for "old encoder behavior" where ticks where reported in val2 only,
    // instead of rotational degrees in val1.
    // REMOVE ME: Remove after a grace period of old ec11 sensor behavior
    if (value.val1 == 0) {
   29358:	0042      	lsls	r2, r0, #1
   2935a:	b1f3      	cbz	r3, 2939a <zmk_behavior_sensor_rotate_common_accept_data+0x62>
        triggers = value.val2;
    } else {
        struct sensor_value remainder = data->remainder[sensor_index][event.layer];
   2935c:	1814      	adds	r4, r2, r0
   2935e:	443c      	add	r4, r7
   29360:	eb05 0ec4 	add.w	lr, r5, r4, lsl #3

        remainder.val1 += value.val1;
        remainder.val2 += value.val2;

        if (remainder.val2 >= 1000000 || remainder.val2 <= 1000000) {
            remainder.val1 += remainder.val2 / 1000000;
   29364:	f8df 9048 	ldr.w	r9, [pc, #72]	; 293b0 <zmk_behavior_sensor_rotate_common_accept_data+0x78>
        remainder.val2 += value.val2;
   29368:	f8de 1004 	ldr.w	r1, [lr, #4]
   2936c:	4431      	add	r1, r6
        remainder.val1 += value.val1;
   2936e:	f855 6034 	ldr.w	r6, [r5, r4, lsl #3]
            remainder.val1 += remainder.val2 / 1000000;
   29372:	fb91 f8f9 	sdiv	r8, r1, r9
        remainder.val1 += value.val1;
   29376:	4433      	add	r3, r6
            remainder.val2 %= 1000000;
        }

        int trigger_degrees = 360 / sensor_config->triggers_per_rotation;
   29378:	9e0c      	ldr	r6, [sp, #48]	; 0x30
            remainder.val1 += remainder.val2 / 1000000;
   2937a:	4443      	add	r3, r8
        int trigger_degrees = 360 / sensor_config->triggers_per_rotation;
   2937c:	8836      	ldrh	r6, [r6, #0]
   2937e:	f44f 7cb4 	mov.w	ip, #360	; 0x168
            remainder.val2 %= 1000000;
   29382:	fb09 1118 	mls	r1, r9, r8, r1
        int trigger_degrees = 360 / sensor_config->triggers_per_rotation;
   29386:	fbbc fcf6 	udiv	ip, ip, r6
        triggers = remainder.val1 / trigger_degrees;
   2938a:	fb93 f6fc 	sdiv	r6, r3, ip
        remainder.val1 %= trigger_degrees;
   2938e:	fb0c 3316 	mls	r3, ip, r6, r3

        data->remainder[sensor_index][event.layer] = remainder;
   29392:	f845 3034 	str.w	r3, [r5, r4, lsl #3]
   29396:	f8ce 1004 	str.w	r1, [lr, #4]
        "val1: %d, val2: %d, remainder: %d/%d triggers: %d inc keycode 0x%02X dec keycode 0x%02X",
        value.val1, value.val2, data->remainder[sensor_index][event.layer].val1,
        data->remainder[sensor_index][event.layer].val2, triggers, binding->param1,
        binding->param2);

    data->triggers[sensor_index][event.layer] = triggers;
   2939a:	4402      	add	r2, r0
   2939c:	443a      	add	r2, r7
   2939e:	320c      	adds	r2, #12
    return 0;
}
   293a0:	2000      	movs	r0, #0
    data->triggers[sensor_index][event.layer] = triggers;
   293a2:	f845 6022 	str.w	r6, [r5, r2, lsl #2]
}
   293a6:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   293aa:	b002      	add	sp, #8
   293ac:	4770      	bx	lr
   293ae:	bf00      	nop
   293b0:	000f4240 	.word	0x000f4240

000293b4 <behavior_queue_process_next>:
K_MSGQ_DEFINE(zmk_behavior_queue_msgq, sizeof(struct q_item), CONFIG_ZMK_BEHAVIORS_QUEUE_SIZE, 4);

static void behavior_queue_process_next(struct k_work *work);
static K_WORK_DELAYABLE_DEFINE(queue_work, behavior_queue_process_next);

static void behavior_queue_process_next(struct k_work *work) {
   293b4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   293b8:	b095      	sub	sp, #84	; 0x54
    struct q_item item = {.wait = 0};
   293ba:	2214      	movs	r2, #20
   293bc:	2100      	movs	r1, #0
   293be:	a80f      	add	r0, sp, #60	; 0x3c
   293c0:	f021 fd66 	bl	4ae90 <memset>
	return z_impl_k_msgq_get(msgq, data, timeout);
   293c4:	f8df 80d0 	ldr.w	r8, [pc, #208]	; 29498 <behavior_queue_process_next+0xe4>
   293c8:	f44f 777a 	mov.w	r7, #1000	; 0x3e8
   293cc:	2200      	movs	r2, #0
   293ce:	2300      	movs	r3, #0
   293d0:	a90f      	add	r1, sp, #60	; 0x3c
   293d2:	4640      	mov	r0, r8
   293d4:	f01d fd8c 	bl	46ef0 <z_impl_k_msgq_get>

    while (k_msgq_get(&zmk_behavior_queue_msgq, &item, K_NO_WAIT) == 0) {
   293d8:	2800      	cmp	r0, #0
   293da:	d149      	bne.n	29470 <behavior_queue_process_next+0xbc>
        LOG_DBG("Invoking %s: 0x%02x 0x%02x", item.binding.behavior_dev, item.binding.param1,
                item.binding.param2);

        struct zmk_behavior_binding_event event = {.position = item.position,
   293dc:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
   293de:	9002      	str	r0, [sp, #8]
	return z_impl_k_uptime_ticks();
   293e0:	f026 ffbe 	bl	50360 <z_impl_k_uptime_ticks>
   293e4:	fba0 0c07 	umull	r0, ip, r0, r7
   293e8:	fb07 cc01 	mla	ip, r7, r1, ip
   293ec:	0bc5      	lsrs	r5, r0, #15
   293ee:	ea45 454c 	orr.w	r5, r5, ip, lsl #17
                                                   .timestamp = k_uptime_get()};

        if (item.press) {
   293f2:	f89d 304c 	ldrb.w	r3, [sp, #76]	; 0x4c
   293f6:	e9cd 6503 	strd	r6, r5, [sp, #12]
   293fa:	ea4f 3cdc 	mov.w	ip, ip, lsr #15
   293fe:	f013 0f01 	tst.w	r3, #1
   29402:	f8cd c014 	str.w	ip, [sp, #20]
   29406:	ab02      	add	r3, sp, #8
   29408:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
   2940a:	ac06      	add	r4, sp, #24
   2940c:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
   29410:	f10d 0928 	add.w	r9, sp, #40	; 0x28
   29414:	d02f      	beq.n	29476 <behavior_queue_process_next+0xc2>
		union { uintptr_t x; struct zmk_behavior_binding_event val; } parm1 = { .val = event };
		return (int) arch_syscall_invoke2(parm0.x, parm1.x, K_SYSCALL_BEHAVIOR_KEYMAP_BINDING_PRESSED);
	}
#endif
	compiler_barrier();
	return z_impl_behavior_keymap_binding_pressed(binding, event);
   29416:	e9cd 6507 	strd	r6, r5, [sp, #28]
   2941a:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
   2941e:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
   29422:	e889 000f 	stmia.w	r9, {r0, r1, r2, r3}
__syscall int behavior_keymap_binding_pressed(struct zmk_behavior_binding *binding,
                                              struct zmk_behavior_binding_event event);

static inline int z_impl_behavior_keymap_binding_pressed(struct zmk_behavior_binding *binding,
                                                         struct zmk_behavior_binding_event event) {
    const struct device *dev = device_get_binding(binding->behavior_dev);
   29426:	9810      	ldr	r0, [sp, #64]	; 0x40
   29428:	f01d faf0 	bl	46a0c <z_impl_device_get_binding>

    if (dev == NULL) {
   2942c:	b150      	cbz	r0, 29444 <behavior_queue_process_next+0x90>
        return -EINVAL;
    }

    const struct behavior_driver_api *api = (const struct behavior_driver_api *)dev->api;

    if (api->binding_pressed == NULL) {
   2942e:	6883      	ldr	r3, [r0, #8]
   29430:	689c      	ldr	r4, [r3, #8]
        return -EINVAL;
    }

    const struct behavior_driver_api *api = (const struct behavior_driver_api *)dev->api;

    if (api->binding_released == NULL) {
   29432:	b13c      	cbz	r4, 29444 <behavior_queue_process_next+0x90>
        return -ENOTSUP;
    }

    return api->binding_released(binding, event);
   29434:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
   29438:	e88d 0003 	stmia.w	sp, {r0, r1}
   2943c:	a810      	add	r0, sp, #64	; 0x40
   2943e:	e899 000c 	ldmia.w	r9, {r2, r3}
   29442:	47a0      	blx	r4
            behavior_keymap_binding_released(&item.binding, event);
        }

        LOG_DBG("Processing next queued behavior in %dms", item.wait);

        if (item.wait > 0) {
   29444:	9c13      	ldr	r4, [sp, #76]	; 0x4c
   29446:	2c01      	cmp	r4, #1
   29448:	d9c0      	bls.n	293cc <behavior_queue_process_next+0x18>
            k_work_schedule(&queue_work, K_MSEC(item.wait));
   2944a:	f3c4 045e 	ubfx	r4, r4, #1, #31
   2944e:	f44f 4500 	mov.w	r5, #32768	; 0x8000
   29452:	f240 30e7 	movw	r0, #999	; 0x3e7
   29456:	2100      	movs	r1, #0
   29458:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   2945c:	2300      	movs	r3, #0
   2945e:	fbe5 0104 	umlal	r0, r1, r5, r4
   29462:	f7fc fe4d 	bl	26100 <__aeabi_uldivmod>
   29466:	4602      	mov	r2, r0
   29468:	460b      	mov	r3, r1
   2946a:	480c      	ldr	r0, [pc, #48]	; (2949c <behavior_queue_process_next+0xe8>)
   2946c:	f01e f88a 	bl	47584 <k_work_schedule>
            break;
        }
    }
}
   29470:	b015      	add	sp, #84	; 0x54
   29472:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		union { uintptr_t x; struct zmk_behavior_binding_event val; } parm1 = { .val = event };
		return (int) arch_syscall_invoke2(parm0.x, parm1.x, K_SYSCALL_BEHAVIOR_KEYMAP_BINDING_RELEASED);
	}
#endif
	compiler_barrier();
	return z_impl_behavior_keymap_binding_released(binding, event);
   29476:	e9cd 6507 	strd	r6, r5, [sp, #28]
   2947a:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
   2947e:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
   29482:	e889 000f 	stmia.w	r9, {r0, r1, r2, r3}
    const struct device *dev = device_get_binding(binding->behavior_dev);
   29486:	9810      	ldr	r0, [sp, #64]	; 0x40
   29488:	f01d fac0 	bl	46a0c <z_impl_device_get_binding>
    if (dev == NULL) {
   2948c:	2800      	cmp	r0, #0
   2948e:	d0d9      	beq.n	29444 <behavior_queue_process_next+0x90>
    if (api->binding_released == NULL) {
   29490:	6883      	ldr	r3, [r0, #8]
   29492:	68dc      	ldr	r4, [r3, #12]
   29494:	e7cd      	b.n	29432 <behavior_queue_process_next+0x7e>
   29496:	bf00      	nop
   29498:	2000117c 	.word	0x2000117c
   2949c:	20000000 	.word	0x20000000

000294a0 <zmk_behavior_queue_add>:

int zmk_behavior_queue_add(uint32_t position, const struct zmk_behavior_binding binding, bool press,
                           uint32_t wait) {
   294a0:	b510      	push	{r4, lr}
   294a2:	b08a      	sub	sp, #40	; 0x28
   294a4:	ac01      	add	r4, sp, #4
   294a6:	e884 000e 	stmia.w	r4, {r1, r2, r3}
    struct q_item item = {.press = press, .binding = binding, .wait = wait};
   294aa:	a805      	add	r0, sp, #20
   294ac:	2211      	movs	r2, #17
   294ae:	2100      	movs	r1, #0
   294b0:	f021 fcee 	bl	4ae90 <memset>
   294b4:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
   294b8:	ab06      	add	r3, sp, #24
   294ba:	e883 0007 	stmia.w	r3, {r0, r1, r2}
   294be:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
   294c2:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   294c4:	ea43 0342 	orr.w	r3, r3, r2, lsl #1
   294c8:	9309      	str	r3, [sp, #36]	; 0x24
	return z_impl_k_msgq_put(msgq, data, timeout);
   294ca:	4809      	ldr	r0, [pc, #36]	; (294f0 <zmk_behavior_queue_add+0x50>)
   294cc:	2200      	movs	r2, #0
   294ce:	2300      	movs	r3, #0
   294d0:	a905      	add	r1, sp, #20
   294d2:	f01d fcb7 	bl	46e44 <z_impl_k_msgq_put>

    const int ret = k_msgq_put(&zmk_behavior_queue_msgq, &item, K_NO_WAIT);
    if (ret < 0) {
   294d6:	2800      	cmp	r0, #0
   294d8:	db04      	blt.n	294e4 <zmk_behavior_queue_add+0x44>
}

static inline bool k_work_delayable_is_pending(
	const struct k_work_delayable *dwork)
{
	return k_work_delayable_busy_get(dwork) != 0;
   294da:	4806      	ldr	r0, [pc, #24]	; (294f4 <zmk_behavior_queue_add+0x54>)
   294dc:	f026 fd9e 	bl	5001c <k_work_delayable_busy_get>
        return ret;
    }

    if (!k_work_delayable_is_pending(&queue_work)) {
   294e0:	b110      	cbz	r0, 294e8 <zmk_behavior_queue_add+0x48>
        behavior_queue_process_next(&queue_work.work);
    }

    return 0;
   294e2:	2000      	movs	r0, #0
}
   294e4:	b00a      	add	sp, #40	; 0x28
   294e6:	bd10      	pop	{r4, pc}
        behavior_queue_process_next(&queue_work.work);
   294e8:	4802      	ldr	r0, [pc, #8]	; (294f4 <zmk_behavior_queue_add+0x54>)
   294ea:	f7ff ff63 	bl	293b4 <behavior_queue_process_next>
   294ee:	e7f8      	b.n	294e2 <zmk_behavior_queue_add+0x42>
   294f0:	2000117c 	.word	0x2000117c
   294f4:	20000000 	.word	0x20000000

000294f8 <send_keyboard_report>:
    enum zmk_endpoint new_endpoint =
        (preferred_endpoint == ZMK_ENDPOINT_USB) ? ZMK_ENDPOINT_BLE : ZMK_ENDPOINT_USB;
    return zmk_endpoints_select(new_endpoint);
}

static int send_keyboard_report() {
   294f8:	b508      	push	{r3, lr}
    struct zmk_hid_keyboard_report *keyboard_report = zmk_hid_get_keyboard_report();
   294fa:	f7ff ff15 	bl	29328 <zmk_hid_get_keyboard_report>

    switch (current_endpoint) {
   294fe:	4a09      	ldr	r2, [pc, #36]	; (29524 <send_keyboard_report+0x2c>)
   29500:	7812      	ldrb	r2, [r2, #0]
   29502:	b122      	cbz	r2, 2950e <send_keyboard_report+0x16>
   29504:	2a01      	cmp	r2, #1
   29506:	d007      	beq.n	29518 <send_keyboard_report+0x20>

    default:
        LOG_ERR("Unsupported endpoint %d", current_endpoint);
        return -ENOTSUP;
    }
}
   29508:	f06f 0085 	mvn.w	r0, #133	; 0x85
   2950c:	bd08      	pop	{r3, pc}
   2950e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        int err = zmk_usb_hid_send_report((uint8_t *)keyboard_report, sizeof(*keyboard_report));
   29512:	2109      	movs	r1, #9
   29514:	f001 bacc 	b.w	2aab0 <zmk_usb_hid_send_report>
}
   29518:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        int err = zmk_hog_send_keyboard_report(&keyboard_report->body);
   2951c:	3001      	adds	r0, #1
   2951e:	f000 bdc1 	b.w	2a0a4 <zmk_hog_send_keyboard_report>
   29522:	bf00      	nop
   29524:	20000f86 	.word	0x20000f86

00029528 <send_consumer_report>:

static int send_consumer_report() {
   29528:	b508      	push	{r3, lr}
    struct zmk_hid_consumer_report *consumer_report = zmk_hid_get_consumer_report();
   2952a:	f7ff ff01 	bl	29330 <zmk_hid_get_consumer_report>

    switch (current_endpoint) {
   2952e:	4a09      	ldr	r2, [pc, #36]	; (29554 <send_consumer_report+0x2c>)
   29530:	7812      	ldrb	r2, [r2, #0]
   29532:	b122      	cbz	r2, 2953e <send_consumer_report+0x16>
   29534:	2a01      	cmp	r2, #1
   29536:	d007      	beq.n	29548 <send_consumer_report+0x20>

    default:
        LOG_ERR("Unsupported endpoint %d", current_endpoint);
        return -ENOTSUP;
    }
}
   29538:	f06f 0085 	mvn.w	r0, #133	; 0x85
   2953c:	bd08      	pop	{r3, pc}
   2953e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        int err = zmk_usb_hid_send_report((uint8_t *)consumer_report, sizeof(*consumer_report));
   29542:	210d      	movs	r1, #13
   29544:	f001 bab4 	b.w	2aab0 <zmk_usb_hid_send_report>
}
   29548:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        int err = zmk_hog_send_consumer_report(&consumer_report->body);
   2954c:	3001      	adds	r0, #1
   2954e:	f000 bdcf 	b.w	2a0f0 <zmk_hog_send_consumer_report>
   29552:	bf00      	nop
   29554:	20000f86 	.word	0x20000f86

00029558 <endpoints_save_preferred_work>:
    settings_save_one("endpoints/preferred", &preferred_endpoint, sizeof(preferred_endpoint));
   29558:	4902      	ldr	r1, [pc, #8]	; (29564 <endpoints_save_preferred_work+0xc>)
   2955a:	4803      	ldr	r0, [pc, #12]	; (29568 <endpoints_save_preferred_work+0x10>)
   2955c:	2201      	movs	r2, #1
   2955e:	f002 bf9d 	b.w	2c49c <settings_save_one>
   29562:	bf00      	nop
   29564:	20006a78 	.word	0x20006a78
   29568:	0005310c 	.word	0x0005310c

0002956c <zmk_endpoints_init>:
}

struct settings_handler endpoints_handler = {.name = "endpoints", .h_set = endpoints_handle_set};
#endif /* IS_ENABLED(CONFIG_SETTINGS) */

static int zmk_endpoints_init(const struct device *_arg) {
   2956c:	b510      	push	{r4, lr}
#if IS_ENABLED(CONFIG_SETTINGS)
    settings_subsys_init();
   2956e:	f003 f8e9 	bl	2c744 <settings_subsys_init>

    int err = settings_register(&endpoints_handler);
   29572:	4807      	ldr	r0, [pc, #28]	; (29590 <zmk_endpoints_init+0x24>)
   29574:	f003 f822 	bl	2c5bc <settings_register>
    if (err) {
   29578:	4604      	mov	r4, r0
   2957a:	b930      	cbnz	r0, 2958a <zmk_endpoints_init+0x1e>
        LOG_ERR("Failed to register the endpoints settings handler (err %d)", err);
        return err;
    }

    k_work_init_delayable(&endpoints_save_work, endpoints_save_preferred_work);
   2957c:	4805      	ldr	r0, [pc, #20]	; (29594 <zmk_endpoints_init+0x28>)
   2957e:	4906      	ldr	r1, [pc, #24]	; (29598 <zmk_endpoints_init+0x2c>)
   29580:	f026 fd40 	bl	50004 <k_work_init_delayable>

    settings_load_subtree("endpoints");
   29584:	4805      	ldr	r0, [pc, #20]	; (2959c <zmk_endpoints_init+0x30>)
   29586:	f002 ffc3 	bl	2c510 <settings_load_subtree>
#endif

    return 0;
}
   2958a:	4620      	mov	r0, r4
   2958c:	bd10      	pop	{r4, pc}
   2958e:	bf00      	nop
   29590:	20000310 	.word	0x20000310
   29594:	200014c8 	.word	0x200014c8
   29598:	00029559 	.word	0x00029559
   2959c:	00053120 	.word	0x00053120

000295a0 <update_current_endpoint>:

    zmk_endpoints_send_report(HID_USAGE_KEY);
    zmk_endpoints_send_report(HID_USAGE_CONSUMER);
}

static void update_current_endpoint() {
   295a0:	b538      	push	{r3, r4, r5, lr}
    return zmk_ble_active_profile_is_connected();
   295a2:	f000 fb41 	bl	29c28 <zmk_ble_active_profile_is_connected>
    if (is_ble_ready()) {
   295a6:	b1c8      	cbz	r0, 295dc <update_current_endpoint+0x3c>

enum usb_dc_status_code zmk_usb_get_status();
enum zmk_usb_conn_state zmk_usb_get_conn_state();

static inline bool zmk_usb_is_powered() { return zmk_usb_get_conn_state() != ZMK_USB_CONN_NONE; }
static inline bool zmk_usb_is_hid_ready() { return zmk_usb_get_conn_state() == ZMK_USB_CONN_HID; }
   295a8:	f001 fa4c 	bl	2aa44 <zmk_usb_get_conn_state>
        if (is_usb_ready()) {
   295ac:	2802      	cmp	r0, #2
   295ae:	d11b      	bne.n	295e8 <update_current_endpoint+0x48>
            return preferred_endpoint;
   295b0:	4b0f      	ldr	r3, [pc, #60]	; (295f0 <update_current_endpoint+0x50>)
   295b2:	781c      	ldrb	r4, [r3, #0]
    enum zmk_endpoint new_endpoint = get_selected_endpoint();

    if (new_endpoint != current_endpoint) {
   295b4:	4d0f      	ldr	r5, [pc, #60]	; (295f4 <update_current_endpoint+0x54>)
   295b6:	782b      	ldrb	r3, [r5, #0]
   295b8:	42a3      	cmp	r3, r4
   295ba:	d017      	beq.n	295ec <update_current_endpoint+0x4c>
    zmk_hid_keyboard_clear();
   295bc:	f7ff fe7c 	bl	292b8 <zmk_hid_keyboard_clear>
    zmk_hid_consumer_clear();
   295c0:	f7ff feaa 	bl	29318 <zmk_hid_consumer_clear>
        return send_keyboard_report();
   295c4:	f7ff ff98 	bl	294f8 <send_keyboard_report>
        return send_consumer_report();
   295c8:	f7ff ffae 	bl	29528 <send_consumer_report>
        disconnect_current_endpoint();

        current_endpoint = new_endpoint;
        LOG_INF("Endpoint changed: %d", current_endpoint);

        ZMK_EVENT_RAISE(new_zmk_endpoint_selection_changed(
   295cc:	4620      	mov	r0, r4
        current_endpoint = new_endpoint;
   295ce:	702c      	strb	r4, [r5, #0]
        ZMK_EVENT_RAISE(new_zmk_endpoint_selection_changed(
   295d0:	f000 f830 	bl	29634 <new_zmk_endpoint_selection_changed>
            (struct zmk_endpoint_selection_changed){.endpoint = current_endpoint}));
    }
}
   295d4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        ZMK_EVENT_RAISE(new_zmk_endpoint_selection_changed(
   295d8:	f01e be52 	b.w	48280 <zmk_event_manager_raise>
   295dc:	f001 fa32 	bl	2aa44 <zmk_usb_get_conn_state>
    if (is_usb_ready()) {
   295e0:	1e84      	subs	r4, r0, #2
   295e2:	bf18      	it	ne
   295e4:	2401      	movne	r4, #1
   295e6:	e7e5      	b.n	295b4 <update_current_endpoint+0x14>
        return ZMK_ENDPOINT_BLE;
   295e8:	2401      	movs	r4, #1
   295ea:	e7e3      	b.n	295b4 <update_current_endpoint+0x14>
}
   295ec:	bd38      	pop	{r3, r4, r5, pc}
   295ee:	bf00      	nop
   295f0:	20006a78 	.word	0x20006a78
   295f4:	20000f86 	.word	0x20000f86

000295f8 <endpoints_handle_set>:
                                void *cb_arg) {
   295f8:	b570      	push	{r4, r5, r6, lr}
   295fa:	460c      	mov	r4, r1
   295fc:	4615      	mov	r5, r2
    if (settings_name_steq(name, "preferred", NULL)) {
   295fe:	490b      	ldr	r1, [pc, #44]	; (2962c <endpoints_handle_set+0x34>)
   29600:	2200      	movs	r2, #0
                                void *cb_arg) {
   29602:	461e      	mov	r6, r3
    if (settings_name_steq(name, "preferred", NULL)) {
   29604:	f020 f889 	bl	4971a <settings_name_steq>
   29608:	b908      	cbnz	r0, 2960e <endpoints_handle_set+0x16>
    return 0;
   2960a:	2000      	movs	r0, #0
}
   2960c:	bd70      	pop	{r4, r5, r6, pc}
        if (len != sizeof(enum zmk_endpoint)) {
   2960e:	2c01      	cmp	r4, #1
   29610:	d108      	bne.n	29624 <endpoints_handle_set+0x2c>
        int err = read_cb(cb_arg, &preferred_endpoint, sizeof(enum zmk_endpoint));
   29612:	4907      	ldr	r1, [pc, #28]	; (29630 <endpoints_handle_set+0x38>)
   29614:	4622      	mov	r2, r4
   29616:	4630      	mov	r0, r6
   29618:	47a8      	blx	r5
        if (err <= 0) {
   2961a:	2800      	cmp	r0, #0
   2961c:	ddf6      	ble.n	2960c <endpoints_handle_set+0x14>
        update_current_endpoint();
   2961e:	f7ff ffbf 	bl	295a0 <update_current_endpoint>
   29622:	e7f2      	b.n	2960a <endpoints_handle_set+0x12>
            return -EINVAL;
   29624:	f06f 0015 	mvn.w	r0, #21
   29628:	e7f0      	b.n	2960c <endpoints_handle_set+0x14>
   2962a:	bf00      	nop
   2962c:	00053116 	.word	0x00053116
   29630:	20006a78 	.word	0x20006a78

00029634 <new_zmk_endpoint_selection_changed>:
 */

#include <zephyr/kernel.h>
#include <zmk/events/endpoint_selection_changed.h>

ZMK_EVENT_IMPL(zmk_endpoint_selection_changed);
   29634:	b510      	push	{r4, lr}
   29636:	4604      	mov	r4, r0
   29638:	200c      	movs	r0, #12
   2963a:	f027 f843 	bl	506c4 <k_malloc>
   2963e:	4a02      	ldr	r2, [pc, #8]	; (29648 <new_zmk_endpoint_selection_changed+0x14>)
   29640:	6002      	str	r2, [r0, #0]
   29642:	7204      	strb	r4, [r0, #8]
   29644:	bd10      	pop	{r4, pc}
   29646:	bf00      	nop
   29648:	00051038 	.word	0x00051038

0002964c <set_layer_state>:
                                                        DT_INST_FOREACH_CHILD(0, SENSOR_LAYER)};

#endif /* ZMK_KEYMAP_HAS_SENSORS */

static inline int set_layer_state(uint8_t layer, bool state) {
    if (layer >= ZMK_KEYMAP_LAYERS_LEN) {
   2964c:	2802      	cmp	r0, #2
static inline int set_layer_state(uint8_t layer, bool state) {
   2964e:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    if (layer >= ZMK_KEYMAP_LAYERS_LEN) {
   29650:	d82f      	bhi.n	296b2 <set_layer_state+0x66>
        return -EINVAL;
    }

    // Default layer should *always* remain active
    if (layer == _zmk_keymap_layer_default && !state) {
   29652:	bb28      	cbnz	r0, 296a0 <set_layer_state+0x54>
   29654:	b309      	cbz	r1, 2969a <set_layer_state+0x4e>
        return 0;
    }

    zmk_keymap_layers_state_t old_state = _zmk_keymap_layer_state;
   29656:	4b18      	ldr	r3, [pc, #96]	; (296b8 <set_layer_state+0x6c>)
   29658:	681a      	ldr	r2, [r3, #0]
    WRITE_BIT(_zmk_keymap_layer_state, layer, state);
   2965a:	2301      	movs	r3, #1
   2965c:	4083      	lsls	r3, r0
   2965e:	4313      	orrs	r3, r2
   29660:	4c15      	ldr	r4, [pc, #84]	; (296b8 <set_layer_state+0x6c>)
    // Don't send state changes unless there was an actual change
    if (old_state != _zmk_keymap_layer_state) {
   29662:	429a      	cmp	r2, r3
    WRITE_BIT(_zmk_keymap_layer_state, layer, state);
   29664:	6023      	str	r3, [r4, #0]
    if (old_state != _zmk_keymap_layer_state) {
   29666:	d018      	beq.n	2969a <set_layer_state+0x4e>

ZMK_EVENT_DECLARE(zmk_layer_state_changed);

static inline struct zmk_layer_state_changed_event *create_layer_state_changed(uint8_t layer,
                                                                               bool state) {
    return new_zmk_layer_state_changed((struct zmk_layer_state_changed){
   29668:	f88d 0000 	strb.w	r0, [sp]
   2966c:	f88d 1001 	strb.w	r1, [sp, #1]
	return z_impl_k_uptime_ticks();
   29670:	f026 fe76 	bl	50360 <z_impl_k_uptime_ticks>
   29674:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   29678:	fba0 0302 	umull	r0, r3, r0, r2
   2967c:	fb02 3101 	mla	r1, r2, r1, r3
   29680:	0bc0      	lsrs	r0, r0, #15
   29682:	ea40 4041 	orr.w	r0, r0, r1, lsl #17
   29686:	0bc9      	lsrs	r1, r1, #15
   29688:	e9cd 0102 	strd	r0, r1, [sp, #8]
   2968c:	ab04      	add	r3, sp, #16
   2968e:	e913 000f 	ldmdb	r3, {r0, r1, r2, r3}
   29692:	f000 f943 	bl	2991c <new_zmk_layer_state_changed>
        LOG_DBG("layer_changed: layer %d state %d", layer, state);
        ZMK_EVENT_RAISE(create_layer_state_changed(layer, state));
   29696:	f01e fdf3 	bl	48280 <zmk_event_manager_raise>
        return 0;
   2969a:	2000      	movs	r0, #0
    }

    return 0;
}
   2969c:	b004      	add	sp, #16
   2969e:	bd10      	pop	{r4, pc}
    zmk_keymap_layers_state_t old_state = _zmk_keymap_layer_state;
   296a0:	4b05      	ldr	r3, [pc, #20]	; (296b8 <set_layer_state+0x6c>)
   296a2:	681a      	ldr	r2, [r3, #0]
    WRITE_BIT(_zmk_keymap_layer_state, layer, state);
   296a4:	2900      	cmp	r1, #0
   296a6:	d1d8      	bne.n	2965a <set_layer_state+0xe>
   296a8:	2301      	movs	r3, #1
   296aa:	4083      	lsls	r3, r0
   296ac:	ea22 0303 	bic.w	r3, r2, r3
   296b0:	e7d6      	b.n	29660 <set_layer_state+0x14>
        return -EINVAL;
   296b2:	f06f 0015 	mvn.w	r0, #21
   296b6:	e7f1      	b.n	2969c <set_layer_state+0x50>
   296b8:	20003890 	.word	0x20003890

000296bc <zmk_keymap_layer_active>:
    // breaks up that assumption by accident
    return (state_to_test & (BIT(layer))) == (BIT(layer)) || layer == _zmk_keymap_layer_default;
};

bool zmk_keymap_layer_active(uint8_t layer) {
    return zmk_keymap_layer_active_with_state(layer, _zmk_keymap_layer_state);
   296bc:	4b01      	ldr	r3, [pc, #4]	; (296c4 <zmk_keymap_layer_active+0x8>)
   296be:	6819      	ldr	r1, [r3, #0]
   296c0:	f01e bf9b 	b.w	485fa <zmk_keymap_layer_active_with_state>
   296c4:	20003890 	.word	0x20003890

000296c8 <zmk_keymap_apply_position_state>:
        return behavior_keymap_binding_released(binding, event);
    }
}

int zmk_keymap_apply_position_state(uint8_t source, int layer, uint32_t position, bool pressed,
                                    int64_t timestamp) {
   296c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   296cc:	4615      	mov	r5, r2
    // We want to make a copy of this, since it may be converted from
    // relative to absolute before being invoked
    struct zmk_behavior_binding binding = zmk_keymap[layer][position];
   296ce:	f44f 7234 	mov.w	r2, #720	; 0x2d0
                                    int64_t timestamp) {
   296d2:	461f      	mov	r7, r3
    struct zmk_behavior_binding binding = zmk_keymap[layer][position];
   296d4:	434a      	muls	r2, r1
   296d6:	230c      	movs	r3, #12
   296d8:	fb03 2205 	mla	r2, r3, r5, r2
   296dc:	4b39      	ldr	r3, [pc, #228]	; (297c4 <zmk_keymap_apply_position_state+0xfc>)
   296de:	4413      	add	r3, r2
                                    int64_t timestamp) {
   296e0:	4682      	mov	sl, r0
   296e2:	460e      	mov	r6, r1
    struct zmk_behavior_binding binding = zmk_keymap[layer][position];
   296e4:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
                                    int64_t timestamp) {
   296e8:	b08d      	sub	sp, #52	; 0x34
    struct zmk_behavior_binding binding = zmk_keymap[layer][position];
   296ea:	ac05      	add	r4, sp, #20
   296ec:	e884 0007 	stmia.w	r4, {r0, r1, r2}
                                    int64_t timestamp) {
   296f0:	e9dd 8916 	ldrd	r8, r9, [sp, #88]	; 0x58
   296f4:	f01d f98a 	bl	46a0c <z_impl_device_get_binding>

    LOG_DBG("layer: %d position: %d, binding name: %s", layer, position, binding.behavior_dev);

    behavior = device_get_binding(binding.behavior_dev);

    if (!behavior) {
   296f8:	4683      	mov	fp, r0
   296fa:	2800      	cmp	r0, #0
   296fc:	d05d      	beq.n	297ba <zmk_keymap_apply_position_state+0xf2>
	return z_impl_behavior_keymap_binding_convert_central_state_dependent_params(binding, event);
   296fe:	e9cd 6508 	strd	r6, r5, [sp, #32]
   29702:	e9cd 890a 	strd	r8, r9, [sp, #40]	; 0x28
    const struct device *dev = device_get_binding(binding->behavior_dev);
   29706:	9805      	ldr	r0, [sp, #20]
   29708:	f01d f980 	bl	46a0c <z_impl_device_get_binding>
    if (api->binding_convert_central_state_dependent_params == NULL) {
   2970c:	6883      	ldr	r3, [r0, #8]
   2970e:	685b      	ldr	r3, [r3, #4]
   29710:	469c      	mov	ip, r3
   29712:	b153      	cbz	r3, 2972a <zmk_keymap_apply_position_state+0x62>
    return api->binding_convert_central_state_dependent_params(binding, event);
   29714:	ab0c      	add	r3, sp, #48	; 0x30
   29716:	e913 0003 	ldmdb	r3, {r0, r1}
   2971a:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
   2971e:	e88d 0003 	stmia.w	sp, {r0, r1}
   29722:	4620      	mov	r0, r4
   29724:	4661      	mov	r1, ip
   29726:	4788      	blx	r1
        LOG_WRN("No behavior assigned to %d on layer %d", position, layer);
        return 1;
    }

    int err = behavior_keymap_binding_convert_central_state_dependent_params(&binding, event);
    if (err) {
   29728:	bb58      	cbnz	r0, 29782 <zmk_keymap_apply_position_state+0xba>
    *locality = api->locality;
   2972a:	f8db 3008 	ldr.w	r3, [fp, #8]
   2972e:	781b      	ldrb	r3, [r3, #0]
    if (err) {
        LOG_ERR("Failed to get behavior locality %d", err);
        return err;
    }

    switch (locality) {
   29730:	2b01      	cmp	r3, #1
   29732:	d013      	beq.n	2975c <zmk_keymap_apply_position_state+0x94>
   29734:	2b02      	cmp	r3, #2
   29736:	d027      	beq.n	29788 <zmk_keymap_apply_position_state+0xc0>
   29738:	2b00      	cmp	r3, #0
   2973a:	d140      	bne.n	297be <zmk_keymap_apply_position_state+0xf6>
    case BEHAVIOR_LOCALITY_CENTRAL:
        return invoke_locally(&binding, event, pressed);
   2973c:	e9cd 6508 	strd	r6, r5, [sp, #32]
   29740:	e9cd 890a 	strd	r8, r9, [sp, #40]	; 0x28
   29744:	ab0c      	add	r3, sp, #48	; 0x30
   29746:	9702      	str	r7, [sp, #8]
   29748:	e913 0003 	ldmdb	r3, {r0, r1}
   2974c:	e88d 0003 	stmia.w	sp, {r0, r1}
   29750:	462b      	mov	r3, r5
   29752:	4632      	mov	r2, r6
#if ZMK_BLE_IS_CENTRAL
        for (int i = 0; i < ZMK_SPLIT_BLE_PERIPHERAL_COUNT; i++) {
            zmk_split_bt_invoke_behavior(i, &binding, event, pressed);
        }
#endif
        return invoke_locally(&binding, event, pressed);
   29754:	4620      	mov	r0, r4
   29756:	f01e ff60 	bl	4861a <invoke_locally>
   2975a:	e012      	b.n	29782 <zmk_keymap_apply_position_state+0xba>
            return invoke_locally(&binding, event, pressed);
   2975c:	e9cd 6508 	strd	r6, r5, [sp, #32]
   29760:	e9cd 890a 	strd	r8, r9, [sp, #40]	; 0x28
   29764:	9702      	str	r7, [sp, #8]
   29766:	aa0a      	add	r2, sp, #40	; 0x28
   29768:	e892 0003 	ldmia.w	r2, {r0, r1}
   2976c:	e88d 0003 	stmia.w	sp, {r0, r1}
   29770:	ab08      	add	r3, sp, #32
        if (source == ZMK_POSITION_STATE_CHANGE_SOURCE_LOCAL) {
   29772:	f1ba 0fff 	cmp.w	sl, #255	; 0xff
            return invoke_locally(&binding, event, pressed);
   29776:	cb0c      	ldmia	r3, {r2, r3}
        if (source == ZMK_POSITION_STATE_CHANGE_SOURCE_LOCAL) {
   29778:	d0ec      	beq.n	29754 <zmk_keymap_apply_position_state+0x8c>
            return zmk_split_bt_invoke_behavior(source, &binding, event, pressed);
   2977a:	4621      	mov	r1, r4
   2977c:	4650      	mov	r0, sl
   2977e:	f01f f87e 	bl	4887e <zmk_split_bt_invoke_behavior>
    }

    return -ENOTSUP;
}
   29782:	b00d      	add	sp, #52	; 0x34
   29784:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            zmk_split_bt_invoke_behavior(i, &binding, event, pressed);
   29788:	e9cd 6508 	strd	r6, r5, [sp, #32]
   2978c:	e9cd 890a 	strd	r8, r9, [sp, #40]	; 0x28
   29790:	9702      	str	r7, [sp, #8]
   29792:	ae0a      	add	r6, sp, #40	; 0x28
   29794:	e896 0003 	ldmia.w	r6, {r0, r1}
   29798:	e88d 0003 	stmia.w	sp, {r0, r1}
   2979c:	ad08      	add	r5, sp, #32
   2979e:	e895 000c 	ldmia.w	r5, {r2, r3}
   297a2:	4621      	mov	r1, r4
   297a4:	2000      	movs	r0, #0
   297a6:	f01f f86a 	bl	4887e <zmk_split_bt_invoke_behavior>
        return invoke_locally(&binding, event, pressed);
   297aa:	9702      	str	r7, [sp, #8]
   297ac:	e896 0003 	ldmia.w	r6, {r0, r1}
   297b0:	e88d 0003 	stmia.w	sp, {r0, r1}
   297b4:	e895 000c 	ldmia.w	r5, {r2, r3}
   297b8:	e7cc      	b.n	29754 <zmk_keymap_apply_position_state+0x8c>
        return 1;
   297ba:	2001      	movs	r0, #1
   297bc:	e7e1      	b.n	29782 <zmk_keymap_apply_position_state+0xba>
    switch (locality) {
   297be:	f06f 0085 	mvn.w	r0, #133	; 0x85
   297c2:	e7de      	b.n	29782 <zmk_keymap_apply_position_state+0xba>
   297c4:	00051044 	.word	0x00051044

000297c8 <zmk_keymap_position_state_changed>:

int zmk_keymap_position_state_changed(uint8_t source, uint32_t position, bool pressed,
                                      int64_t timestamp) {
   297c8:	e92d 4ef3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
   297cc:	e9dd ab0a 	ldrd	sl, fp, [sp, #40]	; 0x28
   297d0:	4d10      	ldr	r5, [pc, #64]	; (29814 <zmk_keymap_position_state_changed+0x4c>)
   297d2:	4681      	mov	r9, r0
   297d4:	460f      	mov	r7, r1
    if (pressed) {
   297d6:	4614      	mov	r4, r2
   297d8:	b11a      	cbz	r2, 297e2 <zmk_keymap_position_state_changed+0x1a>
        zmk_keymap_active_behavior_layer[position] = _zmk_keymap_layer_state;
   297da:	4b0f      	ldr	r3, [pc, #60]	; (29818 <zmk_keymap_position_state_changed+0x50>)
   297dc:	681b      	ldr	r3, [r3, #0]
   297de:	f845 3021 	str.w	r3, [r5, r1, lsl #2]
                                      int64_t timestamp) {
   297e2:	2602      	movs	r6, #2
    }
    for (int layer = ZMK_KEYMAP_LAYERS_LEN - 1; layer >= _zmk_keymap_layer_default; layer--) {
        if (zmk_keymap_layer_active_with_state(layer, zmk_keymap_active_behavior_layer[position])) {
   297e4:	f855 1027 	ldr.w	r1, [r5, r7, lsl #2]
   297e8:	b2f0      	uxtb	r0, r6
   297ea:	f01e ff06 	bl	485fa <zmk_keymap_layer_active_with_state>
   297ee:	b930      	cbnz	r0, 297fe <zmk_keymap_position_state_changed+0x36>
    for (int layer = ZMK_KEYMAP_LAYERS_LEN - 1; layer >= _zmk_keymap_layer_default; layer--) {
   297f0:	3e01      	subs	r6, #1
   297f2:	d2f7      	bcs.n	297e4 <zmk_keymap_position_state_changed+0x1c>
                return ret;
            }
        }
    }

    return -ENOTSUP;
   297f4:	f06f 0085 	mvn.w	r0, #133	; 0x85
}
   297f8:	b002      	add	sp, #8
   297fa:	e8bd 8ef0 	ldmia.w	sp!, {r4, r5, r6, r7, r9, sl, fp, pc}
            int ret = zmk_keymap_apply_position_state(source, layer, position, pressed, timestamp);
   297fe:	e9cd ab00 	strd	sl, fp, [sp]
   29802:	4623      	mov	r3, r4
   29804:	463a      	mov	r2, r7
   29806:	4631      	mov	r1, r6
   29808:	4648      	mov	r0, r9
   2980a:	f7ff ff5d 	bl	296c8 <zmk_keymap_apply_position_state>
            if (ret > 0) {
   2980e:	2800      	cmp	r0, #0
   29810:	ddf2      	ble.n	297f8 <zmk_keymap_position_state_changed+0x30>
   29812:	e7ed      	b.n	297f0 <zmk_keymap_position_state_changed+0x28>
   29814:	200037a0 	.word	0x200037a0
   29818:	20003890 	.word	0x20003890

0002981c <zmk_keymap_sensor_event>:

#if ZMK_KEYMAP_HAS_SENSORS
int zmk_keymap_sensor_event(uint8_t sensor_index,
                            const struct zmk_sensor_channel_data *channel_data,
                            size_t channel_data_size, int64_t timestamp) {
   2981c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   29820:	4c3d      	ldr	r4, [pc, #244]	; (29918 <zmk_keymap_sensor_event+0xfc>)
   29822:	b08f      	sub	sp, #60	; 0x3c
   29824:	eb00 0340 	add.w	r3, r0, r0, lsl #1
   29828:	e9cd 1207 	strd	r1, r2, [sp, #28]
   2982c:	eb04 0483 	add.w	r4, r4, r3, lsl #2
            continue;
        }

        struct zmk_behavior_binding_event event = {
            .layer = layer,
            .position = ZMK_VIRTUAL_KEY_POSITION_SENSOR(sensor_index),
   29830:	f100 033c 	add.w	r3, r0, #60	; 0x3c
                            size_t channel_data_size, int64_t timestamp) {
   29834:	4606      	mov	r6, r0
    for (int layer = ZMK_KEYMAP_LAYERS_LEN - 1; layer >= 0; layer--) {
   29836:	2502      	movs	r5, #2
    bool opaque_response = false;
   29838:	f04f 0900 	mov.w	r9, #0
            .position = ZMK_VIRTUAL_KEY_POSITION_SENSOR(sensor_index),
   2983c:	9306      	str	r3, [sp, #24]

    if (api->sensor_binding_accept_data == NULL) {
        return -ENOTSUP;
    }

    return api->sensor_binding_accept_data(binding, event, sensor_config, channel_data_size,
   2983e:	af0c      	add	r7, sp, #48	; 0x30
        const struct device *behavior = device_get_binding(binding->behavior_dev);
   29840:	6b20      	ldr	r0, [r4, #48]	; 0x30
   29842:	f01d f8e3 	bl	46a0c <z_impl_device_get_binding>
        if (!behavior) {
   29846:	2800      	cmp	r0, #0
   29848:	d05b      	beq.n	29902 <zmk_keymap_sensor_event+0xe6>
            .timestamp = timestamp,
        };

        int ret = behavior_sensor_keymap_binding_accept_data(
   2984a:	4630      	mov	r0, r6
   2984c:	f7ff fae8 	bl	28e20 <zmk_sensors_get_config_at_index>
   29850:	4680      	mov	r8, r0
		union { uintptr_t x; const struct zmk_sensor_channel_data * val; } parm4 = { .val = channel_data };
		return (int) arch_syscall_invoke5(parm0.x, parm1.x, parm2.x, parm3.x, parm4.x, K_SYSCALL_BEHAVIOR_SENSOR_KEYMAP_BINDING_ACCEPT_DATA);
	}
#endif
	compiler_barrier();
	return z_impl_behavior_sensor_keymap_binding_accept_data(binding, event, sensor_config, channel_data_size, channel_data);
   29852:	9b06      	ldr	r3, [sp, #24]
   29854:	930b      	str	r3, [sp, #44]	; 0x2c
   29856:	e9dd 2318 	ldrd	r2, r3, [sp, #96]	; 0x60
    const struct device *dev = device_get_binding(binding->behavior_dev);
   2985a:	6b20      	ldr	r0, [r4, #48]	; 0x30
   2985c:	950a      	str	r5, [sp, #40]	; 0x28
   2985e:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
   29862:	f01d f8d3 	bl	46a0c <z_impl_device_get_binding>
    if (dev == NULL) {
   29866:	2800      	cmp	r0, #0
   29868:	d04b      	beq.n	29902 <zmk_keymap_sensor_event+0xe6>
    if (api->sensor_binding_accept_data == NULL) {
   2986a:	6883      	ldr	r3, [r0, #8]
   2986c:	f8d3 a010 	ldr.w	sl, [r3, #16]
   29870:	f1ba 0f00 	cmp.w	sl, #0
   29874:	d045      	beq.n	29902 <zmk_keymap_sensor_event+0xe6>
    return api->sensor_binding_accept_data(binding, event, sensor_config, channel_data_size,
   29876:	9b07      	ldr	r3, [sp, #28]
   29878:	9304      	str	r3, [sp, #16]
   2987a:	9b08      	ldr	r3, [sp, #32]
   2987c:	e9cd 8302 	strd	r8, r3, [sp, #8]
   29880:	e897 0003 	ldmia.w	r7, {r0, r1}
   29884:	e88d 0003 	stmia.w	sp, {r0, r1}
        struct zmk_behavior_binding *binding = &zmk_sensor_keymap[layer][sensor_index];
   29888:	f104 0b30 	add.w	fp, r4, #48	; 0x30
   2988c:	f10d 0828 	add.w	r8, sp, #40	; 0x28
   29890:	e898 000c 	ldmia.w	r8, {r2, r3}
   29894:	4658      	mov	r0, fp
   29896:	47d0      	blx	sl
            binding, event, zmk_sensors_get_config_at_index(sensor_index), channel_data_size,
            channel_data);

        if (ret < 0) {
   29898:	2800      	cmp	r0, #0
   2989a:	db32      	blt.n	29902 <zmk_keymap_sensor_event+0xe6>

        enum behavior_sensor_binding_process_mode mode =
            (!opaque_response && layer >= _zmk_keymap_layer_default &&
             zmk_keymap_layer_active(layer))
                ? BEHAVIOR_SENSOR_BINDING_PROCESS_MODE_TRIGGER
                : BEHAVIOR_SENSOR_BINDING_PROCESS_MODE_DISCARD;
   2989c:	f1b9 0f00 	cmp.w	r9, #0
   298a0:	d118      	bne.n	298d4 <zmk_keymap_sensor_event+0xb8>
             zmk_keymap_layer_active(layer))
   298a2:	b2e8      	uxtb	r0, r5
   298a4:	f7ff ff0a 	bl	296bc <zmk_keymap_layer_active>
                : BEHAVIOR_SENSOR_BINDING_PROCESS_MODE_DISCARD;
   298a8:	f080 0001 	eor.w	r0, r0, #1
   298ac:	b2c0      	uxtb	r0, r0
        enum behavior_sensor_binding_process_mode mode =
   298ae:	b2c3      	uxtb	r3, r0
   298b0:	9309      	str	r3, [sp, #36]	; 0x24
		union { uintptr_t x; enum behavior_sensor_binding_process_mode val; } parm2 = { .val = mode };
		return (int) arch_syscall_invoke3(parm0.x, parm1.x, parm2.x, K_SYSCALL_BEHAVIOR_SENSOR_KEYMAP_BINDING_PROCESS);
	}
#endif
	compiler_barrier();
	return z_impl_behavior_sensor_keymap_binding_process(binding, event, mode);
   298b2:	9b06      	ldr	r3, [sp, #24]
   298b4:	930b      	str	r3, [sp, #44]	; 0x2c
   298b6:	e9dd 2318 	ldrd	r2, r3, [sp, #96]	; 0x60

static inline int
z_impl_behavior_sensor_keymap_binding_process(struct zmk_behavior_binding *binding,
                                              struct zmk_behavior_binding_event event,
                                              enum behavior_sensor_binding_process_mode mode) {
    const struct device *dev = device_get_binding(binding->behavior_dev);
   298ba:	6b20      	ldr	r0, [r4, #48]	; 0x30
   298bc:	950a      	str	r5, [sp, #40]	; 0x28
   298be:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
   298c2:	f01d f8a3 	bl	46a0c <z_impl_device_get_binding>

    if (dev == NULL) {
   298c6:	9b09      	ldr	r3, [sp, #36]	; 0x24
   298c8:	b930      	cbnz	r0, 298d8 <zmk_keymap_sensor_event+0xbc>
   298ca:	f06f 0015 	mvn.w	r0, #21
            return ret;
        }
    }

    return 0;
}
   298ce:	b00f      	add	sp, #60	; 0x3c
   298d0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                : BEHAVIOR_SENSOR_BINDING_PROCESS_MODE_DISCARD;
   298d4:	2001      	movs	r0, #1
   298d6:	e7ea      	b.n	298ae <zmk_keymap_sensor_event+0x92>
        return -EINVAL;
    }

    const struct behavior_driver_api *api = (const struct behavior_driver_api *)dev->api;

    if (api->sensor_binding_process == NULL) {
   298d8:	6882      	ldr	r2, [r0, #8]
   298da:	f8d2 a014 	ldr.w	sl, [r2, #20]
   298de:	f1ba 0f00 	cmp.w	sl, #0
   298e2:	d102      	bne.n	298ea <zmk_keymap_sensor_event+0xce>
   298e4:	f06f 0085 	mvn.w	r0, #133	; 0x85
   298e8:	e7f1      	b.n	298ce <zmk_keymap_sensor_event+0xb2>
        return -ENOTSUP;
    }

    return api->sensor_binding_process(binding, event, mode);
   298ea:	9302      	str	r3, [sp, #8]
   298ec:	e897 0003 	ldmia.w	r7, {r0, r1}
   298f0:	e88d 0003 	stmia.w	sp, {r0, r1}
   298f4:	4658      	mov	r0, fp
   298f6:	e898 000c 	ldmia.w	r8, {r2, r3}
   298fa:	47d0      	blx	sl
        if (ret == ZMK_BEHAVIOR_OPAQUE) {
   298fc:	2800      	cmp	r0, #0
   298fe:	d007      	beq.n	29910 <zmk_keymap_sensor_event+0xf4>
        } else if (ret < 0) {
   29900:	dbe5      	blt.n	298ce <zmk_keymap_sensor_event+0xb2>
    for (int layer = ZMK_KEYMAP_LAYERS_LEN - 1; layer >= 0; layer--) {
   29902:	3d01      	subs	r5, #1
   29904:	1c6b      	adds	r3, r5, #1
   29906:	f1a4 0418 	sub.w	r4, r4, #24
   2990a:	d199      	bne.n	29840 <zmk_keymap_sensor_event+0x24>
    return 0;
   2990c:	2000      	movs	r0, #0
   2990e:	e7de      	b.n	298ce <zmk_keymap_sensor_event+0xb2>
            opaque_response = true;
   29910:	f04f 0901 	mov.w	r9, #1
   29914:	e7f5      	b.n	29902 <zmk_keymap_sensor_event+0xe6>
   29916:	bf00      	nop
   29918:	20000328 	.word	0x20000328

0002991c <new_zmk_layer_state_changed>:
 */

#include <zephyr/kernel.h>
#include <zmk/events/layer_state_changed.h>

   2991c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
   2991e:	466c      	mov	r4, sp
   29920:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
   29924:	2018      	movs	r0, #24
   29926:	f026 fecd 	bl	506c4 <k_malloc>
   2992a:	4605      	mov	r5, r0
   2992c:	4b05      	ldr	r3, [pc, #20]	; (29944 <new_zmk_layer_state_changed+0x28>)
   2992e:	f845 3b08 	str.w	r3, [r5], #8
   29932:	4606      	mov	r6, r0
   29934:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
   29938:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
   2993c:	4630      	mov	r0, r6
   2993e:	b004      	add	sp, #16
   29940:	bd70      	pop	{r4, r5, r6, pc}
   29942:	bf00      	nop
   29944:	000518b4 	.word	0x000518b4

00029948 <new_zmk_keycode_state_changed>:
 */

#include <zephyr/kernel.h>
#include <zmk/events/keycode_state_changed.h>

ZMK_EVENT_IMPL(zmk_keycode_state_changed);
   29948:	b084      	sub	sp, #16
   2994a:	b570      	push	{r4, r5, r6, lr}
   2994c:	ac04      	add	r4, sp, #16
   2994e:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
   29952:	2020      	movs	r0, #32
   29954:	f026 feb6 	bl	506c4 <k_malloc>
   29958:	4604      	mov	r4, r0
   2995a:	4b08      	ldr	r3, [pc, #32]	; (2997c <new_zmk_keycode_state_changed+0x34>)
   2995c:	f844 3b08 	str.w	r3, [r4], #8
   29960:	ad04      	add	r5, sp, #16
   29962:	4606      	mov	r6, r0
   29964:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   29966:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   29968:	e895 0003 	ldmia.w	r5, {r0, r1}
   2996c:	e884 0003 	stmia.w	r4, {r0, r1}
   29970:	4630      	mov	r0, r6
   29972:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   29976:	b004      	add	sp, #16
   29978:	4770      	bx	lr
   2997a:	bf00      	nop
   2997c:	000518bc 	.word	0x000518bc

00029980 <as_zmk_keycode_state_changed>:
   29980:	6802      	ldr	r2, [r0, #0]
   29982:	4b03      	ldr	r3, [pc, #12]	; (29990 <as_zmk_keycode_state_changed+0x10>)
   29984:	429a      	cmp	r2, r3
   29986:	bf0c      	ite	eq
   29988:	3008      	addeq	r0, #8
   2998a:	2000      	movne	r0, #0
   2998c:	4770      	bx	lr
   2998e:	bf00      	nop
   29990:	000518bc 	.word	0x000518bc

00029994 <new_zmk_ble_active_profile_changed>:
 */

#include <zephyr/kernel.h>
#include <zmk/events/ble_active_profile_changed.h>

   29994:	b513      	push	{r0, r1, r4, lr}
   29996:	466c      	mov	r4, sp
   29998:	e884 0003 	stmia.w	r4, {r0, r1}
   2999c:	2010      	movs	r0, #16
   2999e:	f026 fe91 	bl	506c4 <k_malloc>
   299a2:	4602      	mov	r2, r0
   299a4:	4905      	ldr	r1, [pc, #20]	; (299bc <new_zmk_ble_active_profile_changed+0x28>)
   299a6:	f842 1b08 	str.w	r1, [r2], #8
   299aa:	4603      	mov	r3, r0
   299ac:	e894 0003 	ldmia.w	r4, {r0, r1}
   299b0:	e882 0003 	stmia.w	r2, {r0, r1}
   299b4:	4618      	mov	r0, r3
   299b6:	b002      	add	sp, #8
   299b8:	bd10      	pop	{r4, pc}
   299ba:	bf00      	nop
   299bc:	000518c0 	.word	0x000518c0

000299c0 <raise_profile_changed_event>:

static bt_addr_le_t peripheral_addrs[ZMK_SPLIT_BLE_PERIPHERAL_COUNT];

#endif /* IS_ENABLED(CONFIG_ZMK_SPLIT_ROLE_CENTRAL) */

static void raise_profile_changed_event() {
   299c0:	b507      	push	{r0, r1, r2, lr}
    ZMK_EVENT_RAISE(new_zmk_ble_active_profile_changed((struct zmk_ble_active_profile_changed){
   299c2:	4b09      	ldr	r3, [pc, #36]	; (299e8 <raise_profile_changed_event+0x28>)
   299c4:	781a      	ldrb	r2, [r3, #0]
   299c6:	4b09      	ldr	r3, [pc, #36]	; (299ec <raise_profile_changed_event+0x2c>)
   299c8:	f88d 2000 	strb.w	r2, [sp]
   299cc:	2116      	movs	r1, #22
   299ce:	fb02 3301 	mla	r3, r2, r1, r3
   299d2:	9301      	str	r3, [sp, #4]
   299d4:	ab02      	add	r3, sp, #8
   299d6:	e913 0003 	ldmdb	r3, {r0, r1}
   299da:	f7ff ffdb 	bl	29994 <new_zmk_ble_active_profile_changed>
        .index = active_profile, .profile = &profiles[active_profile]}));
}
   299de:	b003      	add	sp, #12
   299e0:	f85d eb04 	ldr.w	lr, [sp], #4
    ZMK_EVENT_RAISE(new_zmk_ble_active_profile_changed((struct zmk_ble_active_profile_changed){
   299e4:	f01e bc4c 	b.w	48280 <zmk_event_manager_raise>
   299e8:	20006a80 	.word	0x20006a80
   299ec:	20006a81 	.word	0x20006a81

000299f0 <ble_save_profile_work>:

int zmk_ble_active_profile_index() { return active_profile; }

#if IS_ENABLED(CONFIG_SETTINGS)
static void ble_save_profile_work(struct k_work *work) {
    settings_save_one("ble/active_profile", &active_profile, sizeof(active_profile));
   299f0:	4902      	ldr	r1, [pc, #8]	; (299fc <ble_save_profile_work+0xc>)
   299f2:	4803      	ldr	r0, [pc, #12]	; (29a00 <ble_save_profile_work+0x10>)
   299f4:	2201      	movs	r2, #1
   299f6:	f002 bd51 	b.w	2c49c <settings_save_one>
   299fa:	bf00      	nop
   299fc:	20006a80 	.word	0x20006a80
   29a00:	000531c0 	.word	0x000531c0

00029a04 <bt_addr_le_to_str.constprop.0.isra.0>:
 *  @param len Length of data to be copied to user string buffer. Refer to
 *  BT_ADDR_LE_STR_LEN about recommended value.
 *
 *  @return Number of successfully formatted bytes from binary address.
 */
static inline int bt_addr_le_to_str(const bt_addr_le_t *addr, char *str,
   29a04:	b570      	push	{r4, r5, r6, lr}
				    size_t len)
{
	char type[10];

	switch (addr->type) {
   29a06:	7803      	ldrb	r3, [r0, #0]
static inline int bt_addr_le_to_str(const bt_addr_le_t *addr, char *str,
   29a08:	b08a      	sub	sp, #40	; 0x28
   29a0a:	4604      	mov	r4, r0
   29a0c:	460e      	mov	r6, r1
   29a0e:	ad07      	add	r5, sp, #28
	switch (addr->type) {
   29a10:	2b03      	cmp	r3, #3
   29a12:	d820      	bhi.n	29a56 <bt_addr_le_to_str.constprop.0.isra.0+0x52>
   29a14:	e8df f003 	tbb	[pc, r3]
   29a18:	1d1b1902 	.word	0x1d1b1902
	case BT_ADDR_LE_PUBLIC:
		strcpy(type, "public");
   29a1c:	4911      	ldr	r1, [pc, #68]	; (29a64 <bt_addr_le_to_str.constprop.0.isra.0+0x60>)
		break;
	case BT_ADDR_LE_RANDOM:
		strcpy(type, "random");
   29a1e:	4628      	mov	r0, r5
   29a20:	f021 f9ea 	bl	4adf8 <strcpy>
	default:
		snprintk(type, sizeof(type), "0x%02x", addr->type);
		break;
	}

	return snprintk(str, len, "%02X:%02X:%02X:%02X:%02X:%02X (%s)",
   29a24:	9505      	str	r5, [sp, #20]
   29a26:	7863      	ldrb	r3, [r4, #1]
   29a28:	9304      	str	r3, [sp, #16]
   29a2a:	78a3      	ldrb	r3, [r4, #2]
   29a2c:	9303      	str	r3, [sp, #12]
   29a2e:	78e3      	ldrb	r3, [r4, #3]
   29a30:	9302      	str	r3, [sp, #8]
   29a32:	7923      	ldrb	r3, [r4, #4]
   29a34:	9301      	str	r3, [sp, #4]
   29a36:	7963      	ldrb	r3, [r4, #5]
   29a38:	9300      	str	r3, [sp, #0]
   29a3a:	79a3      	ldrb	r3, [r4, #6]
   29a3c:	4a0a      	ldr	r2, [pc, #40]	; (29a68 <bt_addr_le_to_str.constprop.0.isra.0+0x64>)
   29a3e:	211e      	movs	r1, #30
   29a40:	4630      	mov	r0, r6
   29a42:	f01f f82c 	bl	48a9e <snprintk>
			addr->a.val[5], addr->a.val[4], addr->a.val[3],
			addr->a.val[2], addr->a.val[1], addr->a.val[0], type);
}
   29a46:	b00a      	add	sp, #40	; 0x28
   29a48:	bd70      	pop	{r4, r5, r6, pc}
		strcpy(type, "random");
   29a4a:	4908      	ldr	r1, [pc, #32]	; (29a6c <bt_addr_le_to_str.constprop.0.isra.0+0x68>)
   29a4c:	e7e7      	b.n	29a1e <bt_addr_le_to_str.constprop.0.isra.0+0x1a>
		strcpy(type, "public-id");
   29a4e:	4908      	ldr	r1, [pc, #32]	; (29a70 <bt_addr_le_to_str.constprop.0.isra.0+0x6c>)
   29a50:	e7e5      	b.n	29a1e <bt_addr_le_to_str.constprop.0.isra.0+0x1a>
		strcpy(type, "random-id");
   29a52:	4908      	ldr	r1, [pc, #32]	; (29a74 <bt_addr_le_to_str.constprop.0.isra.0+0x70>)
   29a54:	e7e3      	b.n	29a1e <bt_addr_le_to_str.constprop.0.isra.0+0x1a>
		snprintk(type, sizeof(type), "0x%02x", addr->type);
   29a56:	4a08      	ldr	r2, [pc, #32]	; (29a78 <bt_addr_le_to_str.constprop.0.isra.0+0x74>)
   29a58:	210a      	movs	r1, #10
   29a5a:	4628      	mov	r0, r5
   29a5c:	f01f f81f 	bl	48a9e <snprintk>
		break;
   29a60:	e7e0      	b.n	29a24 <bt_addr_le_to_str.constprop.0.isra.0+0x20>
   29a62:	bf00      	nop
   29a64:	000531d3 	.word	0x000531d3
   29a68:	000531fc 	.word	0x000531fc
   29a6c:	000531da 	.word	0x000531da
   29a70:	000531e1 	.word	0x000531e1
   29a74:	000531eb 	.word	0x000531eb
   29a78:	000531f5 	.word	0x000531f5

00029a7c <ble_profiles_handle_set>:
#endif /* IS_ENABLED(CONFIG_ZMK_SPLIT_ROLE_CENTRAL) */

#if IS_ENABLED(CONFIG_SETTINGS)

static int ble_profiles_handle_set(const char *name, size_t len, settings_read_cb read_cb,
                                   void *cb_arg) {
   29a7c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   29a80:	b08a      	sub	sp, #40	; 0x28
   29a82:	460d      	mov	r5, r1
   29a84:	4616      	mov	r6, r2
    const char *next;

    LOG_DBG("Setting BLE value %s", name);

    if (settings_name_steq(name, "profiles", &next) && next) {
   29a86:	4928      	ldr	r1, [pc, #160]	; (29b28 <ble_profiles_handle_set+0xac>)
   29a88:	466a      	mov	r2, sp
                                   void *cb_arg) {
   29a8a:	4604      	mov	r4, r0
   29a8c:	461f      	mov	r7, r3
    if (settings_name_steq(name, "profiles", &next) && next) {
   29a8e:	f01f fe44 	bl	4971a <settings_name_steq>
   29a92:	b1f8      	cbz	r0, 29ad4 <ble_profiles_handle_set+0x58>
   29a94:	9800      	ldr	r0, [sp, #0]
   29a96:	b1e8      	cbz	r0, 29ad4 <ble_profiles_handle_set+0x58>
        char *endptr;
        uint8_t idx = strtoul(next, &endptr, 10);
   29a98:	220a      	movs	r2, #10
   29a9a:	a901      	add	r1, sp, #4
   29a9c:	f021 f8a4 	bl	4abe8 <strtoul>
        if (*endptr != '\0') {
   29aa0:	9b01      	ldr	r3, [sp, #4]
   29aa2:	781b      	ldrb	r3, [r3, #0]
   29aa4:	bb03      	cbnz	r3, 29ae8 <ble_profiles_handle_set+0x6c>
            LOG_WRN("Invalid profile index: %s", next);
            return -EINVAL;
        }

        if (len != sizeof(struct zmk_ble_profile)) {
   29aa6:	2d16      	cmp	r5, #22
   29aa8:	d11e      	bne.n	29ae8 <ble_profiles_handle_set+0x6c>
            LOG_ERR("Invalid profile size (got %d expected %d)", len,
                    sizeof(struct zmk_ble_profile));
            return -EINVAL;
        }

        if (idx >= ZMK_BLE_PROFILE_COUNT) {
   29aaa:	b2c4      	uxtb	r4, r0
   29aac:	2c04      	cmp	r4, #4
   29aae:	d81b      	bhi.n	29ae8 <ble_profiles_handle_set+0x6c>
            LOG_WRN("Profile address for index %d is larger than max of %d", idx,
                    ZMK_BLE_PROFILE_COUNT);
            return -EINVAL;
        }

        int err = read_cb(cb_arg, &profiles[idx], sizeof(struct zmk_ble_profile));
   29ab0:	f8df 8078 	ldr.w	r8, [pc, #120]	; 29b2c <ble_profiles_handle_set+0xb0>
   29ab4:	436c      	muls	r4, r5
   29ab6:	462a      	mov	r2, r5
   29ab8:	eb08 0104 	add.w	r1, r8, r4
   29abc:	4638      	mov	r0, r7
   29abe:	47b0      	blx	r6
        if (err <= 0) {
   29ac0:	2800      	cmp	r0, #0
   29ac2:	dd13      	ble.n	29aec <ble_profiles_handle_set+0x70>
            LOG_ERR("Failed to handle profile address from settings (err %d)", err);
            return err;
        }

        char addr_str[BT_ADDR_LE_STR_LEN];
        bt_addr_le_to_str(&profiles[idx].peer, addr_str, sizeof(addr_str));
   29ac4:	f104 000f 	add.w	r0, r4, #15
   29ac8:	a902      	add	r1, sp, #8
   29aca:	4440      	add	r0, r8
   29acc:	f7ff ff9a 	bl	29a04 <bt_addr_le_to_str.constprop.0.isra.0>
            }
        }
    }
#endif

    return 0;
   29ad0:	2000      	movs	r0, #0
   29ad2:	e00b      	b.n	29aec <ble_profiles_handle_set+0x70>
    } else if (settings_name_steq(name, "active_profile", &next) && !next) {
   29ad4:	4916      	ldr	r1, [pc, #88]	; (29b30 <ble_profiles_handle_set+0xb4>)
   29ad6:	466a      	mov	r2, sp
   29ad8:	4620      	mov	r0, r4
   29ada:	f01f fe1e 	bl	4971a <settings_name_steq>
   29ade:	b178      	cbz	r0, 29b00 <ble_profiles_handle_set+0x84>
   29ae0:	9b00      	ldr	r3, [sp, #0]
   29ae2:	b96b      	cbnz	r3, 29b00 <ble_profiles_handle_set+0x84>
        if (len != sizeof(active_profile)) {
   29ae4:	2d01      	cmp	r5, #1
   29ae6:	d004      	beq.n	29af2 <ble_profiles_handle_set+0x76>
            return -EINVAL;
   29ae8:	f06f 0015 	mvn.w	r0, #21
};
   29aec:	b00a      	add	sp, #40	; 0x28
   29aee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        int err = read_cb(cb_arg, &active_profile, sizeof(active_profile));
   29af2:	4910      	ldr	r1, [pc, #64]	; (29b34 <ble_profiles_handle_set+0xb8>)
   29af4:	462a      	mov	r2, r5
            int err = read_cb(cb_arg, &peripheral_addrs[i], sizeof(bt_addr_le_t));
   29af6:	4638      	mov	r0, r7
   29af8:	47b0      	blx	r6
            if (err <= 0) {
   29afa:	ea00 70e0 	and.w	r0, r0, r0, asr #31
   29afe:	e7f5      	b.n	29aec <ble_profiles_handle_set+0x70>
    else if (settings_name_steq(name, "peripheral_addresses", &next) && next) {
   29b00:	490d      	ldr	r1, [pc, #52]	; (29b38 <ble_profiles_handle_set+0xbc>)
   29b02:	466a      	mov	r2, sp
   29b04:	4620      	mov	r0, r4
   29b06:	f01f fe08 	bl	4971a <settings_name_steq>
   29b0a:	2800      	cmp	r0, #0
   29b0c:	d0e0      	beq.n	29ad0 <ble_profiles_handle_set+0x54>
   29b0e:	9800      	ldr	r0, [sp, #0]
   29b10:	2800      	cmp	r0, #0
   29b12:	d0dd      	beq.n	29ad0 <ble_profiles_handle_set+0x54>
        if (len != sizeof(bt_addr_le_t)) {
   29b14:	2d07      	cmp	r5, #7
   29b16:	d1e7      	bne.n	29ae8 <ble_profiles_handle_set+0x6c>
        int i = atoi(next);
   29b18:	f021 f843 	bl	4aba2 <atoi>
        if (i < 0 || i >= ZMK_SPLIT_BLE_PERIPHERAL_COUNT) {
   29b1c:	2800      	cmp	r0, #0
   29b1e:	d1d7      	bne.n	29ad0 <ble_profiles_handle_set+0x54>
            int err = read_cb(cb_arg, &peripheral_addrs[i], sizeof(bt_addr_le_t));
   29b20:	4906      	ldr	r1, [pc, #24]	; (29b3c <ble_profiles_handle_set+0xc0>)
   29b22:	462a      	mov	r2, r5
   29b24:	e7e7      	b.n	29af6 <ble_profiles_handle_set+0x7a>
   29b26:	bf00      	nop
   29b28:	0005321f 	.word	0x0005321f
   29b2c:	20006a81 	.word	0x20006a81
   29b30:	000531c4 	.word	0x000531c4
   29b34:	20006a80 	.word	0x20006a80
   29b38:	00053228 	.word	0x00053228
   29b3c:	20006a79 	.word	0x20006a79

00029b40 <disconnected>:
        LOG_DBG("Active profile connected");
        k_work_submit(&raise_profile_changed_event_work);
    }
}

static void disconnected(struct bt_conn *conn, uint8_t reason) {
   29b40:	b510      	push	{r4, lr}
   29b42:	b092      	sub	sp, #72	; 0x48
   29b44:	4604      	mov	r4, r0
    char addr[BT_ADDR_LE_STR_LEN];
    struct bt_conn_info info;

    bt_addr_le_to_str(bt_conn_get_dst(conn), addr, sizeof(addr));
   29b46:	f022 fa17 	bl	4bf78 <bt_conn_get_dst>
   29b4a:	a901      	add	r1, sp, #4
   29b4c:	f7ff ff5a 	bl	29a04 <bt_addr_le_to_str.constprop.0.isra.0>

    LOG_DBG("Disconnected from %s (reason 0x%02x)", addr, reason);

    bt_conn_get_info(conn, &info);
   29b50:	a909      	add	r1, sp, #36	; 0x24
   29b52:	4620      	mov	r0, r4
   29b54:	f006 fb5c 	bl	30210 <bt_conn_get_info>

    if (info.role != BT_CONN_ROLE_PERIPHERAL) {
   29b58:	f89d 3025 	ldrb.w	r3, [sp, #37]	; 0x25
   29b5c:	2b01      	cmp	r3, #1
   29b5e:	d114      	bne.n	29b8a <disconnected+0x4a>
        return;
    }

    // We need to do this in a work callback, otherwise the advertising update will still see the
    // connection for a profile as active, and not start advertising yet.
    k_work_submit(&update_advertising_work);
   29b60:	480b      	ldr	r0, [pc, #44]	; (29b90 <disconnected+0x50>)
   29b62:	f01d fca7 	bl	474b4 <k_work_submit>
    return bt_addr_le_cmp(bt_conn_get_dst(conn), &profiles[active_profile].peer) == 0;
   29b66:	4620      	mov	r0, r4
   29b68:	f022 fa06 	bl	4bf78 <bt_conn_get_dst>
   29b6c:	4b09      	ldr	r3, [pc, #36]	; (29b94 <disconnected+0x54>)
   29b6e:	7819      	ldrb	r1, [r3, #0]
   29b70:	220f      	movs	r2, #15
   29b72:	2316      	movs	r3, #22
   29b74:	fb13 2301 	smlabb	r3, r3, r1, r2
	return memcmp(a, b, sizeof(*a));
   29b78:	4907      	ldr	r1, [pc, #28]	; (29b98 <disconnected+0x58>)
   29b7a:	2207      	movs	r2, #7
   29b7c:	4419      	add	r1, r3
   29b7e:	f021 f96c 	bl	4ae5a <memcmp>

    if (is_conn_active_profile(conn)) {
   29b82:	b910      	cbnz	r0, 29b8a <disconnected+0x4a>
        LOG_DBG("Active profile disconnected");
        k_work_submit(&raise_profile_changed_event_work);
   29b84:	4805      	ldr	r0, [pc, #20]	; (29b9c <disconnected+0x5c>)
   29b86:	f01d fc95 	bl	474b4 <k_work_submit>
    }
}
   29b8a:	b012      	add	sp, #72	; 0x48
   29b8c:	bd10      	pop	{r4, pc}
   29b8e:	bf00      	nop
   29b90:	200003d4 	.word	0x200003d4
   29b94:	20006a80 	.word	0x20006a80
   29b98:	20006a81 	.word	0x20006a81
   29b9c:	200003e4 	.word	0x200003e4

00029ba0 <zmk_ble_active_profile_is_open>:
bool zmk_ble_active_profile_is_open() {
   29ba0:	b508      	push	{r3, lr}
    return !bt_addr_le_cmp(&profiles[active_profile].peer, BT_ADDR_LE_ANY);
   29ba2:	4b08      	ldr	r3, [pc, #32]	; (29bc4 <zmk_ble_active_profile_is_open+0x24>)
   29ba4:	4808      	ldr	r0, [pc, #32]	; (29bc8 <zmk_ble_active_profile_is_open+0x28>)
   29ba6:	7819      	ldrb	r1, [r3, #0]
   29ba8:	220f      	movs	r2, #15
   29baa:	2316      	movs	r3, #22
   29bac:	fb13 2301 	smlabb	r3, r3, r1, r2
   29bb0:	4418      	add	r0, r3
   29bb2:	4906      	ldr	r1, [pc, #24]	; (29bcc <zmk_ble_active_profile_is_open+0x2c>)
   29bb4:	2207      	movs	r2, #7
   29bb6:	f021 f950 	bl	4ae5a <memcmp>
}
   29bba:	fab0 f080 	clz	r0, r0
   29bbe:	0940      	lsrs	r0, r0, #5
   29bc0:	bd08      	pop	{r3, pc}
   29bc2:	bf00      	nop
   29bc4:	20006a80 	.word	0x20006a80
   29bc8:	20006a81 	.word	0x20006a81
   29bcc:	00053517 	.word	0x00053517

00029bd0 <set_profile_address>:
void set_profile_address(uint8_t index, const bt_addr_le_t *addr) {
   29bd0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   29bd4:	4604      	mov	r4, r0
   29bd6:	b08c      	sub	sp, #48	; 0x30
   29bd8:	460d      	mov	r5, r1
   29bda:	f04f 0816 	mov.w	r8, #22
    memcpy(&profiles[index].peer, addr, sizeof(bt_addr_le_t));
   29bde:	4f0f      	ldr	r7, [pc, #60]	; (29c1c <set_profile_address+0x4c>)
    bt_addr_le_to_str(addr, addr_str, sizeof(addr_str));
   29be0:	a904      	add	r1, sp, #16
   29be2:	4628      	mov	r0, r5
   29be4:	fb14 f608 	smulbb	r6, r4, r8
   29be8:	f7ff ff0c 	bl	29a04 <bt_addr_le_to_str.constprop.0.isra.0>
    memcpy(&profiles[index].peer, addr, sizeof(bt_addr_le_t));
   29bec:	f106 000f 	add.w	r0, r6, #15
   29bf0:	4629      	mov	r1, r5
   29bf2:	2207      	movs	r2, #7
   29bf4:	4438      	add	r0, r7
   29bf6:	f021 f940 	bl	4ae7a <memcpy>
    sprintf(setting_name, "ble/profiles/%d", index);
   29bfa:	4622      	mov	r2, r4
   29bfc:	4908      	ldr	r1, [pc, #32]	; (29c20 <set_profile_address+0x50>)
   29bfe:	4668      	mov	r0, sp
   29c00:	f003 fbe0 	bl	2d3c4 <sprintf>
    settings_save_one(setting_name, &profiles[index], sizeof(struct zmk_ble_profile));
   29c04:	4642      	mov	r2, r8
   29c06:	19b9      	adds	r1, r7, r6
   29c08:	4668      	mov	r0, sp
   29c0a:	f002 fc47 	bl	2c49c <settings_save_one>
    k_work_submit(&raise_profile_changed_event_work);
   29c0e:	4805      	ldr	r0, [pc, #20]	; (29c24 <set_profile_address+0x54>)
   29c10:	f01d fc50 	bl	474b4 <k_work_submit>
}
   29c14:	b00c      	add	sp, #48	; 0x30
   29c16:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   29c1a:	bf00      	nop
   29c1c:	20006a81 	.word	0x20006a81
   29c20:	0005323d 	.word	0x0005323d
   29c24:	200003e4 	.word	0x200003e4

00029c28 <zmk_ble_active_profile_is_connected>:
bool zmk_ble_active_profile_is_connected() {
   29c28:	b510      	push	{r4, lr}
bt_addr_le_t *zmk_ble_active_profile_addr() { return &profiles[active_profile].peer; }
   29c2a:	4b12      	ldr	r3, [pc, #72]	; (29c74 <zmk_ble_active_profile_is_connected+0x4c>)
   29c2c:	4912      	ldr	r1, [pc, #72]	; (29c78 <zmk_ble_active_profile_is_connected+0x50>)
   29c2e:	781a      	ldrb	r2, [r3, #0]
   29c30:	2416      	movs	r4, #22
   29c32:	230f      	movs	r3, #15
   29c34:	fb14 3402 	smlabb	r4, r4, r2, r3
   29c38:	4b10      	ldr	r3, [pc, #64]	; (29c7c <zmk_ble_active_profile_is_connected+0x54>)
   29c3a:	441c      	add	r4, r3
bool zmk_ble_active_profile_is_connected() {
   29c3c:	b08a      	sub	sp, #40	; 0x28
   29c3e:	2207      	movs	r2, #7
   29c40:	4620      	mov	r0, r4
   29c42:	f021 f90a 	bl	4ae5a <memcmp>
    if (!bt_addr_le_cmp(addr, BT_ADDR_LE_ANY)) {
   29c46:	b910      	cbnz	r0, 29c4e <zmk_ble_active_profile_is_connected+0x26>
        return false;
   29c48:	2000      	movs	r0, #0
}
   29c4a:	b00a      	add	sp, #40	; 0x28
   29c4c:	bd10      	pop	{r4, pc}
    } else if ((conn = bt_conn_lookup_addr_le(BT_ID_DEFAULT, addr)) == NULL) {
   29c4e:	4621      	mov	r1, r4
   29c50:	2000      	movs	r0, #0
   29c52:	f006 fa8b 	bl	3016c <bt_conn_lookup_addr_le>
   29c56:	4604      	mov	r4, r0
   29c58:	2800      	cmp	r0, #0
   29c5a:	d0f5      	beq.n	29c48 <zmk_ble_active_profile_is_connected+0x20>
    bt_conn_get_info(conn, &info);
   29c5c:	a901      	add	r1, sp, #4
   29c5e:	f006 fad7 	bl	30210 <bt_conn_get_info>
    bt_conn_unref(conn);
   29c62:	4620      	mov	r0, r4
   29c64:	f022 f8af 	bl	4bdc6 <bt_conn_unref>
    return info.state == BT_CONN_STATE_CONNECTED;
   29c68:	f89d 0024 	ldrb.w	r0, [sp, #36]	; 0x24
   29c6c:	1e83      	subs	r3, r0, #2
   29c6e:	4258      	negs	r0, r3
   29c70:	4158      	adcs	r0, r3
   29c72:	e7ea      	b.n	29c4a <zmk_ble_active_profile_is_connected+0x22>
   29c74:	20006a80 	.word	0x20006a80
   29c78:	00053517 	.word	0x00053517
   29c7c:	20006a81 	.word	0x20006a81

00029c80 <update_advertising>:
int update_advertising() {
   29c80:	b5f0      	push	{r4, r5, r6, r7, lr}
   29c82:	b08d      	sub	sp, #52	; 0x34
    if (zmk_ble_active_profile_is_open()) {
   29c84:	f7ff ff8c 	bl	29ba0 <zmk_ble_active_profile_is_open>
   29c88:	b998      	cbnz	r0, 29cb2 <update_advertising+0x32>
    } else if (!zmk_ble_active_profile_is_connected()) {
   29c8a:	f7ff ffcd 	bl	29c28 <zmk_ble_active_profile_is_connected>
   29c8e:	f080 0301 	eor.w	r3, r0, #1
   29c92:	005b      	lsls	r3, r3, #1
   29c94:	b2db      	uxtb	r3, r3
    switch (desired_adv + CURR_ADV(advertising_status)) {
   29c96:	4d21      	ldr	r5, [pc, #132]	; (29d1c <update_advertising+0x9c>)
   29c98:	782a      	ldrb	r2, [r5, #0]
   29c9a:	eb03 1302 	add.w	r3, r3, r2, lsl #4
   29c9e:	2b11      	cmp	r3, #17
   29ca0:	dc09      	bgt.n	29cb6 <update_advertising+0x36>
   29ca2:	2b02      	cmp	r3, #2
   29ca4:	d02d      	beq.n	29d02 <update_advertising+0x82>
   29ca6:	2b10      	cmp	r3, #16
   29ca8:	d023      	beq.n	29cf2 <update_advertising+0x72>
        desired_adv = ZMK_ADV_CONN;
   29caa:	2400      	movs	r4, #0
};
   29cac:	4620      	mov	r0, r4
   29cae:	b00d      	add	sp, #52	; 0x34
   29cb0:	bdf0      	pop	{r4, r5, r6, r7, pc}
        desired_adv = ZMK_ADV_CONN;
   29cb2:	2302      	movs	r3, #2
   29cb4:	e7ef      	b.n	29c96 <update_advertising+0x16>
    switch (desired_adv + CURR_ADV(advertising_status)) {
   29cb6:	2b20      	cmp	r3, #32
   29cb8:	d01b      	beq.n	29cf2 <update_advertising+0x72>
   29cba:	2b12      	cmp	r3, #18
   29cbc:	d1f5      	bne.n	29caa <update_advertising+0x2a>
        CHECKED_ADV_STOP();
   29cbe:	f005 faad 	bl	2f21c <bt_le_adv_stop>
   29cc2:	2300      	movs	r3, #0
   29cc4:	702b      	strb	r3, [r5, #0]
   29cc6:	4604      	mov	r4, r0
   29cc8:	2800      	cmp	r0, #0
   29cca:	d1ef      	bne.n	29cac <update_advertising+0x2c>
        CHECKED_OPEN_ADV();
   29ccc:	4f14      	ldr	r7, [pc, #80]	; (29d20 <update_advertising+0xa0>)
   29cce:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
   29cd0:	ae02      	add	r6, sp, #8
   29cd2:	c60f      	stmia	r6!, {r0, r1, r2, r3}
   29cd4:	683b      	ldr	r3, [r7, #0]
   29cd6:	4913      	ldr	r1, [pc, #76]	; (29d24 <update_advertising+0xa4>)
   29cd8:	6033      	str	r3, [r6, #0]
   29cda:	2204      	movs	r2, #4
   29cdc:	9400      	str	r4, [sp, #0]
   29cde:	4623      	mov	r3, r4
   29ce0:	a802      	add	r0, sp, #8
   29ce2:	f005 fa69 	bl	2f1b8 <bt_le_adv_start>
   29ce6:	4604      	mov	r4, r0
   29ce8:	2800      	cmp	r0, #0
   29cea:	d1df      	bne.n	29cac <update_advertising+0x2c>
   29cec:	2302      	movs	r3, #2
   29cee:	702b      	strb	r3, [r5, #0]
        break;
   29cf0:	e7db      	b.n	29caa <update_advertising+0x2a>
        CHECKED_ADV_STOP();
   29cf2:	f005 fa93 	bl	2f21c <bt_le_adv_stop>
   29cf6:	2300      	movs	r3, #0
   29cf8:	702b      	strb	r3, [r5, #0]
   29cfa:	4604      	mov	r4, r0
   29cfc:	2800      	cmp	r0, #0
   29cfe:	d0d4      	beq.n	29caa <update_advertising+0x2a>
   29d00:	e7d4      	b.n	29cac <update_advertising+0x2c>
        CHECKED_OPEN_ADV();
   29d02:	4e07      	ldr	r6, [pc, #28]	; (29d20 <update_advertising+0xa0>)
   29d04:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
   29d06:	ac07      	add	r4, sp, #28
   29d08:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   29d0a:	6833      	ldr	r3, [r6, #0]
   29d0c:	6023      	str	r3, [r4, #0]
   29d0e:	2300      	movs	r3, #0
   29d10:	4904      	ldr	r1, [pc, #16]	; (29d24 <update_advertising+0xa4>)
   29d12:	9300      	str	r3, [sp, #0]
   29d14:	2204      	movs	r2, #4
   29d16:	a807      	add	r0, sp, #28
   29d18:	e7e3      	b.n	29ce2 <update_advertising+0x62>
   29d1a:	bf00      	nop
   29d1c:	20006aef 	.word	0x20006aef
   29d20:	00050d20 	.word	0x00050d20
   29d24:	000518dc 	.word	0x000518dc

00029d28 <auth_pairing_complete>:
    }

    return BT_SECURITY_ERR_SUCCESS;
};

static void auth_pairing_complete(struct bt_conn *conn, bool bonded) {
   29d28:	b530      	push	{r4, r5, lr}
   29d2a:	b093      	sub	sp, #76	; 0x4c
   29d2c:	4605      	mov	r5, r0
    struct bt_conn_info info;
    char addr[BT_ADDR_LE_STR_LEN];
    const bt_addr_le_t *dst = bt_conn_get_dst(conn);
   29d2e:	f022 f923 	bl	4bf78 <bt_conn_get_dst>

    bt_addr_le_to_str(dst, addr, sizeof(addr));
   29d32:	a901      	add	r1, sp, #4
    const bt_addr_le_t *dst = bt_conn_get_dst(conn);
   29d34:	4604      	mov	r4, r0
    bt_addr_le_to_str(dst, addr, sizeof(addr));
   29d36:	f7ff fe65 	bl	29a04 <bt_addr_le_to_str.constprop.0.isra.0>
    bt_conn_get_info(conn, &info);
   29d3a:	a909      	add	r1, sp, #36	; 0x24
   29d3c:	4628      	mov	r0, r5
   29d3e:	f006 fa67 	bl	30210 <bt_conn_get_info>

    if (info.role != BT_CONN_ROLE_PERIPHERAL) {
   29d42:	f89d 3025 	ldrb.w	r3, [sp, #37]	; 0x25
   29d46:	2b01      	cmp	r3, #1
   29d48:	d105      	bne.n	29d56 <auth_pairing_complete+0x2e>
        LOG_DBG("SKIPPING FOR ROLE %d", info.role);
        return;
    }

    if (!zmk_ble_active_profile_is_open()) {
   29d4a:	f7ff ff29 	bl	29ba0 <zmk_ble_active_profile_is_open>
        LOG_ERR("Pairing completed but current profile is not open: %s", addr);
        bt_unpair(BT_ID_DEFAULT, dst);
   29d4e:	4621      	mov	r1, r4
    if (!zmk_ble_active_profile_is_open()) {
   29d50:	b918      	cbnz	r0, 29d5a <auth_pairing_complete+0x32>
        bt_unpair(BT_ID_DEFAULT, dst);
   29d52:	f004 fb81 	bl	2e458 <bt_unpair>
        return;
    }

    set_profile_address(active_profile, dst);
    update_advertising();
};
   29d56:	b013      	add	sp, #76	; 0x4c
   29d58:	bd30      	pop	{r4, r5, pc}
    set_profile_address(active_profile, dst);
   29d5a:	4b03      	ldr	r3, [pc, #12]	; (29d68 <auth_pairing_complete+0x40>)
   29d5c:	7818      	ldrb	r0, [r3, #0]
   29d5e:	f7ff ff37 	bl	29bd0 <set_profile_address>
    update_advertising();
   29d62:	f7ff ff8d 	bl	29c80 <update_advertising>
   29d66:	e7f6      	b.n	29d56 <auth_pairing_complete+0x2e>
   29d68:	20006a80 	.word	0x20006a80

00029d6c <connected>:
static void connected(struct bt_conn *conn, uint8_t err) {
   29d6c:	b530      	push	{r4, r5, lr}
   29d6e:	b093      	sub	sp, #76	; 0x4c
   29d70:	460d      	mov	r5, r1
    bt_conn_get_info(conn, &info);
   29d72:	a909      	add	r1, sp, #36	; 0x24
static void connected(struct bt_conn *conn, uint8_t err) {
   29d74:	4604      	mov	r4, r0
    bt_conn_get_info(conn, &info);
   29d76:	f006 fa4b 	bl	30210 <bt_conn_get_info>
    if (info.role != BT_CONN_ROLE_PERIPHERAL) {
   29d7a:	f89d 3025 	ldrb.w	r3, [sp, #37]	; 0x25
   29d7e:	2b01      	cmp	r3, #1
   29d80:	d10b      	bne.n	29d9a <connected+0x2e>
    bt_addr_le_to_str(bt_conn_get_dst(conn), addr, sizeof(addr));
   29d82:	4620      	mov	r0, r4
   29d84:	f022 f8f8 	bl	4bf78 <bt_conn_get_dst>
   29d88:	a901      	add	r1, sp, #4
   29d8a:	f7ff fe3b 	bl	29a04 <bt_addr_le_to_str.constprop.0.isra.0>
    advertising_status = ZMK_ADV_NONE;
   29d8e:	4b11      	ldr	r3, [pc, #68]	; (29dd4 <connected+0x68>)
   29d90:	2200      	movs	r2, #0
   29d92:	701a      	strb	r2, [r3, #0]
    if (err) {
   29d94:	b11d      	cbz	r5, 29d9e <connected+0x32>
        update_advertising();
   29d96:	f7ff ff73 	bl	29c80 <update_advertising>
}
   29d9a:	b013      	add	sp, #76	; 0x4c
   29d9c:	bd30      	pop	{r4, r5, pc}
    if (bt_conn_set_security(conn, BT_SECURITY_L2)) {
   29d9e:	2102      	movs	r1, #2
   29da0:	4620      	mov	r0, r4
   29da2:	f022 f897 	bl	4bed4 <bt_conn_set_security>
    update_advertising();
   29da6:	f7ff ff6b 	bl	29c80 <update_advertising>
    return bt_addr_le_cmp(bt_conn_get_dst(conn), &profiles[active_profile].peer) == 0;
   29daa:	4620      	mov	r0, r4
   29dac:	f022 f8e4 	bl	4bf78 <bt_conn_get_dst>
   29db0:	4b09      	ldr	r3, [pc, #36]	; (29dd8 <connected+0x6c>)
   29db2:	7819      	ldrb	r1, [r3, #0]
   29db4:	220f      	movs	r2, #15
   29db6:	2316      	movs	r3, #22
   29db8:	fb13 2301 	smlabb	r3, r3, r1, r2
   29dbc:	4907      	ldr	r1, [pc, #28]	; (29ddc <connected+0x70>)
   29dbe:	2207      	movs	r2, #7
   29dc0:	4419      	add	r1, r3
   29dc2:	f021 f84a 	bl	4ae5a <memcmp>
    if (is_conn_active_profile(conn)) {
   29dc6:	2800      	cmp	r0, #0
   29dc8:	d1e7      	bne.n	29d9a <connected+0x2e>
        k_work_submit(&raise_profile_changed_event_work);
   29dca:	4805      	ldr	r0, [pc, #20]	; (29de0 <connected+0x74>)
   29dcc:	f01d fb72 	bl	474b4 <k_work_submit>
   29dd0:	e7e3      	b.n	29d9a <connected+0x2e>
   29dd2:	bf00      	nop
   29dd4:	20006aef 	.word	0x20006aef
   29dd8:	20006a80 	.word	0x20006a80
   29ddc:	20006a81 	.word	0x20006a81
   29de0:	200003e4 	.word	0x200003e4

00029de4 <zmk_ble_init>:
    }

    update_advertising();
}

static int zmk_ble_init(const struct device *_arg) {
   29de4:	b510      	push	{r4, lr}
    int err = bt_enable(NULL);
   29de6:	2000      	movs	r0, #0
   29de8:	f004 fc78 	bl	2e6dc <bt_enable>

    if (err) {
   29dec:	4604      	mov	r4, r0
   29dee:	b9d8      	cbnz	r0, 29e28 <zmk_ble_init+0x44>
        LOG_ERR("BLUETOOTH FAILED (%d)", err);
        return err;
    }

#if IS_ENABLED(CONFIG_SETTINGS)
    settings_subsys_init();
   29df0:	f002 fca8 	bl	2c744 <settings_subsys_init>

    err = settings_register(&profiles_handler);
   29df4:	480d      	ldr	r0, [pc, #52]	; (29e2c <zmk_ble_init+0x48>)
   29df6:	f002 fbe1 	bl	2c5bc <settings_register>
    if (err) {
   29dfa:	4604      	mov	r4, r0
   29dfc:	b9a0      	cbnz	r0, 29e28 <zmk_ble_init+0x44>
        LOG_ERR("Failed to setup the profile settings handler (err %d)", err);
        return err;
    }

    k_work_init_delayable(&ble_save_work, ble_save_profile_work);
   29dfe:	490c      	ldr	r1, [pc, #48]	; (29e30 <zmk_ble_init+0x4c>)
   29e00:	480c      	ldr	r0, [pc, #48]	; (29e34 <zmk_ble_init+0x50>)
   29e02:	f026 f8ff 	bl	50004 <k_work_init_delayable>

    settings_load_subtree("ble");
   29e06:	480c      	ldr	r0, [pc, #48]	; (29e38 <zmk_ble_init+0x54>)
   29e08:	f002 fb82 	bl	2c510 <settings_load_subtree>
    settings_load_subtree("bt");
   29e0c:	480b      	ldr	r0, [pc, #44]	; (29e3c <zmk_ble_init+0x58>)
   29e0e:	f002 fb7f 	bl	2c510 <settings_load_subtree>
        }
    }

#endif // IS_ENABLED(CONFIG_ZMK_BLE_CLEAR_BONDS_ON_START)

    bt_conn_cb_register(&conn_callbacks);
   29e12:	480b      	ldr	r0, [pc, #44]	; (29e40 <zmk_ble_init+0x5c>)
   29e14:	f006 f986 	bl	30124 <bt_conn_cb_register>
    bt_conn_auth_cb_register(&zmk_ble_auth_cb_display);
   29e18:	480a      	ldr	r0, [pc, #40]	; (29e44 <zmk_ble_init+0x60>)
   29e1a:	f006 fc83 	bl	30724 <bt_conn_auth_cb_register>
    bt_conn_auth_info_cb_register(&zmk_ble_auth_info_cb_display);
   29e1e:	480a      	ldr	r0, [pc, #40]	; (29e48 <zmk_ble_init+0x64>)
   29e20:	f006 fc9a 	bl	30758 <bt_conn_auth_info_cb_register>
    update_advertising();
   29e24:	f7ff ff2c 	bl	29c80 <update_advertising>

    zmk_ble_ready(0);

    return 0;
}
   29e28:	4620      	mov	r0, r4
   29e2a:	bd10      	pop	{r4, pc}
   29e2c:	200003bc 	.word	0x200003bc
   29e30:	000299f1 	.word	0x000299f1
   29e34:	200014f8 	.word	0x200014f8
   29e38:	0005324d 	.word	0x0005324d
   29e3c:	00053251 	.word	0x00053251
   29e40:	2000039c 	.word	0x2000039c
   29e44:	20000380 	.word	0x20000380
   29e48:	20000370 	.word	0x20000370

00029e4c <zmk_ble_clear_bonds>:
int zmk_ble_clear_bonds() {
   29e4c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if (bt_addr_le_cmp(&profiles[active_profile].peer, BT_ADDR_LE_ANY)) {
   29e4e:	4d0e      	ldr	r5, [pc, #56]	; (29e88 <zmk_ble_clear_bonds+0x3c>)
   29e50:	4e0e      	ldr	r6, [pc, #56]	; (29e8c <zmk_ble_clear_bonds+0x40>)
   29e52:	7828      	ldrb	r0, [r5, #0]
   29e54:	490e      	ldr	r1, [pc, #56]	; (29e90 <zmk_ble_clear_bonds+0x44>)
   29e56:	2416      	movs	r4, #22
   29e58:	270f      	movs	r7, #15
   29e5a:	fb14 7000 	smlabb	r0, r4, r0, r7
   29e5e:	2207      	movs	r2, #7
   29e60:	4430      	add	r0, r6
   29e62:	f020 fffa 	bl	4ae5a <memcmp>
   29e66:	b150      	cbz	r0, 29e7e <zmk_ble_clear_bonds+0x32>
        bt_unpair(BT_ID_DEFAULT, &profiles[active_profile].peer);
   29e68:	782b      	ldrb	r3, [r5, #0]
   29e6a:	fb14 7103 	smlabb	r1, r4, r3, r7
   29e6e:	4431      	add	r1, r6
   29e70:	2000      	movs	r0, #0
   29e72:	f004 faf1 	bl	2e458 <bt_unpair>
        set_profile_address(active_profile, BT_ADDR_LE_ANY);
   29e76:	4906      	ldr	r1, [pc, #24]	; (29e90 <zmk_ble_clear_bonds+0x44>)
   29e78:	7828      	ldrb	r0, [r5, #0]
   29e7a:	f7ff fea9 	bl	29bd0 <set_profile_address>
    update_advertising();
   29e7e:	f7ff feff 	bl	29c80 <update_advertising>
};
   29e82:	2000      	movs	r0, #0
   29e84:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   29e86:	bf00      	nop
   29e88:	20006a80 	.word	0x20006a80
   29e8c:	20006a81 	.word	0x20006a81
   29e90:	00053517 	.word	0x00053517

00029e94 <zmk_ble_prof_select>:
    if (index >= ZMK_BLE_PROFILE_COUNT) {
   29e94:	2804      	cmp	r0, #4
int zmk_ble_prof_select(uint8_t index) {
   29e96:	b508      	push	{r3, lr}
    if (index >= ZMK_BLE_PROFILE_COUNT) {
   29e98:	d810      	bhi.n	29ebc <zmk_ble_prof_select+0x28>
    if (active_profile == index) {
   29e9a:	4b0a      	ldr	r3, [pc, #40]	; (29ec4 <zmk_ble_prof_select+0x30>)
   29e9c:	781a      	ldrb	r2, [r3, #0]
   29e9e:	4282      	cmp	r2, r0
   29ea0:	d00a      	beq.n	29eb8 <zmk_ble_prof_select+0x24>
    active_profile = index;
   29ea2:	7018      	strb	r0, [r3, #0]
    return k_work_reschedule(&ble_save_work, K_MSEC(CONFIG_ZMK_SETTINGS_SAVE_DEBOUNCE));
   29ea4:	f44f 12f0 	mov.w	r2, #1966080	; 0x1e0000
   29ea8:	2300      	movs	r3, #0
   29eaa:	4807      	ldr	r0, [pc, #28]	; (29ec8 <zmk_ble_prof_select+0x34>)
   29eac:	f01d fb9e 	bl	475ec <k_work_reschedule>
    update_advertising();
   29eb0:	f7ff fee6 	bl	29c80 <update_advertising>
    raise_profile_changed_event();
   29eb4:	f7ff fd84 	bl	299c0 <raise_profile_changed_event>
        return 0;
   29eb8:	2000      	movs	r0, #0
};
   29eba:	bd08      	pop	{r3, pc}
        return -ERANGE;
   29ebc:	f06f 0021 	mvn.w	r0, #33	; 0x21
   29ec0:	e7fb      	b.n	29eba <zmk_ble_prof_select+0x26>
   29ec2:	bf00      	nop
   29ec4:	20006a80 	.word	0x20006a80
   29ec8:	200014f8 	.word	0x200014f8

00029ecc <zmk_ble_prof_next>:
    return zmk_ble_prof_select((active_profile + 1) % ZMK_BLE_PROFILE_COUNT);
   29ecc:	4b05      	ldr	r3, [pc, #20]	; (29ee4 <zmk_ble_prof_next+0x18>)
   29ece:	7818      	ldrb	r0, [r3, #0]
   29ed0:	2305      	movs	r3, #5
   29ed2:	3001      	adds	r0, #1
   29ed4:	fbb0 f3f3 	udiv	r3, r0, r3
   29ed8:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   29edc:	1ac0      	subs	r0, r0, r3
   29ede:	b2c0      	uxtb	r0, r0
   29ee0:	f7ff bfd8 	b.w	29e94 <zmk_ble_prof_select>
   29ee4:	20006a80 	.word	0x20006a80

00029ee8 <zmk_ble_prof_prev>:
    return zmk_ble_prof_select((active_profile + ZMK_BLE_PROFILE_COUNT - 1) %
   29ee8:	4b05      	ldr	r3, [pc, #20]	; (29f00 <zmk_ble_prof_prev+0x18>)
   29eea:	7818      	ldrb	r0, [r3, #0]
   29eec:	2305      	movs	r3, #5
   29eee:	3004      	adds	r0, #4
   29ef0:	fbb0 f3f3 	udiv	r3, r0, r3
   29ef4:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   29ef8:	1ac0      	subs	r0, r0, r3
   29efa:	b2c0      	uxtb	r0, r0
   29efc:	f7ff bfca 	b.w	29e94 <zmk_ble_prof_select>
   29f00:	20006a80 	.word	0x20006a80

00029f04 <zmk_ble_active_profile_addr>:
bt_addr_le_t *zmk_ble_active_profile_addr() { return &profiles[active_profile].peer; }
   29f04:	4b04      	ldr	r3, [pc, #16]	; (29f18 <zmk_ble_active_profile_addr+0x14>)
   29f06:	4805      	ldr	r0, [pc, #20]	; (29f1c <zmk_ble_active_profile_addr+0x18>)
   29f08:	7819      	ldrb	r1, [r3, #0]
   29f0a:	220f      	movs	r2, #15
   29f0c:	2316      	movs	r3, #22
   29f0e:	fb13 2301 	smlabb	r3, r3, r1, r2
   29f12:	4418      	add	r0, r3
   29f14:	4770      	bx	lr
   29f16:	bf00      	nop
   29f18:	20006a80 	.word	0x20006a80
   29f1c:	20006a81 	.word	0x20006a81

00029f20 <zmk_ble_put_peripheral_addr>:
int zmk_ble_put_peripheral_addr(const bt_addr_le_t *addr) {
   29f20:	b530      	push	{r4, r5, lr}
   29f22:	4601      	mov	r1, r0
   29f24:	b091      	sub	sp, #68	; 0x44
   29f26:	4604      	mov	r4, r0
   29f28:	2207      	movs	r2, #7
   29f2a:	4814      	ldr	r0, [pc, #80]	; (29f7c <zmk_ble_put_peripheral_addr+0x5c>)
   29f2c:	f020 ff95 	bl	4ae5a <memcmp>
        if (bt_addr_le_cmp(&peripheral_addrs[i], addr) == 0) {
   29f30:	b1e8      	cbz	r0, 29f6e <zmk_ble_put_peripheral_addr+0x4e>
            bt_addr_le_to_str(&peripheral_addrs[i], addr_str, sizeof(addr_str));
   29f32:	4812      	ldr	r0, [pc, #72]	; (29f7c <zmk_ble_put_peripheral_addr+0x5c>)
   29f34:	a908      	add	r1, sp, #32
   29f36:	f7ff fd65 	bl	29a04 <bt_addr_le_to_str.constprop.0.isra.0>
   29f3a:	4911      	ldr	r1, [pc, #68]	; (29f80 <zmk_ble_put_peripheral_addr+0x60>)
   29f3c:	480f      	ldr	r0, [pc, #60]	; (29f7c <zmk_ble_put_peripheral_addr+0x5c>)
   29f3e:	2207      	movs	r2, #7
   29f40:	f020 ff8b 	bl	4ae5a <memcmp>
        if (bt_addr_le_cmp(&peripheral_addrs[i], BT_ADDR_LE_ANY) == 0) {
   29f44:	4605      	mov	r5, r0
   29f46:	b9a8      	cbnz	r0, 29f74 <zmk_ble_put_peripheral_addr+0x54>
            bt_addr_le_to_str(addr, addr_str, sizeof(addr_str));
   29f48:	4669      	mov	r1, sp
   29f4a:	4620      	mov	r0, r4
   29f4c:	f7ff fd5a 	bl	29a04 <bt_addr_le_to_str.constprop.0.isra.0>
	memcpy(dst, src, sizeof(*dst));
   29f50:	2207      	movs	r2, #7
   29f52:	4621      	mov	r1, r4
   29f54:	4809      	ldr	r0, [pc, #36]	; (29f7c <zmk_ble_put_peripheral_addr+0x5c>)
   29f56:	f020 ff90 	bl	4ae7a <memcpy>
            sprintf(setting_name, "ble/peripheral_addresses/%d", i);
   29f5a:	490a      	ldr	r1, [pc, #40]	; (29f84 <zmk_ble_put_peripheral_addr+0x64>)
   29f5c:	462a      	mov	r2, r5
   29f5e:	a808      	add	r0, sp, #32
   29f60:	f003 fa30 	bl	2d3c4 <sprintf>
            settings_save_one(setting_name, addr, sizeof(bt_addr_le_t));
   29f64:	2207      	movs	r2, #7
   29f66:	4621      	mov	r1, r4
   29f68:	a808      	add	r0, sp, #32
   29f6a:	f002 fa97 	bl	2c49c <settings_save_one>
int zmk_ble_put_peripheral_addr(const bt_addr_le_t *addr) {
   29f6e:	2000      	movs	r0, #0
}
   29f70:	b011      	add	sp, #68	; 0x44
   29f72:	bd30      	pop	{r4, r5, pc}
    return -ENOMEM;
   29f74:	f06f 000b 	mvn.w	r0, #11
   29f78:	e7fa      	b.n	29f70 <zmk_ble_put_peripheral_addr+0x50>
   29f7a:	bf00      	nop
   29f7c:	20006a79 	.word	0x20006a79
   29f80:	00053517 	.word	0x00053517
   29f84:	00053254 	.word	0x00053254

00029f88 <read_hids_report_map>:
    return bt_gatt_attr_read(conn, attr, buf, len, offset, attr->user_data,
                             sizeof(struct hids_report));
}

static ssize_t read_hids_report_map(struct bt_conn *conn, const struct bt_gatt_attr *attr,
                                    void *buf, uint16_t len, uint16_t offset) {
   29f88:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    return bt_gatt_attr_read(conn, attr, buf, len, offset, zmk_hid_report_desc,
   29f8a:	244d      	movs	r4, #77	; 0x4d
   29f8c:	9402      	str	r4, [sp, #8]
   29f8e:	4c04      	ldr	r4, [pc, #16]	; (29fa0 <read_hids_report_map+0x18>)
   29f90:	9401      	str	r4, [sp, #4]
   29f92:	f8bd 4018 	ldrh.w	r4, [sp, #24]
   29f96:	9400      	str	r4, [sp, #0]
   29f98:	f023 fac0 	bl	4d51c <bt_gatt_attr_read>
                             sizeof(zmk_hid_report_desc));
}
   29f9c:	b004      	add	sp, #16
   29f9e:	bd10      	pop	{r4, pc}
   29fa0:	00053292 	.word	0x00053292

00029fa4 <zmk_hog_init>:
    k_work_submit_to_queue(&hog_work_q, &hog_consumer_work);

    return 0;
};

int zmk_hog_init(const struct device *_arg) {
   29fa4:	b507      	push	{r0, r1, r2, lr}
    static const struct k_work_queue_config queue_config = {.name = "HID Over GATT Send Work"};
    k_work_queue_start(&hog_work_q, hog_q_stack, K_THREAD_STACK_SIZEOF(hog_q_stack),
   29fa6:	4b06      	ldr	r3, [pc, #24]	; (29fc0 <zmk_hog_init+0x1c>)
   29fa8:	9300      	str	r3, [sp, #0]
   29faa:	4906      	ldr	r1, [pc, #24]	; (29fc4 <zmk_hog_init+0x20>)
   29fac:	4806      	ldr	r0, [pc, #24]	; (29fc8 <zmk_hog_init+0x24>)
   29fae:	2305      	movs	r3, #5
   29fb0:	f44f 7240 	mov.w	r2, #768	; 0x300
   29fb4:	f01d fa84 	bl	474c0 <k_work_queue_start>
                       CONFIG_ZMK_BLE_THREAD_PRIORITY, &queue_config);

    return 0;
}
   29fb8:	2000      	movs	r0, #0
   29fba:	b003      	add	sp, #12
   29fbc:	f85d fb04 	ldr.w	pc, [sp], #4
   29fc0:	000518fc 	.word	0x000518fc
   29fc4:	20006bc8 	.word	0x20006bc8
   29fc8:	20001528 	.word	0x20001528

00029fcc <destination_connection>:
struct bt_conn *destination_connection() {
   29fcc:	b510      	push	{r4, lr}
    bt_addr_le_t *addr = zmk_ble_active_profile_addr();
   29fce:	f7ff ff99 	bl	29f04 <zmk_ble_active_profile_addr>
	return memcmp(a, b, sizeof(*a));
   29fd2:	4906      	ldr	r1, [pc, #24]	; (29fec <destination_connection+0x20>)
   29fd4:	2207      	movs	r2, #7
   29fd6:	4604      	mov	r4, r0
   29fd8:	f020 ff3f 	bl	4ae5a <memcmp>
    if (!bt_addr_le_cmp(addr, BT_ADDR_LE_ANY)) {
   29fdc:	b128      	cbz	r0, 29fea <destination_connection+0x1e>
    } else if ((conn = bt_conn_lookup_addr_le(BT_ID_DEFAULT, addr)) == NULL) {
   29fde:	4621      	mov	r1, r4
   29fe0:	2000      	movs	r0, #0
}
   29fe2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    } else if ((conn = bt_conn_lookup_addr_le(BT_ID_DEFAULT, addr)) == NULL) {
   29fe6:	f006 b8c1 	b.w	3016c <bt_conn_lookup_addr_le>
}
   29fea:	bd10      	pop	{r4, pc}
   29fec:	00053517 	.word	0x00053517

00029ff0 <send_keyboard_report_callback>:
void send_keyboard_report_callback(struct k_work *work) {
   29ff0:	b5f0      	push	{r4, r5, r6, r7, lr}
	return z_impl_k_msgq_get(msgq, data, timeout);
   29ff2:	4e13      	ldr	r6, [pc, #76]	; (2a040 <send_keyboard_report_callback+0x50>)
        struct bt_gatt_notify_params notify_params = {
   29ff4:	4f13      	ldr	r7, [pc, #76]	; (2a044 <send_keyboard_report_callback+0x54>)
void send_keyboard_report_callback(struct k_work *work) {
   29ff6:	b089      	sub	sp, #36	; 0x24
   29ff8:	2200      	movs	r2, #0
   29ffa:	2300      	movs	r3, #0
   29ffc:	4669      	mov	r1, sp
   29ffe:	4630      	mov	r0, r6
   2a000:	f01c ff76 	bl	46ef0 <z_impl_k_msgq_get>
    while (k_msgq_get(&zmk_hog_keyboard_msgq, &report, K_NO_WAIT) == 0) {
   2a004:	4605      	mov	r5, r0
   2a006:	b108      	cbz	r0, 2a00c <send_keyboard_report_callback+0x1c>
}
   2a008:	b009      	add	sp, #36	; 0x24
   2a00a:	bdf0      	pop	{r4, r5, r6, r7, pc}
        struct bt_conn *conn = destination_connection();
   2a00c:	f7ff ffde 	bl	29fcc <destination_connection>
        if (conn == NULL) {
   2a010:	4604      	mov	r4, r0
   2a012:	2800      	cmp	r0, #0
   2a014:	d0f8      	beq.n	2a008 <send_keyboard_report_callback+0x18>
        struct bt_gatt_notify_params notify_params = {
   2a016:	2218      	movs	r2, #24
   2a018:	4629      	mov	r1, r5
   2a01a:	a802      	add	r0, sp, #8
   2a01c:	f020 ff38 	bl	4ae90 <memset>
   2a020:	2308      	movs	r3, #8
        int err = bt_gatt_notify_cb(conn, &notify_params);
   2a022:	eb0d 0103 	add.w	r1, sp, r3
   2a026:	4620      	mov	r0, r4
        struct bt_gatt_notify_params notify_params = {
   2a028:	9703      	str	r7, [sp, #12]
   2a02a:	f8cd d010 	str.w	sp, [sp, #16]
   2a02e:	f8ad 3014 	strh.w	r3, [sp, #20]
        int err = bt_gatt_notify_cb(conn, &notify_params);
   2a032:	f008 fa73 	bl	3251c <bt_gatt_notify_cb>
        bt_conn_unref(conn);
   2a036:	4620      	mov	r0, r4
   2a038:	f021 fec5 	bl	4bdc6 <bt_conn_unref>
   2a03c:	e7dc      	b.n	29ff8 <send_keyboard_report_callback+0x8>
   2a03e:	bf00      	nop
   2a040:	200011dc 	.word	0x200011dc
   2a044:	00051968 	.word	0x00051968

0002a048 <send_consumer_report_callback>:
void send_consumer_report_callback(struct k_work *work) {
   2a048:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2a04c:	4f13      	ldr	r7, [pc, #76]	; (2a09c <send_consumer_report_callback+0x54>)
        struct bt_gatt_notify_params notify_params = {
   2a04e:	f8df 8050 	ldr.w	r8, [pc, #80]	; 2a0a0 <send_consumer_report_callback+0x58>
void send_consumer_report_callback(struct k_work *work) {
   2a052:	b08a      	sub	sp, #40	; 0x28
   2a054:	ae01      	add	r6, sp, #4
   2a056:	2200      	movs	r2, #0
   2a058:	2300      	movs	r3, #0
   2a05a:	4631      	mov	r1, r6
   2a05c:	4638      	mov	r0, r7
   2a05e:	f01c ff47 	bl	46ef0 <z_impl_k_msgq_get>
    while (k_msgq_get(&zmk_hog_consumer_msgq, &report, K_NO_WAIT) == 0) {
   2a062:	4605      	mov	r5, r0
   2a064:	b110      	cbz	r0, 2a06c <send_consumer_report_callback+0x24>
};
   2a066:	b00a      	add	sp, #40	; 0x28
   2a068:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        struct bt_conn *conn = destination_connection();
   2a06c:	f7ff ffae 	bl	29fcc <destination_connection>
        if (conn == NULL) {
   2a070:	4604      	mov	r4, r0
   2a072:	2800      	cmp	r0, #0
   2a074:	d0f7      	beq.n	2a066 <send_consumer_report_callback+0x1e>
        struct bt_gatt_notify_params notify_params = {
   2a076:	2218      	movs	r2, #24
   2a078:	4629      	mov	r1, r5
   2a07a:	a804      	add	r0, sp, #16
   2a07c:	f020 ff08 	bl	4ae90 <memset>
   2a080:	230c      	movs	r3, #12
        int err = bt_gatt_notify_cb(conn, &notify_params);
   2a082:	a904      	add	r1, sp, #16
   2a084:	4620      	mov	r0, r4
        struct bt_gatt_notify_params notify_params = {
   2a086:	e9cd 8605 	strd	r8, r6, [sp, #20]
   2a08a:	f8ad 301c 	strh.w	r3, [sp, #28]
        int err = bt_gatt_notify_cb(conn, &notify_params);
   2a08e:	f008 fa45 	bl	3251c <bt_gatt_notify_cb>
        bt_conn_unref(conn);
   2a092:	4620      	mov	r0, r4
   2a094:	f021 fe97 	bl	4bdc6 <bt_conn_unref>
   2a098:	e7dd      	b.n	2a056 <send_consumer_report_callback+0xe>
   2a09a:	bf00      	nop
   2a09c:	200011ac 	.word	0x200011ac
   2a0a0:	000519cc 	.word	0x000519cc

0002a0a4 <zmk_hog_send_keyboard_report>:
int zmk_hog_send_keyboard_report(struct zmk_hid_keyboard_report_body *report) {
   2a0a4:	b537      	push	{r0, r1, r2, r4, r5, lr}
   2a0a6:	4605      	mov	r5, r0
	return z_impl_k_msgq_put(msgq, data, timeout);
   2a0a8:	f640 42cd 	movw	r2, #3277	; 0xccd
   2a0ac:	4601      	mov	r1, r0
   2a0ae:	2300      	movs	r3, #0
   2a0b0:	480c      	ldr	r0, [pc, #48]	; (2a0e4 <zmk_hog_send_keyboard_report+0x40>)
   2a0b2:	f01c fec7 	bl	46e44 <z_impl_k_msgq_put>
    if (err) {
   2a0b6:	4604      	mov	r4, r0
   2a0b8:	b178      	cbz	r0, 2a0da <zmk_hog_send_keyboard_report+0x36>
        switch (err) {
   2a0ba:	f110 0f0b 	cmn.w	r0, #11
   2a0be:	d109      	bne.n	2a0d4 <zmk_hog_send_keyboard_report+0x30>
	return z_impl_k_msgq_get(msgq, data, timeout);
   2a0c0:	2200      	movs	r2, #0
   2a0c2:	2300      	movs	r3, #0
   2a0c4:	4669      	mov	r1, sp
   2a0c6:	4807      	ldr	r0, [pc, #28]	; (2a0e4 <zmk_hog_send_keyboard_report+0x40>)
   2a0c8:	f01c ff12 	bl	46ef0 <z_impl_k_msgq_get>
            return zmk_hog_send_keyboard_report(report);
   2a0cc:	4628      	mov	r0, r5
   2a0ce:	f7ff ffe9 	bl	2a0a4 <zmk_hog_send_keyboard_report>
   2a0d2:	4604      	mov	r4, r0
};
   2a0d4:	4620      	mov	r0, r4
   2a0d6:	b003      	add	sp, #12
   2a0d8:	bd30      	pop	{r4, r5, pc}
    k_work_submit_to_queue(&hog_work_q, &hog_keyboard_work);
   2a0da:	4903      	ldr	r1, [pc, #12]	; (2a0e8 <zmk_hog_send_keyboard_report+0x44>)
   2a0dc:	4803      	ldr	r0, [pc, #12]	; (2a0ec <zmk_hog_send_keyboard_report+0x48>)
   2a0de:	f025 ff7a 	bl	4ffd6 <k_work_submit_to_queue>
    return 0;
   2a0e2:	e7f7      	b.n	2a0d4 <zmk_hog_send_keyboard_report+0x30>
   2a0e4:	200011dc 	.word	0x200011dc
   2a0e8:	20000404 	.word	0x20000404
   2a0ec:	20001528 	.word	0x20001528

0002a0f0 <zmk_hog_send_consumer_report>:
int zmk_hog_send_consumer_report(struct zmk_hid_consumer_report_body *report) {
   2a0f0:	b530      	push	{r4, r5, lr}
   2a0f2:	4605      	mov	r5, r0
   2a0f4:	b085      	sub	sp, #20
	return z_impl_k_msgq_put(msgq, data, timeout);
   2a0f6:	f640 42cd 	movw	r2, #3277	; 0xccd
   2a0fa:	4601      	mov	r1, r0
   2a0fc:	2300      	movs	r3, #0
   2a0fe:	480d      	ldr	r0, [pc, #52]	; (2a134 <zmk_hog_send_consumer_report+0x44>)
   2a100:	f01c fea0 	bl	46e44 <z_impl_k_msgq_put>
    if (err) {
   2a104:	4604      	mov	r4, r0
   2a106:	b178      	cbz	r0, 2a128 <zmk_hog_send_consumer_report+0x38>
        switch (err) {
   2a108:	f110 0f0b 	cmn.w	r0, #11
   2a10c:	d109      	bne.n	2a122 <zmk_hog_send_consumer_report+0x32>
	return z_impl_k_msgq_get(msgq, data, timeout);
   2a10e:	2200      	movs	r2, #0
   2a110:	2300      	movs	r3, #0
   2a112:	a901      	add	r1, sp, #4
   2a114:	4807      	ldr	r0, [pc, #28]	; (2a134 <zmk_hog_send_consumer_report+0x44>)
   2a116:	f01c feeb 	bl	46ef0 <z_impl_k_msgq_get>
            return zmk_hog_send_consumer_report(report);
   2a11a:	4628      	mov	r0, r5
   2a11c:	f7ff ffe8 	bl	2a0f0 <zmk_hog_send_consumer_report>
   2a120:	4604      	mov	r4, r0
};
   2a122:	4620      	mov	r0, r4
   2a124:	b005      	add	sp, #20
   2a126:	bd30      	pop	{r4, r5, pc}
    k_work_submit_to_queue(&hog_work_q, &hog_consumer_work);
   2a128:	4903      	ldr	r1, [pc, #12]	; (2a138 <zmk_hog_send_consumer_report+0x48>)
   2a12a:	4804      	ldr	r0, [pc, #16]	; (2a13c <zmk_hog_send_consumer_report+0x4c>)
   2a12c:	f025 ff53 	bl	4ffd6 <k_work_submit_to_queue>
    return 0;
   2a130:	e7f7      	b.n	2a122 <zmk_hog_send_consumer_report+0x32>
   2a132:	bf00      	nop
   2a134:	200011ac 	.word	0x200011ac
   2a138:	200003f4 	.word	0x200003f4
   2a13c:	20001528 	.word	0x20001528

0002a140 <new_zmk_battery_state_changed>:
 */

#include <zephyr/kernel.h>
#include <zmk/events/battery_state_changed.h>

   2a140:	b510      	push	{r4, lr}
   2a142:	4604      	mov	r4, r0
   2a144:	200c      	movs	r0, #12
   2a146:	f026 fabd 	bl	506c4 <k_malloc>
   2a14a:	4a02      	ldr	r2, [pc, #8]	; (2a154 <new_zmk_battery_state_changed+0x14>)
   2a14c:	6002      	str	r2, [r0, #0]
   2a14e:	7204      	strb	r4, [r0, #8]
   2a150:	bd10      	pop	{r4, pc}
   2a152:	bf00      	nop
   2a154:	00051a30 	.word	0x00051a30

0002a158 <zmk_battery_timer>:
    }
}

K_WORK_DEFINE(battery_work, zmk_battery_work);

static void zmk_battery_timer(struct k_timer *timer) {
   2a158:	b508      	push	{r3, lr}
    k_work_submit_to_queue(zmk_workqueue_lowprio_work_q(), &battery_work);
   2a15a:	f000 fceb 	bl	2ab34 <zmk_workqueue_lowprio_work_q>
}
   2a15e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    k_work_submit_to_queue(zmk_workqueue_lowprio_work_q(), &battery_work);
   2a162:	4901      	ldr	r1, [pc, #4]	; (2a168 <zmk_battery_timer+0x10>)
   2a164:	f025 bf37 	b.w	4ffd6 <k_work_submit_to_queue>
   2a168:	200004d4 	.word	0x200004d4

0002a16c <zmk_battery_init>:

K_TIMER_DEFINE(battery_timer, zmk_battery_timer, NULL);

static int zmk_battery_init(const struct device *_arg) {
   2a16c:	b507      	push	{r0, r1, r2, lr}
 */
__syscall bool device_is_ready(const struct device *dev);

static inline bool z_impl_device_is_ready(const struct device *dev)
{
	return z_device_is_ready(dev);
   2a16e:	480a      	ldr	r0, [pc, #40]	; (2a198 <zmk_battery_init+0x2c>)
   2a170:	f025 fc89 	bl	4fa86 <z_device_is_ready>
    }

    LOG_WRN("Finding battery device labeled BATTERY is deprecated. Use zmk,battery chosen node.");
#endif

    if (!device_is_ready(battery)) {
   2a174:	b168      	cbz	r0, 2a192 <zmk_battery_init+0x26>
	z_impl_k_timer_start(timer, duration, period);
   2a176:	f44f 12f0 	mov.w	r2, #1966080	; 0x1e0000
   2a17a:	2300      	movs	r3, #0
   2a17c:	e9cd 2300 	strd	r2, r3, [sp]
   2a180:	4806      	ldr	r0, [pc, #24]	; (2a19c <zmk_battery_init+0x30>)
   2a182:	2200      	movs	r2, #0
   2a184:	2300      	movs	r3, #0
   2a186:	f01d ff59 	bl	4803c <z_impl_k_timer_start>
        return -ENODEV;
    }

    k_timer_start(&battery_timer, K_NO_WAIT, K_SECONDS(CONFIG_ZMK_BATTERY_REPORT_INTERVAL));

    return 0;
   2a18a:	2000      	movs	r0, #0
}
   2a18c:	b003      	add	sp, #12
   2a18e:	f85d fb04 	ldr.w	pc, [sp], #4
        return -ENODEV;
   2a192:	f06f 0012 	mvn.w	r0, #18
   2a196:	e7f9      	b.n	2a18c <zmk_battery_init+0x20>
   2a198:	0005091c 	.word	0x0005091c
   2a19c:	20001038 	.word	0x20001038

0002a1a0 <zmk_battery_work>:
static void zmk_battery_work(struct k_work *work) {
   2a1a0:	b537      	push	{r0, r1, r2, r4, r5, lr}
	return api->sample_fetch(dev, type);
   2a1a2:	4c0f      	ldr	r4, [pc, #60]	; (2a1e0 <zmk_battery_work+0x40>)
   2a1a4:	68a5      	ldr	r5, [r4, #8]
   2a1a6:	212c      	movs	r1, #44	; 0x2c
   2a1a8:	68eb      	ldr	r3, [r5, #12]
   2a1aa:	4620      	mov	r0, r4
   2a1ac:	4798      	blx	r3
    if (rc != 0) {
   2a1ae:	b9a0      	cbnz	r0, 2a1da <zmk_battery_work+0x3a>
	return api->channel_get(dev, chan, val);
   2a1b0:	212c      	movs	r1, #44	; 0x2c
   2a1b2:	692b      	ldr	r3, [r5, #16]
   2a1b4:	466a      	mov	r2, sp
   2a1b6:	4620      	mov	r0, r4
   2a1b8:	4798      	blx	r3
    if (rc != 0) {
   2a1ba:	b970      	cbnz	r0, 2a1da <zmk_battery_work+0x3a>
    if (last_state_of_charge != state_of_charge.val1) {
   2a1bc:	4c09      	ldr	r4, [pc, #36]	; (2a1e4 <zmk_battery_work+0x44>)
   2a1be:	9800      	ldr	r0, [sp, #0]
   2a1c0:	7823      	ldrb	r3, [r4, #0]
   2a1c2:	4283      	cmp	r3, r0
   2a1c4:	d009      	beq.n	2a1da <zmk_battery_work+0x3a>
        last_state_of_charge = state_of_charge.val1;
   2a1c6:	b2c0      	uxtb	r0, r0
   2a1c8:	7020      	strb	r0, [r4, #0]
        rc = bt_bas_set_battery_level(last_state_of_charge);
   2a1ca:	f001 f867 	bl	2b29c <bt_bas_set_battery_level>
        if (rc != 0) {
   2a1ce:	b920      	cbnz	r0, 2a1da <zmk_battery_work+0x3a>
        rc = ZMK_EVENT_RAISE(new_zmk_battery_state_changed(
   2a1d0:	7820      	ldrb	r0, [r4, #0]
   2a1d2:	f7ff ffb5 	bl	2a140 <new_zmk_battery_state_changed>
   2a1d6:	f01e f853 	bl	48280 <zmk_event_manager_raise>
}
   2a1da:	b003      	add	sp, #12
   2a1dc:	bd30      	pop	{r4, r5, pc}
   2a1de:	bf00      	nop
   2a1e0:	0005091c 	.word	0x0005091c
   2a1e4:	20006af1 	.word	0x20006af1

0002a1e8 <start_scanning>:
    } else if (type == BT_GAP_ADV_TYPE_ADV_DIRECT_IND) {
        split_central_eir_found(addr);
    }
}

static int start_scanning(void) {
   2a1e8:	b530      	push	{r4, r5, lr}
    // No action is necessary if central is already scanning.
    if (is_scanning) {
   2a1ea:	4b0c      	ldr	r3, [pc, #48]	; (2a21c <start_scanning+0x34>)
   2a1ec:	7818      	ldrb	r0, [r3, #0]
static int start_scanning(void) {
   2a1ee:	b087      	sub	sp, #28
    if (is_scanning) {
   2a1f0:	b990      	cbnz	r0, 2a218 <start_scanning+0x30>
    }

    // If all the devices are connected, there is no need to scan.
    bool has_unconnected = false;
    for (int i = 0; i < CONFIG_ZMK_SPLIT_BLE_CENTRAL_PERIPHERALS; i++) {
        if (peripherals[i].conn == NULL) {
   2a1f2:	4a0b      	ldr	r2, [pc, #44]	; (2a220 <start_scanning+0x38>)
   2a1f4:	6852      	ldr	r2, [r2, #4]
   2a1f6:	b96a      	cbnz	r2, 2a214 <start_scanning+0x2c>
        return 0;
    }

    // Start scanning otherwise.
    is_scanning = true;
    int err = bt_le_scan_start(BT_LE_SCAN_PASSIVE, split_central_device_found);
   2a1f8:	4d0a      	ldr	r5, [pc, #40]	; (2a224 <start_scanning+0x3c>)
    is_scanning = true;
   2a1fa:	2201      	movs	r2, #1
   2a1fc:	701a      	strb	r2, [r3, #0]
    int err = bt_le_scan_start(BT_LE_SCAN_PASSIVE, split_central_device_found);
   2a1fe:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   2a200:	ac01      	add	r4, sp, #4
   2a202:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   2a204:	682b      	ldr	r3, [r5, #0]
   2a206:	4908      	ldr	r1, [pc, #32]	; (2a228 <start_scanning+0x40>)
   2a208:	6023      	str	r3, [r4, #0]
   2a20a:	a801      	add	r0, sp, #4
   2a20c:	f005 fa50 	bl	2f6b0 <bt_le_scan_start>
    if (err < 0) {
   2a210:	ea00 70e0 	and.w	r0, r0, r0, asr #31
        return err;
    }

    LOG_DBG("Scanning successfully started");
    return 0;
}
   2a214:	b007      	add	sp, #28
   2a216:	bd30      	pop	{r4, r5, pc}
        return 0;
   2a218:	2000      	movs	r0, #0
   2a21a:	e7fb      	b.n	2a214 <start_scanning+0x2c>
   2a21c:	20006af2 	.word	0x20006af2
   2a220:	20003894 	.word	0x20003894
   2a224:	00050d34 	.word	0x00050d34
   2a228:	0002a89d 	.word	0x0002a89d

0002a22c <zmk_split_bt_central_init>:

    struct zmk_split_run_behavior_payload_wrapper wrapper = {.source = source, .payload = payload};
    return split_bt_invoke_behavior_payload(wrapper);
}

int zmk_split_bt_central_init(const struct device *_arg) {
   2a22c:	b507      	push	{r0, r1, r2, lr}
    k_work_queue_start(&split_central_split_run_q, split_central_split_run_q_stack,
   2a22e:	2300      	movs	r3, #0
   2a230:	4907      	ldr	r1, [pc, #28]	; (2a250 <zmk_split_bt_central_init+0x24>)
   2a232:	9300      	str	r3, [sp, #0]
   2a234:	f44f 7200 	mov.w	r2, #512	; 0x200
   2a238:	2305      	movs	r3, #5
   2a23a:	4806      	ldr	r0, [pc, #24]	; (2a254 <zmk_split_bt_central_init+0x28>)
   2a23c:	f01d f940 	bl	474c0 <k_work_queue_start>
                       K_THREAD_STACK_SIZEOF(split_central_split_run_q_stack),
                       CONFIG_ZMK_BLE_THREAD_PRIORITY, NULL);
    bt_conn_cb_register(&conn_callbacks);
   2a240:	4805      	ldr	r0, [pc, #20]	; (2a258 <zmk_split_bt_central_init+0x2c>)
   2a242:	f005 ff6f 	bl	30124 <bt_conn_cb_register>

    return IS_ENABLED(CONFIG_ZMK_BLE_CLEAR_BONDS_ON_START) ? 0 : start_scanning();
}
   2a246:	b003      	add	sp, #12
   2a248:	f85d eb04 	ldr.w	lr, [sp], #4
    return IS_ENABLED(CONFIG_ZMK_BLE_CLEAR_BONDS_ON_START) ? 0 : start_scanning();
   2a24c:	f7ff bfcc 	b.w	2a1e8 <start_scanning>
   2a250:	20006ec8 	.word	0x20006ec8
   2a254:	200015c8 	.word	0x200015c8
   2a258:	200004f4 	.word	0x200004f4

0002a25c <split_bt_invoke_behavior_payload>:
split_bt_invoke_behavior_payload(struct zmk_split_run_behavior_payload_wrapper payload_wrapper) {
   2a25c:	b084      	sub	sp, #16
   2a25e:	b510      	push	{r4, lr}
   2a260:	b088      	sub	sp, #32
   2a262:	ac0a      	add	r4, sp, #40	; 0x28
   2a264:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
	return z_impl_k_msgq_put(msgq, data, timeout);
   2a268:	4811      	ldr	r0, [pc, #68]	; (2a2b0 <split_bt_invoke_behavior_payload+0x54>)
   2a26a:	4621      	mov	r1, r4
   2a26c:	f640 42cd 	movw	r2, #3277	; 0xccd
   2a270:	2300      	movs	r3, #0
   2a272:	f01c fde7 	bl	46e44 <z_impl_k_msgq_put>
    if (err) {
   2a276:	4604      	mov	r4, r0
   2a278:	b1a8      	cbz	r0, 2a2a6 <split_bt_invoke_behavior_payload+0x4a>
        switch (err) {
   2a27a:	f110 0f0b 	cmn.w	r0, #11
   2a27e:	d10c      	bne.n	2a29a <split_bt_invoke_behavior_payload+0x3e>
	return z_impl_k_msgq_get(msgq, data, timeout);
   2a280:	2200      	movs	r2, #0
   2a282:	2300      	movs	r3, #0
   2a284:	a903      	add	r1, sp, #12
   2a286:	480a      	ldr	r0, [pc, #40]	; (2a2b0 <split_bt_invoke_behavior_payload+0x54>)
   2a288:	f01c fe32 	bl	46ef0 <z_impl_k_msgq_get>
            return split_bt_invoke_behavior_payload(payload_wrapper);
   2a28c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   2a28e:	9300      	str	r3, [sp, #0]
   2a290:	ab0a      	add	r3, sp, #40	; 0x28
   2a292:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
   2a294:	f7ff ffe2 	bl	2a25c <split_bt_invoke_behavior_payload>
   2a298:	4604      	mov	r4, r0
};
   2a29a:	4620      	mov	r0, r4
   2a29c:	b008      	add	sp, #32
   2a29e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   2a2a2:	b004      	add	sp, #16
   2a2a4:	4770      	bx	lr
    k_work_submit_to_queue(&split_central_split_run_q, &split_central_split_run_work);
   2a2a6:	4903      	ldr	r1, [pc, #12]	; (2a2b4 <split_bt_invoke_behavior_payload+0x58>)
   2a2a8:	4803      	ldr	r0, [pc, #12]	; (2a2b8 <split_bt_invoke_behavior_payload+0x5c>)
   2a2aa:	f025 fe94 	bl	4ffd6 <k_work_submit_to_queue>
    return 0;
   2a2ae:	e7f4      	b.n	2a29a <split_bt_invoke_behavior_payload+0x3e>
   2a2b0:	2000123c 	.word	0x2000123c
   2a2b4:	200004e4 	.word	0x200004e4
   2a2b8:	200015c8 	.word	0x200015c8

0002a2bc <bt_addr_le_to_str.constprop.0.isra.0>:
static inline int bt_addr_le_to_str(const bt_addr_le_t *addr, char *str,
   2a2bc:	b570      	push	{r4, r5, r6, lr}
	switch (addr->type) {
   2a2be:	7803      	ldrb	r3, [r0, #0]
static inline int bt_addr_le_to_str(const bt_addr_le_t *addr, char *str,
   2a2c0:	b08a      	sub	sp, #40	; 0x28
   2a2c2:	4604      	mov	r4, r0
   2a2c4:	460e      	mov	r6, r1
   2a2c6:	ad07      	add	r5, sp, #28
	switch (addr->type) {
   2a2c8:	2b03      	cmp	r3, #3
   2a2ca:	d820      	bhi.n	2a30e <bt_addr_le_to_str.constprop.0.isra.0+0x52>
   2a2cc:	e8df f003 	tbb	[pc, r3]
   2a2d0:	1d1b1902 	.word	0x1d1b1902
		strcpy(type, "public");
   2a2d4:	4911      	ldr	r1, [pc, #68]	; (2a31c <bt_addr_le_to_str.constprop.0.isra.0+0x60>)
		strcpy(type, "random");
   2a2d6:	4628      	mov	r0, r5
   2a2d8:	f020 fd8e 	bl	4adf8 <strcpy>
	return snprintk(str, len, "%02X:%02X:%02X:%02X:%02X:%02X (%s)",
   2a2dc:	9505      	str	r5, [sp, #20]
   2a2de:	7863      	ldrb	r3, [r4, #1]
   2a2e0:	9304      	str	r3, [sp, #16]
   2a2e2:	78a3      	ldrb	r3, [r4, #2]
   2a2e4:	9303      	str	r3, [sp, #12]
   2a2e6:	78e3      	ldrb	r3, [r4, #3]
   2a2e8:	9302      	str	r3, [sp, #8]
   2a2ea:	7923      	ldrb	r3, [r4, #4]
   2a2ec:	9301      	str	r3, [sp, #4]
   2a2ee:	7963      	ldrb	r3, [r4, #5]
   2a2f0:	9300      	str	r3, [sp, #0]
   2a2f2:	79a3      	ldrb	r3, [r4, #6]
   2a2f4:	4a0a      	ldr	r2, [pc, #40]	; (2a320 <bt_addr_le_to_str.constprop.0.isra.0+0x64>)
   2a2f6:	211e      	movs	r1, #30
   2a2f8:	4630      	mov	r0, r6
   2a2fa:	f01e fbd0 	bl	48a9e <snprintk>
}
   2a2fe:	b00a      	add	sp, #40	; 0x28
   2a300:	bd70      	pop	{r4, r5, r6, pc}
		strcpy(type, "random");
   2a302:	4908      	ldr	r1, [pc, #32]	; (2a324 <bt_addr_le_to_str.constprop.0.isra.0+0x68>)
   2a304:	e7e7      	b.n	2a2d6 <bt_addr_le_to_str.constprop.0.isra.0+0x1a>
		strcpy(type, "public-id");
   2a306:	4908      	ldr	r1, [pc, #32]	; (2a328 <bt_addr_le_to_str.constprop.0.isra.0+0x6c>)
   2a308:	e7e5      	b.n	2a2d6 <bt_addr_le_to_str.constprop.0.isra.0+0x1a>
		strcpy(type, "random-id");
   2a30a:	4908      	ldr	r1, [pc, #32]	; (2a32c <bt_addr_le_to_str.constprop.0.isra.0+0x70>)
   2a30c:	e7e3      	b.n	2a2d6 <bt_addr_le_to_str.constprop.0.isra.0+0x1a>
		snprintk(type, sizeof(type), "0x%02x", addr->type);
   2a30e:	4a08      	ldr	r2, [pc, #32]	; (2a330 <bt_addr_le_to_str.constprop.0.isra.0+0x74>)
   2a310:	210a      	movs	r1, #10
   2a312:	4628      	mov	r0, r5
   2a314:	f01e fbc3 	bl	48a9e <snprintk>
		break;
   2a318:	e7e0      	b.n	2a2dc <bt_addr_le_to_str.constprop.0.isra.0+0x20>
   2a31a:	bf00      	nop
   2a31c:	000531d3 	.word	0x000531d3
   2a320:	000531fc 	.word	0x000531fc
   2a324:	000531da 	.word	0x000531da
   2a328:	000531e1 	.word	0x000531e1
   2a32c:	000531eb 	.word	0x000531eb
   2a330:	000531f5 	.word	0x000531f5

0002a334 <peripheral_event_work_callback>:
void peripheral_event_work_callback(struct k_work *work) {
   2a334:	b530      	push	{r4, r5, lr}
   2a336:	4d0c      	ldr	r5, [pc, #48]	; (2a368 <peripheral_event_work_callback+0x34>)
   2a338:	b089      	sub	sp, #36	; 0x24
   2a33a:	ac02      	add	r4, sp, #8
   2a33c:	2200      	movs	r2, #0
   2a33e:	2300      	movs	r3, #0
   2a340:	4621      	mov	r1, r4
   2a342:	4628      	mov	r0, r5
   2a344:	f01c fdd4 	bl	46ef0 <z_impl_k_msgq_get>
    while (k_msgq_get(&peripheral_event_msgq, &ev, K_NO_WAIT) == 0) {
   2a348:	b108      	cbz	r0, 2a34e <peripheral_event_work_callback+0x1a>
}
   2a34a:	b009      	add	sp, #36	; 0x24
   2a34c:	bd30      	pop	{r4, r5, pc}
        ZMK_EVENT_RAISE(new_zmk_position_state_changed(ev));
   2a34e:	ab08      	add	r3, sp, #32
   2a350:	e913 0003 	ldmdb	r3, {r0, r1}
   2a354:	e88d 0003 	stmia.w	sp, {r0, r1}
   2a358:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
   2a35c:	f7fe fe50 	bl	29000 <new_zmk_position_state_changed>
   2a360:	f01d ff8e 	bl	48280 <zmk_event_manager_raise>
   2a364:	e7ea      	b.n	2a33c <peripheral_event_work_callback+0x8>
   2a366:	bf00      	nop
   2a368:	2000111c 	.word	0x2000111c

0002a36c <peripheral_sensor_event_work_callback>:
void peripheral_sensor_event_work_callback(struct k_work *work) {
   2a36c:	b530      	push	{r4, r5, lr}
   2a36e:	4d0c      	ldr	r5, [pc, #48]	; (2a3a0 <peripheral_sensor_event_work_callback+0x34>)
   2a370:	b08d      	sub	sp, #52	; 0x34
   2a372:	ac04      	add	r4, sp, #16
   2a374:	2200      	movs	r2, #0
   2a376:	2300      	movs	r3, #0
   2a378:	4621      	mov	r1, r4
   2a37a:	4628      	mov	r0, r5
   2a37c:	f01c fdb8 	bl	46ef0 <z_impl_k_msgq_get>
    while (k_msgq_get(&peripheral_sensor_event_msgq, &ev, K_NO_WAIT) == 0) {
   2a380:	b108      	cbz	r0, 2a386 <peripheral_sensor_event_work_callback+0x1a>
}
   2a382:	b00d      	add	sp, #52	; 0x34
   2a384:	bd30      	pop	{r4, r5, pc}
        ZMK_EVENT_RAISE(new_zmk_sensor_event(ev));
   2a386:	ab0c      	add	r3, sp, #48	; 0x30
   2a388:	e913 000f 	ldmdb	r3, {r0, r1, r2, r3}
   2a38c:	e88d 000f 	stmia.w	sp, {r0, r1, r2, r3}
   2a390:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
   2a394:	f7fe fe5a 	bl	2904c <new_zmk_sensor_event>
   2a398:	f01d ff72 	bl	48280 <zmk_event_manager_raise>
   2a39c:	e7ea      	b.n	2a374 <peripheral_sensor_event_work_callback+0x8>
   2a39e:	bf00      	nop
   2a3a0:	2000114c 	.word	0x2000114c

0002a3a4 <split_central_split_run_callback>:
void split_central_split_run_callback(struct k_work *work) {
   2a3a4:	b570      	push	{r4, r5, r6, lr}
   2a3a6:	4e11      	ldr	r6, [pc, #68]	; (2a3ec <split_central_split_run_callback+0x48>)
        if (peripherals[payload_wrapper.source].state != PERIPHERAL_SLOT_STATE_CONNECTED) {
   2a3a8:	4c11      	ldr	r4, [pc, #68]	; (2a3f0 <split_central_split_run_callback+0x4c>)
void split_central_split_run_callback(struct k_work *work) {
   2a3aa:	b08a      	sub	sp, #40	; 0x28
   2a3ac:	2200      	movs	r2, #0
   2a3ae:	2300      	movs	r3, #0
   2a3b0:	a905      	add	r1, sp, #20
   2a3b2:	4630      	mov	r0, r6
   2a3b4:	f01c fd9c 	bl	46ef0 <z_impl_k_msgq_get>
    while (k_msgq_get(&zmk_split_central_split_run_msgq, &payload_wrapper, K_NO_WAIT) == 0) {
   2a3b8:	b108      	cbz	r0, 2a3be <split_central_split_run_callback+0x1a>
}
   2a3ba:	b00a      	add	sp, #40	; 0x28
   2a3bc:	bd70      	pop	{r4, r5, r6, pc}
        if (peripherals[payload_wrapper.source].state != PERIPHERAL_SLOT_STATE_CONNECTED) {
   2a3be:	f89d 3014 	ldrb.w	r3, [sp, #20]
   2a3c2:	22a4      	movs	r2, #164	; 0xa4
   2a3c4:	4353      	muls	r3, r2
   2a3c6:	18e5      	adds	r5, r4, r3
   2a3c8:	5ce3      	ldrb	r3, [r4, r3]
   2a3ca:	2b02      	cmp	r3, #2
   2a3cc:	d1ee      	bne.n	2a3ac <split_central_split_run_callback+0x8>
        if (!peripherals[payload_wrapper.source].run_behavior_handle) {
   2a3ce:	f8b5 1080 	ldrh.w	r1, [r5, #128]	; 0x80
   2a3d2:	2900      	cmp	r1, #0
   2a3d4:	d0ea      	beq.n	2a3ac <split_central_split_run_callback+0x8>
 */
static inline int bt_gatt_write_without_response(struct bt_conn *conn,
						 uint16_t handle, const void *data,
						 uint16_t length, bool sign)
{
	return bt_gatt_write_without_response_cb(conn, handle, data, length,
   2a3d6:	e9cd 0001 	strd	r0, r0, [sp, #4]
   2a3da:	2301      	movs	r3, #1
   2a3dc:	9300      	str	r3, [sp, #0]
   2a3de:	6868      	ldr	r0, [r5, #4]
   2a3e0:	2313      	movs	r3, #19
   2a3e2:	f10d 0215 	add.w	r2, sp, #21
   2a3e6:	f023 fbcd 	bl	4db84 <bt_gatt_write_without_response_cb>
   2a3ea:	e7df      	b.n	2a3ac <split_central_split_run_callback+0x8>
   2a3ec:	2000123c 	.word	0x2000123c
   2a3f0:	20003894 	.word	0x20003894

0002a3f4 <split_central_sensor_notify_func>:
                                                const void *data, uint16_t length) {
   2a3f4:	b500      	push	{lr}
   2a3f6:	4608      	mov	r0, r1
   2a3f8:	b08d      	sub	sp, #52	; 0x34
    if (!data) {
   2a3fa:	4611      	mov	r1, r2
   2a3fc:	b922      	cbnz	r2, 2a408 <split_central_sensor_notify_func+0x14>
        params->value_handle = 0U;
   2a3fe:	8182      	strh	r2, [r0, #12]
        return BT_GATT_ITER_STOP;
   2a400:	2000      	movs	r0, #0
}
   2a402:	b00d      	add	sp, #52	; 0x34
   2a404:	f85d fb04 	ldr.w	pc, [sp], #4
    if (length < offsetof(struct sensor_event, channel_data)) {
   2a408:	2b01      	cmp	r3, #1
   2a40a:	d9f9      	bls.n	2a400 <split_central_sensor_notify_func+0xc>
    memcpy(&sensor_event, data, MIN(length, sizeof(sensor_event)));
   2a40c:	2b0c      	cmp	r3, #12
   2a40e:	bf28      	it	cs
   2a410:	230c      	movcs	r3, #12
   2a412:	461a      	mov	r2, r3
   2a414:	a801      	add	r0, sp, #4
   2a416:	f020 fd30 	bl	4ae7a <memcpy>
    struct zmk_sensor_event ev = {
   2a41a:	221c      	movs	r2, #28
   2a41c:	2100      	movs	r1, #0
   2a41e:	a805      	add	r0, sp, #20
   2a420:	f020 fd36 	bl	4ae90 <memset>
        .channel_data_size = MIN(sensor_event.channel_data_size, ZMK_SENSOR_EVENT_MAX_CHANNELS),
   2a424:	f89d 3005 	ldrb.w	r3, [sp, #5]
   2a428:	3b00      	subs	r3, #0
   2a42a:	bf18      	it	ne
   2a42c:	2301      	movne	r3, #1
    struct zmk_sensor_event ev = {
   2a42e:	9304      	str	r3, [sp, #16]
	return z_impl_k_uptime_ticks();
   2a430:	f025 ff96 	bl	50360 <z_impl_k_uptime_ticks>
   2a434:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   2a438:	fba0 0302 	umull	r0, r3, r0, r2
   2a43c:	fb02 3101 	mla	r1, r2, r1, r3
    memcpy(ev.channel_data, sensor_event.channel_data,
   2a440:	f89d 2005 	ldrb.w	r2, [sp, #5]
    struct zmk_sensor_event ev = {
   2a444:	f89d 3004 	ldrb.w	r3, [sp, #4]
   2a448:	f88d 3028 	strb.w	r3, [sp, #40]	; 0x28
   2a44c:	0bc0      	lsrs	r0, r0, #15
   2a44e:	ea40 4041 	orr.w	r0, r0, r1, lsl #17
    memcpy(ev.channel_data, sensor_event.channel_data,
   2a452:	eb02 0282 	add.w	r2, r2, r2, lsl #2
   2a456:	0bc9      	lsrs	r1, r1, #15
    struct zmk_sensor_event ev = {
   2a458:	e9cd 0108 	strd	r0, r1, [sp, #32]
    memcpy(ev.channel_data, sensor_event.channel_data,
   2a45c:	0052      	lsls	r2, r2, #1
   2a45e:	f10d 0106 	add.w	r1, sp, #6
   2a462:	a805      	add	r0, sp, #20
   2a464:	f020 fd09 	bl	4ae7a <memcpy>
	return z_impl_k_msgq_put(msgq, data, timeout);
   2a468:	2200      	movs	r2, #0
   2a46a:	2300      	movs	r3, #0
   2a46c:	a904      	add	r1, sp, #16
   2a46e:	4804      	ldr	r0, [pc, #16]	; (2a480 <split_central_sensor_notify_func+0x8c>)
   2a470:	f01c fce8 	bl	46e44 <z_impl_k_msgq_put>
    k_work_submit(&peripheral_sensor_event_work);
   2a474:	4803      	ldr	r0, [pc, #12]	; (2a484 <split_central_sensor_notify_func+0x90>)
   2a476:	f01d f81d 	bl	474b4 <k_work_submit>
    return BT_GATT_ITER_CONTINUE;
   2a47a:	2001      	movs	r0, #1
   2a47c:	e7c1      	b.n	2a402 <split_central_sensor_notify_func+0xe>
   2a47e:	bf00      	nop
   2a480:	2000114c 	.word	0x2000114c
   2a484:	20000514 	.word	0x20000514

0002a488 <peripheral_slot_index_for_conn>:
        if (peripherals[i].conn == conn) {
   2a488:	4b03      	ldr	r3, [pc, #12]	; (2a498 <peripheral_slot_index_for_conn+0x10>)
   2a48a:	685b      	ldr	r3, [r3, #4]
   2a48c:	4283      	cmp	r3, r0
}
   2a48e:	bf14      	ite	ne
   2a490:	f06f 0015 	mvnne.w	r0, #21
   2a494:	2000      	moveq	r0, #0
   2a496:	4770      	bx	lr
   2a498:	20003894 	.word	0x20003894

0002a49c <peripheral_slot_for_conn>:
struct peripheral_slot *peripheral_slot_for_conn(struct bt_conn *conn) {
   2a49c:	b508      	push	{r3, lr}
    int idx = peripheral_slot_index_for_conn(conn);
   2a49e:	f7ff fff3 	bl	2a488 <peripheral_slot_index_for_conn>
    if (idx < 0) {
   2a4a2:	1e03      	subs	r3, r0, #0
    return &peripherals[idx];
   2a4a4:	bfa3      	ittte	ge
   2a4a6:	4803      	ldrge	r0, [pc, #12]	; (2a4b4 <peripheral_slot_for_conn+0x18>)
   2a4a8:	22a4      	movge	r2, #164	; 0xa4
   2a4aa:	fb02 0003 	mlage	r0, r2, r3, r0
        return NULL;
   2a4ae:	2000      	movlt	r0, #0
}
   2a4b0:	bd08      	pop	{r3, pc}
   2a4b2:	bf00      	nop
   2a4b4:	20003894 	.word	0x20003894

0002a4b8 <split_central_service_discovery_func>:
                                                    struct bt_gatt_discover_params *params) {
   2a4b8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2a4bc:	4613      	mov	r3, r2
   2a4be:	b086      	sub	sp, #24
   2a4c0:	4607      	mov	r7, r0
    if (!attr) {
   2a4c2:	460d      	mov	r5, r1
   2a4c4:	b939      	cbnz	r1, 2a4d6 <split_central_service_discovery_func+0x1e>
        (void)memset(params, 0, sizeof(*params));
   2a4c6:	2218      	movs	r2, #24
   2a4c8:	4618      	mov	r0, r3
   2a4ca:	f020 fce1 	bl	4ae90 <memset>
        return BT_GATT_ITER_STOP;
   2a4ce:	2000      	movs	r0, #0
}
   2a4d0:	b006      	add	sp, #24
   2a4d2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    struct peripheral_slot *slot = peripheral_slot_for_conn(conn);
   2a4d6:	f7ff ffe1 	bl	2a49c <peripheral_slot_for_conn>
    if (slot == NULL) {
   2a4da:	4604      	mov	r4, r0
   2a4dc:	2800      	cmp	r0, #0
   2a4de:	d0f6      	beq.n	2a4ce <split_central_service_discovery_func+0x16>
    if (bt_uuid_cmp(slot->discover_params.uuid, BT_UUID_DECLARE_128(ZMK_SPLIT_BT_SERVICE_UUID)) !=
   2a4e0:	4b12      	ldr	r3, [pc, #72]	; (2a52c <split_central_service_discovery_func+0x74>)
   2a4e2:	f8d0 c008 	ldr.w	ip, [r0, #8]
   2a4e6:	aa01      	add	r2, sp, #4
   2a4e8:	f103 0810 	add.w	r8, r3, #16
   2a4ec:	4696      	mov	lr, r2
   2a4ee:	6818      	ldr	r0, [r3, #0]
   2a4f0:	6859      	ldr	r1, [r3, #4]
   2a4f2:	4616      	mov	r6, r2
   2a4f4:	c603      	stmia	r6!, {r0, r1}
   2a4f6:	3308      	adds	r3, #8
   2a4f8:	4543      	cmp	r3, r8
   2a4fa:	4632      	mov	r2, r6
   2a4fc:	d1f7      	bne.n	2a4ee <split_central_service_discovery_func+0x36>
   2a4fe:	781b      	ldrb	r3, [r3, #0]
   2a500:	7033      	strb	r3, [r6, #0]
   2a502:	4671      	mov	r1, lr
   2a504:	4660      	mov	r0, ip
   2a506:	f020 fd79 	bl	4affc <bt_uuid_cmp>
   2a50a:	b108      	cbz	r0, 2a510 <split_central_service_discovery_func+0x58>
        return BT_GATT_ITER_CONTINUE;
   2a50c:	2001      	movs	r0, #1
   2a50e:	e7df      	b.n	2a4d0 <split_central_service_discovery_func+0x18>
    slot->discover_params.func = split_central_chrc_discovery_func;
   2a510:	4b07      	ldr	r3, [pc, #28]	; (2a530 <split_central_service_discovery_func+0x78>)
    slot->discover_params.uuid = NULL;
   2a512:	60a0      	str	r0, [r4, #8]
    slot->discover_params.func = split_central_chrc_discovery_func;
   2a514:	60e3      	str	r3, [r4, #12]
    slot->discover_params.start_handle = attr->handle + 1;
   2a516:	8a2b      	ldrh	r3, [r5, #16]
   2a518:	3301      	adds	r3, #1
   2a51a:	8223      	strh	r3, [r4, #16]
    slot->discover_params.type = BT_GATT_DISCOVER_CHARACTERISTIC;
   2a51c:	2303      	movs	r3, #3
   2a51e:	7623      	strb	r3, [r4, #24]
    int err = bt_gatt_discover(conn, &slot->discover_params);
   2a520:	f104 0108 	add.w	r1, r4, #8
   2a524:	4638      	mov	r0, r7
   2a526:	f008 f8fb 	bl	32720 <bt_gatt_discover>
    if (err) {
   2a52a:	e7d0      	b.n	2a4ce <split_central_service_discovery_func+0x16>
   2a52c:	00050d48 	.word	0x00050d48
   2a530:	0002a535 	.word	0x0002a535

0002a534 <split_central_chrc_discovery_func>:
                                                 struct bt_gatt_discover_params *params) {
   2a534:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2a538:	4607      	mov	r7, r0
   2a53a:	b090      	sub	sp, #64	; 0x40
    if (!attr) {
   2a53c:	460d      	mov	r5, r1
   2a53e:	2900      	cmp	r1, #0
   2a540:	f000 8095 	beq.w	2a66e <split_central_chrc_discovery_func+0x13a>
    if (!attr->user_data) {
   2a544:	68c9      	ldr	r1, [r1, #12]
   2a546:	2900      	cmp	r1, #0
   2a548:	f000 8093 	beq.w	2a672 <split_central_chrc_discovery_func+0x13e>
    struct peripheral_slot *slot = peripheral_slot_for_conn(conn);
   2a54c:	f7ff ffa6 	bl	2a49c <peripheral_slot_for_conn>
    if (slot == NULL) {
   2a550:	4604      	mov	r4, r0
   2a552:	2800      	cmp	r0, #0
   2a554:	d03a      	beq.n	2a5cc <split_central_chrc_discovery_func+0x98>
    if (bt_uuid_cmp(chrc_uuid, BT_UUID_DECLARE_128(ZMK_SPLIT_BT_CHAR_POSITION_STATE_UUID)) == 0) {
   2a556:	4b48      	ldr	r3, [pc, #288]	; (2a678 <split_central_chrc_discovery_func+0x144>)
    const struct bt_uuid *chrc_uuid = ((struct bt_gatt_chrc *)attr->user_data)->uuid;
   2a558:	680e      	ldr	r6, [r1, #0]
    if (bt_uuid_cmp(chrc_uuid, BT_UUID_DECLARE_128(ZMK_SPLIT_BT_CHAR_POSITION_STATE_UUID)) == 0) {
   2a55a:	aa01      	add	r2, sp, #4
   2a55c:	f103 0810 	add.w	r8, r3, #16
   2a560:	4696      	mov	lr, r2
   2a562:	6818      	ldr	r0, [r3, #0]
   2a564:	6859      	ldr	r1, [r3, #4]
   2a566:	4694      	mov	ip, r2
   2a568:	e8ac 0003 	stmia.w	ip!, {r0, r1}
   2a56c:	3308      	adds	r3, #8
   2a56e:	4543      	cmp	r3, r8
   2a570:	4662      	mov	r2, ip
   2a572:	d1f6      	bne.n	2a562 <split_central_chrc_discovery_func+0x2e>
   2a574:	781b      	ldrb	r3, [r3, #0]
   2a576:	f88c 3000 	strb.w	r3, [ip]
   2a57a:	4671      	mov	r1, lr
   2a57c:	4630      	mov	r0, r6
   2a57e:	f020 fd3d 	bl	4affc <bt_uuid_cmp>
   2a582:	bb30      	cbnz	r0, 2a5d2 <split_central_chrc_discovery_func+0x9e>
        slot->discover_params.uuid = NULL;
   2a584:	60a0      	str	r0, [r4, #8]
        slot->discover_params.start_handle = attr->handle + 2;
   2a586:	8a2b      	ldrh	r3, [r5, #16]
   2a588:	3302      	adds	r3, #2
   2a58a:	8223      	strh	r3, [r4, #16]
        slot->discover_params.type = BT_GATT_DISCOVER_CHARACTERISTIC;
   2a58c:	2303      	movs	r3, #3
   2a58e:	7623      	strb	r3, [r4, #24]
        slot->subscribe_params.disc_params = &slot->sub_discover_params;
   2a590:	f104 0368 	add.w	r3, r4, #104	; 0x68
   2a594:	6363      	str	r3, [r4, #52]	; 0x34
        slot->subscribe_params.end_handle = slot->discover_params.end_handle;
   2a596:	8ae3      	ldrh	r3, [r4, #22]
   2a598:	8623      	strh	r3, [r4, #48]	; 0x30
        slot->subscribe_params.value_handle = bt_gatt_attr_value_handle(attr);
   2a59a:	4628      	mov	r0, r5
   2a59c:	f022 ffd5 	bl	4d54a <bt_gatt_attr_value_handle>
        slot->subscribe_params.notify = split_central_notify_func;
   2a5a0:	4b36      	ldr	r3, [pc, #216]	; (2a67c <split_central_chrc_discovery_func+0x148>)
   2a5a2:	6223      	str	r3, [r4, #32]
        slot->subscribe_params.value = BT_GATT_CCC_NOTIFY;
   2a5a4:	2301      	movs	r3, #1
        slot->subscribe_params.value_handle = bt_gatt_attr_value_handle(attr);
   2a5a6:	85a0      	strh	r0, [r4, #44]	; 0x2c
        slot->subscribe_params.value = BT_GATT_CCC_NOTIFY;
   2a5a8:	8723      	strh	r3, [r4, #56]	; 0x38
    int err = bt_gatt_subscribe(conn, params);
   2a5aa:	f104 0120 	add.w	r1, r4, #32
   2a5ae:	4638      	mov	r0, r7
   2a5b0:	f008 fac0 	bl	32b34 <bt_gatt_subscribe>
    bool subscribed = slot->run_behavior_handle && slot->subscribe_params.value_handle;
   2a5b4:	f8b4 3080 	ldrh.w	r3, [r4, #128]	; 0x80
   2a5b8:	b133      	cbz	r3, 2a5c8 <split_central_chrc_discovery_func+0x94>
   2a5ba:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
   2a5bc:	b123      	cbz	r3, 2a5c8 <split_central_chrc_discovery_func+0x94>
    subscribed = subscribed && slot->sensor_subscribe_params.value_handle;
   2a5be:	f8b4 3050 	ldrh.w	r3, [r4, #80]	; 0x50
   2a5c2:	3b00      	subs	r3, #0
   2a5c4:	bf18      	it	ne
   2a5c6:	2301      	movne	r3, #1
    return subscribed ? BT_GATT_ITER_STOP : BT_GATT_ITER_CONTINUE;
   2a5c8:	f083 0001 	eor.w	r0, r3, #1
}
   2a5cc:	b010      	add	sp, #64	; 0x40
   2a5ce:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    } else if (bt_uuid_cmp(chrc_uuid, BT_UUID_DECLARE_128(ZMK_SPLIT_BT_CHAR_SENSOR_STATE_UUID)) ==
   2a5d2:	4b2b      	ldr	r3, [pc, #172]	; (2a680 <split_central_chrc_discovery_func+0x14c>)
   2a5d4:	aa06      	add	r2, sp, #24
   2a5d6:	f103 0810 	add.w	r8, r3, #16
   2a5da:	4696      	mov	lr, r2
   2a5dc:	6818      	ldr	r0, [r3, #0]
   2a5de:	6859      	ldr	r1, [r3, #4]
   2a5e0:	4694      	mov	ip, r2
   2a5e2:	e8ac 0003 	stmia.w	ip!, {r0, r1}
   2a5e6:	3308      	adds	r3, #8
   2a5e8:	4543      	cmp	r3, r8
   2a5ea:	4662      	mov	r2, ip
   2a5ec:	d1f6      	bne.n	2a5dc <split_central_chrc_discovery_func+0xa8>
   2a5ee:	781b      	ldrb	r3, [r3, #0]
   2a5f0:	f88c 3000 	strb.w	r3, [ip]
   2a5f4:	4671      	mov	r1, lr
   2a5f6:	4630      	mov	r0, r6
   2a5f8:	f020 fd00 	bl	4affc <bt_uuid_cmp>
   2a5fc:	b9c0      	cbnz	r0, 2a630 <split_central_chrc_discovery_func+0xfc>
        slot->discover_params.uuid = NULL;
   2a5fe:	60a0      	str	r0, [r4, #8]
        slot->discover_params.start_handle = attr->handle + 2;
   2a600:	8a2b      	ldrh	r3, [r5, #16]
   2a602:	3302      	adds	r3, #2
   2a604:	8223      	strh	r3, [r4, #16]
        slot->discover_params.type = BT_GATT_DISCOVER_CHARACTERISTIC;
   2a606:	2303      	movs	r3, #3
   2a608:	7623      	strb	r3, [r4, #24]
        slot->sensor_subscribe_params.disc_params = &slot->sub_discover_params;
   2a60a:	f104 0368 	add.w	r3, r4, #104	; 0x68
   2a60e:	65a3      	str	r3, [r4, #88]	; 0x58
        slot->sensor_subscribe_params.end_handle = slot->discover_params.end_handle;
   2a610:	8ae3      	ldrh	r3, [r4, #22]
   2a612:	f8a4 3054 	strh.w	r3, [r4, #84]	; 0x54
        slot->sensor_subscribe_params.value_handle = bt_gatt_attr_value_handle(attr);
   2a616:	4628      	mov	r0, r5
   2a618:	f022 ff97 	bl	4d54a <bt_gatt_attr_value_handle>
        slot->sensor_subscribe_params.notify = split_central_sensor_notify_func;
   2a61c:	4b19      	ldr	r3, [pc, #100]	; (2a684 <split_central_chrc_discovery_func+0x150>)
   2a61e:	6463      	str	r3, [r4, #68]	; 0x44
        slot->sensor_subscribe_params.value = BT_GATT_CCC_NOTIFY;
   2a620:	2301      	movs	r3, #1
        slot->sensor_subscribe_params.value_handle = bt_gatt_attr_value_handle(attr);
   2a622:	f8a4 0050 	strh.w	r0, [r4, #80]	; 0x50
        slot->sensor_subscribe_params.value = BT_GATT_CCC_NOTIFY;
   2a626:	f8a4 305c 	strh.w	r3, [r4, #92]	; 0x5c
    int err = bt_gatt_subscribe(conn, params);
   2a62a:	f104 0144 	add.w	r1, r4, #68	; 0x44
   2a62e:	e7be      	b.n	2a5ae <split_central_chrc_discovery_func+0x7a>
    } else if (bt_uuid_cmp(chrc_uuid, BT_UUID_DECLARE_128(ZMK_SPLIT_BT_CHAR_RUN_BEHAVIOR_UUID)) ==
   2a630:	4b15      	ldr	r3, [pc, #84]	; (2a688 <split_central_chrc_discovery_func+0x154>)
   2a632:	aa0b      	add	r2, sp, #44	; 0x2c
   2a634:	f103 0e10 	add.w	lr, r3, #16
   2a638:	4694      	mov	ip, r2
   2a63a:	6818      	ldr	r0, [r3, #0]
   2a63c:	6859      	ldr	r1, [r3, #4]
   2a63e:	4617      	mov	r7, r2
   2a640:	c703      	stmia	r7!, {r0, r1}
   2a642:	3308      	adds	r3, #8
   2a644:	4573      	cmp	r3, lr
   2a646:	463a      	mov	r2, r7
   2a648:	d1f7      	bne.n	2a63a <split_central_chrc_discovery_func+0x106>
   2a64a:	781b      	ldrb	r3, [r3, #0]
   2a64c:	703b      	strb	r3, [r7, #0]
   2a64e:	4661      	mov	r1, ip
   2a650:	4630      	mov	r0, r6
   2a652:	f020 fcd3 	bl	4affc <bt_uuid_cmp>
   2a656:	2800      	cmp	r0, #0
   2a658:	d1ac      	bne.n	2a5b4 <split_central_chrc_discovery_func+0x80>
        slot->discover_params.uuid = NULL;
   2a65a:	60a0      	str	r0, [r4, #8]
        slot->discover_params.start_handle = attr->handle + 2;
   2a65c:	8a2b      	ldrh	r3, [r5, #16]
   2a65e:	3302      	adds	r3, #2
   2a660:	8223      	strh	r3, [r4, #16]
        slot->run_behavior_handle = bt_gatt_attr_value_handle(attr);
   2a662:	4628      	mov	r0, r5
   2a664:	f022 ff71 	bl	4d54a <bt_gatt_attr_value_handle>
   2a668:	f8a4 0080 	strh.w	r0, [r4, #128]	; 0x80
   2a66c:	e7a2      	b.n	2a5b4 <split_central_chrc_discovery_func+0x80>
        return BT_GATT_ITER_STOP;
   2a66e:	4608      	mov	r0, r1
   2a670:	e7ac      	b.n	2a5cc <split_central_chrc_discovery_func+0x98>
   2a672:	4608      	mov	r0, r1
   2a674:	e7aa      	b.n	2a5cc <split_central_chrc_discovery_func+0x98>
   2a676:	bf00      	nop
   2a678:	00050d59 	.word	0x00050d59
   2a67c:	0002a68d 	.word	0x0002a68d
   2a680:	00050d6a 	.word	0x00050d6a
   2a684:	0002a3f5 	.word	0x0002a3f5
   2a688:	00050d7b 	.word	0x00050d7b

0002a68c <split_central_notify_func>:
                                         uint16_t length) {
   2a68c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2a690:	b086      	sub	sp, #24
   2a692:	4607      	mov	r7, r0
   2a694:	4614      	mov	r4, r2
    struct peripheral_slot *slot = peripheral_slot_for_conn(conn);
   2a696:	f7ff ff01 	bl	2a49c <peripheral_slot_for_conn>
    if (slot == NULL) {
   2a69a:	2800      	cmp	r0, #0
   2a69c:	d051      	beq.n	2a742 <split_central_notify_func+0xb6>
    if (!data) {
   2a69e:	b924      	cbnz	r4, 2a6aa <split_central_notify_func+0x1e>
        params->value_handle = 0U;
   2a6a0:	818c      	strh	r4, [r1, #12]
        return BT_GATT_ITER_STOP;
   2a6a2:	4620      	mov	r0, r4
}
   2a6a4:	b006      	add	sp, #24
   2a6a6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2a6aa:	1e63      	subs	r3, r4, #1
   2a6ac:	f100 0281 	add.w	r2, r0, #129	; 0x81
   2a6b0:	340f      	adds	r4, #15
        slot->changed_positions[i] = ((uint8_t *)data)[i] ^ slot->position_state[i];
   2a6b2:	f813 1f01 	ldrb.w	r1, [r3, #1]!
   2a6b6:	f812 5f01 	ldrb.w	r5, [r2, #1]!
   2a6ba:	4069      	eors	r1, r5
   2a6bc:	7411      	strb	r1, [r2, #16]
        slot->position_state[i] = ((uint8_t *)data)[i];
   2a6be:	7819      	ldrb	r1, [r3, #0]
   2a6c0:	7011      	strb	r1, [r2, #0]
    for (int i = 0; i < POSITION_STATE_DATA_LEN; i++) {
   2a6c2:	42a3      	cmp	r3, r4
   2a6c4:	d1f5      	bne.n	2a6b2 <split_central_notify_func+0x26>
   2a6c6:	f8df 9080 	ldr.w	r9, [pc, #128]	; 2a748 <split_central_notify_func+0xbc>
                k_work_submit(&peripheral_event_work);
   2a6ca:	f8df a080 	ldr.w	sl, [pc, #128]	; 2a74c <split_central_notify_func+0xc0>
   2a6ce:	f100 0492 	add.w	r4, r0, #146	; 0x92
    for (int i = 0; i < POSITION_STATE_DATA_LEN; i++) {
   2a6d2:	2600      	movs	r6, #0
                bool pressed = slot->position_state[i] & BIT(j);
   2a6d4:	f04f 0801 	mov.w	r8, #1
        for (int j = 0; j < 8; j++) {
   2a6d8:	2500      	movs	r5, #0
            if (slot->changed_positions[i] & BIT(j)) {
   2a6da:	7823      	ldrb	r3, [r4, #0]
   2a6dc:	40eb      	lsrs	r3, r5
   2a6de:	07db      	lsls	r3, r3, #31
   2a6e0:	d527      	bpl.n	2a732 <split_central_notify_func+0xa6>
                bool pressed = slot->position_state[i] & BIT(j);
   2a6e2:	f814 1c10 	ldrb.w	r1, [r4, #-16]
   2a6e6:	fa08 f305 	lsl.w	r3, r8, r5
   2a6ea:	4219      	tst	r1, r3
                                                            peripheral_slot_index_for_conn(conn),
   2a6ec:	4638      	mov	r0, r7
                bool pressed = slot->position_state[i] & BIT(j);
   2a6ee:	bf14      	ite	ne
   2a6f0:	2101      	movne	r1, #1
   2a6f2:	2100      	moveq	r1, #0
                                                            peripheral_slot_index_for_conn(conn),
   2a6f4:	f7ff fec8 	bl	2a488 <peripheral_slot_index_for_conn>
   2a6f8:	19aa      	adds	r2, r5, r6
                struct zmk_position_state_changed ev = {.source =
   2a6fa:	f88d 0000 	strb.w	r0, [sp]
   2a6fe:	9201      	str	r2, [sp, #4]
   2a700:	f88d 1008 	strb.w	r1, [sp, #8]
	return z_impl_k_uptime_ticks();
   2a704:	f025 fe2c 	bl	50360 <z_impl_k_uptime_ticks>
   2a708:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   2a70c:	fba0 0302 	umull	r0, r3, r0, r2
   2a710:	fb02 3101 	mla	r1, r2, r1, r3
   2a714:	0bc0      	lsrs	r0, r0, #15
   2a716:	ea40 4041 	orr.w	r0, r0, r1, lsl #17
   2a71a:	0bc9      	lsrs	r1, r1, #15
   2a71c:	e9cd 0104 	strd	r0, r1, [sp, #16]
	return z_impl_k_msgq_put(msgq, data, timeout);
   2a720:	2200      	movs	r2, #0
   2a722:	2300      	movs	r3, #0
   2a724:	4669      	mov	r1, sp
   2a726:	4648      	mov	r0, r9
   2a728:	f01c fb8c 	bl	46e44 <z_impl_k_msgq_put>
                k_work_submit(&peripheral_event_work);
   2a72c:	4650      	mov	r0, sl
   2a72e:	f01c fec1 	bl	474b4 <k_work_submit>
        for (int j = 0; j < 8; j++) {
   2a732:	3501      	adds	r5, #1
   2a734:	2d08      	cmp	r5, #8
   2a736:	d1d0      	bne.n	2a6da <split_central_notify_func+0x4e>
    for (int i = 0; i < POSITION_STATE_DATA_LEN; i++) {
   2a738:	3608      	adds	r6, #8
   2a73a:	2e80      	cmp	r6, #128	; 0x80
   2a73c:	f104 0401 	add.w	r4, r4, #1
   2a740:	d1ca      	bne.n	2a6d8 <split_central_notify_func+0x4c>
        return BT_GATT_ITER_CONTINUE;
   2a742:	2001      	movs	r0, #1
   2a744:	e7ae      	b.n	2a6a4 <split_central_notify_func+0x18>
   2a746:	bf00      	nop
   2a748:	2000111c 	.word	0x2000111c
   2a74c:	20000524 	.word	0x20000524

0002a750 <release_peripheral_slot>:
int release_peripheral_slot(int index) {
   2a750:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    if (index < 0 || index >= ZMK_SPLIT_BLE_PERIPHERAL_COUNT) {
   2a754:	4604      	mov	r4, r0
int release_peripheral_slot(int index) {
   2a756:	b086      	sub	sp, #24
    if (index < 0 || index >= ZMK_SPLIT_BLE_PERIPHERAL_COUNT) {
   2a758:	2800      	cmp	r0, #0
   2a75a:	d14a      	bne.n	2a7f2 <release_peripheral_slot+0xa2>
    if (slot->state == PERIPHERAL_SLOT_STATE_OPEN) {
   2a75c:	4d26      	ldr	r5, [pc, #152]	; (2a7f8 <release_peripheral_slot+0xa8>)
   2a75e:	782b      	ldrb	r3, [r5, #0]
   2a760:	2b00      	cmp	r3, #0
   2a762:	d046      	beq.n	2a7f2 <release_peripheral_slot+0xa2>
    if (slot->conn != NULL) {
   2a764:	6868      	ldr	r0, [r5, #4]
   2a766:	b110      	cbz	r0, 2a76e <release_peripheral_slot+0x1e>
        bt_conn_unref(slot->conn);
   2a768:	f021 fb2d 	bl	4bdc6 <bt_conn_unref>
        slot->conn = NULL;
   2a76c:	606c      	str	r4, [r5, #4]
    slot->state = PERIPHERAL_SLOT_STATE_OPEN;
   2a76e:	2400      	movs	r4, #0
   2a770:	4f22      	ldr	r7, [pc, #136]	; (2a7fc <release_peripheral_slot+0xac>)
   2a772:	f8df 908c 	ldr.w	r9, [pc, #140]	; 2a800 <release_peripheral_slot+0xb0>
                k_work_submit(&peripheral_event_work);
   2a776:	f8df a08c 	ldr.w	sl, [pc, #140]	; 2a804 <release_peripheral_slot+0xb4>
    slot->state = PERIPHERAL_SLOT_STATE_OPEN;
   2a77a:	702c      	strb	r4, [r5, #0]
                struct zmk_position_state_changed ev = {.source = index,
   2a77c:	46a0      	mov	r8, r4
        for (int j = 0; j < 8; j++) {
   2a77e:	2600      	movs	r6, #0
            if (slot->position_state[i] & BIT(j)) {
   2a780:	783b      	ldrb	r3, [r7, #0]
   2a782:	40f3      	lsrs	r3, r6
   2a784:	07db      	lsls	r3, r3, #31
   2a786:	d51c      	bpl.n	2a7c2 <release_peripheral_slot+0x72>
                struct zmk_position_state_changed ev = {.source = index,
   2a788:	1933      	adds	r3, r6, r4
   2a78a:	f88d 8000 	strb.w	r8, [sp]
   2a78e:	9301      	str	r3, [sp, #4]
   2a790:	f88d 8008 	strb.w	r8, [sp, #8]
	return z_impl_k_uptime_ticks();
   2a794:	f025 fde4 	bl	50360 <z_impl_k_uptime_ticks>
   2a798:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   2a79c:	fba0 0302 	umull	r0, r3, r0, r2
   2a7a0:	fb02 3101 	mla	r1, r2, r1, r3
   2a7a4:	0bc0      	lsrs	r0, r0, #15
   2a7a6:	ea40 4041 	orr.w	r0, r0, r1, lsl #17
   2a7aa:	0bc9      	lsrs	r1, r1, #15
   2a7ac:	e9cd 0104 	strd	r0, r1, [sp, #16]
	return z_impl_k_msgq_put(msgq, data, timeout);
   2a7b0:	2200      	movs	r2, #0
   2a7b2:	2300      	movs	r3, #0
   2a7b4:	4669      	mov	r1, sp
   2a7b6:	4648      	mov	r0, r9
   2a7b8:	f01c fb44 	bl	46e44 <z_impl_k_msgq_put>
                k_work_submit(&peripheral_event_work);
   2a7bc:	4650      	mov	r0, sl
   2a7be:	f01c fe79 	bl	474b4 <k_work_submit>
        for (int j = 0; j < 8; j++) {
   2a7c2:	3601      	adds	r6, #1
   2a7c4:	2e08      	cmp	r6, #8
   2a7c6:	d1db      	bne.n	2a780 <release_peripheral_slot+0x30>
    for (int i = 0; i < POSITION_STATE_DATA_LEN; i++) {
   2a7c8:	3408      	adds	r4, #8
   2a7ca:	2c80      	cmp	r4, #128	; 0x80
   2a7cc:	f107 0701 	add.w	r7, r7, #1
   2a7d0:	d1d5      	bne.n	2a77e <release_peripheral_slot+0x2e>
    for (int i = 0; i < POSITION_STATE_DATA_LEN; i++) {
   2a7d2:	2200      	movs	r2, #0
   2a7d4:	490c      	ldr	r1, [pc, #48]	; (2a808 <release_peripheral_slot+0xb8>)
        slot->position_state[i] = 0U;
   2a7d6:	4613      	mov	r3, r2
   2a7d8:	f801 3f01 	strb.w	r3, [r1, #1]!
    for (int i = 0; i < POSITION_STATE_DATA_LEN; i++) {
   2a7dc:	3201      	adds	r2, #1
   2a7de:	2a10      	cmp	r2, #16
        slot->changed_positions[i] = 0U;
   2a7e0:	740b      	strb	r3, [r1, #16]
    for (int i = 0; i < POSITION_STATE_DATA_LEN; i++) {
   2a7e2:	d1f9      	bne.n	2a7d8 <release_peripheral_slot+0x88>
    slot->subscribe_params.value_handle = 0;
   2a7e4:	85ab      	strh	r3, [r5, #44]	; 0x2c
    slot->run_behavior_handle = 0;
   2a7e6:	f8a5 3080 	strh.w	r3, [r5, #128]	; 0x80
   2a7ea:	2000      	movs	r0, #0
}
   2a7ec:	b006      	add	sp, #24
   2a7ee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        return -EINVAL;
   2a7f2:	f06f 0015 	mvn.w	r0, #21
   2a7f6:	e7f9      	b.n	2a7ec <release_peripheral_slot+0x9c>
   2a7f8:	20003894 	.word	0x20003894
   2a7fc:	20003916 	.word	0x20003916
   2a800:	2000111c 	.word	0x2000111c
   2a804:	20000524 	.word	0x20000524
   2a808:	20003915 	.word	0x20003915

0002a80c <reserve_peripheral_slot>:
int reserve_peripheral_slot(const bt_addr_le_t *addr) {
   2a80c:	b570      	push	{r4, r5, r6, lr}
    int i = zmk_ble_put_peripheral_addr(addr);
   2a80e:	f7ff fb87 	bl	29f20 <zmk_ble_put_peripheral_addr>
    if (i >= 0) {
   2a812:	1e04      	subs	r4, r0, #0
   2a814:	db0a      	blt.n	2a82c <reserve_peripheral_slot+0x20>
        if (peripherals[i].state == PERIPHERAL_SLOT_STATE_OPEN) {
   2a816:	25a4      	movs	r5, #164	; 0xa4
   2a818:	4e06      	ldr	r6, [pc, #24]	; (2a834 <reserve_peripheral_slot+0x28>)
   2a81a:	4365      	muls	r5, r4
   2a81c:	5d73      	ldrb	r3, [r6, r5]
   2a81e:	b92b      	cbnz	r3, 2a82c <reserve_peripheral_slot+0x20>
            release_peripheral_slot(i);
   2a820:	f7ff ff96 	bl	2a750 <release_peripheral_slot>
            peripherals[i].state = PERIPHERAL_SLOT_STATE_CONNECTING;
   2a824:	2301      	movs	r3, #1
   2a826:	5573      	strb	r3, [r6, r5]
}
   2a828:	4620      	mov	r0, r4
   2a82a:	bd70      	pop	{r4, r5, r6, pc}
    return -ENOMEM;
   2a82c:	f06f 040b 	mvn.w	r4, #11
   2a830:	e7fa      	b.n	2a828 <reserve_peripheral_slot+0x1c>
   2a832:	bf00      	nop
   2a834:	20003894 	.word	0x20003894

0002a838 <split_central_eir_found>:
static bool split_central_eir_found(const bt_addr_le_t *addr) {
   2a838:	b570      	push	{r4, r5, r6, lr}
   2a83a:	b086      	sub	sp, #24
   2a83c:	4606      	mov	r6, r0
    int slot_idx = reserve_peripheral_slot(addr);
   2a83e:	f7ff ffe5 	bl	2a80c <reserve_peripheral_slot>
    if (slot_idx < 0) {
   2a842:	1e04      	subs	r4, r0, #0
   2a844:	db20      	blt.n	2a888 <split_central_eir_found+0x50>
    is_scanning = false;
   2a846:	4b12      	ldr	r3, [pc, #72]	; (2a890 <split_central_eir_found+0x58>)
   2a848:	2200      	movs	r2, #0
   2a84a:	701a      	strb	r2, [r3, #0]
    int err = bt_le_scan_stop();
   2a84c:	f004 ffb0 	bl	2f7b0 <bt_le_scan_stop>
    if (err < 0) {
   2a850:	2800      	cmp	r0, #0
   2a852:	db19      	blt.n	2a888 <split_central_eir_found+0x50>
        BT_LE_CONN_PARAM(CONFIG_ZMK_SPLIT_BLE_PREF_INT, CONFIG_ZMK_SPLIT_BLE_PREF_INT,
   2a854:	4b0f      	ldr	r3, [pc, #60]	; (2a894 <split_central_eir_found+0x5c>)
   2a856:	6d98      	ldr	r0, [r3, #88]	; 0x58
   2a858:	6dd9      	ldr	r1, [r3, #92]	; 0x5c
   2a85a:	466a      	mov	r2, sp
   2a85c:	c203      	stmia	r2!, {r0, r1}
    err = bt_conn_le_create(addr, BT_CONN_LE_CREATE_CONN, param, &slot->conn);
   2a85e:	3360      	adds	r3, #96	; 0x60
   2a860:	4615      	mov	r5, r2
   2a862:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
   2a864:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
   2a868:	4b0b      	ldr	r3, [pc, #44]	; (2a898 <split_central_eir_found+0x60>)
   2a86a:	22a4      	movs	r2, #164	; 0xa4
   2a86c:	fb02 3304 	mla	r3, r2, r4, r3
   2a870:	4629      	mov	r1, r5
   2a872:	466a      	mov	r2, sp
   2a874:	4630      	mov	r0, r6
   2a876:	f005 fd2d 	bl	302d4 <bt_conn_le_create>
    if (err < 0) {
   2a87a:	2800      	cmp	r0, #0
   2a87c:	da04      	bge.n	2a888 <split_central_eir_found+0x50>
        release_peripheral_slot(slot_idx);
   2a87e:	4620      	mov	r0, r4
   2a880:	f7ff ff66 	bl	2a750 <release_peripheral_slot>
        start_scanning();
   2a884:	f7ff fcb0 	bl	2a1e8 <start_scanning>
}
   2a888:	2000      	movs	r0, #0
   2a88a:	b006      	add	sp, #24
   2a88c:	bd70      	pop	{r4, r5, r6, pc}
   2a88e:	bf00      	nop
   2a890:	20006af2 	.word	0x20006af2
   2a894:	00050d34 	.word	0x00050d34
   2a898:	20003898 	.word	0x20003898

0002a89c <split_central_device_found>:
                                       struct net_buf_simple *ad) {
   2a89c:	b570      	push	{r4, r5, r6, lr}
   2a89e:	b088      	sub	sp, #32
   2a8a0:	4615      	mov	r5, r2
    bt_addr_le_to_str(addr, dev, sizeof(dev));
   2a8a2:	4669      	mov	r1, sp
                                       struct net_buf_simple *ad) {
   2a8a4:	4604      	mov	r4, r0
   2a8a6:	461e      	mov	r6, r3
    bt_addr_le_to_str(addr, dev, sizeof(dev));
   2a8a8:	f7ff fd08 	bl	2a2bc <bt_addr_le_to_str.constprop.0.isra.0>
    if (type == BT_GAP_ADV_TYPE_ADV_IND) {
   2a8ac:	b935      	cbnz	r5, 2a8bc <split_central_device_found+0x20>
        bt_data_parse(ad, split_central_eir_parse, (void *)addr);
   2a8ae:	4906      	ldr	r1, [pc, #24]	; (2a8c8 <split_central_device_found+0x2c>)
   2a8b0:	4622      	mov	r2, r4
   2a8b2:	4630      	mov	r0, r6
   2a8b4:	f020 ff33 	bl	4b71e <bt_data_parse>
}
   2a8b8:	b008      	add	sp, #32
   2a8ba:	bd70      	pop	{r4, r5, r6, pc}
    } else if (type == BT_GAP_ADV_TYPE_ADV_DIRECT_IND) {
   2a8bc:	2d01      	cmp	r5, #1
   2a8be:	d1fb      	bne.n	2a8b8 <split_central_device_found+0x1c>
        split_central_eir_found(addr);
   2a8c0:	4620      	mov	r0, r4
   2a8c2:	f7ff ffb9 	bl	2a838 <split_central_eir_found>
}
   2a8c6:	e7f7      	b.n	2a8b8 <split_central_device_found+0x1c>
   2a8c8:	0002a8cd 	.word	0x0002a8cd

0002a8cc <split_central_eir_parse>:
static bool split_central_eir_parse(struct bt_data *data, void *user_data) {
   2a8cc:	b5f0      	push	{r4, r5, r6, r7, lr}
    switch (data->type) {
   2a8ce:	7803      	ldrb	r3, [r0, #0]
   2a8d0:	3b06      	subs	r3, #6
   2a8d2:	2b01      	cmp	r3, #1
static bool split_central_eir_parse(struct bt_data *data, void *user_data) {
   2a8d4:	b0a5      	sub	sp, #148	; 0x94
   2a8d6:	4605      	mov	r5, r0
   2a8d8:	460e      	mov	r6, r1
    switch (data->type) {
   2a8da:	d902      	bls.n	2a8e2 <split_central_eir_parse+0x16>
            return true;
   2a8dc:	2001      	movs	r0, #1
}
   2a8de:	b025      	add	sp, #148	; 0x94
   2a8e0:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if (data->data_len % 16 != 0U) {
   2a8e2:	7844      	ldrb	r4, [r0, #1]
   2a8e4:	f014 040f 	ands.w	r4, r4, #15
   2a8e8:	d1f8      	bne.n	2a8dc <split_central_eir_parse+0x10>
        for (i = 0; i < data->data_len; i += 16) {
   2a8ea:	786b      	ldrb	r3, [r5, #1]
   2a8ec:	429c      	cmp	r4, r3
   2a8ee:	daf5      	bge.n	2a8dc <split_central_eir_parse+0x10>
            if (!bt_uuid_create(&uuid.uuid, &data->data[i], 16)) {
   2a8f0:	6869      	ldr	r1, [r5, #4]
   2a8f2:	2210      	movs	r2, #16
   2a8f4:	4421      	add	r1, r4
   2a8f6:	a801      	add	r0, sp, #4
   2a8f8:	f020 fbae 	bl	4b058 <bt_uuid_create>
   2a8fc:	b370      	cbz	r0, 2a95c <split_central_eir_parse+0x90>
            if (bt_uuid_cmp(&uuid.uuid, BT_UUID_DECLARE_128(ZMK_SPLIT_BT_SERVICE_UUID)) != 0) {
   2a8fe:	4b1a      	ldr	r3, [pc, #104]	; (2a968 <split_central_eir_parse+0x9c>)
   2a900:	aa06      	add	r2, sp, #24
   2a902:	f103 0710 	add.w	r7, r3, #16
   2a906:	4696      	mov	lr, r2
   2a908:	6818      	ldr	r0, [r3, #0]
   2a90a:	6859      	ldr	r1, [r3, #4]
   2a90c:	4694      	mov	ip, r2
   2a90e:	e8ac 0003 	stmia.w	ip!, {r0, r1}
   2a912:	3308      	adds	r3, #8
   2a914:	42bb      	cmp	r3, r7
   2a916:	4662      	mov	r2, ip
   2a918:	d1f6      	bne.n	2a908 <split_central_eir_parse+0x3c>
   2a91a:	781b      	ldrb	r3, [r3, #0]
   2a91c:	f88c 3000 	strb.w	r3, [ip]
   2a920:	4671      	mov	r1, lr
   2a922:	a801      	add	r0, sp, #4
   2a924:	f020 fb6a 	bl	4affc <bt_uuid_cmp>
   2a928:	b1d0      	cbz	r0, 2a960 <split_central_eir_parse+0x94>
                bt_uuid_to_str(&uuid.uuid, uuid_str, sizeof(uuid_str));
   2a92a:	2225      	movs	r2, #37	; 0x25
   2a92c:	a910      	add	r1, sp, #64	; 0x40
   2a92e:	a801      	add	r0, sp, #4
   2a930:	f003 f82c 	bl	2d98c <bt_uuid_to_str>
                bt_uuid_to_str(BT_UUID_DECLARE_128(ZMK_SPLIT_BT_SERVICE_UUID), service_uuid_str,
   2a934:	aa0b      	add	r2, sp, #44	; 0x2c
   2a936:	4b0c      	ldr	r3, [pc, #48]	; (2a968 <split_central_eir_parse+0x9c>)
   2a938:	4696      	mov	lr, r2
   2a93a:	6818      	ldr	r0, [r3, #0]
   2a93c:	6859      	ldr	r1, [r3, #4]
   2a93e:	4694      	mov	ip, r2
   2a940:	e8ac 0003 	stmia.w	ip!, {r0, r1}
   2a944:	3308      	adds	r3, #8
   2a946:	42bb      	cmp	r3, r7
   2a948:	4662      	mov	r2, ip
   2a94a:	d1f6      	bne.n	2a93a <split_central_eir_parse+0x6e>
   2a94c:	781b      	ldrb	r3, [r3, #0]
   2a94e:	f88c 3000 	strb.w	r3, [ip]
   2a952:	2225      	movs	r2, #37	; 0x25
   2a954:	a91a      	add	r1, sp, #104	; 0x68
   2a956:	4670      	mov	r0, lr
   2a958:	f003 f818 	bl	2d98c <bt_uuid_to_str>
        for (i = 0; i < data->data_len; i += 16) {
   2a95c:	3410      	adds	r4, #16
   2a95e:	e7c4      	b.n	2a8ea <split_central_eir_parse+0x1e>
            return split_central_eir_found(addr);
   2a960:	4630      	mov	r0, r6
   2a962:	f7ff ff69 	bl	2a838 <split_central_eir_found>
   2a966:	e7ba      	b.n	2a8de <split_central_eir_parse+0x12>
   2a968:	00050d48 	.word	0x00050d48

0002a96c <confirm_peripheral_slot_conn>:
int confirm_peripheral_slot_conn(struct bt_conn *conn) {
   2a96c:	b508      	push	{r3, lr}
    int idx = peripheral_slot_index_for_conn(conn);
   2a96e:	f7ff fd8b 	bl	2a488 <peripheral_slot_index_for_conn>
    if (idx < 0) {
   2a972:	2800      	cmp	r0, #0
   2a974:	db05      	blt.n	2a982 <confirm_peripheral_slot_conn+0x16>
    peripherals[idx].state = PERIPHERAL_SLOT_STATE_CONNECTED;
   2a976:	23a4      	movs	r3, #164	; 0xa4
   2a978:	4358      	muls	r0, r3
   2a97a:	4b02      	ldr	r3, [pc, #8]	; (2a984 <confirm_peripheral_slot_conn+0x18>)
   2a97c:	2202      	movs	r2, #2
   2a97e:	541a      	strb	r2, [r3, r0]
    return 0;
   2a980:	2000      	movs	r0, #0
}
   2a982:	bd08      	pop	{r3, pc}
   2a984:	20003894 	.word	0x20003894

0002a988 <split_central_connected>:
static void split_central_connected(struct bt_conn *conn, uint8_t conn_err) {
   2a988:	b530      	push	{r4, r5, lr}
   2a98a:	b09b      	sub	sp, #108	; 0x6c
   2a98c:	4604      	mov	r4, r0
   2a98e:	460d      	mov	r5, r1
    bt_addr_le_to_str(bt_conn_get_dst(conn), addr, sizeof(addr));
   2a990:	f021 faf2 	bl	4bf78 <bt_conn_get_dst>
   2a994:	4669      	mov	r1, sp
   2a996:	f7ff fc91 	bl	2a2bc <bt_addr_le_to_str.constprop.0.isra.0>
    bt_conn_get_info(conn, &info);
   2a99a:	a908      	add	r1, sp, #32
   2a99c:	4620      	mov	r0, r4
   2a99e:	f005 fc37 	bl	30210 <bt_conn_get_info>
    if (info.role != BT_CONN_ROLE_CENTRAL) {
   2a9a2:	f89d 3021 	ldrb.w	r3, [sp, #33]	; 0x21
   2a9a6:	b92b      	cbnz	r3, 2a9b4 <split_central_connected+0x2c>
        release_peripheral_slot_for_conn(conn);
   2a9a8:	4620      	mov	r0, r4
    if (conn_err) {
   2a9aa:	b12d      	cbz	r5, 2a9b8 <split_central_connected+0x30>
        release_peripheral_slot_for_conn(conn);
   2a9ac:	f01d ff4c 	bl	48848 <release_peripheral_slot_for_conn>
    start_scanning();
   2a9b0:	f7ff fc1a 	bl	2a1e8 <start_scanning>
}
   2a9b4:	b01b      	add	sp, #108	; 0x6c
   2a9b6:	bd30      	pop	{r4, r5, pc}
    confirm_peripheral_slot_conn(conn);
   2a9b8:	f7ff ffd8 	bl	2a96c <confirm_peripheral_slot_conn>
    err = bt_conn_set_security(conn, BT_SECURITY_L2);
   2a9bc:	2102      	movs	r1, #2
   2a9be:	4620      	mov	r0, r4
   2a9c0:	f021 fa88 	bl	4bed4 <bt_conn_set_security>
    if (err) {
   2a9c4:	2800      	cmp	r0, #0
   2a9c6:	d1f5      	bne.n	2a9b4 <split_central_connected+0x2c>
    struct peripheral_slot *slot = peripheral_slot_for_conn(conn);
   2a9c8:	4620      	mov	r0, r4
   2a9ca:	f7ff fd67 	bl	2a49c <peripheral_slot_for_conn>
    if (slot == NULL) {
   2a9ce:	2800      	cmp	r0, #0
   2a9d0:	d0f0      	beq.n	2a9b4 <split_central_connected+0x2c>
    if (!slot->subscribe_params.value_handle) {
   2a9d2:	8d83      	ldrh	r3, [r0, #44]	; 0x2c
   2a9d4:	b123      	cbz	r3, 2a9e0 <split_central_connected+0x58>
    bt_conn_get_info(conn, &info);
   2a9d6:	a911      	add	r1, sp, #68	; 0x44
   2a9d8:	4620      	mov	r0, r4
   2a9da:	f005 fc19 	bl	30210 <bt_conn_get_info>
   2a9de:	e7e7      	b.n	2a9b0 <split_central_connected+0x28>
        slot->discover_params.uuid = &split_service_uuid.uuid;
   2a9e0:	4a08      	ldr	r2, [pc, #32]	; (2aa04 <split_central_connected+0x7c>)
   2a9e2:	6082      	str	r2, [r0, #8]
        slot->discover_params.func = split_central_service_discovery_func;
   2a9e4:	4a08      	ldr	r2, [pc, #32]	; (2aa08 <split_central_connected+0x80>)
   2a9e6:	60c2      	str	r2, [r0, #12]
        slot->discover_params.start_handle = 0x0001;
   2a9e8:	2201      	movs	r2, #1
   2a9ea:	8202      	strh	r2, [r0, #16]
        slot->discover_params.end_handle = 0xffff;
   2a9ec:	f64f 72ff 	movw	r2, #65535	; 0xffff
   2a9f0:	82c2      	strh	r2, [r0, #22]
        slot->discover_params.type = BT_GATT_DISCOVER_PRIMARY;
   2a9f2:	7603      	strb	r3, [r0, #24]
        err = bt_gatt_discover(slot->conn, &slot->discover_params);
   2a9f4:	f100 0108 	add.w	r1, r0, #8
   2a9f8:	6840      	ldr	r0, [r0, #4]
   2a9fa:	f007 fe91 	bl	32720 <bt_gatt_discover>
        if (err) {
   2a9fe:	2800      	cmp	r0, #0
   2aa00:	d0e9      	beq.n	2a9d6 <split_central_connected+0x4e>
   2aa02:	e7d7      	b.n	2a9b4 <split_central_connected+0x2c>
   2aa04:	0005331d 	.word	0x0005331d
   2aa08:	0002a4b9 	.word	0x0002a4b9

0002aa0c <usb_status_cb>:
        return ZMK_USB_CONN_POWERED;
    }
}

void usb_status_cb(enum usb_dc_status_code status, const uint8_t *params) {
    usb_status = status;
   2aa0c:	4b02      	ldr	r3, [pc, #8]	; (2aa18 <usb_status_cb+0xc>)
   2aa0e:	7018      	strb	r0, [r3, #0]
    k_work_submit(&usb_status_notifier_work);
   2aa10:	4802      	ldr	r0, [pc, #8]	; (2aa1c <usb_status_cb+0x10>)
   2aa12:	f01c bd4f 	b.w	474b4 <k_work_submit>
   2aa16:	bf00      	nop
   2aa18:	20000f96 	.word	0x20000f96
   2aa1c:	20000534 	.word	0x20000534

0002aa20 <zmk_usb_init>:
};

static int zmk_usb_init(const struct device *_arg) {
   2aa20:	b508      	push	{r3, lr}
    int usb_enable_ret;

    usb_enable_ret = usb_enable(usb_status_cb);
   2aa22:	4804      	ldr	r0, [pc, #16]	; (2aa34 <zmk_usb_init+0x14>)
   2aa24:	f001 fa54 	bl	2bed0 <usb_enable>

    if (usb_enable_ret != 0) {
        LOG_ERR("Unable to enable USB");
        return -EINVAL;
   2aa28:	2800      	cmp	r0, #0
    }

    return 0;
}
   2aa2a:	bf18      	it	ne
   2aa2c:	f06f 0015 	mvnne.w	r0, #21
   2aa30:	bd08      	pop	{r3, pc}
   2aa32:	bf00      	nop
   2aa34:	0002aa0d 	.word	0x0002aa0d

0002aa38 <zmk_usb_get_status>:
enum usb_dc_status_code zmk_usb_get_status() { return usb_status; }
   2aa38:	4b01      	ldr	r3, [pc, #4]	; (2aa40 <zmk_usb_get_status+0x8>)
   2aa3a:	7818      	ldrb	r0, [r3, #0]
   2aa3c:	4770      	bx	lr
   2aa3e:	bf00      	nop
   2aa40:	20000f96 	.word	0x20000f96

0002aa44 <zmk_usb_get_conn_state>:
    switch (usb_status) {
   2aa44:	4b08      	ldr	r3, [pc, #32]	; (2aa68 <zmk_usb_get_conn_state+0x24>)
   2aa46:	781b      	ldrb	r3, [r3, #0]
   2aa48:	2b0b      	cmp	r3, #11
   2aa4a:	f04f 0001 	mov.w	r0, #1
   2aa4e:	d80a      	bhi.n	2aa66 <zmk_usb_get_conn_state+0x22>
   2aa50:	4098      	lsls	r0, r3
   2aa52:	f410 7f1a 	tst.w	r0, #616	; 0x268
   2aa56:	d105      	bne.n	2aa64 <zmk_usb_get_conn_state+0x20>
   2aa58:	f410 6f01 	tst.w	r0, #2064	; 0x810
   2aa5c:	bf0c      	ite	eq
   2aa5e:	2001      	moveq	r0, #1
   2aa60:	2000      	movne	r0, #0
   2aa62:	4770      	bx	lr
        return ZMK_USB_CONN_HID;
   2aa64:	2002      	movs	r0, #2
}
   2aa66:	4770      	bx	lr
   2aa68:	20000f96 	.word	0x20000f96

0002aa6c <zmk_usb_hid_init>:

        return err;
    }
}

static int zmk_usb_hid_init(const struct device *_arg) {
   2aa6c:	b510      	push	{r4, lr}
   2aa6e:	4809      	ldr	r0, [pc, #36]	; (2aa94 <zmk_usb_hid_init+0x28>)
    hid_dev = device_get_binding("HID_0");
   2aa70:	4c09      	ldr	r4, [pc, #36]	; (2aa98 <zmk_usb_hid_init+0x2c>)
   2aa72:	f01b ffcb 	bl	46a0c <z_impl_device_get_binding>
   2aa76:	6020      	str	r0, [r4, #0]
    if (hid_dev == NULL) {
   2aa78:	b148      	cbz	r0, 2aa8e <zmk_usb_hid_init+0x22>
        LOG_ERR("Unable to locate HID device");
        return -EINVAL;
    }

    usb_hid_register_device(hid_dev, zmk_hid_report_desc, sizeof(zmk_hid_report_desc), &ops);
   2aa7a:	4b08      	ldr	r3, [pc, #32]	; (2aa9c <zmk_usb_hid_init+0x30>)
   2aa7c:	4908      	ldr	r1, [pc, #32]	; (2aaa0 <zmk_usb_hid_init+0x34>)
   2aa7e:	224d      	movs	r2, #77	; 0x4d
   2aa80:	f017 fff8 	bl	42a74 <usb_hid_register_device>
    usb_hid_init(hid_dev);
   2aa84:	6820      	ldr	r0, [r4, #0]
   2aa86:	f024 f9ee 	bl	4ee66 <usb_hid_init>

    return 0;
   2aa8a:	2000      	movs	r0, #0
}
   2aa8c:	bd10      	pop	{r4, pc}
        return -EINVAL;
   2aa8e:	f06f 0015 	mvn.w	r0, #21
   2aa92:	e7fb      	b.n	2aa8c <zmk_usb_hid_init+0x20>
   2aa94:	0005332e 	.word	0x0005332e
   2aa98:	20003938 	.word	0x20003938
   2aa9c:	00051a38 	.word	0x00051a38
   2aaa0:	00053334 	.word	0x00053334

0002aaa4 <in_ready_cb>:
	z_impl_k_sem_give(sem);
   2aaa4:	4801      	ldr	r0, [pc, #4]	; (2aaac <in_ready_cb+0x8>)
   2aaa6:	f01c bb67 	b.w	47178 <z_impl_k_sem_give>
   2aaaa:	bf00      	nop
   2aaac:	2000126c 	.word	0x2000126c

0002aab0 <zmk_usb_hid_send_report>:
int zmk_usb_hid_send_report(const uint8_t *report, size_t len) {
   2aab0:	b538      	push	{r3, r4, r5, lr}
   2aab2:	4604      	mov	r4, r0
   2aab4:	460d      	mov	r5, r1
    switch (zmk_usb_get_status()) {
   2aab6:	f7ff ffbf 	bl	2aa38 <zmk_usb_get_status>
   2aaba:	280b      	cmp	r0, #11
   2aabc:	d80b      	bhi.n	2aad6 <zmk_usb_hid_send_report+0x26>
   2aabe:	e8df f000 	tbb	[pc, r0]
   2aac2:	1e1e      	.short	0x1e1e
   2aac4:	061e0a0a 	.word	0x061e0a0a
   2aac8:	0a0a0a0a 	.word	0x0a0a0a0a
   2aacc:	1e0a      	.short	0x1e0a
}
   2aace:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        return usb_wakeup_request();
   2aad2:	f001 b9c7 	b.w	2be64 <usb_wakeup_request>
	return z_impl_k_sem_take(sem, timeout);
   2aad6:	f44f 7276 	mov.w	r2, #984	; 0x3d8
   2aada:	2300      	movs	r3, #0
   2aadc:	4809      	ldr	r0, [pc, #36]	; (2ab04 <zmk_usb_hid_send_report+0x54>)
   2aade:	f01c fb71 	bl	471c4 <z_impl_k_sem_take>
        int err = hid_int_ep_write(hid_dev, report, len, NULL);
   2aae2:	4809      	ldr	r0, [pc, #36]	; (2ab08 <zmk_usb_hid_send_report+0x58>)
   2aae4:	4621      	mov	r1, r4
   2aae6:	6800      	ldr	r0, [r0, #0]
   2aae8:	2300      	movs	r3, #0
   2aaea:	462a      	mov	r2, r5
   2aaec:	f024 f9c5 	bl	4ee7a <hid_int_ep_write>
        if (err) {
   2aaf0:	4604      	mov	r4, r0
   2aaf2:	b110      	cbz	r0, 2aafa <zmk_usb_hid_send_report+0x4a>
	z_impl_k_sem_give(sem);
   2aaf4:	4803      	ldr	r0, [pc, #12]	; (2ab04 <zmk_usb_hid_send_report+0x54>)
   2aaf6:	f01c fb3f 	bl	47178 <z_impl_k_sem_give>
}
   2aafa:	4620      	mov	r0, r4
   2aafc:	bd38      	pop	{r3, r4, r5, pc}
    switch (zmk_usb_get_status()) {
   2aafe:	f06f 0412 	mvn.w	r4, #18
   2ab02:	e7fa      	b.n	2aafa <zmk_usb_hid_send_report+0x4a>
   2ab04:	2000126c 	.word	0x2000126c
   2ab08:	20003938 	.word	0x20003938

0002ab0c <workqueue_init>:

struct k_work_q *zmk_workqueue_lowprio_work_q() {
    return &lowprio_work_q;
}

static int workqueue_init() {
   2ab0c:	b507      	push	{r0, r1, r2, lr}
    static const struct k_work_queue_config queue_config = {.name = "Low Priority Work Queue"};
    k_work_queue_start(&lowprio_work_q, lowprio_q_stack, K_THREAD_STACK_SIZEOF(lowprio_q_stack),
   2ab0e:	4b06      	ldr	r3, [pc, #24]	; (2ab28 <workqueue_init+0x1c>)
   2ab10:	9300      	str	r3, [sp, #0]
   2ab12:	4906      	ldr	r1, [pc, #24]	; (2ab2c <workqueue_init+0x20>)
   2ab14:	4806      	ldr	r0, [pc, #24]	; (2ab30 <workqueue_init+0x24>)
   2ab16:	230a      	movs	r3, #10
   2ab18:	f44f 7240 	mov.w	r2, #768	; 0x300
   2ab1c:	f01c fcd0 	bl	474c0 <k_work_queue_start>
                       CONFIG_ZMK_LOW_PRIORITY_THREAD_PRIORITY, &queue_config);
    return 0;
}
   2ab20:	2000      	movs	r0, #0
   2ab22:	b003      	add	sp, #12
   2ab24:	f85d fb04 	ldr.w	pc, [sp], #4
   2ab28:	00051a4c 	.word	0x00051a4c
   2ab2c:	200070c8 	.word	0x200070c8
   2ab30:	20001668 	.word	0x20001668

0002ab34 <zmk_workqueue_lowprio_work_q>:
}
   2ab34:	4800      	ldr	r0, [pc, #0]	; (2ab38 <zmk_workqueue_lowprio_work_q+0x4>)
   2ab36:	4770      	bx	lr
   2ab38:	20001668 	.word	0x20001668

0002ab3c <main>:
#include <drivers/ext_power.h>

void main(void) {
    LOG_INF("Welcome to ZMK!\n");

    if (zmk_kscan_init(DEVICE_DT_GET(ZMK_MATRIX_NODE_ID)) != 0) {
   2ab3c:	4801      	ldr	r0, [pc, #4]	; (2ab44 <main+0x8>)
   2ab3e:	f7fe b8a1 	b.w	28c84 <zmk_kscan_init>
   2ab42:	bf00      	nop
   2ab44:	00050a24 	.word	0x00050a24

0002ab48 <crc8_ccitt>:
	0x00, 0x07, 0x0e, 0x09, 0x1c, 0x1b, 0x12, 0x15,
	0x38, 0x3f, 0x36, 0x31, 0x24, 0x23, 0x2a, 0x2d
};

uint8_t crc8_ccitt(uint8_t val, const void *buf, size_t cnt)
{
   2ab48:	b510      	push	{r4, lr}
	size_t i;
	const uint8_t *p = buf;

	for (i = 0; i < cnt; i++) {
		val ^= p[i];
		val = (val << 4) ^ crc8_ccitt_small_table[val >> 4];
   2ab4a:	4c09      	ldr	r4, [pc, #36]	; (2ab70 <crc8_ccitt+0x28>)
   2ab4c:	440a      	add	r2, r1
	for (i = 0; i < cnt; i++) {
   2ab4e:	4291      	cmp	r1, r2
   2ab50:	d100      	bne.n	2ab54 <crc8_ccitt+0xc>
		val = (val << 4) ^ crc8_ccitt_small_table[val >> 4];
	}
	return val;
}
   2ab52:	bd10      	pop	{r4, pc}
		val ^= p[i];
   2ab54:	f811 3b01 	ldrb.w	r3, [r1], #1
   2ab58:	4058      	eors	r0, r3
		val = (val << 4) ^ crc8_ccitt_small_table[val >> 4];
   2ab5a:	0903      	lsrs	r3, r0, #4
   2ab5c:	0100      	lsls	r0, r0, #4
   2ab5e:	5ce3      	ldrb	r3, [r4, r3]
   2ab60:	b2c0      	uxtb	r0, r0
   2ab62:	4043      	eors	r3, r0
		val = (val << 4) ^ crc8_ccitt_small_table[val >> 4];
   2ab64:	0918      	lsrs	r0, r3, #4
   2ab66:	011b      	lsls	r3, r3, #4
   2ab68:	5c20      	ldrb	r0, [r4, r0]
   2ab6a:	b2db      	uxtb	r3, r3
   2ab6c:	4058      	eors	r0, r3
	for (i = 0; i < cnt; i++) {
   2ab6e:	e7ee      	b.n	2ab4e <crc8_ccitt+0x6>
   2ab70:	00053399 	.word	0x00053399

0002ab74 <char_out>:
}

static int char_out(int c, void *ctx_p)
{
	(void) ctx_p;
	return _char_out(c);
   2ab74:	4b01      	ldr	r3, [pc, #4]	; (2ab7c <char_out+0x8>)
   2ab76:	681b      	ldr	r3, [r3, #0]
   2ab78:	4718      	bx	r3
   2ab7a:	bf00      	nop
   2ab7c:	20000544 	.word	0x20000544

0002ab80 <vprintk>:
}

void vprintk(const char *fmt, va_list ap)
{
   2ab80:	b507      	push	{r0, r1, r2, lr}
   2ab82:	460b      	mov	r3, r1
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap);
#else
static inline
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap)
{
	return z_cbvprintf_impl(out, ctx, format, ap, 0);
   2ab84:	2100      	movs	r1, #0
   2ab86:	4602      	mov	r2, r0
   2ab88:	9100      	str	r1, [sp, #0]
   2ab8a:	4803      	ldr	r0, [pc, #12]	; (2ab98 <vprintk+0x18>)
   2ab8c:	f000 f92a 	bl	2ade4 <z_cbvprintf_impl>

#ifdef CONFIG_PRINTK_SYNC
		k_spin_unlock(&lock, key);
#endif
	}
}
   2ab90:	b003      	add	sp, #12
   2ab92:	f85d fb04 	ldr.w	pc, [sp], #4
   2ab96:	bf00      	nop
   2ab98:	0002ab75 	.word	0x0002ab75

0002ab9c <vsnprintk>:

	return ret;
}

int vsnprintk(char *str, size_t size, const char *fmt, va_list ap)
{
   2ab9c:	b530      	push	{r4, r5, lr}
   2ab9e:	b087      	sub	sp, #28
	struct str_context ctx = { str, size, 0 };
   2aba0:	2500      	movs	r5, #0
   2aba2:	e9cd 0103 	strd	r0, r1, [sp, #12]
{
   2aba6:	4604      	mov	r4, r0
   2aba8:	9500      	str	r5, [sp, #0]
   2abaa:	a903      	add	r1, sp, #12
   2abac:	4805      	ldr	r0, [pc, #20]	; (2abc4 <vsnprintk+0x28>)
	struct str_context ctx = { str, size, 0 };
   2abae:	9505      	str	r5, [sp, #20]
   2abb0:	f000 f918 	bl	2ade4 <z_cbvprintf_impl>

	cbvprintf(str_out, &ctx, fmt, ap);

	if (ctx.count < ctx.max) {
   2abb4:	e9dd 3004 	ldrd	r3, r0, [sp, #16]
   2abb8:	4298      	cmp	r0, r3
		str[ctx.count] = '\0';
   2abba:	bfb8      	it	lt
   2abbc:	5425      	strblt	r5, [r4, r0]
	}

	return ctx.count;
}
   2abbe:	b007      	add	sp, #28
   2abc0:	bd30      	pop	{r4, r5, pc}
   2abc2:	bf00      	nop
   2abc4:	00048a5f 	.word	0x00048a5f

0002abc8 <process_event>:
 * regions.
 */
static void process_event(struct onoff_manager *mgr,
			  int evt,
			  k_spinlock_key_t key)
{
   2abc8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	sys_slist_t clients;
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   2abcc:	8b05      	ldrh	r5, [r0, #24]
{
   2abce:	4604      	mov	r4, r0
	__ASSERT_NO_MSG(evt != EVT_NOP);

	/* If this is a nested call record the event for processing in
	 * the top invocation.
	 */
	if (processing) {
   2abd0:	0728      	lsls	r0, r5, #28
{
   2abd2:	4690      	mov	r8, r2
	if (processing) {
   2abd4:	d411      	bmi.n	2abfa <process_event+0x32>

	sys_slist_init(&clients);
	do {
		onoff_transition_fn transit = NULL;

		if (evt == EVT_RECHECK) {
   2abd6:	2902      	cmp	r1, #2
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   2abd8:	f005 0507 	and.w	r5, r5, #7
		if (evt == EVT_RECHECK) {
   2abdc:	f040 80cd 	bne.w	2ad7a <process_event+0x1b2>
			evt = process_recheck(mgr);
   2abe0:	4620      	mov	r0, r4
   2abe2:	f01d ff84 	bl	48aee <process_recheck>
		}

		if (evt == EVT_NOP) {
   2abe6:	b178      	cbz	r0, 2ac08 <process_event+0x40>
			break;
		}

		res = 0;
		if (evt == EVT_COMPLETE) {
   2abe8:	3801      	subs	r0, #1
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   2abea:	8b21      	ldrh	r1, [r4, #24]
   2abec:	2804      	cmp	r0, #4
   2abee:	d811      	bhi.n	2ac14 <process_event+0x4c>
   2abf0:	e8df f000 	tbb	[pc, r0]
   2abf4:	856d10c3 	.word	0x856d10c3
   2abf8:	95          	.byte	0x95
   2abf9:	00          	.byte	0x00
		if (evt == EVT_COMPLETE) {
   2abfa:	2901      	cmp	r1, #1
			mgr->flags |= ONOFF_FLAG_COMPLETE;
   2abfc:	bf0c      	ite	eq
   2abfe:	f045 0510 	orreq.w	r5, r5, #16
			mgr->flags |= ONOFF_FLAG_RECHECK;
   2ac02:	f045 0520 	orrne.w	r5, r5, #32
   2ac06:	8325      	strh	r5, [r4, #24]
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
   2ac08:	f388 8811 	msr	BASEPRI, r8
   2ac0c:	f3bf 8f6f 	isb	sy
		state = mgr->flags & ONOFF_STATE_MASK;
	} while (evt != EVT_NOP);

out:
	k_spin_unlock(&mgr->lock, key);
}
   2ac10:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
   2ac14:	f001 0a07 	and.w	sl, r1, #7
				   && !sys_slist_is_empty(&mgr->monitors);
   2ac18:	45aa      	cmp	sl, r5
   2ac1a:	f000 80a6 	beq.w	2ad6a <process_event+0x1a2>
	 * a memory barrier when used like this, and we don't have a
	 * Zephyr framework for that.
	 */
	atomic_clear(&l->locked);
#endif
	arch_irq_unlock(key.key);
   2ac1e:	2700      	movs	r7, #0
   2ac20:	46b9      	mov	r9, r7
   2ac22:	463e      	mov	r6, r7
   2ac24:	68a3      	ldr	r3, [r4, #8]
   2ac26:	2b00      	cmp	r3, #0
   2ac28:	f000 80bd 	beq.w	2ada6 <process_event+0x1de>
			uint32_t flags = mgr->flags | ONOFF_FLAG_PROCESSING;
   2ac2c:	f041 0108 	orr.w	r1, r1, #8
			mgr->flags = flags;
   2ac30:	8321      	strh	r1, [r4, #24]
   2ac32:	f388 8811 	msr	BASEPRI, r8
   2ac36:	f3bf 8f6f 	isb	sy
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_head(sys_slist_t *list)
{
	return list->head;
   2ac3a:	68a1      	ldr	r1, [r4, #8]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
   2ac3c:	2900      	cmp	r1, #0
   2ac3e:	f000 80bb 	beq.w	2adb8 <process_event+0x1f0>
	return node->next;
   2ac42:	680d      	ldr	r5, [r1, #0]
   2ac44:	2900      	cmp	r1, #0
   2ac46:	f000 80b7 	beq.w	2adb8 <process_event+0x1f0>
		mon->callback(mgr, mon, state, res);
   2ac4a:	f8d1 8004 	ldr.w	r8, [r1, #4]
   2ac4e:	4633      	mov	r3, r6
   2ac50:	4652      	mov	r2, sl
   2ac52:	4620      	mov	r0, r4
   2ac54:	47c0      	blx	r8
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
   2ac56:	2d00      	cmp	r5, #0
   2ac58:	d076      	beq.n	2ad48 <process_event+0x180>
   2ac5a:	682b      	ldr	r3, [r5, #0]
   2ac5c:	4629      	mov	r1, r5
   2ac5e:	461d      	mov	r5, r3
   2ac60:	e7f0      	b.n	2ac44 <process_event+0x7c>
   2ac62:	f001 0307 	and.w	r3, r1, #7
		   || (state == ONOFF_STATE_RESETTING)) {
   2ac66:	1f5a      	subs	r2, r3, #5
	} else if ((state == ONOFF_STATE_TO_ON)
   2ac68:	2a01      	cmp	r2, #1
   2ac6a:	d81b      	bhi.n	2aca4 <process_event+0xdc>
	list->head = NULL;
   2ac6c:	2200      	movs	r2, #0
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   2ac6e:	f021 0107 	bic.w	r1, r1, #7
		if (state == ONOFF_STATE_TO_ON) {
   2ac72:	2b06      	cmp	r3, #6
		*clients = mgr->clients;
   2ac74:	6827      	ldr	r7, [r4, #0]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   2ac76:	b289      	uxth	r1, r1
	list->tail = NULL;
   2ac78:	e9c4 2200 	strd	r2, r2, [r4]
		if (state == ONOFF_STATE_TO_ON) {
   2ac7c:	d109      	bne.n	2ac92 <process_event+0xca>
   2ac7e:	463b      	mov	r3, r7
   2ac80:	e003      	b.n	2ac8a <process_event+0xc2>
				mgr->refs += 1U;
   2ac82:	8b62      	ldrh	r2, [r4, #26]
   2ac84:	3201      	adds	r2, #1
   2ac86:	8362      	strh	r2, [r4, #26]
	return node->next;
   2ac88:	681b      	ldr	r3, [r3, #0]
			SYS_SLIST_FOR_EACH_CONTAINER(clients, cp, node) {
   2ac8a:	2b00      	cmp	r3, #0
   2ac8c:	d1f9      	bne.n	2ac82 <process_event+0xba>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   2ac8e:	f041 0102 	orr.w	r1, r1, #2
	mgr->flags = (state & ONOFF_STATE_MASK)
   2ac92:	8321      	strh	r1, [r4, #24]
		if (process_recheck(mgr) != EVT_NOP) {
   2ac94:	4620      	mov	r0, r4
   2ac96:	f01d ff2a 	bl	48aee <process_recheck>
   2ac9a:	2800      	cmp	r0, #0
   2ac9c:	d07b      	beq.n	2ad96 <process_event+0x1ce>
			mgr->flags |= ONOFF_FLAG_RECHECK;
   2ac9e:	f041 0120 	orr.w	r1, r1, #32
   2aca2:	e077      	b.n	2ad94 <process_event+0x1cc>
	} else if (state == ONOFF_STATE_TO_OFF) {
   2aca4:	2b04      	cmp	r3, #4
   2aca6:	d10a      	bne.n	2acbe <process_event+0xf6>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   2aca8:	f021 0107 	bic.w	r1, r1, #7
   2acac:	b289      	uxth	r1, r1
	mgr->flags = (state & ONOFF_STATE_MASK)
   2acae:	8321      	strh	r1, [r4, #24]
		if (process_recheck(mgr) != EVT_NOP) {
   2acb0:	4620      	mov	r0, r4
   2acb2:	f01d ff1c 	bl	48aee <process_recheck>
   2acb6:	b110      	cbz	r0, 2acbe <process_event+0xf6>
			mgr->flags |= ONOFF_FLAG_RECHECK;
   2acb8:	f041 0120 	orr.w	r1, r1, #32
   2acbc:	8321      	strh	r1, [r4, #24]
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
   2acbe:	8b21      	ldrh	r1, [r4, #24]
   2acc0:	f001 0a07 	and.w	sl, r1, #7
				   && !sys_slist_is_empty(&mgr->monitors);
   2acc4:	45aa      	cmp	sl, r5
   2acc6:	d050      	beq.n	2ad6a <process_event+0x1a2>
   2acc8:	2700      	movs	r7, #0
		onoff_transition_fn transit = NULL;
   2acca:	46b9      	mov	r9, r7
   2accc:	e7aa      	b.n	2ac24 <process_event+0x5c>
			transit = mgr->transitions->start;
   2acce:	6923      	ldr	r3, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   2acd0:	f021 0107 	bic.w	r1, r1, #7
   2acd4:	f041 0106 	orr.w	r1, r1, #6
				   && !sys_slist_is_empty(&mgr->monitors);
   2acd8:	2d06      	cmp	r5, #6
			transit = mgr->transitions->start;
   2acda:	f8d3 9000 	ldr.w	r9, [r3]
	mgr->flags = (state & ONOFF_STATE_MASK)
   2acde:	8321      	strh	r1, [r4, #24]
				   && !sys_slist_is_empty(&mgr->monitors);
   2ace0:	d12d      	bne.n	2ad3e <process_event+0x176>
		    || (transit != NULL)) {
   2ace2:	f1b9 0f00 	cmp.w	r9, #0
   2ace6:	d040      	beq.n	2ad6a <process_event+0x1a2>
			uint32_t flags = mgr->flags | ONOFF_FLAG_PROCESSING;
   2ace8:	f041 0108 	orr.w	r1, r1, #8
			mgr->flags = flags;
   2acec:	8321      	strh	r1, [r4, #24]
   2acee:	f388 8811 	msr	BASEPRI, r8
   2acf2:	f3bf 8f6f 	isb	sy
				transit(mgr, transition_complete);
   2acf6:	493a      	ldr	r1, [pc, #232]	; (2ade0 <process_event+0x218>)
   2acf8:	4620      	mov	r0, r4
   2acfa:	47c8      	blx	r9
   2acfc:	e029      	b.n	2ad52 <process_event+0x18a>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   2acfe:	f021 0107 	bic.w	r1, r1, #7
			transit = mgr->transitions->stop;
   2ad02:	6923      	ldr	r3, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   2ad04:	f041 0104 	orr.w	r1, r1, #4
   2ad08:	b289      	uxth	r1, r1
				   && !sys_slist_is_empty(&mgr->monitors);
   2ad0a:	2d04      	cmp	r5, #4
			transit = mgr->transitions->stop;
   2ad0c:	f8d3 9004 	ldr.w	r9, [r3, #4]
	mgr->flags = (state & ONOFF_STATE_MASK)
   2ad10:	8321      	strh	r1, [r4, #24]
				   && !sys_slist_is_empty(&mgr->monitors);
   2ad12:	d0e6      	beq.n	2ace2 <process_event+0x11a>
   2ad14:	2700      	movs	r7, #0
		res = 0;
   2ad16:	463e      	mov	r6, r7
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
   2ad18:	f04f 0a04 	mov.w	sl, #4
   2ad1c:	e782      	b.n	2ac24 <process_event+0x5c>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   2ad1e:	f021 0107 	bic.w	r1, r1, #7
			transit = mgr->transitions->reset;
   2ad22:	6923      	ldr	r3, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   2ad24:	f041 0105 	orr.w	r1, r1, #5
   2ad28:	b289      	uxth	r1, r1
				   && !sys_slist_is_empty(&mgr->monitors);
   2ad2a:	2d05      	cmp	r5, #5
			transit = mgr->transitions->reset;
   2ad2c:	f8d3 9008 	ldr.w	r9, [r3, #8]
	mgr->flags = (state & ONOFF_STATE_MASK)
   2ad30:	8321      	strh	r1, [r4, #24]
				   && !sys_slist_is_empty(&mgr->monitors);
   2ad32:	d0d6      	beq.n	2ace2 <process_event+0x11a>
   2ad34:	2700      	movs	r7, #0
		res = 0;
   2ad36:	463e      	mov	r6, r7
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
   2ad38:	f04f 0a05 	mov.w	sl, #5
   2ad3c:	e772      	b.n	2ac24 <process_event+0x5c>
				   && !sys_slist_is_empty(&mgr->monitors);
   2ad3e:	2700      	movs	r7, #0
		res = 0;
   2ad40:	463e      	mov	r6, r7
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
   2ad42:	f04f 0a06 	mov.w	sl, #6
   2ad46:	e76d      	b.n	2ac24 <process_event+0x5c>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
   2ad48:	462b      	mov	r3, r5
   2ad4a:	e787      	b.n	2ac5c <process_event+0x94>
			if (transit != NULL) {
   2ad4c:	f1b9 0f00 	cmp.w	r9, #0
   2ad50:	d1d1      	bne.n	2acf6 <process_event+0x12e>
	__asm__ volatile(
   2ad52:	f04f 0320 	mov.w	r3, #32
   2ad56:	f3ef 8811 	mrs	r8, BASEPRI
   2ad5a:	f383 8812 	msr	BASEPRI_MAX, r3
   2ad5e:	f3bf 8f6f 	isb	sy
			mgr->flags &= ~ONOFF_FLAG_PROCESSING;
   2ad62:	8b23      	ldrh	r3, [r4, #24]
   2ad64:	f023 0308 	bic.w	r3, r3, #8
   2ad68:	8323      	strh	r3, [r4, #24]
		if ((mgr->flags & ONOFF_FLAG_COMPLETE) != 0) {
   2ad6a:	8b25      	ldrh	r5, [r4, #24]
   2ad6c:	06ea      	lsls	r2, r5, #27
   2ad6e:	d52e      	bpl.n	2adce <process_event+0x206>
			mgr->flags &= ~ONOFF_FLAG_COMPLETE;
   2ad70:	f025 0310 	bic.w	r3, r5, #16
   2ad74:	8323      	strh	r3, [r4, #24]
		state = mgr->flags & ONOFF_STATE_MASK;
   2ad76:	f005 0507 	and.w	r5, r5, #7
			res = mgr->last_res;
   2ad7a:	6966      	ldr	r6, [r4, #20]
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   2ad7c:	8b21      	ldrh	r1, [r4, #24]
	if (res < 0) {
   2ad7e:	2e00      	cmp	r6, #0
   2ad80:	f6bf af6f 	bge.w	2ac62 <process_event+0x9a>
	list->head = NULL;
   2ad84:	2300      	movs	r3, #0
		*clients = mgr->clients;
   2ad86:	6827      	ldr	r7, [r4, #0]
	list->tail = NULL;
   2ad88:	e9c4 3300 	strd	r3, r3, [r4]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   2ad8c:	f021 0107 	bic.w	r1, r1, #7
   2ad90:	f041 0101 	orr.w	r1, r1, #1
			mgr->flags |= ONOFF_FLAG_RECHECK;
   2ad94:	8321      	strh	r1, [r4, #24]
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
   2ad96:	8b21      	ldrh	r1, [r4, #24]
   2ad98:	f001 0a07 	and.w	sl, r1, #7
				   && !sys_slist_is_empty(&mgr->monitors);
   2ad9c:	45aa      	cmp	sl, r5
   2ad9e:	f04f 0900 	mov.w	r9, #0
   2ada2:	f47f af3f 	bne.w	2ac24 <process_event+0x5c>
		    || !sys_slist_is_empty(&clients)
   2ada6:	2f00      	cmp	r7, #0
   2ada8:	d09b      	beq.n	2ace2 <process_event+0x11a>
			uint32_t flags = mgr->flags | ONOFF_FLAG_PROCESSING;
   2adaa:	f041 0108 	orr.w	r1, r1, #8
			mgr->flags = flags;
   2adae:	8321      	strh	r1, [r4, #24]
	__asm__ volatile(
   2adb0:	f388 8811 	msr	BASEPRI, r8
   2adb4:	f3bf 8f6f 	isb	sy
			if (!sys_slist_is_empty(&clients)) {
   2adb8:	2f00      	cmp	r7, #0
   2adba:	d0c7      	beq.n	2ad4c <process_event+0x184>
	return node->next;
   2adbc:	683d      	ldr	r5, [r7, #0]
		notify_one(mgr, cli, state, res);
   2adbe:	4639      	mov	r1, r7
   2adc0:	4633      	mov	r3, r6
   2adc2:	4652      	mov	r2, sl
   2adc4:	4620      	mov	r0, r4
   2adc6:	f01d febe 	bl	48b46 <notify_one>
	list->head = node;
   2adca:	462f      	mov	r7, r5
	while (!sys_slist_is_empty(list)) {
   2adcc:	e7f4      	b.n	2adb8 <process_event+0x1f0>
		} else if ((mgr->flags & ONOFF_FLAG_RECHECK) != 0) {
   2adce:	06ab      	lsls	r3, r5, #26
   2add0:	f57f af1a 	bpl.w	2ac08 <process_event+0x40>
			mgr->flags &= ~ONOFF_FLAG_RECHECK;
   2add4:	f025 0320 	bic.w	r3, r5, #32
			mgr->flags &= ~ONOFF_FLAG_COMPLETE;
   2add8:	8323      	strh	r3, [r4, #24]
		state = mgr->flags & ONOFF_STATE_MASK;
   2adda:	f005 0507 	and.w	r5, r5, #7
		if (evt == EVT_RECHECK) {
   2adde:	e6ff      	b.n	2abe0 <process_event+0x18>
   2ade0:	00048b73 	.word	0x00048b73

0002ade4 <z_cbvprintf_impl>:
 *
 * @return printed byte count if CONFIG_CBPRINTF_LIBC_SUBSTS is set
 */
int z_cbvprintf_impl(cbprintf_cb out, void *ctx, const char *fmt,
		     va_list ap, uint32_t flags)
{
   2ade4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2ade8:	b08d      	sub	sp, #52	; 0x34
   2adea:	461d      	mov	r5, r3

	const bool tagged_ap = (flags & Z_CBVPRINTF_PROCESS_FLAG_TAGGED_ARGS)
			       == Z_CBVPRINTF_PROCESS_FLAG_TAGGED_ARGS;

	/* we pre-increment in the loop  afterwards */
	fmt--;
   2adec:	1e53      	subs	r3, r2, #1
{
   2adee:	4682      	mov	sl, r0
   2adf0:	9101      	str	r1, [sp, #4]
	fmt--;
   2adf2:	9303      	str	r3, [sp, #12]
	size_t count = 0;
   2adf4:	f04f 0900 	mov.w	r9, #0

start:
	while (*++fmt != '%') {
   2adf8:	9b03      	ldr	r3, [sp, #12]
   2adfa:	7858      	ldrb	r0, [r3, #1]
   2adfc:	2825      	cmp	r0, #37	; 0x25
   2adfe:	f103 0401 	add.w	r4, r3, #1
   2ae02:	d119      	bne.n	2ae38 <z_cbvprintf_impl+0x54>
	prefix = "";
	padding_mode = 0;
	length_mod = 0;
	special = 0;

	for (fmt++ ; ; fmt++) {
   2ae04:	461e      	mov	r6, r3
	special = 0;
   2ae06:	2000      	movs	r0, #0
	precision = -1;
   2ae08:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
	for (fmt++ ; ; fmt++) {
   2ae0c:	3602      	adds	r6, #2
	length_mod = 0;
   2ae0e:	4603      	mov	r3, r0
	padding_mode = 0;
   2ae10:	9002      	str	r0, [sp, #8]
	min_width = -1;
   2ae12:	4644      	mov	r4, r8
		switch (*fmt) {
   2ae14:	7831      	ldrb	r1, [r6, #0]
   2ae16:	9603      	str	r6, [sp, #12]
   2ae18:	2939      	cmp	r1, #57	; 0x39
   2ae1a:	d854      	bhi.n	2aec6 <z_cbvprintf_impl+0xe2>
   2ae1c:	291f      	cmp	r1, #31
   2ae1e:	d814      	bhi.n	2ae4a <z_cbvprintf_impl+0x66>
   2ae20:	2900      	cmp	r1, #0
   2ae22:	f000 81f0 	beq.w	2b206 <z_cbvprintf_impl+0x422>
			precision = 0;
			break;
		}

		default:
			OUTC('%');
   2ae26:	9901      	ldr	r1, [sp, #4]
   2ae28:	2025      	movs	r0, #37	; 0x25
   2ae2a:	47d0      	blx	sl
			OUTC(*fmt);
   2ae2c:	9901      	ldr	r1, [sp, #4]
   2ae2e:	7830      	ldrb	r0, [r6, #0]
   2ae30:	47d0      	blx	sl
   2ae32:	f109 0902 	add.w	r9, r9, #2
			goto start;
   2ae36:	e7df      	b.n	2adf8 <z_cbvprintf_impl+0x14>
		if (*fmt == '\0') {
   2ae38:	2800      	cmp	r0, #0
   2ae3a:	f000 81e4 	beq.w	2b206 <z_cbvprintf_impl+0x422>
		OUTC(*fmt);
   2ae3e:	9901      	ldr	r1, [sp, #4]
   2ae40:	47d0      	blx	sl
   2ae42:	f109 0901 	add.w	r9, r9, #1
	while (*++fmt != '%') {
   2ae46:	9403      	str	r4, [sp, #12]
   2ae48:	e7d6      	b.n	2adf8 <z_cbvprintf_impl+0x14>
		switch (*fmt) {
   2ae4a:	f1a1 0220 	sub.w	r2, r1, #32
   2ae4e:	2a19      	cmp	r2, #25
   2ae50:	d8e9      	bhi.n	2ae26 <z_cbvprintf_impl+0x42>
   2ae52:	a701      	add	r7, pc, #4	; (adr r7, 2ae58 <z_cbvprintf_impl+0x74>)
   2ae54:	f857 f022 	ldr.w	pc, [r7, r2, lsl #2]
   2ae58:	0002aec1 	.word	0x0002aec1
   2ae5c:	0002ae27 	.word	0x0002ae27
   2ae60:	0002ae27 	.word	0x0002ae27
   2ae64:	0002aec1 	.word	0x0002aec1
   2ae68:	0002ae27 	.word	0x0002ae27
   2ae6c:	0002af41 	.word	0x0002af41
   2ae70:	0002ae27 	.word	0x0002ae27
   2ae74:	0002ae27 	.word	0x0002ae27
   2ae78:	0002ae27 	.word	0x0002ae27
   2ae7c:	0002ae27 	.word	0x0002ae27
   2ae80:	0002af8d 	.word	0x0002af8d
   2ae84:	0002aec1 	.word	0x0002aec1
   2ae88:	0002ae27 	.word	0x0002ae27
   2ae8c:	0002afa1 	.word	0x0002afa1
   2ae90:	0002af4d 	.word	0x0002af4d
   2ae94:	0002ae27 	.word	0x0002ae27
   2ae98:	0002af5b 	.word	0x0002af5b
   2ae9c:	0002af7b 	.word	0x0002af7b
   2aea0:	0002af7b 	.word	0x0002af7b
   2aea4:	0002af7b 	.word	0x0002af7b
   2aea8:	0002af7b 	.word	0x0002af7b
   2aeac:	0002af7b 	.word	0x0002af7b
   2aeb0:	0002af7b 	.word	0x0002af7b
   2aeb4:	0002af7b 	.word	0x0002af7b
   2aeb8:	0002af7b 	.word	0x0002af7b
   2aebc:	0002af7b 	.word	0x0002af7b
   2aec0:	4608      	mov	r0, r1
   2aec2:	3601      	adds	r6, #1
   2aec4:	e7a6      	b.n	2ae14 <z_cbvprintf_impl+0x30>
   2aec6:	2958      	cmp	r1, #88	; 0x58
   2aec8:	f000 80ee 	beq.w	2b0a8 <z_cbvprintf_impl+0x2c4>
   2aecc:	f1a1 0263 	sub.w	r2, r1, #99	; 0x63
   2aed0:	b2d7      	uxtb	r7, r2
   2aed2:	2f17      	cmp	r7, #23
   2aed4:	d8a7      	bhi.n	2ae26 <z_cbvprintf_impl+0x42>
   2aed6:	2a17      	cmp	r2, #23
   2aed8:	d8a5      	bhi.n	2ae26 <z_cbvprintf_impl+0x42>
   2aeda:	a701      	add	r7, pc, #4	; (adr r7, 2aee0 <z_cbvprintf_impl+0xfc>)
   2aedc:	f857 f022 	ldr.w	pc, [r7, r2, lsl #2]
   2aee0:	0002b14f 	.word	0x0002b14f
   2aee4:	0002afc7 	.word	0x0002afc7
   2aee8:	0002ae27 	.word	0x0002ae27
   2aeec:	0002ae27 	.word	0x0002ae27
   2aef0:	0002ae27 	.word	0x0002ae27
   2aef4:	0002afa7 	.word	0x0002afa7
   2aef8:	0002afc7 	.word	0x0002afc7
   2aefc:	0002ae27 	.word	0x0002ae27
   2af00:	0002ae27 	.word	0x0002ae27
   2af04:	0002afa7 	.word	0x0002afa7
   2af08:	0002ae27 	.word	0x0002ae27
   2af0c:	0002ae27 	.word	0x0002ae27
   2af10:	0002ae27 	.word	0x0002ae27
   2af14:	0002b083 	.word	0x0002b083
   2af18:	0002ae27 	.word	0x0002ae27
   2af1c:	0002ae27 	.word	0x0002ae27
   2af20:	0002b123 	.word	0x0002b123
   2af24:	0002ae27 	.word	0x0002ae27
   2af28:	0002afc7 	.word	0x0002afc7
   2af2c:	0002ae27 	.word	0x0002ae27
   2af30:	0002ae27 	.word	0x0002ae27
   2af34:	0002b083 	.word	0x0002b083
   2af38:	0002ae27 	.word	0x0002ae27
   2af3c:	0002afa7 	.word	0x0002afa7
			OUTC('%');
   2af40:	9901      	ldr	r1, [sp, #4]
   2af42:	2025      	movs	r0, #37	; 0x25
   2af44:	47d0      	blx	sl
   2af46:	f109 0901 	add.w	r9, r9, #1
			goto start;
   2af4a:	e755      	b.n	2adf8 <z_cbvprintf_impl+0x14>
			padding_mode &= (char)~PAD_ZERO;
   2af4c:	9a02      	ldr	r2, [sp, #8]
   2af4e:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
   2af52:	9202      	str	r2, [sp, #8]
			precision = 0;
   2af54:	f04f 0800 	mov.w	r8, #0
			continue;
   2af58:	e7b3      	b.n	2aec2 <z_cbvprintf_impl+0xde>
			if (min_width < 0 && precision < 0 && !padding_mode) {
   2af5a:	2c00      	cmp	r4, #0
   2af5c:	da0d      	bge.n	2af7a <z_cbvprintf_impl+0x196>
   2af5e:	f1b8 0f00 	cmp.w	r8, #0
   2af62:	da0d      	bge.n	2af80 <z_cbvprintf_impl+0x19c>
   2af64:	9a02      	ldr	r2, [sp, #8]
   2af66:	2a00      	cmp	r2, #0
   2af68:	f000 8145 	beq.w	2b1f6 <z_cbvprintf_impl+0x412>
				if (min_width < 0) {
   2af6c:	ea24 74e4 	bic.w	r4, r4, r4, asr #31
				min_width = 10 * min_width + *fmt - '0';
   2af70:	220a      	movs	r2, #10
   2af72:	fb02 1404 	mla	r4, r2, r4, r1
   2af76:	3c30      	subs	r4, #48	; 0x30
   2af78:	e7a3      	b.n	2aec2 <z_cbvprintf_impl+0xde>
			if (precision >= 0) {
   2af7a:	f1b8 0f00 	cmp.w	r8, #0
   2af7e:	dbf5      	blt.n	2af6c <z_cbvprintf_impl+0x188>
				precision = 10 * precision + *fmt - '0';
   2af80:	220a      	movs	r2, #10
   2af82:	fb02 1208 	mla	r2, r2, r8, r1
   2af86:	f1a2 0830 	sub.w	r8, r2, #48	; 0x30
   2af8a:	e79a      	b.n	2aec2 <z_cbvprintf_impl+0xde>
			if (precision >= 0) {
   2af8c:	f1b8 0f00 	cmp.w	r8, #0
				precision = va_arg(ap, int);
   2af90:	f855 2b04 	ldr.w	r2, [r5], #4
			if (precision >= 0) {
   2af94:	f280 8131 	bge.w	2b1fa <z_cbvprintf_impl+0x416>
				if (min_width < 0) {
   2af98:	2a00      	cmp	r2, #0
   2af9a:	f280 8130 	bge.w	2b1fe <z_cbvprintf_impl+0x41a>
					min_width = -min_width;
   2af9e:	4254      	negs	r4, r2
		switch (*fmt) {
   2afa0:	2202      	movs	r2, #2
				padding_mode = PAD_ZERO;
   2afa2:	9202      	str	r2, [sp, #8]
   2afa4:	e78d      	b.n	2aec2 <z_cbvprintf_impl+0xde>
			if (*fmt == 'h' && length_mod == 'h') {
   2afa6:	2968      	cmp	r1, #104	; 0x68
   2afa8:	d103      	bne.n	2afb2 <z_cbvprintf_impl+0x1ce>
   2afaa:	2b68      	cmp	r3, #104	; 0x68
   2afac:	d106      	bne.n	2afbc <z_cbvprintf_impl+0x1d8>
				length_mod = 'H';
   2afae:	2348      	movs	r3, #72	; 0x48
   2afb0:	e787      	b.n	2aec2 <z_cbvprintf_impl+0xde>
			} else if (*fmt == 'l' && length_mod == 'l') {
   2afb2:	296c      	cmp	r1, #108	; 0x6c
   2afb4:	d102      	bne.n	2afbc <z_cbvprintf_impl+0x1d8>
   2afb6:	2b6c      	cmp	r3, #108	; 0x6c
   2afb8:	f000 8123 	beq.w	2b202 <z_cbvprintf_impl+0x41e>
			} else if (length_mod == '\0') {
   2afbc:	2b00      	cmp	r3, #0
   2afbe:	f47f af32 	bne.w	2ae26 <z_cbvprintf_impl+0x42>
		switch (*fmt) {
   2afc2:	460b      	mov	r3, r1
   2afc4:	e77d      	b.n	2aec2 <z_cbvprintf_impl+0xde>
			if (length_mod == 'z') {
   2afc6:	2b7a      	cmp	r3, #122	; 0x7a
   2afc8:	d106      	bne.n	2afd8 <z_cbvprintf_impl+0x1f4>
			} else if (*fmt == 'u') {
   2afca:	2975      	cmp	r1, #117	; 0x75
				precision = va_arg(ap, int);
   2afcc:	f855 6b04 	ldr.w	r6, [r5], #4
			} else if (*fmt == 'u') {
   2afd0:	d114      	bne.n	2affc <z_cbvprintf_impl+0x218>
				d = va_arg(ap, unsigned int);
   2afd2:	f04f 0b00 	mov.w	fp, #0
			if (*fmt != 'u' && (int_value_type)d < 0) {
   2afd6:	e00c      	b.n	2aff2 <z_cbvprintf_impl+0x20e>
			} else if (length_mod == 'l') {
   2afd8:	2b6c      	cmp	r3, #108	; 0x6c
   2afda:	d0f6      	beq.n	2afca <z_cbvprintf_impl+0x1e6>
			} else if (length_mod == 'L') {
   2afdc:	2b4c      	cmp	r3, #76	; 0x4c
   2afde:	d1f4      	bne.n	2afca <z_cbvprintf_impl+0x1e6>
					unsigned long long llu =
   2afe0:	3507      	adds	r5, #7
   2afe2:	f025 0307 	bic.w	r3, r5, #7
				if (*fmt == 'u') {
   2afe6:	2975      	cmp	r1, #117	; 0x75
					unsigned long long llu =
   2afe8:	e9d3 6b00 	ldrd	r6, fp, [r3]
   2afec:	f103 0508 	add.w	r5, r3, #8
				if (*fmt == 'u') {
   2aff0:	d106      	bne.n	2b000 <z_cbvprintf_impl+0x21c>
			} else if (special == ' ') {
   2aff2:	2820      	cmp	r0, #32
   2aff4:	d13e      	bne.n	2b074 <z_cbvprintf_impl+0x290>
				prefix = " ";
   2aff6:	4f86      	ldr	r7, [pc, #536]	; (2b210 <z_cbvprintf_impl+0x42c>)
				min_width--;
   2aff8:	3c01      	subs	r4, #1
   2affa:	e009      	b.n	2b010 <z_cbvprintf_impl+0x22c>
				d = va_arg(ap, int);
   2affc:	ea4f 7be6 	mov.w	fp, r6, asr #31
			if (*fmt != 'u' && (int_value_type)d < 0) {
   2b000:	f1bb 0f00 	cmp.w	fp, #0
   2b004:	daf5      	bge.n	2aff2 <z_cbvprintf_impl+0x20e>
				d = -d;
   2b006:	4276      	negs	r6, r6
				prefix = "-";
   2b008:	4f82      	ldr	r7, [pc, #520]	; (2b214 <z_cbvprintf_impl+0x430>)
				d = -d;
   2b00a:	eb6b 0b4b 	sbc.w	fp, fp, fp, lsl #1
				min_width--;
   2b00e:	3c01      	subs	r4, #1
	int i = 0;
   2b010:	f10d 032d 	add.w	r3, sp, #45	; 0x2d
   2b014:	9305      	str	r3, [sp, #20]
   2b016:	2300      	movs	r3, #0
   2b018:	9304      	str	r3, [sp, #16]
		unsigned int c = num % base;
   2b01a:	4630      	mov	r0, r6
   2b01c:	4659      	mov	r1, fp
   2b01e:	220a      	movs	r2, #10
   2b020:	2300      	movs	r3, #0
   2b022:	f7fb f86d 	bl	26100 <__aeabi_uldivmod>
		buftop[--i] = c + '0';
   2b026:	9b04      	ldr	r3, [sp, #16]
   2b028:	f103 3cff 	add.w	ip, r3, #4294967295	; 0xffffffff
   2b02c:	f8cd c010 	str.w	ip, [sp, #16]
   2b030:	f8dd c014 	ldr.w	ip, [sp, #20]
   2b034:	3230      	adds	r2, #48	; 0x30
   2b036:	f80c 2d01 	strb.w	r2, [ip, #-1]!
   2b03a:	f8cd c014 	str.w	ip, [sp, #20]
		num /= base;
   2b03e:	46b4      	mov	ip, r6
   2b040:	465a      	mov	r2, fp
	} while (num);
   2b042:	f1bc 0f0a 	cmp.w	ip, #10
   2b046:	f172 0200 	sbcs.w	r2, r2, #0
		num /= base;
   2b04a:	4606      	mov	r6, r0
   2b04c:	468b      	mov	fp, r1
	} while (num);
   2b04e:	d2e4      	bcs.n	2b01a <z_cbvprintf_impl+0x236>
	return -i;
   2b050:	f1c3 0b01 	rsb	fp, r3, #1
			data = buf + sizeof(buf) - data_len;
   2b054:	3330      	adds	r3, #48	; 0x30
			data = buf + sizeof(buf) - data_len;
   2b056:	eb0d 0603 	add.w	r6, sp, r3
		}

		if (precision < 0 && (padding_mode & PAD_ZERO)) {
   2b05a:	f1b8 0f00 	cmp.w	r8, #0
			data = buf + sizeof(buf) - data_len;
   2b05e:	f1a6 0604 	sub.w	r6, r6, #4
		if (precision < 0 && (padding_mode & PAD_ZERO)) {
   2b062:	da6d      	bge.n	2b140 <z_cbvprintf_impl+0x35c>
   2b064:	9b02      	ldr	r3, [sp, #8]
   2b066:	07d9      	lsls	r1, r3, #31
   2b068:	d47c      	bmi.n	2b164 <z_cbvprintf_impl+0x380>
			precision = min_width;
		}
		min_width -= data_len;
		precision -= data_len;
   2b06a:	eba8 030b 	sub.w	r3, r8, fp
		min_width -= data_len;
   2b06e:	eba4 040b 	sub.w	r4, r4, fp
   2b072:	e013      	b.n	2b09c <z_cbvprintf_impl+0x2b8>
			} else if (special == '+') {
   2b074:	282b      	cmp	r0, #43	; 0x2b
				prefix = "+";
   2b076:	bf0a      	itet	eq
   2b078:	4f67      	ldreq	r7, [pc, #412]	; (2b218 <z_cbvprintf_impl+0x434>)
	prefix = "";
   2b07a:	4f68      	ldrne	r7, [pc, #416]	; (2b21c <z_cbvprintf_impl+0x438>)
				min_width--;
   2b07c:	f104 34ff 	addeq.w	r4, r4, #4294967295	; 0xffffffff
   2b080:	e7c6      	b.n	2b010 <z_cbvprintf_impl+0x22c>
			if (*fmt == 'p') {
   2b082:	2970      	cmp	r1, #112	; 0x70
   2b084:	d10f      	bne.n	2b0a6 <z_cbvprintf_impl+0x2c2>
				x = (uintptr_t)va_arg(ap, void *);
   2b086:	f855 2b04 	ldr.w	r2, [r5], #4
   2b08a:	2300      	movs	r3, #0
				if (x == (uint_value_type)0) {
   2b08c:	b9fa      	cbnz	r2, 2b0ce <z_cbvprintf_impl+0x2ea>
					data = "(nil)";
   2b08e:	4e64      	ldr	r6, [pc, #400]	; (2b220 <z_cbvprintf_impl+0x43c>)
		min_width -= data_len;
   2b090:	3c05      	subs	r4, #5
		precision -= data_len;
   2b092:	f06f 0304 	mvn.w	r3, #4
					data_len = 5;
   2b096:	f04f 0b05 	mov.w	fp, #5
	prefix = "";
   2b09a:	4f60      	ldr	r7, [pc, #384]	; (2b21c <z_cbvprintf_impl+0x438>)
		if (precision > 0) {
			min_width -= precision;
		}

		if (!(padding_mode & PAD_TAIL)) {
   2b09c:	9a02      	ldr	r2, [sp, #8]
   2b09e:	0792      	lsls	r2, r2, #30
   2b0a0:	d46f      	bmi.n	2b182 <z_cbvprintf_impl+0x39e>
   2b0a2:	46a0      	mov	r8, r4
   2b0a4:	e065      	b.n	2b172 <z_cbvprintf_impl+0x38e>
		switch (*fmt) {
   2b0a6:	2178      	movs	r1, #120	; 0x78
			} else if (length_mod == 'l') {
   2b0a8:	2b6c      	cmp	r3, #108	; 0x6c
   2b0aa:	d103      	bne.n	2b0b4 <z_cbvprintf_impl+0x2d0>
				x = va_arg(ap, unsigned int);
   2b0ac:	f855 2b04 	ldr.w	r2, [r5], #4
   2b0b0:	2300      	movs	r3, #0
   2b0b2:	e008      	b.n	2b0c6 <z_cbvprintf_impl+0x2e2>
			} else if (length_mod == 'L') {
   2b0b4:	2b4c      	cmp	r3, #76	; 0x4c
   2b0b6:	d1f9      	bne.n	2b0ac <z_cbvprintf_impl+0x2c8>
				unsigned long long llx =
   2b0b8:	3507      	adds	r5, #7
   2b0ba:	f025 0307 	bic.w	r3, r5, #7
   2b0be:	461d      	mov	r5, r3
   2b0c0:	685b      	ldr	r3, [r3, #4]
   2b0c2:	f855 2b08 	ldr.w	r2, [r5], #8
			if (special == '#') {
   2b0c6:	2823      	cmp	r0, #35	; 0x23
   2b0c8:	d125      	bne.n	2b116 <z_cbvprintf_impl+0x332>
				prefix = (*fmt & 0x20) ? "0x" : "0X";
   2b0ca:	0688      	lsls	r0, r1, #26
   2b0cc:	d521      	bpl.n	2b112 <z_cbvprintf_impl+0x32e>
   2b0ce:	4f55      	ldr	r7, [pc, #340]	; (2b224 <z_cbvprintf_impl+0x440>)
				min_width -= 2;
   2b0d0:	3c02      	subs	r4, #2
			data_len = convert_value(x, 16, ALPHA(*fmt),
   2b0d2:	f001 0160 	and.w	r1, r1, #96	; 0x60
   2b0d6:	f1a1 0b39 	sub.w	fp, r1, #57	; 0x39
	int i = 0;
   2b0da:	f10d 0e2d 	add.w	lr, sp, #45	; 0x2d
   2b0de:	2600      	movs	r6, #0
		unsigned int c = num % base;
   2b0e0:	f002 010f 	and.w	r1, r2, #15
		if (c >= 10) {
   2b0e4:	2909      	cmp	r1, #9
			c += alpha;
   2b0e6:	bf88      	it	hi
   2b0e8:	4459      	addhi	r1, fp
		buftop[--i] = c + '0';
   2b0ea:	3130      	adds	r1, #48	; 0x30
   2b0ec:	f80e 1d01 	strb.w	r1, [lr, #-1]!
	} while (num);
   2b0f0:	2a10      	cmp	r2, #16
		num /= base;
   2b0f2:	ea4f 1112 	mov.w	r1, r2, lsr #4
   2b0f6:	ea41 7103 	orr.w	r1, r1, r3, lsl #28
   2b0fa:	ea4f 1013 	mov.w	r0, r3, lsr #4
	} while (num);
   2b0fe:	f173 0300 	sbcs.w	r3, r3, #0
		buftop[--i] = c + '0';
   2b102:	f106 3cff 	add.w	ip, r6, #4294967295	; 0xffffffff
	} while (num);
   2b106:	d208      	bcs.n	2b11a <z_cbvprintf_impl+0x336>
	return -i;
   2b108:	f1c6 0b01 	rsb	fp, r6, #1
			data = buf + sizeof(buf) - data_len;
   2b10c:	f106 0330 	add.w	r3, r6, #48	; 0x30
   2b110:	e7a1      	b.n	2b056 <z_cbvprintf_impl+0x272>
				prefix = (*fmt & 0x20) ? "0x" : "0X";
   2b112:	4f45      	ldr	r7, [pc, #276]	; (2b228 <z_cbvprintf_impl+0x444>)
   2b114:	e7dc      	b.n	2b0d0 <z_cbvprintf_impl+0x2ec>
	prefix = "";
   2b116:	4f41      	ldr	r7, [pc, #260]	; (2b21c <z_cbvprintf_impl+0x438>)
   2b118:	e7db      	b.n	2b0d2 <z_cbvprintf_impl+0x2ee>
		buftop[--i] = c + '0';
   2b11a:	4666      	mov	r6, ip
		num /= base;
   2b11c:	460a      	mov	r2, r1
   2b11e:	4603      	mov	r3, r0
   2b120:	e7de      	b.n	2b0e0 <z_cbvprintf_impl+0x2fc>
			data = va_arg(ap, char *);
   2b122:	f855 6b04 	ldr.w	r6, [r5], #4
			data_len = strlen(data);
   2b126:	4630      	mov	r0, r6
   2b128:	f01f fe70 	bl	4ae0c <strlen>
			if (precision >= 0 && data_len > precision) {
   2b12c:	f1b8 0f00 	cmp.w	r8, #0
			data_len = strlen(data);
   2b130:	4683      	mov	fp, r0
			if (precision >= 0 && data_len > precision) {
   2b132:	db02      	blt.n	2b13a <z_cbvprintf_impl+0x356>
   2b134:	4540      	cmp	r0, r8
   2b136:	bfa8      	it	ge
   2b138:	46c3      	movge	fp, r8
	prefix = "";
   2b13a:	4f38      	ldr	r7, [pc, #224]	; (2b21c <z_cbvprintf_impl+0x438>)
			precision = 0;
   2b13c:	f04f 0800 	mov.w	r8, #0
		precision -= data_len;
   2b140:	eba8 030b 	sub.w	r3, r8, fp
		if (precision > 0) {
   2b144:	2b00      	cmp	r3, #0
   2b146:	dd92      	ble.n	2b06e <z_cbvprintf_impl+0x28a>
			min_width -= precision;
   2b148:	eba4 0408 	sub.w	r4, r4, r8
   2b14c:	e7a6      	b.n	2b09c <z_cbvprintf_impl+0x2b8>
			buf[0] = c;
   2b14e:	f855 3b04 	ldr.w	r3, [r5], #4
   2b152:	f88d 3018 	strb.w	r3, [sp, #24]
		min_width -= data_len;
   2b156:	3c01      	subs	r4, #1
		precision -= data_len;
   2b158:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
			data_len = 1;
   2b15c:	f04f 0b01 	mov.w	fp, #1
			data = buf;
   2b160:	ae06      	add	r6, sp, #24
   2b162:	e79a      	b.n	2b09a <z_cbvprintf_impl+0x2b6>
   2b164:	46a0      	mov	r8, r4
   2b166:	e7eb      	b.n	2b140 <z_cbvprintf_impl+0x35c>
   2b168:	9302      	str	r3, [sp, #8]
			while (--min_width >= 0) {
				OUTC(' ');
   2b16a:	9901      	ldr	r1, [sp, #4]
   2b16c:	2020      	movs	r0, #32
   2b16e:	47d0      	blx	sl
   2b170:	9b02      	ldr	r3, [sp, #8]
			while (--min_width >= 0) {
   2b172:	f1b8 0801 	subs.w	r8, r8, #1
   2b176:	d5f7      	bpl.n	2b168 <z_cbvprintf_impl+0x384>
   2b178:	ea24 72e4 	bic.w	r2, r4, r4, asr #31
   2b17c:	3c01      	subs	r4, #1
   2b17e:	4491      	add	r9, r2
   2b180:	1aa4      	subs	r4, r4, r2
   2b182:	46b8      	mov	r8, r7
   2b184:	e006      	b.n	2b194 <z_cbvprintf_impl+0x3b0>
   2b186:	9304      	str	r3, [sp, #16]
   2b188:	9202      	str	r2, [sp, #8]
			}
		}
		while (*prefix) {
			OUTC(*prefix++);
   2b18a:	9901      	ldr	r1, [sp, #4]
   2b18c:	47d0      	blx	sl
   2b18e:	9a02      	ldr	r2, [sp, #8]
   2b190:	9b04      	ldr	r3, [sp, #16]
   2b192:	4690      	mov	r8, r2
		while (*prefix) {
   2b194:	4642      	mov	r2, r8
   2b196:	f812 0b01 	ldrb.w	r0, [r2], #1
   2b19a:	2800      	cmp	r0, #0
   2b19c:	d1f3      	bne.n	2b186 <z_cbvprintf_impl+0x3a2>
   2b19e:	461a      	mov	r2, r3
		}
		while (--precision >= 0) {
   2b1a0:	3a01      	subs	r2, #1
   2b1a2:	d515      	bpl.n	2b1d0 <z_cbvprintf_impl+0x3ec>
   2b1a4:	2b00      	cmp	r3, #0
   2b1a6:	bfac      	ite	ge
   2b1a8:	ebc7 0703 	rsbge	r7, r7, r3
   2b1ac:	427f      	neglt	r7, r7
   2b1ae:	465b      	mov	r3, fp
			OUTC('0');
		}
		while (--data_len >= 0) {
   2b1b0:	3b01      	subs	r3, #1
   2b1b2:	d515      	bpl.n	2b1e0 <z_cbvprintf_impl+0x3fc>
   2b1b4:	f1bb 0f00 	cmp.w	fp, #0
   2b1b8:	bfa8      	it	ge
   2b1ba:	445f      	addge	r7, fp
   2b1bc:	444f      	add	r7, r9
   2b1be:	4626      	mov	r6, r4
			OUTC(*data++);
		}
		while (--min_width >= 0) {
   2b1c0:	3e01      	subs	r6, #1
   2b1c2:	d514      	bpl.n	2b1ee <z_cbvprintf_impl+0x40a>
   2b1c4:	2c00      	cmp	r4, #0
   2b1c6:	bfa8      	it	ge
   2b1c8:	193f      	addge	r7, r7, r4
   2b1ca:	eb07 0908 	add.w	r9, r7, r8
   2b1ce:	e613      	b.n	2adf8 <z_cbvprintf_impl+0x14>
   2b1d0:	9304      	str	r3, [sp, #16]
   2b1d2:	9202      	str	r2, [sp, #8]
			OUTC('0');
   2b1d4:	9901      	ldr	r1, [sp, #4]
   2b1d6:	2030      	movs	r0, #48	; 0x30
   2b1d8:	47d0      	blx	sl
   2b1da:	9b04      	ldr	r3, [sp, #16]
   2b1dc:	9a02      	ldr	r2, [sp, #8]
   2b1de:	e7df      	b.n	2b1a0 <z_cbvprintf_impl+0x3bc>
   2b1e0:	9302      	str	r3, [sp, #8]
			OUTC(*data++);
   2b1e2:	9901      	ldr	r1, [sp, #4]
   2b1e4:	f816 0b01 	ldrb.w	r0, [r6], #1
   2b1e8:	47d0      	blx	sl
   2b1ea:	9b02      	ldr	r3, [sp, #8]
   2b1ec:	e7e0      	b.n	2b1b0 <z_cbvprintf_impl+0x3cc>
			OUTC(' ');
   2b1ee:	9901      	ldr	r1, [sp, #4]
   2b1f0:	2020      	movs	r0, #32
   2b1f2:	47d0      	blx	sl
   2b1f4:	e7e4      	b.n	2b1c0 <z_cbvprintf_impl+0x3dc>
				padding_mode = PAD_ZERO;
   2b1f6:	2201      	movs	r2, #1
   2b1f8:	e6d3      	b.n	2afa2 <z_cbvprintf_impl+0x1be>
				precision = va_arg(ap, int);
   2b1fa:	4690      	mov	r8, r2
   2b1fc:	e661      	b.n	2aec2 <z_cbvprintf_impl+0xde>
   2b1fe:	4614      	mov	r4, r2
   2b200:	e65f      	b.n	2aec2 <z_cbvprintf_impl+0xde>
				length_mod = 'L';
   2b202:	234c      	movs	r3, #76	; 0x4c
   2b204:	e65d      	b.n	2aec2 <z_cbvprintf_impl+0xde>
		}

		goto start;
	}
}
   2b206:	4648      	mov	r0, r9
   2b208:	b00d      	add	sp, #52	; 0x34
   2b20a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2b20e:	bf00      	nop
   2b210:	000533ab 	.word	0x000533ab
   2b214:	000533a9 	.word	0x000533a9
   2b218:	000533ad 	.word	0x000533ad
   2b21c:	0005391e 	.word	0x0005391e
   2b220:	000533b5 	.word	0x000533b5
   2b224:	000533af 	.word	0x000533af
   2b228:	000533b2 	.word	0x000533b2

0002b22c <sys_reboot>:
#include <zephyr/sys/printk.h>

extern void sys_arch_reboot(int type);

FUNC_NORETURN void sys_reboot(int type)
{
   2b22c:	b508      	push	{r3, lr}
	__asm__ volatile(
   2b22e:	f04f 0220 	mov.w	r2, #32
   2b232:	f3ef 8311 	mrs	r3, BASEPRI
   2b236:	f382 8812 	msr	BASEPRI_MAX, r2
   2b23a:	f3bf 8f6f 	isb	sy
	(void)irq_lock();
	sys_clock_disable();

	sys_arch_reboot(type);
   2b23e:	f002 f8f3 	bl	2d428 <sys_arch_reboot>

	/* should never get here */
	printk("Failed to reboot: spinning endlessly...\n");
   2b242:	4803      	ldr	r0, [pc, #12]	; (2b250 <sys_reboot+0x24>)
   2b244:	f01d fc1e 	bl	48a84 <printk>
 * @note In some architectures, before returning, the function unmasks interrupts
 * unconditionally.
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
   2b248:	f001 fd9c 	bl	2cd84 <arch_cpu_idle>
   2b24c:	e7fc      	b.n	2b248 <sys_reboot+0x1c>
   2b24e:	bf00      	nop
   2b250:	000533bb 	.word	0x000533bb

0002b254 <z_arm_platform_init>:
	 */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r0, =SystemInit
	bx r0
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	b SystemInit
   2b254:	f019 bce6 	b.w	44c24 <SystemInit>

0002b258 <read_pnp_id>:

#if CONFIG_BT_DIS_PNP
static ssize_t read_pnp_id(struct bt_conn *conn,
			   const struct bt_gatt_attr *attr, void *buf,
			   uint16_t len, uint16_t offset)
{
   2b258:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &dis_pnp_id,
   2b25a:	2407      	movs	r4, #7
   2b25c:	9402      	str	r4, [sp, #8]
   2b25e:	4c04      	ldr	r4, [pc, #16]	; (2b270 <read_pnp_id+0x18>)
   2b260:	9401      	str	r4, [sp, #4]
   2b262:	f8bd 4018 	ldrh.w	r4, [sp, #24]
   2b266:	9400      	str	r4, [sp, #0]
   2b268:	f022 f958 	bl	4d51c <bt_gatt_attr_read>
				 sizeof(dis_pnp_id));
}
   2b26c:	b004      	add	sp, #16
   2b26e:	bd10      	pop	{r4, pc}
   2b270:	20000f97 	.word	0x20000f97

0002b274 <read_blvl>:
}

static ssize_t read_blvl(struct bt_conn *conn,
			       const struct bt_gatt_attr *attr, void *buf,
			       uint16_t len, uint16_t offset)
{
   2b274:	b510      	push	{r4, lr}
	uint8_t lvl8 = battery_level;
   2b276:	4c08      	ldr	r4, [pc, #32]	; (2b298 <read_blvl+0x24>)
{
   2b278:	b086      	sub	sp, #24
	uint8_t lvl8 = battery_level;
   2b27a:	7824      	ldrb	r4, [r4, #0]
   2b27c:	f88d 4017 	strb.w	r4, [sp, #23]

	return bt_gatt_attr_read(conn, attr, buf, len, offset, &lvl8,
   2b280:	2401      	movs	r4, #1
   2b282:	9402      	str	r4, [sp, #8]
   2b284:	f10d 0417 	add.w	r4, sp, #23
   2b288:	9401      	str	r4, [sp, #4]
   2b28a:	f8bd 4020 	ldrh.w	r4, [sp, #32]
   2b28e:	9400      	str	r4, [sp, #0]
   2b290:	f022 f944 	bl	4d51c <bt_gatt_attr_read>
				 sizeof(lvl8));
}
   2b294:	b006      	add	sp, #24
   2b296:	bd10      	pop	{r4, pc}
   2b298:	20000f9e 	.word	0x20000f9e

0002b29c <bt_bas_set_battery_level>:
{
	return battery_level;
}

int bt_bas_set_battery_level(uint8_t level)
{
   2b29c:	b500      	push	{lr}
   2b29e:	b089      	sub	sp, #36	; 0x24
	int rc;

	if (level > 100U) {
   2b2a0:	2864      	cmp	r0, #100	; 0x64
{
   2b2a2:	f88d 0007 	strb.w	r0, [sp, #7]
	if (level > 100U) {
   2b2a6:	d819      	bhi.n	2b2dc <bt_bas_set_battery_level+0x40>
		return -EINVAL;
	}

	battery_level = level;
   2b2a8:	4b0e      	ldr	r3, [pc, #56]	; (2b2e4 <bt_bas_set_battery_level+0x48>)
	memset(&params, 0, sizeof(params));
   2b2aa:	2218      	movs	r2, #24
   2b2ac:	7018      	strb	r0, [r3, #0]
   2b2ae:	2100      	movs	r1, #0
   2b2b0:	a802      	add	r0, sp, #8
   2b2b2:	f01f fded 	bl	4ae90 <memset>
	params.attr = attr;
   2b2b6:	4b0c      	ldr	r3, [pc, #48]	; (2b2e8 <bt_bas_set_battery_level+0x4c>)
   2b2b8:	9303      	str	r3, [sp, #12]
	params.data = data;
   2b2ba:	f10d 0307 	add.w	r3, sp, #7
   2b2be:	9304      	str	r3, [sp, #16]
	return bt_gatt_notify_cb(conn, &params);
   2b2c0:	a902      	add	r1, sp, #8
	params.len = len;
   2b2c2:	2301      	movs	r3, #1
	return bt_gatt_notify_cb(conn, &params);
   2b2c4:	2000      	movs	r0, #0
	params.len = len;
   2b2c6:	f8ad 3014 	strh.w	r3, [sp, #20]
	return bt_gatt_notify_cb(conn, &params);
   2b2ca:	f007 f927 	bl	3251c <bt_gatt_notify_cb>

	rc = bt_gatt_notify(NULL, &bas.attrs[1], &level, sizeof(level));

	return rc == -ENOTCONN ? 0 : rc;
   2b2ce:	f110 0f80 	cmn.w	r0, #128	; 0x80
   2b2d2:	bf08      	it	eq
   2b2d4:	2000      	moveq	r0, #0
}
   2b2d6:	b009      	add	sp, #36	; 0x24
   2b2d8:	f85d fb04 	ldr.w	pc, [sp], #4
		return -EINVAL;
   2b2dc:	f06f 0015 	mvn.w	r0, #21
   2b2e0:	e7f9      	b.n	2b2d6 <bt_bas_set_battery_level+0x3a>
   2b2e2:	bf00      	nop
   2b2e4:	20000f9e 	.word	0x20000f9e
   2b2e8:	00051af4 	.word	0x00051af4

0002b2ec <nvs_recover_last_ate>:
 *
 * addr should point to the faulty closing ate and will be updated to the last
 * valid ate. If no valid ate is found it will be left untouched.
 */
static int nvs_recover_last_ate(struct nvs_fs *fs, uint32_t *addr)
{
   2b2ec:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   2b2f0:	460f      	mov	r7, r1
   2b2f2:	4606      	mov	r6, r0
	int rc;

	LOG_DBG("Recovering last ate from sector %d",
		(*addr >> ADDR_SECT_SHIFT));

	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   2b2f4:	2108      	movs	r1, #8
   2b2f6:	6ac0      	ldr	r0, [r0, #44]	; 0x2c

	*addr -= ate_size;
	ate_end_addr = *addr;
	data_end_addr = *addr & ADDR_SECT_MASK;
   2b2f8:	f8df 9050 	ldr.w	r9, [pc, #80]	; 2b34c <nvs_recover_last_ate+0x60>
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   2b2fc:	f01d ff7a 	bl	491f4 <nvs_al_size.isra.0>
	*addr -= ate_size;
   2b300:	683c      	ldr	r4, [r7, #0]
   2b302:	1a24      	subs	r4, r4, r0
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   2b304:	4680      	mov	r8, r0
	*addr -= ate_size;
   2b306:	603c      	str	r4, [r7, #0]
	data_end_addr = *addr & ADDR_SECT_MASK;
   2b308:	ea04 0509 	and.w	r5, r4, r9
	while (ate_end_addr > data_end_addr) {
   2b30c:	42ac      	cmp	r4, r5
   2b30e:	d803      	bhi.n	2b318 <nvs_recover_last_ate+0x2c>
			*addr = ate_end_addr;
		}
		ate_end_addr -= ate_size;
	}

	return 0;
   2b310:	2000      	movs	r0, #0
}
   2b312:	b003      	add	sp, #12
   2b314:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
   2b318:	2308      	movs	r3, #8
   2b31a:	466a      	mov	r2, sp
   2b31c:	4621      	mov	r1, r4
   2b31e:	4630      	mov	r0, r6
   2b320:	f01d fedb 	bl	490da <nvs_flash_rd>
		if (rc) {
   2b324:	2800      	cmp	r0, #0
   2b326:	d1f4      	bne.n	2b312 <nvs_recover_last_ate+0x26>
		if (nvs_ate_valid(fs, &end_ate)) {
   2b328:	4669      	mov	r1, sp
   2b32a:	4630      	mov	r0, r6
   2b32c:	f01d ff6c 	bl	49208 <nvs_ate_valid>
   2b330:	b140      	cbz	r0, 2b344 <nvs_recover_last_ate+0x58>
			data_end_addr += end_ate.offset + end_ate.len;
   2b332:	f8bd 3002 	ldrh.w	r3, [sp, #2]
   2b336:	f8bd 2004 	ldrh.w	r2, [sp, #4]
			*addr = ate_end_addr;
   2b33a:	603c      	str	r4, [r7, #0]
			data_end_addr &= ADDR_SECT_MASK;
   2b33c:	ea05 0509 	and.w	r5, r5, r9
			data_end_addr += end_ate.offset + end_ate.len;
   2b340:	4413      	add	r3, r2
   2b342:	441d      	add	r5, r3
		ate_end_addr -= ate_size;
   2b344:	eba4 0408 	sub.w	r4, r4, r8
   2b348:	e7e0      	b.n	2b30c <nvs_recover_last_ate+0x20>
   2b34a:	bf00      	nop
   2b34c:	ffff0000 	.word	0xffff0000

0002b350 <nvs_mount>:

	return 0;
}

int nvs_mount(struct nvs_fs *fs)
{
   2b350:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2b354:	4604      	mov	r4, r0
   2b356:	b088      	sub	sp, #32

	int rc;
	struct flash_pages_info info;
	size_t write_block_size;

	k_mutex_init(&fs->nvs_lock);
   2b358:	f100 0714 	add.w	r7, r0, #20
	return z_impl_k_mutex_init(mutex);
   2b35c:	4638      	mov	r0, r7
   2b35e:	f024 fc92 	bl	4fc86 <z_impl_k_mutex_init>

	fs->flash_parameters = flash_get_parameters(fs->flash_device);
   2b362:	6aa0      	ldr	r0, [r4, #40]	; 0x28
static inline const struct flash_parameters *z_impl_flash_get_parameters(const struct device *dev)
{
	const struct flash_driver_api *api =
		(const struct flash_driver_api *)dev->api;

	return api->get_parameters(dev);
   2b364:	6883      	ldr	r3, [r0, #8]
   2b366:	68db      	ldr	r3, [r3, #12]
   2b368:	4798      	blx	r3
   2b36a:	62e0      	str	r0, [r4, #44]	; 0x2c
	if (fs->flash_parameters == NULL) {
   2b36c:	b928      	cbnz	r0, 2b37a <nvs_mount+0x2a>
		LOG_ERR("Could not obtain flash parameters");
		return -EINVAL;
   2b36e:	f06f 0515 	mvn.w	r5, #21
	LOG_INF("data wra: %d, %x",
		(fs->data_wra >> ADDR_SECT_SHIFT),
		(fs->data_wra & ADDR_OFFS_MASK));

	return 0;
}
   2b372:	4628      	mov	r0, r5
   2b374:	b008      	add	sp, #32
   2b376:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	write_block_size = flash_get_write_block_size(fs->flash_device);
   2b37a:	6aa0      	ldr	r0, [r4, #40]	; 0x28
	return api->get_parameters(dev)->write_block_size;
   2b37c:	6883      	ldr	r3, [r0, #8]
   2b37e:	68db      	ldr	r3, [r3, #12]
   2b380:	4798      	blx	r3
	if (write_block_size > NVS_BLOCK_SIZE || write_block_size == 0) {
   2b382:	6803      	ldr	r3, [r0, #0]
   2b384:	3b01      	subs	r3, #1
   2b386:	2b1f      	cmp	r3, #31
   2b388:	d8f1      	bhi.n	2b36e <nvs_mount+0x1e>
	rc = flash_get_page_info_by_offs(fs->flash_device, fs->offset, &info);
   2b38a:	6aa0      	ldr	r0, [r4, #40]	; 0x28
   2b38c:	6821      	ldr	r1, [r4, #0]
		union { uintptr_t x; struct flash_pages_info * val; } parm2 = { .val = info };
		return (int) arch_syscall_invoke3(parm0.x, parm1.x, parm2.x, K_SYSCALL_FLASH_GET_PAGE_INFO_BY_OFFS);
	}
#endif
	compiler_barrier();
	return z_impl_flash_get_page_info_by_offs(dev, offset, info);
   2b38e:	aa05      	add	r2, sp, #20
   2b390:	f023 ff35 	bl	4f1fe <z_impl_flash_get_page_info_by_offs>
	if (rc) {
   2b394:	2800      	cmp	r0, #0
   2b396:	d1ea      	bne.n	2b36e <nvs_mount+0x1e>
	if (!fs->sector_size || fs->sector_size % info.size) {
   2b398:	89a5      	ldrh	r5, [r4, #12]
   2b39a:	2d00      	cmp	r5, #0
   2b39c:	d0e7      	beq.n	2b36e <nvs_mount+0x1e>
   2b39e:	9b06      	ldr	r3, [sp, #24]
   2b3a0:	fbb5 f2f3 	udiv	r2, r5, r3
   2b3a4:	fb03 5512 	mls	r5, r3, r2, r5
   2b3a8:	2d00      	cmp	r5, #0
   2b3aa:	d1e0      	bne.n	2b36e <nvs_mount+0x1e>
	if (fs->sector_count < 2) {
   2b3ac:	89e3      	ldrh	r3, [r4, #14]
   2b3ae:	2b01      	cmp	r3, #1
   2b3b0:	d9dd      	bls.n	2b36e <nvs_mount+0x1e>
	uint8_t erase_value = fs->flash_parameters->erase_value;
   2b3b2:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
	uint32_t addr = 0U;
   2b3b4:	9500      	str	r5, [sp, #0]
	uint8_t erase_value = fs->flash_parameters->erase_value;
   2b3b6:	f893 9004 	ldrb.w	r9, [r3, #4]
	return z_impl_k_mutex_lock(mutex, timeout);
   2b3ba:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2b3be:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   2b3c2:	4638      	mov	r0, r7
   2b3c4:	f01b fdee 	bl	46fa4 <z_impl_k_mutex_lock>
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   2b3c8:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   2b3ca:	2108      	movs	r1, #8
   2b3cc:	f01d ff12 	bl	491f4 <nvs_al_size.isra.0>
	uint16_t i, closed_sectors = 0;
   2b3d0:	46a8      	mov	r8, r5
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   2b3d2:	4606      	mov	r6, r0
	for (i = 0; i < fs->sector_count; i++) {
   2b3d4:	89e3      	ldrh	r3, [r4, #14]
   2b3d6:	fa1f fa85 	uxth.w	sl, r5
   2b3da:	4553      	cmp	r3, sl
   2b3dc:	d808      	bhi.n	2b3f0 <nvs_mount+0xa0>
	if (closed_sectors == fs->sector_count) {
   2b3de:	89e3      	ldrh	r3, [r4, #14]
   2b3e0:	4543      	cmp	r3, r8
   2b3e2:	d123      	bne.n	2b42c <nvs_mount+0xdc>
	return z_impl_k_mutex_unlock(mutex);
   2b3e4:	4638      	mov	r0, r7
   2b3e6:	f01b fe57 	bl	47098 <z_impl_k_mutex_unlock>
		rc = -EDEADLK;
   2b3ea:	f06f 052c 	mvn.w	r5, #44	; 0x2c
   2b3ee:	e7c0      	b.n	2b372 <nvs_mount+0x22>
		       (uint16_t)(fs->sector_size - ate_size);
   2b3f0:	89a1      	ldrh	r1, [r4, #12]
		addr = (i << ADDR_SECT_SHIFT) +
   2b3f2:	042b      	lsls	r3, r5, #16
		       (uint16_t)(fs->sector_size - ate_size);
   2b3f4:	1b89      	subs	r1, r1, r6
		addr = (i << ADDR_SECT_SHIFT) +
   2b3f6:	fa13 f181 	uxtah	r1, r3, r1
		rc = nvs_flash_cmp_const(fs, addr, erase_value,
   2b3fa:	464a      	mov	r2, r9
   2b3fc:	2308      	movs	r3, #8
   2b3fe:	4620      	mov	r0, r4
		addr = (i << ADDR_SECT_SHIFT) +
   2b400:	9100      	str	r1, [sp, #0]
		rc = nvs_flash_cmp_const(fs, addr, erase_value,
   2b402:	f01d feaf 	bl	49164 <nvs_flash_cmp_const>
		if (rc) {
   2b406:	b178      	cbz	r0, 2b428 <nvs_mount+0xd8>
			nvs_sector_advance(fs, &addr);
   2b408:	4669      	mov	r1, sp
   2b40a:	4620      	mov	r0, r4
   2b40c:	f01d fe73 	bl	490f6 <nvs_sector_advance>
			closed_sectors++;
   2b410:	f108 0801 	add.w	r8, r8, #1
			rc = nvs_flash_cmp_const(fs, addr, erase_value,
   2b414:	9900      	ldr	r1, [sp, #0]
   2b416:	2308      	movs	r3, #8
   2b418:	464a      	mov	r2, r9
   2b41a:	4620      	mov	r0, r4
			closed_sectors++;
   2b41c:	fa1f f888 	uxth.w	r8, r8
			rc = nvs_flash_cmp_const(fs, addr, erase_value,
   2b420:	f01d fea0 	bl	49164 <nvs_flash_cmp_const>
			if (!rc) {
   2b424:	2800      	cmp	r0, #0
   2b426:	d0da      	beq.n	2b3de <nvs_mount+0x8e>
	for (i = 0; i < fs->sector_count; i++) {
   2b428:	3501      	adds	r5, #1
   2b42a:	e7d3      	b.n	2b3d4 <nvs_mount+0x84>
	if (i == fs->sector_count) {
   2b42c:	4553      	cmp	r3, sl
   2b42e:	d10b      	bne.n	2b448 <nvs_mount+0xf8>
		rc = nvs_flash_cmp_const(fs, addr - ate_size, erase_value,
   2b430:	9900      	ldr	r1, [sp, #0]
   2b432:	2308      	movs	r3, #8
   2b434:	464a      	mov	r2, r9
   2b436:	1b89      	subs	r1, r1, r6
   2b438:	4620      	mov	r0, r4
   2b43a:	f01d fe93 	bl	49164 <nvs_flash_cmp_const>
		if (!rc) {
   2b43e:	b918      	cbnz	r0, 2b448 <nvs_mount+0xf8>
			nvs_sector_advance(fs, &addr);
   2b440:	4669      	mov	r1, sp
   2b442:	4620      	mov	r0, r4
   2b444:	f01d fe57 	bl	490f6 <nvs_sector_advance>
	rc = nvs_recover_last_ate(fs, &addr);
   2b448:	4669      	mov	r1, sp
   2b44a:	4620      	mov	r0, r4
   2b44c:	f7ff ff4e 	bl	2b2ec <nvs_recover_last_ate>
	if (rc) {
   2b450:	4605      	mov	r5, r0
   2b452:	b118      	cbz	r0, 2b45c <nvs_mount+0x10c>
   2b454:	4638      	mov	r0, r7
   2b456:	f01b fe1f 	bl	47098 <z_impl_k_mutex_unlock>
	if (rc) {
   2b45a:	e78a      	b.n	2b372 <nvs_mount+0x22>
	fs->ate_wra = addr;
   2b45c:	9b00      	ldr	r3, [sp, #0]
   2b45e:	6063      	str	r3, [r4, #4]
	fs->data_wra = addr & ADDR_SECT_MASK;
   2b460:	ea4f 4813 	mov.w	r8, r3, lsr #16
   2b464:	ea4f 4808 	mov.w	r8, r8, lsl #16
   2b468:	f8c4 8008 	str.w	r8, [r4, #8]
	while (fs->ate_wra >= fs->data_wra) {
   2b46c:	e9d4 1301 	ldrd	r1, r3, [r4, #4]
   2b470:	4299      	cmp	r1, r3
   2b472:	d30f      	bcc.n	2b494 <nvs_mount+0x144>
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
   2b474:	2308      	movs	r3, #8
   2b476:	aa01      	add	r2, sp, #4
   2b478:	4620      	mov	r0, r4
   2b47a:	f01d fe2e 	bl	490da <nvs_flash_rd>
		if (rc) {
   2b47e:	4605      	mov	r5, r0
   2b480:	2800      	cmp	r0, #0
   2b482:	d1e7      	bne.n	2b454 <nvs_mount+0x104>
   2b484:	ab01      	add	r3, sp, #4
		if (data8[i] != value) {
   2b486:	f813 2b01 	ldrb.w	r2, [r3], #1
   2b48a:	4591      	cmp	r9, r2
   2b48c:	d133      	bne.n	2b4f6 <nvs_mount+0x1a6>
	for (i = 0; i < sizeof(struct nvs_ate); i++) {
   2b48e:	3501      	adds	r5, #1
   2b490:	2d08      	cmp	r5, #8
   2b492:	d1f8      	bne.n	2b486 <nvs_mount+0x136>
	addr = fs->ate_wra & ADDR_SECT_MASK;
   2b494:	6863      	ldr	r3, [r4, #4]
   2b496:	0c1b      	lsrs	r3, r3, #16
   2b498:	041b      	lsls	r3, r3, #16
	nvs_sector_advance(fs, &addr);
   2b49a:	4669      	mov	r1, sp
   2b49c:	4620      	mov	r0, r4
	addr = fs->ate_wra & ADDR_SECT_MASK;
   2b49e:	9300      	str	r3, [sp, #0]
	nvs_sector_advance(fs, &addr);
   2b4a0:	f01d fe29 	bl	490f6 <nvs_sector_advance>
	rc = nvs_flash_cmp_const(fs, addr, erase_value, fs->sector_size);
   2b4a4:	89a3      	ldrh	r3, [r4, #12]
   2b4a6:	9900      	ldr	r1, [sp, #0]
   2b4a8:	464a      	mov	r2, r9
   2b4aa:	4620      	mov	r0, r4
   2b4ac:	f01d fe5a 	bl	49164 <nvs_flash_cmp_const>
	if (rc < 0) {
   2b4b0:	1e05      	subs	r5, r0, #0
   2b4b2:	dbcf      	blt.n	2b454 <nvs_mount+0x104>
		addr = fs->ate_wra + ate_size;
   2b4b4:	6863      	ldr	r3, [r4, #4]
	if (rc) {
   2b4b6:	d076      	beq.n	2b5a6 <nvs_mount+0x256>
		addr = fs->ate_wra + ate_size;
   2b4b8:	eb06 0803 	add.w	r8, r6, r3
		while ((addr & ADDR_OFFS_MASK) < (fs->sector_size - ate_size)) {
   2b4bc:	f64f 79ff 	movw	r9, #65535	; 0xffff
   2b4c0:	89a3      	ldrh	r3, [r4, #12]
		addr = fs->ate_wra + ate_size;
   2b4c2:	f8cd 8000 	str.w	r8, [sp]
		while ((addr & ADDR_OFFS_MASK) < (fs->sector_size - ate_size)) {
   2b4c6:	fa1f f288 	uxth.w	r2, r8
   2b4ca:	1b9b      	subs	r3, r3, r6
   2b4cc:	429a      	cmp	r2, r3
   2b4ce:	d32e      	bcc.n	2b52e <nvs_mount+0x1de>
		bool gc_done_marker = false;
   2b4d0:	2300      	movs	r3, #0
			addr = fs->ate_wra & ADDR_SECT_MASK;
   2b4d2:	6861      	ldr	r1, [r4, #4]
		if (gc_done_marker) {
   2b4d4:	2b00      	cmp	r3, #0
   2b4d6:	d043      	beq.n	2b560 <nvs_mount+0x210>
			addr = fs->ate_wra & ADDR_SECT_MASK;
   2b4d8:	0c09      	lsrs	r1, r1, #16
   2b4da:	0409      	lsls	r1, r1, #16
   2b4dc:	9100      	str	r1, [sp, #0]
			nvs_sector_advance(fs, &addr);
   2b4de:	4620      	mov	r0, r4
   2b4e0:	4669      	mov	r1, sp
   2b4e2:	f01d fe08 	bl	490f6 <nvs_sector_advance>
			rc = nvs_flash_erase_sector(fs, addr);
   2b4e6:	9900      	ldr	r1, [sp, #0]
   2b4e8:	4620      	mov	r0, r4
   2b4ea:	f01d fe60 	bl	491ae <nvs_flash_erase_sector>
		rc = nvs_gc(fs);
   2b4ee:	4605      	mov	r5, r0
	if ((!rc) && ((fs->ate_wra & ADDR_OFFS_MASK) ==
   2b4f0:	2d00      	cmp	r5, #0
   2b4f2:	d074      	beq.n	2b5de <nvs_mount+0x28e>
   2b4f4:	e7ae      	b.n	2b454 <nvs_mount+0x104>
		if (nvs_ate_valid(fs, &last_ate)) {
   2b4f6:	a901      	add	r1, sp, #4
   2b4f8:	4620      	mov	r0, r4
   2b4fa:	f01d fe85 	bl	49208 <nvs_ate_valid>
   2b4fe:	6862      	ldr	r2, [r4, #4]
   2b500:	b910      	cbnz	r0, 2b508 <nvs_mount+0x1b8>
		fs->ate_wra -= ate_size;
   2b502:	1b92      	subs	r2, r2, r6
   2b504:	6062      	str	r2, [r4, #4]
   2b506:	e7b1      	b.n	2b46c <nvs_mount+0x11c>
			fs->data_wra += nvs_al_size(fs, last_ate.offset + last_ate.len);
   2b508:	f8bd 5008 	ldrh.w	r5, [sp, #8]
   2b50c:	f8bd 1006 	ldrh.w	r1, [sp, #6]
   2b510:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
			fs->data_wra = addr & ADDR_SECT_MASK;
   2b512:	f8c4 8008 	str.w	r8, [r4, #8]
			fs->data_wra += nvs_al_size(fs, last_ate.offset + last_ate.len);
   2b516:	4429      	add	r1, r5
   2b518:	f01d fe6c 	bl	491f4 <nvs_al_size.isra.0>
   2b51c:	4440      	add	r0, r8
			if (fs->ate_wra == fs->data_wra && last_ate.len) {
   2b51e:	4290      	cmp	r0, r2
			fs->data_wra += nvs_al_size(fs, last_ate.offset + last_ate.len);
   2b520:	60a0      	str	r0, [r4, #8]
			if (fs->ate_wra == fs->data_wra && last_ate.len) {
   2b522:	d1ee      	bne.n	2b502 <nvs_mount+0x1b2>
   2b524:	2d00      	cmp	r5, #0
   2b526:	d0ec      	beq.n	2b502 <nvs_mount+0x1b2>
				rc = -ESPIPE;
   2b528:	f06f 051c 	mvn.w	r5, #28
   2b52c:	e068      	b.n	2b600 <nvs_mount+0x2b0>
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
   2b52e:	2308      	movs	r3, #8
   2b530:	aa03      	add	r2, sp, #12
   2b532:	4641      	mov	r1, r8
   2b534:	4620      	mov	r0, r4
   2b536:	f01d fdd0 	bl	490da <nvs_flash_rd>
			if (rc) {
   2b53a:	4605      	mov	r5, r0
   2b53c:	2800      	cmp	r0, #0
   2b53e:	d189      	bne.n	2b454 <nvs_mount+0x104>
			if (nvs_ate_valid(fs, &gc_done_ate) &&
   2b540:	a903      	add	r1, sp, #12
   2b542:	4620      	mov	r0, r4
   2b544:	f01d fe60 	bl	49208 <nvs_ate_valid>
   2b548:	b130      	cbz	r0, 2b558 <nvs_mount+0x208>
   2b54a:	f8bd 300c 	ldrh.w	r3, [sp, #12]
   2b54e:	454b      	cmp	r3, r9
   2b550:	d102      	bne.n	2b558 <nvs_mount+0x208>
			    (gc_done_ate.id == 0xffff) &&
   2b552:	f8bd 3010 	ldrh.w	r3, [sp, #16]
   2b556:	b10b      	cbz	r3, 2b55c <nvs_mount+0x20c>
			addr += ate_size;
   2b558:	44b0      	add	r8, r6
   2b55a:	e7b1      	b.n	2b4c0 <nvs_mount+0x170>
				gc_done_marker = true;
   2b55c:	2301      	movs	r3, #1
   2b55e:	e7b8      	b.n	2b4d2 <nvs_mount+0x182>
		rc = nvs_flash_erase_sector(fs, fs->ate_wra);
   2b560:	4620      	mov	r0, r4
   2b562:	f01d fe24 	bl	491ae <nvs_flash_erase_sector>
		if (rc) {
   2b566:	4605      	mov	r5, r0
   2b568:	2800      	cmp	r0, #0
   2b56a:	f47f af73 	bne.w	2b454 <nvs_mount+0x104>
		fs->ate_wra &= ADDR_SECT_MASK;
   2b56e:	6863      	ldr	r3, [r4, #4]
   2b570:	4a26      	ldr	r2, [pc, #152]	; (2b60c <nvs_mount+0x2bc>)
		fs->ate_wra += (fs->sector_size - 2 * ate_size);
   2b572:	89a1      	ldrh	r1, [r4, #12]
		fs->ate_wra &= ADDR_SECT_MASK;
   2b574:	4013      	ands	r3, r2
		fs->ate_wra += (fs->sector_size - 2 * ate_size);
   2b576:	440b      	add	r3, r1
   2b578:	eba3 0346 	sub.w	r3, r3, r6, lsl #1
   2b57c:	6063      	str	r3, [r4, #4]
		fs->data_wra = (fs->ate_wra & ADDR_SECT_MASK);
   2b57e:	4013      	ands	r3, r2
   2b580:	60a3      	str	r3, [r4, #8]
		rc = nvs_gc(fs);
   2b582:	4620      	mov	r0, r4
   2b584:	f01d ff22 	bl	493cc <nvs_gc>
   2b588:	e7b1      	b.n	2b4ee <nvs_mount+0x19e>
		rc = nvs_flash_cmp_const(fs, fs->data_wra, erase_value,
   2b58a:	1a5b      	subs	r3, r3, r1
   2b58c:	464a      	mov	r2, r9
   2b58e:	4620      	mov	r0, r4
   2b590:	f01d fde8 	bl	49164 <nvs_flash_cmp_const>
		if (rc < 0) {
   2b594:	1e05      	subs	r5, r0, #0
   2b596:	f6ff af5d 	blt.w	2b454 <nvs_mount+0x104>
		if (!rc) {
   2b59a:	d008      	beq.n	2b5ae <nvs_mount+0x25e>
		fs->data_wra += fs->flash_parameters->write_block_size;
   2b59c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   2b59e:	68a3      	ldr	r3, [r4, #8]
   2b5a0:	6812      	ldr	r2, [r2, #0]
   2b5a2:	4413      	add	r3, r2
   2b5a4:	60a3      	str	r3, [r4, #8]
	while (fs->ate_wra > fs->data_wra) {
   2b5a6:	e9d4 3101 	ldrd	r3, r1, [r4, #4]
   2b5aa:	428b      	cmp	r3, r1
   2b5ac:	d8ed      	bhi.n	2b58a <nvs_mount+0x23a>
	if (((fs->ate_wra + 2 * ate_size) == fs->sector_size) &&
   2b5ae:	6861      	ldr	r1, [r4, #4]
   2b5b0:	89a3      	ldrh	r3, [r4, #12]
   2b5b2:	eb01 0246 	add.w	r2, r1, r6, lsl #1
   2b5b6:	429a      	cmp	r2, r3
   2b5b8:	d19a      	bne.n	2b4f0 <nvs_mount+0x1a0>
	    (fs->data_wra != (fs->ate_wra & ADDR_SECT_MASK))) {
   2b5ba:	f8df 8050 	ldr.w	r8, [pc, #80]	; 2b60c <nvs_mount+0x2bc>
	if (((fs->ate_wra + 2 * ate_size) == fs->sector_size) &&
   2b5be:	68a2      	ldr	r2, [r4, #8]
	    (fs->data_wra != (fs->ate_wra & ADDR_SECT_MASK))) {
   2b5c0:	ea01 0308 	and.w	r3, r1, r8
	if (((fs->ate_wra + 2 * ate_size) == fs->sector_size) &&
   2b5c4:	429a      	cmp	r2, r3
   2b5c6:	d093      	beq.n	2b4f0 <nvs_mount+0x1a0>
		rc = nvs_flash_erase_sector(fs, fs->ate_wra);
   2b5c8:	4620      	mov	r0, r4
   2b5ca:	f01d fdf0 	bl	491ae <nvs_flash_erase_sector>
		if (rc) {
   2b5ce:	4605      	mov	r5, r0
   2b5d0:	2800      	cmp	r0, #0
   2b5d2:	f47f af3f 	bne.w	2b454 <nvs_mount+0x104>
		fs->data_wra = fs->ate_wra & ADDR_SECT_MASK;
   2b5d6:	6863      	ldr	r3, [r4, #4]
   2b5d8:	ea03 0308 	and.w	r3, r3, r8
   2b5dc:	60a3      	str	r3, [r4, #8]
		      (fs->sector_size - 2 * ate_size))) {
   2b5de:	89a3      	ldrh	r3, [r4, #12]
	if ((!rc) && ((fs->ate_wra & ADDR_OFFS_MASK) ==
   2b5e0:	88a2      	ldrh	r2, [r4, #4]
		      (fs->sector_size - 2 * ate_size))) {
   2b5e2:	eba3 0346 	sub.w	r3, r3, r6, lsl #1
	if ((!rc) && ((fs->ate_wra & ADDR_OFFS_MASK) ==
   2b5e6:	429a      	cmp	r2, r3
   2b5e8:	d006      	beq.n	2b5f8 <nvs_mount+0x2a8>
   2b5ea:	4638      	mov	r0, r7
   2b5ec:	f01b fd54 	bl	47098 <z_impl_k_mutex_unlock>
	fs->ready = true;
   2b5f0:	2301      	movs	r3, #1
   2b5f2:	7423      	strb	r3, [r4, #16]
	return 0;
   2b5f4:	2500      	movs	r5, #0
   2b5f6:	e6bc      	b.n	2b372 <nvs_mount+0x22>
		rc = nvs_add_gc_done_ate(fs);
   2b5f8:	4620      	mov	r0, r4
   2b5fa:	f01d fed2 	bl	493a2 <nvs_add_gc_done_ate>
   2b5fe:	4605      	mov	r5, r0
   2b600:	4638      	mov	r0, r7
   2b602:	f01b fd49 	bl	47098 <z_impl_k_mutex_unlock>
	if (rc) {
   2b606:	2d00      	cmp	r5, #0
   2b608:	d0f2      	beq.n	2b5f0 <nvs_mount+0x2a0>
   2b60a:	e6b2      	b.n	2b372 <nvs_mount+0x22>
   2b60c:	ffff0000 	.word	0xffff0000

0002b610 <nvs_write>:

ssize_t nvs_write(struct nvs_fs *fs, uint16_t id, const void *data, size_t len)
{
   2b610:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2b614:	461d      	mov	r5, r3
	struct nvs_ate wlk_ate;
	uint32_t wlk_addr, rd_addr;
	uint16_t required_space = 0U; /* no space, appropriate for delete ate */
	bool prev_found = false;

	if (!fs->ready) {
   2b616:	7c03      	ldrb	r3, [r0, #16]
{
   2b618:	b089      	sub	sp, #36	; 0x24
   2b61a:	4604      	mov	r4, r0
   2b61c:	4689      	mov	r9, r1
   2b61e:	4690      	mov	r8, r2
	if (!fs->ready) {
   2b620:	2b00      	cmp	r3, #0
   2b622:	f000 80bd 	beq.w	2b7a0 <nvs_write+0x190>
		LOG_ERR("NVS not initialized");
		return -EACCES;
	}

	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   2b626:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
   2b628:	2108      	movs	r1, #8
   2b62a:	4610      	mov	r0, r2
   2b62c:	f01d fde2 	bl	491f4 <nvs_al_size.isra.0>
	data_size = nvs_al_size(fs, len);
   2b630:	4629      	mov	r1, r5
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   2b632:	4682      	mov	sl, r0
	data_size = nvs_al_size(fs, len);
   2b634:	4610      	mov	r0, r2
   2b636:	f01d fddd 	bl	491f4 <nvs_al_size.isra.0>

	/* The maximum data size is sector size - 4 ate
	 * where: 1 ate for data, 1 ate for sector close, 1 ate for gc done,
	 * and 1 ate to always allow a delete.
	 */
	if ((len > (fs->sector_size - 4 * ate_size)) ||
   2b63a:	89a3      	ldrh	r3, [r4, #12]
   2b63c:	eba3 038a 	sub.w	r3, r3, sl, lsl #2
   2b640:	429d      	cmp	r5, r3
	data_size = nvs_al_size(fs, len);
   2b642:	4607      	mov	r7, r0
	if ((len > (fs->sector_size - 4 * ate_size)) ||
   2b644:	f200 80af 	bhi.w	2b7a6 <nvs_write+0x196>
   2b648:	b11d      	cbz	r5, 2b652 <nvs_write+0x42>
	    ((len > 0) && (data == NULL))) {
   2b64a:	f1b8 0f00 	cmp.w	r8, #0
   2b64e:	f000 80aa 	beq.w	2b7a6 <nvs_write+0x196>
		return -EINVAL;
	}

	/* find latest entry with same id */
	wlk_addr = fs->ate_wra;
   2b652:	6863      	ldr	r3, [r4, #4]
   2b654:	9303      	str	r3, [sp, #12]
	rd_addr = wlk_addr;

	while (1) {
		rd_addr = wlk_addr;
		rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
   2b656:	aa04      	add	r2, sp, #16
   2b658:	a903      	add	r1, sp, #12
   2b65a:	4620      	mov	r0, r4
		rd_addr = wlk_addr;
   2b65c:	f8dd b00c 	ldr.w	fp, [sp, #12]
		rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
   2b660:	f01d fe0a 	bl	49278 <nvs_prev_ate>
		if (rc) {
   2b664:	4606      	mov	r6, r0
   2b666:	2800      	cmp	r0, #0
   2b668:	d165      	bne.n	2b736 <nvs_write+0x126>
			return rc;
		}
		if ((wlk_ate.id == id) && (nvs_ate_valid(fs, &wlk_ate))) {
   2b66a:	f8bd 3010 	ldrh.w	r3, [sp, #16]
   2b66e:	454b      	cmp	r3, r9
   2b670:	d005      	beq.n	2b67e <nvs_write+0x6e>
			prev_found = true;
			break;
		}
		if (wlk_addr == fs->ate_wra) {
   2b672:	6862      	ldr	r2, [r4, #4]
   2b674:	9b03      	ldr	r3, [sp, #12]
   2b676:	429a      	cmp	r2, r3
   2b678:	d1ed      	bne.n	2b656 <nvs_write+0x46>
				return rc;
			}
		}
	} else {
		/* skip delete entry for non-existing entry */
		if (len == 0) {
   2b67a:	b9e5      	cbnz	r5, 2b6b6 <nvs_write+0xa6>
   2b67c:	e05b      	b.n	2b736 <nvs_write+0x126>
		if ((wlk_ate.id == id) && (nvs_ate_valid(fs, &wlk_ate))) {
   2b67e:	a904      	add	r1, sp, #16
   2b680:	4620      	mov	r0, r4
   2b682:	f01d fdc1 	bl	49208 <nvs_ate_valid>
   2b686:	2800      	cmp	r0, #0
   2b688:	d0f3      	beq.n	2b672 <nvs_write+0x62>
		rd_addr += wlk_ate.offset;
   2b68a:	f8bd 0012 	ldrh.w	r0, [sp, #18]
			if (wlk_ate.len == 0U) {
   2b68e:	f8bd 3014 	ldrh.w	r3, [sp, #20]
		if (len == 0) {
   2b692:	b175      	cbz	r5, 2b6b2 <nvs_write+0xa2>
		} else if (len == wlk_ate.len) {
   2b694:	429d      	cmp	r5, r3
   2b696:	d10e      	bne.n	2b6b6 <nvs_write+0xa6>
		rd_addr &= ADDR_SECT_MASK;
   2b698:	ea4f 411b 	mov.w	r1, fp, lsr #16
   2b69c:	0409      	lsls	r1, r1, #16
			rc = nvs_flash_block_cmp(fs, rd_addr, data, len);
   2b69e:	4401      	add	r1, r0
   2b6a0:	462b      	mov	r3, r5
   2b6a2:	4642      	mov	r2, r8
   2b6a4:	4620      	mov	r0, r4
   2b6a6:	f01d fd33 	bl	49110 <nvs_flash_block_cmp>
			if (rc <= 0) {
   2b6aa:	2800      	cmp	r0, #0
   2b6ac:	dc03      	bgt.n	2b6b6 <nvs_write+0xa6>
   2b6ae:	4606      	mov	r6, r0
   2b6b0:	e041      	b.n	2b736 <nvs_write+0x126>
			if (wlk_ate.len == 0U) {
   2b6b2:	2b00      	cmp	r3, #0
   2b6b4:	d03f      	beq.n	2b736 <nvs_write+0x126>
			return 0;
		}
	}

	/* calculate required space if the entry contains data */
	if (data_size) {
   2b6b6:	2f00      	cmp	r7, #0
   2b6b8:	d141      	bne.n	2b73e <nvs_write+0x12e>
		/* Leave space for delete ate */
		required_space = data_size + ate_size;
	}

	k_mutex_lock(&fs->nvs_lock, K_FOREVER);
   2b6ba:	f104 0314 	add.w	r3, r4, #20
   2b6be:	9301      	str	r3, [sp, #4]
	return z_impl_k_mutex_lock(mutex, timeout);
   2b6c0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   2b6c4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2b6c8:	f104 0014 	add.w	r0, r4, #20
   2b6cc:	f01b fc6a 	bl	46fa4 <z_impl_k_mutex_lock>
	fs->ate_wra &= ADDR_SECT_MASK;
   2b6d0:	f8df b0d8 	ldr.w	fp, [pc, #216]	; 2b7ac <nvs_write+0x19c>

	gc_count = 0;
	while (1) {
		if (gc_count == fs->sector_count) {
   2b6d4:	89e3      	ldrh	r3, [r4, #14]
   2b6d6:	429e      	cmp	r6, r3
   2b6d8:	d05f      	beq.n	2b79a <nvs_write+0x18a>
			 */
			rc = -ENOSPC;
			goto end;
		}

		if (fs->ate_wra >= (fs->data_wra + required_space)) {
   2b6da:	e9d4 2301 	ldrd	r2, r3, [r4, #4]
   2b6de:	18f9      	adds	r1, r7, r3
   2b6e0:	428a      	cmp	r2, r1
   2b6e2:	d32f      	bcc.n	2b744 <nvs_write+0x134>
	entry.offset = (uint16_t)(fs->data_wra & ADDR_OFFS_MASK);
   2b6e4:	f8ad 301a 	strh.w	r3, [sp, #26]
	nvs_ate_crc8_update(&entry);
   2b6e8:	a806      	add	r0, sp, #24
	entry.part = 0xff;
   2b6ea:	23ff      	movs	r3, #255	; 0xff
   2b6ec:	f88d 301e 	strb.w	r3, [sp, #30]
	entry.id = id;
   2b6f0:	f8ad 9018 	strh.w	r9, [sp, #24]
	entry.len = (uint16_t)len;
   2b6f4:	f8ad 501c 	strh.w	r5, [sp, #28]
	nvs_ate_crc8_update(&entry);
   2b6f8:	f01d fd73 	bl	491e2 <nvs_ate_crc8_update>
	rc = nvs_flash_al_wrt(fs, fs->data_wra, data, len);
   2b6fc:	68a1      	ldr	r1, [r4, #8]
   2b6fe:	462b      	mov	r3, r5
   2b700:	4642      	mov	r2, r8
   2b702:	4620      	mov	r0, r4
   2b704:	f01d fe02 	bl	4930c <nvs_flash_al_wrt>
	fs->data_wra += nvs_al_size(fs, len);
   2b708:	4629      	mov	r1, r5
	rc = nvs_flash_al_wrt(fs, fs->data_wra, data, len);
   2b70a:	4682      	mov	sl, r0
	fs->data_wra += nvs_al_size(fs, len);
   2b70c:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   2b70e:	f01d fd71 	bl	491f4 <nvs_al_size.isra.0>
   2b712:	68a2      	ldr	r2, [r4, #8]
   2b714:	4402      	add	r2, r0
   2b716:	60a2      	str	r2, [r4, #8]
	if (rc) {
   2b718:	f1ba 0f00 	cmp.w	sl, #0
   2b71c:	d107      	bne.n	2b72e <nvs_write+0x11e>
	rc = nvs_flash_ate_wrt(fs, &entry);
   2b71e:	a906      	add	r1, sp, #24
   2b720:	4620      	mov	r0, r4
   2b722:	f01d fe2d 	bl	49380 <nvs_flash_ate_wrt>
		if (rc) {
			goto end;
		}
		gc_count++;
	}
	rc = len;
   2b726:	2800      	cmp	r0, #0
   2b728:	bf14      	ite	ne
   2b72a:	4682      	movne	sl, r0
   2b72c:	46aa      	moveq	sl, r5
	return z_impl_k_mutex_unlock(mutex);
   2b72e:	9801      	ldr	r0, [sp, #4]
   2b730:	f01b fcb2 	bl	47098 <z_impl_k_mutex_unlock>
end:
	k_mutex_unlock(&fs->nvs_lock);
	return rc;
   2b734:	4656      	mov	r6, sl
}
   2b736:	4630      	mov	r0, r6
   2b738:	b009      	add	sp, #36	; 0x24
   2b73a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		required_space = data_size + ate_size;
   2b73e:	4457      	add	r7, sl
   2b740:	b2bf      	uxth	r7, r7
   2b742:	e7ba      	b.n	2b6ba <nvs_write+0xaa>
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   2b744:	2108      	movs	r1, #8
   2b746:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   2b748:	f01d fd54 	bl	491f4 <nvs_al_size.isra.0>
	close_ate.id = 0xFFFF;
   2b74c:	f64f 73ff 	movw	r3, #65535	; 0xffff
   2b750:	f8ad 3018 	strh.w	r3, [sp, #24]
	close_ate.len = 0U;
   2b754:	2300      	movs	r3, #0
   2b756:	f8ad 301c 	strh.w	r3, [sp, #28]
	close_ate.offset = (uint16_t)((fs->ate_wra + ate_size) & ADDR_OFFS_MASK);
   2b75a:	1813      	adds	r3, r2, r0
   2b75c:	f8ad 301a 	strh.w	r3, [sp, #26]
	fs->ate_wra += (fs->sector_size - ate_size);
   2b760:	89a3      	ldrh	r3, [r4, #12]
	fs->ate_wra &= ADDR_SECT_MASK;
   2b762:	ea02 020b 	and.w	r2, r2, fp
	fs->ate_wra += (fs->sector_size - ate_size);
   2b766:	441a      	add	r2, r3
   2b768:	1a10      	subs	r0, r2, r0
   2b76a:	6060      	str	r0, [r4, #4]
	nvs_ate_crc8_update(&close_ate);
   2b76c:	a806      	add	r0, sp, #24
   2b76e:	f01d fd38 	bl	491e2 <nvs_ate_crc8_update>
	rc = nvs_flash_ate_wrt(fs, &close_ate);
   2b772:	a906      	add	r1, sp, #24
   2b774:	4620      	mov	r0, r4
   2b776:	f01d fe03 	bl	49380 <nvs_flash_ate_wrt>
	nvs_sector_advance(fs, &fs->ate_wra);
   2b77a:	1d21      	adds	r1, r4, #4
   2b77c:	4620      	mov	r0, r4
   2b77e:	f01d fcba 	bl	490f6 <nvs_sector_advance>
	fs->data_wra = fs->ate_wra & ADDR_SECT_MASK;
   2b782:	6863      	ldr	r3, [r4, #4]
   2b784:	ea03 030b 	and.w	r3, r3, fp
   2b788:	60a3      	str	r3, [r4, #8]
		rc = nvs_gc(fs);
   2b78a:	4620      	mov	r0, r4
   2b78c:	f01d fe1e 	bl	493cc <nvs_gc>
		if (rc) {
   2b790:	4682      	mov	sl, r0
   2b792:	2800      	cmp	r0, #0
   2b794:	d1cb      	bne.n	2b72e <nvs_write+0x11e>
		gc_count++;
   2b796:	3601      	adds	r6, #1
		if (gc_count == fs->sector_count) {
   2b798:	e79c      	b.n	2b6d4 <nvs_write+0xc4>
			rc = -ENOSPC;
   2b79a:	f06f 0a1b 	mvn.w	sl, #27
   2b79e:	e7c6      	b.n	2b72e <nvs_write+0x11e>
		return -EACCES;
   2b7a0:	f06f 060c 	mvn.w	r6, #12
   2b7a4:	e7c7      	b.n	2b736 <nvs_write+0x126>
		return -EINVAL;
   2b7a6:	f06f 0615 	mvn.w	r6, #21
   2b7aa:	e7c4      	b.n	2b736 <nvs_write+0x126>
   2b7ac:	ffff0000 	.word	0xffff0000

0002b7b0 <class_handler>:
 * usb_enable() is no longer needed.
 */

static int class_handler(struct usb_setup_packet *pSetup,
			 int32_t *len, uint8_t **data)
{
   2b7b0:	b4f0      	push	{r4, r5, r6, r7}
		if_descr = cfg_data->interface_descriptor;
		/*
		 * Wind forward until it is within the range
		 * of the current descriptor.
		 */
		if ((uint8_t *)if_descr < usb_dev.descriptors) {
   2b7b2:	4b0c      	ldr	r3, [pc, #48]	; (2b7e4 <class_handler+0x34>)
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   2b7b4:	4e0c      	ldr	r6, [pc, #48]	; (2b7e8 <class_handler+0x38>)
		if ((uint8_t *)if_descr < usb_dev.descriptors) {
   2b7b6:	6a5f      	ldr	r7, [r3, #36]	; 0x24
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   2b7b8:	4b0c      	ldr	r3, [pc, #48]	; (2b7ec <class_handler+0x3c>)
   2b7ba:	42b3      	cmp	r3, r6
   2b7bc:	d303      	bcc.n	2b7c6 <class_handler+0x16>
			return iface->class_handler(pSetup, len, data);
		}
	}

	return -ENOTSUP;
}
   2b7be:	f06f 0085 	mvn.w	r0, #133	; 0x85
   2b7c2:	bcf0      	pop	{r4, r5, r6, r7}
   2b7c4:	4770      	bx	lr
		if_descr = cfg_data->interface_descriptor;
   2b7c6:	685d      	ldr	r5, [r3, #4]
		if ((uint8_t *)if_descr < usb_dev.descriptors) {
   2b7c8:	42bd      	cmp	r5, r7
   2b7ca:	d309      	bcc.n	2b7e0 <class_handler+0x30>
		if (iface->class_handler &&
   2b7cc:	691c      	ldr	r4, [r3, #16]
   2b7ce:	b13c      	cbz	r4, 2b7e0 <class_handler+0x30>
		    if_descr->bInterfaceNumber == (pSetup->wIndex & 0xFF)) {
   2b7d0:	f895 c002 	ldrb.w	ip, [r5, #2]
   2b7d4:	7905      	ldrb	r5, [r0, #4]
		if (iface->class_handler &&
   2b7d6:	45ac      	cmp	ip, r5
   2b7d8:	d102      	bne.n	2b7e0 <class_handler+0x30>
			return iface->class_handler(pSetup, len, data);
   2b7da:	4623      	mov	r3, r4
}
   2b7dc:	bcf0      	pop	{r4, r5, r6, r7}
			return iface->class_handler(pSetup, len, data);
   2b7de:	4718      	bx	r3
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   2b7e0:	3324      	adds	r3, #36	; 0x24
   2b7e2:	e7ea      	b.n	2b7ba <class_handler+0xa>
   2b7e4:	2000393c 	.word	0x2000393c
   2b7e8:	20001498 	.word	0x20001498
   2b7ec:	20001474 	.word	0x20001474

0002b7f0 <custom_handler>:

static int custom_handler(struct usb_setup_packet *pSetup,
			  int32_t *len, uint8_t **data)
{
   2b7f0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	struct usb_interface_cfg_data *iface;

	LOG_DBG("bRequest 0x%02x, wIndex 0x%04x",
		pSetup->bRequest, pSetup->wIndex);

	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   2b7f4:	4c13      	ldr	r4, [pc, #76]	; (2b844 <custom_handler+0x54>)
   2b7f6:	f8df 8050 	ldr.w	r8, [pc, #80]	; 2b848 <custom_handler+0x58>
		if_descr = cfg_data->interface_descriptor;
		/*
		 * Wind forward until it is within the range
		 * of the current descriptor.
		 */
		if ((uint8_t *)if_descr < usb_dev.descriptors) {
   2b7fa:	f8df 9050 	ldr.w	r9, [pc, #80]	; 2b84c <custom_handler+0x5c>
{
   2b7fe:	4605      	mov	r5, r0
   2b800:	460e      	mov	r6, r1
   2b802:	4617      	mov	r7, r2
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   2b804:	4544      	cmp	r4, r8
   2b806:	d303      	bcc.n	2b810 <custom_handler+0x20>
			}
		}
	}

	return -ENOTSUP;
}
   2b808:	f06f 0085 	mvn.w	r0, #133	; 0x85
   2b80c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		if_descr = cfg_data->interface_descriptor;
   2b810:	6862      	ldr	r2, [r4, #4]
		if ((uint8_t *)if_descr < usb_dev.descriptors) {
   2b812:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
   2b816:	429a      	cmp	r2, r3
   2b818:	d312      	bcc.n	2b840 <custom_handler+0x50>
		if (iface->custom_handler == NULL) {
   2b81a:	69a3      	ldr	r3, [r4, #24]
   2b81c:	b183      	cbz	r3, 2b840 <custom_handler+0x50>
		if (if_descr->bInterfaceNumber == (pSetup->wIndex & 0xFF)) {
   2b81e:	7890      	ldrb	r0, [r2, #2]
   2b820:	7929      	ldrb	r1, [r5, #4]
   2b822:	4288      	cmp	r0, r1
   2b824:	d105      	bne.n	2b832 <custom_handler+0x42>
			return iface->custom_handler(pSetup, len, data);
   2b826:	463a      	mov	r2, r7
   2b828:	4631      	mov	r1, r6
   2b82a:	4628      	mov	r0, r5
}
   2b82c:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
			return iface->custom_handler(pSetup, len, data);
   2b830:	4718      	bx	r3
			if (if_descr->bInterfaceClass == USB_BCC_AUDIO) {
   2b832:	7952      	ldrb	r2, [r2, #5]
   2b834:	2a01      	cmp	r2, #1
   2b836:	d103      	bne.n	2b840 <custom_handler+0x50>
				(void)iface->custom_handler(pSetup, len, data);
   2b838:	463a      	mov	r2, r7
   2b83a:	4631      	mov	r1, r6
   2b83c:	4628      	mov	r0, r5
   2b83e:	4798      	blx	r3
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   2b840:	3424      	adds	r4, #36	; 0x24
   2b842:	e7df      	b.n	2b804 <custom_handler+0x14>
   2b844:	20001474 	.word	0x20001474
   2b848:	20001498 	.word	0x20001498
   2b84c:	2000393c 	.word	0x2000393c

0002b850 <vendor_handler>:

static int vendor_handler(struct usb_setup_packet *pSetup,
			  int32_t *len, uint8_t **data)
{
   2b850:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		if (!usb_handle_os_desc_feature(pSetup, len, data)) {
			return 0;
		}
	}

	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   2b854:	4c0b      	ldr	r4, [pc, #44]	; (2b884 <vendor_handler+0x34>)
   2b856:	f8df 8030 	ldr.w	r8, [pc, #48]	; 2b888 <vendor_handler+0x38>
{
   2b85a:	4605      	mov	r5, r0
   2b85c:	460e      	mov	r6, r1
   2b85e:	4617      	mov	r7, r2
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   2b860:	4544      	cmp	r4, r8
   2b862:	d302      	bcc.n	2b86a <vendor_handler+0x1a>
				return 0;
			}
		}
	}

	return -ENOTSUP;
   2b864:	f06f 0085 	mvn.w	r0, #133	; 0x85
   2b868:	e009      	b.n	2b87e <vendor_handler+0x2e>
		if (iface->vendor_handler) {
   2b86a:	6963      	ldr	r3, [r4, #20]
   2b86c:	b90b      	cbnz	r3, 2b872 <vendor_handler+0x22>
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   2b86e:	3424      	adds	r4, #36	; 0x24
   2b870:	e7f6      	b.n	2b860 <vendor_handler+0x10>
			if (!iface->vendor_handler(pSetup, len, data)) {
   2b872:	463a      	mov	r2, r7
   2b874:	4631      	mov	r1, r6
   2b876:	4628      	mov	r0, r5
   2b878:	4798      	blx	r3
   2b87a:	2800      	cmp	r0, #0
   2b87c:	d1f7      	bne.n	2b86e <vendor_handler+0x1e>
}
   2b87e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2b882:	bf00      	nop
   2b884:	20001474 	.word	0x20001474
   2b888:	20001498 	.word	0x20001498

0002b88c <set_endpoint>:
{
   2b88c:	b507      	push	{r0, r1, r2, lr}
	ep_cfg.ep_addr = ep_desc->bEndpointAddress;
   2b88e:	7883      	ldrb	r3, [r0, #2]
   2b890:	f88d 3000 	strb.w	r3, [sp]
	ep_cfg.ep_mps = sys_le16_to_cpu(ep_desc->wMaxPacketSize);
   2b894:	7903      	ldrb	r3, [r0, #4]
   2b896:	7942      	ldrb	r2, [r0, #5]
   2b898:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   2b89c:	f8ad 3002 	strh.w	r3, [sp, #2]
	ep_cfg.ep_type = ep_desc->bmAttributes & USB_EP_TRANSFER_TYPE_MASK;
   2b8a0:	78c3      	ldrb	r3, [r0, #3]
	ret = usb_dc_ep_configure(&ep_cfg);
   2b8a2:	4668      	mov	r0, sp
	ep_cfg.ep_type = ep_desc->bmAttributes & USB_EP_TRANSFER_TYPE_MASK;
   2b8a4:	f003 0303 	and.w	r3, r3, #3
   2b8a8:	f88d 3004 	strb.w	r3, [sp, #4]
	ret = usb_dc_ep_configure(&ep_cfg);
   2b8ac:	f017 fcb0 	bl	43210 <usb_dc_ep_configure>
	if (ret == -EALREADY) {
   2b8b0:	f110 0f78 	cmn.w	r0, #120	; 0x78
   2b8b4:	d004      	beq.n	2b8c0 <set_endpoint+0x34>
	} else if (ret) {
   2b8b6:	b118      	cbz	r0, 2b8c0 <set_endpoint+0x34>
		return false;
   2b8b8:	2000      	movs	r0, #0
}
   2b8ba:	b003      	add	sp, #12
   2b8bc:	f85d fb04 	ldr.w	pc, [sp], #4
	ret = usb_dc_ep_enable(ep_cfg.ep_addr);
   2b8c0:	f89d 0000 	ldrb.w	r0, [sp]
   2b8c4:	f017 fd2c 	bl	43320 <usb_dc_ep_enable>
	if (ret == -EALREADY) {
   2b8c8:	f110 0f78 	cmn.w	r0, #120	; 0x78
   2b8cc:	d001      	beq.n	2b8d2 <set_endpoint+0x46>
	} else if (ret) {
   2b8ce:	2800      	cmp	r0, #0
   2b8d0:	d1f2      	bne.n	2b8b8 <set_endpoint+0x2c>
	usb_dev.configured = true;
   2b8d2:	4b02      	ldr	r3, [pc, #8]	; (2b8dc <set_endpoint+0x50>)
   2b8d4:	2001      	movs	r0, #1
   2b8d6:	f883 00b9 	strb.w	r0, [r3, #185]	; 0xb9
	return true;
   2b8da:	e7ee      	b.n	2b8ba <set_endpoint+0x2e>
   2b8dc:	2000393c 	.word	0x2000393c

0002b8e0 <usb_reset_alt_setting>:
	memset(usb_dev.alt_setting, 0, ARRAY_SIZE(usb_dev.alt_setting));
   2b8e0:	4802      	ldr	r0, [pc, #8]	; (2b8ec <usb_reset_alt_setting+0xc>)
   2b8e2:	2208      	movs	r2, #8
   2b8e4:	2100      	movs	r1, #0
   2b8e6:	f01f bad3 	b.w	4ae90 <memset>
   2b8ea:	bf00      	nop
   2b8ec:	200039f7 	.word	0x200039f7

0002b8f0 <is_ep_valid.part.0>:
static bool is_ep_valid(uint8_t ep)
   2b8f0:	b570      	push	{r4, r5, r6, lr}
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   2b8f2:	4b0b      	ldr	r3, [pc, #44]	; (2b920 <is_ep_valid.part.0+0x30>)
   2b8f4:	4c0b      	ldr	r4, [pc, #44]	; (2b924 <is_ep_valid.part.0+0x34>)
   2b8f6:	42a3      	cmp	r3, r4
   2b8f8:	d301      	bcc.n	2b8fe <is_ep_valid.part.0+0xe>
	return false;
   2b8fa:	2000      	movs	r0, #0
}
   2b8fc:	bd70      	pop	{r4, r5, r6, pc}
		ep_data = cfg_data->endpoint;
   2b8fe:	6a19      	ldr	r1, [r3, #32]
		for (uint8_t n = 0; n < cfg_data->num_endpoints; n++) {
   2b900:	7f1e      	ldrb	r6, [r3, #28]
   2b902:	2200      	movs	r2, #0
			if (ep_data[n].ep_addr == ep) {
   2b904:	3904      	subs	r1, #4
		for (uint8_t n = 0; n < cfg_data->num_endpoints; n++) {
   2b906:	b2d5      	uxtb	r5, r2
   2b908:	42ae      	cmp	r6, r5
   2b90a:	d801      	bhi.n	2b910 <is_ep_valid.part.0+0x20>
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   2b90c:	3324      	adds	r3, #36	; 0x24
   2b90e:	e7f2      	b.n	2b8f6 <is_ep_valid.part.0+0x6>
			if (ep_data[n].ep_addr == ep) {
   2b910:	3201      	adds	r2, #1
   2b912:	f811 5032 	ldrb.w	r5, [r1, r2, lsl #3]
   2b916:	4285      	cmp	r5, r0
   2b918:	d1f5      	bne.n	2b906 <is_ep_valid.part.0+0x16>
		return true;
   2b91a:	2001      	movs	r0, #1
   2b91c:	e7ee      	b.n	2b8fc <is_ep_valid.part.0+0xc>
   2b91e:	bf00      	nop
   2b920:	20001474 	.word	0x20001474
   2b924:	20001498 	.word	0x20001498

0002b928 <usb_handle_request.constprop.0>:
static bool usb_handle_request(struct usb_setup_packet *setup,
   2b928:	b508      	push	{r3, lr}
	handler = usb_dev.req_handlers[type];
   2b92a:	4809      	ldr	r0, [pc, #36]	; (2b950 <usb_handle_request.constprop.0+0x28>)
	uint32_t type = setup->RequestType.type;
   2b92c:	7803      	ldrb	r3, [r0, #0]
   2b92e:	f3c3 1341 	ubfx	r3, r3, #5, #2
	handler = usb_dev.req_handlers[type];
   2b932:	330a      	adds	r3, #10
   2b934:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
	if (handler == NULL) {
   2b938:	b13b      	cbz	r3, 2b94a <usb_handle_request.constprop.0+0x22>
	if ((*handler)(setup, len, data) < 0) {
   2b93a:	f100 0208 	add.w	r2, r0, #8
   2b93e:	f100 0110 	add.w	r1, r0, #16
   2b942:	4798      	blx	r3
   2b944:	43c0      	mvns	r0, r0
   2b946:	0fc0      	lsrs	r0, r0, #31
}
   2b948:	bd08      	pop	{r3, pc}
		return false;
   2b94a:	4618      	mov	r0, r3
   2b94c:	e7fc      	b.n	2b948 <usb_handle_request.constprop.0+0x20>
   2b94e:	bf00      	nop
   2b950:	2000393c 	.word	0x2000393c

0002b954 <forward_status_cb>:
	if (status == USB_DC_DISCONNECTED) {
   2b954:	2804      	cmp	r0, #4
{
   2b956:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2b95a:	f8df 808c 	ldr.w	r8, [pc, #140]	; 2b9e8 <forward_status_cb+0x94>
   2b95e:	4604      	mov	r4, r0
   2b960:	460e      	mov	r6, r1
	if (status == USB_DC_DISCONNECTED) {
   2b962:	d113      	bne.n	2b98c <forward_status_cb+0x38>
		usb_reset_alt_setting();
   2b964:	f7ff ffbc 	bl	2b8e0 <usb_reset_alt_setting>
		if (usb_dev.configured) {
   2b968:	4b20      	ldr	r3, [pc, #128]	; (2b9ec <forward_status_cb+0x98>)
   2b96a:	f893 30b9 	ldrb.w	r3, [r3, #185]	; 0xb9
   2b96e:	b1ab      	cbz	r3, 2b99c <forward_status_cb+0x48>
			usb_cancel_transfers();
   2b970:	f000 fcfe 	bl	2c370 <usb_cancel_transfers>
   2b974:	4d1e      	ldr	r5, [pc, #120]	; (2b9f0 <forward_status_cb+0x9c>)
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   2b976:	4545      	cmp	r5, r8
   2b978:	d226      	bcs.n	2b9c8 <forward_status_cb+0x74>
		ep_data = cfg_data->endpoint;
   2b97a:	f8d5 9020 	ldr.w	r9, [r5, #32]
		for (uint8_t n = 0; n < cfg_data->num_endpoints; n++) {
   2b97e:	2700      	movs	r7, #0
   2b980:	7f2a      	ldrb	r2, [r5, #28]
   2b982:	b2fb      	uxtb	r3, r7
   2b984:	429a      	cmp	r2, r3
   2b986:	d817      	bhi.n	2b9b8 <forward_status_cb+0x64>
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   2b988:	3524      	adds	r5, #36	; 0x24
   2b98a:	e7f4      	b.n	2b976 <forward_status_cb+0x22>
	if (status == USB_DC_DISCONNECTED || status == USB_DC_SUSPEND || status == USB_DC_RESET) {
   2b98c:	2805      	cmp	r0, #5
   2b98e:	d110      	bne.n	2b9b2 <forward_status_cb+0x5e>
		if (usb_dev.configured) {
   2b990:	4b16      	ldr	r3, [pc, #88]	; (2b9ec <forward_status_cb+0x98>)
   2b992:	f893 30b9 	ldrb.w	r3, [r3, #185]	; 0xb9
   2b996:	b10b      	cbz	r3, 2b99c <forward_status_cb+0x48>
			usb_cancel_transfers();
   2b998:	f000 fcea 	bl	2c370 <usb_cancel_transfers>
   2b99c:	4d14      	ldr	r5, [pc, #80]	; (2b9f0 <forward_status_cb+0x9c>)
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   2b99e:	4545      	cmp	r5, r8
   2b9a0:	d317      	bcc.n	2b9d2 <forward_status_cb+0x7e>
	if (usb_dev.user_status_callback) {
   2b9a2:	4b12      	ldr	r3, [pc, #72]	; (2b9ec <forward_status_cb+0x98>)
   2b9a4:	6a1b      	ldr	r3, [r3, #32]
   2b9a6:	b1e3      	cbz	r3, 2b9e2 <forward_status_cb+0x8e>
		usb_dev.user_status_callback(status, param);
   2b9a8:	4631      	mov	r1, r6
   2b9aa:	4620      	mov	r0, r4
}
   2b9ac:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		usb_dev.user_status_callback(status, param);
   2b9b0:	4718      	bx	r3
	if (status == USB_DC_DISCONNECTED || status == USB_DC_SUSPEND || status == USB_DC_RESET) {
   2b9b2:	2801      	cmp	r0, #1
   2b9b4:	d1f2      	bne.n	2b99c <forward_status_cb+0x48>
   2b9b6:	e7d7      	b.n	2b968 <forward_status_cb+0x14>
	return usb_dc_ep_disable(ep_data->ep_addr);
   2b9b8:	eb09 03c3 	add.w	r3, r9, r3, lsl #3
			if (ret < 0) {
   2b9bc:	3701      	adds	r7, #1
	return usb_dc_ep_disable(ep_data->ep_addr);
   2b9be:	7918      	ldrb	r0, [r3, #4]
   2b9c0:	f017 fcd8 	bl	43374 <usb_dc_ep_disable>
			if (ret < 0) {
   2b9c4:	2800      	cmp	r0, #0
   2b9c6:	dadb      	bge.n	2b980 <forward_status_cb+0x2c>
				usb_dev.configured = false;
   2b9c8:	4b08      	ldr	r3, [pc, #32]	; (2b9ec <forward_status_cb+0x98>)
   2b9ca:	2200      	movs	r2, #0
   2b9cc:	f883 20b9 	strb.w	r2, [r3, #185]	; 0xb9
   2b9d0:	e7e4      	b.n	2b99c <forward_status_cb+0x48>
		if (cfg_data->cb_usb_status) {
   2b9d2:	68eb      	ldr	r3, [r5, #12]
   2b9d4:	b11b      	cbz	r3, 2b9de <forward_status_cb+0x8a>
			cfg_data->cb_usb_status(cfg_data, status, param);
   2b9d6:	4632      	mov	r2, r6
   2b9d8:	4621      	mov	r1, r4
   2b9da:	4628      	mov	r0, r5
   2b9dc:	4798      	blx	r3
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   2b9de:	3524      	adds	r5, #36	; 0x24
   2b9e0:	e7dd      	b.n	2b99e <forward_status_cb+0x4a>
}
   2b9e2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2b9e6:	bf00      	nop
   2b9e8:	20001498 	.word	0x20001498
   2b9ec:	2000393c 	.word	0x2000393c
   2b9f0:	20001474 	.word	0x20001474

0002b9f4 <usb_halt_endpoint_req.isra.0>:
static bool usb_halt_endpoint_req(struct usb_setup_packet *setup, bool halt)
   2b9f4:	b573      	push	{r0, r1, r4, r5, r6, lr}
	uint8_t ep = setup->wIndex;
   2b9f6:	b2c4      	uxtb	r4, r0
	if (USB_EP_GET_IDX(ep) == 0) {
   2b9f8:	0663      	lsls	r3, r4, #25
static bool usb_halt_endpoint_req(struct usb_setup_packet *setup, bool halt)
   2b9fa:	460d      	mov	r5, r1
	uint8_t ep = setup->wIndex;
   2b9fc:	f88d 4007 	strb.w	r4, [sp, #7]
	if (USB_EP_GET_IDX(ep) == 0) {
   2ba00:	d007      	beq.n	2ba12 <usb_halt_endpoint_req.isra.0+0x1e>
   2ba02:	4620      	mov	r0, r4
   2ba04:	f7ff ff74 	bl	2b8f0 <is_ep_valid.part.0>
	if (!is_ep_valid(ep)) {
   2ba08:	b178      	cbz	r0, 2ba2a <usb_halt_endpoint_req.isra.0+0x36>
	return (usb_dev.configuration != 0);
   2ba0a:	4b0d      	ldr	r3, [pc, #52]	; (2ba40 <usb_halt_endpoint_req.isra.0+0x4c>)
	if ((USB_EP_GET_IDX(ep) == 0) || is_device_configured()) {
   2ba0c:	f893 00ba 	ldrb.w	r0, [r3, #186]	; 0xba
   2ba10:	b158      	cbz	r0, 2ba2a <usb_halt_endpoint_req.isra.0+0x36>
		if (halt) {
   2ba12:	4e0b      	ldr	r6, [pc, #44]	; (2ba40 <usb_halt_endpoint_req.isra.0+0x4c>)
			usb_dc_ep_set_stall(ep);
   2ba14:	4620      	mov	r0, r4
		if (halt) {
   2ba16:	b155      	cbz	r5, 2ba2e <usb_halt_endpoint_req.isra.0+0x3a>
			usb_dc_ep_set_stall(ep);
   2ba18:	f017 fc1e 	bl	43258 <usb_dc_ep_set_stall>
			if (usb_dev.status_callback) {
   2ba1c:	69f3      	ldr	r3, [r6, #28]
   2ba1e:	b11b      	cbz	r3, 2ba28 <usb_halt_endpoint_req.isra.0+0x34>
				usb_dev.status_callback(USB_DC_SET_HALT, &ep);
   2ba20:	f10d 0107 	add.w	r1, sp, #7
   2ba24:	2008      	movs	r0, #8
				usb_dev.status_callback(USB_DC_CLEAR_HALT, &ep);
   2ba26:	4798      	blx	r3
		return true;
   2ba28:	2001      	movs	r0, #1
}
   2ba2a:	b002      	add	sp, #8
   2ba2c:	bd70      	pop	{r4, r5, r6, pc}
			usb_dc_ep_clear_stall(ep);
   2ba2e:	f017 fc3b 	bl	432a8 <usb_dc_ep_clear_stall>
			if (usb_dev.status_callback) {
   2ba32:	69f3      	ldr	r3, [r6, #28]
   2ba34:	2b00      	cmp	r3, #0
   2ba36:	d0f7      	beq.n	2ba28 <usb_halt_endpoint_req.isra.0+0x34>
				usb_dev.status_callback(USB_DC_CLEAR_HALT, &ep);
   2ba38:	f10d 0107 	add.w	r1, sp, #7
   2ba3c:	2009      	movs	r0, #9
   2ba3e:	e7f2      	b.n	2ba26 <usb_halt_endpoint_req.isra.0+0x32>
   2ba40:	2000393c 	.word	0x2000393c

0002ba44 <usb_handle_standard_request>:
{
   2ba44:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if (usb_dev.custom_req_handler &&
   2ba48:	4ea4      	ldr	r6, [pc, #656]	; (2bcdc <usb_handle_standard_request+0x298>)
   2ba4a:	69b3      	ldr	r3, [r6, #24]
{
   2ba4c:	4604      	mov	r4, r0
   2ba4e:	460f      	mov	r7, r1
   2ba50:	4615      	mov	r5, r2
	if (usb_dev.custom_req_handler &&
   2ba52:	b9fb      	cbnz	r3, 2ba94 <usb_handle_standard_request+0x50>
	switch (setup->RequestType.recipient) {
   2ba54:	7823      	ldrb	r3, [r4, #0]
   2ba56:	f003 031f 	and.w	r3, r3, #31
   2ba5a:	2b01      	cmp	r3, #1
   2ba5c:	f000 809d 	beq.w	2bb9a <usb_handle_standard_request+0x156>
   2ba60:	2b02      	cmp	r3, #2
   2ba62:	f000 8107 	beq.w	2bc74 <usb_handle_standard_request+0x230>
   2ba66:	bb33      	cbnz	r3, 2bab6 <usb_handle_standard_request+0x72>
	if (usb_reqtype_is_to_host(setup)) {
   2ba68:	f994 0000 	ldrsb.w	r0, [r4]
	uint8_t *data = *data_buf;
   2ba6c:	682a      	ldr	r2, [r5, #0]
		switch (setup->bRequest) {
   2ba6e:	7861      	ldrb	r1, [r4, #1]
	if (usb_reqtype_is_to_host(setup)) {
   2ba70:	2800      	cmp	r0, #0
   2ba72:	da34      	bge.n	2bade <usb_handle_standard_request+0x9a>
		switch (setup->bRequest) {
   2ba74:	2906      	cmp	r1, #6
   2ba76:	d012      	beq.n	2ba9e <usb_handle_standard_request+0x5a>
   2ba78:	2908      	cmp	r1, #8
   2ba7a:	d02b      	beq.n	2bad4 <usb_handle_standard_request+0x90>
   2ba7c:	b9d9      	cbnz	r1, 2bab6 <usb_handle_standard_request+0x72>
		data[0] |= USB_GET_STATUS_SELF_POWERED;
   2ba7e:	2301      	movs	r3, #1
   2ba80:	7013      	strb	r3, [r2, #0]
	data[1] = 0U;
   2ba82:	7051      	strb	r1, [r2, #1]
		data[0] |= (usb_dev.remote_wakeup ?
   2ba84:	f896 30c3 	ldrb.w	r3, [r6, #195]	; 0xc3
   2ba88:	005b      	lsls	r3, r3, #1
   2ba8a:	f043 0301 	orr.w	r3, r3, #1
   2ba8e:	7013      	strb	r3, [r2, #0]
		*len = 2;
   2ba90:	2302      	movs	r3, #2
   2ba92:	e12c      	b.n	2bcee <usb_handle_standard_request+0x2aa>
	    !usb_dev.custom_req_handler(setup, len, data_buf)) {
   2ba94:	4798      	blx	r3
	if (usb_dev.custom_req_handler &&
   2ba96:	2800      	cmp	r0, #0
   2ba98:	d1dc      	bne.n	2ba54 <usb_handle_standard_request+0x10>
		return 0;
   2ba9a:	2000      	movs	r0, #0
   2ba9c:	e00d      	b.n	2baba <usb_handle_standard_request+0x76>
			return usb_get_descriptor(setup, len, data_buf);
   2ba9e:	8862      	ldrh	r2, [r4, #2]
	type = USB_GET_DESCRIPTOR_TYPE(setup->wValue);
   2baa0:	0a10      	lsrs	r0, r2, #8
	if ((type == USB_DESC_INTERFACE) || (type == USB_DESC_ENDPOINT) ||
   2baa2:	1f01      	subs	r1, r0, #4
   2baa4:	2901      	cmp	r1, #1
	type = USB_GET_DESCRIPTOR_TYPE(setup->wValue);
   2baa6:	4684      	mov	ip, r0
	if ((type == USB_DESC_INTERFACE) || (type == USB_DESC_ENDPOINT) ||
   2baa8:	d905      	bls.n	2bab6 <usb_handle_standard_request+0x72>
   2baaa:	2807      	cmp	r0, #7
   2baac:	d803      	bhi.n	2bab6 <usb_handle_standard_request+0x72>
	p = (uint8_t *)usb_dev.descriptors;
   2baae:	6a71      	ldr	r1, [r6, #36]	; 0x24
	index = USB_GET_DESCRIPTOR_INDEX(setup->wValue);
   2bab0:	b2d2      	uxtb	r2, r2
	while (p[DESC_bLength] != 0U) {
   2bab2:	780c      	ldrb	r4, [r1, #0]
   2bab4:	b91c      	cbnz	r4, 2babe <usb_handle_standard_request+0x7a>
			rc = -EINVAL;
   2bab6:	f06f 0015 	mvn.w	r0, #21
}
   2baba:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		if (p[DESC_bDescriptorType] == type) {
   2babe:	784e      	ldrb	r6, [r1, #1]
   2bac0:	4566      	cmp	r6, ip
   2bac2:	d103      	bne.n	2bacc <usb_handle_standard_request+0x88>
			if (cur_index == index) {
   2bac4:	429a      	cmp	r2, r3
   2bac6:	f000 810d 	beq.w	2bce4 <usb_handle_standard_request+0x2a0>
			cur_index++;
   2baca:	3301      	adds	r3, #1
		p += p[DESC_bLength];
   2bacc:	4421      	add	r1, r4
   2bace:	e7f0      	b.n	2bab2 <usb_handle_standard_request+0x6e>
			*len = p[DESC_bLength];
   2bad0:	780b      	ldrb	r3, [r1, #0]
   2bad2:	e10c      	b.n	2bcee <usb_handle_standard_request+0x2aa>
			data[0] = usb_dev.configuration;
   2bad4:	f896 30ba 	ldrb.w	r3, [r6, #186]	; 0xba
   2bad8:	7013      	strb	r3, [r2, #0]
				*len = 1;
   2bada:	2301      	movs	r3, #1
   2badc:	e107      	b.n	2bcee <usb_handle_standard_request+0x2aa>
		switch (setup->bRequest) {
   2bade:	3901      	subs	r1, #1
   2bae0:	2908      	cmp	r1, #8
   2bae2:	d8e8      	bhi.n	2bab6 <usb_handle_standard_request+0x72>
   2bae4:	a301      	add	r3, pc, #4	; (adr r3, 2baec <usb_handle_standard_request+0xa8>)
   2bae6:	f853 f021 	ldr.w	pc, [r3, r1, lsl #2]
   2baea:	bf00      	nop
   2baec:	0002bb85 	.word	0x0002bb85
   2baf0:	0002bab7 	.word	0x0002bab7
   2baf4:	0002bb93 	.word	0x0002bb93
   2baf8:	0002bab7 	.word	0x0002bab7
   2bafc:	0002bb11 	.word	0x0002bb11
   2bb00:	0002bab7 	.word	0x0002bab7
   2bb04:	0002bab7 	.word	0x0002bab7
   2bb08:	0002bab7 	.word	0x0002bab7
   2bb0c:	0002bb1d 	.word	0x0002bb1d
			return !usb_dc_set_address(setup->wValue);
   2bb10:	78a0      	ldrb	r0, [r4, #2]
   2bb12:	f017 fb6b 	bl	431ec <usb_dc_set_address>
		if (usb_handle_std_device_req(setup, len, data_buf) == false) {
   2bb16:	2800      	cmp	r0, #0
   2bb18:	d0bf      	beq.n	2ba9a <usb_handle_standard_request+0x56>
   2bb1a:	e7cc      	b.n	2bab6 <usb_handle_standard_request+0x72>
	if (setup->wValue == 0U) {
   2bb1c:	8863      	ldrh	r3, [r4, #2]
	uint8_t *p = (uint8_t *)usb_dev.descriptors;
   2bb1e:	6a75      	ldr	r5, [r6, #36]	; 0x24
	if (setup->wValue == 0U) {
   2bb20:	bb63      	cbnz	r3, 2bb7c <usb_handle_standard_request+0x138>
		usb_reset_alt_setting();
   2bb22:	f7ff fedd 	bl	2b8e0 <usb_reset_alt_setting>
		usb_dev.configuration = setup->wValue;
   2bb26:	8863      	ldrh	r3, [r4, #2]
   2bb28:	f886 30ba 	strb.w	r3, [r6, #186]	; 0xba
		if (usb_dev.status_callback) {
   2bb2c:	69f3      	ldr	r3, [r6, #28]
   2bb2e:	2b00      	cmp	r3, #0
   2bb30:	d0b3      	beq.n	2ba9a <usb_handle_standard_request+0x56>
			usb_dev.status_callback(USB_DC_CONFIGURED,
   2bb32:	496b      	ldr	r1, [pc, #428]	; (2bce0 <usb_handle_standard_request+0x29c>)
   2bb34:	2003      	movs	r0, #3
   2bb36:	4798      	blx	r3
   2bb38:	e7af      	b.n	2ba9a <usb_handle_standard_request+0x56>
		switch (p[DESC_bDescriptorType]) {
   2bb3a:	786b      	ldrb	r3, [r5, #1]
   2bb3c:	2b04      	cmp	r3, #4
   2bb3e:	d010      	beq.n	2bb62 <usb_handle_standard_request+0x11e>
   2bb40:	2b05      	cmp	r3, #5
   2bb42:	d011      	beq.n	2bb68 <usb_handle_standard_request+0x124>
   2bb44:	2b02      	cmp	r3, #2
   2bb46:	d104      	bne.n	2bb52 <usb_handle_standard_request+0x10e>
			cur_config = p[CONF_DESC_bConfigurationValue];
   2bb48:	796f      	ldrb	r7, [r5, #5]
			if (cur_config == setup->wValue) {
   2bb4a:	8863      	ldrh	r3, [r4, #2]
				found = true;
   2bb4c:	42bb      	cmp	r3, r7
   2bb4e:	bf08      	it	eq
   2bb50:	2001      	moveq	r0, #1
		p += p[DESC_bLength];
   2bb52:	782b      	ldrb	r3, [r5, #0]
   2bb54:	441d      	add	r5, r3
	while (p[DESC_bLength] != 0U) {
   2bb56:	782b      	ldrb	r3, [r5, #0]
   2bb58:	2b00      	cmp	r3, #0
   2bb5a:	d1ee      	bne.n	2bb3a <usb_handle_standard_request+0xf6>
	if (found) {
   2bb5c:	2800      	cmp	r0, #0
   2bb5e:	d0aa      	beq.n	2bab6 <usb_handle_standard_request+0x72>
   2bb60:	e7df      	b.n	2bb22 <usb_handle_standard_request+0xde>
			cur_alt_setting =
   2bb62:	f895 8003 	ldrb.w	r8, [r5, #3]
			break;
   2bb66:	e7f4      	b.n	2bb52 <usb_handle_standard_request+0x10e>
			if ((cur_config != setup->wValue) ||
   2bb68:	8863      	ldrh	r3, [r4, #2]
   2bb6a:	42bb      	cmp	r3, r7
   2bb6c:	d1f1      	bne.n	2bb52 <usb_handle_standard_request+0x10e>
   2bb6e:	f1b8 0f00 	cmp.w	r8, #0
   2bb72:	d1ee      	bne.n	2bb52 <usb_handle_standard_request+0x10e>
			found = set_endpoint((struct usb_ep_descriptor *)p);
   2bb74:	4628      	mov	r0, r5
   2bb76:	f7ff fe89 	bl	2b88c <set_endpoint>
			break;
   2bb7a:	e7ea      	b.n	2bb52 <usb_handle_standard_request+0x10e>
	uint8_t cur_config = 0xFF;
   2bb7c:	27ff      	movs	r7, #255	; 0xff
	bool found = false;
   2bb7e:	2000      	movs	r0, #0
	uint8_t cur_alt_setting = 0xFF;
   2bb80:	46b8      	mov	r8, r7
   2bb82:	e7e8      	b.n	2bb56 <usb_handle_standard_request+0x112>
				if (setup->wValue == USB_SFS_REMOTE_WAKEUP) {
   2bb84:	8863      	ldrh	r3, [r4, #2]
   2bb86:	2b01      	cmp	r3, #1
   2bb88:	d195      	bne.n	2bab6 <usb_handle_standard_request+0x72>
					usb_dev.remote_wakeup = false;
   2bb8a:	2300      	movs	r3, #0
					usb_dev.remote_wakeup = true;
   2bb8c:	f886 30c3 	strb.w	r3, [r6, #195]	; 0xc3
					return true;
   2bb90:	e783      	b.n	2ba9a <usb_handle_standard_request+0x56>
				if (setup->wValue == USB_SFS_REMOTE_WAKEUP) {
   2bb92:	8863      	ldrh	r3, [r4, #2]
   2bb94:	2b01      	cmp	r3, #1
   2bb96:	d18e      	bne.n	2bab6 <usb_handle_standard_request+0x72>
   2bb98:	e7f8      	b.n	2bb8c <usb_handle_standard_request+0x148>
	if (!is_device_configured() ||
   2bb9a:	f896 30ba 	ldrb.w	r3, [r6, #186]	; 0xba
   2bb9e:	f8d5 c000 	ldr.w	ip, [r5]
   2bba2:	2b00      	cmp	r3, #0
   2bba4:	d087      	beq.n	2bab6 <usb_handle_standard_request+0x72>
	const uint8_t *p = (uint8_t *)usb_dev.descriptors;
   2bba6:	6a75      	ldr	r5, [r6, #36]	; 0x24
	   (!is_interface_valid((uint8_t)setup->wIndex))) {
   2bba8:	88a3      	ldrh	r3, [r4, #4]
   2bbaa:	f894 e004 	ldrb.w	lr, [r4, #4]
	const uint8_t *p = (uint8_t *)usb_dev.descriptors;
   2bbae:	462a      	mov	r2, r5
	while (p[DESC_bLength] != 0U) {
   2bbb0:	7810      	ldrb	r0, [r2, #0]
   2bbb2:	2800      	cmp	r0, #0
   2bbb4:	f43f af7f 	beq.w	2bab6 <usb_handle_standard_request+0x72>
		if (p[DESC_bDescriptorType] == USB_DESC_CONFIGURATION) {
   2bbb8:	7851      	ldrb	r1, [r2, #1]
   2bbba:	2902      	cmp	r1, #2
   2bbbc:	d104      	bne.n	2bbc8 <usb_handle_standard_request+0x184>
			if (interface < cfg_descr->bNumInterfaces) {
   2bbbe:	f892 8004 	ldrb.w	r8, [r2, #4]
   2bbc2:	45f0      	cmp	r8, lr
   2bbc4:	f200 8095 	bhi.w	2bcf2 <usb_handle_standard_request+0x2ae>
		p += p[DESC_bLength];
   2bbc8:	4402      	add	r2, r0
   2bbca:	e7f1      	b.n	2bbb0 <usb_handle_standard_request+0x16c>
			data[0] = 0U;
   2bbcc:	f88c 2000 	strb.w	r2, [ip]
			data[1] = 0U;
   2bbd0:	f88c 2001 	strb.w	r2, [ip, #1]
			*len = 2;
   2bbd4:	6039      	str	r1, [r7, #0]
			return true;
   2bbd6:	e760      	b.n	2ba9a <usb_handle_standard_request+0x56>
		p += p[DESC_bLength];
   2bbd8:	4415      	add	r5, r2
   2bbda:	e096      	b.n	2bd0a <usb_handle_standard_request+0x2c6>
		if (setup->bRequest == USB_SREQ_SET_INTERFACE) {
   2bbdc:	2a0b      	cmp	r2, #11
   2bbde:	f47f af6a 	bne.w	2bab6 <usb_handle_standard_request+0x72>
	bool ret = false;
   2bbe2:	2700      	movs	r7, #0
	uint8_t cur_iface = 0xFF;
   2bbe4:	f04f 08ff 	mov.w	r8, #255	; 0xff
	uint8_t cur_alt_setting = 0xFF;
   2bbe8:	46c1      	mov	r9, r8
	const uint8_t *if_desc = NULL;
   2bbea:	46ba      	mov	sl, r7
   2bbec:	e006      	b.n	2bbfc <usb_handle_standard_request+0x1b8>
		switch (p[DESC_bDescriptorType]) {
   2bbee:	786b      	ldrb	r3, [r5, #1]
   2bbf0:	2b04      	cmp	r3, #4
   2bbf2:	d00f      	beq.n	2bc14 <usb_handle_standard_request+0x1d0>
   2bbf4:	2b05      	cmp	r3, #5
   2bbf6:	d021      	beq.n	2bc3c <usb_handle_standard_request+0x1f8>
		p += p[DESC_bLength];
   2bbf8:	782b      	ldrb	r3, [r5, #0]
   2bbfa:	441d      	add	r5, r3
	while (p[DESC_bLength] != 0U) {
   2bbfc:	782b      	ldrb	r3, [r5, #0]
   2bbfe:	2b00      	cmp	r3, #0
   2bc00:	d1f5      	bne.n	2bbee <usb_handle_standard_request+0x1aa>
	if (usb_dev.status_callback) {
   2bc02:	69f3      	ldr	r3, [r6, #28]
   2bc04:	b113      	cbz	r3, 2bc0c <usb_handle_standard_request+0x1c8>
		usb_dev.status_callback(USB_DC_INTERFACE, if_desc);
   2bc06:	4651      	mov	r1, sl
   2bc08:	2007      	movs	r0, #7
   2bc0a:	4798      	blx	r3
		if (usb_handle_std_interface_req(setup, len, data_buf) == false) {
   2bc0c:	2f00      	cmp	r7, #0
   2bc0e:	f47f af44 	bne.w	2ba9a <usb_handle_standard_request+0x56>
   2bc12:	e750      	b.n	2bab6 <usb_handle_standard_request+0x72>
			cur_iface = p[INTF_DESC_bInterfaceNumber];
   2bc14:	f895 8002 	ldrb.w	r8, [r5, #2]
			if (cur_iface == setup->wIndex &&
   2bc18:	88a3      	ldrh	r3, [r4, #4]
			cur_alt_setting = p[INTF_DESC_bAlternateSetting];
   2bc1a:	f895 9003 	ldrb.w	r9, [r5, #3]
			if (cur_iface == setup->wIndex &&
   2bc1e:	4598      	cmp	r8, r3
   2bc20:	d1ea      	bne.n	2bbf8 <usb_handle_standard_request+0x1b4>
			    cur_alt_setting == setup->wValue) {
   2bc22:	8863      	ldrh	r3, [r4, #2]
			if (cur_iface == setup->wIndex &&
   2bc24:	4599      	cmp	r9, r3
   2bc26:	d1e7      	bne.n	2bbf8 <usb_handle_standard_request+0x1b4>
	if (iface < ARRAY_SIZE(usb_dev.alt_setting)) {
   2bc28:	f1b8 0f07 	cmp.w	r8, #7
   2bc2c:	d81f      	bhi.n	2bc6e <usb_handle_standard_request+0x22a>
		usb_dev.alt_setting[iface] = alt_setting;
   2bc2e:	eb06 0308 	add.w	r3, r6, r8
		return true;
   2bc32:	46aa      	mov	sl, r5
				ret = usb_set_alt_setting(setup->wIndex,
   2bc34:	f883 90bb 	strb.w	r9, [r3, #187]	; 0xbb
	return true;
   2bc38:	2701      	movs	r7, #1
   2bc3a:	e7dd      	b.n	2bbf8 <usb_handle_standard_request+0x1b4>
			if (cur_iface == setup->wIndex) {
   2bc3c:	88a3      	ldrh	r3, [r4, #4]
   2bc3e:	4543      	cmp	r3, r8
   2bc40:	d1da      	bne.n	2bbf8 <usb_handle_standard_request+0x1b4>
	if (cur_alt_setting != alt_setting) {
   2bc42:	78a3      	ldrb	r3, [r4, #2]
   2bc44:	454b      	cmp	r3, r9
   2bc46:	d00d      	beq.n	2bc64 <usb_handle_standard_request+0x220>
		ret = reset_endpoint(ep_desc);
   2bc48:	78af      	ldrb	r7, [r5, #2]
	usb_cancel_transfer(ep_cfg.ep_addr);
   2bc4a:	4638      	mov	r0, r7
   2bc4c:	f000 fb72 	bl	2c334 <usb_cancel_transfer>
	ret = usb_dc_ep_disable(ep_cfg.ep_addr);
   2bc50:	4638      	mov	r0, r7
   2bc52:	f017 fb8f 	bl	43374 <usb_dc_ep_disable>
	if (ret == -EALREADY) {
   2bc56:	f110 0f78 	cmn.w	r0, #120	; 0x78
   2bc5a:	d0ed      	beq.n	2bc38 <usb_handle_standard_request+0x1f4>
	} else if (ret) {
   2bc5c:	fab0 f780 	clz	r7, r0
   2bc60:	097f      	lsrs	r7, r7, #5
   2bc62:	e7c9      	b.n	2bbf8 <usb_handle_standard_request+0x1b4>
		ret = set_endpoint(ep_desc);
   2bc64:	4628      	mov	r0, r5
   2bc66:	f7ff fe11 	bl	2b88c <set_endpoint>
   2bc6a:	4607      	mov	r7, r0
   2bc6c:	e7c4      	b.n	2bbf8 <usb_handle_standard_request+0x1b4>
   2bc6e:	46aa      	mov	sl, r5
	return false;
   2bc70:	2700      	movs	r7, #0
   2bc72:	e7c1      	b.n	2bbf8 <usb_handle_standard_request+0x1b4>
	if (usb_reqtype_is_to_host(setup)) {
   2bc74:	f994 2000 	ldrsb.w	r2, [r4]
		switch (setup->bRequest) {
   2bc78:	7863      	ldrb	r3, [r4, #1]
	if (usb_reqtype_is_to_host(setup)) {
   2bc7a:	2a00      	cmp	r2, #0
   2bc7c:	da18      	bge.n	2bcb0 <usb_handle_standard_request+0x26c>
		if (setup->bRequest == USB_SREQ_GET_STATUS) {
   2bc7e:	2b00      	cmp	r3, #0
   2bc80:	f47f af19 	bne.w	2bab6 <usb_handle_standard_request+0x72>
	uint8_t ep = setup->wIndex;
   2bc84:	7924      	ldrb	r4, [r4, #4]
   2bc86:	682d      	ldr	r5, [r5, #0]
	if (USB_EP_GET_IDX(ep) == 0) {
   2bc88:	0663      	lsls	r3, r4, #25
   2bc8a:	d00a      	beq.n	2bca2 <usb_handle_standard_request+0x25e>
   2bc8c:	4620      	mov	r0, r4
   2bc8e:	f7ff fe2f 	bl	2b8f0 <is_ep_valid.part.0>
	if (!is_ep_valid(ep)) {
   2bc92:	2800      	cmp	r0, #0
   2bc94:	f43f af0f 	beq.w	2bab6 <usb_handle_standard_request+0x72>
	if ((USB_EP_GET_IDX(ep) == 0) || is_device_configured()) {
   2bc98:	f896 30ba 	ldrb.w	r3, [r6, #186]	; 0xba
   2bc9c:	2b00      	cmp	r3, #0
   2bc9e:	f43f af0a 	beq.w	2bab6 <usb_handle_standard_request+0x72>
		usb_dc_ep_is_stalled(ep, &data[0]);
   2bca2:	4629      	mov	r1, r5
   2bca4:	4620      	mov	r0, r4
   2bca6:	f017 fb1f 	bl	432e8 <usb_dc_ep_is_stalled>
		data[1] = 0U;
   2bcaa:	2300      	movs	r3, #0
   2bcac:	706b      	strb	r3, [r5, #1]
   2bcae:	e6ef      	b.n	2ba90 <usb_handle_standard_request+0x4c>
		switch (setup->bRequest) {
   2bcb0:	2b01      	cmp	r3, #1
   2bcb2:	d008      	beq.n	2bcc6 <usb_handle_standard_request+0x282>
   2bcb4:	2b03      	cmp	r3, #3
   2bcb6:	f47f aefe 	bne.w	2bab6 <usb_handle_standard_request+0x72>
			if (setup->wValue == USB_SFS_ENDPOINT_HALT) {
   2bcba:	8863      	ldrh	r3, [r4, #2]
   2bcbc:	2b00      	cmp	r3, #0
   2bcbe:	f47f aefa 	bne.w	2bab6 <usb_handle_standard_request+0x72>
				return usb_halt_endpoint_req(setup, true);
   2bcc2:	2101      	movs	r1, #1
   2bcc4:	e003      	b.n	2bcce <usb_handle_standard_request+0x28a>
			if (setup->wValue == USB_SFS_ENDPOINT_HALT) {
   2bcc6:	8861      	ldrh	r1, [r4, #2]
   2bcc8:	2900      	cmp	r1, #0
   2bcca:	f47f aef4 	bne.w	2bab6 <usb_handle_standard_request+0x72>
				return usb_halt_endpoint_req(setup, true);
   2bcce:	88a0      	ldrh	r0, [r4, #4]
   2bcd0:	f7ff fe90 	bl	2b9f4 <usb_halt_endpoint_req.isra.0>
		if (usb_handle_std_endpoint_req(setup, len, data_buf) == false) {
   2bcd4:	2800      	cmp	r0, #0
   2bcd6:	f47f aee0 	bne.w	2ba9a <usb_handle_standard_request+0x56>
   2bcda:	e6ec      	b.n	2bab6 <usb_handle_standard_request+0x72>
   2bcdc:	2000393c 	.word	0x2000393c
   2bce0:	200039f6 	.word	0x200039f6
		if (type == USB_DESC_CONFIGURATION) {
   2bce4:	2802      	cmp	r0, #2
		*data = p;
   2bce6:	6029      	str	r1, [r5, #0]
		if (type == USB_DESC_CONFIGURATION) {
   2bce8:	f47f aef2 	bne.w	2bad0 <usb_handle_standard_request+0x8c>
			*len = (p[CONF_DESC_wTotalLength]) |
   2bcec:	884b      	ldrh	r3, [r1, #2]
		*len = 2;
   2bcee:	603b      	str	r3, [r7, #0]
		return true;
   2bcf0:	e6d3      	b.n	2ba9a <usb_handle_standard_request+0x56>
	if (usb_reqtype_is_to_host(setup)) {
   2bcf2:	f994 0000 	ldrsb.w	r0, [r4]
		switch (setup->bRequest) {
   2bcf6:	7862      	ldrb	r2, [r4, #1]
	if (usb_reqtype_is_to_host(setup)) {
   2bcf8:	2800      	cmp	r0, #0
   2bcfa:	f6bf af6f 	bge.w	2bbdc <usb_handle_standard_request+0x198>
		switch (setup->bRequest) {
   2bcfe:	2a00      	cmp	r2, #0
   2bd00:	f43f af64 	beq.w	2bbcc <usb_handle_standard_request+0x188>
   2bd04:	2a0a      	cmp	r2, #10
   2bd06:	f47f aed6 	bne.w	2bab6 <usb_handle_standard_request+0x72>
	while (p[DESC_bLength] != 0U) {
   2bd0a:	782a      	ldrb	r2, [r5, #0]
   2bd0c:	2a00      	cmp	r2, #0
   2bd0e:	f43f aed2 	beq.w	2bab6 <usb_handle_standard_request+0x72>
		if (p[DESC_bDescriptorType] == USB_DESC_INTERFACE) {
   2bd12:	7869      	ldrb	r1, [r5, #1]
   2bd14:	2904      	cmp	r1, #4
   2bd16:	f47f af5f 	bne.w	2bbd8 <usb_handle_standard_request+0x194>
			cur_iface = p[INTF_DESC_bInterfaceNumber];
   2bd1a:	78a9      	ldrb	r1, [r5, #2]
			if (cur_iface == setup->wIndex) {
   2bd1c:	428b      	cmp	r3, r1
   2bd1e:	f47f af5b 	bne.w	2bbd8 <usb_handle_standard_request+0x194>
	if (iface < ARRAY_SIZE(usb_dev.alt_setting)) {
   2bd22:	2b07      	cmp	r3, #7
		return usb_dev.alt_setting[iface];
   2bd24:	bf96      	itet	ls
   2bd26:	199b      	addls	r3, r3, r6
	return 0;
   2bd28:	2300      	movhi	r3, #0
		return usb_dev.alt_setting[iface];
   2bd2a:	f893 30bb 	ldrbls.w	r3, [r3, #187]	; 0xbb
				data[0] = usb_get_alt_setting(cur_iface);
   2bd2e:	f88c 3000 	strb.w	r3, [ip]
   2bd32:	e6d2      	b.n	2bada <usb_handle_standard_request+0x96>

0002bd34 <usb_data_to_host>:
{
   2bd34:	b513      	push	{r0, r1, r4, lr}
	if (usb_dev.zlp_flag == false) {
   2bd36:	4c13      	ldr	r4, [pc, #76]	; (2bd84 <usb_data_to_host+0x50>)
   2bd38:	7d23      	ldrb	r3, [r4, #20]
   2bd3a:	b9cb      	cbnz	r3, 2bd70 <usb_data_to_host+0x3c>
		uint32_t chunk = usb_dev.data_buf_residue;
   2bd3c:	68e2      	ldr	r2, [r4, #12]
		usb_write(USB_CONTROL_EP_IN, usb_dev.data_buf,
   2bd3e:	68a1      	ldr	r1, [r4, #8]
		uint32_t chunk = usb_dev.data_buf_residue;
   2bd40:	9201      	str	r2, [sp, #4]
		usb_write(USB_CONTROL_EP_IN, usb_dev.data_buf,
   2bd42:	ab01      	add	r3, sp, #4
   2bd44:	2080      	movs	r0, #128	; 0x80
   2bd46:	f01d fc79 	bl	4963c <usb_write>
		usb_dev.data_buf += chunk;
   2bd4a:	9a01      	ldr	r2, [sp, #4]
   2bd4c:	68a3      	ldr	r3, [r4, #8]
   2bd4e:	4413      	add	r3, r2
   2bd50:	60a3      	str	r3, [r4, #8]
		usb_dev.data_buf_residue -= chunk;
   2bd52:	68e3      	ldr	r3, [r4, #12]
   2bd54:	1a9b      	subs	r3, r3, r2
   2bd56:	60e3      	str	r3, [r4, #12]
		if (!usb_dev.data_buf_residue && chunk &&
   2bd58:	b943      	cbnz	r3, 2bd6c <usb_data_to_host+0x38>
   2bd5a:	b13a      	cbz	r2, 2bd6c <usb_data_to_host+0x38>
		    usb_dev.setup.wLength > usb_dev.data_buf_len) {
   2bd5c:	6923      	ldr	r3, [r4, #16]
   2bd5e:	88e2      	ldrh	r2, [r4, #6]
		if (!usb_dev.data_buf_residue && chunk &&
   2bd60:	429a      	cmp	r2, r3
   2bd62:	dd03      	ble.n	2bd6c <usb_data_to_host+0x38>
			if (!(usb_dev.data_buf_len % USB_MAX_CTRL_MPS)) {
   2bd64:	069b      	lsls	r3, r3, #26
   2bd66:	d101      	bne.n	2bd6c <usb_data_to_host+0x38>
				usb_dev.zlp_flag = true;
   2bd68:	2301      	movs	r3, #1
   2bd6a:	7523      	strb	r3, [r4, #20]
}
   2bd6c:	b002      	add	sp, #8
   2bd6e:	bd10      	pop	{r4, pc}
		usb_dev.zlp_flag = false;
   2bd70:	2300      	movs	r3, #0
		usb_dc_ep_write(USB_CONTROL_EP_IN, NULL, 0, NULL);
   2bd72:	461a      	mov	r2, r3
   2bd74:	4619      	mov	r1, r3
   2bd76:	2080      	movs	r0, #128	; 0x80
		usb_dev.zlp_flag = false;
   2bd78:	7523      	strb	r3, [r4, #20]
}
   2bd7a:	b002      	add	sp, #8
   2bd7c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		usb_dc_ep_write(USB_CONTROL_EP_IN, NULL, 0, NULL);
   2bd80:	f017 bb1e 	b.w	433c0 <usb_dc_ep_write>
   2bd84:	2000393c 	.word	0x2000393c

0002bd88 <usb_handle_control_transfer>:
{
   2bd88:	b530      	push	{r4, r5, lr}
   2bd8a:	b085      	sub	sp, #20
	uint32_t chunk = 0U;
   2bd8c:	2300      	movs	r3, #0
{
   2bd8e:	4602      	mov	r2, r0
   2bd90:	460d      	mov	r5, r1
	uint32_t chunk = 0U;
   2bd92:	9301      	str	r3, [sp, #4]
	if (ep == USB_CONTROL_EP_OUT && ep_status == USB_DC_EP_SETUP) {
   2bd94:	2800      	cmp	r0, #0
   2bd96:	d158      	bne.n	2be4a <usb_handle_control_transfer+0xc2>
   2bd98:	2900      	cmp	r1, #0
   2bd9a:	d135      	bne.n	2be08 <usb_handle_control_transfer+0x80>
		if (usb_dc_ep_read(ep, (uint8_t *)&setup_raw,
   2bd9c:	2208      	movs	r2, #8
   2bd9e:	460b      	mov	r3, r1
   2bda0:	eb0d 0102 	add.w	r1, sp, r2
   2bda4:	f023 f8a8 	bl	4eef8 <usb_dc_ep_read>
   2bda8:	2800      	cmp	r0, #0
   2bdaa:	da04      	bge.n	2bdb6 <usb_handle_control_transfer+0x2e>
			usb_dc_ep_set_stall(USB_CONTROL_EP_IN);
   2bdac:	2080      	movs	r0, #128	; 0x80
				usb_dc_ep_set_stall(USB_CONTROL_EP_OUT);
   2bdae:	f017 fa53 	bl	43258 <usb_dc_ep_set_stall>
}
   2bdb2:	b005      	add	sp, #20
   2bdb4:	bd30      	pop	{r4, r5, pc}
		setup->bmRequestType = setup_raw.bmRequestType;
   2bdb6:	4c2a      	ldr	r4, [pc, #168]	; (2be60 <usb_handle_control_transfer+0xd8>)
   2bdb8:	9a02      	ldr	r2, [sp, #8]
   2bdba:	6022      	str	r2, [r4, #0]
		setup->wIndex = sys_le16_to_cpu(setup_raw.wIndex);
   2bdbc:	9a03      	ldr	r2, [sp, #12]
   2bdbe:	6062      	str	r2, [r4, #4]
		usb_dev.data_buf = usb_dev.req_data;
   2bdc0:	f104 0238 	add.w	r2, r4, #56	; 0x38
   2bdc4:	60a2      	str	r2, [r4, #8]
		if (usb_reqtype_is_to_device(setup)) {
   2bdc6:	f99d 2008 	ldrsb.w	r2, [sp, #8]
		setup->wLength = sys_le16_to_cpu(setup_raw.wLength);
   2bdca:	f8bd 300e 	ldrh.w	r3, [sp, #14]
		usb_dev.zlp_flag = false;
   2bdce:	7525      	strb	r5, [r4, #20]
		if (usb_reqtype_is_to_device(setup)) {
   2bdd0:	2a00      	cmp	r2, #0
		usb_dev.data_buf_residue = 0;
   2bdd2:	e9c4 5503 	strd	r5, r5, [r4, #12]
		if (usb_reqtype_is_to_device(setup)) {
   2bdd6:	db0a      	blt.n	2bdee <usb_handle_control_transfer+0x66>
			if (setup->wLength > CONFIG_USB_REQUEST_BUFFER_SIZE) {
   2bdd8:	2b80      	cmp	r3, #128	; 0x80
   2bdda:	d904      	bls.n	2bde6 <usb_handle_control_transfer+0x5e>
				usb_dc_ep_set_stall(USB_CONTROL_EP_IN);
   2bddc:	2080      	movs	r0, #128	; 0x80
   2bdde:	f017 fa3b 	bl	43258 <usb_dc_ep_set_stall>
				usb_dc_ep_set_stall(USB_CONTROL_EP_OUT);
   2bde2:	2000      	movs	r0, #0
   2bde4:	e7e3      	b.n	2bdae <usb_handle_control_transfer+0x26>
			if (setup->wLength) {
   2bde6:	b113      	cbz	r3, 2bdee <usb_handle_control_transfer+0x66>
				usb_dev.data_buf_residue = setup->wLength;
   2bde8:	e9c4 3303 	strd	r3, r3, [r4, #12]
				return;
   2bdec:	e7e1      	b.n	2bdb2 <usb_handle_control_transfer+0x2a>
		if (!usb_handle_request(setup,
   2bdee:	f7ff fd9b 	bl	2b928 <usb_handle_request.constprop.0>
   2bdf2:	2800      	cmp	r0, #0
   2bdf4:	d0da      	beq.n	2bdac <usb_handle_control_transfer+0x24>
		usb_dev.data_buf_residue = MIN(usb_dev.data_buf_len,
   2bdf6:	88e2      	ldrh	r2, [r4, #6]
   2bdf8:	6923      	ldr	r3, [r4, #16]
   2bdfa:	429a      	cmp	r2, r3
   2bdfc:	bfd4      	ite	le
   2bdfe:	60e2      	strle	r2, [r4, #12]
   2be00:	60e3      	strgt	r3, [r4, #12]
			usb_data_to_host();
   2be02:	f7ff ff97 	bl	2bd34 <usb_data_to_host>
   2be06:	e7d4      	b.n	2bdb2 <usb_handle_control_transfer+0x2a>
		if (usb_dev.data_buf_residue <= 0) {
   2be08:	4c15      	ldr	r4, [pc, #84]	; (2be60 <usb_handle_control_transfer+0xd8>)
			if (usb_dc_ep_read(USB_CONTROL_EP_OUT,
   2be0a:	e9d4 1502 	ldrd	r1, r5, [r4, #8]
		if (usb_dev.data_buf_residue <= 0) {
   2be0e:	2d00      	cmp	r5, #0
			if (usb_dc_ep_read(USB_CONTROL_EP_OUT,
   2be10:	ab01      	add	r3, sp, #4
		if (usb_dev.data_buf_residue <= 0) {
   2be12:	dc04      	bgt.n	2be1e <usb_handle_control_transfer+0x96>
			if (usb_dc_ep_read(USB_CONTROL_EP_OUT,
   2be14:	f023 f870 	bl	4eef8 <usb_dc_ep_read>
   2be18:	2800      	cmp	r0, #0
   2be1a:	daca      	bge.n	2bdb2 <usb_handle_control_transfer+0x2a>
   2be1c:	e7c6      	b.n	2bdac <usb_handle_control_transfer+0x24>
		if (usb_dc_ep_read(USB_CONTROL_EP_OUT,
   2be1e:	462a      	mov	r2, r5
   2be20:	f023 f86a 	bl	4eef8 <usb_dc_ep_read>
   2be24:	2800      	cmp	r0, #0
   2be26:	dbd9      	blt.n	2bddc <usb_handle_control_transfer+0x54>
		usb_dev.data_buf += chunk;
   2be28:	9a01      	ldr	r2, [sp, #4]
   2be2a:	68a3      	ldr	r3, [r4, #8]
   2be2c:	4413      	add	r3, r2
   2be2e:	60a3      	str	r3, [r4, #8]
		usb_dev.data_buf_residue -= chunk;
   2be30:	68e3      	ldr	r3, [r4, #12]
   2be32:	1a9b      	subs	r3, r3, r2
   2be34:	60e3      	str	r3, [r4, #12]
		if (usb_dev.data_buf_residue == 0) {
   2be36:	2b00      	cmp	r3, #0
   2be38:	d1bb      	bne.n	2bdb2 <usb_handle_control_transfer+0x2a>
			usb_dev.data_buf = usb_dev.req_data;
   2be3a:	f104 0338 	add.w	r3, r4, #56	; 0x38
   2be3e:	60a3      	str	r3, [r4, #8]
			if (!usb_handle_request(setup,
   2be40:	f7ff fd72 	bl	2b928 <usb_handle_request.constprop.0>
   2be44:	2800      	cmp	r0, #0
   2be46:	d1dc      	bne.n	2be02 <usb_handle_control_transfer+0x7a>
   2be48:	e7b0      	b.n	2bdac <usb_handle_control_transfer+0x24>
	} else if (ep == USB_CONTROL_EP_IN) {
   2be4a:	2880      	cmp	r0, #128	; 0x80
   2be4c:	d1b1      	bne.n	2bdb2 <usb_handle_control_transfer+0x2a>
		if (usb_dev.data_buf_residue != 0 || usb_dev.zlp_flag == true) {
   2be4e:	4b04      	ldr	r3, [pc, #16]	; (2be60 <usb_handle_control_transfer+0xd8>)
   2be50:	68da      	ldr	r2, [r3, #12]
   2be52:	2a00      	cmp	r2, #0
   2be54:	d1d5      	bne.n	2be02 <usb_handle_control_transfer+0x7a>
   2be56:	7d1b      	ldrb	r3, [r3, #20]
   2be58:	2b00      	cmp	r3, #0
   2be5a:	d1d2      	bne.n	2be02 <usb_handle_control_transfer+0x7a>
   2be5c:	e7a9      	b.n	2bdb2 <usb_handle_control_transfer+0x2a>
   2be5e:	bf00      	nop
   2be60:	2000393c 	.word	0x2000393c

0002be64 <usb_wakeup_request>:
	return usb_dev.remote_wakeup;
   2be64:	4b04      	ldr	r3, [pc, #16]	; (2be78 <usb_wakeup_request+0x14>)
		if (usb_get_remote_wakeup_status()) {
   2be66:	f893 30c3 	ldrb.w	r3, [r3, #195]	; 0xc3
   2be6a:	b10b      	cbz	r3, 2be70 <usb_wakeup_request+0xc>
			return usb_dc_wakeup_request();
   2be6c:	f023 b853 	b.w	4ef16 <usb_dc_wakeup_request>
}
   2be70:	f06f 000c 	mvn.w	r0, #12
   2be74:	4770      	bx	lr
   2be76:	bf00      	nop
   2be78:	2000393c 	.word	0x2000393c

0002be7c <usb_set_config>:
	usb_dev.descriptors = usb_descriptors;
   2be7c:	4b05      	ldr	r3, [pc, #20]	; (2be94 <usb_set_config+0x18>)
	usb_dev.req_handlers[type] = handler;
   2be7e:	4a06      	ldr	r2, [pc, #24]	; (2be98 <usb_set_config+0x1c>)
   2be80:	629a      	str	r2, [r3, #40]	; 0x28
   2be82:	4a06      	ldr	r2, [pc, #24]	; (2be9c <usb_set_config+0x20>)
   2be84:	62da      	str	r2, [r3, #44]	; 0x2c
   2be86:	4a06      	ldr	r2, [pc, #24]	; (2bea0 <usb_set_config+0x24>)
   2be88:	631a      	str	r2, [r3, #48]	; 0x30
	usb_dev.custom_req_handler = handler;
   2be8a:	4a06      	ldr	r2, [pc, #24]	; (2bea4 <usb_set_config+0x28>)
	usb_dev.descriptors = usb_descriptors;
   2be8c:	6258      	str	r0, [r3, #36]	; 0x24
	usb_dev.custom_req_handler = handler;
   2be8e:	619a      	str	r2, [r3, #24]

	/* register class request handlers for each interface*/
	usb_register_custom_req_handler(custom_handler);

	return 0;
}
   2be90:	2000      	movs	r0, #0
   2be92:	4770      	bx	lr
   2be94:	2000393c 	.word	0x2000393c
   2be98:	0002ba45 	.word	0x0002ba45
   2be9c:	0002b7b1 	.word	0x0002b7b1
   2bea0:	0002b851 	.word	0x0002b851
   2bea4:	0002b7f1 	.word	0x0002b7f1

0002bea8 <usb_device_init>:
/*
 * This function configures the USB device stack based on USB descriptor and
 * usb_cfg_data.
 */
static int usb_device_init(const struct device *dev)
{
   2bea8:	b510      	push	{r4, lr}
	uint8_t *device_descriptor;

	if (usb_dev.enabled == true) {
   2beaa:	4b08      	ldr	r3, [pc, #32]	; (2becc <usb_device_init+0x24>)
   2beac:	f893 40b8 	ldrb.w	r4, [r3, #184]	; 0xb8
   2beb0:	b934      	cbnz	r4, 2bec0 <usb_device_init+0x18>
		return -EALREADY;
	}

	/* register device descriptor */
	device_descriptor = usb_get_device_descriptor();
   2beb2:	f000 f8cb 	bl	2c04c <usb_get_device_descriptor>
	if (!device_descriptor) {
   2beb6:	b130      	cbz	r0, 2bec6 <usb_device_init+0x1e>
		LOG_ERR("Failed to configure USB device stack");
		return -1;
	}

	usb_set_config(device_descriptor);
   2beb8:	f7ff ffe0 	bl	2be7c <usb_set_config>

	if (IS_ENABLED(CONFIG_USB_DEVICE_INITIALIZE_AT_BOOT)) {
		return usb_enable(NULL);
	}

	return 0;
   2bebc:	4620      	mov	r0, r4
}
   2bebe:	bd10      	pop	{r4, pc}
		return -EALREADY;
   2bec0:	f06f 0077 	mvn.w	r0, #119	; 0x77
   2bec4:	e7fb      	b.n	2bebe <usb_device_init+0x16>
		return -1;
   2bec6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2beca:	e7f8      	b.n	2bebe <usb_device_init+0x16>
   2becc:	2000393c 	.word	0x2000393c

0002bed0 <usb_enable>:
{
   2bed0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   2bed4:	4604      	mov	r4, r0
	if (usb_dev.enabled == true) {
   2bed6:	4d35      	ldr	r5, [pc, #212]	; (2bfac <usb_enable+0xdc>)
	return z_impl_k_mutex_lock(mutex, timeout);
   2bed8:	4835      	ldr	r0, [pc, #212]	; (2bfb0 <usb_enable+0xe0>)
   2beda:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   2bede:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2bee2:	f01b f85f 	bl	46fa4 <z_impl_k_mutex_lock>
   2bee6:	f895 60b8 	ldrb.w	r6, [r5, #184]	; 0xb8
   2beea:	2e00      	cmp	r6, #0
   2beec:	d15b      	bne.n	2bfa6 <usb_enable+0xd6>
	usb_dev.status_callback = cb;
   2beee:	4831      	ldr	r0, [pc, #196]	; (2bfb4 <usb_enable+0xe4>)
	usb_dev.user_status_callback = status_cb;
   2bef0:	622c      	str	r4, [r5, #32]
	usb_dev.status_callback = cb;
   2bef2:	61e8      	str	r0, [r5, #28]
	usb_dc_set_status_callback(forward_status_cb);
   2bef4:	f017 fb7e 	bl	435f4 <usb_dc_set_status_callback>
	ret = usb_dc_attach();
   2bef8:	f017 f93a 	bl	43170 <usb_dc_attach>
	if (ret < 0) {
   2befc:	1e04      	subs	r4, r0, #0
   2befe:	db36      	blt.n	2bf6e <usb_enable+0x9e>
	ret = usb_transfer_init();
   2bf00:	f000 fa5a 	bl	2c3b8 <usb_transfer_init>
	if (ret < 0) {
   2bf04:	1e04      	subs	r4, r0, #0
   2bf06:	db32      	blt.n	2bf6e <usb_enable+0x9e>
	ep0_cfg.ep_mps = USB_MAX_CTRL_MPS;
   2bf08:	2340      	movs	r3, #64	; 0x40
	ret = usb_dc_ep_configure(&ep0_cfg);
   2bf0a:	4668      	mov	r0, sp
	ep0_cfg.ep_mps = USB_MAX_CTRL_MPS;
   2bf0c:	f8ad 3002 	strh.w	r3, [sp, #2]
	ep0_cfg.ep_type = USB_DC_EP_CONTROL;
   2bf10:	f88d 6004 	strb.w	r6, [sp, #4]
	ep0_cfg.ep_addr = USB_CONTROL_EP_OUT;
   2bf14:	f88d 6000 	strb.w	r6, [sp]
	ret = usb_dc_ep_configure(&ep0_cfg);
   2bf18:	f017 f97a 	bl	43210 <usb_dc_ep_configure>
	if (ret < 0) {
   2bf1c:	1e04      	subs	r4, r0, #0
   2bf1e:	db26      	blt.n	2bf6e <usb_enable+0x9e>
	ep0_cfg.ep_addr = USB_CONTROL_EP_IN;
   2bf20:	2780      	movs	r7, #128	; 0x80
	ret = usb_dc_ep_configure(&ep0_cfg);
   2bf22:	4668      	mov	r0, sp
	ep0_cfg.ep_addr = USB_CONTROL_EP_IN;
   2bf24:	f88d 7000 	strb.w	r7, [sp]
	ret = usb_dc_ep_configure(&ep0_cfg);
   2bf28:	f017 f972 	bl	43210 <usb_dc_ep_configure>
	if (ret < 0) {
   2bf2c:	1e04      	subs	r4, r0, #0
   2bf2e:	db1e      	blt.n	2bf6e <usb_enable+0x9e>
	ret = usb_dc_ep_set_callback(USB_CONTROL_EP_OUT,
   2bf30:	4921      	ldr	r1, [pc, #132]	; (2bfb8 <usb_enable+0xe8>)
   2bf32:	4630      	mov	r0, r6
   2bf34:	f017 fb4a 	bl	435cc <usb_dc_ep_set_callback>
	if (ret < 0) {
   2bf38:	1e04      	subs	r4, r0, #0
   2bf3a:	db18      	blt.n	2bf6e <usb_enable+0x9e>
	ret = usb_dc_ep_set_callback(USB_CONTROL_EP_IN,
   2bf3c:	491e      	ldr	r1, [pc, #120]	; (2bfb8 <usb_enable+0xe8>)
   2bf3e:	4638      	mov	r0, r7
   2bf40:	f017 fb44 	bl	435cc <usb_dc_ep_set_callback>
	if (ret < 0) {
   2bf44:	1e04      	subs	r4, r0, #0
   2bf46:	db12      	blt.n	2bf6e <usb_enable+0x9e>
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   2bf48:	4c1c      	ldr	r4, [pc, #112]	; (2bfbc <usb_enable+0xec>)
   2bf4a:	f8df 8074 	ldr.w	r8, [pc, #116]	; 2bfc0 <usb_enable+0xf0>
   2bf4e:	4544      	cmp	r4, r8
   2bf50:	d314      	bcc.n	2bf7c <usb_enable+0xac>
	ret = usb_dc_ep_enable(USB_CONTROL_EP_OUT);
   2bf52:	2000      	movs	r0, #0
   2bf54:	f017 f9e4 	bl	43320 <usb_dc_ep_enable>
	if (ret < 0) {
   2bf58:	1e04      	subs	r4, r0, #0
   2bf5a:	db08      	blt.n	2bf6e <usb_enable+0x9e>
	ret = usb_dc_ep_enable(USB_CONTROL_EP_IN);
   2bf5c:	2080      	movs	r0, #128	; 0x80
   2bf5e:	f017 f9df 	bl	43320 <usb_dc_ep_enable>
	if (ret < 0) {
   2bf62:	1e04      	subs	r4, r0, #0
   2bf64:	db03      	blt.n	2bf6e <usb_enable+0x9e>
	usb_dev.enabled = true;
   2bf66:	2301      	movs	r3, #1
   2bf68:	f885 30b8 	strb.w	r3, [r5, #184]	; 0xb8
	ret = 0;
   2bf6c:	2400      	movs	r4, #0
	return z_impl_k_mutex_unlock(mutex);
   2bf6e:	4810      	ldr	r0, [pc, #64]	; (2bfb0 <usb_enable+0xe0>)
   2bf70:	f01b f892 	bl	47098 <z_impl_k_mutex_unlock>
}
   2bf74:	4620      	mov	r0, r4
   2bf76:	b002      	add	sp, #8
   2bf78:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		ep_data = cfg_data->endpoint;
   2bf7c:	6a27      	ldr	r7, [r4, #32]
		for (uint8_t n = 0; n < cfg_data->num_endpoints; n++) {
   2bf7e:	2600      	movs	r6, #0
   2bf80:	7f22      	ldrb	r2, [r4, #28]
   2bf82:	b2f3      	uxtb	r3, r6
   2bf84:	429a      	cmp	r2, r3
   2bf86:	d801      	bhi.n	2bf8c <usb_enable+0xbc>
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   2bf88:	3424      	adds	r4, #36	; 0x24
   2bf8a:	e7e0      	b.n	2bf4e <usb_enable+0x7e>
			if (usb_dc_ep_set_callback(ep_data[n].ep_addr,
   2bf8c:	eb07 02c3 	add.w	r2, r7, r3, lsl #3
   2bf90:	f857 1033 	ldr.w	r1, [r7, r3, lsl #3]
   2bf94:	7910      	ldrb	r0, [r2, #4]
   2bf96:	f017 fb19 	bl	435cc <usb_dc_ep_set_callback>
   2bf9a:	3601      	adds	r6, #1
   2bf9c:	2800      	cmp	r0, #0
   2bf9e:	d0ef      	beq.n	2bf80 <usb_enable+0xb0>
   2bfa0:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   2bfa4:	e7e3      	b.n	2bf6e <usb_enable+0x9e>
		ret = -EALREADY;
   2bfa6:	f06f 0477 	mvn.w	r4, #119	; 0x77
   2bfaa:	e7e0      	b.n	2bf6e <usb_enable+0x9e>
   2bfac:	2000393c 	.word	0x2000393c
   2bfb0:	20001108 	.word	0x20001108
   2bfb4:	0002b955 	.word	0x0002b955
   2bfb8:	0002bd89 	.word	0x0002bd89
   2bfbc:	20001474 	.word	0x20001474
   2bfc0:	20001498 	.word	0x20001498

0002bfc4 <usb_update_sn_string_descriptor>:
 * case the device ID returned by the HWINFO driver is bigger, the lower
 * part is used for the USB Serial Number, as that part is usually having
 * more entropy.
 */
__weak uint8_t *usb_update_sn_string_descriptor(void)
{
   2bfc4:	b530      	push	{r4, r5, lr}
	 * unless the user requested a longer serial number.
	 */
	const int usblen = sizeof(CONFIG_USB_DEVICE_SN) / 2;
	uint8_t hwid[MAX(16, sizeof(CONFIG_USB_DEVICE_SN) / 2)];
	static uint8_t sn[sizeof(CONFIG_USB_DEVICE_SN) + 1];
	const char hex[] = "0123456789ABCDEF";
   2bfc6:	4b1f      	ldr	r3, [pc, #124]	; (2c044 <usb_update_sn_string_descriptor+0x80>)
{
   2bfc8:	b08b      	sub	sp, #44	; 0x2c
	const char hex[] = "0123456789ABCDEF";
   2bfca:	aa05      	add	r2, sp, #20
   2bfcc:	f103 0510 	add.w	r5, r3, #16
   2bfd0:	6818      	ldr	r0, [r3, #0]
   2bfd2:	6859      	ldr	r1, [r3, #4]
   2bfd4:	4614      	mov	r4, r2
   2bfd6:	c403      	stmia	r4!, {r0, r1}
   2bfd8:	3308      	adds	r3, #8
   2bfda:	42ab      	cmp	r3, r5
   2bfdc:	4622      	mov	r2, r4
   2bfde:	d1f7      	bne.n	2bfd0 <usb_update_sn_string_descriptor+0xc>
   2bfe0:	781b      	ldrb	r3, [r3, #0]
   2bfe2:	7023      	strb	r3, [r4, #0]
	int hwlen, skip;

	memset(hwid, 0, sizeof(hwid));
   2bfe4:	2210      	movs	r2, #16
   2bfe6:	2100      	movs	r1, #0
   2bfe8:	a801      	add	r0, sp, #4
   2bfea:	f01e ff51 	bl	4ae90 <memset>
	memset(sn, 0, sizeof(sn));
   2bfee:	2212      	movs	r2, #18
   2bff0:	2100      	movs	r1, #0
   2bff2:	4815      	ldr	r0, [pc, #84]	; (2c048 <usb_update_sn_string_descriptor+0x84>)
   2bff4:	f01e ff4c 	bl	4ae90 <memset>
		union { uintptr_t x; size_t val; } parm1 = { .val = length };
		return (ssize_t) arch_syscall_invoke2(parm0.x, parm1.x, K_SYSCALL_HWINFO_GET_DEVICE_ID);
	}
#endif
	compiler_barrier();
	return z_impl_hwinfo_get_device_id(buffer, length);
   2bff8:	2110      	movs	r1, #16
   2bffa:	a801      	add	r0, sp, #4
   2bffc:	f023 f892 	bl	4f124 <z_impl_hwinfo_get_device_id>

	hwlen = hwinfo_get_device_id(hwid, sizeof(hwid));
	if (hwlen > 0) {
   2c000:	2800      	cmp	r0, #0
   2c002:	dd1b      	ble.n	2c03c <usb_update_sn_string_descriptor+0x78>
		skip = MAX(0, hwlen - usblen);
   2c004:	2808      	cmp	r0, #8
   2c006:	bfb8      	it	lt
   2c008:	2008      	movlt	r0, #8
   2c00a:	3809      	subs	r0, #9
   2c00c:	ab01      	add	r3, sp, #4
   2c00e:	490e      	ldr	r1, [pc, #56]	; (2c048 <usb_update_sn_string_descriptor+0x84>)
   2c010:	181a      	adds	r2, r3, r0
		LOG_HEXDUMP_DBG(&hwid[skip], usblen, "Serial Number");
		for (int i = 0; i < usblen; i++) {
   2c012:	2000      	movs	r0, #0
			sn[i * 2] = hex[hwid[i + skip] >> 4];
   2c014:	f812 3f01 	ldrb.w	r3, [r2, #1]!
   2c018:	ac0a      	add	r4, sp, #40	; 0x28
   2c01a:	eb04 1413 	add.w	r4, r4, r3, lsr #4
			sn[i * 2 + 1] = hex[hwid[i + skip] & 0xF];
   2c01e:	f003 030f 	and.w	r3, r3, #15
   2c022:	3328      	adds	r3, #40	; 0x28
   2c024:	446b      	add	r3, sp
		for (int i = 0; i < usblen; i++) {
   2c026:	3001      	adds	r0, #1
			sn[i * 2] = hex[hwid[i + skip] >> 4];
   2c028:	f814 4c14 	ldrb.w	r4, [r4, #-20]
			sn[i * 2 + 1] = hex[hwid[i + skip] & 0xF];
   2c02c:	f813 3c14 	ldrb.w	r3, [r3, #-20]
			sn[i * 2] = hex[hwid[i + skip] >> 4];
   2c030:	700c      	strb	r4, [r1, #0]
		for (int i = 0; i < usblen; i++) {
   2c032:	2808      	cmp	r0, #8
			sn[i * 2 + 1] = hex[hwid[i + skip] & 0xF];
   2c034:	704b      	strb	r3, [r1, #1]
		for (int i = 0; i < usblen; i++) {
   2c036:	f101 0102 	add.w	r1, r1, #2
   2c03a:	d1eb      	bne.n	2c014 <usb_update_sn_string_descriptor+0x50>
		}
	}

	return sn;
}
   2c03c:	4802      	ldr	r0, [pc, #8]	; (2c048 <usb_update_sn_string_descriptor+0x84>)
   2c03e:	b00b      	add	sp, #44	; 0x2c
   2c040:	bd30      	pop	{r4, r5, pc}
   2c042:	bf00      	nop
   2c044:	000533f0 	.word	0x000533f0
   2c048:	20006af3 	.word	0x20006af3

0002c04c <usb_get_device_descriptor>:
	return 0;
}


uint8_t *usb_get_device_descriptor(void)
{
   2c04c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2c050:	4c64      	ldr	r4, [pc, #400]	; (2c1e4 <usb_get_device_descriptor+0x198>)
   2c052:	b085      	sub	sp, #20
	uint8_t str_descr_idx = 0U;
   2c054:	2600      	movs	r6, #0
	uint32_t requested_ep = BIT(16) | BIT(0);
   2c056:	f04f 1b01 	mov.w	fp, #65537	; 0x10001
	uint8_t numof_ifaces = 0U;
   2c05a:	46b1      	mov	r9, r6
	struct usb_cfg_data *cfg_data = NULL;
   2c05c:	4635      	mov	r5, r6
	struct usb_cfg_descriptor *cfg_descr = NULL;
   2c05e:	46b2      	mov	sl, r6
	while (head->bLength != 0U) {
   2c060:	7823      	ldrb	r3, [r4, #0]
   2c062:	b92b      	cbnz	r3, 2c070 <usb_get_device_descriptor+0x24>
	if ((head + 1) != __usb_descriptor_end) {
   2c064:	4b60      	ldr	r3, [pc, #384]	; (2c1e8 <usb_get_device_descriptor+0x19c>)
   2c066:	3402      	adds	r4, #2
   2c068:	429c      	cmp	r4, r3
   2c06a:	d1f3      	bne.n	2c054 <usb_get_device_descriptor+0x8>
	if (usb_fix_descriptor(__usb_descriptor_start)) {
		LOG_ERR("Failed to fixup USB descriptor");
		return NULL;
	}

	return (uint8_t *) __usb_descriptor_start;
   2c06c:	485d      	ldr	r0, [pc, #372]	; (2c1e4 <usb_get_device_descriptor+0x198>)
   2c06e:	e01c      	b.n	2c0aa <usb_get_device_descriptor+0x5e>
		switch (head->bDescriptorType) {
   2c070:	7863      	ldrb	r3, [r4, #1]
   2c072:	2b05      	cmp	r3, #5
   2c074:	d805      	bhi.n	2c082 <usb_get_device_descriptor+0x36>
   2c076:	e8df f003 	tbb	[pc, r3]
   2c07a:	047b      	.short	0x047b
   2c07c:	25077b03 	.word	0x25077b03
   2c080:	46a2      	mov	sl, r4
		head = (struct usb_desc_header *)((uint8_t *)head + head->bLength);
   2c082:	7823      	ldrb	r3, [r4, #0]
   2c084:	441c      	add	r4, r3
   2c086:	e7eb      	b.n	2c060 <usb_get_device_descriptor+0x14>
			if (if_descr->bAlternateSetting) {
   2c088:	78e3      	ldrb	r3, [r4, #3]
   2c08a:	2b00      	cmp	r3, #0
   2c08c:	d1f9      	bne.n	2c082 <usb_get_device_descriptor+0x36>
			if (if_descr->bInterfaceNumber == 0U) {
   2c08e:	78a3      	ldrb	r3, [r4, #2]
   2c090:	b173      	cbz	r3, 2c0b0 <usb_get_device_descriptor+0x64>
			numof_ifaces++;
   2c092:	f109 0901 	add.w	r9, r9, #1
   2c096:	fa5f f989 	uxtb.w	r9, r9
			break;
   2c09a:	e7f2      	b.n	2c082 <usb_get_device_descriptor+0x36>
		if (cfg_data->interface_descriptor == iface) {
   2c09c:	686a      	ldr	r2, [r5, #4]
   2c09e:	4294      	cmp	r4, r2
   2c0a0:	d009      	beq.n	2c0b6 <usb_get_device_descriptor+0x6a>
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   2c0a2:	3524      	adds	r5, #36	; 0x24
   2c0a4:	429d      	cmp	r5, r3
   2c0a6:	d3f9      	bcc.n	2c09c <usb_get_device_descriptor+0x50>
		return NULL;
   2c0a8:	2000      	movs	r0, #0
}
   2c0aa:	b005      	add	sp, #20
   2c0ac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   2c0b0:	4d4e      	ldr	r5, [pc, #312]	; (2c1ec <usb_get_device_descriptor+0x1a0>)
   2c0b2:	4b4f      	ldr	r3, [pc, #316]	; (2c1f0 <usb_get_device_descriptor+0x1a4>)
   2c0b4:	e7f6      	b.n	2c0a4 <usb_get_device_descriptor+0x58>
				if (cfg_data->interface_config) {
   2c0b6:	68ab      	ldr	r3, [r5, #8]
   2c0b8:	2b00      	cmp	r3, #0
   2c0ba:	d0ea      	beq.n	2c092 <usb_get_device_descriptor+0x46>
					cfg_data->interface_config(head,
   2c0bc:	4649      	mov	r1, r9
   2c0be:	4620      	mov	r0, r4
   2c0c0:	4798      	blx	r3
   2c0c2:	e7e6      	b.n	2c092 <usb_get_device_descriptor+0x46>
			if (!cfg_data) {
   2c0c4:	2d00      	cmp	r5, #0
   2c0c6:	d0ef      	beq.n	2c0a8 <usb_get_device_descriptor+0x5c>
	for (unsigned int i = 0; i < cfg_data->num_endpoints; i++) {
   2c0c8:	2300      	movs	r3, #0
   2c0ca:	2101      	movs	r1, #1
   2c0cc:	7f2a      	ldrb	r2, [r5, #28]
   2c0ce:	4293      	cmp	r3, r2
   2c0d0:	d2ea      	bcs.n	2c0a8 <usb_get_device_descriptor+0x5c>
		if (ep_descr->bEndpointAddress != ep_data[i].ep_addr) {
   2c0d2:	6a2a      	ldr	r2, [r5, #32]
   2c0d4:	78a7      	ldrb	r7, [r4, #2]
   2c0d6:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
   2c0da:	7910      	ldrb	r0, [r2, #4]
   2c0dc:	4287      	cmp	r7, r0
   2c0de:	d001      	beq.n	2c0e4 <usb_get_device_descriptor+0x98>
	for (unsigned int i = 0; i < cfg_data->num_endpoints; i++) {
   2c0e0:	3301      	adds	r3, #1
   2c0e2:	e7f3      	b.n	2c0cc <usb_get_device_descriptor+0x80>
   2c0e4:	2701      	movs	r7, #1
			ep_cfg.ep_type = (ep_descr->bmAttributes &
   2c0e6:	78e0      	ldrb	r0, [r4, #3]
   2c0e8:	f000 0003 	and.w	r0, r0, #3
   2c0ec:	f88d 000c 	strb.w	r0, [sp, #12]
			ep_cfg.ep_mps = ep_descr->wMaxPacketSize;
   2c0f0:	7920      	ldrb	r0, [r4, #4]
   2c0f2:	f894 c005 	ldrb.w	ip, [r4, #5]
   2c0f6:	ea40 200c 	orr.w	r0, r0, ip, lsl #8
   2c0fa:	f8ad 000a 	strh.w	r0, [sp, #10]
			if (ep_cfg.ep_addr & USB_EP_DIR_IN) {
   2c0fe:	f994 0002 	ldrsb.w	r0, [r4, #2]
   2c102:	2800      	cmp	r0, #0
   2c104:	fa5f f887 	uxtb.w	r8, r7
   2c108:	da27      	bge.n	2c15a <usb_get_device_descriptor+0x10e>
				if ((*requested_ep & (1U << (idx + 16U)))) {
   2c10a:	f107 0010 	add.w	r0, r7, #16
   2c10e:	fa01 f000 	lsl.w	r0, r1, r0
   2c112:	ea10 0f0b 	tst.w	r0, fp
   2c116:	d127      	bne.n	2c168 <usb_get_device_descriptor+0x11c>
				ep_cfg.ep_addr = (USB_EP_DIR_IN | idx);
   2c118:	f048 0080 	orr.w	r0, r8, #128	; 0x80
   2c11c:	f88d 0008 	strb.w	r0, [sp, #8]
			if (!usb_dc_ep_check_cap(&ep_cfg)) {
   2c120:	a802      	add	r0, sp, #8
   2c122:	e9cd 3200 	strd	r3, r2, [sp]
   2c126:	f022 fecf 	bl	4eec8 <usb_dc_ep_check_cap>
   2c12a:	e9dd 3200 	ldrd	r3, r2, [sp]
   2c12e:	2101      	movs	r1, #1
   2c130:	b9d0      	cbnz	r0, 2c168 <usb_get_device_descriptor+0x11c>
				ep_descr->bEndpointAddress = ep_cfg.ep_addr;
   2c132:	f89d 3008 	ldrb.w	r3, [sp, #8]
   2c136:	70a3      	strb	r3, [r4, #2]
				if (ep_cfg.ep_addr & USB_EP_DIR_IN) {
   2c138:	f013 0f80 	tst.w	r3, #128	; 0x80
					*requested_ep |= (1U << (idx + 16U));
   2c13c:	bf18      	it	ne
   2c13e:	f108 0810 	addne.w	r8, r8, #16
				ep_data[i].ep_addr = ep_cfg.ep_addr;
   2c142:	7113      	strb	r3, [r2, #4]
					*requested_ep |= (1U << (idx + 16U));
   2c144:	bf18      	it	ne
   2c146:	fa5f f888 	uxtbne.w	r8, r8
   2c14a:	460b      	mov	r3, r1
					*requested_ep |= (1U << idx);
   2c14c:	bf0c      	ite	eq
   2c14e:	40bb      	lsleq	r3, r7
					*requested_ep |= (1U << (idx + 16U));
   2c150:	fa01 f308 	lslne.w	r3, r1, r8
					*requested_ep |= (1U << idx);
   2c154:	ea4b 0b03 	orr.w	fp, fp, r3
				return 0;
   2c158:	e793      	b.n	2c082 <usb_get_device_descriptor+0x36>
				if ((*requested_ep & (1U << (idx)))) {
   2c15a:	fa01 f007 	lsl.w	r0, r1, r7
   2c15e:	ea10 0f0b 	tst.w	r0, fp
   2c162:	d101      	bne.n	2c168 <usb_get_device_descriptor+0x11c>
   2c164:	4640      	mov	r0, r8
   2c166:	e7d9      	b.n	2c11c <usb_get_device_descriptor+0xd0>
		for (uint8_t idx = 1; idx < 16U; idx++) {
   2c168:	3701      	adds	r7, #1
   2c16a:	2f10      	cmp	r7, #16
   2c16c:	d1bb      	bne.n	2c0e6 <usb_get_device_descriptor+0x9a>
   2c16e:	e7b7      	b.n	2c0e0 <usb_get_device_descriptor+0x94>
			if (str_descr_idx == USB_DESC_SERIAL_NUMBER_IDX) {
   2c170:	2e03      	cmp	r6, #3
   2c172:	d11d      	bne.n	2c1b0 <usb_get_device_descriptor+0x164>
	uint8_t *runtime_sn =  usb_update_sn_string_descriptor();
   2c174:	f7ff ff26 	bl	2bfc4 <usb_update_sn_string_descriptor>
	if (!runtime_sn) {
   2c178:	4607      	mov	r7, r0
   2c17a:	b168      	cbz	r0, 2c198 <usb_get_device_descriptor+0x14c>
	runtime_sn_len = strlen(runtime_sn);
   2c17c:	f01e fe46 	bl	4ae0c <strlen>
	if (!runtime_sn_len) {
   2c180:	4680      	mov	r8, r0
   2c182:	b148      	cbz	r0, 2c198 <usb_get_device_descriptor+0x14c>
	default_sn_len = strlen(CONFIG_USB_DEVICE_SN);
   2c184:	481b      	ldr	r0, [pc, #108]	; (2c1f4 <usb_get_device_descriptor+0x1a8>)
   2c186:	f01e fe41 	bl	4ae0c <strlen>
	if (runtime_sn_len != default_sn_len) {
   2c18a:	4580      	cmp	r8, r0
   2c18c:	d104      	bne.n	2c198 <usb_get_device_descriptor+0x14c>
	memcpy(sn->bString, runtime_sn, runtime_sn_len);
   2c18e:	4642      	mov	r2, r8
   2c190:	4639      	mov	r1, r7
   2c192:	1ca0      	adds	r0, r4, #2
   2c194:	f01e fe71 	bl	4ae7a <memcpy>
	int idx_max = USB_BSTRING_UTF16LE_IDX_MAX(str_descr->bLength);
   2c198:	7823      	ldrb	r3, [r4, #0]
	for (int i = idx_max; i >= 0; i -= 2) {
   2c19a:	f06f 0102 	mvn.w	r1, #2
   2c19e:	18e2      	adds	r2, r4, r3
   2c1a0:	1b09      	subs	r1, r1, r4
   2c1a2:	eb04 0353 	add.w	r3, r4, r3, lsr #1
   2c1a6:	42d1      	cmn	r1, r2
   2c1a8:	d513      	bpl.n	2c1d2 <usb_get_device_descriptor+0x186>
			str_descr_idx += 1U;
   2c1aa:	3601      	adds	r6, #1
   2c1ac:	b2f6      	uxtb	r6, r6
			break;
   2c1ae:	e768      	b.n	2c082 <usb_get_device_descriptor+0x36>
			if (str_descr_idx) {
   2c1b0:	2e00      	cmp	r6, #0
   2c1b2:	d1f1      	bne.n	2c198 <usb_get_device_descriptor+0x14c>
				if (!cfg_descr) {
   2c1b4:	f1ba 0f00 	cmp.w	sl, #0
   2c1b8:	f43f af76 	beq.w	2c0a8 <usb_get_device_descriptor+0x5c>
				sys_put_le16((uint8_t *)head - (uint8_t *)cfg_descr,
   2c1bc:	eba4 030a 	sub.w	r3, r4, sl
	dst[0] = val;
   2c1c0:	f88a 3002 	strb.w	r3, [sl, #2]
	dst[1] = val >> 8;
   2c1c4:	f3c3 2307 	ubfx	r3, r3, #8, #8
   2c1c8:	f88a 3003 	strb.w	r3, [sl, #3]
				cfg_descr->bNumInterfaces = numof_ifaces;
   2c1cc:	f88a 9004 	strb.w	r9, [sl, #4]
   2c1d0:	e7eb      	b.n	2c1aa <usb_get_device_descriptor+0x15e>
		buf[i] = 0U;
   2c1d2:	f04f 0000 	mov.w	r0, #0
   2c1d6:	f802 0c01 	strb.w	r0, [r2, #-1]
		buf[i - 1] = buf[ascii_idx_max--];
   2c1da:	f813 0901 	ldrb.w	r0, [r3], #-1
   2c1de:	f802 0d02 	strb.w	r0, [r2, #-2]!
	for (int i = idx_max; i >= 0; i -= 2) {
   2c1e2:	e7e0      	b.n	2c1a6 <usb_get_device_descriptor+0x15a>
   2c1e4:	200013ec 	.word	0x200013ec
   2c1e8:	20001474 	.word	0x20001474
   2c1ec:	20001474 	.word	0x20001474
   2c1f0:	20001498 	.word	0x20001498
   2c1f4:	000533f0 	.word	0x000533f0

0002c1f8 <usb_ep_get_transfer>:
/** Max number of parallel transfers */
static struct usb_transfer_data ut_data[CONFIG_USB_MAX_NUM_TRANSFERS];

/* Transfer management */
static struct usb_transfer_data *usb_ep_get_transfer(uint8_t ep)
{
   2c1f8:	b510      	push	{r4, lr}
   2c1fa:	4b09      	ldr	r3, [pc, #36]	; (2c220 <usb_ep_get_transfer+0x28>)
	for (int i = 0; i < ARRAY_SIZE(ut_data); i++) {
   2c1fc:	2100      	movs	r1, #0
   2c1fe:	461a      	mov	r2, r3
		if (ut_data[i].ep == ep && ut_data[i].status != 0) {
   2c200:	781c      	ldrb	r4, [r3, #0]
   2c202:	4284      	cmp	r4, r0
   2c204:	d105      	bne.n	2c212 <usb_ep_get_transfer+0x1a>
   2c206:	685c      	ldr	r4, [r3, #4]
   2c208:	b11c      	cbz	r4, 2c212 <usb_ep_get_transfer+0x1a>
			return &ut_data[i];
   2c20a:	2348      	movs	r3, #72	; 0x48
   2c20c:	fb03 2001 	mla	r0, r3, r1, r2
		}
	}

	return NULL;
}
   2c210:	bd10      	pop	{r4, pc}
	for (int i = 0; i < ARRAY_SIZE(ut_data); i++) {
   2c212:	3101      	adds	r1, #1
   2c214:	2904      	cmp	r1, #4
   2c216:	f103 0348 	add.w	r3, r3, #72	; 0x48
   2c21a:	d1f1      	bne.n	2c200 <usb_ep_get_transfer+0x8>
	return NULL;
   2c21c:	2000      	movs	r0, #0
   2c21e:	e7f7      	b.n	2c210 <usb_ep_get_transfer+0x18>
   2c220:	20003a00 	.word	0x20003a00

0002c224 <usb_transfer_work>:

	return false;
}

static void usb_transfer_work(struct k_work *item)
{
   2c224:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	uint8_t ep;

	trans = CONTAINER_OF(item, struct usb_transfer_data, work);
	ep = trans->ep;

	if (trans->status != -EBUSY) {
   2c228:	f850 3c30 	ldr.w	r3, [r0, #-48]
	ep = trans->ep;
   2c22c:	f810 6c34 	ldrb.w	r6, [r0, #-52]
	if (trans->status != -EBUSY) {
   2c230:	3310      	adds	r3, #16
{
   2c232:	4604      	mov	r4, r0
	if (trans->status != -EBUSY) {
   2c234:	d110      	bne.n	2c258 <usb_transfer_work+0x34>
		/* transfer cancelled or already completed */
		LOG_DBG("Transfer cancelled or completed, ep 0x%02x", ep);
		goto done;
	}

	if (trans->flags & USB_TRANS_WRITE) {
   2c236:	6903      	ldr	r3, [r0, #16]
		if (!trans->bsize) {
   2c238:	f850 2c28 	ldr.w	r2, [r0, #-40]
	if (trans->flags & USB_TRANS_WRITE) {
   2c23c:	0799      	lsls	r1, r3, #30
   2c23e:	d53c      	bpl.n	2c2ba <usb_transfer_work+0x96>
		if (!trans->bsize) {
   2c240:	bb02      	cbnz	r2, 2c284 <usb_transfer_work+0x60>
			if (!(trans->flags & USB_TRANS_NO_ZLP)) {
   2c242:	f013 0304 	ands.w	r3, r3, #4
   2c246:	d104      	bne.n	2c252 <usb_transfer_work+0x2e>
				LOG_DBG("Transfer ZLP");
				usb_write(ep, NULL, 0, NULL);
   2c248:	461a      	mov	r2, r3
   2c24a:	4619      	mov	r1, r3
   2c24c:	4630      	mov	r0, r6
   2c24e:	f01d f9f5 	bl	4963c <usb_write>
			}
			trans->status = 0;
   2c252:	2300      	movs	r3, #0

		ret = usb_write(ep, trans->buffer, trans->bsize, &bytes);
		if (ret) {
			LOG_ERR("Transfer error %d, ep 0x%02x", ret, ep);
			/* transfer error */
			trans->status = -EINVAL;
   2c254:	f844 3c30 	str.w	r3, [r4, #-48]
		/* we expect mote data, clear NAK */
		usb_dc_ep_read_continue(ep);
	}

done:
	if (trans->status != -EBUSY && trans->cb) { /* Transfer complete */
   2c258:	f854 3c30 	ldr.w	r3, [r4, #-48]
   2c25c:	3310      	adds	r3, #16
   2c25e:	d00e      	beq.n	2c27e <usb_transfer_work+0x5a>
   2c260:	f854 5c20 	ldr.w	r5, [r4, #-32]
   2c264:	b15d      	cbz	r5, 2c27e <usb_transfer_work+0x5a>
		usb_transfer_callback cb = trans->cb;
		int tsize = trans->tsize;
   2c266:	f854 7c24 	ldr.w	r7, [r4, #-36]
		void *priv = trans->priv;
   2c26a:	f854 8c1c 	ldr.w	r8, [r4, #-28]

		if (k_is_in_isr()) {
   2c26e:	f023 fcf0 	bl	4fc52 <k_is_in_isr>
   2c272:	2800      	cmp	r0, #0
   2c274:	d04c      	beq.n	2c310 <usb_transfer_work+0xec>
			/* reschedule completion in thread context */
			k_work_submit_to_queue(&USB_WORK_Q, &trans->work);
   2c276:	482e      	ldr	r0, [pc, #184]	; (2c330 <usb_transfer_work+0x10c>)
   2c278:	4621      	mov	r1, r4
   2c27a:	f023 feac 	bl	4ffd6 <k_work_submit_to_queue>
		/* Transfer completion callback */
		if (trans->status != -ECANCELED) {
			cb(ep, tsize, priv);
		}
	}
}
   2c27e:	b002      	add	sp, #8
   2c280:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		ret = usb_write(ep, trans->buffer, trans->bsize, &bytes);
   2c284:	f850 1c2c 	ldr.w	r1, [r0, #-44]
   2c288:	ab01      	add	r3, sp, #4
   2c28a:	4630      	mov	r0, r6
   2c28c:	f01d f9d6 	bl	4963c <usb_write>
		if (ret) {
   2c290:	b110      	cbz	r0, 2c298 <usb_transfer_work+0x74>
			trans->status = -EINVAL;
   2c292:	f06f 0315 	mvn.w	r3, #21
   2c296:	e7dd      	b.n	2c254 <usb_transfer_work+0x30>
		trans->buffer += bytes;
   2c298:	9a01      	ldr	r2, [sp, #4]
   2c29a:	f854 3c2c 	ldr.w	r3, [r4, #-44]
   2c29e:	4413      	add	r3, r2
   2c2a0:	f844 3c2c 	str.w	r3, [r4, #-44]
		trans->bsize -= bytes;
   2c2a4:	f854 3c28 	ldr.w	r3, [r4, #-40]
   2c2a8:	1a9b      	subs	r3, r3, r2
   2c2aa:	f844 3c28 	str.w	r3, [r4, #-40]
		trans->tsize += bytes;
   2c2ae:	f854 3c24 	ldr.w	r3, [r4, #-36]
   2c2b2:	4413      	add	r3, r2
   2c2b4:	f844 3c24 	str.w	r3, [r4, #-36]
   2c2b8:	e7ce      	b.n	2c258 <usb_transfer_work+0x34>
		ret = usb_dc_ep_read_wait(ep, trans->buffer, trans->bsize,
   2c2ba:	f850 1c2c 	ldr.w	r1, [r0, #-44]
   2c2be:	ab01      	add	r3, sp, #4
   2c2c0:	4630      	mov	r0, r6
   2c2c2:	f017 f8f9 	bl	434b8 <usb_dc_ep_read_wait>
		if (ret) {
   2c2c6:	2800      	cmp	r0, #0
   2c2c8:	d1e3      	bne.n	2c292 <usb_transfer_work+0x6e>
		trans->buffer += bytes;
   2c2ca:	9d01      	ldr	r5, [sp, #4]
   2c2cc:	f854 3c2c 	ldr.w	r3, [r4, #-44]
   2c2d0:	442b      	add	r3, r5
   2c2d2:	f844 3c2c 	str.w	r3, [r4, #-44]
		trans->bsize -= bytes;
   2c2d6:	f854 3c28 	ldr.w	r3, [r4, #-40]
   2c2da:	1b5b      	subs	r3, r3, r5
   2c2dc:	f844 3c28 	str.w	r3, [r4, #-40]
		trans->tsize += bytes;
   2c2e0:	f854 3c24 	ldr.w	r3, [r4, #-36]
   2c2e4:	442b      	add	r3, r5
   2c2e6:	f844 3c24 	str.w	r3, [r4, #-36]
		if (!bytes || (bytes % usb_dc_ep_mps(ep)) || !trans->bsize) {
   2c2ea:	2d00      	cmp	r5, #0
   2c2ec:	d0b1      	beq.n	2c252 <usb_transfer_work+0x2e>
   2c2ee:	4630      	mov	r0, r6
   2c2f0:	f017 f986 	bl	43600 <usb_dc_ep_mps>
   2c2f4:	fbb5 f3f0 	udiv	r3, r5, r0
   2c2f8:	fb03 5510 	mls	r5, r3, r0, r5
   2c2fc:	2d00      	cmp	r5, #0
   2c2fe:	d1a8      	bne.n	2c252 <usb_transfer_work+0x2e>
   2c300:	f854 3c28 	ldr.w	r3, [r4, #-40]
   2c304:	2b00      	cmp	r3, #0
   2c306:	d0a4      	beq.n	2c252 <usb_transfer_work+0x2e>
		usb_dc_ep_read_continue(ep);
   2c308:	4630      	mov	r0, r6
   2c30a:	f017 f91d 	bl	43548 <usb_dc_ep_read_continue>
   2c30e:	e7a3      	b.n	2c258 <usb_transfer_work+0x34>
		trans->cb = NULL;
   2c310:	f844 0c20 	str.w	r0, [r4, #-32]
	z_impl_k_sem_give(sem);
   2c314:	f1a4 0018 	sub.w	r0, r4, #24
   2c318:	f01a ff2e 	bl	47178 <z_impl_k_sem_give>
		if (trans->status != -ECANCELED) {
   2c31c:	f854 3c30 	ldr.w	r3, [r4, #-48]
   2c320:	338c      	adds	r3, #140	; 0x8c
   2c322:	d0ac      	beq.n	2c27e <usb_transfer_work+0x5a>
			cb(ep, tsize, priv);
   2c324:	4642      	mov	r2, r8
   2c326:	4639      	mov	r1, r7
   2c328:	4630      	mov	r0, r6
   2c32a:	47a8      	blx	r5
   2c32c:	e7a7      	b.n	2c27e <usb_transfer_work+0x5a>
   2c32e:	bf00      	nop
   2c330:	20003678 	.word	0x20003678

0002c334 <usb_cancel_transfer>:
	irq_unlock(key);
	return ret;
}

void usb_cancel_transfer(uint8_t ep)
{
   2c334:	b510      	push	{r4, lr}
   2c336:	f04f 0320 	mov.w	r3, #32
   2c33a:	f3ef 8411 	mrs	r4, BASEPRI
   2c33e:	f383 8812 	msr	BASEPRI_MAX, r3
   2c342:	f3bf 8f6f 	isb	sy
	struct usb_transfer_data *trans;
	unsigned int key;

	key = irq_lock();

	trans = usb_ep_get_transfer(ep);
   2c346:	f7ff ff57 	bl	2c1f8 <usb_ep_get_transfer>
	if (!trans) {
   2c34a:	b150      	cbz	r0, 2c362 <usb_cancel_transfer+0x2e>
		goto done;
	}

	if (trans->status != -EBUSY) {
   2c34c:	6843      	ldr	r3, [r0, #4]
   2c34e:	3310      	adds	r3, #16
   2c350:	d107      	bne.n	2c362 <usb_cancel_transfer+0x2e>
		goto done;
	}

	trans->status = -ECANCELED;
   2c352:	f06f 038b 	mvn.w	r3, #139	; 0x8b
   2c356:	6043      	str	r3, [r0, #4]
	k_work_submit_to_queue(&USB_WORK_Q, &trans->work);
   2c358:	f100 0134 	add.w	r1, r0, #52	; 0x34
   2c35c:	4803      	ldr	r0, [pc, #12]	; (2c36c <usb_cancel_transfer+0x38>)
   2c35e:	f023 fe3a 	bl	4ffd6 <k_work_submit_to_queue>
	__asm__ volatile(
   2c362:	f384 8811 	msr	BASEPRI, r4
   2c366:	f3bf 8f6f 	isb	sy

done:
	irq_unlock(key);
}
   2c36a:	bd10      	pop	{r4, pc}
   2c36c:	20003678 	.word	0x20003678

0002c370 <usb_cancel_transfers>:

void usb_cancel_transfers(void)
{
   2c370:	b570      	push	{r4, r5, r6, lr}
   2c372:	4c0f      	ldr	r4, [pc, #60]	; (2c3b0 <usb_cancel_transfers+0x40>)
   2c374:	2504      	movs	r5, #4
	__asm__ volatile(
   2c376:	f04f 0320 	mov.w	r3, #32
   2c37a:	f3ef 8611 	mrs	r6, BASEPRI
   2c37e:	f383 8812 	msr	BASEPRI_MAX, r3
   2c382:	f3bf 8f6f 	isb	sy
		struct usb_transfer_data *trans = &ut_data[i];
		unsigned int key;

		key = irq_lock();

		if (trans->status == -EBUSY) {
   2c386:	6863      	ldr	r3, [r4, #4]
   2c388:	3310      	adds	r3, #16
   2c38a:	d107      	bne.n	2c39c <usb_cancel_transfers+0x2c>
			trans->status = -ECANCELED;
   2c38c:	f06f 038b 	mvn.w	r3, #139	; 0x8b
			k_work_submit_to_queue(&USB_WORK_Q, &trans->work);
   2c390:	4808      	ldr	r0, [pc, #32]	; (2c3b4 <usb_cancel_transfers+0x44>)
			trans->status = -ECANCELED;
   2c392:	6063      	str	r3, [r4, #4]
			k_work_submit_to_queue(&USB_WORK_Q, &trans->work);
   2c394:	f104 0134 	add.w	r1, r4, #52	; 0x34
   2c398:	f023 fe1d 	bl	4ffd6 <k_work_submit_to_queue>
	__asm__ volatile(
   2c39c:	f386 8811 	msr	BASEPRI, r6
   2c3a0:	f3bf 8f6f 	isb	sy
	for (int i = 0; i < ARRAY_SIZE(ut_data); i++) {
   2c3a4:	3d01      	subs	r5, #1
   2c3a6:	f104 0448 	add.w	r4, r4, #72	; 0x48
   2c3aa:	d1e4      	bne.n	2c376 <usb_cancel_transfers+0x6>
			LOG_DBG("Cancel transfer for ep: 0x%02x", trans->ep);
		}

		irq_unlock(key);
	}
}
   2c3ac:	bd70      	pop	{r4, r5, r6, pc}
   2c3ae:	bf00      	nop
   2c3b0:	20003a00 	.word	0x20003a00
   2c3b4:	20003678 	.word	0x20003678

0002c3b8 <usb_transfer_init>:
	return pdata.tsize;
}

/* Init transfer slots */
int usb_transfer_init(void)
{
   2c3b8:	b570      	push	{r4, r5, r6, lr}
   2c3ba:	4c0a      	ldr	r4, [pc, #40]	; (2c3e4 <usb_transfer_init+0x2c>)
	for (int i = 0; i < ARRAY_SIZE(ut_data); i++) {
		k_work_init(&ut_data[i].work, usb_transfer_work);
   2c3bc:	4e0a      	ldr	r6, [pc, #40]	; (2c3e8 <usb_transfer_init+0x30>)
	for (int i = 0; i < ARRAY_SIZE(ut_data); i++) {
   2c3be:	2500      	movs	r5, #0
		k_work_init(&ut_data[i].work, usb_transfer_work);
   2c3c0:	4631      	mov	r1, r6
   2c3c2:	4620      	mov	r0, r4
   2c3c4:	f023 fdda 	bl	4ff7c <k_work_init>
	return z_impl_k_sem_init(sem, initial_count, limit);
   2c3c8:	2201      	movs	r2, #1
   2c3ca:	f1a4 0018 	sub.w	r0, r4, #24
   2c3ce:	4611      	mov	r1, r2
	for (int i = 0; i < ARRAY_SIZE(ut_data); i++) {
   2c3d0:	3501      	adds	r5, #1
   2c3d2:	f023 fd51 	bl	4fe78 <z_impl_k_sem_init>
   2c3d6:	2d04      	cmp	r5, #4
   2c3d8:	f104 0448 	add.w	r4, r4, #72	; 0x48
   2c3dc:	d1f0      	bne.n	2c3c0 <usb_transfer_init+0x8>
		k_sem_init(&ut_data[i].sem, 1, 1);
	}

	return 0;
}
   2c3de:	2000      	movs	r0, #0
   2c3e0:	bd70      	pop	{r4, r5, r6, pc}
   2c3e2:	bf00      	nop
   2c3e4:	20003a34 	.word	0x20003a34
   2c3e8:	0002c225 	.word	0x0002c225

0002c3ec <flash_area_open>:
		user_cb(&flash_map[i], user_data);
	}
}

int flash_area_open(uint8_t id, const struct flash_area **fap)
{
   2c3ec:	b570      	push	{r4, r5, r6, lr}
	const struct flash_area *area;

	if (flash_map == NULL) {
   2c3ee:	4b11      	ldr	r3, [pc, #68]	; (2c434 <flash_area_open+0x48>)
   2c3f0:	681c      	ldr	r4, [r3, #0]
{
   2c3f2:	460d      	mov	r5, r1
	if (flash_map == NULL) {
   2c3f4:	b1dc      	cbz	r4, 2c42e <flash_area_open+0x42>
extern const struct flash_area *flash_map;
extern const int flash_map_entries;

static inline struct flash_area const *get_flash_area_from_id(int idx)
{
	for (int i = 0; i < flash_map_entries; i++) {
   2c3f6:	4b10      	ldr	r3, [pc, #64]	; (2c438 <flash_area_open+0x4c>)
   2c3f8:	6819      	ldr	r1, [r3, #0]
   2c3fa:	2300      	movs	r3, #0
   2c3fc:	428b      	cmp	r3, r1
   2c3fe:	db02      	blt.n	2c406 <flash_area_open+0x1a>
		return -EACCES;
	}

	area = get_flash_area_from_id(id);
	if (area == NULL) {
		return -ENOENT;
   2c400:	f06f 0001 	mvn.w	r0, #1
	}

	*fap = area;

	return 0;
}
   2c404:	bd70      	pop	{r4, r5, r6, pc}
		if (flash_map[i].fa_id == idx) {
   2c406:	4622      	mov	r2, r4
   2c408:	f812 6b10 	ldrb.w	r6, [r2], #16
   2c40c:	4286      	cmp	r6, r0
   2c40e:	d002      	beq.n	2c416 <flash_area_open+0x2a>
	for (int i = 0; i < flash_map_entries; i++) {
   2c410:	3301      	adds	r3, #1
   2c412:	4614      	mov	r4, r2
   2c414:	e7f2      	b.n	2c3fc <flash_area_open+0x10>
	if (!area->fa_dev || !device_is_ready(area->fa_dev)) {
   2c416:	68e0      	ldr	r0, [r4, #12]
   2c418:	b910      	cbnz	r0, 2c420 <flash_area_open+0x34>
		return -ENODEV;
   2c41a:	f06f 0012 	mvn.w	r0, #18
   2c41e:	e7f1      	b.n	2c404 <flash_area_open+0x18>
   2c420:	f023 fb31 	bl	4fa86 <z_device_is_ready>
	if (!area->fa_dev || !device_is_ready(area->fa_dev)) {
   2c424:	2800      	cmp	r0, #0
   2c426:	d0f8      	beq.n	2c41a <flash_area_open+0x2e>
	*fap = area;
   2c428:	602c      	str	r4, [r5, #0]
	return 0;
   2c42a:	2000      	movs	r0, #0
   2c42c:	e7ea      	b.n	2c404 <flash_area_open+0x18>
		return -EACCES;
   2c42e:	f06f 000c 	mvn.w	r0, #12
   2c432:	e7e7      	b.n	2c404 <flash_area_open+0x18>
   2c434:	200005b4 	.word	0x200005b4
   2c438:	00051b30 	.word	0x00051b30

0002c43c <flash_area_get_sectors>:

	return true;
}

int flash_area_get_sectors(int idx, uint32_t *cnt, struct flash_sector *ret)
{
   2c43c:	b570      	push	{r4, r5, r6, lr}
   2c43e:	b088      	sub	sp, #32
   2c440:	4605      	mov	r5, r0
   2c442:	460c      	mov	r4, r1
	int rc = flash_area_open(idx, &fa);
   2c444:	b2c0      	uxtb	r0, r0
   2c446:	4669      	mov	r1, sp
{
   2c448:	4616      	mov	r6, r2
	int rc = flash_area_open(idx, &fa);
   2c44a:	f7ff ffcf 	bl	2c3ec <flash_area_open>
	if (rc < 0 || fa == NULL) {
   2c44e:	2800      	cmp	r0, #0
   2c450:	db1b      	blt.n	2c48a <flash_area_get_sectors+0x4e>
   2c452:	9800      	ldr	r0, [sp, #0]
   2c454:	b1c8      	cbz	r0, 2c48a <flash_area_get_sectors+0x4e>
	cb_data->area_off = fa->fa_off;
   2c456:	6843      	ldr	r3, [r0, #4]
   2c458:	9302      	str	r3, [sp, #8]
	cb_data->area_len = fa->fa_size;
   2c45a:	6883      	ldr	r3, [r0, #8]
	cb_data->ret_len = *cnt;
   2c45c:	6822      	ldr	r2, [r4, #0]
	cb_data->area_idx = idx;
   2c45e:	9501      	str	r5, [sp, #4]
	cb_data->ret = ret;
   2c460:	e9cd 3603 	strd	r3, r6, [sp, #12]
	cb_data->ret_idx = 0U;
   2c464:	2300      	movs	r3, #0
	cb_data->status = 0;
   2c466:	e9cd 2306 	strd	r2, r3, [sp, #24]
	cb_data->ret_idx = 0U;
   2c46a:	9305      	str	r3, [sp, #20]
	flash_dev = fa->fa_dev;
   2c46c:	68c5      	ldr	r5, [r0, #12]
	flash_area_close(fa);
   2c46e:	f01d f92d 	bl	496cc <flash_area_close>
	if (flash_dev == NULL) {
   2c472:	b16d      	cbz	r5, 2c490 <flash_area_get_sectors+0x54>
	flash_page_foreach(flash_dev, cb, cb_data);
   2c474:	4628      	mov	r0, r5
   2c476:	4908      	ldr	r1, [pc, #32]	; (2c498 <flash_area_get_sectors+0x5c>)
   2c478:	aa01      	add	r2, sp, #4
   2c47a:	f022 fec4 	bl	4f206 <flash_page_foreach>
	if (cb_data->status == 0) {
   2c47e:	9807      	ldr	r0, [sp, #28]
   2c480:	b908      	cbnz	r0, 2c486 <flash_area_get_sectors+0x4a>
		*cnt = cb_data->ret_idx;
   2c482:	9b05      	ldr	r3, [sp, #20]
   2c484:	6023      	str	r3, [r4, #0]
	struct layout_data data;

	return flash_area_layout(idx, cnt, ret, get_sectors_cb, &data);
}
   2c486:	b008      	add	sp, #32
   2c488:	bd70      	pop	{r4, r5, r6, pc}
		return -EINVAL;
   2c48a:	f06f 0015 	mvn.w	r0, #21
   2c48e:	e7fa      	b.n	2c486 <flash_area_get_sectors+0x4a>
		return -ENODEV;
   2c490:	f06f 0012 	mvn.w	r0, #18
	return flash_area_layout(idx, cnt, ret, get_sectors_cb, &data);
   2c494:	e7f7      	b.n	2c486 <flash_area_get_sectors+0x4a>
   2c496:	bf00      	nop
   2c498:	000496cf 	.word	0x000496cf

0002c49c <settings_save_one>:

/*
 * Append a single value to persisted config. Don't store duplicate value.
 */
int settings_save_one(const char *name, const void *value, size_t val_len)
{
   2c49c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	int rc;
	struct settings_store *cs;

	cs = settings_save_dst;
   2c4a0:	4b0f      	ldr	r3, [pc, #60]	; (2c4e0 <settings_save_one+0x44>)
   2c4a2:	681c      	ldr	r4, [r3, #0]
{
   2c4a4:	4605      	mov	r5, r0
   2c4a6:	460e      	mov	r6, r1
   2c4a8:	4617      	mov	r7, r2
	if (!cs) {
   2c4aa:	b1ac      	cbz	r4, 2c4d8 <settings_save_one+0x3c>
	return z_impl_k_mutex_lock(mutex, timeout);
   2c4ac:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   2c4b0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2c4b4:	480b      	ldr	r0, [pc, #44]	; (2c4e4 <settings_save_one+0x48>)
   2c4b6:	f01a fd75 	bl	46fa4 <z_impl_k_mutex_lock>
		return -ENOENT;
	}

	k_mutex_lock(&settings_lock, K_FOREVER);

	rc = cs->cs_itf->csi_save(cs, name, (char *)value, val_len);
   2c4ba:	6863      	ldr	r3, [r4, #4]
   2c4bc:	4632      	mov	r2, r6
   2c4be:	f8d3 8008 	ldr.w	r8, [r3, #8]
   2c4c2:	4629      	mov	r1, r5
   2c4c4:	463b      	mov	r3, r7
   2c4c6:	4620      	mov	r0, r4
   2c4c8:	47c0      	blx	r8
   2c4ca:	4604      	mov	r4, r0
	return z_impl_k_mutex_unlock(mutex);
   2c4cc:	4805      	ldr	r0, [pc, #20]	; (2c4e4 <settings_save_one+0x48>)
   2c4ce:	f01a fde3 	bl	47098 <z_impl_k_mutex_unlock>

	k_mutex_unlock(&settings_lock);

	return rc;
}
   2c4d2:	4620      	mov	r0, r4
   2c4d4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return -ENOENT;
   2c4d8:	f06f 0401 	mvn.w	r4, #1
   2c4dc:	e7f9      	b.n	2c4d2 <settings_save_one+0x36>
   2c4de:	bf00      	nop
   2c4e0:	20003b20 	.word	0x20003b20
   2c4e4:	200010f4 	.word	0x200010f4

0002c4e8 <settings_src_register>:
	parent->next = child;
   2c4e8:	2300      	movs	r3, #0
   2c4ea:	6003      	str	r3, [r0, #0]
 *
 * @return A pointer on the last node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_tail(sys_slist_t *list)
{
	return list->tail;
   2c4ec:	4b04      	ldr	r3, [pc, #16]	; (2c500 <settings_src_register+0x18>)
   2c4ee:	685a      	ldr	r2, [r3, #4]
 * @param node A pointer on the node to append
 */
static inline void sys_slist_append(sys_slist_t *list,
				    sys_snode_t *node);

Z_GENLIST_APPEND(slist, snode)
   2c4f0:	b912      	cbnz	r2, 2c4f8 <settings_src_register+0x10>
	list->head = node;
   2c4f2:	e9c3 0000 	strd	r0, r0, [r3]
}
   2c4f6:	4770      	bx	lr
	parent->next = child;
   2c4f8:	6010      	str	r0, [r2, #0]
	list->tail = node;
   2c4fa:	6058      	str	r0, [r3, #4]
}
   2c4fc:	4770      	bx	lr
   2c4fe:	bf00      	nop
   2c500:	20003b24 	.word	0x20003b24

0002c504 <settings_dst_register>:
	settings_save_dst = cs;
   2c504:	4b01      	ldr	r3, [pc, #4]	; (2c50c <settings_dst_register+0x8>)
   2c506:	6018      	str	r0, [r3, #0]
}
   2c508:	4770      	bx	lr
   2c50a:	bf00      	nop
   2c50c:	20003b20 	.word	0x20003b20

0002c510 <settings_load_subtree>:
{
   2c510:	b530      	push	{r4, r5, lr}
   2c512:	b085      	sub	sp, #20
	const struct settings_load_arg arg = {
   2c514:	2300      	movs	r3, #0
{
   2c516:	4605      	mov	r5, r0
	const struct settings_load_arg arg = {
   2c518:	e9cd 3302 	strd	r3, r3, [sp, #8]
   2c51c:	9001      	str	r0, [sp, #4]
	return z_impl_k_mutex_lock(mutex, timeout);
   2c51e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2c522:	480c      	ldr	r0, [pc, #48]	; (2c554 <settings_load_subtree+0x44>)
   2c524:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   2c528:	f01a fd3c 	bl	46fa4 <z_impl_k_mutex_lock>
	return list->head;
   2c52c:	4b0a      	ldr	r3, [pc, #40]	; (2c558 <settings_load_subtree+0x48>)
   2c52e:	681c      	ldr	r4, [r3, #0]
	SYS_SLIST_FOR_EACH_CONTAINER(&settings_load_srcs, cs, cs_next) {
   2c530:	b94c      	cbnz	r4, 2c546 <settings_load_subtree+0x36>
	rc = settings_commit_subtree(subtree);
   2c532:	4628      	mov	r0, r5
   2c534:	f000 f8ce 	bl	2c6d4 <settings_commit_subtree>
   2c538:	4604      	mov	r4, r0
	return z_impl_k_mutex_unlock(mutex);
   2c53a:	4806      	ldr	r0, [pc, #24]	; (2c554 <settings_load_subtree+0x44>)
   2c53c:	f01a fdac 	bl	47098 <z_impl_k_mutex_unlock>
}
   2c540:	4620      	mov	r0, r4
   2c542:	b005      	add	sp, #20
   2c544:	bd30      	pop	{r4, r5, pc}
		cs->cs_itf->csi_load(cs, &arg);
   2c546:	6863      	ldr	r3, [r4, #4]
   2c548:	4620      	mov	r0, r4
   2c54a:	681b      	ldr	r3, [r3, #0]
   2c54c:	a901      	add	r1, sp, #4
   2c54e:	4798      	blx	r3
	return node->next;
   2c550:	6824      	ldr	r4, [r4, #0]
   2c552:	e7ed      	b.n	2c530 <settings_load_subtree+0x20>
   2c554:	200010f4 	.word	0x200010f4
   2c558:	20003b24 	.word	0x20003b24

0002c55c <settings_load_subtree_direct>:
{
   2c55c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	const struct settings_load_arg arg = {
   2c55e:	e9cd 0101 	strd	r0, r1, [sp, #4]
   2c562:	9203      	str	r2, [sp, #12]
	return z_impl_k_mutex_lock(mutex, timeout);
   2c564:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2c568:	480a      	ldr	r0, [pc, #40]	; (2c594 <settings_load_subtree_direct+0x38>)
   2c56a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   2c56e:	f01a fd19 	bl	46fa4 <z_impl_k_mutex_lock>
	return list->head;
   2c572:	4b09      	ldr	r3, [pc, #36]	; (2c598 <settings_load_subtree_direct+0x3c>)
   2c574:	681c      	ldr	r4, [r3, #0]
	SYS_SLIST_FOR_EACH_CONTAINER(&settings_load_srcs, cs, cs_next) {
   2c576:	b92c      	cbnz	r4, 2c584 <settings_load_subtree_direct+0x28>
	return z_impl_k_mutex_unlock(mutex);
   2c578:	4806      	ldr	r0, [pc, #24]	; (2c594 <settings_load_subtree_direct+0x38>)
   2c57a:	f01a fd8d 	bl	47098 <z_impl_k_mutex_unlock>
}
   2c57e:	4620      	mov	r0, r4
   2c580:	b004      	add	sp, #16
   2c582:	bd10      	pop	{r4, pc}
		cs->cs_itf->csi_load(cs, &arg);
   2c584:	6863      	ldr	r3, [r4, #4]
   2c586:	4620      	mov	r0, r4
   2c588:	681b      	ldr	r3, [r3, #0]
   2c58a:	a901      	add	r1, sp, #4
   2c58c:	4798      	blx	r3
	return node->next;
   2c58e:	6824      	ldr	r4, [r4, #0]
   2c590:	e7f1      	b.n	2c576 <settings_load_subtree_direct+0x1a>
   2c592:	bf00      	nop
   2c594:	200010f4 	.word	0x200010f4
   2c598:	20003b24 	.word	0x20003b24

0002c59c <settings_store_init>:
	list->head = NULL;
   2c59c:	4b02      	ldr	r3, [pc, #8]	; (2c5a8 <settings_store_init+0xc>)
   2c59e:	2200      	movs	r2, #0
	list->tail = NULL;
   2c5a0:	e9c3 2200 	strd	r2, r2, [r3]
}

void settings_store_init(void)
{
	sys_slist_init(&settings_load_srcs);
}
   2c5a4:	4770      	bx	lr
   2c5a6:	bf00      	nop
   2c5a8:	20003b24 	.word	0x20003b24

0002c5ac <settings_init>:
	list->head = NULL;
   2c5ac:	4b02      	ldr	r3, [pc, #8]	; (2c5b8 <settings_init+0xc>)
   2c5ae:	2200      	movs	r2, #0
	list->tail = NULL;
   2c5b0:	e9c3 2200 	strd	r2, r2, [r3]
void settings_init(void)
{
#if defined(CONFIG_SETTINGS_DYNAMIC_HANDLERS)
	sys_slist_init(&settings_handlers);
#endif /* CONFIG_SETTINGS_DYNAMIC_HANDLERS */
	settings_store_init();
   2c5b4:	f7ff bff2 	b.w	2c59c <settings_store_init>
   2c5b8:	20003b2c 	.word	0x20003b2c

0002c5bc <settings_register>:
}

#if defined(CONFIG_SETTINGS_DYNAMIC_HANDLERS)
int settings_register(struct settings_handler *handler)
{
   2c5bc:	b570      	push	{r4, r5, r6, lr}
	int rc = 0;

	STRUCT_SECTION_FOREACH(settings_handler_static, ch) {
   2c5be:	4c1b      	ldr	r4, [pc, #108]	; (2c62c <settings_register+0x70>)
   2c5c0:	4e1b      	ldr	r6, [pc, #108]	; (2c630 <settings_register+0x74>)
{
   2c5c2:	4605      	mov	r5, r0
	STRUCT_SECTION_FOREACH(settings_handler_static, ch) {
   2c5c4:	42b4      	cmp	r4, r6
   2c5c6:	d312      	bcc.n	2c5ee <settings_register+0x32>
	return list->head;
   2c5c8:	4e1a      	ldr	r6, [pc, #104]	; (2c634 <settings_register+0x78>)
	return z_impl_k_mutex_lock(mutex, timeout);
   2c5ca:	481b      	ldr	r0, [pc, #108]	; (2c638 <settings_register+0x7c>)
   2c5cc:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   2c5d0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2c5d4:	f01a fce6 	bl	46fa4 <z_impl_k_mutex_lock>
   2c5d8:	6834      	ldr	r4, [r6, #0]
	}

	k_mutex_lock(&settings_lock, K_FOREVER);

	struct settings_handler *ch;
	SYS_SLIST_FOR_EACH_CONTAINER(&settings_handlers, ch, node) {
   2c5da:	b17c      	cbz	r4, 2c5fc <settings_register+0x40>
		if (strcmp(handler->name, ch->name) == 0) {
   2c5dc:	6828      	ldr	r0, [r5, #0]
   2c5de:	f854 1c14 	ldr.w	r1, [r4, #-20]
	SYS_SLIST_FOR_EACH_CONTAINER(&settings_handlers, ch, node) {
   2c5e2:	3c14      	subs	r4, #20
		if (strcmp(handler->name, ch->name) == 0) {
   2c5e4:	f01e fc19 	bl	4ae1a <strcmp>
   2c5e8:	b1c8      	cbz	r0, 2c61e <settings_register+0x62>
	return node->next;
   2c5ea:	6964      	ldr	r4, [r4, #20]
   2c5ec:	e7f5      	b.n	2c5da <settings_register+0x1e>
		if (strcmp(handler->name, ch->name) == 0) {
   2c5ee:	6821      	ldr	r1, [r4, #0]
   2c5f0:	6828      	ldr	r0, [r5, #0]
   2c5f2:	f01e fc12 	bl	4ae1a <strcmp>
   2c5f6:	b1a8      	cbz	r0, 2c624 <settings_register+0x68>
	STRUCT_SECTION_FOREACH(settings_handler_static, ch) {
   2c5f8:	3414      	adds	r4, #20
   2c5fa:	e7e3      	b.n	2c5c4 <settings_register+0x8>
	parent->next = child;
   2c5fc:	2200      	movs	r2, #0
   2c5fe:	616a      	str	r2, [r5, #20]
	return list->tail;
   2c600:	6872      	ldr	r2, [r6, #4]
			rc = -EEXIST;
			goto end;
		}
	}
	sys_slist_append(&settings_handlers, &handler->node);
   2c602:	f105 0314 	add.w	r3, r5, #20
Z_GENLIST_APPEND(slist, snode)
   2c606:	b93a      	cbnz	r2, 2c618 <settings_register+0x5c>
	list->head = node;
   2c608:	e9c6 3300 	strd	r3, r3, [r6]
	int rc = 0;
   2c60c:	2400      	movs	r4, #0
	return z_impl_k_mutex_unlock(mutex);
   2c60e:	480a      	ldr	r0, [pc, #40]	; (2c638 <settings_register+0x7c>)
   2c610:	f01a fd42 	bl	47098 <z_impl_k_mutex_unlock>

end:
	k_mutex_unlock(&settings_lock);
	return rc;
}
   2c614:	4620      	mov	r0, r4
   2c616:	bd70      	pop	{r4, r5, r6, pc}
	parent->next = child;
   2c618:	6013      	str	r3, [r2, #0]
	list->tail = node;
   2c61a:	6073      	str	r3, [r6, #4]
}
   2c61c:	e7f6      	b.n	2c60c <settings_register+0x50>
			rc = -EEXIST;
   2c61e:	f06f 0410 	mvn.w	r4, #16
   2c622:	e7f4      	b.n	2c60e <settings_register+0x52>
			return -EEXIST;
   2c624:	f06f 0410 	mvn.w	r4, #16
   2c628:	e7f4      	b.n	2c614 <settings_register+0x58>
   2c62a:	bf00      	nop
   2c62c:	00050ca0 	.word	0x00050ca0
   2c630:	00050d18 	.word	0x00050d18
   2c634:	20003b2c 	.word	0x20003b2c
   2c638:	200010f4 	.word	0x200010f4

0002c63c <settings_parse_and_lookup>:
	return rc;
}

struct settings_handler_static *settings_parse_and_lookup(const char *name,
							const char **next)
{
   2c63c:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   2c640:	4607      	mov	r7, r0
	struct settings_handler_static *bestmatch;
	const char *tmpnext;

	bestmatch = NULL;
	if (next) {
   2c642:	460c      	mov	r4, r1
   2c644:	b109      	cbz	r1, 2c64a <settings_parse_and_lookup+0xe>
		*next = NULL;
   2c646:	2300      	movs	r3, #0
   2c648:	600b      	str	r3, [r1, #0]
{
   2c64a:	4d1f      	ldr	r5, [pc, #124]	; (2c6c8 <settings_parse_and_lookup+0x8c>)
	}

	STRUCT_SECTION_FOREACH(settings_handler_static, ch) {
   2c64c:	f8df 907c 	ldr.w	r9, [pc, #124]	; 2c6cc <settings_parse_and_lookup+0x90>
{
   2c650:	2600      	movs	r6, #0
	STRUCT_SECTION_FOREACH(settings_handler_static, ch) {
   2c652:	454d      	cmp	r5, r9
   2c654:	d30f      	bcc.n	2c676 <settings_parse_and_lookup+0x3a>
	return list->head;
   2c656:	4b1e      	ldr	r3, [pc, #120]	; (2c6d0 <settings_parse_and_lookup+0x94>)
   2c658:	681d      	ldr	r5, [r3, #0]
	}

#if defined(CONFIG_SETTINGS_DYNAMIC_HANDLERS)
	struct settings_handler *ch;

	SYS_SLIST_FOR_EACH_CONTAINER(&settings_handlers, ch, node) {
   2c65a:	b385      	cbz	r5, 2c6be <settings_parse_and_lookup+0x82>
		if (!settings_name_steq(name, ch->name, &tmpnext)) {
   2c65c:	f855 8c14 	ldr.w	r8, [r5, #-20]
   2c660:	aa01      	add	r2, sp, #4
   2c662:	4641      	mov	r1, r8
   2c664:	4638      	mov	r0, r7
	SYS_SLIST_FOR_EACH_CONTAINER(&settings_handlers, ch, node) {
   2c666:	3d14      	subs	r5, #20
		if (!settings_name_steq(name, ch->name, &tmpnext)) {
   2c668:	f01d f857 	bl	4971a <settings_name_steq>
   2c66c:	b310      	cbz	r0, 2c6b4 <settings_parse_and_lookup+0x78>
			continue;
		}
		if (!bestmatch) {
   2c66e:	b9d6      	cbnz	r6, 2c6a6 <settings_parse_and_lookup+0x6a>
			}
			continue;
		}
		if (settings_name_steq(ch->name, bestmatch->name, NULL)) {
			bestmatch = (struct settings_handler_static *)ch;
			if (next) {
   2c670:	bb14      	cbnz	r4, 2c6b8 <settings_parse_and_lookup+0x7c>
{
   2c672:	462e      	mov	r6, r5
   2c674:	e01e      	b.n	2c6b4 <settings_parse_and_lookup+0x78>
		if (!settings_name_steq(name, ch->name, &tmpnext)) {
   2c676:	f8d5 8000 	ldr.w	r8, [r5]
   2c67a:	aa01      	add	r2, sp, #4
   2c67c:	4641      	mov	r1, r8
   2c67e:	4638      	mov	r0, r7
   2c680:	f01d f84b 	bl	4971a <settings_name_steq>
   2c684:	b150      	cbz	r0, 2c69c <settings_parse_and_lookup+0x60>
		if (!bestmatch) {
   2c686:	b916      	cbnz	r6, 2c68e <settings_parse_and_lookup+0x52>
			if (next) {
   2c688:	b954      	cbnz	r4, 2c6a0 <settings_parse_and_lookup+0x64>
{
   2c68a:	462e      	mov	r6, r5
   2c68c:	e006      	b.n	2c69c <settings_parse_and_lookup+0x60>
		if (settings_name_steq(ch->name, bestmatch->name, NULL)) {
   2c68e:	6831      	ldr	r1, [r6, #0]
   2c690:	2200      	movs	r2, #0
   2c692:	4640      	mov	r0, r8
   2c694:	f01d f841 	bl	4971a <settings_name_steq>
   2c698:	2800      	cmp	r0, #0
   2c69a:	d1f5      	bne.n	2c688 <settings_parse_and_lookup+0x4c>
	STRUCT_SECTION_FOREACH(settings_handler_static, ch) {
   2c69c:	3514      	adds	r5, #20
   2c69e:	e7d8      	b.n	2c652 <settings_parse_and_lookup+0x16>
				*next = tmpnext;
   2c6a0:	9b01      	ldr	r3, [sp, #4]
   2c6a2:	6023      	str	r3, [r4, #0]
   2c6a4:	e7f1      	b.n	2c68a <settings_parse_and_lookup+0x4e>
		if (settings_name_steq(ch->name, bestmatch->name, NULL)) {
   2c6a6:	6831      	ldr	r1, [r6, #0]
   2c6a8:	2200      	movs	r2, #0
   2c6aa:	4640      	mov	r0, r8
   2c6ac:	f01d f835 	bl	4971a <settings_name_steq>
   2c6b0:	2800      	cmp	r0, #0
   2c6b2:	d1dd      	bne.n	2c670 <settings_parse_and_lookup+0x34>
	return node->next;
   2c6b4:	696d      	ldr	r5, [r5, #20]
   2c6b6:	e7d0      	b.n	2c65a <settings_parse_and_lookup+0x1e>
				*next = tmpnext;
   2c6b8:	9b01      	ldr	r3, [sp, #4]
   2c6ba:	6023      	str	r3, [r4, #0]
   2c6bc:	e7d9      	b.n	2c672 <settings_parse_and_lookup+0x36>
			}
		}
	}
#endif /* CONFIG_SETTINGS_DYNAMIC_HANDLERS */
	return bestmatch;
}
   2c6be:	4630      	mov	r0, r6
   2c6c0:	b003      	add	sp, #12
   2c6c2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   2c6c6:	bf00      	nop
   2c6c8:	00050ca0 	.word	0x00050ca0
   2c6cc:	00050d18 	.word	0x00050d18
   2c6d0:	20003b2c 	.word	0x20003b2c

0002c6d4 <settings_commit_subtree>:
{
	return settings_commit_subtree(NULL);
}

int settings_commit_subtree(const char *subtree)
{
   2c6d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	int rc;
	int rc2;

	rc = 0;

	STRUCT_SECTION_FOREACH(settings_handler_static, ch) {
   2c6d6:	4c18      	ldr	r4, [pc, #96]	; (2c738 <settings_commit_subtree+0x64>)
   2c6d8:	4f18      	ldr	r7, [pc, #96]	; (2c73c <settings_commit_subtree+0x68>)
{
   2c6da:	4606      	mov	r6, r0
	rc = 0;
   2c6dc:	2500      	movs	r5, #0
	STRUCT_SECTION_FOREACH(settings_handler_static, ch) {
   2c6de:	42bc      	cmp	r4, r7
   2c6e0:	d308      	bcc.n	2c6f4 <settings_commit_subtree+0x20>
	return list->head;
   2c6e2:	4b17      	ldr	r3, [pc, #92]	; (2c740 <settings_commit_subtree+0x6c>)
   2c6e4:	681c      	ldr	r4, [r3, #0]
		}
	}

#if defined(CONFIG_SETTINGS_DYNAMIC_HANDLERS)
	struct settings_handler *ch;
	SYS_SLIST_FOR_EACH_CONTAINER(&settings_handlers, ch, node) {
   2c6e6:	b32c      	cbz	r4, 2c734 <settings_commit_subtree+0x60>
   2c6e8:	3c14      	subs	r4, #20
		if (subtree && !settings_name_steq(ch->name, subtree, NULL)) {
   2c6ea:	b9b6      	cbnz	r6, 2c71a <settings_commit_subtree+0x46>
			continue;
		}
		if (ch->h_commit) {
   2c6ec:	68e3      	ldr	r3, [r4, #12]
   2c6ee:	b9e3      	cbnz	r3, 2c72a <settings_commit_subtree+0x56>
	return node->next;
   2c6f0:	6964      	ldr	r4, [r4, #20]
   2c6f2:	e7f8      	b.n	2c6e6 <settings_commit_subtree+0x12>
		if (subtree && !settings_name_steq(ch->name, subtree, NULL)) {
   2c6f4:	b92e      	cbnz	r6, 2c702 <settings_commit_subtree+0x2e>
		if (ch->h_commit) {
   2c6f6:	68e3      	ldr	r3, [r4, #12]
   2c6f8:	b95b      	cbnz	r3, 2c712 <settings_commit_subtree+0x3e>
{
   2c6fa:	4628      	mov	r0, r5
	STRUCT_SECTION_FOREACH(settings_handler_static, ch) {
   2c6fc:	3414      	adds	r4, #20
   2c6fe:	4605      	mov	r5, r0
   2c700:	e7ed      	b.n	2c6de <settings_commit_subtree+0xa>
		if (subtree && !settings_name_steq(ch->name, subtree, NULL)) {
   2c702:	6820      	ldr	r0, [r4, #0]
   2c704:	2200      	movs	r2, #0
   2c706:	4631      	mov	r1, r6
   2c708:	f01d f807 	bl	4971a <settings_name_steq>
   2c70c:	2800      	cmp	r0, #0
   2c70e:	d1f2      	bne.n	2c6f6 <settings_commit_subtree+0x22>
   2c710:	e7f3      	b.n	2c6fa <settings_commit_subtree+0x26>
			rc2 = ch->h_commit();
   2c712:	4798      	blx	r3
			if (!rc) {
   2c714:	2d00      	cmp	r5, #0
   2c716:	d1f0      	bne.n	2c6fa <settings_commit_subtree+0x26>
   2c718:	e7f0      	b.n	2c6fc <settings_commit_subtree+0x28>
		if (subtree && !settings_name_steq(ch->name, subtree, NULL)) {
   2c71a:	6820      	ldr	r0, [r4, #0]
   2c71c:	2200      	movs	r2, #0
   2c71e:	4631      	mov	r1, r6
   2c720:	f01c fffb 	bl	4971a <settings_name_steq>
   2c724:	2800      	cmp	r0, #0
   2c726:	d1e1      	bne.n	2c6ec <settings_commit_subtree+0x18>
   2c728:	e7e2      	b.n	2c6f0 <settings_commit_subtree+0x1c>
			rc2 = ch->h_commit();
   2c72a:	4798      	blx	r3
			if (!rc) {
				rc = rc2;
   2c72c:	2d00      	cmp	r5, #0
   2c72e:	bf08      	it	eq
   2c730:	4605      	moveq	r5, r0
   2c732:	e7dd      	b.n	2c6f0 <settings_commit_subtree+0x1c>
		}
	}
#endif /* CONFIG_SETTINGS_DYNAMIC_HANDLERS */

	return rc;
}
   2c734:	4628      	mov	r0, r5
   2c736:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2c738:	00050ca0 	.word	0x00050ca0
   2c73c:	00050d18 	.word	0x00050d18
   2c740:	20003b2c 	.word	0x20003b2c

0002c744 <settings_subsys_init>:
void settings_init(void);

int settings_backend_init(void);

int settings_subsys_init(void)
{
   2c744:	b510      	push	{r4, lr}

	int err = 0;

	if (settings_subsys_initialized) {
   2c746:	4c07      	ldr	r4, [pc, #28]	; (2c764 <settings_subsys_init+0x20>)
   2c748:	7823      	ldrb	r3, [r4, #0]
   2c74a:	b10b      	cbz	r3, 2c750 <settings_subsys_init+0xc>
		return 0;
   2c74c:	2000      	movs	r0, #0
	if (!err) {
		settings_subsys_initialized = true;
	}

	return err;
}
   2c74e:	bd10      	pop	{r4, pc}
	settings_init();
   2c750:	f7ff ff2c 	bl	2c5ac <settings_init>
	err = settings_backend_init(); /* func rises kernel panic once error */
   2c754:	f000 f866 	bl	2c824 <settings_backend_init>
	if (!err) {
   2c758:	2800      	cmp	r0, #0
   2c75a:	d1f8      	bne.n	2c74e <settings_subsys_init+0xa>
		settings_subsys_initialized = true;
   2c75c:	2301      	movs	r3, #1
   2c75e:	7023      	strb	r3, [r4, #0]
   2c760:	e7f4      	b.n	2c74c <settings_subsys_init+0x8>
   2c762:	bf00      	nop
   2c764:	20006b05 	.word	0x20006b05

0002c768 <settings_nvs_load>:
	return 0;
}

static int settings_nvs_load(struct settings_store *cs,
			     const struct settings_load_arg *arg)
{
   2c768:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	char name[SETTINGS_MAX_NAME_LEN + SETTINGS_EXTRA_LEN + 1];
	char buf;
	ssize_t rc1, rc2;
	uint16_t name_id = NVS_NAMECNT_ID;

	name_id = cf->last_name_id + 1;
   2c76c:	8f04      	ldrh	r4, [r0, #56]	; 0x38
		/* Found a name, this might not include a trailing \0 */
		name[rc1] = '\0';
		read_fn_arg.fs = &cf->cf_nvs;
		read_fn_arg.id = name_id + NVS_NAME_ID_OFFSET;

		ret = settings_call_set_handler(
   2c76e:	f8df a0b0 	ldr.w	sl, [pc, #176]	; 2c820 <settings_nvs_load+0xb8>
	name_id = cf->last_name_id + 1;
   2c772:	3401      	adds	r4, #1
{
   2c774:	b098      	sub	sp, #96	; 0x60
   2c776:	4680      	mov	r8, r0
   2c778:	4689      	mov	r9, r1
	name_id = cf->last_name_id + 1;
   2c77a:	b2a4      	uxth	r4, r4
		rc1 = nvs_read(&cf->cf_nvs, name_id, &name, sizeof(name));
   2c77c:	f100 0608 	add.w	r6, r0, #8
		name_id--;
   2c780:	1e65      	subs	r5, r4, #1
   2c782:	b2ad      	uxth	r5, r5
		if (name_id == NVS_NAMECNT_ID) {
   2c784:	f5b5 4f00 	cmp.w	r5, #32768	; 0x8000
   2c788:	d047      	beq.n	2c81a <settings_nvs_load+0xb2>
		rc1 = nvs_read(&cf->cf_nvs, name_id, &name, sizeof(name));
   2c78a:	234a      	movs	r3, #74	; 0x4a
   2c78c:	aa05      	add	r2, sp, #20
   2c78e:	4629      	mov	r1, r5
   2c790:	4630      	mov	r0, r6
   2c792:	f01c ff4c 	bl	4962e <nvs_read>
		rc2 = nvs_read(&cf->cf_nvs, name_id + NVS_NAME_ID_OFFSET,
   2c796:	f504 547f 	add.w	r4, r4, #16320	; 0x3fc0
   2c79a:	343f      	adds	r4, #63	; 0x3f
   2c79c:	b2a4      	uxth	r4, r4
		rc1 = nvs_read(&cf->cf_nvs, name_id, &name, sizeof(name));
   2c79e:	4607      	mov	r7, r0
		rc2 = nvs_read(&cf->cf_nvs, name_id + NVS_NAME_ID_OFFSET,
   2c7a0:	4621      	mov	r1, r4
   2c7a2:	2301      	movs	r3, #1
   2c7a4:	f10d 020b 	add.w	r2, sp, #11
   2c7a8:	4630      	mov	r0, r6
   2c7aa:	f01c ff40 	bl	4962e <nvs_read>
		if ((rc1 <= 0) && (rc2 <= 0)) {
   2c7ae:	2f00      	cmp	r7, #0
		rc2 = nvs_read(&cf->cf_nvs, name_id + NVS_NAME_ID_OFFSET,
   2c7b0:	4601      	mov	r1, r0
		if ((rc1 <= 0) && (rc2 <= 0)) {
   2c7b2:	dc03      	bgt.n	2c7bc <settings_nvs_load+0x54>
   2c7b4:	2800      	cmp	r0, #0
   2c7b6:	dc03      	bgt.n	2c7c0 <settings_nvs_load+0x58>
{
   2c7b8:	462c      	mov	r4, r5
   2c7ba:	e7e1      	b.n	2c780 <settings_nvs_load+0x18>
		if ((rc1 <= 0) || (rc2 <= 0)) {
   2c7bc:	2800      	cmp	r0, #0
   2c7be:	dc16      	bgt.n	2c7ee <settings_nvs_load+0x86>
			if (name_id == cf->last_name_id) {
   2c7c0:	f8b8 3038 	ldrh.w	r3, [r8, #56]	; 0x38
   2c7c4:	42ab      	cmp	r3, r5
   2c7c6:	d109      	bne.n	2c7dc <settings_nvs_load+0x74>
				cf->last_name_id--;
   2c7c8:	4642      	mov	r2, r8
   2c7ca:	1e6b      	subs	r3, r5, #1
   2c7cc:	f822 3f38 	strh.w	r3, [r2, #56]!
				nvs_write(&cf->cf_nvs, NVS_NAMECNT_ID,
   2c7d0:	f44f 4100 	mov.w	r1, #32768	; 0x8000
   2c7d4:	2302      	movs	r3, #2
   2c7d6:	4630      	mov	r0, r6
   2c7d8:	f7fe ff1a 	bl	2b610 <nvs_write>
			nvs_delete(&cf->cf_nvs, name_id);
   2c7dc:	4629      	mov	r1, r5
   2c7de:	4630      	mov	r0, r6
   2c7e0:	f01c fec1 	bl	49566 <nvs_delete>
			nvs_delete(&cf->cf_nvs, name_id + NVS_NAME_ID_OFFSET);
   2c7e4:	4621      	mov	r1, r4
   2c7e6:	4630      	mov	r0, r6
   2c7e8:	f01c febd 	bl	49566 <nvs_delete>
			continue;
   2c7ec:	e7e4      	b.n	2c7b8 <settings_nvs_load+0x50>
		name[rc1] = '\0';
   2c7ee:	f107 0360 	add.w	r3, r7, #96	; 0x60
   2c7f2:	eb0d 0703 	add.w	r7, sp, r3
   2c7f6:	2300      	movs	r3, #0
   2c7f8:	f807 3c4c 	strb.w	r3, [r7, #-76]
		ret = settings_call_set_handler(
   2c7fc:	4652      	mov	r2, sl
   2c7fe:	f8cd 9000 	str.w	r9, [sp]
   2c802:	ab03      	add	r3, sp, #12
   2c804:	a805      	add	r0, sp, #20
		read_fn_arg.fs = &cf->cf_nvs;
   2c806:	9603      	str	r6, [sp, #12]
		read_fn_arg.id = name_id + NVS_NAME_ID_OFFSET;
   2c808:	f8ad 4010 	strh.w	r4, [sp, #16]
		ret = settings_call_set_handler(
   2c80c:	f01c ffbb 	bl	49786 <settings_call_set_handler>
			name, rc2,
			settings_nvs_read_fn, &read_fn_arg,
			(void *)arg);
		if (ret) {
   2c810:	2800      	cmp	r0, #0
   2c812:	d0d1      	beq.n	2c7b8 <settings_nvs_load+0x50>
			break;
		}
	}
	return ret;
}
   2c814:	b018      	add	sp, #96	; 0x60
   2c816:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2c81a:	2000      	movs	r0, #0
	return ret;
   2c81c:	e7fa      	b.n	2c814 <settings_nvs_load+0xac>
   2c81e:	bf00      	nop
   2c820:	000497f5 	.word	0x000497f5

0002c824 <settings_backend_init>:
	LOG_DBG("Initialized");
	return 0;
}

int settings_backend_init(void)
{
   2c824:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	int rc;
	uint16_t cnt = 0;
	size_t nvs_sector_size, nvs_size = 0;
	const struct flash_area *fa;
	struct flash_sector hw_flash_sector;
	uint32_t sector_cnt = 1;
   2c826:	2301      	movs	r3, #1

	rc = flash_area_open(SETTINGS_PARTITION, &fa);
   2c828:	4669      	mov	r1, sp
   2c82a:	2002      	movs	r0, #2
	uint32_t sector_cnt = 1;
   2c82c:	9301      	str	r3, [sp, #4]
	rc = flash_area_open(SETTINGS_PARTITION, &fa);
   2c82e:	f7ff fddd 	bl	2c3ec <flash_area_open>
	if (rc) {
   2c832:	4604      	mov	r4, r0
   2c834:	2800      	cmp	r0, #0
   2c836:	d134      	bne.n	2c8a2 <settings_backend_init+0x7e>
		return rc;
	}

	rc = flash_area_get_sectors(SETTINGS_PARTITION, &sector_cnt,
   2c838:	aa02      	add	r2, sp, #8
   2c83a:	a901      	add	r1, sp, #4
   2c83c:	2002      	movs	r0, #2
   2c83e:	f7ff fdfd 	bl	2c43c <flash_area_get_sectors>
				    &hw_flash_sector);
	if (rc == -ENODEV) {
   2c842:	f110 0f13 	cmn.w	r0, #19
	rc = flash_area_get_sectors(SETTINGS_PARTITION, &sector_cnt,
   2c846:	4604      	mov	r4, r0
	if (rc == -ENODEV) {
   2c848:	d02b      	beq.n	2c8a2 <settings_backend_init+0x7e>
		return rc;
	} else if (rc != 0 && rc != -ENOMEM) {
   2c84a:	b138      	cbz	r0, 2c85c <settings_backend_init+0x38>
   2c84c:	340c      	adds	r4, #12
   2c84e:	d005      	beq.n	2c85c <settings_backend_init+0x38>
		k_panic();
   2c850:	4040      	eors	r0, r0
   2c852:	f380 8811 	msr	BASEPRI, r0
   2c856:	f04f 0004 	mov.w	r0, #4
   2c85a:	df02      	svc	2
	}

	nvs_sector_size = CONFIG_SETTINGS_NVS_SECTOR_SIZE_MULT *
   2c85c:	9903      	ldr	r1, [sp, #12]
			  hw_flash_sector.fs_size;

	if (nvs_sector_size > UINT16_MAX) {
   2c85e:	f5b1 3f80 	cmp.w	r1, #65536	; 0x10000
   2c862:	d223      	bcs.n	2c8ac <settings_backend_init+0x88>
		return -EDOM;
	}

	while (cnt < CONFIG_SETTINGS_NVS_SECTOR_COUNT) {
		nvs_size += nvs_sector_size;
		if (nvs_size > fa->fa_size) {
   2c864:	9a00      	ldr	r2, [sp, #0]
   2c866:	2300      	movs	r3, #0
   2c868:	6894      	ldr	r4, [r2, #8]
	size_t nvs_sector_size, nvs_size = 0;
   2c86a:	4618      	mov	r0, r3
		nvs_size += nvs_sector_size;
   2c86c:	4408      	add	r0, r1
		if (nvs_size > fa->fa_size) {
   2c86e:	4284      	cmp	r4, r0
   2c870:	d31a      	bcc.n	2c8a8 <settings_backend_init+0x84>
	while (cnt < CONFIG_SETTINGS_NVS_SECTOR_COUNT) {
   2c872:	3301      	adds	r3, #1
   2c874:	2b08      	cmp	r3, #8
   2c876:	d1f9      	bne.n	2c86c <settings_backend_init+0x48>
		}
		cnt++;
	}

	/* define the nvs file system using the page_info */
	default_settings_nvs.cf_nvs.sector_size = nvs_sector_size;
   2c878:	4d0e      	ldr	r5, [pc, #56]	; (2c8b4 <settings_backend_init+0x90>)
   2c87a:	82a9      	strh	r1, [r5, #20]
	default_settings_nvs.cf_nvs.sector_count = cnt;
   2c87c:	82eb      	strh	r3, [r5, #22]
	default_settings_nvs.cf_nvs.offset = fa->fa_off;
   2c87e:	6853      	ldr	r3, [r2, #4]
   2c880:	60ab      	str	r3, [r5, #8]
	default_settings_nvs.flash_dev = fa->fa_dev;

	rc = settings_nvs_backend_init(&default_settings_nvs);
   2c882:	4628      	mov	r0, r5
	default_settings_nvs.flash_dev = fa->fa_dev;
   2c884:	68d3      	ldr	r3, [r2, #12]
   2c886:	63eb      	str	r3, [r5, #60]	; 0x3c
	rc = settings_nvs_backend_init(&default_settings_nvs);
   2c888:	f01d f84e 	bl	49928 <settings_nvs_backend_init>
	if (rc) {
   2c88c:	4604      	mov	r4, r0
   2c88e:	b940      	cbnz	r0, 2c8a2 <settings_backend_init+0x7e>
	cf->cf_store.cs_itf = &settings_nvs_itf;
   2c890:	4e09      	ldr	r6, [pc, #36]	; (2c8b8 <settings_backend_init+0x94>)
   2c892:	606e      	str	r6, [r5, #4]
	settings_src_register(&cf->cf_store);
   2c894:	4628      	mov	r0, r5
   2c896:	f7ff fe27 	bl	2c4e8 <settings_src_register>
	settings_dst_register(&cf->cf_store);
   2c89a:	4628      	mov	r0, r5
	cf->cf_store.cs_itf = &settings_nvs_itf;
   2c89c:	606e      	str	r6, [r5, #4]
	settings_dst_register(&cf->cf_store);
   2c89e:	f7ff fe31 	bl	2c504 <settings_dst_register>
	}

	rc = settings_nvs_dst(&default_settings_nvs);

	return rc;
}
   2c8a2:	4620      	mov	r0, r4
   2c8a4:	b004      	add	sp, #16
   2c8a6:	bd70      	pop	{r4, r5, r6, pc}
   2c8a8:	b29b      	uxth	r3, r3
   2c8aa:	e7e5      	b.n	2c878 <settings_backend_init+0x54>
		return -EDOM;
   2c8ac:	f06f 0420 	mvn.w	r4, #32
   2c8b0:	e7f7      	b.n	2c8a2 <settings_backend_init+0x7e>
   2c8b2:	bf00      	nop
   2c8b4:	20003b34 	.word	0x20003b34
   2c8b8:	200005b8 	.word	0x200005b8

0002c8bc <pm_state_notify>:
/*
 * Function called to notify when the system is entering / exiting a
 * power state
 */
static inline void pm_state_notify(bool entering_state)
{
   2c8bc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   2c8c0:	4605      	mov	r5, r0
	__asm__ volatile(
   2c8c2:	f04f 0320 	mov.w	r3, #32
   2c8c6:	f3ef 8611 	mrs	r6, BASEPRI
   2c8ca:	f383 8812 	msr	BASEPRI_MAX, r3
   2c8ce:	f3bf 8f6f 	isb	sy
	return list->head;
   2c8d2:	4b0e      	ldr	r3, [pc, #56]	; (2c90c <pm_state_notify+0x50>)
		} else {
			callback = notifier->state_exit;
		}

		if (callback) {
			callback(z_cpus_pm_state[_current_cpu->id].state);
   2c8d4:	4f0e      	ldr	r7, [pc, #56]	; (2c910 <pm_state_notify+0x54>)
   2c8d6:	681c      	ldr	r4, [r3, #0]
   2c8d8:	f8df 8038 	ldr.w	r8, [pc, #56]	; 2c914 <pm_state_notify+0x58>
   2c8dc:	f04f 090c 	mov.w	r9, #12
	SYS_SLIST_FOR_EACH_CONTAINER(&pm_notifiers, notifier, _node) {
   2c8e0:	b92c      	cbnz	r4, 2c8ee <pm_state_notify+0x32>
	__asm__ volatile(
   2c8e2:	f386 8811 	msr	BASEPRI, r6
   2c8e6:	f3bf 8f6f 	isb	sy
		}
	}
	k_spin_unlock(&pm_notifier_lock, pm_notifier_key);
}
   2c8ea:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			callback = notifier->state_exit;
   2c8ee:	e9d4 2301 	ldrd	r2, r3, [r4, #4]
			callback = notifier->state_entry;
   2c8f2:	2d00      	cmp	r5, #0
   2c8f4:	bf18      	it	ne
   2c8f6:	4613      	movne	r3, r2
		if (callback) {
   2c8f8:	b12b      	cbz	r3, 2c906 <pm_state_notify+0x4a>
			callback(z_cpus_pm_state[_current_cpu->id].state);
   2c8fa:	f898 2014 	ldrb.w	r2, [r8, #20]
   2c8fe:	fb09 f202 	mul.w	r2, r9, r2
   2c902:	5cb8      	ldrb	r0, [r7, r2]
   2c904:	4798      	blx	r3
	return node->next;
   2c906:	6824      	ldr	r4, [r4, #0]
   2c908:	e7ea      	b.n	2c8e0 <pm_state_notify+0x24>
   2c90a:	bf00      	nop
   2c90c:	20003b8c 	.word	0x20003b8c
   2c910:	20003b80 	.word	0x20003b80
   2c914:	2000694c 	.word	0x2000694c

0002c918 <pm_system_resume>:

void pm_system_resume(void)
{
   2c918:	b570      	push	{r4, r5, r6, lr}
	uint8_t id = CURRENT_CPU;
   2c91a:	4b19      	ldr	r3, [pc, #100]	; (2c980 <pm_system_resume+0x68>)
   2c91c:	7d1c      	ldrb	r4, [r3, #20]
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   2c91e:	f3bf 8f5b 	dmb	ish
	atomic_val_t mask = ATOMIC_MASK(bit);
   2c922:	f004 031f 	and.w	r3, r4, #31
   2c926:	2201      	movs	r2, #1
   2c928:	409a      	lsls	r2, r3
   2c92a:	4b16      	ldr	r3, [pc, #88]	; (2c984 <pm_system_resume+0x6c>)
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   2c92c:	0961      	lsrs	r1, r4, #5
   2c92e:	eb03 0381 	add.w	r3, r3, r1, lsl #2
   2c932:	43d0      	mvns	r0, r2
   2c934:	e853 1f00 	ldrex	r1, [r3]
   2c938:	ea01 0500 	and.w	r5, r1, r0
   2c93c:	e843 5600 	strex	r6, r5, [r3]
   2c940:	2e00      	cmp	r6, #0
   2c942:	d1f7      	bne.n	2c934 <pm_system_resume+0x1c>
   2c944:	f3bf 8f5b 	dmb	ish
	 * that caused the wake. This hook will be called from the ISR.
	 * For such CPU LPS states, do post operations and restores here.
	 * The kernel scheduler will get control after the ISR finishes
	 * and it may schedule another thread.
	 */
	if (atomic_test_and_clear_bit(z_post_ops_required, id)) {
   2c948:	420a      	tst	r2, r1
   2c94a:	d013      	beq.n	2c974 <pm_system_resume+0x5c>
	if (pm_state_exit_post_ops != NULL) {
   2c94c:	4b0e      	ldr	r3, [pc, #56]	; (2c988 <pm_system_resume+0x70>)
   2c94e:	4d0f      	ldr	r5, [pc, #60]	; (2c98c <pm_system_resume+0x74>)
   2c950:	b18b      	cbz	r3, 2c976 <pm_system_resume+0x5e>
		pm_state_exit_post_ops(info->state, info->substate_id);
   2c952:	230c      	movs	r3, #12
   2c954:	4363      	muls	r3, r4
   2c956:	18ea      	adds	r2, r5, r3
   2c958:	5ce8      	ldrb	r0, [r5, r3]
   2c95a:	7851      	ldrb	r1, [r2, #1]
   2c95c:	f01e faba 	bl	4aed4 <pm_state_exit_post_ops>
		pm_exit_pos_ops(&z_cpus_pm_state[id]);
		pm_state_notify(false);
   2c960:	2000      	movs	r0, #0
   2c962:	f7ff ffab 	bl	2c8bc <pm_state_notify>
		z_cpus_pm_state[id] = (struct pm_state_info){PM_STATE_ACTIVE,
   2c966:	230c      	movs	r3, #12
   2c968:	435c      	muls	r4, r3
   2c96a:	192a      	adds	r2, r5, r4
   2c96c:	2300      	movs	r3, #0
   2c96e:	512b      	str	r3, [r5, r4]
   2c970:	e9c2 3301 	strd	r3, r3, [r2, #4]
			0, 0};
	}
}
   2c974:	bd70      	pop	{r4, r5, r6, pc}
   2c976:	f383 8811 	msr	BASEPRI, r3
   2c97a:	f3bf 8f6f 	isb	sy
		"cpsie i;"
		: : : "memory", "cc");
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
}
   2c97e:	e7ef      	b.n	2c960 <pm_system_resume+0x48>
   2c980:	2000694c 	.word	0x2000694c
   2c984:	20003b94 	.word	0x20003b94
   2c988:	0004aed5 	.word	0x0004aed5
   2c98c:	20003b80 	.word	0x20003b80

0002c990 <pm_system_suspend>:

	return true;
}

bool pm_system_suspend(int32_t ticks)
{
   2c990:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint8_t id = CURRENT_CPU;
   2c994:	4b35      	ldr	r3, [pc, #212]	; (2ca6c <pm_system_suspend+0xdc>)
{
   2c996:	4607      	mov	r7, r0
	uint8_t id = CURRENT_CPU;
   2c998:	7d1d      	ldrb	r5, [r3, #20]
	__asm__ volatile(
   2c99a:	f04f 0320 	mov.w	r3, #32
   2c99e:	f3ef 8811 	mrs	r8, BASEPRI
   2c9a2:	f383 8812 	msr	BASEPRI_MAX, r3
   2c9a6:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key;

	SYS_PORT_TRACING_FUNC_ENTER(pm, system_suspend, ticks);

	key = k_spin_lock(&pm_forced_state_lock);
	if (z_cpus_pm_forced_state[id].state != PM_STATE_ACTIVE) {
   2c9aa:	240c      	movs	r4, #12
   2c9ac:	4b30      	ldr	r3, [pc, #192]	; (2ca70 <pm_system_suspend+0xe0>)
   2c9ae:	4e31      	ldr	r6, [pc, #196]	; (2ca74 <pm_system_suspend+0xe4>)
   2c9b0:	436c      	muls	r4, r5
   2c9b2:	191a      	adds	r2, r3, r4
   2c9b4:	5d19      	ldrb	r1, [r3, r4]
   2c9b6:	2900      	cmp	r1, #0
   2c9b8:	d04c      	beq.n	2ca54 <pm_system_suspend+0xc4>
		z_cpus_pm_state[id] = z_cpus_pm_forced_state[id];
   2c9ba:	ca07      	ldmia	r2, {r0, r1, r2}
   2c9bc:	eb06 0c04 	add.w	ip, r6, r4
   2c9c0:	e88c 0007 	stmia.w	ip, {r0, r1, r2}
		z_cpus_pm_forced_state[id].state = PM_STATE_ACTIVE;
   2c9c4:	2200      	movs	r2, #0
   2c9c6:	551a      	strb	r2, [r3, r4]
	__asm__ volatile(
   2c9c8:	f388 8811 	msr	BASEPRI, r8
   2c9cc:	f3bf 8f6f 	isb	sy
			z_cpus_pm_state[id] = *info;
		}
	}
	k_spin_unlock(&pm_forced_state_lock, key);

	if (z_cpus_pm_state[id].state == PM_STATE_ACTIVE) {
   2c9d0:	230c      	movs	r3, #12
   2c9d2:	436b      	muls	r3, r5
   2c9d4:	18f2      	adds	r2, r6, r3
   2c9d6:	5cf0      	ldrb	r0, [r6, r3]
   2c9d8:	2800      	cmp	r0, #0
   2c9da:	d039      	beq.n	2ca50 <pm_system_suspend+0xc0>
		SYS_PORT_TRACING_FUNC_EXIT(pm, system_suspend, ticks,
				   z_cpus_pm_state[id].state);
		return false;
	}

	if (ticks != K_TICKS_FOREVER) {
   2c9dc:	1c7b      	adds	r3, r7, #1
   2c9de:	d010      	beq.n	2ca02 <pm_system_suspend+0x72>
			return (uint32_t)((t * to_hz + off) / from_hz);
   2c9e0:	f8d2 c008 	ldr.w	ip, [r2, #8]
   2c9e4:	4c24      	ldr	r4, [pc, #144]	; (2ca78 <pm_system_suspend+0xe8>)
   2c9e6:	4a25      	ldr	r2, [pc, #148]	; (2ca7c <pm_system_suspend+0xec>)
   2c9e8:	f44f 4000 	mov.w	r0, #32768	; 0x8000
   2c9ec:	2100      	movs	r1, #0
   2c9ee:	fbec 4100 	umlal	r4, r1, ip, r0
   2c9f2:	2300      	movs	r3, #0
   2c9f4:	4620      	mov	r0, r4
   2c9f6:	f7f9 fb83 	bl	26100 <__aeabi_uldivmod>
		/*
		 * We need to set the timer to interrupt a little bit early to
		 * accommodate the time required by the CPU to fully wake up.
		 */
		z_set_timeout_expiry(ticks -
   2c9fa:	2101      	movs	r1, #1
   2c9fc:	1a38      	subs	r0, r7, r0
   2c9fe:	f023 fc8f 	bl	50320 <z_set_timeout_expiry>
	 * state. We don't want to be scheduled out yet, first we need
	 * to send a notification about leaving the idle state. So,
	 * we lock the scheduler here and unlock just after we have
	 * sent the notification in pm_system_resume().
	 */
	k_sched_lock();
   2ca02:	f01b f807 	bl	47a14 <k_sched_lock>
	pm_stats_start();
	/* Enter power state */
	pm_state_notify(true);
   2ca06:	2001      	movs	r0, #1
   2ca08:	f7ff ff58 	bl	2c8bc <pm_state_notify>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   2ca0c:	f3bf 8f5b 	dmb	ish
   2ca10:	4b1b      	ldr	r3, [pc, #108]	; (2ca80 <pm_system_suspend+0xf0>)
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
   2ca12:	096a      	lsrs	r2, r5, #5
   2ca14:	eb03 0382 	add.w	r3, r3, r2, lsl #2
	atomic_val_t mask = ATOMIC_MASK(bit);
   2ca18:	f005 011f 	and.w	r1, r5, #31
   2ca1c:	2201      	movs	r2, #1
   2ca1e:	408a      	lsls	r2, r1
   2ca20:	e853 0f00 	ldrex	r0, [r3]
   2ca24:	4310      	orrs	r0, r2
   2ca26:	e843 0100 	strex	r1, r0, [r3]
   2ca2a:	2900      	cmp	r1, #0
   2ca2c:	d1f8      	bne.n	2ca20 <pm_system_suspend+0x90>
   2ca2e:	f3bf 8f5b 	dmb	ish
	if (pm_state_set != NULL) {
   2ca32:	4b14      	ldr	r3, [pc, #80]	; (2ca84 <pm_system_suspend+0xf4>)
   2ca34:	b13b      	cbz	r3, 2ca46 <pm_system_suspend+0xb6>
		pm_state_set(info->state, info->substate_id);
   2ca36:	230c      	movs	r3, #12
   2ca38:	fb03 f005 	mul.w	r0, r3, r5
   2ca3c:	1833      	adds	r3, r6, r0
   2ca3e:	5c30      	ldrb	r0, [r6, r0]
   2ca40:	7859      	ldrb	r1, [r3, #1]
   2ca42:	f01e fa3b 	bl	4aebc <pm_state_set>
	if (atomic_add(&z_cpus_active, 1) == 0) {
		pm_resume_devices();
	}
#endif
	pm_stats_update(z_cpus_pm_state[id].state);
	pm_system_resume();
   2ca46:	f7ff ff67 	bl	2c918 <pm_system_resume>
	k_sched_unlock();
   2ca4a:	f01a fff7 	bl	47a3c <k_sched_unlock>
	SYS_PORT_TRACING_FUNC_EXIT(pm, system_suspend, ticks,
				   z_cpus_pm_state[id].state);

	return true;
   2ca4e:	2001      	movs	r0, #1
}
   2ca50:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		info = pm_policy_next_state(id, ticks);
   2ca54:	4601      	mov	r1, r0
   2ca56:	4628      	mov	r0, r5
   2ca58:	f000 f816 	bl	2ca88 <pm_policy_next_state>
		if (info != NULL) {
   2ca5c:	2800      	cmp	r0, #0
   2ca5e:	d0b3      	beq.n	2c9c8 <pm_system_suspend+0x38>
			z_cpus_pm_state[id] = *info;
   2ca60:	c807      	ldmia	r0, {r0, r1, r2}
   2ca62:	4434      	add	r4, r6
   2ca64:	e884 0007 	stmia.w	r4, {r0, r1, r2}
   2ca68:	e7ae      	b.n	2c9c8 <pm_system_suspend+0x38>
   2ca6a:	bf00      	nop
   2ca6c:	2000694c 	.word	0x2000694c
   2ca70:	20003b74 	.word	0x20003b74
   2ca74:	20003b80 	.word	0x20003b80
   2ca78:	000f423f 	.word	0x000f423f
   2ca7c:	000f4240 	.word	0x000f4240
   2ca80:	20003b94 	.word	0x20003b94
   2ca84:	0004aebd 	.word	0x0004aebd

0002ca88 <pm_policy_next_state>:
	}
}

#ifdef CONFIG_PM_POLICY_DEFAULT
const struct pm_state_info *pm_policy_next_state(uint8_t cpu, int32_t ticks)
{
   2ca88:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2ca8c:	b085      	sub	sp, #20
   2ca8e:	460e      	mov	r6, r1
	uint8_t num_cpu_states;
	const struct pm_state_info *cpu_states;

	num_cpu_states = pm_state_cpu_get_all(cpu, &cpu_states);
   2ca90:	a903      	add	r1, sp, #12
   2ca92:	f000 f843 	bl	2cb1c <pm_state_cpu_get_all>

		min_residency = k_us_to_ticks_ceil32(state->min_residency_us);
		exit_latency = k_us_to_ticks_ceil32(state->exit_latency_us);

		/* skip state if it brings too much latency */
		if ((max_latency_ticks != K_TICKS_FOREVER) &&
   2ca96:	4b1e      	ldr	r3, [pc, #120]	; (2cb10 <pm_policy_next_state+0x88>)
   2ca98:	9d03      	ldr	r5, [sp, #12]
   2ca9a:	f8d3 a000 	ldr.w	sl, [r3]
   2ca9e:	f8df 8074 	ldr.w	r8, [pc, #116]	; 2cb14 <pm_policy_next_state+0x8c>
	for (int16_t i = (int16_t)num_cpu_states - 1; i >= 0; i--) {
   2caa2:	1e43      	subs	r3, r0, #1
   2caa4:	b21b      	sxth	r3, r3
   2caa6:	eb03 0343 	add.w	r3, r3, r3, lsl #1
	num_cpu_states = pm_state_cpu_get_all(cpu, &cpu_states);
   2caaa:	4604      	mov	r4, r0
	for (int16_t i = (int16_t)num_cpu_states - 1; i >= 0; i--) {
   2caac:	eb05 0583 	add.w	r5, r5, r3, lsl #2
   2cab0:	f44f 4700 	mov.w	r7, #32768	; 0x8000
   2cab4:	f04f 0b00 	mov.w	fp, #0
   2cab8:	b924      	cbnz	r4, 2cac4 <pm_policy_next_state+0x3c>
		    (ticks >= (min_residency + exit_latency))) {
			return state;
		}
	}

	return NULL;
   2caba:	46a1      	mov	r9, r4
}
   2cabc:	4648      	mov	r0, r9
   2cabe:	b005      	add	sp, #20
   2cac0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2cac4:	6868      	ldr	r0, [r5, #4]
   2cac6:	4a14      	ldr	r2, [pc, #80]	; (2cb18 <pm_policy_next_state+0x90>)
   2cac8:	46c4      	mov	ip, r8
   2caca:	4659      	mov	r1, fp
   2cacc:	fbe0 c107 	umlal	ip, r1, r0, r7
   2cad0:	2300      	movs	r3, #0
   2cad2:	4660      	mov	r0, ip
   2cad4:	f7f9 fb14 	bl	26100 <__aeabi_uldivmod>
   2cad8:	9001      	str	r0, [sp, #4]
   2cada:	68a8      	ldr	r0, [r5, #8]
   2cadc:	4a0e      	ldr	r2, [pc, #56]	; (2cb18 <pm_policy_next_state+0x90>)
   2cade:	46c4      	mov	ip, r8
   2cae0:	4659      	mov	r1, fp
   2cae2:	fbe0 c107 	umlal	ip, r1, r0, r7
   2cae6:	2300      	movs	r3, #0
   2cae8:	4660      	mov	r0, ip
   2caea:	f7f9 fb09 	bl	26100 <__aeabi_uldivmod>
		if ((max_latency_ticks != K_TICKS_FOREVER) &&
   2caee:	f1ba 3fff 	cmp.w	sl, #4294967295	; 0xffffffff
		const struct pm_state_info *state = &cpu_states[i];
   2caf2:	46a9      	mov	r9, r5
		if ((max_latency_ticks != K_TICKS_FOREVER) &&
   2caf4:	d001      	beq.n	2cafa <pm_policy_next_state+0x72>
   2caf6:	4582      	cmp	sl, r0
   2caf8:	d905      	bls.n	2cb06 <pm_policy_next_state+0x7e>
		if ((ticks == K_TICKS_FOREVER) ||
   2cafa:	1c73      	adds	r3, r6, #1
   2cafc:	d0de      	beq.n	2cabc <pm_policy_next_state+0x34>
		    (ticks >= (min_residency + exit_latency))) {
   2cafe:	9b01      	ldr	r3, [sp, #4]
   2cb00:	4418      	add	r0, r3
		if ((ticks == K_TICKS_FOREVER) ||
   2cb02:	42b0      	cmp	r0, r6
   2cb04:	d9da      	bls.n	2cabc <pm_policy_next_state+0x34>
	for (int16_t i = (int16_t)num_cpu_states - 1; i >= 0; i--) {
   2cb06:	3c01      	subs	r4, #1
   2cb08:	b2a4      	uxth	r4, r4
   2cb0a:	3d0c      	subs	r5, #12
   2cb0c:	e7d4      	b.n	2cab8 <pm_policy_next_state+0x30>
   2cb0e:	bf00      	nop
   2cb10:	200005cc 	.word	0x200005cc
   2cb14:	000f423f 	.word	0x000f423f
   2cb18:	000f4240 	.word	0x000f4240

0002cb1c <pm_state_cpu_get_all>:
	DT_FOREACH_CHILD_SEP(DT_PATH(cpus), DT_NUM_CPU_POWER_STATES, (,))
};

uint8_t pm_state_cpu_get_all(uint8_t cpu, const struct pm_state_info **states)
{
	if (cpu >= ARRAY_SIZE(cpus_states)) {
   2cb1c:	b908      	cbnz	r0, 2cb22 <pm_state_cpu_get_all+0x6>
		return 0;
	}

	*states = cpus_states[cpu];
   2cb1e:	4b02      	ldr	r3, [pc, #8]	; (2cb28 <pm_state_cpu_get_all+0xc>)
   2cb20:	600b      	str	r3, [r1, #0]

	return states_per_cpu[cpu];
}
   2cb22:	2000      	movs	r0, #0
   2cb24:	4770      	bx	lr
   2cb26:	bf00      	nop
   2cb28:	00051b74 	.word	0x00051b74

0002cb2c <uECC_get_rng>:
}

uECC_RNG_Function uECC_get_rng(void)
{
	return g_rng_function;
}
   2cb2c:	4b01      	ldr	r3, [pc, #4]	; (2cb34 <uECC_get_rng+0x8>)
   2cb2e:	6818      	ldr	r0, [r3, #0]
   2cb30:	4770      	bx	lr
   2cb32:	bf00      	nop
   2cb34:	200005d0 	.word	0x200005d0

0002cb38 <vli_mmod_fast_secp256r1>:
{
	return &curve_secp256r1;
}

void vli_mmod_fast_secp256r1(unsigned int *result, unsigned int*product)
{
   2cb38:	b5f0      	push	{r4, r5, r6, r7, lr}
	unsigned int tmp[NUM_ECC_WORDS];
	int carry;

	/* t */
	uECC_vli_set(result, product, NUM_ECC_WORDS);
   2cb3a:	2208      	movs	r2, #8
{
   2cb3c:	b089      	sub	sp, #36	; 0x24
	uECC_vli_set(result, product, NUM_ECC_WORDS);
   2cb3e:	f01d f8ca 	bl	49cd6 <uECC_vli_set>

	/* s1 */
	tmp[0] = tmp[1] = tmp[2] = 0;
	tmp[3] = product[11];
   2cb42:	6acb      	ldr	r3, [r1, #44]	; 0x2c
   2cb44:	9303      	str	r3, [sp, #12]
	tmp[4] = product[12];
   2cb46:	6b0b      	ldr	r3, [r1, #48]	; 0x30
   2cb48:	9304      	str	r3, [sp, #16]
	tmp[5] = product[13];
   2cb4a:	6b4b      	ldr	r3, [r1, #52]	; 0x34
   2cb4c:	9305      	str	r3, [sp, #20]
	tmp[6] = product[14];
   2cb4e:	6b8b      	ldr	r3, [r1, #56]	; 0x38
   2cb50:	9306      	str	r3, [sp, #24]
	tmp[7] = product[15];
   2cb52:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
   2cb54:	9307      	str	r3, [sp, #28]
	carry = uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
   2cb56:	4613      	mov	r3, r2
   2cb58:	466a      	mov	r2, sp
{
   2cb5a:	460c      	mov	r4, r1
   2cb5c:	4606      	mov	r6, r0
	tmp[0] = tmp[1] = tmp[2] = 0;
   2cb5e:	2700      	movs	r7, #0
	carry = uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
   2cb60:	4611      	mov	r1, r2
   2cb62:	4610      	mov	r0, r2
	tmp[0] = tmp[1] = tmp[2] = 0;
   2cb64:	e9cd 7701 	strd	r7, r7, [sp, #4]
   2cb68:	9700      	str	r7, [sp, #0]
	carry = uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
   2cb6a:	f01c ffc2 	bl	49af2 <uECC_vli_add>
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
   2cb6e:	4631      	mov	r1, r6
	carry = uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
   2cb70:	4605      	mov	r5, r0
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
   2cb72:	4630      	mov	r0, r6
   2cb74:	f01c ffbd 	bl	49af2 <uECC_vli_add>

	/* s2 */
	tmp[3] = product[12];
   2cb78:	6b21      	ldr	r1, [r4, #48]	; 0x30
   2cb7a:	9103      	str	r1, [sp, #12]
	tmp[4] = product[13];
   2cb7c:	6b61      	ldr	r1, [r4, #52]	; 0x34
   2cb7e:	9104      	str	r1, [sp, #16]
	tmp[5] = product[14];
   2cb80:	6ba1      	ldr	r1, [r4, #56]	; 0x38
   2cb82:	9105      	str	r1, [sp, #20]
	tmp[6] = product[15];
   2cb84:	6be1      	ldr	r1, [r4, #60]	; 0x3c
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
   2cb86:	4405      	add	r5, r0
	tmp[7] = 0;
   2cb88:	e9cd 1706 	strd	r1, r7, [sp, #24]
	carry += uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
   2cb8c:	4610      	mov	r0, r2
   2cb8e:	4611      	mov	r1, r2
   2cb90:	f01c ffaf 	bl	49af2 <uECC_vli_add>
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
   2cb94:	4631      	mov	r1, r6
	carry += uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
   2cb96:	4405      	add	r5, r0
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
   2cb98:	4630      	mov	r0, r6
   2cb9a:	f01c ffaa 	bl	49af2 <uECC_vli_add>
   2cb9e:	4405      	add	r5, r0

	/* s3 */
	tmp[0] = product[8];
   2cba0:	6a20      	ldr	r0, [r4, #32]
   2cba2:	9000      	str	r0, [sp, #0]
	tmp[1] = product[9];
   2cba4:	6a60      	ldr	r0, [r4, #36]	; 0x24
   2cba6:	9001      	str	r0, [sp, #4]
	tmp[2] = product[10];
   2cba8:	6aa0      	ldr	r0, [r4, #40]	; 0x28
   2cbaa:	9002      	str	r0, [sp, #8]
	tmp[3] = tmp[4] = tmp[5] = 0;
	tmp[6] = product[14];
   2cbac:	6ba0      	ldr	r0, [r4, #56]	; 0x38
   2cbae:	9006      	str	r0, [sp, #24]
	tmp[7] = product[15];
   2cbb0:	6be0      	ldr	r0, [r4, #60]	; 0x3c
   2cbb2:	9007      	str	r0, [sp, #28]
  	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
   2cbb4:	4630      	mov	r0, r6
	tmp[3] = tmp[4] = tmp[5] = 0;
   2cbb6:	e9cd 7704 	strd	r7, r7, [sp, #16]
   2cbba:	9703      	str	r7, [sp, #12]
  	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
   2cbbc:	f01c ff99 	bl	49af2 <uECC_vli_add>
   2cbc0:	4405      	add	r5, r0

	/* s4 */
	tmp[0] = product[9];
   2cbc2:	6a60      	ldr	r0, [r4, #36]	; 0x24
   2cbc4:	9000      	str	r0, [sp, #0]
	tmp[1] = product[10];
   2cbc6:	6aa0      	ldr	r0, [r4, #40]	; 0x28
	tmp[2] = product[11];
	tmp[3] = product[13];
	tmp[4] = product[14];
   2cbc8:	f8d4 c038 	ldr.w	ip, [r4, #56]	; 0x38
	tmp[1] = product[10];
   2cbcc:	9001      	str	r0, [sp, #4]
	tmp[2] = product[11];
   2cbce:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   2cbd0:	9002      	str	r0, [sp, #8]
	tmp[4] = product[14];
   2cbd2:	f8cd c010 	str.w	ip, [sp, #16]
	tmp[3] = product[13];
   2cbd6:	6b60      	ldr	r0, [r4, #52]	; 0x34
	tmp[5] = product[15];
   2cbd8:	f8d4 c03c 	ldr.w	ip, [r4, #60]	; 0x3c
	tmp[3] = product[13];
   2cbdc:	9003      	str	r0, [sp, #12]
	tmp[6] = product[13];
   2cbde:	e9cd c005 	strd	ip, r0, [sp, #20]
	tmp[7] = product[8];
   2cbe2:	6a20      	ldr	r0, [r4, #32]
   2cbe4:	9007      	str	r0, [sp, #28]
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
   2cbe6:	4630      	mov	r0, r6
   2cbe8:	f01c ff83 	bl	49af2 <uECC_vli_add>
   2cbec:	4405      	add	r5, r0

	/* d1 */
	tmp[0] = product[11];
   2cbee:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   2cbf0:	9000      	str	r0, [sp, #0]
	tmp[1] = product[12];
   2cbf2:	6b20      	ldr	r0, [r4, #48]	; 0x30
   2cbf4:	9001      	str	r0, [sp, #4]
	tmp[2] = product[13];
   2cbf6:	6b60      	ldr	r0, [r4, #52]	; 0x34
   2cbf8:	9002      	str	r0, [sp, #8]
	tmp[3] = tmp[4] = tmp[5] = 0;
	tmp[6] = product[8];
   2cbfa:	6a20      	ldr	r0, [r4, #32]
   2cbfc:	9006      	str	r0, [sp, #24]
	tmp[7] = product[10];
   2cbfe:	6aa0      	ldr	r0, [r4, #40]	; 0x28
   2cc00:	9007      	str	r0, [sp, #28]
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
   2cc02:	4630      	mov	r0, r6
	tmp[3] = tmp[4] = tmp[5] = 0;
   2cc04:	e9cd 7704 	strd	r7, r7, [sp, #16]
   2cc08:	9703      	str	r7, [sp, #12]
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
   2cc0a:	f01d f897 	bl	49d3c <uECC_vli_sub>

	/* d2 */
	tmp[0] = product[12];
   2cc0e:	6b23      	ldr	r3, [r4, #48]	; 0x30
   2cc10:	9300      	str	r3, [sp, #0]
	tmp[1] = product[13];
   2cc12:	6b63      	ldr	r3, [r4, #52]	; 0x34
   2cc14:	9301      	str	r3, [sp, #4]
	tmp[2] = product[14];
   2cc16:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   2cc18:	9302      	str	r3, [sp, #8]
	tmp[3] = product[15];
   2cc1a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   2cc1c:	9303      	str	r3, [sp, #12]
	tmp[4] = tmp[5] = 0;
	tmp[6] = product[9];
   2cc1e:	6a63      	ldr	r3, [r4, #36]	; 0x24
   2cc20:	9306      	str	r3, [sp, #24]
	tmp[7] = product[11];
   2cc22:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   2cc24:	9307      	str	r3, [sp, #28]
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
   2cc26:	1a2d      	subs	r5, r5, r0
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
   2cc28:	2308      	movs	r3, #8
   2cc2a:	4630      	mov	r0, r6
   2cc2c:	f01d f886 	bl	49d3c <uECC_vli_sub>

	/* d3 */
	tmp[0] = product[13];
   2cc30:	6b63      	ldr	r3, [r4, #52]	; 0x34
   2cc32:	9300      	str	r3, [sp, #0]
	tmp[1] = product[14];
   2cc34:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   2cc36:	9301      	str	r3, [sp, #4]
	tmp[2] = product[15];
   2cc38:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   2cc3a:	9302      	str	r3, [sp, #8]
	tmp[3] = product[8];
   2cc3c:	6a23      	ldr	r3, [r4, #32]
   2cc3e:	9303      	str	r3, [sp, #12]
	tmp[4] = product[9];
   2cc40:	6a63      	ldr	r3, [r4, #36]	; 0x24
   2cc42:	9304      	str	r3, [sp, #16]
	tmp[5] = product[10];
   2cc44:	6aa3      	ldr	r3, [r4, #40]	; 0x28
	tmp[6] = 0;
   2cc46:	e9cd 3705 	strd	r3, r7, [sp, #20]
	tmp[7] = product[12];
   2cc4a:	6b23      	ldr	r3, [r4, #48]	; 0x30
   2cc4c:	9307      	str	r3, [sp, #28]
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
   2cc4e:	1a2d      	subs	r5, r5, r0
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
   2cc50:	2308      	movs	r3, #8
   2cc52:	4630      	mov	r0, r6
   2cc54:	f01d f872 	bl	49d3c <uECC_vli_sub>

	/* d4 */
	tmp[0] = product[14];
   2cc58:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   2cc5a:	9300      	str	r3, [sp, #0]
	tmp[1] = product[15];
   2cc5c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
	tmp[2] = 0;
   2cc5e:	e9cd 3701 	strd	r3, r7, [sp, #4]
	tmp[3] = product[9];
   2cc62:	6a63      	ldr	r3, [r4, #36]	; 0x24
   2cc64:	9303      	str	r3, [sp, #12]
	tmp[4] = product[10];
   2cc66:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   2cc68:	9304      	str	r3, [sp, #16]
	tmp[5] = product[11];
   2cc6a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   2cc6c:	9305      	str	r3, [sp, #20]
	tmp[6] = 0;
	tmp[7] = product[13];
   2cc6e:	6b63      	ldr	r3, [r4, #52]	; 0x34
   2cc70:	9307      	str	r3, [sp, #28]
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
   2cc72:	1a2d      	subs	r5, r5, r0
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
   2cc74:	2308      	movs	r3, #8
   2cc76:	4630      	mov	r0, r6
   2cc78:	f01d f860 	bl	49d3c <uECC_vli_sub>

	if (carry < 0) {
   2cc7c:	1a2d      	subs	r5, r5, r0
   2cc7e:	d410      	bmi.n	2cca2 <vli_mmod_fast_secp256r1+0x16a>
			carry += uECC_vli_add(result, result, curve_secp256r1.p, NUM_ECC_WORDS);
		}
		while (carry < 0);
	} else  {
		while (carry || 
		       uECC_vli_cmp_unsafe(curve_secp256r1.p, result, NUM_ECC_WORDS) != 1) {
   2cc80:	4c0d      	ldr	r4, [pc, #52]	; (2ccb8 <vli_mmod_fast_secp256r1+0x180>)
		while (carry || 
   2cc82:	b935      	cbnz	r5, 2cc92 <vli_mmod_fast_secp256r1+0x15a>
		       uECC_vli_cmp_unsafe(curve_secp256r1.p, result, NUM_ECC_WORDS) != 1) {
   2cc84:	2208      	movs	r2, #8
   2cc86:	4631      	mov	r1, r6
   2cc88:	4620      	mov	r0, r4
   2cc8a:	f01d f830 	bl	49cee <uECC_vli_cmp_unsafe>
		while (carry || 
   2cc8e:	2801      	cmp	r0, #1
   2cc90:	d00f      	beq.n	2ccb2 <vli_mmod_fast_secp256r1+0x17a>
			carry -= uECC_vli_sub(result, result, curve_secp256r1.p, NUM_ECC_WORDS);
   2cc92:	2308      	movs	r3, #8
   2cc94:	4622      	mov	r2, r4
   2cc96:	4631      	mov	r1, r6
   2cc98:	4630      	mov	r0, r6
   2cc9a:	f01d f84f 	bl	49d3c <uECC_vli_sub>
   2cc9e:	1a2d      	subs	r5, r5, r0
   2cca0:	e7ef      	b.n	2cc82 <vli_mmod_fast_secp256r1+0x14a>
			carry += uECC_vli_add(result, result, curve_secp256r1.p, NUM_ECC_WORDS);
   2cca2:	4a05      	ldr	r2, [pc, #20]	; (2ccb8 <vli_mmod_fast_secp256r1+0x180>)
   2cca4:	2308      	movs	r3, #8
   2cca6:	4631      	mov	r1, r6
   2cca8:	4630      	mov	r0, r6
   2ccaa:	f01c ff22 	bl	49af2 <uECC_vli_add>
		while (carry < 0);
   2ccae:	182d      	adds	r5, r5, r0
   2ccb0:	d4f8      	bmi.n	2cca4 <vli_mmod_fast_secp256r1+0x16c>
		}
	}
}
   2ccb2:	b009      	add	sp, #36	; 0x24
   2ccb4:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2ccb6:	bf00      	nop
   2ccb8:	00051b78 	.word	0x00051b78

0002ccbc <sub_bytes>:
static inline void sub_bytes(uint8_t *s)
{
	unsigned int i;

	for (i = 0; i < (Nb * Nk); ++i) {
		s[i] = sbox[s[i]];
   2ccbc:	4904      	ldr	r1, [pc, #16]	; (2ccd0 <sub_bytes+0x14>)
   2ccbe:	1e43      	subs	r3, r0, #1
   2ccc0:	300f      	adds	r0, #15
   2ccc2:	f813 2f01 	ldrb.w	r2, [r3, #1]!
   2ccc6:	5c8a      	ldrb	r2, [r1, r2]
   2ccc8:	701a      	strb	r2, [r3, #0]
	for (i = 0; i < (Nb * Nk); ++i) {
   2ccca:	4283      	cmp	r3, r0
   2cccc:	d1f9      	bne.n	2ccc2 <sub_bytes+0x6>
	}
}
   2ccce:	4770      	bx	lr
   2ccd0:	00053401 	.word	0x00053401

0002ccd4 <tc_aes128_set_encrypt_key>:
{
   2ccd4:	b5f0      	push	{r4, r5, r6, r7, lr}
	const unsigned int rconst[11] = {
   2ccd6:	4e26      	ldr	r6, [pc, #152]	; (2cd70 <tc_aes128_set_encrypt_key+0x9c>)
{
   2ccd8:	4607      	mov	r7, r0
   2ccda:	460c      	mov	r4, r1
	const unsigned int rconst[11] = {
   2ccdc:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
{
   2ccde:	b08d      	sub	sp, #52	; 0x34
	const unsigned int rconst[11] = {
   2cce0:	ad01      	add	r5, sp, #4
   2cce2:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   2cce4:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
   2cce6:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   2cce8:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
   2ccec:	e885 0007 	stmia.w	r5, {r0, r1, r2}
	if (s == (TCAesKeySched_t) 0) {
   2ccf0:	4638      	mov	r0, r7
   2ccf2:	2f00      	cmp	r7, #0
   2ccf4:	d038      	beq.n	2cd68 <tc_aes128_set_encrypt_key+0x94>
	} else if (k == (const uint8_t *) 0) {
   2ccf6:	2c00      	cmp	r4, #0
   2ccf8:	d038      	beq.n	2cd6c <tc_aes128_set_encrypt_key+0x98>
   2ccfa:	1f38      	subs	r0, r7, #4
   2ccfc:	4621      	mov	r1, r4
   2ccfe:	4602      	mov	r2, r0
   2cd00:	3410      	adds	r4, #16
		s->words[i] = (k[Nb*i]<<24) | (k[Nb*i+1]<<16) |
   2cd02:	784b      	ldrb	r3, [r1, #1]
   2cd04:	780d      	ldrb	r5, [r1, #0]
   2cd06:	041b      	lsls	r3, r3, #16
			      (k[Nb*i+2]<<8) | (k[Nb*i+3]);
   2cd08:	ea43 6305 	orr.w	r3, r3, r5, lsl #24
   2cd0c:	78cd      	ldrb	r5, [r1, #3]
   2cd0e:	432b      	orrs	r3, r5
   2cd10:	788d      	ldrb	r5, [r1, #2]
	for (i = 0; i < Nk; ++i) {
   2cd12:	3104      	adds	r1, #4
			      (k[Nb*i+2]<<8) | (k[Nb*i+3]);
   2cd14:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
	for (i = 0; i < Nk; ++i) {
   2cd18:	428c      	cmp	r4, r1
		s->words[i] = (k[Nb*i]<<24) | (k[Nb*i+1]<<16) |
   2cd1a:	f842 3f04 	str.w	r3, [r2, #4]!
	for (i = 0; i < Nk; ++i) {
   2cd1e:	d1f0      	bne.n	2cd02 <tc_aes128_set_encrypt_key+0x2e>
			t = subword(rotword(t)) ^ rconst[i/Nk];
   2cd20:	4c14      	ldr	r4, [pc, #80]	; (2cd74 <tc_aes128_set_encrypt_key+0xa0>)
   2cd22:	2104      	movs	r1, #4
		if ((i % Nk) == 0) {
   2cd24:	078a      	lsls	r2, r1, #30
		t = s->words[i-1];
   2cd26:	6903      	ldr	r3, [r0, #16]
		if ((i % Nk) == 0) {
   2cd28:	d116      	bne.n	2cd58 <tc_aes128_set_encrypt_key+0x84>
			t = subword(rotword(t)) ^ rconst[i/Nk];
   2cd2a:	f3c3 4207 	ubfx	r2, r3, #16, #8
   2cd2e:	5ca5      	ldrb	r5, [r4, r2]
   2cd30:	0e1a      	lsrs	r2, r3, #24
   2cd32:	5ca2      	ldrb	r2, [r4, r2]
   2cd34:	ea42 6205 	orr.w	r2, r2, r5, lsl #24
   2cd38:	f3c3 2507 	ubfx	r5, r3, #8, #8
   2cd3c:	b2db      	uxtb	r3, r3
   2cd3e:	5d65      	ldrb	r5, [r4, r5]
   2cd40:	5ce3      	ldrb	r3, [r4, r3]
   2cd42:	ea42 4205 	orr.w	r2, r2, r5, lsl #16
   2cd46:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
   2cd4a:	f021 0303 	bic.w	r3, r1, #3
   2cd4e:	3330      	adds	r3, #48	; 0x30
   2cd50:	446b      	add	r3, sp
   2cd52:	f853 3c2c 	ldr.w	r3, [r3, #-44]
   2cd56:	4053      	eors	r3, r2
		s->words[i] = s->words[i-Nk] ^ t;
   2cd58:	f850 2f04 	ldr.w	r2, [r0, #4]!
	for (; i < (Nb * (Nr + 1)); ++i) {
   2cd5c:	3101      	adds	r1, #1
		s->words[i] = s->words[i-Nk] ^ t;
   2cd5e:	4053      	eors	r3, r2
	for (; i < (Nb * (Nr + 1)); ++i) {
   2cd60:	292c      	cmp	r1, #44	; 0x2c
		s->words[i] = s->words[i-Nk] ^ t;
   2cd62:	6103      	str	r3, [r0, #16]
	for (; i < (Nb * (Nr + 1)); ++i) {
   2cd64:	d1de      	bne.n	2cd24 <tc_aes128_set_encrypt_key+0x50>
	return TC_CRYPTO_SUCCESS;
   2cd66:	2001      	movs	r0, #1
}
   2cd68:	b00d      	add	sp, #52	; 0x34
   2cd6a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return TC_CRYPTO_FAIL;
   2cd6c:	4620      	mov	r0, r4
   2cd6e:	e7fb      	b.n	2cd68 <tc_aes128_set_encrypt_key+0x94>
   2cd70:	00050da4 	.word	0x00050da4
   2cd74:	00053401 	.word	0x00053401

0002cd78 <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr	r1, =_SCB_SCR
   2cd78:	4901      	ldr	r1, [pc, #4]	; (2cd80 <z_arm_cpu_idle_init+0x8>)
	movs.n	r2, #_SCR_INIT_BITS
   2cd7a:	2210      	movs	r2, #16
	str	r2, [r1]
   2cd7c:	600a      	str	r2, [r1, #0]
#endif
	bx	lr
   2cd7e:	4770      	bx	lr
	ldr	r1, =_SCB_SCR
   2cd80:	e000ed10 	.word	0xe000ed10

0002cd84 <arch_cpu_idle>:
	 * before entering low power state.
	 *
	 * Set PRIMASK before configuring BASEPRI to prevent interruption
	 * before wake-up.
	 */
	cpsid	i
   2cd84:	b672      	cpsid	i

	/*
	 * Set wake-up interrupt priority to the lowest and synchronise to
	 * ensure that this is visible to the WFI instruction.
	 */
	eors.n	r0, r0
   2cd86:	4040      	eors	r0, r0
	msr	BASEPRI, r0
   2cd88:	f380 8811 	msr	BASEPRI, r0
	isb
   2cd8c:	f3bf 8f6f 	isb	sy

	/*
	 * Wait for all memory transactions to complete before entering low
	 * power state.
	 */
	dsb
   2cd90:	f3bf 8f4f 	dsb	sy

	/* Enter low power state */
	wfi
   2cd94:	bf30      	wfi

	/*
	 * Clear PRIMASK and flush instruction buffer to immediately service
	 * the wake-up interrupt.
	 */
	cpsie	i
   2cd96:	b662      	cpsie	i
	isb
   2cd98:	f3bf 8f6f 	isb	sy

	bx	lr
   2cd9c:	4770      	bx	lr
   2cd9e:	bf00      	nop

0002cda0 <arch_cpu_atomic_idle>:

	/*
	 * Lock PRIMASK while sleeping: wfe will still get interrupted by
	 * incoming interrupts but the CPU will not service them right away.
	 */
	cpsid	i
   2cda0:	b672      	cpsid	i
	cpsie	i
_irq_disabled:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* r1: zero, for setting BASEPRI (needs a register) */
	eors.n	r1, r1
   2cda2:	4049      	eors	r1, r1

	/* unlock BASEPRI so wfe gets interrupted by incoming interrupts */
	msr	BASEPRI, r1
   2cda4:	f381 8811 	msr	BASEPRI, r1

	wfe
   2cda8:	bf20      	wfe

	msr	BASEPRI, r0
   2cdaa:	f380 8811 	msr	BASEPRI, r0
	cpsie	i
   2cdae:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	bx	lr
   2cdb0:	4770      	bx	lr
   2cdb2:	bf00      	nop

0002cdb4 <arch_irq_enable>:
#define REG_FROM_IRQ(irq) (irq / NUM_IRQS_PER_REG)
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
   2cdb4:	b240      	sxtb	r0, r0
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
   2cdb6:	2800      	cmp	r0, #0
   2cdb8:	db07      	blt.n	2cdca <arch_irq_enable+0x16>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   2cdba:	4a04      	ldr	r2, [pc, #16]	; (2cdcc <arch_irq_enable+0x18>)
   2cdbc:	0941      	lsrs	r1, r0, #5
   2cdbe:	2301      	movs	r3, #1
   2cdc0:	f000 001f 	and.w	r0, r0, #31
   2cdc4:	4083      	lsls	r3, r0
   2cdc6:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
}
   2cdca:	4770      	bx	lr
   2cdcc:	e000e100 	.word	0xe000e100

0002cdd0 <arch_irq_disable>:

void arch_irq_disable(unsigned int irq)
{
	NVIC_DisableIRQ((IRQn_Type)irq);
   2cdd0:	b240      	sxtb	r0, r0
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
   2cdd2:	2800      	cmp	r0, #0
   2cdd4:	db0c      	blt.n	2cdf0 <arch_irq_disable+0x20>
  {
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   2cdd6:	0943      	lsrs	r3, r0, #5
   2cdd8:	4906      	ldr	r1, [pc, #24]	; (2cdf4 <arch_irq_disable+0x24>)
   2cdda:	f000 001f 	and.w	r0, r0, #31
   2cdde:	3320      	adds	r3, #32
   2cde0:	2201      	movs	r2, #1
   2cde2:	4082      	lsls	r2, r0
   2cde4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
   2cde8:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   2cdec:	f3bf 8f6f 	isb	sy
}
   2cdf0:	4770      	bx	lr
   2cdf2:	bf00      	nop
   2cdf4:	e000e100 	.word	0xe000e100

0002cdf8 <arch_irq_is_enabled>:

int arch_irq_is_enabled(unsigned int irq)
{
	return NVIC->ISER[REG_FROM_IRQ(irq)] & BIT(BIT_FROM_IRQ(irq));
   2cdf8:	4b05      	ldr	r3, [pc, #20]	; (2ce10 <arch_irq_is_enabled+0x18>)
   2cdfa:	0942      	lsrs	r2, r0, #5
   2cdfc:	f000 001f 	and.w	r0, r0, #31
   2ce00:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
   2ce04:	2301      	movs	r3, #1
   2ce06:	fa03 f000 	lsl.w	r0, r3, r0
}
   2ce0a:	4010      	ands	r0, r2
   2ce0c:	4770      	bx	lr
   2ce0e:	bf00      	nop
   2ce10:	e000e100 	.word	0xe000e100

0002ce14 <z_arm_irq_priority_set>:
	 */
	__ASSERT(prio <= (BIT(NUM_IRQ_PRIO_BITS) - 1),
		 "invalid priority %d for %d irq! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET, irq,
		 BIT(NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
   2ce14:	b240      	sxtb	r0, r0
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
   2ce16:	2800      	cmp	r0, #0
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   2ce18:	bfa8      	it	ge
   2ce1a:	f100 4060 	addge.w	r0, r0, #3758096384	; 0xe0000000
		prio += _IRQ_PRIO_OFFSET;
   2ce1e:	f101 0101 	add.w	r1, r1, #1
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   2ce22:	bfb8      	it	lt
   2ce24:	4b06      	ldrlt	r3, [pc, #24]	; (2ce40 <z_arm_irq_priority_set+0x2c>)
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   2ce26:	ea4f 1141 	mov.w	r1, r1, lsl #5
   2ce2a:	bfac      	ite	ge
   2ce2c:	f500 4061 	addge.w	r0, r0, #57600	; 0xe100
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   2ce30:	f000 000f 	andlt.w	r0, r0, #15
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   2ce34:	b2c9      	uxtb	r1, r1
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   2ce36:	bfb4      	ite	lt
   2ce38:	5419      	strblt	r1, [r3, r0]
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   2ce3a:	f880 1300 	strbge.w	r1, [r0, #768]	; 0x300
}
   2ce3e:	4770      	bx	lr
   2ce40:	e000ed14 	.word	0xe000ed14

0002ce44 <_arch_isr_direct_pm>:
	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
}

#ifdef CONFIG_PM
void _arch_isr_direct_pm(void)
{
   2ce44:	b508      	push	{r3, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Lock all interrupts. irq_lock() will on this CPU only disable those
	 * lower than BASEPRI, which is not what we want. See comments in
	 * arch/arm/core/aarch32/isr_wrapper.S
	 */
	__asm__ volatile("cpsid i" : : : "memory");
   2ce46:	b672      	cpsid	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	if (_kernel.idle) {
   2ce48:	4b04      	ldr	r3, [pc, #16]	; (2ce5c <_arch_isr_direct_pm+0x18>)
   2ce4a:	699a      	ldr	r2, [r3, #24]
   2ce4c:	b11a      	cbz	r2, 2ce56 <_arch_isr_direct_pm+0x12>
		_kernel.idle = 0;
   2ce4e:	2200      	movs	r2, #0
   2ce50:	619a      	str	r2, [r3, #24]
		z_pm_save_idle_exit();
   2ce52:	f022 ff09 	bl	4fc68 <z_pm_save_idle_exit>
	|| defined(CONFIG_ARMV7_R) \
	|| defined(CONFIG_AARCH32_ARMV8_R) \
	|| defined(CONFIG_ARMV7_A)
	irq_unlock(key);
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile("cpsie i" : : : "memory");
   2ce56:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

}
   2ce58:	bd08      	pop	{r3, pc}
   2ce5a:	bf00      	nop
   2ce5c:	2000694c 	.word	0x2000694c

0002ce60 <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
   2ce60:	bf30      	wfi
    b z_SysNmiOnReset
   2ce62:	f7ff bffd 	b.w	2ce60 <z_SysNmiOnReset>
   2ce66:	bf00      	nop

0002ce68 <z_arm_prep_c>:

#define VECTOR_ADDRESS ((uintptr_t)_vector_start)

static inline void relocate_vector_table(void)
{
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
   2ce68:	4a0f      	ldr	r2, [pc, #60]	; (2cea8 <z_arm_prep_c+0x40>)
 *
 * This routine prepares for the execution of and runs C code.
 *
 */
void z_arm_prep_c(void)
{
   2ce6a:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
   2ce6c:	4b0f      	ldr	r3, [pc, #60]	; (2ceac <z_arm_prep_c+0x44>)
   2ce6e:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
   2ce72:	609a      	str	r2, [r3, #8]
  __ASM volatile ("dsb 0xF":::"memory");
   2ce74:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   2ce78:	f3bf 8f6f 	isb	sy
	SCB->CPACR &= (~(CPACR_CP10_Msk | CPACR_CP11_Msk));
   2ce7c:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
   2ce80:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
   2ce84:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
 */
__STATIC_FORCEINLINE uint32_t __get_CONTROL(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, control" : "=r" (result) );
   2ce88:	f3ef 8314 	mrs	r3, CONTROL
	__set_CONTROL(__get_CONTROL() & (~(CONTROL_FPCA_Msk)));
   2ce8c:	f023 0304 	bic.w	r3, r3, #4
  \details Writes the given value to the Control Register.
  \param [in]    control  Control Register value to set
 */
__STATIC_FORCEINLINE void __set_CONTROL(uint32_t control)
{
  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
   2ce90:	f383 8814 	msr	CONTROL, r3
  __ASM volatile ("isb 0xF":::"memory");
   2ce94:	f3bf 8f6f 	isb	sy
	relocate_vector_table();
#if defined(CONFIG_CPU_HAS_FPU)
	z_arm_floating_point_init();
#endif
	z_bss_zero();
   2ce98:	f019 fe02 	bl	46aa0 <z_bss_zero>
	z_data_copy();
   2ce9c:	f01a ff0a 	bl	47cb4 <z_data_copy>
#if ((defined(CONFIG_ARMV7_R) || defined(CONFIG_ARMV7_A)) && defined(CONFIG_INIT_STACKS))
	z_arm_init_stacks();
#endif
	z_arm_interrupt_init();
   2cea0:	f000 f99c 	bl	2d1dc <z_arm_interrupt_init>
	z_cstart();
   2cea4:	f019 fe3c 	bl	46b20 <z_cstart>
   2cea8:	00026000 	.word	0x00026000
   2ceac:	e000ed00 	.word	0xe000ed00

0002ceb0 <arch_swap>:
 * as BASEPRI is not available.
 */
int arch_swap(unsigned int key)
{
	/* store off key and return value */
	_current->arch.basepri = key;
   2ceb0:	4a09      	ldr	r2, [pc, #36]	; (2ced8 <arch_swap+0x28>)
	_current->arch.swap_return_value = _k_neg_eagain;
   2ceb2:	490a      	ldr	r1, [pc, #40]	; (2cedc <arch_swap+0x2c>)
	_current->arch.basepri = key;
   2ceb4:	6893      	ldr	r3, [r2, #8]
	_current->arch.swap_return_value = _k_neg_eagain;
   2ceb6:	6809      	ldr	r1, [r1, #0]
   2ceb8:	67d9      	str	r1, [r3, #124]	; 0x7c

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
   2ceba:	4909      	ldr	r1, [pc, #36]	; (2cee0 <arch_swap+0x30>)
	_current->arch.basepri = key;
   2cebc:	6798      	str	r0, [r3, #120]	; 0x78
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
   2cebe:	684b      	ldr	r3, [r1, #4]
   2cec0:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
   2cec4:	604b      	str	r3, [r1, #4]
   2cec6:	2300      	movs	r3, #0
   2cec8:	f383 8811 	msr	BASEPRI, r3
   2cecc:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
   2ced0:	6893      	ldr	r3, [r2, #8]
}
   2ced2:	6fd8      	ldr	r0, [r3, #124]	; 0x7c
   2ced4:	4770      	bx	lr
   2ced6:	bf00      	nop
   2ced8:	2000694c 	.word	0x2000694c
   2cedc:	00053014 	.word	0x00053014
   2cee0:	e000ed00 	.word	0xe000ed00

0002cee4 <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_INSTRUMENT_THREAD_SWITCHING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
   2cee4:	490f      	ldr	r1, [pc, #60]	; (2cf24 <z_arm_pendsv+0x40>)
    ldr r2, [r1, #_kernel_offset_to_current]
   2cee6:	688a      	ldr	r2, [r1, #8]
    /* Store LSB of LR (EXC_RETURN) to the thread's 'mode' word. */
    strb lr, [r2, #_thread_offset_to_mode_exc_return]
#endif

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
   2cee8:	f04f 0030 	mov.w	r0, #48	; 0x30
    add r0, r2
   2ceec:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
   2ceee:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
   2cef2:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
   2cef6:	2020      	movs	r0, #32
    msr BASEPRI_MAX, r0
   2cef8:	f380 8812 	msr	BASEPRI_MAX, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
   2cefc:	f3bf 8f6f 	isb	sy
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
   2cf00:	4f09      	ldr	r7, [pc, #36]	; (2cf28 <z_arm_pendsv+0x44>)
    ldr v3, =_SCS_ICSR_UNPENDSV
   2cf02:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
   2cf06:	69ca      	ldr	r2, [r1, #28]

    str r2, [r1, #_kernel_offset_to_current]
   2cf08:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
   2cf0a:	603e      	str	r6, [r7, #0]

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
   2cf0c:	6f90      	ldr	r0, [r2, #120]	; 0x78
    movs r3, #0
   2cf0e:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
   2cf10:	6793      	str	r3, [r2, #120]	; 0x78
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
   2cf12:	f380 8811 	msr	BASEPRI, r0
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
   2cf16:	f102 0030 	add.w	r0, r2, #48	; 0x30
    ldmia r0, {v1-v8, ip}
   2cf1a:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
   2cf1e:	f38c 8809 	msr	PSP, ip

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (z_arm_{exc,int}_exit, or z_arm_svc)
     */
    bx lr
   2cf22:	4770      	bx	lr
    ldr r1, =_kernel
   2cf24:	2000694c 	.word	0x2000694c
    ldr v4, =_SCS_ICSR
   2cf28:	e000ed04 	.word	0xe000ed04

0002cf2c <z_arm_svc>:
  bne _stack_frame_endif
_stack_frame_msp:
  mrs r0, MSP
_stack_frame_endif:
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    tst lr, #_EXC_RETURN_SPSEL_Msk /* did we come from thread mode ? */
   2cf2c:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
   2cf30:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
   2cf32:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
   2cf36:	f3ef 8009 	mrsne	r0, PSP
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
   2cf3a:	6981      	ldr	r1, [r0, #24]
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    ldrb r1, [r1]
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    ldrb r1, [r1, #-2]
   2cf3c:	f811 1c02 	ldrb.w	r1, [r1, #-2]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
   2cf40:	2902      	cmp	r1, #2
    beq _oops
   2cf42:	d0ff      	beq.n	2cf44 <_oops>

0002cf44 <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
   2cf44:	b501      	push	{r0, lr}
    push {r1, r2}
    push {r4-r11}
    mov  r1, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_ARMV7_M_ARMV8_M_MAINLINE */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
    bl z_do_kernel_oops
   2cf46:	f01d fe1d 	bl	4ab84 <z_do_kernel_oops>
     * the MSP to its value prior to entering the function
     */
    add sp, #40
#endif /* CONFIG_ARMV7_M_ARMV8_M_MAINLINE */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
    pop {r0, pc}
   2cf4a:	bd01      	pop	{r0, pc}

0002cf4c <arch_new_thread>:

#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	iframe->pc &= 0xfffffffe;
#endif
	iframe->a1 = (uint32_t)entry;
   2cf4c:	f842 3c20 	str.w	r3, [r2, #-32]
	iframe->a2 = (uint32_t)p1;
   2cf50:	9b00      	ldr	r3, [sp, #0]
   2cf52:	f842 3c1c 	str.w	r3, [r2, #-28]
	iframe->pc &= 0xfffffffe;
   2cf56:	490a      	ldr	r1, [pc, #40]	; (2cf80 <arch_new_thread+0x34>)
	iframe->a3 = (uint32_t)p2;
   2cf58:	9b01      	ldr	r3, [sp, #4]
   2cf5a:	f842 3c18 	str.w	r3, [r2, #-24]
	iframe->a4 = (uint32_t)p3;
   2cf5e:	9b02      	ldr	r3, [sp, #8]
   2cf60:	f842 3c14 	str.w	r3, [r2, #-20]
	iframe->pc &= 0xfffffffe;
   2cf64:	f021 0101 	bic.w	r1, r1, #1

#if defined(CONFIG_CPU_CORTEX_M)
	iframe->xpsr =
   2cf68:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
   2cf6c:	f842 3c04 	str.w	r3, [r2, #-4]
	iframe->pc &= 0xfffffffe;
   2cf70:	f842 1c08 	str.w	r1, [r2, #-8]
		((uintptr_t)iframe - sizeof(struct __fpu_sf));
	memset(iframe, 0, sizeof(struct __fpu_sf));
#endif

	thread->callee_saved.psp = (uint32_t)iframe;
	thread->arch.basepri = 0;
   2cf74:	2300      	movs	r3, #0
	iframe = Z_STACK_PTR_TO_FRAME(struct __basic_sf, stack_ptr);
   2cf76:	3a20      	subs	r2, #32
	thread->callee_saved.psp = (uint32_t)iframe;
   2cf78:	6502      	str	r2, [r0, #80]	; 0x50
	thread->arch.basepri = 0;
   2cf7a:	6783      	str	r3, [r0, #120]	; 0x78
#endif
	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
   2cf7c:	4770      	bx	lr
   2cf7e:	bf00      	nop
   2cf80:	00048ce7 	.word	0x00048ce7

0002cf84 <arch_switch_to_main_thread>:
void arch_switch_to_main_thread(struct k_thread *main_thread, char *stack_ptr,
				k_thread_entry_t _main)
{
	z_arm_prepare_switch_to_main();

	_current = main_thread;
   2cf84:	4b07      	ldr	r3, [pc, #28]	; (2cfa4 <arch_switch_to_main_thread+0x20>)
   2cf86:	6098      	str	r0, [r3, #8]

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
   2cf88:	4610      	mov	r0, r2
   2cf8a:	f381 8809 	msr	PSP, r1
   2cf8e:	2100      	movs	r1, #0
   2cf90:	b663      	cpsie	if
   2cf92:	f381 8811 	msr	BASEPRI, r1
   2cf96:	f3bf 8f6f 	isb	sy
   2cf9a:	2200      	movs	r2, #0
   2cf9c:	2300      	movs	r3, #0
   2cf9e:	f01b fea2 	bl	48ce6 <z_thread_entry>
	:
	: "r" (_main), "r" (stack_ptr)
	: "r0" /* not to be overwritten by msr PSP, %1 */
	);

	CODE_UNREACHABLE;
   2cfa2:	bf00      	nop
   2cfa4:	2000694c 	.word	0x2000694c

0002cfa8 <_isr_wrapper>:
 *
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
   2cfa8:	b501      	push	{r0, lr}
	 * Disable interrupts to prevent nesting while exiting idle state. This
	 * is only necessary for the Cortex-M because it is the only ARM
	 * architecture variant that automatically enables interrupts when
	 * entering an ISR.
	 */
	cpsid i  /* PRIMASK = 1 */
   2cfaa:	b672      	cpsid	i
#endif

	/* is this a wakeup from idle ? */
	ldr r2, =_kernel
   2cfac:	4a0b      	ldr	r2, [pc, #44]	; (2cfdc <_isr_wrapper+0x34>)
	/* requested idle duration, in ticks */
	ldr r0, [r2, #_kernel_offset_to_idle]
   2cfae:	6990      	ldr	r0, [r2, #24]
	cmp r0, #0
   2cfb0:	2800      	cmp	r0, #0
	str r1, [r2, #_kernel_offset_to_idle]
	bl z_pm_save_idle_exit
_idle_state_cleared:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	ittt ne
   2cfb2:	bf1e      	ittt	ne
	movne	r1, #0
   2cfb4:	2100      	movne	r1, #0
		/* clear kernel idle state */
		strne	r1, [r2, #_kernel_offset_to_idle]
   2cfb6:	6191      	strne	r1, [r2, #24]
		blne	z_pm_save_idle_exit
   2cfb8:	f022 fe56 	blne	4fc68 <z_pm_save_idle_exit>
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
	cpsie i		/* re-enable interrupts (PRIMASK = 0) */
   2cfbc:	b662      	cpsie	i
#endif

#endif /* CONFIG_PM */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
   2cfbe:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
   2cfc2:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
   2cfc6:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	lsl r1, r1, #3
	cmp r0, r1
	bge spurious_continue
#endif /* !CONFIG_CPU_CORTEX_M */

	ldr r1, =_sw_isr_table
   2cfca:	4905      	ldr	r1, [pc, #20]	; (2cfe0 <_isr_wrapper+0x38>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
   2cfcc:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
   2cfce:	c909      	ldmia	r1!, {r0, r3}
	blx r3		/* call ISR */
   2cfd0:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
   2cfd2:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
   2cfd6:	4903      	ldr	r1, [pc, #12]	; (2cfe4 <_isr_wrapper+0x3c>)
	bx r1
   2cfd8:	4708      	bx	r1
   2cfda:	0000      	.short	0x0000
	ldr r2, =_kernel
   2cfdc:	2000694c 	.word	0x2000694c
	ldr r1, =_sw_isr_table
   2cfe0:	00050a3c 	.word	0x00050a3c
	ldr r1, =z_arm_int_exit
   2cfe4:	0002cfe9 	.word	0x0002cfe9

0002cfe8 <z_arm_exc_exit>:
 */

SECTION_SUBSEC_FUNC(TEXT, _HandlerModeExit, z_arm_exc_exit)

#ifdef CONFIG_PREEMPT_ENABLED
	ldr r3, =_kernel
   2cfe8:	4b04      	ldr	r3, [pc, #16]	; (2cffc <_EXIT_EXC+0x2>)

	ldr r1, [r3, #_kernel_offset_to_current]
   2cfea:	6899      	ldr	r1, [r3, #8]
	ldr r0, [r3, #_kernel_offset_to_ready_q_cache]
   2cfec:	69d8      	ldr	r0, [r3, #28]
	cmp r0, r1
   2cfee:	4288      	cmp	r0, r1
	beq _EXIT_EXC
   2cff0:	d003      	beq.n	2cffa <_EXIT_EXC>

	/* context switch required, pend the PendSV exception */
	ldr r1, =_SCS_ICSR
   2cff2:	4903      	ldr	r1, [pc, #12]	; (2d000 <_EXIT_EXC+0x6>)
	ldr r2, =_SCS_ICSR_PENDSV
   2cff4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
	str r2, [r1]
   2cff8:	600a      	str	r2, [r1, #0]

0002cffa <_EXIT_EXC>:
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_STACK_SENTINEL */

	bx lr
   2cffa:	4770      	bx	lr
	ldr r3, =_kernel
   2cffc:	2000694c 	.word	0x2000694c
	ldr r1, =_SCS_ICSR
   2d000:	e000ed04 	.word	0xe000ed04

0002d004 <bus_fault.constprop.0>:
{
	uint32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** BUS FAULT *****");

	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
   2d004:	4b0d      	ldr	r3, [pc, #52]	; (2d03c <bus_fault.constprop.0+0x38>)
   2d006:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Stacking error");
	}
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
   2d008:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Unstacking error");
	}
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
   2d00a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   2d00c:	0592      	lsls	r2, r2, #22
   2d00e:	d508      	bpl.n	2d022 <bus_fault.constprop.0+0x1e>
		 * The BFAR address is valid only if this bit is 1.
		 *
		 * Software must follow this sequence because another
		 * higher priority exception might change the BFAR value.
		 */
		STORE_xFAR(bfar, SCB->BFAR);
   2d010:	6b9a      	ldr	r2, [r3, #56]	; 0x38

		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
   2d012:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   2d014:	0412      	lsls	r2, r2, #16
   2d016:	d504      	bpl.n	2d022 <bus_fault.constprop.0+0x1e>
			PR_EXC("  BFAR Address: 0x%x", bfar);
			if (from_hard_fault != 0) {
   2d018:	b118      	cbz	r0, 2d022 <bus_fault.constprop.0+0x1e>
				/* clear SCB_CFSR_BFAR[VALID] to reset */
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
   2d01a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   2d01c:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
   2d020:	629a      	str	r2, [r3, #40]	; 0x28
			}
		}
	}
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
   2d022:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Imprecise data bus error");
	}
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
   2d024:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   2d026:	05d2      	lsls	r2, r2, #23
		SYSMPU->CESR &= ~sperr;
	}
#endif /* defined(CONFIG_ARM_MPU) && defined(CONFIG_CPU_HAS_NXP_MPU) */

	/* clear BFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
   2d028:	4a04      	ldr	r2, [pc, #16]	; (2d03c <bus_fault.constprop.0+0x38>)
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
   2d02a:	bf58      	it	pl
   2d02c:	6a9b      	ldrpl	r3, [r3, #40]	; 0x28
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
   2d02e:	6a93      	ldr	r3, [r2, #40]	; 0x28

	*recoverable = memory_fault_recoverable(esf, true);
   2d030:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
   2d032:	f443 437f 	orr.w	r3, r3, #65280	; 0xff00
   2d036:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
   2d038:	7008      	strb	r0, [r1, #0]

	return reason;
}
   2d03a:	4770      	bx	lr
   2d03c:	e000ed00 	.word	0xe000ed00

0002d040 <mem_manage_fault.constprop.0>:
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
   2d040:	4b11      	ldr	r3, [pc, #68]	; (2d088 <mem_manage_fault.constprop.0+0x48>)
   2d042:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
   2d044:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
   2d046:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   2d048:	0792      	lsls	r2, r2, #30
   2d04a:	d508      	bpl.n	2d05e <mem_manage_fault.constprop.0+0x1e>
		uint32_t temp = SCB->MMFAR;
   2d04c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
   2d04e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   2d050:	0612      	lsls	r2, r2, #24
   2d052:	d504      	bpl.n	2d05e <mem_manage_fault.constprop.0+0x1e>
			if (from_hard_fault != 0) {
   2d054:	b118      	cbz	r0, 2d05e <mem_manage_fault.constprop.0+0x1e>
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
   2d056:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   2d058:	f022 0280 	bic.w	r2, r2, #128	; 0x80
   2d05c:	629a      	str	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
   2d05e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
   2d060:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
   2d062:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   2d064:	06d0      	lsls	r0, r2, #27
		(SCB->CFSR & SCB_CFSR_DACCVIOL_Msk)) {
   2d066:	bf58      	it	pl
   2d068:	6a9b      	ldrpl	r3, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
   2d06a:	4b07      	ldr	r3, [pc, #28]	; (2d088 <mem_manage_fault.constprop.0+0x48>)
   2d06c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   2d06e:	0692      	lsls	r2, r2, #26
		SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTPENDED_Msk;
   2d070:	bf42      	ittt	mi
   2d072:	6a5a      	ldrmi	r2, [r3, #36]	; 0x24
   2d074:	f422 5200 	bicmi.w	r2, r2, #8192	; 0x2000
   2d078:	625a      	strmi	r2, [r3, #36]	; 0x24
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
   2d07a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
   2d07c:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
   2d07e:	f042 02ff 	orr.w	r2, r2, #255	; 0xff
   2d082:	629a      	str	r2, [r3, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
   2d084:	7008      	strb	r0, [r1, #0]
}
   2d086:	4770      	bx	lr
   2d088:	e000ed00 	.word	0xe000ed00

0002d08c <z_arm_fault>:
 * @param callee_regs Callee-saved registers (R4-R11, PSP)
 *
 */
void z_arm_fault(uint32_t msp, uint32_t psp, uint32_t exc_return,
	_callee_saved_t *callee_regs)
{
   2d08c:	b570      	push	{r4, r5, r6, lr}
	uint32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
   2d08e:	4b49      	ldr	r3, [pc, #292]	; (2d1b4 <z_arm_fault+0x128>)
   2d090:	685b      	ldr	r3, [r3, #4]
{
   2d092:	b08a      	sub	sp, #40	; 0x28
   2d094:	4606      	mov	r6, r0
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
   2d096:	f3c3 0308 	ubfx	r3, r3, #0, #9
   2d09a:	2500      	movs	r5, #0
   2d09c:	f385 8811 	msr	BASEPRI, r5
   2d0a0:	f3bf 8f6f 	isb	sy
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
   2d0a4:	f002 407f 	and.w	r0, r2, #4278190080	; 0xff000000
   2d0a8:	f1b0 4f7f 	cmp.w	r0, #4278190080	; 0xff000000
   2d0ac:	d111      	bne.n	2d0d2 <z_arm_fault+0x46>
	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
   2d0ae:	f002 000c 	and.w	r0, r2, #12
   2d0b2:	2808      	cmp	r0, #8
   2d0b4:	d00d      	beq.n	2d0d2 <z_arm_fault+0x46>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
   2d0b6:	0710      	lsls	r0, r2, #28
			ptr_esf =  (z_arch_esf_t *)psp;
   2d0b8:	bf4c      	ite	mi
   2d0ba:	460e      	movmi	r6, r1
			*nested_exc = true;
   2d0bc:	2501      	movpl	r5, #1
	*recoverable = false;
   2d0be:	2200      	movs	r2, #0
	switch (fault) {
   2d0c0:	3b03      	subs	r3, #3
	*recoverable = false;
   2d0c2:	f88d 2007 	strb.w	r2, [sp, #7]
	switch (fault) {
   2d0c6:	2b03      	cmp	r3, #3
   2d0c8:	d84c      	bhi.n	2d164 <z_arm_fault+0xd8>
   2d0ca:	e8df f003 	tbb	[pc, r3]
   2d0ce:	6404      	.short	0x6404
   2d0d0:	6c68      	.short	0x6c68
		return NULL;
   2d0d2:	462e      	mov	r6, r5
   2d0d4:	e7f3      	b.n	2d0be <z_arm_fault+0x32>
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
   2d0d6:	4b37      	ldr	r3, [pc, #220]	; (2d1b4 <z_arm_fault+0x128>)
   2d0d8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   2d0da:	0791      	lsls	r1, r2, #30
   2d0dc:	d442      	bmi.n	2d164 <z_arm_fault+0xd8>
	} else if ((SCB->HFSR & SCB_HFSR_DEBUGEVT_Msk) != 0) {
   2d0de:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   2d0e0:	2a00      	cmp	r2, #0
   2d0e2:	db3f      	blt.n	2d164 <z_arm_fault+0xd8>
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
   2d0e4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   2d0e6:	0052      	lsls	r2, r2, #1
   2d0e8:	d53c      	bpl.n	2d164 <z_arm_fault+0xd8>
	SCB->CCR |= SCB_CCR_BFHFNMIGN_Msk;
   2d0ea:	695a      	ldr	r2, [r3, #20]
	uint16_t *ret_addr = (uint16_t *)esf->basic.pc;
   2d0ec:	69b1      	ldr	r1, [r6, #24]
	SCB->CCR |= SCB_CCR_BFHFNMIGN_Msk;
   2d0ee:	f442 7280 	orr.w	r2, r2, #256	; 0x100
   2d0f2:	615a      	str	r2, [r3, #20]
  __ASM volatile ("dsb 0xF":::"memory");
   2d0f4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   2d0f8:	f3bf 8f6f 	isb	sy
	SCB->CCR &= ~SCB_CCR_BFHFNMIGN_Msk;
   2d0fc:	695a      	ldr	r2, [r3, #20]
	uint16_t fault_insn = *(ret_addr - 1);
   2d0fe:	f831 1c02 	ldrh.w	r1, [r1, #-2]
	SCB->CCR &= ~SCB_CCR_BFHFNMIGN_Msk;
   2d102:	f422 7280 	bic.w	r2, r2, #256	; 0x100
   2d106:	615a      	str	r2, [r3, #20]
  __ASM volatile ("dsb 0xF":::"memory");
   2d108:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   2d10c:	f3bf 8f6f 	isb	sy
	if (((fault_insn & 0xff00) == _SVC_OPCODE) &&
   2d110:	f64d 7202 	movw	r2, #57090	; 0xdf02
   2d114:	4291      	cmp	r1, r2
   2d116:	d008      	beq.n	2d12a <z_arm_fault+0x9e>
		} else if ((SCB->CFSR & SCB_CFSR_MEMFAULTSR_Msk) != 0) {
   2d118:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   2d11a:	b2d2      	uxtb	r2, r2
   2d11c:	b13a      	cbz	r2, 2d12e <z_arm_fault+0xa2>
			reason = mem_manage_fault(esf, 1, recoverable);
   2d11e:	f10d 0107 	add.w	r1, sp, #7
   2d122:	2001      	movs	r0, #1
		reason = mem_manage_fault(esf, 0, recoverable);
   2d124:	f7ff ff8c 	bl	2d040 <mem_manage_fault.constprop.0>
   2d128:	e00a      	b.n	2d140 <z_arm_fault+0xb4>
			reason = esf->basic.r0;
   2d12a:	6834      	ldr	r4, [r6, #0]
   2d12c:	e01b      	b.n	2d166 <z_arm_fault+0xda>
		} else if ((SCB->CFSR & SCB_CFSR_BUSFAULTSR_Msk) != 0) {
   2d12e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   2d130:	f412 4f7f 	tst.w	r2, #65280	; 0xff00
   2d134:	d006      	beq.n	2d144 <z_arm_fault+0xb8>
			reason = bus_fault(esf, 1, recoverable);
   2d136:	f10d 0107 	add.w	r1, sp, #7
   2d13a:	2001      	movs	r0, #1
   2d13c:	f7ff ff62 	bl	2d004 <bus_fault.constprop.0>
   2d140:	4604      	mov	r4, r0
   2d142:	e010      	b.n	2d166 <z_arm_fault+0xda>
		} else if ((SCB->CFSR & SCB_CFSR_USGFAULTSR_Msk) != 0) {
   2d144:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   2d146:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
   2d14a:	d30b      	bcc.n	2d164 <z_arm_fault+0xd8>
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
   2d14c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
   2d14e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
   2d150:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
   2d152:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
   2d154:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
   2d156:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
   2d158:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   2d15a:	ea6f 4202 	mvn.w	r2, r2, lsl #16
   2d15e:	ea6f 4212 	mvn.w	r2, r2, lsr #16
   2d162:	629a      	str	r2, [r3, #40]	; 0x28
		return NULL;
   2d164:	2400      	movs	r4, #0
#ifdef CONFIG_DEBUG_COREDUMP
	z_arm_coredump_fault_sp = POINTER_TO_UINT(esf);
#endif

	reason = fault_handle(esf, fault, &recoverable);
	if (recoverable) {
   2d166:	f89d 3007 	ldrb.w	r3, [sp, #7]
   2d16a:	b993      	cbnz	r3, 2d192 <z_arm_fault+0x106>
		return;
	}

	/* Copy ESF */
#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
   2d16c:	2220      	movs	r2, #32
   2d16e:	4631      	mov	r1, r6
   2d170:	a802      	add	r0, sp, #8
   2d172:	f01d fe82 	bl	4ae7a <memcpy>
	/* Overwrite stacked IPSR to mark a nested exception,
	 * or a return to Thread mode. Note that this may be
	 * required, if the retrieved ESF contents are invalid
	 * due to, for instance, a stacking error.
	 */
	if (nested_exc) {
   2d176:	9b09      	ldr	r3, [sp, #36]	; 0x24
   2d178:	b1bd      	cbz	r5, 2d1aa <z_arm_fault+0x11e>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
   2d17a:	f3c3 0208 	ubfx	r2, r3, #0, #9
   2d17e:	b922      	cbnz	r2, 2d18a <z_arm_fault+0xfe>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
   2d180:	ea6f 2353 	mvn.w	r3, r3, lsr #9
   2d184:	ea6f 2343 	mvn.w	r3, r3, lsl #9
		}
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
   2d188:	9309      	str	r3, [sp, #36]	; 0x24
	}

	z_arm_fatal_error(reason, &esf_copy);
   2d18a:	a902      	add	r1, sp, #8
   2d18c:	4620      	mov	r0, r4
   2d18e:	f01d fcf7 	bl	4ab80 <z_arm_fatal_error>
}
   2d192:	b00a      	add	sp, #40	; 0x28
   2d194:	bd70      	pop	{r4, r5, r6, pc}
		reason = mem_manage_fault(esf, 0, recoverable);
   2d196:	f10d 0107 	add.w	r1, sp, #7
   2d19a:	2000      	movs	r0, #0
   2d19c:	e7c2      	b.n	2d124 <z_arm_fault+0x98>
		reason = bus_fault(esf, 0, recoverable);
   2d19e:	f10d 0107 	add.w	r1, sp, #7
   2d1a2:	2000      	movs	r0, #0
   2d1a4:	e7ca      	b.n	2d13c <z_arm_fault+0xb0>
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
   2d1a6:	4b03      	ldr	r3, [pc, #12]	; (2d1b4 <z_arm_fault+0x128>)
   2d1a8:	e7d0      	b.n	2d14c <z_arm_fault+0xc0>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
   2d1aa:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
   2d1ae:	f023 0301 	bic.w	r3, r3, #1
   2d1b2:	e7e9      	b.n	2d188 <z_arm_fault+0xfc>
   2d1b4:	e000ed00 	.word	0xe000ed00

0002d1b8 <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
   2d1b8:	4a02      	ldr	r2, [pc, #8]	; (2d1c4 <z_arm_fault_init+0xc>)
   2d1ba:	6953      	ldr	r3, [r2, #20]
   2d1bc:	f043 0310 	orr.w	r3, r3, #16
   2d1c0:	6153      	str	r3, [r2, #20]
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
#ifdef CONFIG_TRAP_UNALIGNED_ACCESS
	SCB->CCR |= SCB_CCR_UNALIGN_TRP_Msk;
#endif /* CONFIG_TRAP_UNALIGNED_ACCESS */
}
   2d1c2:	4770      	bx	lr
   2d1c4:	e000ed00 	.word	0xe000ed00

0002d1c8 <z_arm_bus_fault>:
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_exc_spurious)

	mrs r0, MSP
   2d1c8:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
   2d1cc:	f3ef 8109 	mrs	r1, PSP
	push {r0, lr}
   2d1d0:	b501      	push	{r0, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	push {r4-r11}
#endif
	mov  r3, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
	mov r2, lr /* EXC_RETURN */
   2d1d2:	4672      	mov	r2, lr
	bl z_arm_fault
   2d1d4:	f7ff ff5a 	bl	2d08c <z_arm_fault>
	 * in this routine. Therefore, we can just reset
	 * the MSP to its value prior to entering the function
	 */
	add sp, #40
#endif
	pop {r0, pc}
   2d1d8:	bd01      	pop	{r0, pc}
   2d1da:	bf00      	nop

0002d1dc <z_arm_interrupt_init>:
   2d1dc:	4804      	ldr	r0, [pc, #16]	; (2d1f0 <z_arm_interrupt_init+0x14>)
 *
 */

void z_arm_interrupt_init(void)
{
	int irq = 0;
   2d1de:	2300      	movs	r3, #0
   2d1e0:	2120      	movs	r1, #32
   2d1e2:	18c2      	adds	r2, r0, r3

	for (; irq < CONFIG_NUM_IRQS; irq++) {
   2d1e4:	3301      	adds	r3, #1
   2d1e6:	2b30      	cmp	r3, #48	; 0x30
   2d1e8:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
   2d1ec:	d1f9      	bne.n	2d1e2 <z_arm_interrupt_init+0x6>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
	}
}
   2d1ee:	4770      	bx	lr
   2d1f0:	e000e100 	.word	0xe000e100

0002d1f4 <__start>:
#if defined(CONFIG_PM_S2RAM)
    bl arch_pm_s2ram_resume
#endif /* CONFIG_PM_S2RAM */

#if defined(CONFIG_PLATFORM_SPECIFIC_INIT)
    bl z_arm_platform_init
   2d1f4:	f7fe f82e 	bl	2b254 <z_arm_platform_init>

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
   2d1f8:	2020      	movs	r0, #32
    msr BASEPRI, r0
   2d1fa:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to z_interrupt_stacks during initialization.
     */
    ldr r0, =z_interrupt_stacks
   2d1fe:	4808      	ldr	r0, [pc, #32]	; (2d220 <__start+0x2c>)
    ldr r1, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
   2d200:	f44f 6100 	mov.w	r1, #2048	; 0x800
    adds r0, r0, r1
   2d204:	1840      	adds	r0, r0, r1
    msr PSP, r0
   2d206:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
   2d20a:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
   2d20e:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
   2d210:	4308      	orrs	r0, r1
    msr CONTROL, r0
   2d212:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
   2d216:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
   2d21a:	f7ff fe25 	bl	2ce68 <z_arm_prep_c>
   2d21e:	0000      	.short	0x0000
    ldr r0, =z_interrupt_stacks
   2d220:	200090a8 	.word	0x200090a8

0002d224 <z_impl_k_thread_abort>:
#include <zephyr/wait_q.h>
#include <zephyr/sys/__assert.h>

void z_impl_k_thread_abort(k_tid_t thread)
{
	if (_current == thread) {
   2d224:	4b08      	ldr	r3, [pc, #32]	; (2d248 <z_impl_k_thread_abort+0x24>)
   2d226:	689b      	ldr	r3, [r3, #8]
   2d228:	4283      	cmp	r3, r0
   2d22a:	d10b      	bne.n	2d244 <z_impl_k_thread_abort+0x20>
 */
__STATIC_FORCEINLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   2d22c:	f3ef 8305 	mrs	r3, IPSR
		if (arch_is_in_isr()) {
   2d230:	b143      	cbz	r3, 2d244 <z_impl_k_thread_abort+0x20>
			 * should no longer run after we return, so
			 * Trigger PendSV, in case we are in one of the
			 * situations where the isr check is true but there
			 * is not an implicit scheduler invocation.
			 */
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
   2d232:	4b06      	ldr	r3, [pc, #24]	; (2d24c <z_impl_k_thread_abort+0x28>)
   2d234:	685a      	ldr	r2, [r3, #4]
   2d236:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
   2d23a:	605a      	str	r2, [r3, #4]
			/* Clear any system calls that may be pending
			 * as they have a higher priority than the PendSV
			 * handler and will check the stack of the thread
			 * being aborted.
			 */
			SCB->SHCSR &= ~SCB_SHCSR_SVCALLPENDED_Msk;
   2d23c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
   2d23e:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
   2d242:	625a      	str	r2, [r3, #36]	; 0x24
		}
	}

	z_thread_abort(thread);
   2d244:	f01a bcc4 	b.w	47bd0 <z_thread_abort>
   2d248:	2000694c 	.word	0x2000694c
   2d24c:	e000ed00 	.word	0xe000ed00

0002d250 <z_arm_configure_static_mpu_regions>:
	/* Configure the static MPU regions within firmware SRAM boundaries.
	 * Start address of the image is given by _image_ram_start. The end
	 * of the firmware SRAM area is marked by __kernel_ram_end, taking
	 * into account the unused SRAM area, as well.
	 */
	arm_core_mpu_configure_static_mpu_regions(static_regions,
   2d250:	4b02      	ldr	r3, [pc, #8]	; (2d25c <z_arm_configure_static_mpu_regions+0xc>)
   2d252:	4a03      	ldr	r2, [pc, #12]	; (2d260 <z_arm_configure_static_mpu_regions+0x10>)
   2d254:	4803      	ldr	r0, [pc, #12]	; (2d264 <z_arm_configure_static_mpu_regions+0x14>)
   2d256:	2101      	movs	r1, #1
   2d258:	f000 b860 	b.w	2d31c <arm_core_mpu_configure_static_mpu_regions>
   2d25c:	20040000 	.word	0x20040000
   2d260:	20000000 	.word	0x20000000
   2d264:	00051c24 	.word	0x00051c24

0002d268 <mpu_configure_regions>:
 * sanity check of the memory regions to be programmed.
 */
static int mpu_configure_regions(const struct z_arm_mpu_partition
	regions[], uint8_t regions_num, uint8_t start_reg_index,
	bool do_sanity_check)
{
   2d268:	b5f0      	push	{r4, r5, r6, r7, lr}
#endif /* CPU_CORTEX_M0PLUS | CPU_CORTEX_M3 | CPU_CORTEX_M4 */
}

static inline void set_region_number(uint32_t index)
{
	MPU->RNR = index;
   2d26a:	4e20      	ldr	r6, [pc, #128]	; (2d2ec <mpu_configure_regions+0x84>)
	int i;
	int reg_index = start_reg_index;

	for (i = 0; i < regions_num; i++) {
   2d26c:	2500      	movs	r5, #0
   2d26e:	428d      	cmp	r5, r1
   2d270:	da39      	bge.n	2d2e6 <mpu_configure_regions+0x7e>
		if (regions[i].size == 0U) {
   2d272:	6844      	ldr	r4, [r0, #4]
   2d274:	b374      	cbz	r4, 2d2d4 <mpu_configure_regions+0x6c>
			continue;
		}
		/* Non-empty region. */

		if (do_sanity_check &&
   2d276:	b153      	cbz	r3, 2d28e <mpu_configure_regions+0x26>
	 * and greater or equal to the minimum
	 * MPU region size. Start address of the
	 * partition must align with size.
	 */
	int partition_is_valid =
		((part->size & (part->size - 1U)) == 0U)
   2d278:	f104 3cff 	add.w	ip, r4, #4294967295	; 0xffffffff
		&&
		(part->size >= CONFIG_ARM_MPU_REGION_MIN_ALIGN_AND_SIZE)
		&&
   2d27c:	ea14 0f0c 	tst.w	r4, ip
   2d280:	d12f      	bne.n	2d2e2 <mpu_configure_regions+0x7a>
		&&
   2d282:	2c1f      	cmp	r4, #31
   2d284:	d92d      	bls.n	2d2e2 <mpu_configure_regions+0x7a>
		((part->start & (part->size - 1U)) == 0U);
   2d286:	6807      	ldr	r7, [r0, #0]
		&&
   2d288:	ea1c 0f07 	tst.w	ip, r7
   2d28c:	d129      	bne.n	2d2e2 <mpu_configure_regions+0x7a>
 * to that power-of-two value.
 */
static inline uint32_t size_to_mpu_rasr_size(uint32_t size)
{
	/* The minimal supported region size is 32 bytes */
	if (size <= 32U) {
   2d28e:	2c20      	cmp	r4, #32
	region_conf.base = new_region->start;
   2d290:	6807      	ldr	r7, [r0, #0]
#if defined(CONFIG_CPU_AARCH32_CORTEX_R)
	(void) size;

	p_attr->rasr = attr->rasr_attr;
#else
	p_attr->rasr = attr->rasr_attr | size_to_mpu_rasr_size(size);
   2d292:	f8d0 c008 	ldr.w	ip, [r0, #8]
				(!mpu_partition_is_valid(&regions[i]))) {
			LOG_ERR("Partition %u: sanity check failed.", i);
			return -EINVAL;
		}

		reg_index = mpu_configure_region(reg_index, &regions[i]);
   2d296:	fa5f fe82 	uxtb.w	lr, r2
	if (size <= 32U) {
   2d29a:	d91e      	bls.n	2d2da <mpu_configure_regions+0x72>
	if (size > (1UL << 31)) {
   2d29c:	f1b4 4f00 	cmp.w	r4, #2147483648	; 0x80000000
   2d2a0:	d81d      	bhi.n	2d2de <mpu_configure_regions+0x76>
	return ((32 - __builtin_clz(size - 1U) - 2 + 1) << MPU_RASR_SIZE_Pos) &
   2d2a2:	3c01      	subs	r4, #1
   2d2a4:	fab4 f484 	clz	r4, r4
   2d2a8:	f1c4 041f 	rsb	r4, r4, #31
   2d2ac:	0064      	lsls	r4, r4, #1
	if (index > (get_num_regions() - 1U)) {
   2d2ae:	f1be 0f07 	cmp.w	lr, #7
	p_attr->rasr = attr->rasr_attr | size_to_mpu_rasr_size(size);
   2d2b2:	ea4c 0c04 	orr.w	ip, ip, r4
   2d2b6:	d814      	bhi.n	2d2e2 <mpu_configure_regions+0x7a>
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
   2d2b8:	f027 041f 	bic.w	r4, r7, #31
				| MPU_RBAR_VALID_Msk | index;
   2d2bc:	4314      	orrs	r4, r2
   2d2be:	f044 0410 	orr.w	r4, r4, #16
   2d2c2:	f8c6 2098 	str.w	r2, [r6, #152]	; 0x98
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
   2d2c6:	f8c6 409c 	str.w	r4, [r6, #156]	; 0x9c
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
   2d2ca:	f04c 0401 	orr.w	r4, ip, #1
   2d2ce:	f8c6 40a0 	str.w	r4, [r6, #160]	; 0xa0
		if (reg_index == -EINVAL) {
			return reg_index;
		}

		/* Increment number of programmed MPU indices. */
		reg_index++;
   2d2d2:	3201      	adds	r2, #1
	for (i = 0; i < regions_num; i++) {
   2d2d4:	3501      	adds	r5, #1
   2d2d6:	300c      	adds	r0, #12
   2d2d8:	e7c9      	b.n	2d26e <mpu_configure_regions+0x6>
		return REGION_32B;
   2d2da:	2408      	movs	r4, #8
   2d2dc:	e7e7      	b.n	2d2ae <mpu_configure_regions+0x46>
		return REGION_4G;
   2d2de:	243e      	movs	r4, #62	; 0x3e
   2d2e0:	e7e5      	b.n	2d2ae <mpu_configure_regions+0x46>
			return -EINVAL;
   2d2e2:	f06f 0215 	mvn.w	r2, #21
	}

	return reg_index;
}
   2d2e6:	4610      	mov	r0, r2
   2d2e8:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2d2ea:	bf00      	nop
   2d2ec:	e000ed00 	.word	0xe000ed00

0002d2f0 <arm_core_mpu_enable>:
void arm_core_mpu_enable(void)
{
	/* Enable MPU and use the default memory map as a
	 * background region for privileged software access.
	 */
	MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
   2d2f0:	4b04      	ldr	r3, [pc, #16]	; (2d304 <arm_core_mpu_enable+0x14>)
   2d2f2:	2205      	movs	r2, #5
   2d2f4:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  __ASM volatile ("dsb 0xF":::"memory");
   2d2f8:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   2d2fc:	f3bf 8f6f 	isb	sy

	/* Make sure that all the registers are set before proceeding */
	__DSB();
	__ISB();
}
   2d300:	4770      	bx	lr
   2d302:	bf00      	nop
   2d304:	e000ed00 	.word	0xe000ed00

0002d308 <arm_core_mpu_disable>:
  __ASM volatile ("dmb 0xF":::"memory");
   2d308:	f3bf 8f5f 	dmb	sy
{
	/* Force any outstanding transfers to complete before disabling MPU */
	__DMB();

	/* Disable MPU */
	MPU->CTRL = 0;
   2d30c:	4b02      	ldr	r3, [pc, #8]	; (2d318 <arm_core_mpu_disable+0x10>)
   2d30e:	2200      	movs	r2, #0
   2d310:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
}
   2d314:	4770      	bx	lr
   2d316:	bf00      	nop
   2d318:	e000ed00 	.word	0xe000ed00

0002d31c <arm_core_mpu_configure_static_mpu_regions>:
 * @brief configure fixed (static) MPU regions.
 */
void arm_core_mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	*static_regions, const uint8_t regions_num,
	const uint32_t background_area_start, const uint32_t background_area_end)
{
   2d31c:	b510      	push	{r4, lr}
static int mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	static_regions[], const uint8_t regions_num,
	const uint32_t background_area_base,
	const uint32_t background_area_end)
{
	int mpu_reg_index = static_regions_num;
   2d31e:	4c03      	ldr	r4, [pc, #12]	; (2d32c <arm_core_mpu_configure_static_mpu_regions+0x10>)
	 * programmed on top of SRAM region configuration.
	 */
	ARG_UNUSED(background_area_base);
	ARG_UNUSED(background_area_end);

	mpu_reg_index = mpu_configure_regions(static_regions,
   2d320:	2301      	movs	r3, #1
   2d322:	7822      	ldrb	r2, [r4, #0]
   2d324:	f7ff ffa0 	bl	2d268 <mpu_configure_regions>
		regions_num, mpu_reg_index, true);

	static_regions_num = mpu_reg_index;
   2d328:	7020      	strb	r0, [r4, #0]
					       background_area_start, background_area_end) == -EINVAL) {

		__ASSERT(0, "Configuring %u static MPU regions failed\n",
			regions_num);
	}
}
   2d32a:	bd10      	pop	{r4, pc}
   2d32c:	20006b06 	.word	0x20006b06

0002d330 <z_arm_mpu_init>:
 */
int z_arm_mpu_init(void)
{
	uint32_t r_index;

	if (mpu_config.num_regions > get_num_regions()) {
   2d330:	4914      	ldr	r1, [pc, #80]	; (2d384 <z_arm_mpu_init+0x54>)
   2d332:	6808      	ldr	r0, [r1, #0]
   2d334:	2808      	cmp	r0, #8
{
   2d336:	b510      	push	{r4, lr}
	if (mpu_config.num_regions > get_num_regions()) {
   2d338:	d821      	bhi.n	2d37e <z_arm_mpu_init+0x4e>
		return -1;
	}

	LOG_DBG("total region count: %d", get_num_regions());

	arm_core_mpu_disable();
   2d33a:	f7ff ffe5 	bl	2d308 <arm_core_mpu_disable>
   2d33e:	4c12      	ldr	r4, [pc, #72]	; (2d388 <z_arm_mpu_init+0x58>)
   2d340:	6849      	ldr	r1, [r1, #4]

	/* Architecture-specific configuration */
	mpu_init();

	/* Program fixed regions configured at SOC definition. */
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
   2d342:	2200      	movs	r2, #0
   2d344:	4290      	cmp	r0, r2
   2d346:	f101 010c 	add.w	r1, r1, #12
   2d34a:	d105      	bne.n	2d358 <z_arm_mpu_init+0x28>
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
	}

	/* Update the number of programmed MPU regions. */
	static_regions_num = mpu_config.num_regions;
   2d34c:	4b0f      	ldr	r3, [pc, #60]	; (2d38c <z_arm_mpu_init+0x5c>)
   2d34e:	7018      	strb	r0, [r3, #0]


	arm_core_mpu_enable();
   2d350:	f7ff ffce 	bl	2d2f0 <arm_core_mpu_enable>
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos ==
		NUM_MPU_REGIONS,
		"Invalid number of MPU regions\n");
#endif /* CORTEX_M0PLUS || CPU_CORTEX_M3 || CPU_CORTEX_M4 */

	return 0;
   2d354:	2000      	movs	r0, #0
}
   2d356:	bd10      	pop	{r4, pc}
   2d358:	f8c4 2098 	str.w	r2, [r4, #152]	; 0x98
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
   2d35c:	f851 3c0c 	ldr.w	r3, [r1, #-12]
   2d360:	f023 031f 	bic.w	r3, r3, #31
				| MPU_RBAR_VALID_Msk | index;
   2d364:	4313      	orrs	r3, r2
   2d366:	f043 0310 	orr.w	r3, r3, #16
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
   2d36a:	f8c4 309c 	str.w	r3, [r4, #156]	; 0x9c
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
   2d36e:	f851 3c04 	ldr.w	r3, [r1, #-4]
   2d372:	f043 0301 	orr.w	r3, r3, #1
   2d376:	f8c4 30a0 	str.w	r3, [r4, #160]	; 0xa0
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
   2d37a:	3201      	adds	r2, #1
   2d37c:	e7e2      	b.n	2d344 <z_arm_mpu_init+0x14>
		return -1;
   2d37e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2d382:	e7e8      	b.n	2d356 <z_arm_mpu_init+0x26>
   2d384:	00051c30 	.word	0x00051c30
   2d388:	e000ed00 	.word	0xe000ed00
   2d38c:	20006b06 	.word	0x20006b06

0002d390 <snprintf>:
	return 0; /* indicate keep going so we get the total count */
}

int snprintf(char *ZRESTRICT str, size_t len,
	     const char *ZRESTRICT format, ...)
{
   2d390:	b40c      	push	{r2, r3}
   2d392:	b510      	push	{r4, lr}
   2d394:	b086      	sub	sp, #24

	struct emitter p;
	int     r;
	char    dummy;

	if (len == 0) {
   2d396:	b909      	cbnz	r1, 2d39c <snprintf+0xc>
		str = &dummy; /* write final NUL to dummy, can't change *s */
   2d398:	f10d 000b 	add.w	r0, sp, #11
   2d39c:	2400      	movs	r4, #0
	}

	p.ptr = str;
	p.len = (int) len;
   2d39e:	e9cd 0104 	strd	r0, r1, [sp, #16]

	va_start(vargs, format);
   2d3a2:	ab09      	add	r3, sp, #36	; 0x24
   2d3a4:	9a08      	ldr	r2, [sp, #32]
   2d3a6:	9400      	str	r4, [sp, #0]
   2d3a8:	a904      	add	r1, sp, #16
   2d3aa:	4805      	ldr	r0, [pc, #20]	; (2d3c0 <snprintf+0x30>)
   2d3ac:	9303      	str	r3, [sp, #12]
   2d3ae:	f7fd fd19 	bl	2ade4 <z_cbvprintf_impl>
	r = cbvprintf(sprintf_out, (void *) (&p), format, vargs);
	va_end(vargs);

	*(p.ptr) = 0;
   2d3b2:	9b04      	ldr	r3, [sp, #16]
   2d3b4:	701c      	strb	r4, [r3, #0]
	return r;
}
   2d3b6:	b006      	add	sp, #24
   2d3b8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   2d3bc:	b002      	add	sp, #8
   2d3be:	4770      	bx	lr
   2d3c0:	0004aea3 	.word	0x0004aea3

0002d3c4 <sprintf>:

int sprintf(char *ZRESTRICT str, const char *ZRESTRICT format, ...)
{
   2d3c4:	b40e      	push	{r1, r2, r3}
   2d3c6:	b510      	push	{r4, lr}
   2d3c8:	b087      	sub	sp, #28
   2d3ca:	ab09      	add	r3, sp, #36	; 0x24
   2d3cc:	2400      	movs	r4, #0

	struct emitter p;
	int     r;

	p.ptr = str;
	p.len = (int) 0x7fffffff; /* allow up to "maxint" characters */
   2d3ce:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
{
   2d3d2:	f853 2b04 	ldr.w	r2, [r3], #4
	p.ptr = str;
   2d3d6:	9004      	str	r0, [sp, #16]
	p.len = (int) 0x7fffffff; /* allow up to "maxint" characters */
   2d3d8:	9105      	str	r1, [sp, #20]
   2d3da:	9400      	str	r4, [sp, #0]
   2d3dc:	a904      	add	r1, sp, #16
   2d3de:	4805      	ldr	r0, [pc, #20]	; (2d3f4 <sprintf+0x30>)

	va_start(vargs, format);
   2d3e0:	9303      	str	r3, [sp, #12]
   2d3e2:	f7fd fcff 	bl	2ade4 <z_cbvprintf_impl>
	r = cbvprintf(sprintf_out, (void *) (&p), format, vargs);
	va_end(vargs);

	*(p.ptr) = 0;
   2d3e6:	9b04      	ldr	r3, [sp, #16]
   2d3e8:	701c      	strb	r4, [r3, #0]
	return r;
}
   2d3ea:	b007      	add	sp, #28
   2d3ec:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   2d3f0:	b003      	add	sp, #12
   2d3f2:	4770      	bx	lr
   2d3f4:	0004aea3 	.word	0x0004aea3

0002d3f8 <nordicsemi_nrf52_init>:
	__asm__ volatile(
   2d3f8:	f04f 0320 	mov.w	r3, #32
   2d3fc:	f3ef 8211 	mrs	r2, BASEPRI
   2d400:	f383 8812 	msr	BASEPRI_MAX, r3
   2d404:	f3bf 8f6f 	isb	sy

	key = irq_lock();

#ifdef CONFIG_NRF_ENABLE_ICACHE
	/* Enable the instruction cache */
	NRF_NVMC->ICACHECNF = NVMC_ICACHECNF_CACHEEN_Msk;
   2d408:	4906      	ldr	r1, [pc, #24]	; (2d424 <nordicsemi_nrf52_init+0x2c>)
   2d40a:	2301      	movs	r3, #1
   2d40c:	f8c1 3540 	str.w	r3, [r1, #1344]	; 0x540
#endif

#if NRF_POWER_HAS_DCDCEN
NRF_STATIC_INLINE void nrf_power_dcdcen_set(NRF_POWER_Type * p_reg, bool enable)
{
    p_reg->DCDCEN = (enable ? POWER_DCDCEN_DCDCEN_Enabled : POWER_DCDCEN_DCDCEN_Disabled) <<
   2d410:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
   2d414:	f8c1 3578 	str.w	r3, [r1, #1400]	; 0x578
	__asm__ volatile(
   2d418:	f382 8811 	msr	BASEPRI, r2
   2d41c:	f3bf 8f6f 	isb	sy
	NMI_INIT();

	irq_unlock(key);

	return 0;
}
   2d420:	2000      	movs	r0, #0
   2d422:	4770      	bx	lr
   2d424:	4001e000 	.word	0x4001e000

0002d428 <sys_arch_reboot>:
    *p_gpregret = val;
   2d428:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   2d42c:	b2c0      	uxtb	r0, r0
   2d42e:	f8c3 051c 	str.w	r0, [r3, #1308]	; 0x51c
  __ASM volatile ("dsb 0xF":::"memory");
   2d432:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
   2d436:	4905      	ldr	r1, [pc, #20]	; (2d44c <sys_arch_reboot+0x24>)
   2d438:	4b05      	ldr	r3, [pc, #20]	; (2d450 <sys_arch_reboot+0x28>)
   2d43a:	68ca      	ldr	r2, [r1, #12]
   2d43c:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
   2d440:	4313      	orrs	r3, r2
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
   2d442:	60cb      	str	r3, [r1, #12]
   2d444:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
   2d448:	bf00      	nop
  for(;;)                                                           /* wait until reset */
   2d44a:	e7fd      	b.n	2d448 <sys_arch_reboot+0x20>
   2d44c:	e000ed00 	.word	0xe000ed00
   2d450:	05fa0004 	.word	0x05fa0004

0002d454 <arch_busy_wait>:

#else // NRFX_CHECK(NRFX_DELAY_DWT_BASED)

NRF_STATIC_INLINE void nrfx_coredep_delay_us(uint32_t time_us)
{
    if (time_us == 0)
   2d454:	b120      	cbz	r0, 2d460 <arch_busy_wait+0xc>
    typedef void (* delay_func_t)(uint32_t);
    const delay_func_t delay_cycles =
        // Set LSB to 1 to execute the code in the Thumb mode.
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
    uint32_t cycles = time_us * NRFX_DELAY_CPU_FREQ_MHZ;
    delay_cycles(cycles);
   2d456:	4b03      	ldr	r3, [pc, #12]	; (2d464 <arch_busy_wait+0x10>)
   2d458:	0180      	lsls	r0, r0, #6
   2d45a:	f043 0301 	orr.w	r3, r3, #1
   2d45e:	4718      	bx	r3

void arch_busy_wait(uint32_t time_us)
{
	nrfx_coredep_delay_us(time_us);
}
   2d460:	4770      	bx	lr
   2d462:	bf00      	nop
   2d464:	00050e20 	.word	0x00050e20

0002d468 <ecc_process>:

	bt_recv(buf);
}

static void ecc_process(struct k_work *work)
{
   2d468:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   2d46a:	4e59      	ldr	r6, [pc, #356]	; (2d5d0 <ecc_process+0x168>)
   2d46c:	f3bf 8f5b 	dmb	ish
   2d470:	6834      	ldr	r4, [r6, #0]
   2d472:	f3bf 8f5b 	dmb	ish
	if (atomic_test_bit(flags, PENDING_PUB_KEY)) {
   2d476:	f014 0401 	ands.w	r4, r4, #1
   2d47a:	d050      	beq.n	2d51e <ecc_process+0xb6>
		rc = uECC_make_key(ecc.public_key_be, ecc.private_key_be,
   2d47c:	4f55      	ldr	r7, [pc, #340]	; (2d5d4 <ecc_process+0x16c>)
   2d47e:	4c56      	ldr	r4, [pc, #344]	; (2d5d8 <ecc_process+0x170>)
	} while (memcmp(ecc.private_key_be, debug_private_key_be, BT_PRIV_KEY_LEN) == 0);
   2d480:	4d56      	ldr	r5, [pc, #344]	; (2d5dc <ecc_process+0x174>)
		rc = uECC_make_key(ecc.public_key_be, ecc.private_key_be,
   2d482:	4857      	ldr	r0, [pc, #348]	; (2d5e0 <ecc_process+0x178>)
   2d484:	463a      	mov	r2, r7
   2d486:	4621      	mov	r1, r4
   2d488:	f01c fa87 	bl	4999a <uECC_make_key>
		if (rc == TC_CRYPTO_FAIL) {
   2d48c:	b3e0      	cbz	r0, 2d508 <ecc_process+0xa0>
	} while (memcmp(ecc.private_key_be, debug_private_key_be, BT_PRIV_KEY_LEN) == 0);
   2d48e:	2220      	movs	r2, #32
   2d490:	4629      	mov	r1, r5
   2d492:	4620      	mov	r0, r4
   2d494:	f01d fce1 	bl	4ae5a <memcmp>
   2d498:	2800      	cmp	r0, #0
   2d49a:	d0f2      	beq.n	2d482 <ecc_process+0x1a>
	return 0;
   2d49c:	2700      	movs	r7, #0
	buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
   2d49e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   2d4a2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2d4a6:	2001      	movs	r0, #1
   2d4a8:	f000 face 	bl	2da48 <bt_buf_get_rx>
   2d4ac:	f100 0508 	add.w	r5, r0, #8
   2d4b0:	2102      	movs	r1, #2
   2d4b2:	4604      	mov	r4, r0
   2d4b4:	4628      	mov	r0, r5
   2d4b6:	f021 fc7d 	bl	4edb4 <net_buf_simple_add>
	hdr->evt = BT_HCI_EVT_LE_META_EVENT;
   2d4ba:	233e      	movs	r3, #62	; 0x3e
   2d4bc:	7003      	strb	r3, [r0, #0]
	hdr->len = sizeof(*meta) + sizeof(*evt);
   2d4be:	2342      	movs	r3, #66	; 0x42
   2d4c0:	7043      	strb	r3, [r0, #1]
   2d4c2:	2101      	movs	r1, #1
   2d4c4:	4628      	mov	r0, r5
   2d4c6:	f021 fc75 	bl	4edb4 <net_buf_simple_add>
	meta->subevent = BT_HCI_EVT_LE_P256_PUBLIC_KEY_COMPLETE;
   2d4ca:	2308      	movs	r3, #8
   2d4cc:	7003      	strb	r3, [r0, #0]
   2d4ce:	2141      	movs	r1, #65	; 0x41
   2d4d0:	4628      	mov	r0, r5
   2d4d2:	f021 fc6f 	bl	4edb4 <net_buf_simple_add>
   2d4d6:	4605      	mov	r5, r0
	evt->status = status;
   2d4d8:	f800 7b01 	strb.w	r7, [r0], #1
	if (status) {
   2d4dc:	b1b7      	cbz	r7, 2d50c <ecc_process+0xa4>
		(void)memset(evt->key, 0, sizeof(evt->key));
   2d4de:	2240      	movs	r2, #64	; 0x40
   2d4e0:	2100      	movs	r1, #0
   2d4e2:	f01d fcd5 	bl	4ae90 <memset>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   2d4e6:	f3bf 8f5b 	dmb	ish
   2d4ea:	e856 3f00 	ldrex	r3, [r6]
   2d4ee:	f023 0301 	bic.w	r3, r3, #1
   2d4f2:	e846 3200 	strex	r2, r3, [r6]
   2d4f6:	2a00      	cmp	r2, #0
   2d4f8:	d1f7      	bne.n	2d4ea <ecc_process+0x82>
   2d4fa:	f3bf 8f5b 	dmb	ish
	bt_recv(buf);
   2d4fe:	4620      	mov	r0, r4
	} else if (atomic_test_bit(flags, PENDING_DHKEY)) {
		emulate_le_generate_dhkey();
	} else {
		__ASSERT(0, "Unhandled ECC command");
	}
}
   2d500:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	bt_recv(buf);
   2d504:	f001 b826 	b.w	2e554 <bt_recv>
			return BT_HCI_ERR_UNSPECIFIED;
   2d508:	271f      	movs	r7, #31
   2d50a:	e7c8      	b.n	2d49e <ecc_process+0x36>
		sys_memcpy_swap(evt->key, ecc.public_key_be, BT_PUB_KEY_COORD_LEN);
   2d50c:	4934      	ldr	r1, [pc, #208]	; (2d5e0 <ecc_process+0x178>)
   2d50e:	f01d fd31 	bl	4af74 <sys_memcpy_swap.constprop.0>
		sys_memcpy_swap(&evt->key[BT_PUB_KEY_COORD_LEN],
   2d512:	3120      	adds	r1, #32
   2d514:	f105 0021 	add.w	r0, r5, #33	; 0x21
   2d518:	f01d fd2c 	bl	4af74 <sys_memcpy_swap.constprop.0>
   2d51c:	e7e3      	b.n	2d4e6 <ecc_process+0x7e>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   2d51e:	f3bf 8f5b 	dmb	ish
   2d522:	6833      	ldr	r3, [r6, #0]
   2d524:	f3bf 8f5b 	dmb	ish
	} else if (atomic_test_bit(flags, PENDING_DHKEY)) {
   2d528:	079b      	lsls	r3, r3, #30
   2d52a:	d550      	bpl.n	2d5ce <ecc_process+0x166>
	ret = uECC_valid_public_key(ecc.public_key_be, &curve_secp256r1);
   2d52c:	4929      	ldr	r1, [pc, #164]	; (2d5d4 <ecc_process+0x16c>)
   2d52e:	482c      	ldr	r0, [pc, #176]	; (2d5e0 <ecc_process+0x178>)
   2d530:	f01d f8f1 	bl	4a716 <uECC_valid_public_key>
	if (ret < 0) {
   2d534:	2800      	cmp	r0, #0
   2d536:	db11      	blt.n	2d55c <ecc_process+0xf4>
   2d538:	f3bf 8f5b 	dmb	ish
		ret = uECC_shared_secret(ecc.public_key_be,
   2d53c:	4926      	ldr	r1, [pc, #152]	; (2d5d8 <ecc_process+0x170>)
   2d53e:	6833      	ldr	r3, [r6, #0]
   2d540:	4826      	ldr	r0, [pc, #152]	; (2d5dc <ecc_process+0x174>)
   2d542:	f3bf 8f5b 	dmb	ish
   2d546:	f013 0f04 	tst.w	r3, #4
   2d54a:	f101 0220 	add.w	r2, r1, #32
   2d54e:	4b21      	ldr	r3, [pc, #132]	; (2d5d4 <ecc_process+0x16c>)
   2d550:	bf18      	it	ne
   2d552:	4601      	movne	r1, r0
   2d554:	4610      	mov	r0, r2
   2d556:	f01c fa6f 	bl	49a38 <uECC_shared_secret>
   2d55a:	4604      	mov	r4, r0
	buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
   2d55c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   2d560:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2d564:	2001      	movs	r0, #1
   2d566:	f000 fa6f 	bl	2da48 <bt_buf_get_rx>
   2d56a:	f100 0708 	add.w	r7, r0, #8
   2d56e:	2102      	movs	r1, #2
   2d570:	4605      	mov	r5, r0
   2d572:	4638      	mov	r0, r7
   2d574:	f021 fc1e 	bl	4edb4 <net_buf_simple_add>
	hdr->evt = BT_HCI_EVT_LE_META_EVENT;
   2d578:	233e      	movs	r3, #62	; 0x3e
   2d57a:	7003      	strb	r3, [r0, #0]
	hdr->len = sizeof(*meta) + sizeof(*evt);
   2d57c:	2322      	movs	r3, #34	; 0x22
   2d57e:	7043      	strb	r3, [r0, #1]
   2d580:	2101      	movs	r1, #1
   2d582:	4638      	mov	r0, r7
   2d584:	f021 fc16 	bl	4edb4 <net_buf_simple_add>
	meta->subevent = BT_HCI_EVT_LE_GENERATE_DHKEY_COMPLETE;
   2d588:	2309      	movs	r3, #9
   2d58a:	7003      	strb	r3, [r0, #0]
   2d58c:	2121      	movs	r1, #33	; 0x21
   2d58e:	4638      	mov	r0, r7
   2d590:	f021 fc10 	bl	4edb4 <net_buf_simple_add>
   2d594:	4603      	mov	r3, r0
	if (ret == TC_CRYPTO_FAIL) {
   2d596:	3001      	adds	r0, #1
   2d598:	b99c      	cbnz	r4, 2d5c2 <ecc_process+0x15a>
		evt->status = BT_HCI_ERR_UNSPECIFIED;
   2d59a:	221f      	movs	r2, #31
   2d59c:	701a      	strb	r2, [r3, #0]
		(void)memset(evt->dhkey, 0xff, sizeof(evt->dhkey));
   2d59e:	21ff      	movs	r1, #255	; 0xff
   2d5a0:	2220      	movs	r2, #32
   2d5a2:	f01d fc75 	bl	4ae90 <memset>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   2d5a6:	f3bf 8f5b 	dmb	ish
   2d5aa:	e856 3f00 	ldrex	r3, [r6]
   2d5ae:	f023 0302 	bic.w	r3, r3, #2
   2d5b2:	e846 3200 	strex	r2, r3, [r6]
   2d5b6:	2a00      	cmp	r2, #0
   2d5b8:	d1f7      	bne.n	2d5aa <ecc_process+0x142>
   2d5ba:	f3bf 8f5b 	dmb	ish
	bt_recv(buf);
   2d5be:	4628      	mov	r0, r5
   2d5c0:	e79e      	b.n	2d500 <ecc_process+0x98>
		evt->status = 0U;
   2d5c2:	2200      	movs	r2, #0
		sys_memcpy_swap(evt->dhkey, ecc.dhkey_be, sizeof(ecc.dhkey_be));
   2d5c4:	4906      	ldr	r1, [pc, #24]	; (2d5e0 <ecc_process+0x178>)
		evt->status = 0U;
   2d5c6:	701a      	strb	r2, [r3, #0]
		sys_memcpy_swap(evt->dhkey, ecc.dhkey_be, sizeof(ecc.dhkey_be));
   2d5c8:	f01d fcd4 	bl	4af74 <sys_memcpy_swap.constprop.0>
   2d5cc:	e7eb      	b.n	2d5a6 <ecc_process+0x13e>
}
   2d5ce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2d5d0:	20003b98 	.word	0x20003b98
   2d5d4:	00051c50 	.word	0x00051c50
   2d5d8:	20006b07 	.word	0x20006b07
   2d5dc:	0005352a 	.word	0x0005352a
   2d5e0:	20006b27 	.word	0x20006b27

0002d5e4 <le_gen_dhkey>:
	cmd->events[0] &= ~0x80; /* LE Read Local P-256 PKey Compl */
	cmd->events[1] &= ~0x01; /* LE Generate DHKey Compl Event */
}

static uint8_t le_gen_dhkey(uint8_t *key, uint8_t key_type)
{
   2d5e4:	b570      	push	{r4, r5, r6, lr}
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   2d5e6:	4c21      	ldr	r4, [pc, #132]	; (2d66c <le_gen_dhkey+0x88>)
   2d5e8:	f3bf 8f5b 	dmb	ish
   2d5ec:	6823      	ldr	r3, [r4, #0]
   2d5ee:	f3bf 8f5b 	dmb	ish
	if (atomic_test_bit(flags, PENDING_PUB_KEY)) {
   2d5f2:	07da      	lsls	r2, r3, #31
{
   2d5f4:	4606      	mov	r6, r0
   2d5f6:	460d      	mov	r5, r1
	if (atomic_test_bit(flags, PENDING_PUB_KEY)) {
   2d5f8:	d501      	bpl.n	2d5fe <le_gen_dhkey+0x1a>
		return BT_HCI_ERR_CMD_DISALLOWED;
   2d5fa:	200c      	movs	r0, #12
			  key_type == BT_HCI_LE_KEY_TYPE_DEBUG);

	bt_long_wq_submit(&ecc_work);

	return BT_HCI_ERR_SUCCESS;
}
   2d5fc:	bd70      	pop	{r4, r5, r6, pc}
	if (key_type > BT_HCI_LE_KEY_TYPE_DEBUG) {
   2d5fe:	2901      	cmp	r1, #1
   2d600:	d831      	bhi.n	2d666 <le_gen_dhkey+0x82>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   2d602:	f3bf 8f5b 	dmb	ish
   2d606:	e854 3f00 	ldrex	r3, [r4]
   2d60a:	f043 0202 	orr.w	r2, r3, #2
   2d60e:	e844 2100 	strex	r1, r2, [r4]
   2d612:	2900      	cmp	r1, #0
   2d614:	d1f7      	bne.n	2d606 <le_gen_dhkey+0x22>
   2d616:	f3bf 8f5b 	dmb	ish
	if (atomic_test_and_set_bit(flags, PENDING_DHKEY)) {
   2d61a:	079b      	lsls	r3, r3, #30
   2d61c:	d4ed      	bmi.n	2d5fa <le_gen_dhkey+0x16>
	sys_memcpy_swap(ecc.public_key_be, key, BT_PUB_KEY_COORD_LEN);
   2d61e:	4814      	ldr	r0, [pc, #80]	; (2d670 <le_gen_dhkey+0x8c>)
   2d620:	4631      	mov	r1, r6
   2d622:	f01d fca7 	bl	4af74 <sys_memcpy_swap.constprop.0>
	sys_memcpy_swap(&ecc.public_key_be[BT_PUB_KEY_COORD_LEN], &key[BT_PUB_KEY_COORD_LEN],
   2d626:	4813      	ldr	r0, [pc, #76]	; (2d674 <le_gen_dhkey+0x90>)
   2d628:	f106 0120 	add.w	r1, r6, #32
   2d62c:	f01d fca2 	bl	4af74 <sys_memcpy_swap.constprop.0>
   2d630:	f3bf 8f5b 	dmb	ish
 */
static inline void atomic_set_bit_to(atomic_t *target, int bit, bool val)
{
	atomic_val_t mask = ATOMIC_MASK(bit);

	if (val) {
   2d634:	b175      	cbz	r5, 2d654 <le_gen_dhkey+0x70>
   2d636:	e854 3f00 	ldrex	r3, [r4]
   2d63a:	f043 0304 	orr.w	r3, r3, #4
   2d63e:	e844 3200 	strex	r2, r3, [r4]
   2d642:	2a00      	cmp	r2, #0
   2d644:	d1f7      	bne.n	2d636 <le_gen_dhkey+0x52>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   2d646:	f3bf 8f5b 	dmb	ish
	bt_long_wq_submit(&ecc_work);
   2d64a:	480b      	ldr	r0, [pc, #44]	; (2d678 <le_gen_dhkey+0x94>)
   2d64c:	f000 f962 	bl	2d914 <bt_long_wq_submit>
   2d650:	2000      	movs	r0, #0
   2d652:	e7d3      	b.n	2d5fc <le_gen_dhkey+0x18>
   2d654:	e854 3f00 	ldrex	r3, [r4]
   2d658:	f023 0304 	bic.w	r3, r3, #4
   2d65c:	e844 3200 	strex	r2, r3, [r4]
   2d660:	2a00      	cmp	r2, #0
   2d662:	d0f0      	beq.n	2d646 <le_gen_dhkey+0x62>
   2d664:	e7f6      	b.n	2d654 <le_gen_dhkey+0x70>
		return BT_HCI_ERR_INVALID_PARAM;
   2d666:	2012      	movs	r0, #18
   2d668:	e7c8      	b.n	2d5fc <le_gen_dhkey+0x18>
   2d66a:	bf00      	nop
   2d66c:	20003b98 	.word	0x20003b98
   2d670:	20006b27 	.word	0x20006b27
   2d674:	20006b47 	.word	0x20006b47
   2d678:	200005d4 	.word	0x200005d4

0002d67c <bt_hci_ecc_send>:

	send_cmd_status(BT_HCI_OP_LE_P256_PUBLIC_KEY, status);
}

int bt_hci_ecc_send(struct net_buf *buf)
{
   2d67c:	b570      	push	{r4, r5, r6, lr}
 *
 *  @return The BT_* type to of the buffer
 */
static inline enum bt_buf_type bt_buf_get_type(struct net_buf *buf)
{
	return (enum bt_buf_type)((struct bt_buf_data *)net_buf_user_data(buf))
   2d67e:	7d06      	ldrb	r6, [r0, #20]
   2d680:	4604      	mov	r4, r0
	if (bt_buf_get_type(buf) == BT_BUF_CMD) {
   2d682:	b976      	cbnz	r6, 2d6a2 <bt_hci_ecc_send+0x26>
		struct bt_hci_cmd_hdr *chdr = (void *)buf->data;
   2d684:	6883      	ldr	r3, [r0, #8]

		switch (sys_le16_to_cpu(chdr->opcode)) {
   2d686:	881d      	ldrh	r5, [r3, #0]
   2d688:	f242 0226 	movw	r2, #8230	; 0x2026
   2d68c:	4295      	cmp	r5, r2
   2d68e:	d045      	beq.n	2d71c <bt_hci_ecc_send+0xa0>
   2d690:	d80f      	bhi.n	2d6b2 <bt_hci_ecc_send+0x36>
   2d692:	f242 0201 	movw	r2, #8193	; 0x2001
   2d696:	4295      	cmp	r5, r2
   2d698:	d04f      	beq.n	2d73a <bt_hci_ecc_send+0xbe>
   2d69a:	f242 0325 	movw	r3, #8229	; 0x2025
   2d69e:	429d      	cmp	r5, r3
   2d6a0:	d013      	beq.n	2d6ca <bt_hci_ecc_send+0x4e>
		default:
			break;
		}
	}

	return bt_dev.drv->send(buf);
   2d6a2:	4b2a      	ldr	r3, [pc, #168]	; (2d74c <bt_hci_ecc_send+0xd0>)
   2d6a4:	f8d3 3154 	ldr.w	r3, [r3, #340]	; 0x154
   2d6a8:	4620      	mov	r0, r4
   2d6aa:	695b      	ldr	r3, [r3, #20]
}
   2d6ac:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return bt_dev.drv->send(buf);
   2d6b0:	4718      	bx	r3
		switch (sys_le16_to_cpu(chdr->opcode)) {
   2d6b2:	f242 035e 	movw	r3, #8286	; 0x205e
   2d6b6:	429d      	cmp	r5, r3
   2d6b8:	d1f3      	bne.n	2d6a2 <bt_hci_ecc_send+0x26>
 *
 * @return New beginning of the buffer data.
 */
static inline void *net_buf_pull(struct net_buf *buf, size_t len)
{
	return net_buf_simple_pull(&buf->b, len);
   2d6ba:	2103      	movs	r1, #3
   2d6bc:	3008      	adds	r0, #8
   2d6be:	f021 fba2 	bl	4ee06 <net_buf_simple_pull>
	cmd = (void *)buf->data;
   2d6c2:	68a0      	ldr	r0, [r4, #8]
	status = le_gen_dhkey(cmd->key, cmd->key_type);
   2d6c4:	f890 1040 	ldrb.w	r1, [r0, #64]	; 0x40
   2d6c8:	e02e      	b.n	2d728 <bt_hci_ecc_send+0xac>
   2d6ca:	2103      	movs	r1, #3
   2d6cc:	3008      	adds	r0, #8
   2d6ce:	f021 fb9a 	bl	4ee06 <net_buf_simple_pull>
	net_buf_unref(buf);
   2d6d2:	4620      	mov	r0, r4
   2d6d4:	f015 f8b8 	bl	42848 <net_buf_unref>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   2d6d8:	f3bf 8f5b 	dmb	ish
   2d6dc:	4b1c      	ldr	r3, [pc, #112]	; (2d750 <bt_hci_ecc_send+0xd4>)
   2d6de:	681a      	ldr	r2, [r3, #0]
   2d6e0:	f3bf 8f5b 	dmb	ish
	if (atomic_test_bit(flags, PENDING_DHKEY)) {
   2d6e4:	0792      	lsls	r2, r2, #30
   2d6e6:	d507      	bpl.n	2d6f8 <bt_hci_ecc_send+0x7c>
		status = BT_HCI_ERR_CMD_DISALLOWED;
   2d6e8:	260c      	movs	r6, #12
	send_cmd_status(BT_HCI_OP_LE_P256_PUBLIC_KEY, status);
   2d6ea:	4631      	mov	r1, r6
   2d6ec:	f242 0025 	movw	r0, #8229	; 0x2025
	send_cmd_status(BT_HCI_OP_LE_GENERATE_DHKEY, status);
   2d6f0:	f01d fc1c 	bl	4af2c <send_cmd_status>
}
   2d6f4:	2000      	movs	r0, #0
   2d6f6:	bd70      	pop	{r4, r5, r6, pc}
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   2d6f8:	f3bf 8f5b 	dmb	ish
   2d6fc:	e853 2f00 	ldrex	r2, [r3]
   2d700:	f042 0101 	orr.w	r1, r2, #1
   2d704:	e843 1000 	strex	r0, r1, [r3]
   2d708:	2800      	cmp	r0, #0
   2d70a:	d1f7      	bne.n	2d6fc <bt_hci_ecc_send+0x80>
   2d70c:	f3bf 8f5b 	dmb	ish
	} else if (atomic_test_and_set_bit(flags, PENDING_PUB_KEY)) {
   2d710:	07d3      	lsls	r3, r2, #31
   2d712:	d4e9      	bmi.n	2d6e8 <bt_hci_ecc_send+0x6c>
		bt_long_wq_submit(&ecc_work);
   2d714:	480f      	ldr	r0, [pc, #60]	; (2d754 <bt_hci_ecc_send+0xd8>)
   2d716:	f000 f8fd 	bl	2d914 <bt_long_wq_submit>
		status = BT_HCI_ERR_SUCCESS;
   2d71a:	e7e6      	b.n	2d6ea <bt_hci_ecc_send+0x6e>
   2d71c:	2103      	movs	r1, #3
   2d71e:	3008      	adds	r0, #8
   2d720:	f021 fb71 	bl	4ee06 <net_buf_simple_pull>
	status = le_gen_dhkey(cmd->key, BT_HCI_LE_KEY_TYPE_GENERATED);
   2d724:	68a0      	ldr	r0, [r4, #8]
   2d726:	4631      	mov	r1, r6
   2d728:	f7ff ff5c 	bl	2d5e4 <le_gen_dhkey>
   2d72c:	4606      	mov	r6, r0
	net_buf_unref(buf);
   2d72e:	4620      	mov	r0, r4
   2d730:	f015 f88a 	bl	42848 <net_buf_unref>
	send_cmd_status(BT_HCI_OP_LE_GENERATE_DHKEY, status);
   2d734:	4631      	mov	r1, r6
   2d736:	4628      	mov	r0, r5
   2d738:	e7da      	b.n	2d6f0 <bt_hci_ecc_send+0x74>
	cmd->events[0] &= ~0x80; /* LE Read Local P-256 PKey Compl */
   2d73a:	78da      	ldrb	r2, [r3, #3]
   2d73c:	f002 027f 	and.w	r2, r2, #127	; 0x7f
   2d740:	70da      	strb	r2, [r3, #3]
	cmd->events[1] &= ~0x01; /* LE Generate DHKey Compl Event */
   2d742:	791a      	ldrb	r2, [r3, #4]
   2d744:	f022 0201 	bic.w	r2, r2, #1
   2d748:	711a      	strb	r2, [r3, #4]
}
   2d74a:	e7aa      	b.n	2d6a2 <bt_hci_ecc_send+0x26>
   2d74c:	20000030 	.word	0x20000030
   2d750:	20003b98 	.word	0x20003b98
   2d754:	200005d4 	.word	0x200005d4

0002d758 <save_id>:
static void save_id(struct k_work *work)
{
	int err;
	BT_INFO("Saving ID");
	err = settings_save_one("bt/id", &bt_dev.id_addr,
				ID_DATA_LEN(bt_dev.id_addr));
   2d758:	4903      	ldr	r1, [pc, #12]	; (2d768 <save_id+0x10>)
	err = settings_save_one("bt/id", &bt_dev.id_addr,
   2d75a:	4804      	ldr	r0, [pc, #16]	; (2d76c <save_id+0x14>)
   2d75c:	79ca      	ldrb	r2, [r1, #7]
   2d75e:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
   2d762:	f7fe be9b 	b.w	2c49c <settings_save_one>
   2d766:	bf00      	nop
   2d768:	20000030 	.word	0x20000030
   2d76c:	0005354a 	.word	0x0005354a

0002d770 <set>:
{
   2d770:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   2d772:	4c1b      	ldr	r4, [pc, #108]	; (2d7e0 <set+0x70>)
   2d774:	f3bf 8f5b 	dmb	ish
   2d778:	461f      	mov	r7, r3
   2d77a:	6823      	ldr	r3, [r4, #0]
   2d77c:	f3bf 8f5b 	dmb	ish
   2d780:	4616      	mov	r6, r2
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_ENABLE)) {
   2d782:	07da      	lsls	r2, r3, #31
{
   2d784:	4605      	mov	r5, r0
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_ENABLE)) {
   2d786:	d524      	bpl.n	2d7d2 <set+0x62>
	if (!name) {
   2d788:	b918      	cbnz	r0, 2d792 <set+0x22>
		return -ENOENT;
   2d78a:	f06f 0001 	mvn.w	r0, #1
}
   2d78e:	b003      	add	sp, #12
   2d790:	bdf0      	pop	{r4, r5, r6, r7, pc}
	len = settings_name_next(name, &next);
   2d792:	a901      	add	r1, sp, #4
   2d794:	f01b ffe5 	bl	49762 <settings_name_next>
	if (!strncmp(name, "id", len)) {
   2d798:	4912      	ldr	r1, [pc, #72]	; (2d7e4 <set+0x74>)
	len = settings_name_next(name, &next);
   2d79a:	4602      	mov	r2, r0
	if (!strncmp(name, "id", len)) {
   2d79c:	4628      	mov	r0, r5
   2d79e:	f01d fb48 	bl	4ae32 <strncmp>
   2d7a2:	2800      	cmp	r0, #0
   2d7a4:	d1f1      	bne.n	2d78a <set+0x1a>
   2d7a6:	f3bf 8f5b 	dmb	ish
   2d7aa:	6823      	ldr	r3, [r4, #0]
   2d7ac:	f3bf 8f5b 	dmb	ish
		if (atomic_test_bit(bt_dev.flags, BT_DEV_PRESET_ID)) {
   2d7b0:	f3c3 05c0 	ubfx	r5, r3, #3, #1
   2d7b4:	071b      	lsls	r3, r3, #28
   2d7b6:	d40c      	bmi.n	2d7d2 <set+0x62>
		len = read_cb(cb_arg, &bt_dev.id_addr, sizeof(bt_dev.id_addr));
   2d7b8:	3ccc      	subs	r4, #204	; 0xcc
   2d7ba:	2207      	movs	r2, #7
   2d7bc:	4621      	mov	r1, r4
   2d7be:	4638      	mov	r0, r7
   2d7c0:	47b0      	blx	r6
		if (len < sizeof(bt_dev.id_addr[0])) {
   2d7c2:	2806      	cmp	r0, #6
   2d7c4:	d807      	bhi.n	2d7d6 <set+0x66>
			(void)memset(bt_dev.id_addr, 0,
   2d7c6:	2207      	movs	r2, #7
   2d7c8:	4629      	mov	r1, r5
   2d7ca:	4620      	mov	r0, r4
   2d7cc:	f01d fb60 	bl	4ae90 <memset>
			bt_dev.id_count = 0U;
   2d7d0:	71e5      	strb	r5, [r4, #7]
		return 0;
   2d7d2:	2000      	movs	r0, #0
   2d7d4:	e7db      	b.n	2d78e <set+0x1e>
			bt_dev.id_count = len / sizeof(bt_dev.id_addr[0]);
   2d7d6:	2307      	movs	r3, #7
   2d7d8:	fbb0 f0f3 	udiv	r0, r0, r3
   2d7dc:	71e0      	strb	r0, [r4, #7]
			for (i = 0; i < bt_dev.id_count; i++) {
   2d7de:	e7f8      	b.n	2d7d2 <set+0x62>
   2d7e0:	200000fc 	.word	0x200000fc
   2d7e4:	000531e8 	.word	0x000531e8

0002d7e8 <bt_settings_encode_key>:
{
   2d7e8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2d7ec:	b088      	sub	sp, #32
		snprintk(path, path_size,
   2d7ee:	799c      	ldrb	r4, [r3, #6]
{
   2d7f0:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
		snprintk(path, path_size,
   2d7f4:	795d      	ldrb	r5, [r3, #5]
   2d7f6:	791e      	ldrb	r6, [r3, #4]
   2d7f8:	78df      	ldrb	r7, [r3, #3]
   2d7fa:	f893 c002 	ldrb.w	ip, [r3, #2]
   2d7fe:	f893 e001 	ldrb.w	lr, [r3, #1]
   2d802:	781b      	ldrb	r3, [r3, #0]
	if (key) {
   2d804:	f1b8 0f00 	cmp.w	r8, #0
   2d808:	d00e      	beq.n	2d828 <bt_settings_encode_key+0x40>
		snprintk(path, path_size,
   2d80a:	e9cd 3806 	strd	r3, r8, [sp, #24]
   2d80e:	e9cd ce04 	strd	ip, lr, [sp, #16]
   2d812:	4613      	mov	r3, r2
   2d814:	e9cd 6702 	strd	r6, r7, [sp, #8]
   2d818:	e9cd 4500 	strd	r4, r5, [sp]
   2d81c:	4a08      	ldr	r2, [pc, #32]	; (2d840 <bt_settings_encode_key+0x58>)
   2d81e:	f01b f93e 	bl	48a9e <snprintk>
}
   2d822:	b008      	add	sp, #32
   2d824:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		snprintk(path, path_size,
   2d828:	e9cd e305 	strd	lr, r3, [sp, #20]
   2d82c:	e9cd 7c03 	strd	r7, ip, [sp, #12]
   2d830:	4613      	mov	r3, r2
   2d832:	e9cd 5601 	strd	r5, r6, [sp, #4]
   2d836:	4a03      	ldr	r2, [pc, #12]	; (2d844 <bt_settings_encode_key+0x5c>)
   2d838:	9400      	str	r4, [sp, #0]
   2d83a:	f01b f930 	bl	48a9e <snprintk>
}
   2d83e:	e7f0      	b.n	2d822 <bt_settings_encode_key+0x3a>
   2d840:	00053550 	.word	0x00053550
   2d844:	00053574 	.word	0x00053574

0002d848 <bt_settings_save_id>:

K_WORK_DEFINE(save_id_work, save_id);

void bt_settings_save_id(void)
{
	k_work_submit(&save_id_work);
   2d848:	4801      	ldr	r0, [pc, #4]	; (2d850 <bt_settings_save_id+0x8>)
   2d84a:	f019 be33 	b.w	474b4 <k_work_submit>
   2d84e:	bf00      	nop
   2d850:	200005e4 	.word	0x200005e4

0002d854 <commit>:
}

static int commit(void)
{
   2d854:	b570      	push	{r4, r5, r6, lr}
   2d856:	4c1a      	ldr	r4, [pc, #104]	; (2d8c0 <commit+0x6c>)
   2d858:	f3bf 8f5b 	dmb	ish
   2d85c:	6823      	ldr	r3, [r4, #0]
   2d85e:	f3bf 8f5b 	dmb	ish
	int err;

	BT_DBG("");

	if (!atomic_test_bit(bt_dev.flags, BT_DEV_ENABLE)) {
   2d862:	f013 0f01 	tst.w	r3, #1
   2d866:	4625      	mov	r5, r4
   2d868:	d01d      	beq.n	2d8a6 <commit+0x52>
#if defined(CONFIG_BT_DEVICE_NAME_DYNAMIC)
	if (bt_dev.name[0] == '\0') {
		bt_set_name(CONFIG_BT_DEVICE_NAME);
	}
#endif
	if (!bt_dev.id_count) {
   2d86a:	f814 3cc5 	ldrb.w	r3, [r4, #-197]
   2d86e:	f1a4 06cc 	sub.w	r6, r4, #204	; 0xcc
   2d872:	b1d3      	cbz	r3, 2d8aa <commit+0x56>
   2d874:	f3bf 8f5b 	dmb	ish
   2d878:	6823      	ldr	r3, [r4, #0]
   2d87a:	f3bf 8f5b 	dmb	ish
			BT_ERR("Unable to setup an identity address");
			return err;
		}
	}

	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
   2d87e:	075a      	lsls	r2, r3, #29
   2d880:	d401      	bmi.n	2d886 <commit+0x32>
		bt_finalize_init();
   2d882:	f000 ff13 	bl	2e6ac <bt_finalize_init>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   2d886:	f3bf 8f5b 	dmb	ish
   2d88a:	e855 3f00 	ldrex	r3, [r5]
   2d88e:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
   2d892:	e845 2100 	strex	r1, r2, [r5]
   2d896:	2900      	cmp	r1, #0
   2d898:	d1f7      	bne.n	2d88a <commit+0x36>
   2d89a:	f3bf 8f5b 	dmb	ish
	}

	/* If any part of the Identity Information of the device has been
	 * generated this Identity needs to be saved persistently.
	 */
	if (atomic_test_and_clear_bit(bt_dev.flags, BT_DEV_STORE_ID)) {
   2d89e:	03db      	lsls	r3, r3, #15
   2d8a0:	d501      	bpl.n	2d8a6 <commit+0x52>
		BT_DBG("Storing Identity Information");
		bt_settings_save_id();
   2d8a2:	f7ff ffd1 	bl	2d848 <bt_settings_save_id>
		return 0;
   2d8a6:	2000      	movs	r0, #0
   2d8a8:	e009      	b.n	2d8be <commit+0x6a>
		err = bt_setup_public_id_addr();
   2d8aa:	f001 f9fd 	bl	2eca8 <bt_setup_public_id_addr>
		if (err) {
   2d8ae:	b930      	cbnz	r0, 2d8be <commit+0x6a>
	if (!bt_dev.id_count) {
   2d8b0:	79f3      	ldrb	r3, [r6, #7]
   2d8b2:	2b00      	cmp	r3, #0
   2d8b4:	d1de      	bne.n	2d874 <commit+0x20>
		err = bt_setup_random_id_addr();
   2d8b6:	f001 fa37 	bl	2ed28 <bt_setup_random_id_addr>
		if (err) {
   2d8ba:	2800      	cmp	r0, #0
   2d8bc:	d0da      	beq.n	2d874 <commit+0x20>
	}

	return 0;
}
   2d8be:	bd70      	pop	{r4, r5, r6, pc}
   2d8c0:	200000fc 	.word	0x200000fc

0002d8c4 <long_wq_init>:
{
	return k_work_submit_to_queue(&bt_long_wq, work);
}

static int long_wq_init(const struct device *d)
{
   2d8c4:	b530      	push	{r4, r5, lr}
	ARG_UNUSED(d);

	const struct k_work_queue_config cfg = {.name = "BT_LW_WQ"};

	k_work_queue_init(&bt_long_wq);
   2d8c6:	4d0a      	ldr	r5, [pc, #40]	; (2d8f0 <long_wq_init+0x2c>)
	const struct k_work_queue_config cfg = {.name = "BT_LW_WQ"};
   2d8c8:	4b0a      	ldr	r3, [pc, #40]	; (2d8f4 <long_wq_init+0x30>)
{
   2d8ca:	b085      	sub	sp, #20
	const struct k_work_queue_config cfg = {.name = "BT_LW_WQ"};
   2d8cc:	2400      	movs	r4, #0
	k_work_queue_init(&bt_long_wq);
   2d8ce:	4628      	mov	r0, r5
	const struct k_work_queue_config cfg = {.name = "BT_LW_WQ"};
   2d8d0:	9302      	str	r3, [sp, #8]
   2d8d2:	9403      	str	r4, [sp, #12]
	k_work_queue_init(&bt_long_wq);
   2d8d4:	f022 fb90 	bl	4fff8 <k_work_queue_init>

	k_work_queue_start(&bt_long_wq, bt_lw_stack_area,
   2d8d8:	ab02      	add	r3, sp, #8
   2d8da:	9300      	str	r3, [sp, #0]
   2d8dc:	4628      	mov	r0, r5
   2d8de:	4906      	ldr	r1, [pc, #24]	; (2d8f8 <long_wq_init+0x34>)
   2d8e0:	230a      	movs	r3, #10
   2d8e2:	f44f 62a3 	mov.w	r2, #1304	; 0x518
   2d8e6:	f019 fdeb 	bl	474c0 <k_work_queue_start>
			   K_THREAD_STACK_SIZEOF(bt_lw_stack_area),
			   CONFIG_BT_LONG_WQ_PRIO, &cfg);

	return 0;
}
   2d8ea:	4620      	mov	r0, r4
   2d8ec:	b005      	add	sp, #20
   2d8ee:	bd30      	pop	{r4, r5, pc}
   2d8f0:	20001708 	.word	0x20001708
   2d8f4:	00053595 	.word	0x00053595
   2d8f8:	200073c8 	.word	0x200073c8

0002d8fc <bt_long_wq_schedule>:
{
   2d8fc:	4601      	mov	r1, r0
	return k_work_schedule_for_queue(&bt_long_wq, dwork, timeout);
   2d8fe:	4801      	ldr	r0, [pc, #4]	; (2d904 <bt_long_wq_schedule+0x8>)
   2d900:	f019 be16 	b.w	47530 <k_work_schedule_for_queue>
   2d904:	20001708 	.word	0x20001708

0002d908 <bt_long_wq_reschedule>:
{
   2d908:	4601      	mov	r1, r0
	return k_work_reschedule_for_queue(&bt_long_wq, dwork, timeout);
   2d90a:	4801      	ldr	r0, [pc, #4]	; (2d910 <bt_long_wq_reschedule+0x8>)
   2d90c:	f019 be40 	b.w	47590 <k_work_reschedule_for_queue>
   2d910:	20001708 	.word	0x20001708

0002d914 <bt_long_wq_submit>:
{
   2d914:	4601      	mov	r1, r0
	return k_work_submit_to_queue(&bt_long_wq, work);
   2d916:	4801      	ldr	r0, [pc, #4]	; (2d91c <bt_long_wq_submit+0x8>)
   2d918:	f022 bb5d 	b.w	4ffd6 <k_work_submit_to_queue>
   2d91c:	20001708 	.word	0x20001708

0002d920 <uuid_to_uuid128>:
	.val = { BT_UUID_128_ENCODE(
		0x00000000, 0x0000, 0x1000, 0x8000, 0x00805F9B34FB) }
};

static void uuid_to_uuid128(const struct bt_uuid *src, struct bt_uuid_128 *dst)
{
   2d920:	b430      	push	{r4, r5}
   2d922:	4603      	mov	r3, r0
   2d924:	4608      	mov	r0, r1
	switch (src->type) {
   2d926:	781a      	ldrb	r2, [r3, #0]
   2d928:	2a01      	cmp	r2, #1
   2d92a:	d013      	beq.n	2d954 <uuid_to_uuid128+0x34>
   2d92c:	2a02      	cmp	r2, #2
   2d92e:	d026      	beq.n	2d97e <uuid_to_uuid128+0x5e>
   2d930:	b972      	cbnz	r2, 2d950 <uuid_to_uuid128+0x30>
	case BT_UUID_TYPE_16:
		*dst = uuid128_base;
   2d932:	4a15      	ldr	r2, [pc, #84]	; (2d988 <uuid_to_uuid128+0x68>)
   2d934:	f102 0410 	add.w	r4, r2, #16
   2d938:	f852 5b04 	ldr.w	r5, [r2], #4
   2d93c:	f841 5b04 	str.w	r5, [r1], #4
   2d940:	42a2      	cmp	r2, r4
   2d942:	d1f9      	bne.n	2d938 <uuid_to_uuid128+0x18>
   2d944:	7812      	ldrb	r2, [r2, #0]
   2d946:	700a      	strb	r2, [r1, #0]
		sys_put_le16(BT_UUID_16(src)->val,
   2d948:	885b      	ldrh	r3, [r3, #2]
	dst[0] = val;
   2d94a:	7343      	strb	r3, [r0, #13]
	dst[1] = val >> 8;
   2d94c:	0a1b      	lsrs	r3, r3, #8
   2d94e:	7383      	strb	r3, [r0, #14]
		return;
	case BT_UUID_TYPE_128:
		memcpy(dst, src, sizeof(*dst));
		return;
	}
}
   2d950:	bc30      	pop	{r4, r5}
   2d952:	4770      	bx	lr
		*dst = uuid128_base;
   2d954:	4a0c      	ldr	r2, [pc, #48]	; (2d988 <uuid_to_uuid128+0x68>)
   2d956:	f102 0410 	add.w	r4, r2, #16
   2d95a:	f852 5b04 	ldr.w	r5, [r2], #4
   2d95e:	f841 5b04 	str.w	r5, [r1], #4
   2d962:	42a2      	cmp	r2, r4
   2d964:	d1f9      	bne.n	2d95a <uuid_to_uuid128+0x3a>
   2d966:	7812      	ldrb	r2, [r2, #0]
   2d968:	700a      	strb	r2, [r1, #0]
		sys_put_le32(BT_UUID_32(src)->val,
   2d96a:	685b      	ldr	r3, [r3, #4]
	dst[0] = val;
   2d96c:	7343      	strb	r3, [r0, #13]
	dst[1] = val >> 8;
   2d96e:	f3c3 2207 	ubfx	r2, r3, #8, #8
	sys_put_le16(val >> 16, &dst[2]);
   2d972:	0c1b      	lsrs	r3, r3, #16
	dst[0] = val;
   2d974:	73c3      	strb	r3, [r0, #15]
	dst[1] = val >> 8;
   2d976:	0a1b      	lsrs	r3, r3, #8
   2d978:	7382      	strb	r2, [r0, #14]
   2d97a:	7403      	strb	r3, [r0, #16]
}
   2d97c:	e7e8      	b.n	2d950 <uuid_to_uuid128+0x30>
}
   2d97e:	bc30      	pop	{r4, r5}
		memcpy(dst, src, sizeof(*dst));
   2d980:	2211      	movs	r2, #17
   2d982:	4619      	mov	r1, r3
   2d984:	f01d ba79 	b.w	4ae7a <memcpy>
   2d988:	000535c0 	.word	0x000535c0

0002d98c <bt_uuid_to_str>:
	}
	return true;
}

void bt_uuid_to_str(const struct bt_uuid *uuid, char *str, size_t len)
{
   2d98c:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint32_t tmp1, tmp5;
	uint16_t tmp0, tmp2, tmp3, tmp4;

	switch (uuid->type) {
   2d98e:	7805      	ldrb	r5, [r0, #0]
   2d990:	2d01      	cmp	r5, #1
{
   2d992:	b08b      	sub	sp, #44	; 0x2c
   2d994:	4604      	mov	r4, r0
   2d996:	460e      	mov	r6, r1
   2d998:	4617      	mov	r7, r2
	switch (uuid->type) {
   2d99a:	d00c      	beq.n	2d9b6 <bt_uuid_to_str+0x2a>
   2d99c:	2d02      	cmp	r5, #2
   2d99e:	d00d      	beq.n	2d9bc <bt_uuid_to_str+0x30>
   2d9a0:	2d00      	cmp	r5, #0
   2d9a2:	d144      	bne.n	2da2e <bt_uuid_to_str+0xa2>
	case BT_UUID_TYPE_16:
		snprintk(str, len, "%04x", BT_UUID_16(uuid)->val);
   2d9a4:	8843      	ldrh	r3, [r0, #2]
   2d9a6:	4a25      	ldr	r2, [pc, #148]	; (2da3c <bt_uuid_to_str+0xb0>)
		break;
	case BT_UUID_TYPE_32:
		snprintk(str, len, "%08x", BT_UUID_32(uuid)->val);
   2d9a8:	4639      	mov	r1, r7
   2d9aa:	4630      	mov	r0, r6
		break;
	default:
		(void)memset(str, 0, len);
		return;
	}
}
   2d9ac:	b00b      	add	sp, #44	; 0x2c
   2d9ae:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		snprintk(str, len, "%08x", BT_UUID_32(uuid)->val);
   2d9b2:	f01b b874 	b.w	48a9e <snprintk>
   2d9b6:	6843      	ldr	r3, [r0, #4]
   2d9b8:	4a21      	ldr	r2, [pc, #132]	; (2da40 <bt_uuid_to_str+0xb4>)
   2d9ba:	e7f5      	b.n	2d9a8 <bt_uuid_to_str+0x1c>
		memcpy(&tmp0, &BT_UUID_128(uuid)->val[0], sizeof(tmp0));
   2d9bc:	462a      	mov	r2, r5
   2d9be:	1c41      	adds	r1, r0, #1
   2d9c0:	a806      	add	r0, sp, #24
   2d9c2:	f01d fa5a 	bl	4ae7a <memcpy>
		memcpy(&tmp1, &BT_UUID_128(uuid)->val[2], sizeof(tmp1));
   2d9c6:	1ce1      	adds	r1, r4, #3
   2d9c8:	2204      	movs	r2, #4
   2d9ca:	a808      	add	r0, sp, #32
   2d9cc:	f01d fa55 	bl	4ae7a <memcpy>
		memcpy(&tmp2, &BT_UUID_128(uuid)->val[6], sizeof(tmp2));
   2d9d0:	462a      	mov	r2, r5
   2d9d2:	1de1      	adds	r1, r4, #7
   2d9d4:	f10d 001a 	add.w	r0, sp, #26
   2d9d8:	f01d fa4f 	bl	4ae7a <memcpy>
		memcpy(&tmp3, &BT_UUID_128(uuid)->val[8], sizeof(tmp3));
   2d9dc:	462a      	mov	r2, r5
   2d9de:	f104 0109 	add.w	r1, r4, #9
   2d9e2:	a807      	add	r0, sp, #28
   2d9e4:	f01d fa49 	bl	4ae7a <memcpy>
		memcpy(&tmp4, &BT_UUID_128(uuid)->val[10], sizeof(tmp4));
   2d9e8:	462a      	mov	r2, r5
   2d9ea:	f104 010b 	add.w	r1, r4, #11
   2d9ee:	f10d 001e 	add.w	r0, sp, #30
   2d9f2:	f01d fa42 	bl	4ae7a <memcpy>
		memcpy(&tmp5, &BT_UUID_128(uuid)->val[12], sizeof(tmp5));
   2d9f6:	f104 010d 	add.w	r1, r4, #13
   2d9fa:	2204      	movs	r2, #4
   2d9fc:	a809      	add	r0, sp, #36	; 0x24
   2d9fe:	f01d fa3c 	bl	4ae7a <memcpy>
		snprintk(str, len, "%08x-%04x-%04x-%04x-%08x%04x",
   2da02:	f8bd 3018 	ldrh.w	r3, [sp, #24]
   2da06:	9304      	str	r3, [sp, #16]
   2da08:	9b08      	ldr	r3, [sp, #32]
   2da0a:	9303      	str	r3, [sp, #12]
   2da0c:	f8bd 301a 	ldrh.w	r3, [sp, #26]
   2da10:	9302      	str	r3, [sp, #8]
   2da12:	f8bd 301c 	ldrh.w	r3, [sp, #28]
   2da16:	9301      	str	r3, [sp, #4]
   2da18:	f8bd 301e 	ldrh.w	r3, [sp, #30]
   2da1c:	9300      	str	r3, [sp, #0]
   2da1e:	4a09      	ldr	r2, [pc, #36]	; (2da44 <bt_uuid_to_str+0xb8>)
   2da20:	9b09      	ldr	r3, [sp, #36]	; 0x24
   2da22:	4639      	mov	r1, r7
   2da24:	4630      	mov	r0, r6
   2da26:	f01b f83a 	bl	48a9e <snprintk>
}
   2da2a:	b00b      	add	sp, #44	; 0x2c
   2da2c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		(void)memset(str, 0, len);
   2da2e:	2100      	movs	r1, #0
   2da30:	4630      	mov	r0, r6
}
   2da32:	b00b      	add	sp, #44	; 0x2c
   2da34:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		(void)memset(str, 0, len);
   2da38:	f01d ba2a 	b.w	4ae90 <memset>
   2da3c:	000535bb 	.word	0x000535bb
   2da40:	0005359e 	.word	0x0005359e
   2da44:	000535a3 	.word	0x000535a3

0002da48 <bt_buf_get_rx>:
			  BT_BUF_RX_SIZE, 8,
			  NULL);
#endif /* CONFIG_BT_HCI_ACL_FLOW_CONTROL */

struct net_buf *bt_buf_get_rx(enum bt_buf_type type, k_timeout_t timeout)
{
   2da48:	b538      	push	{r3, r4, r5, lr}
   2da4a:	4605      	mov	r5, r0
	return net_buf_alloc_fixed(pool, timeout);
   2da4c:	4805      	ldr	r0, [pc, #20]	; (2da64 <bt_buf_get_rx+0x1c>)
   2da4e:	f021 f949 	bl	4ece4 <net_buf_alloc_fixed>
	}
#else
	buf = net_buf_alloc(&hci_rx_pool, timeout);
#endif

	if (buf) {
   2da52:	4604      	mov	r4, r0
   2da54:	b120      	cbz	r0, 2da60 <bt_buf_get_rx+0x18>
	net_buf_simple_reserve(&buf->b, reserve);
   2da56:	2100      	movs	r1, #0
   2da58:	3008      	adds	r0, #8
   2da5a:	f021 f968 	bl	4ed2e <net_buf_simple_reserve>
	((struct bt_buf_data *)net_buf_user_data(buf))->type = type;
   2da5e:	7525      	strb	r5, [r4, #20]
		net_buf_reserve(buf, BT_BUF_RESERVE);
		bt_buf_set_type(buf, type);
	}

	return buf;
}
   2da60:	4620      	mov	r0, r4
   2da62:	bd38      	pop	{r3, r4, r5, pc}
   2da64:	20001394 	.word	0x20001394

0002da68 <bt_buf_get_cmd_complete>:

struct net_buf *bt_buf_get_cmd_complete(k_timeout_t timeout)
{
   2da68:	b510      	push	{r4, lr}
   2da6a:	460b      	mov	r3, r1
	struct net_buf *buf;

	if (bt_dev.sent_cmd) {
   2da6c:	490a      	ldr	r1, [pc, #40]	; (2da98 <bt_buf_get_cmd_complete+0x30>)
{
   2da6e:	4602      	mov	r2, r0
	if (bt_dev.sent_cmd) {
   2da70:	f8d1 0138 	ldr.w	r0, [r1, #312]	; 0x138
   2da74:	b920      	cbnz	r0, 2da80 <bt_buf_get_cmd_complete+0x18>

		return buf;
	}

	return bt_buf_get_rx(BT_BUF_EVT, timeout);
}
   2da76:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return bt_buf_get_rx(BT_BUF_EVT, timeout);
   2da7a:	2001      	movs	r0, #1
   2da7c:	f7ff bfe4 	b.w	2da48 <bt_buf_get_rx>
		buf = net_buf_ref(bt_dev.sent_cmd);
   2da80:	f021 f966 	bl	4ed50 <net_buf_ref>
   2da84:	2301      	movs	r3, #1
		buf->len = 0U;
   2da86:	2100      	movs	r1, #0
   2da88:	7503      	strb	r3, [r0, #20]
   2da8a:	8181      	strh	r1, [r0, #12]
		buf = net_buf_ref(bt_dev.sent_cmd);
   2da8c:	4604      	mov	r4, r0
   2da8e:	3008      	adds	r0, #8
   2da90:	f021 f94d 	bl	4ed2e <net_buf_simple_reserve>
}
   2da94:	4620      	mov	r0, r4
   2da96:	bd10      	pop	{r4, pc}
   2da98:	20000030 	.word	0x20000030

0002da9c <bt_buf_get_evt>:

struct net_buf *bt_buf_get_evt(uint8_t evt, bool discardable,
			       k_timeout_t timeout)
{
   2da9c:	b570      	push	{r4, r5, r6, lr}
   2da9e:	4604      	mov	r4, r0
	switch (evt) {
   2daa0:	2c0f      	cmp	r4, #15
{
   2daa2:	460d      	mov	r5, r1
   2daa4:	4610      	mov	r0, r2
   2daa6:	4619      	mov	r1, r3
	switch (evt) {
   2daa8:	d805      	bhi.n	2dab6 <bt_buf_get_evt+0x1a>
   2daaa:	2c0d      	cmp	r4, #13
   2daac:	d90d      	bls.n	2daca <bt_buf_get_evt+0x2e>
			return buf;
		}

		return bt_buf_get_rx(BT_BUF_EVT, timeout);
	}
}
   2daae:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return bt_buf_get_cmd_complete(timeout);
   2dab2:	f7ff bfd9 	b.w	2da68 <bt_buf_get_cmd_complete>
	switch (evt) {
   2dab6:	2c13      	cmp	r4, #19
   2dab8:	d107      	bne.n	2daca <bt_buf_get_evt+0x2e>
	return net_buf_alloc_fixed(pool, timeout);
   2daba:	480c      	ldr	r0, [pc, #48]	; (2daec <bt_buf_get_evt+0x50>)
   2dabc:	f021 f912 	bl	4ece4 <net_buf_alloc_fixed>
			if (buf) {
   2dac0:	4604      	mov	r4, r0
   2dac2:	b938      	cbnz	r0, 2dad4 <bt_buf_get_evt+0x38>
{
   2dac4:	2400      	movs	r4, #0
}
   2dac6:	4620      	mov	r0, r4
   2dac8:	bd70      	pop	{r4, r5, r6, pc}
   2daca:	4602      	mov	r2, r0
   2dacc:	460b      	mov	r3, r1
		if (discardable) {
   2dace:	b145      	cbz	r5, 2dae2 <bt_buf_get_evt+0x46>
   2dad0:	4807      	ldr	r0, [pc, #28]	; (2daf0 <bt_buf_get_evt+0x54>)
   2dad2:	e7f3      	b.n	2dabc <bt_buf_get_evt+0x20>
	net_buf_simple_reserve(&buf->b, reserve);
   2dad4:	2100      	movs	r1, #0
   2dad6:	3008      	adds	r0, #8
   2dad8:	f021 f929 	bl	4ed2e <net_buf_simple_reserve>
   2dadc:	2301      	movs	r3, #1
   2dade:	7523      	strb	r3, [r4, #20]
}
   2dae0:	e7f1      	b.n	2dac6 <bt_buf_get_evt+0x2a>
}
   2dae2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return bt_buf_get_rx(BT_BUF_EVT, timeout);
   2dae6:	2001      	movs	r0, #1
   2dae8:	f7ff bfae 	b.w	2da48 <bt_buf_get_rx>
   2daec:	200013c0 	.word	0x200013c0
   2daf0:	20001310 	.word	0x20001310

0002daf4 <unpair>:
{
   2daf4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2daf6:	4606      	mov	r6, r0
   2daf8:	460f      	mov	r7, r1
	struct bt_conn *conn = bt_conn_lookup_addr_le(id, addr);
   2dafa:	f002 fb37 	bl	3016c <bt_conn_lookup_addr_le>
	if (conn) {
   2dafe:	4604      	mov	r4, r0
   2db00:	b140      	cbz	r0, 2db14 <unpair+0x20>
		if (conn->type == BT_CONN_TYPE_LE) {
   2db02:	7883      	ldrb	r3, [r0, #2]
   2db04:	2b01      	cmp	r3, #1
   2db06:	d024      	beq.n	2db52 <unpair+0x5e>
		bt_conn_disconnect(conn, BT_HCI_ERR_REMOTE_USER_TERM_CONN);
   2db08:	2113      	movs	r1, #19
   2db0a:	f01e fa37 	bl	4bf7c <bt_conn_disconnect>
		bt_conn_unref(conn);
   2db0e:	4620      	mov	r0, r4
   2db10:	f01e f959 	bl	4bdc6 <bt_conn_unref>
			keys = bt_keys_find_addr(id, addr);
   2db14:	4639      	mov	r1, r7
   2db16:	4630      	mov	r0, r6
   2db18:	f006 fc38 	bl	3438c <bt_keys_find_addr>
		if (keys) {
   2db1c:	4605      	mov	r5, r0
   2db1e:	bb28      	cbnz	r0, 2db6c <unpair+0x78>
	bt_gatt_clear(id, addr);
   2db20:	4639      	mov	r1, r7
   2db22:	4630      	mov	r0, r6
   2db24:	f005 f9b4 	bl	32e90 <bt_gatt_clear>
	return list->head;
   2db28:	4b14      	ldr	r3, [pc, #80]	; (2db7c <unpair+0x88>)
   2db2a:	681b      	ldr	r3, [r3, #0]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&bt_auth_info_cbs, listener,
   2db2c:	b323      	cbz	r3, 2db78 <unpair+0x84>
	return node->next;
   2db2e:	681c      	ldr	r4, [r3, #0]
   2db30:	b104      	cbz	r4, 2db34 <unpair+0x40>
   2db32:	3c0c      	subs	r4, #12
		if (listener->bond_deleted) {
   2db34:	f853 3c04 	ldr.w	r3, [r3, #-4]
   2db38:	b113      	cbz	r3, 2db40 <unpair+0x4c>
			listener->bond_deleted(id, addr);
   2db3a:	4639      	mov	r1, r7
   2db3c:	4630      	mov	r0, r6
   2db3e:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&bt_auth_info_cbs, listener,
   2db40:	b1d4      	cbz	r4, 2db78 <unpair+0x84>
   2db42:	4623      	mov	r3, r4
   2db44:	68e4      	ldr	r4, [r4, #12]
   2db46:	689b      	ldr	r3, [r3, #8]
   2db48:	b1a4      	cbz	r4, 2db74 <unpair+0x80>
   2db4a:	3c0c      	subs	r4, #12
		if (listener->bond_deleted) {
   2db4c:	2b00      	cmp	r3, #0
   2db4e:	d1f4      	bne.n	2db3a <unpair+0x46>
   2db50:	e7f7      	b.n	2db42 <unpair+0x4e>
			conn->le.keys = NULL;
   2db52:	2300      	movs	r3, #0
			keys = conn->le.keys;
   2db54:	f8d0 50b4 	ldr.w	r5, [r0, #180]	; 0xb4
			conn->le.keys = NULL;
   2db58:	f8c0 30b4 	str.w	r3, [r0, #180]	; 0xb4
		bt_conn_disconnect(conn, BT_HCI_ERR_REMOTE_USER_TERM_CONN);
   2db5c:	2113      	movs	r1, #19
   2db5e:	f01e fa0d 	bl	4bf7c <bt_conn_disconnect>
		bt_conn_unref(conn);
   2db62:	4620      	mov	r0, r4
   2db64:	f01e f92f 	bl	4bdc6 <bt_conn_unref>
		if (!keys) {
   2db68:	2d00      	cmp	r5, #0
   2db6a:	d0d3      	beq.n	2db14 <unpair+0x20>
			bt_keys_clear(keys);
   2db6c:	4628      	mov	r0, r5
   2db6e:	f006 fc2b 	bl	343c8 <bt_keys_clear>
   2db72:	e7d5      	b.n	2db20 <unpair+0x2c>
		if (listener->bond_deleted) {
   2db74:	2b00      	cmp	r3, #0
   2db76:	d1e0      	bne.n	2db3a <unpair+0x46>
}
   2db78:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2db7a:	bf00      	nop
   2db7c:	20003c04 	.word	0x20003c04

0002db80 <hci_disconn_complete_prio>:
{
   2db80:	b538      	push	{r3, r4, r5, lr}
	struct bt_hci_evt_disconn_complete *evt = (void *)buf->data;
   2db82:	6883      	ldr	r3, [r0, #8]
	uint16_t handle = sys_le16_to_cpu(evt->handle);
   2db84:	f8b3 4001 	ldrh.w	r4, [r3, #1]
	if (evt->status) {
   2db88:	781b      	ldrb	r3, [r3, #0]
   2db8a:	b98b      	cbnz	r3, 2dbb0 <hci_disconn_complete_prio+0x30>
	conn = bt_conn_lookup_handle(handle);
   2db8c:	4620      	mov	r0, r4
   2db8e:	f002 f8d9 	bl	2fd44 <bt_conn_lookup_handle>
	if (!conn) {
   2db92:	4605      	mov	r5, r0
   2db94:	b968      	cbnz	r0, 2dbb2 <hci_disconn_complete_prio+0x32>
			disconnected_handles[i] = ~BT_ACL_HANDLE_MASK | handle;
   2db96:	ea6f 5004 	mvn.w	r0, r4, lsl #20
   2db9a:	4a0a      	ldr	r2, [pc, #40]	; (2dbc4 <hci_disconn_complete_prio+0x44>)
	if (!conn) {
   2db9c:	2306      	movs	r3, #6
			disconnected_handles[i] = ~BT_ACL_HANDLE_MASK | handle;
   2db9e:	ea6f 5010 	mvn.w	r0, r0, lsr #20
		if (!disconnected_handles[i]) {
   2dba2:	f832 1b02 	ldrh.w	r1, [r2], #2
   2dba6:	b909      	cbnz	r1, 2dbac <hci_disconn_complete_prio+0x2c>
			disconnected_handles[i] = ~BT_ACL_HANDLE_MASK | handle;
   2dba8:	f822 0c02 	strh.w	r0, [r2, #-2]
	for (int i = 0; i < ARRAY_SIZE(disconnected_handles); i++) {
   2dbac:	3b01      	subs	r3, #1
   2dbae:	d1f8      	bne.n	2dba2 <hci_disconn_complete_prio+0x22>
}
   2dbb0:	bd38      	pop	{r3, r4, r5, pc}
	bt_conn_set_state(conn, BT_CONN_DISCONNECT_COMPLETE);
   2dbb2:	2101      	movs	r1, #1
   2dbb4:	f002 f8ce 	bl	2fd54 <bt_conn_set_state>
	bt_conn_unref(conn);
   2dbb8:	4628      	mov	r0, r5
}
   2dbba:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	bt_conn_unref(conn);
   2dbbe:	f01e b902 	b.w	4bdc6 <bt_conn_unref>
   2dbc2:	bf00      	nop
   2dbc4:	2000698c 	.word	0x2000698c

0002dbc8 <find_pending_connect.part.0>:
static struct bt_conn *find_pending_connect(uint8_t role, bt_addr_le_t *peer_addr)
   2dbc8:	b510      	push	{r4, lr}
		conn = bt_conn_lookup_state_le(bt_dev.adv_conn_id, peer_addr,
   2dbca:	4c08      	ldr	r4, [pc, #32]	; (2dbec <find_pending_connect.part.0+0x24>)
static struct bt_conn *find_pending_connect(uint8_t role, bt_addr_le_t *peer_addr)
   2dbcc:	4601      	mov	r1, r0
		conn = bt_conn_lookup_state_le(bt_dev.adv_conn_id, peer_addr,
   2dbce:	2205      	movs	r2, #5
   2dbd0:	f894 0067 	ldrb.w	r0, [r4, #103]	; 0x67
   2dbd4:	f002 faee 	bl	301b4 <bt_conn_lookup_state_le>
		if (!conn) {
   2dbd8:	b938      	cbnz	r0, 2dbea <find_pending_connect.part.0+0x22>
			conn = bt_conn_lookup_state_le(bt_dev.adv_conn_id,
   2dbda:	f894 0067 	ldrb.w	r0, [r4, #103]	; 0x67
   2dbde:	4904      	ldr	r1, [pc, #16]	; (2dbf0 <find_pending_connect.part.0+0x28>)
}
   2dbe0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			conn = bt_conn_lookup_state_le(bt_dev.adv_conn_id,
   2dbe4:	2204      	movs	r2, #4
   2dbe6:	f002 bae5 	b.w	301b4 <bt_conn_lookup_state_le>
}
   2dbea:	bd10      	pop	{r4, pc}
   2dbec:	20000030 	.word	0x20000030
   2dbf0:	00053510 	.word	0x00053510

0002dbf4 <hci_le_meta_event>:
{
   2dbf4:	b510      	push	{r4, lr}
 *
 * @return Pointer to the old beginning of the buffer data.
 */
static inline void *net_buf_pull_mem(struct net_buf *buf, size_t len)
{
	return net_buf_simple_pull_mem(&buf->b, len);
   2dbf6:	2101      	movs	r1, #1
   2dbf8:	4604      	mov	r4, r0
   2dbfa:	3008      	adds	r0, #8
   2dbfc:	f021 f90b 	bl	4ee16 <net_buf_simple_pull_mem>
	err = handle_event_common(event, buf, handlers, num_handlers);
   2dc00:	4621      	mov	r1, r4
   2dc02:	4a03      	ldr	r2, [pc, #12]	; (2dc10 <hci_le_meta_event+0x1c>)
   2dc04:	7800      	ldrb	r0, [r0, #0]
}
   2dc06:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	err = handle_event_common(event, buf, handlers, num_handlers);
   2dc0a:	230b      	movs	r3, #11
   2dc0c:	f01d bb16 	b.w	4b23c <handle_event_common.isra.0>
   2dc10:	00051d88 	.word	0x00051d88

0002dc14 <hci_cmd_done>:
{
   2dc14:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2dc16:	4607      	mov	r7, r0
	if (net_buf_pool_get(buf->pool_id) != &hci_cmd_pool) {
   2dc18:	7990      	ldrb	r0, [r2, #6]
{
   2dc1a:	460e      	mov	r6, r1
   2dc1c:	4614      	mov	r4, r2
	if (net_buf_pool_get(buf->pool_id) != &hci_cmd_pool) {
   2dc1e:	f014 fd51 	bl	426c4 <net_buf_pool_get>
   2dc22:	4b28      	ldr	r3, [pc, #160]	; (2dcc4 <hci_cmd_done+0xb0>)
   2dc24:	4283      	cmp	r3, r0
   2dc26:	d14b      	bne.n	2dcc0 <hci_cmd_done+0xac>
	if (cmd(buf)->opcode != opcode) {
   2dc28:	4620      	mov	r0, r4
   2dc2a:	f014 fd53 	bl	426d4 <net_buf_id>
   2dc2e:	4d26      	ldr	r5, [pc, #152]	; (2dcc8 <hci_cmd_done+0xb4>)
   2dc30:	230c      	movs	r3, #12
   2dc32:	fb03 5000 	mla	r0, r3, r0, r5
   2dc36:	8843      	ldrh	r3, [r0, #2]
   2dc38:	42bb      	cmp	r3, r7
   2dc3a:	d141      	bne.n	2dcc0 <hci_cmd_done+0xac>
	if (bt_dev.sent_cmd) {
   2dc3c:	4f23      	ldr	r7, [pc, #140]	; (2dccc <hci_cmd_done+0xb8>)
   2dc3e:	f8d7 0138 	ldr.w	r0, [r7, #312]	; 0x138
   2dc42:	b120      	cbz	r0, 2dc4e <hci_cmd_done+0x3a>
		net_buf_unref(bt_dev.sent_cmd);
   2dc44:	f014 fe00 	bl	42848 <net_buf_unref>
		bt_dev.sent_cmd = NULL;
   2dc48:	2300      	movs	r3, #0
   2dc4a:	f8c7 3138 	str.w	r3, [r7, #312]	; 0x138
	if (cmd(buf)->state && !status) {
   2dc4e:	4620      	mov	r0, r4
   2dc50:	f014 fd40 	bl	426d4 <net_buf_id>
   2dc54:	270c      	movs	r7, #12
   2dc56:	fb07 5000 	mla	r0, r7, r0, r5
   2dc5a:	6843      	ldr	r3, [r0, #4]
   2dc5c:	b19b      	cbz	r3, 2dc86 <hci_cmd_done+0x72>
   2dc5e:	b996      	cbnz	r6, 2dc86 <hci_cmd_done+0x72>
		struct bt_hci_cmd_state_set *update = cmd(buf)->state;
   2dc60:	4620      	mov	r0, r4
   2dc62:	f014 fd37 	bl	426d4 <net_buf_id>
   2dc66:	fb07 5000 	mla	r0, r7, r0, r5
	atomic_val_t mask = ATOMIC_MASK(bit);
   2dc6a:	2101      	movs	r1, #1
   2dc6c:	6842      	ldr	r2, [r0, #4]
		atomic_set_bit_to(update->target, update->bit, update->val);
   2dc6e:	e9d2 0300 	ldrd	r0, r3, [r2]
	if (val) {
   2dc72:	7a12      	ldrb	r2, [r2, #8]
	atomic_val_t mask = ATOMIC_MASK(bit);
   2dc74:	f003 071f 	and.w	r7, r3, #31
   2dc78:	40b9      	lsls	r1, r7
	if (val) {
   2dc7a:	095b      	lsrs	r3, r3, #5
   2dc7c:	b1d2      	cbz	r2, 2dcb4 <hci_cmd_done+0xa0>
		(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
   2dc7e:	eb00 0083 	add.w	r0, r0, r3, lsl #2
   2dc82:	f01d fa40 	bl	4b106 <atomic_or>
	if (cmd(buf)->sync) {
   2dc86:	4620      	mov	r0, r4
   2dc88:	f014 fd24 	bl	426d4 <net_buf_id>
   2dc8c:	270c      	movs	r7, #12
   2dc8e:	fb07 5000 	mla	r0, r7, r0, r5
   2dc92:	6883      	ldr	r3, [r0, #8]
   2dc94:	b1a3      	cbz	r3, 2dcc0 <hci_cmd_done+0xac>
		cmd(buf)->status = status;
   2dc96:	4620      	mov	r0, r4
   2dc98:	f014 fd1c 	bl	426d4 <net_buf_id>
   2dc9c:	4378      	muls	r0, r7
   2dc9e:	542e      	strb	r6, [r5, r0]
		k_sem_give(cmd(buf)->sync);
   2dca0:	4620      	mov	r0, r4
   2dca2:	f014 fd17 	bl	426d4 <net_buf_id>
   2dca6:	fb07 5500 	mla	r5, r7, r0, r5
   2dcaa:	68a8      	ldr	r0, [r5, #8]
}
   2dcac:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	z_impl_k_sem_give(sem);
   2dcb0:	f019 ba62 	b.w	47178 <z_impl_k_sem_give>
	} else {
		(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   2dcb4:	43c9      	mvns	r1, r1
   2dcb6:	eb00 0083 	add.w	r0, r0, r3, lsl #2
   2dcba:	f01d fad6 	bl	4b26a <atomic_and.isra.0>
   2dcbe:	e7e2      	b.n	2dc86 <hci_cmd_done+0x72>
   2dcc0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2dcc2:	bf00      	nop
   2dcc4:	20001368 	.word	0x20001368
   2dcc8:	20003b9c 	.word	0x20003b9c
   2dccc:	20000030 	.word	0x20000030

0002dcd0 <hci_cmd_status>:
{
   2dcd0:	b538      	push	{r3, r4, r5, lr}
   2dcd2:	2104      	movs	r1, #4
   2dcd4:	4604      	mov	r4, r0
   2dcd6:	3008      	adds	r0, #8
   2dcd8:	f021 f89d 	bl	4ee16 <net_buf_simple_pull_mem>
	ncmd = evt->ncmd;
   2dcdc:	7845      	ldrb	r5, [r0, #1]
	hci_cmd_done(opcode, evt->status, buf);
   2dcde:	7801      	ldrb	r1, [r0, #0]
   2dce0:	8840      	ldrh	r0, [r0, #2]
   2dce2:	4622      	mov	r2, r4
   2dce4:	f7ff ff96 	bl	2dc14 <hci_cmd_done>
	if (ncmd) {
   2dce8:	b125      	cbz	r5, 2dcf4 <hci_cmd_status+0x24>
   2dcea:	4803      	ldr	r0, [pc, #12]	; (2dcf8 <hci_cmd_status+0x28>)
}
   2dcec:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   2dcf0:	f019 ba42 	b.w	47178 <z_impl_k_sem_give>
   2dcf4:	bd38      	pop	{r3, r4, r5, pc}
   2dcf6:	bf00      	nop
   2dcf8:	20000150 	.word	0x20000150

0002dcfc <hci_cmd_complete>:
{
   2dcfc:	b538      	push	{r3, r4, r5, lr}
   2dcfe:	2103      	movs	r1, #3
   2dd00:	4604      	mov	r4, r0
   2dd02:	3008      	adds	r0, #8
   2dd04:	f021 f887 	bl	4ee16 <net_buf_simple_pull_mem>
	status = buf->data[0];
   2dd08:	68a3      	ldr	r3, [r4, #8]
	ncmd = evt->ncmd;
   2dd0a:	7805      	ldrb	r5, [r0, #0]
	hci_cmd_done(opcode, status, buf);
   2dd0c:	7819      	ldrb	r1, [r3, #0]
   2dd0e:	f8b0 0001 	ldrh.w	r0, [r0, #1]
   2dd12:	4622      	mov	r2, r4
   2dd14:	f7ff ff7e 	bl	2dc14 <hci_cmd_done>
	if (ncmd) {
   2dd18:	b125      	cbz	r5, 2dd24 <hci_cmd_complete+0x28>
   2dd1a:	4803      	ldr	r0, [pc, #12]	; (2dd28 <hci_cmd_complete+0x2c>)
}
   2dd1c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   2dd20:	f019 ba2a 	b.w	47178 <z_impl_k_sem_give>
   2dd24:	bd38      	pop	{r3, r4, r5, pc}
   2dd26:	bf00      	nop
   2dd28:	20000150 	.word	0x20000150

0002dd2c <hci_tx_thread>:
{
   2dd2c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		events[0].state = K_POLL_STATE_NOT_READY;
   2dd30:	4f3c      	ldr	r7, [pc, #240]	; (2de24 <hci_tx_thread+0xf8>)
		BT_ASSERT(err == 0);
   2dd32:	f8df 80f4 	ldr.w	r8, [pc, #244]	; 2de28 <hci_tx_thread+0xfc>
			ev_count += bt_conn_prepare_events(&events[1]);
   2dd36:	f107 0914 	add.w	r9, r7, #20
		events[0].state = K_POLL_STATE_NOT_READY;
   2dd3a:	68fb      	ldr	r3, [r7, #12]
			ev_count += bt_conn_prepare_events(&events[1]);
   2dd3c:	4648      	mov	r0, r9
		events[0].state = K_POLL_STATE_NOT_READY;
   2dd3e:	f36f 3394 	bfc	r3, #14, #7
   2dd42:	60fb      	str	r3, [r7, #12]
			ev_count += bt_conn_prepare_events(&events[1]);
   2dd44:	f001 ffbe 	bl	2fcc4 <bt_conn_prepare_events>
   2dd48:	1c45      	adds	r5, r0, #1
		union { struct { uintptr_t lo, hi; } split; k_timeout_t val; } parm2 = { .val = timeout };
		return (int) arch_syscall_invoke4(parm0.x, parm1.x, parm2.split.lo, parm2.split.hi, K_SYSCALL_K_POLL);
	}
#endif
	compiler_barrier();
	return z_impl_k_poll(events, num_events, timeout);
   2dd4a:	4836      	ldr	r0, [pc, #216]	; (2de24 <hci_tx_thread+0xf8>)
   2dd4c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   2dd50:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2dd54:	4629      	mov	r1, r5
   2dd56:	f01a f9bd 	bl	480d4 <z_impl_k_poll>
		BT_ASSERT(err == 0);
   2dd5a:	b160      	cbz	r0, 2dd76 <hci_tx_thread+0x4a>
   2dd5c:	4933      	ldr	r1, [pc, #204]	; (2de2c <hci_tx_thread+0x100>)
   2dd5e:	4834      	ldr	r0, [pc, #208]	; (2de30 <hci_tx_thread+0x104>)
   2dd60:	f640 13d3 	movw	r3, #2515	; 0x9d3
   2dd64:	4642      	mov	r2, r8
   2dd66:	f01b f98d 	bl	49084 <assert_print>
   2dd6a:	4040      	eors	r0, r0
   2dd6c:	f380 8811 	msr	BASEPRI, r0
   2dd70:	f04f 0003 	mov.w	r0, #3
   2dd74:	df02      	svc	2
{
   2dd76:	4e2b      	ldr	r6, [pc, #172]	; (2de24 <hci_tx_thread+0xf8>)
	for (; count; ev++, count--) {
   2dd78:	b915      	cbnz	r5, 2dd80 <hci_tx_thread+0x54>
	z_impl_k_yield();
   2dd7a:	f019 fe87 	bl	47a8c <z_impl_k_yield>
	while (1) {
   2dd7e:	e7dc      	b.n	2dd3a <hci_tx_thread+0xe>
		switch (ev->state) {
   2dd80:	68f3      	ldr	r3, [r6, #12]
   2dd82:	f3c3 3386 	ubfx	r3, r3, #14, #7
   2dd86:	2b04      	cmp	r3, #4
   2dd88:	d142      	bne.n	2de10 <hci_tx_thread+0xe4>
			if (ev->tag == BT_EVENT_CMD_TX) {
   2dd8a:	7b33      	ldrb	r3, [r6, #12]
   2dd8c:	2b00      	cmp	r3, #0
   2dd8e:	d142      	bne.n	2de16 <hci_tx_thread+0xea>
	buf = net_buf_get(&bt_dev.cmd_tx_queue, K_NO_WAIT);
   2dd90:	4828      	ldr	r0, [pc, #160]	; (2de34 <hci_tx_thread+0x108>)
   2dd92:	2200      	movs	r2, #0
   2dd94:	2300      	movs	r3, #0
   2dd96:	f020 ffaa 	bl	4ecee <net_buf_get>
	BT_ASSERT(buf);
   2dd9a:	4604      	mov	r4, r0
   2dd9c:	b960      	cbnz	r0, 2ddb8 <hci_tx_thread+0x8c>
   2dd9e:	4926      	ldr	r1, [pc, #152]	; (2de38 <hci_tx_thread+0x10c>)
   2dda0:	4823      	ldr	r0, [pc, #140]	; (2de30 <hci_tx_thread+0x104>)
   2dda2:	f640 136c 	movw	r3, #2412	; 0x96c
   2dda6:	4642      	mov	r2, r8
   2dda8:	f01b f96c 	bl	49084 <assert_print>
   2ddac:	4040      	eors	r0, r0
   2ddae:	f380 8811 	msr	BASEPRI, r0
   2ddb2:	f04f 0003 	mov.w	r0, #3
   2ddb6:	df02      	svc	2
	if (bt_dev.sent_cmd) {
   2ddb8:	f8df a080 	ldr.w	sl, [pc, #128]	; 2de3c <hci_tx_thread+0x110>
	return z_impl_k_sem_take(sem, timeout);
   2ddbc:	4820      	ldr	r0, [pc, #128]	; (2de40 <hci_tx_thread+0x114>)
   2ddbe:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   2ddc2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2ddc6:	f019 f9fd 	bl	471c4 <z_impl_k_sem_take>
   2ddca:	f8da 0138 	ldr.w	r0, [sl, #312]	; 0x138
   2ddce:	b120      	cbz	r0, 2ddda <hci_tx_thread+0xae>
		net_buf_unref(bt_dev.sent_cmd);
   2ddd0:	f014 fd3a 	bl	42848 <net_buf_unref>
		bt_dev.sent_cmd = NULL;
   2ddd4:	2300      	movs	r3, #0
   2ddd6:	f8ca 3138 	str.w	r3, [sl, #312]	; 0x138
	bt_dev.sent_cmd = net_buf_ref(buf);
   2ddda:	4620      	mov	r0, r4
   2dddc:	f020 ffb8 	bl	4ed50 <net_buf_ref>
   2dde0:	f8ca 0138 	str.w	r0, [sl, #312]	; 0x138
		return bt_hci_ecc_send(buf);
   2dde4:	4620      	mov	r0, r4
   2dde6:	f7ff fc49 	bl	2d67c <bt_hci_ecc_send>
	if (err) {
   2ddea:	b188      	cbz	r0, 2de10 <hci_tx_thread+0xe4>
	z_impl_k_sem_give(sem);
   2ddec:	4814      	ldr	r0, [pc, #80]	; (2de40 <hci_tx_thread+0x114>)
   2ddee:	f019 f9c3 	bl	47178 <z_impl_k_sem_give>
		hci_cmd_done(cmd(buf)->opcode, BT_HCI_ERR_UNSPECIFIED, buf);
   2ddf2:	4620      	mov	r0, r4
   2ddf4:	f014 fc6e 	bl	426d4 <net_buf_id>
   2ddf8:	4b12      	ldr	r3, [pc, #72]	; (2de44 <hci_tx_thread+0x118>)
   2ddfa:	220c      	movs	r2, #12
   2ddfc:	fb02 3000 	mla	r0, r2, r0, r3
   2de00:	211f      	movs	r1, #31
   2de02:	8840      	ldrh	r0, [r0, #2]
   2de04:	4622      	mov	r2, r4
   2de06:	f7ff ff05 	bl	2dc14 <hci_cmd_done>
		net_buf_unref(buf);
   2de0a:	4620      	mov	r0, r4
   2de0c:	f014 fd1c 	bl	42848 <net_buf_unref>
	for (; count; ev++, count--) {
   2de10:	3614      	adds	r6, #20
   2de12:	3d01      	subs	r5, #1
   2de14:	e7b0      	b.n	2dd78 <hci_tx_thread+0x4c>
				if (ev->tag == BT_EVENT_CONN_TX_QUEUE) {
   2de16:	2b01      	cmp	r3, #1
   2de18:	d1fa      	bne.n	2de10 <hci_tx_thread+0xe4>
					conn = CONTAINER_OF(ev->fifo,
   2de1a:	6930      	ldr	r0, [r6, #16]
					bt_conn_process_tx(conn);
   2de1c:	3838      	subs	r0, #56	; 0x38
   2de1e:	f002 fc19 	bl	30654 <bt_conn_process_tx>
   2de22:	e7f5      	b.n	2de10 <hci_tx_thread+0xe4>
   2de24:	200005f4 	.word	0x200005f4
   2de28:	000535d1 	.word	0x000535d1
   2de2c:	00053605 	.word	0x00053605
   2de30:	0005360e 	.word	0x0005360e
   2de34:	2000016c 	.word	0x2000016c
   2de38:	0005362b 	.word	0x0005362b
   2de3c:	20000030 	.word	0x20000030
   2de40:	20000150 	.word	0x20000150
   2de44:	20003b9c 	.word	0x20003b9c

0002de48 <bt_hci_cmd_state_set_init>:
{
   2de48:	b510      	push	{r4, lr}
	state->bit = bit;
   2de4a:	e9c1 2300 	strd	r2, r3, [r1]
	state->val = val;
   2de4e:	f89d 3008 	ldrb.w	r3, [sp, #8]
   2de52:	720b      	strb	r3, [r1, #8]
{
   2de54:	460c      	mov	r4, r1
	cmd(buf)->state = state;
   2de56:	f014 fc3d 	bl	426d4 <net_buf_id>
   2de5a:	4b03      	ldr	r3, [pc, #12]	; (2de68 <bt_hci_cmd_state_set_init+0x20>)
   2de5c:	220c      	movs	r2, #12
   2de5e:	fb02 3300 	mla	r3, r2, r0, r3
   2de62:	605c      	str	r4, [r3, #4]
}
   2de64:	bd10      	pop	{r4, pc}
   2de66:	bf00      	nop
   2de68:	20003b9c 	.word	0x20003b9c

0002de6c <bt_hci_cmd_create>:
{
   2de6c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return net_buf_alloc_fixed(pool, timeout);
   2de70:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   2de74:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2de78:	4606      	mov	r6, r0
   2de7a:	4817      	ldr	r0, [pc, #92]	; (2ded8 <bt_hci_cmd_create+0x6c>)
	cmd(buf)->opcode = opcode;
   2de7c:	4d17      	ldr	r5, [pc, #92]	; (2dedc <bt_hci_cmd_create+0x70>)
{
   2de7e:	460f      	mov	r7, r1
   2de80:	f020 ff30 	bl	4ece4 <net_buf_alloc_fixed>
   2de84:	4604      	mov	r4, r0
	net_buf_simple_reserve(&buf->b, reserve);
   2de86:	f100 0a08 	add.w	sl, r0, #8
   2de8a:	2100      	movs	r1, #0
	((struct bt_buf_data *)net_buf_user_data(buf))->type = type;
   2de8c:	f04f 0800 	mov.w	r8, #0
   2de90:	4650      	mov	r0, sl
   2de92:	f020 ff4c 	bl	4ed2e <net_buf_simple_reserve>
   2de96:	f884 8014 	strb.w	r8, [r4, #20]
	cmd(buf)->opcode = opcode;
   2de9a:	4620      	mov	r0, r4
   2de9c:	f014 fc1a 	bl	426d4 <net_buf_id>
   2dea0:	f04f 090c 	mov.w	r9, #12
   2dea4:	fb09 5000 	mla	r0, r9, r0, r5
   2dea8:	8046      	strh	r6, [r0, #2]
	cmd(buf)->sync = NULL;
   2deaa:	4620      	mov	r0, r4
   2deac:	f014 fc12 	bl	426d4 <net_buf_id>
   2deb0:	fb09 5000 	mla	r0, r9, r0, r5
   2deb4:	f8c0 8008 	str.w	r8, [r0, #8]
	cmd(buf)->state = NULL;
   2deb8:	4620      	mov	r0, r4
   2deba:	f014 fc0b 	bl	426d4 <net_buf_id>
   2debe:	fb09 5500 	mla	r5, r9, r0, r5
	return net_buf_simple_add(&buf->b, len);
   2dec2:	2103      	movs	r1, #3
   2dec4:	f8c5 8004 	str.w	r8, [r5, #4]
   2dec8:	4650      	mov	r0, sl
   2deca:	f020 ff73 	bl	4edb4 <net_buf_simple_add>
	hdr->opcode = sys_cpu_to_le16(opcode);
   2dece:	8006      	strh	r6, [r0, #0]
	hdr->param_len = param_len;
   2ded0:	7087      	strb	r7, [r0, #2]
}
   2ded2:	4620      	mov	r0, r4
   2ded4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2ded8:	20001368 	.word	0x20001368
   2dedc:	20003b9c 	.word	0x20003b9c

0002dee0 <bt_hci_cmd_send>:
{
   2dee0:	b538      	push	{r3, r4, r5, lr}
   2dee2:	4605      	mov	r5, r0
	if (!buf) {
   2dee4:	460c      	mov	r4, r1
   2dee6:	b919      	cbnz	r1, 2def0 <bt_hci_cmd_send+0x10>
		buf = bt_hci_cmd_create(opcode, 0);
   2dee8:	f7ff ffc0 	bl	2de6c <bt_hci_cmd_create>
		if (!buf) {
   2deec:	4604      	mov	r4, r0
   2deee:	b198      	cbz	r0, 2df18 <bt_hci_cmd_send+0x38>
	if (opcode == BT_HCI_OP_HOST_NUM_COMPLETED_PACKETS) {
   2def0:	f640 4335 	movw	r3, #3125	; 0xc35
   2def4:	429d      	cmp	r5, r3
   2def6:	d109      	bne.n	2df0c <bt_hci_cmd_send+0x2c>
		return bt_hci_ecc_send(buf);
   2def8:	4620      	mov	r0, r4
   2defa:	f7ff fbbf 	bl	2d67c <bt_hci_ecc_send>
		if (err) {
   2defe:	4605      	mov	r5, r0
   2df00:	b140      	cbz	r0, 2df14 <bt_hci_cmd_send+0x34>
			net_buf_unref(buf);
   2df02:	4620      	mov	r0, r4
   2df04:	f014 fca0 	bl	42848 <net_buf_unref>
}
   2df08:	4628      	mov	r0, r5
   2df0a:	bd38      	pop	{r3, r4, r5, pc}
	net_buf_put(&bt_dev.cmd_tx_queue, buf);
   2df0c:	4804      	ldr	r0, [pc, #16]	; (2df20 <bt_hci_cmd_send+0x40>)
   2df0e:	4621      	mov	r1, r4
   2df10:	f020 ff11 	bl	4ed36 <net_buf_put>
	return 0;
   2df14:	2500      	movs	r5, #0
   2df16:	e7f7      	b.n	2df08 <bt_hci_cmd_send+0x28>
			return -ENOBUFS;
   2df18:	f06f 0568 	mvn.w	r5, #104	; 0x68
   2df1c:	e7f4      	b.n	2df08 <bt_hci_cmd_send+0x28>
   2df1e:	bf00      	nop
   2df20:	2000016c 	.word	0x2000016c

0002df24 <bt_hci_cmd_send_sync>:
{
   2df24:	b5f0      	push	{r4, r5, r6, r7, lr}
   2df26:	4615      	mov	r5, r2
   2df28:	b087      	sub	sp, #28
	if (!buf) {
   2df2a:	460c      	mov	r4, r1
   2df2c:	b921      	cbnz	r1, 2df38 <bt_hci_cmd_send_sync+0x14>
		buf = bt_hci_cmd_create(opcode, 0);
   2df2e:	f7ff ff9d 	bl	2de6c <bt_hci_cmd_create>
		if (!buf) {
   2df32:	4604      	mov	r4, r0
   2df34:	2800      	cmp	r0, #0
   2df36:	d047      	beq.n	2dfc8 <bt_hci_cmd_send_sync+0xa4>
	return z_impl_k_sem_init(sem, initial_count, limit);
   2df38:	2201      	movs	r2, #1
   2df3a:	2100      	movs	r1, #0
   2df3c:	4668      	mov	r0, sp
   2df3e:	f021 ff9b 	bl	4fe78 <z_impl_k_sem_init>
	cmd(buf)->sync = &sync_sem;
   2df42:	4620      	mov	r0, r4
   2df44:	f014 fbc6 	bl	426d4 <net_buf_id>
   2df48:	4f21      	ldr	r7, [pc, #132]	; (2dfd0 <bt_hci_cmd_send_sync+0xac>)
   2df4a:	230c      	movs	r3, #12
   2df4c:	fb03 7000 	mla	r0, r3, r0, r7
   2df50:	f8c0 d008 	str.w	sp, [r0, #8]
	net_buf_put(&bt_dev.cmd_tx_queue, net_buf_ref(buf));
   2df54:	4620      	mov	r0, r4
   2df56:	f020 fefb 	bl	4ed50 <net_buf_ref>
   2df5a:	4601      	mov	r1, r0
   2df5c:	481d      	ldr	r0, [pc, #116]	; (2dfd4 <bt_hci_cmd_send_sync+0xb0>)
   2df5e:	f020 feea 	bl	4ed36 <net_buf_put>
	return z_impl_k_sem_take(sem, timeout);
   2df62:	f44f 22a0 	mov.w	r2, #327680	; 0x50000
   2df66:	2300      	movs	r3, #0
   2df68:	4668      	mov	r0, sp
   2df6a:	f019 f92b 	bl	471c4 <z_impl_k_sem_take>
	BT_ASSERT_MSG(err == 0, "k_sem_take failed with err %d", err);
   2df6e:	4606      	mov	r6, r0
   2df70:	b180      	cbz	r0, 2df94 <bt_hci_cmd_send_sync+0x70>
   2df72:	4a19      	ldr	r2, [pc, #100]	; (2dfd8 <bt_hci_cmd_send_sync+0xb4>)
   2df74:	4919      	ldr	r1, [pc, #100]	; (2dfdc <bt_hci_cmd_send_sync+0xb8>)
   2df76:	481a      	ldr	r0, [pc, #104]	; (2dfe0 <bt_hci_cmd_send_sync+0xbc>)
   2df78:	f240 1347 	movw	r3, #327	; 0x147
   2df7c:	f01b f882 	bl	49084 <assert_print>
   2df80:	4818      	ldr	r0, [pc, #96]	; (2dfe4 <bt_hci_cmd_send_sync+0xc0>)
   2df82:	4631      	mov	r1, r6
   2df84:	f01b f87e 	bl	49084 <assert_print>
   2df88:	4040      	eors	r0, r0
   2df8a:	f380 8811 	msr	BASEPRI, r0
   2df8e:	f04f 0003 	mov.w	r0, #3
   2df92:	df02      	svc	2
	status = cmd(buf)->status;
   2df94:	4620      	mov	r0, r4
   2df96:	f014 fb9d 	bl	426d4 <net_buf_id>
   2df9a:	230c      	movs	r3, #12
   2df9c:	4358      	muls	r0, r3
   2df9e:	5c3e      	ldrb	r6, [r7, r0]
	if (status) {
   2dfa0:	b156      	cbz	r6, 2dfb8 <bt_hci_cmd_send_sync+0x94>
		net_buf_unref(buf);
   2dfa2:	4620      	mov	r0, r4
   2dfa4:	f014 fc50 	bl	42848 <net_buf_unref>
			return -ECONNREFUSED;
   2dfa8:	2e09      	cmp	r6, #9
   2dfaa:	bf14      	ite	ne
   2dfac:	f06f 0004 	mvnne.w	r0, #4
   2dfb0:	f06f 006e 	mvneq.w	r0, #110	; 0x6e
}
   2dfb4:	b007      	add	sp, #28
   2dfb6:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (rsp) {
   2dfb8:	b115      	cbz	r5, 2dfc0 <bt_hci_cmd_send_sync+0x9c>
		*rsp = buf;
   2dfba:	602c      	str	r4, [r5, #0]
	return 0;
   2dfbc:	2000      	movs	r0, #0
   2dfbe:	e7f9      	b.n	2dfb4 <bt_hci_cmd_send_sync+0x90>
		net_buf_unref(buf);
   2dfc0:	4620      	mov	r0, r4
   2dfc2:	f014 fc41 	bl	42848 <net_buf_unref>
   2dfc6:	e7f9      	b.n	2dfbc <bt_hci_cmd_send_sync+0x98>
			return -ENOBUFS;
   2dfc8:	f06f 0068 	mvn.w	r0, #104	; 0x68
   2dfcc:	e7f2      	b.n	2dfb4 <bt_hci_cmd_send_sync+0x90>
   2dfce:	bf00      	nop
   2dfd0:	20003b9c 	.word	0x20003b9c
   2dfd4:	2000016c 	.word	0x2000016c
   2dfd8:	000535d1 	.word	0x000535d1
   2dfdc:	00053605 	.word	0x00053605
   2dfe0:	0005360e 	.word	0x0005360e
   2dfe4:	0005362f 	.word	0x0005362f

0002dfe8 <bt_hci_le_rand>:
{
   2dfe8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	if (!BT_CMD_TEST(bt_dev.supported_commands, 27, 7)) {
   2dfea:	4b14      	ldr	r3, [pc, #80]	; (2e03c <bt_hci_le_rand+0x54>)
   2dfec:	f993 3093 	ldrsb.w	r3, [r3, #147]	; 0x93
   2dff0:	2b00      	cmp	r3, #0
{
   2dff2:	4605      	mov	r5, r0
   2dff4:	460c      	mov	r4, r1
	if (!BT_CMD_TEST(bt_dev.supported_commands, 27, 7)) {
   2dff6:	da1d      	bge.n	2e034 <bt_hci_le_rand+0x4c>
	while (len > 0) {
   2dff8:	b914      	cbnz	r4, 2e000 <bt_hci_le_rand+0x18>
	return 0;
   2dffa:	4620      	mov	r0, r4
}
   2dffc:	b003      	add	sp, #12
   2dffe:	bdf0      	pop	{r4, r5, r6, r7, pc}
		count = MIN(len, sizeof(rp->rand));
   2e000:	2c08      	cmp	r4, #8
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_RAND, NULL, &rsp);
   2e002:	aa01      	add	r2, sp, #4
   2e004:	f04f 0100 	mov.w	r1, #0
   2e008:	f242 0018 	movw	r0, #8216	; 0x2018
		count = MIN(len, sizeof(rp->rand));
   2e00c:	4626      	mov	r6, r4
   2e00e:	bf28      	it	cs
   2e010:	2608      	movcs	r6, #8
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_RAND, NULL, &rsp);
   2e012:	f7ff ff87 	bl	2df24 <bt_hci_cmd_send_sync>
		if (err) {
   2e016:	2800      	cmp	r0, #0
   2e018:	d1f0      	bne.n	2dffc <bt_hci_le_rand+0x14>
		rp = (void *)rsp->data;
   2e01a:	9f01      	ldr	r7, [sp, #4]
		memcpy(buffer, rp->rand, count);
   2e01c:	68b9      	ldr	r1, [r7, #8]
   2e01e:	4632      	mov	r2, r6
   2e020:	3101      	adds	r1, #1
   2e022:	4628      	mov	r0, r5
   2e024:	f01c ff29 	bl	4ae7a <memcpy>
		net_buf_unref(rsp);
   2e028:	4638      	mov	r0, r7
   2e02a:	f014 fc0d 	bl	42848 <net_buf_unref>
		buffer = (uint8_t *)buffer + count;
   2e02e:	4435      	add	r5, r6
		len -= count;
   2e030:	1ba4      	subs	r4, r4, r6
   2e032:	e7e1      	b.n	2dff8 <bt_hci_le_rand+0x10>
		return -ENOTSUP;
   2e034:	f06f 0085 	mvn.w	r0, #133	; 0x85
   2e038:	e7e0      	b.n	2dffc <bt_hci_le_rand+0x14>
   2e03a:	bf00      	nop
   2e03c:	20000030 	.word	0x20000030

0002e040 <bt_get_phy>:
	switch (hci_phy) {
   2e040:	3801      	subs	r0, #1
   2e042:	b2c0      	uxtb	r0, r0
   2e044:	2802      	cmp	r0, #2
   2e046:	bf9a      	itte	ls
   2e048:	4b01      	ldrls	r3, [pc, #4]	; (2e050 <bt_get_phy+0x10>)
   2e04a:	5c18      	ldrbls	r0, [r3, r0]
{
   2e04c:	2000      	movhi	r0, #0
}
   2e04e:	4770      	bx	lr
   2e050:	00053702 	.word	0x00053702

0002e054 <bt_le_create_conn>:
{
   2e054:	b5f0      	push	{r4, r5, r6, r7, lr}
   2e056:	b087      	sub	sp, #28
   2e058:	4606      	mov	r6, r0
	err = bt_id_set_create_conn_own_addr(use_filter, &own_addr_type);
   2e05a:	f10d 010b 	add.w	r1, sp, #11
   2e05e:	2000      	movs	r0, #0
   2e060:	f000 fe90 	bl	2ed84 <bt_id_set_create_conn_own_addr>
	if (err) {
   2e064:	4605      	mov	r5, r0
   2e066:	2800      	cmp	r0, #0
   2e068:	d148      	bne.n	2e0fc <bt_le_create_conn+0xa8>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_CREATE_CONN, sizeof(*cp));
   2e06a:	2119      	movs	r1, #25
   2e06c:	f242 000d 	movw	r0, #8205	; 0x200d
   2e070:	f7ff fefc 	bl	2de6c <bt_hci_cmd_create>
	if (!buf) {
   2e074:	4607      	mov	r7, r0
   2e076:	2800      	cmp	r0, #0
   2e078:	d043      	beq.n	2e102 <bt_le_create_conn+0xae>
   2e07a:	2119      	movs	r1, #25
   2e07c:	3008      	adds	r0, #8
   2e07e:	f020 fe99 	bl	4edb4 <net_buf_simple_add>
	memset(cp, 0, sizeof(*cp));
   2e082:	4629      	mov	r1, r5
   2e084:	4604      	mov	r4, r0
   2e086:	2219      	movs	r2, #25
   2e088:	f01c ff02 	bl	4ae90 <memset>
		if (bt_addr_le_cmp(&conn->le.resp_addr, BT_ADDR_LE_ANY)) {
   2e08c:	f106 0596 	add.w	r5, r6, #150	; 0x96
	cp->own_addr_type = own_addr_type;
   2e090:	f89d 300b 	ldrb.w	r3, [sp, #11]
	return memcmp(a, b, sizeof(*a));
   2e094:	491c      	ldr	r1, [pc, #112]	; (2e108 <bt_le_create_conn+0xb4>)
   2e096:	7323      	strb	r3, [r4, #12]
   2e098:	2207      	movs	r2, #7
   2e09a:	4628      	mov	r0, r5
   2e09c:	f01c fedd 	bl	4ae5a <memcmp>
		if (bt_addr_le_cmp(&conn->le.resp_addr, BT_ADDR_LE_ANY)) {
   2e0a0:	b908      	cbnz	r0, 2e0a6 <bt_le_create_conn+0x52>
		const bt_addr_le_t *peer_addr = &conn->le.dst;
   2e0a2:	f106 0588 	add.w	r5, r6, #136	; 0x88
		bt_addr_le_copy(&cp->peer_addr, peer_addr);
   2e0a6:	4629      	mov	r1, r5
   2e0a8:	1d60      	adds	r0, r4, #5
   2e0aa:	f01d f829 	bl	4b100 <bt_addr_le_copy>
		cp->filter_policy = BT_HCI_LE_CREATE_CONN_FP_NO_FILTER;
   2e0ae:	2500      	movs	r5, #0
	cp->scan_interval = sys_cpu_to_le16(bt_dev.create_param.interval);
   2e0b0:	4a16      	ldr	r2, [pc, #88]	; (2e10c <bt_le_create_conn+0xb8>)
		cp->filter_policy = BT_HCI_LE_CREATE_CONN_FP_NO_FILTER;
   2e0b2:	7125      	strb	r5, [r4, #4]
	cp->scan_interval = sys_cpu_to_le16(bt_dev.create_param.interval);
   2e0b4:	8993      	ldrh	r3, [r2, #12]
   2e0b6:	8023      	strh	r3, [r4, #0]
	cp->scan_window = sys_cpu_to_le16(bt_dev.create_param.window);
   2e0b8:	89d3      	ldrh	r3, [r2, #14]
   2e0ba:	8063      	strh	r3, [r4, #2]
	cp->conn_interval_min = sys_cpu_to_le16(conn->le.interval_min);
   2e0bc:	f8b6 30a0 	ldrh.w	r3, [r6, #160]	; 0xa0
   2e0c0:	f8a4 300d 	strh.w	r3, [r4, #13]
	cp->conn_interval_max = sys_cpu_to_le16(conn->le.interval_max);
   2e0c4:	f8b6 30a2 	ldrh.w	r3, [r6, #162]	; 0xa2
   2e0c8:	f8a4 300f 	strh.w	r3, [r4, #15]
	cp->conn_latency = sys_cpu_to_le16(conn->le.latency);
   2e0cc:	f8b6 30a4 	ldrh.w	r3, [r6, #164]	; 0xa4
   2e0d0:	f8a4 3011 	strh.w	r3, [r4, #17]
	cp->supervision_timeout = sys_cpu_to_le16(conn->le.timeout);
   2e0d4:	f8b6 30a6 	ldrh.w	r3, [r6, #166]	; 0xa6
   2e0d8:	f8a4 3013 	strh.w	r3, [r4, #19]
	bt_hci_cmd_state_set_init(buf, &state, bt_dev.flags,
   2e0dc:	2301      	movs	r3, #1
   2e0de:	9300      	str	r3, [sp, #0]
   2e0e0:	230c      	movs	r3, #12
   2e0e2:	eb0d 0103 	add.w	r1, sp, r3
   2e0e6:	32cc      	adds	r2, #204	; 0xcc
   2e0e8:	4638      	mov	r0, r7
   2e0ea:	f7ff fead 	bl	2de48 <bt_hci_cmd_state_set_init>
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_CREATE_CONN, buf, NULL);
   2e0ee:	462a      	mov	r2, r5
   2e0f0:	4639      	mov	r1, r7
   2e0f2:	f242 000d 	movw	r0, #8205	; 0x200d
   2e0f6:	f7ff ff15 	bl	2df24 <bt_hci_cmd_send_sync>
   2e0fa:	4605      	mov	r5, r0
}
   2e0fc:	4628      	mov	r0, r5
   2e0fe:	b007      	add	sp, #28
   2e100:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return -ENOBUFS;
   2e102:	f06f 0568 	mvn.w	r5, #104	; 0x68
   2e106:	e7f9      	b.n	2e0fc <bt_le_create_conn+0xa8>
   2e108:	00053517 	.word	0x00053517
   2e10c:	20000030 	.word	0x20000030

0002e110 <bt_le_create_conn_cancel>:
{
   2e110:	b530      	push	{r4, r5, lr}
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_CREATE_CONN_CANCEL, 0);
   2e112:	2100      	movs	r1, #0
{
   2e114:	b087      	sub	sp, #28
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_CREATE_CONN_CANCEL, 0);
   2e116:	f242 000e 	movw	r0, #8206	; 0x200e
   2e11a:	f7ff fea7 	bl	2de6c <bt_hci_cmd_create>
	bt_hci_cmd_state_set_init(buf, &state, bt_dev.flags,
   2e11e:	2500      	movs	r5, #0
   2e120:	230c      	movs	r3, #12
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_CREATE_CONN_CANCEL, 0);
   2e122:	4604      	mov	r4, r0
	bt_hci_cmd_state_set_init(buf, &state, bt_dev.flags,
   2e124:	eb0d 0103 	add.w	r1, sp, r3
   2e128:	4a05      	ldr	r2, [pc, #20]	; (2e140 <bt_le_create_conn_cancel+0x30>)
   2e12a:	9500      	str	r5, [sp, #0]
   2e12c:	f7ff fe8c 	bl	2de48 <bt_hci_cmd_state_set_init>
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_CREATE_CONN_CANCEL, buf, NULL);
   2e130:	462a      	mov	r2, r5
   2e132:	4621      	mov	r1, r4
   2e134:	f242 000e 	movw	r0, #8206	; 0x200e
   2e138:	f7ff fef4 	bl	2df24 <bt_hci_cmd_send_sync>
}
   2e13c:	b007      	add	sp, #28
   2e13e:	bd30      	pop	{r4, r5, pc}
   2e140:	200000fc 	.word	0x200000fc

0002e144 <bt_hci_le_enh_conn_complete>:
{
   2e144:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	uint16_t handle = sys_le16_to_cpu(evt->handle);
   2e148:	f8b0 7001 	ldrh.w	r7, [r0, #1]
   2e14c:	49a5      	ldr	r1, [pc, #660]	; (2e3e4 <bt_hci_le_enh_conn_complete+0x2a0>)
	handle |= ~BT_ACL_HANDLE_MASK;
   2e14e:	ea6f 5307 	mvn.w	r3, r7, lsl #20
   2e152:	ea6f 5313 	mvn.w	r3, r3, lsr #20
{
   2e156:	4605      	mov	r5, r0
   2e158:	b089      	sub	sp, #36	; 0x24
	uint16_t handle = sys_le16_to_cpu(evt->handle);
   2e15a:	fa1f f887 	uxth.w	r8, r7
	handle |= ~BT_ACL_HANDLE_MASK;
   2e15e:	b29b      	uxth	r3, r3
	for (int i = 0; i < ARRAY_SIZE(disconnected_handles); i++) {
   2e160:	2200      	movs	r2, #0
   2e162:	4608      	mov	r0, r1
		if (disconnected_handles[i] == handle) {
   2e164:	f831 4b02 	ldrh.w	r4, [r1], #2
   2e168:	42a3      	cmp	r3, r4
   2e16a:	d120      	bne.n	2e1ae <bt_hci_le_enh_conn_complete+0x6a>
			disconnected_handles[i] = 0;
   2e16c:	2300      	movs	r3, #0
   2e16e:	f820 3012 	strh.w	r3, [r0, r2, lsl #1]
			return true;
   2e172:	2601      	movs	r6, #1
	bt_id_pending_keys_update();
   2e174:	f000 fbce 	bl	2e914 <bt_id_pending_keys_update>
	if (evt->status) {
   2e178:	782c      	ldrb	r4, [r5, #0]
   2e17a:	2c00      	cmp	r4, #0
   2e17c:	d03d      	beq.n	2e1fa <bt_hci_le_enh_conn_complete+0xb6>
		if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
   2e17e:	2c3c      	cmp	r4, #60	; 0x3c
   2e180:	d11a      	bne.n	2e1b8 <bt_hci_le_enh_conn_complete+0x74>
		struct bt_le_ext_adv *adv = bt_le_adv_lookup_legacy();
   2e182:	f000 fee9 	bl	2ef58 <bt_le_adv_lookup_legacy>
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   2e186:	f06f 0140 	mvn.w	r1, #64	; 0x40
   2e18a:	3010      	adds	r0, #16
   2e18c:	f01d f86d 	bl	4b26a <atomic_and.isra.0>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && role == BT_HCI_ROLE_PERIPHERAL) {
   2e190:	2000      	movs	r0, #0
   2e192:	f7ff fd19 	bl	2dbc8 <find_pending_connect.part.0>
		if (!conn) {
   2e196:	4605      	mov	r5, r0
   2e198:	b360      	cbz	r0, 2e1f4 <bt_hci_le_enh_conn_complete+0xb0>
		conn->err = BT_HCI_ERR_ADV_TIMEOUT;
   2e19a:	7304      	strb	r4, [r0, #12]
		bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
   2e19c:	2100      	movs	r1, #0
   2e19e:	f001 fdd9 	bl	2fd54 <bt_conn_set_state>
		bt_conn_unref(conn);
   2e1a2:	4628      	mov	r0, r5
}
   2e1a4:	b009      	add	sp, #36	; 0x24
   2e1a6:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
		bt_conn_unref(conn);
   2e1aa:	f01d be0c 	b.w	4bdc6 <bt_conn_unref>
	for (int i = 0; i < ARRAY_SIZE(disconnected_handles); i++) {
   2e1ae:	3201      	adds	r2, #1
   2e1b0:	2a06      	cmp	r2, #6
   2e1b2:	d1d7      	bne.n	2e164 <bt_hci_le_enh_conn_complete+0x20>
	return false;
   2e1b4:	2600      	movs	r6, #0
   2e1b6:	e7dd      	b.n	2e174 <bt_hci_le_enh_conn_complete+0x30>
		if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
   2e1b8:	2c02      	cmp	r4, #2
   2e1ba:	d11b      	bne.n	2e1f4 <bt_hci_le_enh_conn_complete+0xb0>
		conn = bt_conn_lookup_state_le(BT_ID_DEFAULT, peer_addr,
   2e1bc:	2100      	movs	r1, #0
   2e1be:	2206      	movs	r2, #6
   2e1c0:	4608      	mov	r0, r1
   2e1c2:	f001 fff7 	bl	301b4 <bt_conn_lookup_state_le>
	if (!conn) {
   2e1c6:	4605      	mov	r5, r0
   2e1c8:	b188      	cbz	r0, 2e1ee <bt_hci_le_enh_conn_complete+0xaa>
	conn->err = BT_HCI_ERR_UNKNOWN_CONN_ID;
   2e1ca:	7304      	strb	r4, [r0, #12]
		bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
   2e1cc:	2100      	movs	r1, #0
   2e1ce:	f001 fdc1 	bl	2fd54 <bt_conn_set_state>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   2e1d2:	f3bf 8f5b 	dmb	ish
   2e1d6:	686b      	ldr	r3, [r5, #4]
   2e1d8:	f3bf 8f5b 	dmb	ish
		if (atomic_test_bit(conn->flags, BT_CONN_AUTO_CONNECT)) {
   2e1dc:	07de      	lsls	r6, r3, #31
   2e1de:	d503      	bpl.n	2e1e8 <bt_hci_le_enh_conn_complete+0xa4>
			bt_conn_set_state(conn, BT_CONN_CONNECTING_SCAN);
   2e1e0:	4621      	mov	r1, r4
   2e1e2:	4628      	mov	r0, r5
   2e1e4:	f001 fdb6 	bl	2fd54 <bt_conn_set_state>
	bt_conn_unref(conn);
   2e1e8:	4628      	mov	r0, r5
   2e1ea:	f01d fdec 	bl	4bdc6 <bt_conn_unref>
			bt_le_scan_update(false);
   2e1ee:	2000      	movs	r0, #0
   2e1f0:	f001 f926 	bl	2f440 <bt_le_scan_update>
}
   2e1f4:	b009      	add	sp, #36	; 0x24
   2e1f6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (evt->peer_addr.type == BT_ADDR_LE_PUBLIC_ID ||
   2e1fa:	792b      	ldrb	r3, [r5, #4]
   2e1fc:	3b02      	subs	r3, #2
   2e1fe:	2b01      	cmp	r3, #1
		bt_addr_le_copy(&id_addr, &evt->peer_addr);
   2e200:	f105 0904 	add.w	r9, r5, #4
	if (evt->peer_addr.type == BT_ADDR_LE_PUBLIC_ID ||
   2e204:	f200 80d0 	bhi.w	2e3a8 <bt_hci_le_enh_conn_complete+0x264>
		bt_addr_le_copy(&id_addr, &evt->peer_addr);
   2e208:	4649      	mov	r1, r9
   2e20a:	a806      	add	r0, sp, #24
   2e20c:	f01c ff78 	bl	4b100 <bt_addr_le_copy>
		id_addr.type -= BT_ADDR_LE_PUBLIC_ID;
   2e210:	f89d 3018 	ldrb.w	r3, [sp, #24]
	memcpy(dst, src, sizeof(*dst));
   2e214:	2206      	movs	r2, #6
   2e216:	3b02      	subs	r3, #2
   2e218:	f105 0111 	add.w	r1, r5, #17
   2e21c:	f10d 0011 	add.w	r0, sp, #17
   2e220:	f88d 3018 	strb.w	r3, [sp, #24]
   2e224:	f01c fe29 	bl	4ae7a <memcpy>
		peer_addr.type = BT_ADDR_LE_RANDOM;
   2e228:	2301      	movs	r3, #1
   2e22a:	f88d 3010 	strb.w	r3, [sp, #16]
	conn = find_pending_connect(evt->role, &id_addr);
   2e22e:	78e8      	ldrb	r0, [r5, #3]
	if (IS_ENABLED(CONFIG_BT_CENTRAL) && role == BT_HCI_ROLE_CENTRAL) {
   2e230:	2800      	cmp	r0, #0
   2e232:	f040 80cc 	bne.w	2e3ce <bt_hci_le_enh_conn_complete+0x28a>
		conn = bt_conn_lookup_state_le(BT_ID_DEFAULT, peer_addr,
   2e236:	2206      	movs	r2, #6
   2e238:	a906      	add	r1, sp, #24
   2e23a:	f001 ffbb 	bl	301b4 <bt_conn_lookup_state_le>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
   2e23e:	78eb      	ldrb	r3, [r5, #3]
   2e240:	2b01      	cmp	r3, #1
   2e242:	4604      	mov	r4, r0
   2e244:	d10a      	bne.n	2e25c <bt_hci_le_enh_conn_complete+0x118>
		struct bt_le_ext_adv *adv = bt_le_adv_lookup_legacy();
   2e246:	f000 fe87 	bl	2ef58 <bt_le_adv_lookup_legacy>
   2e24a:	f06f 0140 	mvn.w	r1, #64	; 0x40
   2e24e:	4681      	mov	r9, r0
   2e250:	3010      	adds	r0, #16
   2e252:	f01d f80a 	bl	4b26a <atomic_and.isra.0>
		(void)bt_le_lim_adv_cancel_timeout(adv);
   2e256:	4648      	mov	r0, r9
   2e258:	f01d fcc9 	bl	4bbee <bt_le_lim_adv_cancel_timeout>
	if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
   2e25c:	78eb      	ldrb	r3, [r5, #3]
   2e25e:	b923      	cbnz	r3, 2e26a <bt_hci_le_enh_conn_complete+0x126>
   2e260:	4861      	ldr	r0, [pc, #388]	; (2e3e8 <bt_hci_le_enh_conn_complete+0x2a4>)
   2e262:	f46f 5180 	mvn.w	r1, #4096	; 0x1000
   2e266:	f01d f800 	bl	4b26a <atomic_and.isra.0>
	if (!conn) {
   2e26a:	2c00      	cmp	r4, #0
   2e26c:	f000 80b1 	beq.w	2e3d2 <bt_hci_le_enh_conn_complete+0x28e>
	conn->handle = handle;
   2e270:	4620      	mov	r0, r4
	bt_addr_le_copy(&conn->le.dst, &id_addr);
   2e272:	a906      	add	r1, sp, #24
	conn->handle = handle;
   2e274:	f820 7b88 	strh.w	r7, [r0], #136
	bt_addr_le_copy(&conn->le.dst, &id_addr);
   2e278:	f01c ff42 	bl	4b100 <bt_addr_le_copy>
	conn->le.interval = sys_le16_to_cpu(evt->interval);
   2e27c:	f8b5 3017 	ldrh.w	r3, [r5, #23]
   2e280:	f8a4 309e 	strh.w	r3, [r4, #158]	; 0x9e
	conn->le.latency = sys_le16_to_cpu(evt->latency);
   2e284:	f8b5 3019 	ldrh.w	r3, [r5, #25]
   2e288:	f8a4 30a4 	strh.w	r3, [r4, #164]	; 0xa4
	conn->le.timeout = sys_le16_to_cpu(evt->supv_timeout);
   2e28c:	f8b5 301b 	ldrh.w	r3, [r5, #27]
   2e290:	f8a4 30a6 	strh.w	r3, [r4, #166]	; 0xa6
	conn->role = evt->role;
   2e294:	78eb      	ldrb	r3, [r5, #3]
   2e296:	70e3      	strb	r3, [r4, #3]
	conn->err = 0U;
   2e298:	2200      	movs	r2, #0
   2e29a:	7322      	strb	r2, [r4, #12]
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
   2e29c:	2b01      	cmp	r3, #1
	conn->le.phy.tx_phy = BT_GAP_LE_PHY_1M;
   2e29e:	f240 1201 	movw	r2, #257	; 0x101
   2e2a2:	f8a4 20b8 	strh.w	r2, [r4, #184]	; 0xb8
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
   2e2a6:	d115      	bne.n	2e2d4 <bt_hci_le_enh_conn_complete+0x190>
		bt_addr_le_copy(&conn->le.init_addr, &peer_addr);
   2e2a8:	a904      	add	r1, sp, #16
   2e2aa:	f104 008f 	add.w	r0, r4, #143	; 0x8f
   2e2ae:	f01c ff27 	bl	4b100 <bt_addr_le_copy>
			struct bt_le_ext_adv *adv = bt_le_adv_lookup_legacy();
   2e2b2:	f000 fe51 	bl	2ef58 <bt_le_adv_lookup_legacy>
						&bt_dev.id_addr[conn->id]);
   2e2b6:	7a21      	ldrb	r1, [r4, #8]
   2e2b8:	4d4c      	ldr	r5, [pc, #304]	; (2e3ec <bt_hci_le_enh_conn_complete+0x2a8>)
   2e2ba:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
				bt_addr_le_copy(&conn->le.resp_addr,
   2e2be:	4429      	add	r1, r5
   2e2c0:	f104 0096 	add.w	r0, r4, #150	; 0x96
   2e2c4:	f01c ff1c 	bl	4b100 <bt_addr_le_copy>
		if (BT_LE_STATES_PER_CONN_ADV(bt_dev.le.states)) {
   2e2c8:	f8d5 30dc 	ldr.w	r3, [r5, #220]	; 0xdc
   2e2cc:	065d      	lsls	r5, r3, #25
   2e2ce:	d501      	bpl.n	2e2d4 <bt_hci_le_enh_conn_complete+0x190>
			bt_le_adv_resume();
   2e2d0:	f000 ffe6 	bl	2f2a0 <bt_le_adv_resume>
	if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
   2e2d4:	78e3      	ldrb	r3, [r4, #3]
   2e2d6:	b96b      	cbnz	r3, 2e2f4 <bt_hci_le_enh_conn_complete+0x1b0>
		bt_addr_le_copy(&conn->le.resp_addr, &peer_addr);
   2e2d8:	a904      	add	r1, sp, #16
   2e2da:	f104 0096 	add.w	r0, r4, #150	; 0x96
   2e2de:	f01c ff0f 	bl	4b100 <bt_addr_le_copy>
					&bt_dev.id_addr[conn->id]);
   2e2e2:	7a21      	ldrb	r1, [r4, #8]
			bt_addr_le_copy(&conn->le.init_addr,
   2e2e4:	4b41      	ldr	r3, [pc, #260]	; (2e3ec <bt_hci_le_enh_conn_complete+0x2a8>)
					&bt_dev.id_addr[conn->id]);
   2e2e6:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
			bt_addr_le_copy(&conn->le.init_addr,
   2e2ea:	4419      	add	r1, r3
   2e2ec:	f104 008f 	add.w	r0, r4, #143	; 0x8f
   2e2f0:	f01c ff06 	bl	4b100 <bt_addr_le_copy>
	bt_conn_set_state(conn, BT_CONN_CONNECTED);
   2e2f4:	2107      	movs	r1, #7
   2e2f6:	4620      	mov	r0, r4
   2e2f8:	f001 fd2c 	bl	2fd54 <bt_conn_set_state>
	if (is_disconnected) {
   2e2fc:	b11e      	cbz	r6, 2e306 <bt_hci_le_enh_conn_complete+0x1c2>
		bt_conn_set_state(conn, BT_CONN_DISCONNECT_COMPLETE);
   2e2fe:	2101      	movs	r1, #1
   2e300:	4620      	mov	r0, r4
   2e302:	f001 fd27 	bl	2fd54 <bt_conn_set_state>
	bt_conn_connected(conn);
   2e306:	4620      	mov	r0, r4
   2e308:	f01d fd98 	bl	4be3c <bt_conn_connected>
	if (conn->state != BT_CONN_CONNECTED) {
   2e30c:	7b63      	ldrb	r3, [r4, #13]
   2e30e:	2b07      	cmp	r3, #7
   2e310:	d142      	bne.n	2e398 <bt_hci_le_enh_conn_complete+0x254>
   2e312:	f3bf 8f5b 	dmb	ish
   2e316:	6863      	ldr	r3, [r4, #4]
   2e318:	4e34      	ldr	r6, [pc, #208]	; (2e3ec <bt_hci_le_enh_conn_complete+0x2a8>)
   2e31a:	f3bf 8f5b 	dmb	ish
	if (!atomic_test_bit(conn->flags, BT_CONN_AUTO_FEATURE_EXCH) &&
   2e31e:	f413 5f80 	tst.w	r3, #4096	; 0x1000
   2e322:	d118      	bne.n	2e356 <bt_hci_le_enh_conn_complete+0x212>
   2e324:	78e3      	ldrb	r3, [r4, #3]
   2e326:	b11b      	cbz	r3, 2e330 <bt_hci_le_enh_conn_complete+0x1ec>
	    ((conn->role == BT_HCI_ROLE_CENTRAL) ||
   2e328:	f896 30d0 	ldrb.w	r3, [r6, #208]	; 0xd0
   2e32c:	0718      	lsls	r0, r3, #28
   2e32e:	d512      	bpl.n	2e356 <bt_hci_le_enh_conn_complete+0x212>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_READ_REMOTE_FEATURES,
   2e330:	2102      	movs	r1, #2
   2e332:	f242 0016 	movw	r0, #8214	; 0x2016
   2e336:	f7ff fd99 	bl	2de6c <bt_hci_cmd_create>
	if (!buf) {
   2e33a:	4605      	mov	r5, r0
   2e33c:	b158      	cbz	r0, 2e356 <bt_hci_le_enh_conn_complete+0x212>
   2e33e:	2102      	movs	r1, #2
   2e340:	3008      	adds	r0, #8
   2e342:	f020 fd37 	bl	4edb4 <net_buf_simple_add>
	cp->handle = sys_cpu_to_le16(conn->handle);
   2e346:	8823      	ldrh	r3, [r4, #0]
   2e348:	8003      	strh	r3, [r0, #0]
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_REMOTE_FEATURES, buf, NULL);
   2e34a:	2200      	movs	r2, #0
   2e34c:	4629      	mov	r1, r5
   2e34e:	f242 0016 	movw	r0, #8214	; 0x2016
   2e352:	f7ff fde7 	bl	2df24 <bt_hci_cmd_send_sync>
	if (IS_ENABLED(CONFIG_BT_AUTO_PHY_UPDATE) &&
   2e356:	f896 30d1 	ldrb.w	r3, [r6, #209]	; 0xd1
   2e35a:	07d9      	lsls	r1, r3, #31
   2e35c:	d506      	bpl.n	2e36c <bt_hci_le_enh_conn_complete+0x228>
		err = bt_le_set_phy(conn, 0U, BT_HCI_LE_PHY_PREFER_2M,
   2e35e:	2100      	movs	r1, #0
   2e360:	2302      	movs	r3, #2
   2e362:	9100      	str	r1, [sp, #0]
   2e364:	461a      	mov	r2, r3
   2e366:	4620      	mov	r0, r4
   2e368:	f01d f918 	bl	4b59c <bt_le_set_phy>
	if (IS_ENABLED(CONFIG_BT_AUTO_DATA_LEN_UPDATE) &&
   2e36c:	f896 30d0 	ldrb.w	r3, [r6, #208]	; 0xd0
   2e370:	069a      	lsls	r2, r3, #26
   2e372:	d511      	bpl.n	2e398 <bt_hci_le_enh_conn_complete+0x254>
		if (IS_BT_QUIRK_NO_AUTO_DLE(&bt_dev)) {
   2e374:	f8d6 3154 	ldr.w	r3, [r6, #340]	; 0x154
   2e378:	689b      	ldr	r3, [r3, #8]
   2e37a:	079b      	lsls	r3, r3, #30
   2e37c:	d50c      	bpl.n	2e398 <bt_hci_le_enh_conn_complete+0x254>
			err = hci_le_read_max_data_len(&tx_octets, &tx_time);
   2e37e:	f10d 010e 	add.w	r1, sp, #14
   2e382:	a803      	add	r0, sp, #12
   2e384:	f01d f89e 	bl	4b4c4 <hci_le_read_max_data_len>
			if (!err) {
   2e388:	b930      	cbnz	r0, 2e398 <bt_hci_le_enh_conn_complete+0x254>
				err = bt_le_set_data_len(conn,
   2e38a:	f8bd 200e 	ldrh.w	r2, [sp, #14]
   2e38e:	f8bd 100c 	ldrh.w	r1, [sp, #12]
   2e392:	4620      	mov	r0, r4
   2e394:	f01d f8e4 	bl	4b560 <bt_le_set_data_len>
	bt_conn_unref(conn);
   2e398:	4620      	mov	r0, r4
   2e39a:	f01d fd14 	bl	4bdc6 <bt_conn_unref>
	if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
   2e39e:	78e3      	ldrb	r3, [r4, #3]
   2e3a0:	2b00      	cmp	r3, #0
   2e3a2:	f47f af27 	bne.w	2e1f4 <bt_hci_le_enh_conn_complete+0xb0>
   2e3a6:	e722      	b.n	2e1ee <bt_hci_le_enh_conn_complete+0xaa>
		uint8_t id = evt->role == BT_HCI_ROLE_PERIPHERAL ? bt_dev.adv_conn_id :
   2e3a8:	78eb      	ldrb	r3, [r5, #3]
   2e3aa:	2b01      	cmp	r3, #1
   2e3ac:	bf04      	itt	eq
   2e3ae:	4b0f      	ldreq	r3, [pc, #60]	; (2e3ec <bt_hci_le_enh_conn_complete+0x2a8>)
   2e3b0:	f893 4067 	ldrbeq.w	r4, [r3, #103]	; 0x67
		bt_addr_le_copy(&id_addr,
   2e3b4:	4649      	mov	r1, r9
   2e3b6:	4620      	mov	r0, r4
   2e3b8:	f01d fa9c 	bl	4b8f4 <bt_lookup_id_addr>
   2e3bc:	4601      	mov	r1, r0
   2e3be:	a806      	add	r0, sp, #24
   2e3c0:	f01c fe9e 	bl	4b100 <bt_addr_le_copy>
		bt_addr_le_copy(&peer_addr, &evt->peer_addr);
   2e3c4:	4649      	mov	r1, r9
   2e3c6:	a804      	add	r0, sp, #16
   2e3c8:	f01c fe9a 	bl	4b100 <bt_addr_le_copy>
   2e3cc:	e72f      	b.n	2e22e <bt_hci_le_enh_conn_complete+0xea>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && role == BT_HCI_ROLE_PERIPHERAL) {
   2e3ce:	2801      	cmp	r0, #1
   2e3d0:	d004      	beq.n	2e3dc <bt_hci_le_enh_conn_complete+0x298>
		bt_hci_disconnect(handle, BT_HCI_ERR_UNSPECIFIED);
   2e3d2:	211f      	movs	r1, #31
   2e3d4:	4640      	mov	r0, r8
   2e3d6:	f01d f8a8 	bl	4b52a <bt_hci_disconnect>
		return;
   2e3da:	e70b      	b.n	2e1f4 <bt_hci_le_enh_conn_complete+0xb0>
   2e3dc:	a806      	add	r0, sp, #24
   2e3de:	f7ff fbf3 	bl	2dbc8 <find_pending_connect.part.0>
   2e3e2:	e72c      	b.n	2e23e <bt_hci_le_enh_conn_complete+0xfa>
   2e3e4:	2000698c 	.word	0x2000698c
   2e3e8:	200000fc 	.word	0x200000fc
   2e3ec:	20000030 	.word	0x20000030

0002e3f0 <le_legacy_conn_complete>:
{
   2e3f0:	b510      	push	{r4, lr}
	struct bt_hci_evt_le_conn_complete *evt = (void *)buf->data;
   2e3f2:	6881      	ldr	r1, [r0, #8]
   2e3f4:	4c17      	ldr	r4, [pc, #92]	; (2e454 <le_legacy_conn_complete+0x64>)
	enh.status         = evt->status;
   2e3f6:	780b      	ldrb	r3, [r1, #0]
{
   2e3f8:	b088      	sub	sp, #32
	bt_addr_le_copy(&enh.peer_addr, &evt->peer_addr);
   2e3fa:	a801      	add	r0, sp, #4
	enh.status         = evt->status;
   2e3fc:	f88d 3000 	strb.w	r3, [sp]
	enh.handle         = evt->handle;
   2e400:	f8b1 3001 	ldrh.w	r3, [r1, #1]
   2e404:	f8ad 3001 	strh.w	r3, [sp, #1]
	enh.role           = evt->role;
   2e408:	78cb      	ldrb	r3, [r1, #3]
   2e40a:	f88d 3003 	strb.w	r3, [sp, #3]
	enh.interval       = evt->interval;
   2e40e:	f8b1 300b 	ldrh.w	r3, [r1, #11]
   2e412:	f8ad 3017 	strh.w	r3, [sp, #23]
	enh.latency        = evt->latency;
   2e416:	f8b1 300d 	ldrh.w	r3, [r1, #13]
   2e41a:	f8ad 3019 	strh.w	r3, [sp, #25]
	enh.supv_timeout   = evt->supv_timeout;
   2e41e:	f8b1 300f 	ldrh.w	r3, [r1, #15]
   2e422:	f8ad 301b 	strh.w	r3, [sp, #27]
	enh.clock_accuracy = evt->clock_accuracy;
   2e426:	7c4b      	ldrb	r3, [r1, #17]
   2e428:	f88d 301d 	strb.w	r3, [sp, #29]
	bt_addr_le_copy(&enh.peer_addr, &evt->peer_addr);
   2e42c:	3104      	adds	r1, #4
   2e42e:	f01c fe67 	bl	4b100 <bt_addr_le_copy>
   2e432:	4621      	mov	r1, r4
   2e434:	2206      	movs	r2, #6
   2e436:	f10d 000b 	add.w	r0, sp, #11
   2e43a:	f01c fd1e 	bl	4ae7a <memcpy>
   2e43e:	2206      	movs	r2, #6
   2e440:	4621      	mov	r1, r4
   2e442:	f10d 0011 	add.w	r0, sp, #17
   2e446:	f01c fd18 	bl	4ae7a <memcpy>
	bt_hci_le_enh_conn_complete(evt);
   2e44a:	4668      	mov	r0, sp
   2e44c:	f7ff fe7a 	bl	2e144 <bt_hci_le_enh_conn_complete>
}
   2e450:	b008      	add	sp, #32
   2e452:	bd10      	pop	{r4, pc}
   2e454:	00053524 	.word	0x00053524

0002e458 <bt_unpair>:
{
   2e458:	b513      	push	{r0, r1, r4, lr}
   2e45a:	460c      	mov	r4, r1
   2e45c:	f88d 0007 	strb.w	r0, [sp, #7]
	if (id >= CONFIG_BT_ID_MAX) {
   2e460:	b9b8      	cbnz	r0, 2e492 <bt_unpair+0x3a>
	if (IS_ENABLED(CONFIG_BT_SMP) &&
   2e462:	b949      	cbnz	r1, 2e478 <bt_unpair+0x20>
		bt_foreach_bond(id, unpair_remote, &id);
   2e464:	490c      	ldr	r1, [pc, #48]	; (2e498 <bt_unpair+0x40>)
   2e466:	f89d 0007 	ldrb.w	r0, [sp, #7]
   2e46a:	f10d 0207 	add.w	r2, sp, #7
   2e46e:	f005 fed5 	bl	3421c <bt_foreach_bond>
		return 0;
   2e472:	2000      	movs	r0, #0
}
   2e474:	b002      	add	sp, #8
   2e476:	bd10      	pop	{r4, pc}
	return memcmp(a, b, sizeof(*a));
   2e478:	4908      	ldr	r1, [pc, #32]	; (2e49c <bt_unpair+0x44>)
   2e47a:	2207      	movs	r2, #7
   2e47c:	4620      	mov	r0, r4
   2e47e:	f01c fcec 	bl	4ae5a <memcmp>
	if (IS_ENABLED(CONFIG_BT_SMP) &&
   2e482:	2800      	cmp	r0, #0
   2e484:	d0ee      	beq.n	2e464 <bt_unpair+0xc>
	unpair(id, addr);
   2e486:	f89d 0007 	ldrb.w	r0, [sp, #7]
   2e48a:	4621      	mov	r1, r4
   2e48c:	f7ff fb32 	bl	2daf4 <unpair>
	return 0;
   2e490:	e7ef      	b.n	2e472 <bt_unpair+0x1a>
		return -EINVAL;
   2e492:	f06f 0015 	mvn.w	r0, #21
   2e496:	e7ed      	b.n	2e474 <bt_unpair+0x1c>
   2e498:	0004b125 	.word	0x0004b125
   2e49c:	00053517 	.word	0x00053517

0002e4a0 <bt_security_err_get>:
	switch (hci_err) {
   2e4a0:	2829      	cmp	r0, #41	; 0x29
   2e4a2:	bf9a      	itte	ls
   2e4a4:	4b01      	ldrls	r3, [pc, #4]	; (2e4ac <bt_security_err_get+0xc>)
   2e4a6:	5c18      	ldrbls	r0, [r3, r0]
{
   2e4a8:	2009      	movhi	r0, #9
}
   2e4aa:	4770      	bx	lr
   2e4ac:	000536d8 	.word	0x000536d8

0002e4b0 <hci_event_prio>:
{
   2e4b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2e4b4:	4604      	mov	r4, r0
	net_buf_simple_save(&buf->b, &state);
   2e4b6:	f100 0608 	add.w	r6, r0, #8
	state->offset = net_buf_simple_headroom(buf);
   2e4ba:	4630      	mov	r0, r6
   2e4bc:	f020 fcc3 	bl	4ee46 <net_buf_simple_headroom>
	state->len = buf->len;
   2e4c0:	f8b4 800c 	ldrh.w	r8, [r4, #12]
	BT_ASSERT(buf->len >= sizeof(*hdr));
   2e4c4:	f1b8 0f01 	cmp.w	r8, #1
	state->offset = net_buf_simple_headroom(buf);
   2e4c8:	4605      	mov	r5, r0
   2e4ca:	d80c      	bhi.n	2e4e6 <hci_event_prio+0x36>
   2e4cc:	4a1c      	ldr	r2, [pc, #112]	; (2e540 <hci_event_prio+0x90>)
   2e4ce:	491d      	ldr	r1, [pc, #116]	; (2e544 <hci_event_prio+0x94>)
   2e4d0:	481d      	ldr	r0, [pc, #116]	; (2e548 <hci_event_prio+0x98>)
   2e4d2:	f640 536f 	movw	r3, #3439	; 0xd6f
   2e4d6:	f01a fdd5 	bl	49084 <assert_print>
   2e4da:	4040      	eors	r0, r0
   2e4dc:	f380 8811 	msr	BASEPRI, r0
   2e4e0:	f04f 0003 	mov.w	r0, #3
   2e4e4:	df02      	svc	2
	return net_buf_simple_pull_mem(&buf->b, len);
   2e4e6:	4630      	mov	r0, r6
   2e4e8:	2102      	movs	r1, #2
   2e4ea:	f020 fc94 	bl	4ee16 <net_buf_simple_pull_mem>
   2e4ee:	4607      	mov	r7, r0
	evt_flags = bt_hci_evt_get_flags(hdr->evt);
   2e4f0:	7800      	ldrb	r0, [r0, #0]
   2e4f2:	f01c fdda 	bl	4b0aa <bt_hci_evt_get_flags>
	BT_ASSERT(evt_flags & BT_HCI_EVT_FLAG_RECV_PRIO);
   2e4f6:	07c2      	lsls	r2, r0, #31
	evt_flags = bt_hci_evt_get_flags(hdr->evt);
   2e4f8:	4606      	mov	r6, r0
	BT_ASSERT(evt_flags & BT_HCI_EVT_FLAG_RECV_PRIO);
   2e4fa:	d40c      	bmi.n	2e516 <hci_event_prio+0x66>
   2e4fc:	4a10      	ldr	r2, [pc, #64]	; (2e540 <hci_event_prio+0x90>)
   2e4fe:	4913      	ldr	r1, [pc, #76]	; (2e54c <hci_event_prio+0x9c>)
   2e500:	4811      	ldr	r0, [pc, #68]	; (2e548 <hci_event_prio+0x98>)
   2e502:	f640 5373 	movw	r3, #3443	; 0xd73
   2e506:	f01a fdbd 	bl	49084 <assert_print>
   2e50a:	4040      	eors	r0, r0
   2e50c:	f380 8811 	msr	BASEPRI, r0
   2e510:	f04f 0003 	mov.w	r0, #3
   2e514:	df02      	svc	2
	err = handle_event_common(event, buf, handlers, num_handlers);
   2e516:	2305      	movs	r3, #5
   2e518:	4a0d      	ldr	r2, [pc, #52]	; (2e550 <hci_event_prio+0xa0>)
   2e51a:	7838      	ldrb	r0, [r7, #0]
   2e51c:	4621      	mov	r1, r4
   2e51e:	f01c fe8d 	bl	4b23c <handle_event_common.isra.0>
	if (evt_flags & BT_HCI_EVT_FLAG_RECV) {
   2e522:	07b3      	lsls	r3, r6, #30
   2e524:	d507      	bpl.n	2e536 <hci_event_prio+0x86>
	buf->data = buf->__buf + state->offset;
   2e526:	6923      	ldr	r3, [r4, #16]
	buf->len = state->len;
   2e528:	f8a4 800c 	strh.w	r8, [r4, #12]
	buf->data = buf->__buf + state->offset;
   2e52c:	fa13 f585 	uxtah	r5, r3, r5
   2e530:	60a5      	str	r5, [r4, #8]
}
   2e532:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		net_buf_unref(buf);
   2e536:	4620      	mov	r0, r4
}
   2e538:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		net_buf_unref(buf);
   2e53c:	f014 b984 	b.w	42848 <net_buf_unref>
   2e540:	000535d1 	.word	0x000535d1
   2e544:	0005364f 	.word	0x0005364f
   2e548:	0005360e 	.word	0x0005360e
   2e54c:	00053668 	.word	0x00053668
   2e550:	00051d30 	.word	0x00051d30

0002e554 <bt_recv>:
{
   2e554:	b570      	push	{r4, r5, r6, lr}
	return (enum bt_buf_type)((struct bt_buf_data *)net_buf_user_data(buf))
   2e556:	7d03      	ldrb	r3, [r0, #20]
	switch (bt_buf_get_type(buf)) {
   2e558:	2b01      	cmp	r3, #1
{
   2e55a:	4604      	mov	r4, r0
	switch (bt_buf_get_type(buf)) {
   2e55c:	d036      	beq.n	2e5cc <bt_recv+0x78>
   2e55e:	2b03      	cmp	r3, #3
   2e560:	d163      	bne.n	2e62a <bt_recv+0xd6>
	BT_ASSERT(buf->len >= sizeof(*hdr));
   2e562:	8983      	ldrh	r3, [r0, #12]
   2e564:	2b03      	cmp	r3, #3
   2e566:	d80c      	bhi.n	2e582 <bt_recv+0x2e>
   2e568:	4a32      	ldr	r2, [pc, #200]	; (2e634 <bt_recv+0xe0>)
   2e56a:	4933      	ldr	r1, [pc, #204]	; (2e638 <bt_recv+0xe4>)
   2e56c:	4833      	ldr	r0, [pc, #204]	; (2e63c <bt_recv+0xe8>)
   2e56e:	f240 13eb 	movw	r3, #491	; 0x1eb
   2e572:	f01a fd87 	bl	49084 <assert_print>
   2e576:	4040      	eors	r0, r0
   2e578:	f380 8811 	msr	BASEPRI, r0
   2e57c:	f04f 0003 	mov.w	r0, #3
   2e580:	df02      	svc	2
	return net_buf_simple_pull_mem(&buf->b, len);
   2e582:	2104      	movs	r1, #4
   2e584:	f104 0008 	add.w	r0, r4, #8
   2e588:	f020 fc45 	bl	4ee16 <net_buf_simple_pull_mem>
	acl(buf)->index = BT_CONN_INDEX_INVALID;
   2e58c:	22ff      	movs	r2, #255	; 0xff
	len = sys_le16_to_cpu(hdr->len);
   2e58e:	8843      	ldrh	r3, [r0, #2]
	handle = sys_le16_to_cpu(hdr->handle);
   2e590:	8806      	ldrh	r6, [r0, #0]
	acl(buf)->index = BT_CONN_INDEX_INVALID;
   2e592:	7562      	strb	r2, [r4, #21]
	if (buf->len != len) {
   2e594:	89a2      	ldrh	r2, [r4, #12]
	acl(buf)->handle = bt_acl_handle(handle);
   2e596:	f3c6 000b 	ubfx	r0, r6, #0, #12
	if (buf->len != len) {
   2e59a:	429a      	cmp	r2, r3
	acl(buf)->handle = bt_acl_handle(handle);
   2e59c:	82e0      	strh	r0, [r4, #22]
	if (buf->len != len) {
   2e59e:	d003      	beq.n	2e5a8 <bt_recv+0x54>
	net_buf_unref(buf);
   2e5a0:	4620      	mov	r0, r4
   2e5a2:	f014 f951 	bl	42848 <net_buf_unref>
}
   2e5a6:	e00f      	b.n	2e5c8 <bt_recv+0x74>
	conn = bt_conn_lookup_handle(acl(buf)->handle);
   2e5a8:	f001 fbcc 	bl	2fd44 <bt_conn_lookup_handle>
	if (!conn) {
   2e5ac:	4605      	mov	r5, r0
   2e5ae:	2800      	cmp	r0, #0
   2e5b0:	d0f6      	beq.n	2e5a0 <bt_recv+0x4c>
	acl(buf)->index = bt_conn_index(conn);
   2e5b2:	f001 fca7 	bl	2ff04 <bt_conn_index>
	bt_conn_recv(conn, buf, flags);
   2e5b6:	0b32      	lsrs	r2, r6, #12
	acl(buf)->index = bt_conn_index(conn);
   2e5b8:	7560      	strb	r0, [r4, #21]
	bt_conn_recv(conn, buf, flags);
   2e5ba:	4621      	mov	r1, r4
   2e5bc:	4628      	mov	r0, r5
   2e5be:	f01d fb9a 	bl	4bcf6 <bt_conn_recv>
	bt_conn_unref(conn);
   2e5c2:	4628      	mov	r0, r5
   2e5c4:	f01d fbff 	bl	4bdc6 <bt_conn_unref>
		return 0;
   2e5c8:	2000      	movs	r0, #0
}
   2e5ca:	bd70      	pop	{r4, r5, r6, pc}
	BT_ASSERT(buf->len >= sizeof(*hdr));
   2e5cc:	8983      	ldrh	r3, [r0, #12]
   2e5ce:	2b01      	cmp	r3, #1
   2e5d0:	d80c      	bhi.n	2e5ec <bt_recv+0x98>
   2e5d2:	4a18      	ldr	r2, [pc, #96]	; (2e634 <bt_recv+0xe0>)
   2e5d4:	4918      	ldr	r1, [pc, #96]	; (2e638 <bt_recv+0xe4>)
   2e5d6:	4819      	ldr	r0, [pc, #100]	; (2e63c <bt_recv+0xe8>)
   2e5d8:	f640 1359 	movw	r3, #2393	; 0x959
   2e5dc:	f01a fd52 	bl	49084 <assert_print>
   2e5e0:	4040      	eors	r0, r0
   2e5e2:	f380 8811 	msr	BASEPRI, r0
   2e5e6:	f04f 0003 	mov.w	r0, #3
   2e5ea:	df02      	svc	2
   2e5ec:	2102      	movs	r1, #2
   2e5ee:	f104 0008 	add.w	r0, r4, #8
   2e5f2:	f020 fc10 	bl	4ee16 <net_buf_simple_pull_mem>
   2e5f6:	4605      	mov	r5, r0
	BT_ASSERT(bt_hci_evt_get_flags(hdr->evt) & BT_HCI_EVT_FLAG_RECV);
   2e5f8:	7800      	ldrb	r0, [r0, #0]
   2e5fa:	f01c fd56 	bl	4b0aa <bt_hci_evt_get_flags>
   2e5fe:	0783      	lsls	r3, r0, #30
   2e600:	d40c      	bmi.n	2e61c <bt_recv+0xc8>
   2e602:	4a0c      	ldr	r2, [pc, #48]	; (2e634 <bt_recv+0xe0>)
   2e604:	490e      	ldr	r1, [pc, #56]	; (2e640 <bt_recv+0xec>)
   2e606:	480d      	ldr	r0, [pc, #52]	; (2e63c <bt_recv+0xe8>)
   2e608:	f640 135d 	movw	r3, #2397	; 0x95d
   2e60c:	f01a fd3a 	bl	49084 <assert_print>
   2e610:	4040      	eors	r0, r0
   2e612:	f380 8811 	msr	BASEPRI, r0
   2e616:	f04f 0003 	mov.w	r0, #3
   2e61a:	df02      	svc	2
	err = handle_event_common(event, buf, handlers, num_handlers);
   2e61c:	4a09      	ldr	r2, [pc, #36]	; (2e644 <bt_recv+0xf0>)
   2e61e:	7828      	ldrb	r0, [r5, #0]
   2e620:	2306      	movs	r3, #6
   2e622:	4621      	mov	r1, r4
   2e624:	f01c fe0a 	bl	4b23c <handle_event_common.isra.0>
   2e628:	e7ba      	b.n	2e5a0 <bt_recv+0x4c>
		net_buf_unref(buf);
   2e62a:	f014 f90d 	bl	42848 <net_buf_unref>
		return -EINVAL;
   2e62e:	f06f 0015 	mvn.w	r0, #21
   2e632:	e7ca      	b.n	2e5ca <bt_recv+0x76>
   2e634:	000535d1 	.word	0x000535d1
   2e638:	0005364f 	.word	0x0005364f
   2e63c:	0005360e 	.word	0x0005360e
   2e640:	00053681 	.word	0x00053681
   2e644:	00051d58 	.word	0x00051d58

0002e648 <bt_recv_prio>:
{
   2e648:	b510      	push	{r4, lr}
	BT_ASSERT(bt_buf_get_type(buf) == BT_BUF_EVT);
   2e64a:	7d03      	ldrb	r3, [r0, #20]
   2e64c:	2b01      	cmp	r3, #1
{
   2e64e:	4604      	mov	r4, r0
	BT_ASSERT(bt_buf_get_type(buf) == BT_BUF_EVT);
   2e650:	d00c      	beq.n	2e66c <bt_recv_prio+0x24>
   2e652:	4a09      	ldr	r2, [pc, #36]	; (2e678 <bt_recv_prio+0x30>)
   2e654:	4909      	ldr	r1, [pc, #36]	; (2e67c <bt_recv_prio+0x34>)
   2e656:	480a      	ldr	r0, [pc, #40]	; (2e680 <bt_recv_prio+0x38>)
   2e658:	f640 53c5 	movw	r3, #3525	; 0xdc5
   2e65c:	f01a fd12 	bl	49084 <assert_print>
   2e660:	4040      	eors	r0, r0
   2e662:	f380 8811 	msr	BASEPRI, r0
   2e666:	f04f 0003 	mov.w	r0, #3
   2e66a:	df02      	svc	2
	hci_event_prio(buf);
   2e66c:	4620      	mov	r0, r4
   2e66e:	f7ff ff1f 	bl	2e4b0 <hci_event_prio>
}
   2e672:	2000      	movs	r0, #0
   2e674:	bd10      	pop	{r4, pc}
   2e676:	bf00      	nop
   2e678:	000535d1 	.word	0x000535d1
   2e67c:	000536af 	.word	0x000536af
   2e680:	0005360e 	.word	0x0005360e

0002e684 <bt_hci_driver_register>:
	if (bt_dev.drv) {
   2e684:	4a08      	ldr	r2, [pc, #32]	; (2e6a8 <bt_hci_driver_register+0x24>)
{
   2e686:	4603      	mov	r3, r0
	if (bt_dev.drv) {
   2e688:	f8d2 0154 	ldr.w	r0, [r2, #340]	; 0x154
   2e68c:	b930      	cbnz	r0, 2e69c <bt_hci_driver_register+0x18>
	if (!drv->open || !drv->send) {
   2e68e:	68d9      	ldr	r1, [r3, #12]
   2e690:	b139      	cbz	r1, 2e6a2 <bt_hci_driver_register+0x1e>
   2e692:	6959      	ldr	r1, [r3, #20]
   2e694:	b129      	cbz	r1, 2e6a2 <bt_hci_driver_register+0x1e>
	bt_dev.drv = drv;
   2e696:	f8c2 3154 	str.w	r3, [r2, #340]	; 0x154
	return 0;
   2e69a:	4770      	bx	lr
		return -EALREADY;
   2e69c:	f06f 0077 	mvn.w	r0, #119	; 0x77
   2e6a0:	4770      	bx	lr
		return -EINVAL;
   2e6a2:	f06f 0015 	mvn.w	r0, #21
}
   2e6a6:	4770      	bx	lr
   2e6a8:	20000030 	.word	0x20000030

0002e6ac <bt_finalize_init>:
{
   2e6ac:	b508      	push	{r3, lr}
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
   2e6ae:	4804      	ldr	r0, [pc, #16]	; (2e6c0 <bt_finalize_init+0x14>)
   2e6b0:	2104      	movs	r1, #4
   2e6b2:	f01c fd28 	bl	4b106 <atomic_or>
}
   2e6b6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		bt_le_scan_update(false);
   2e6ba:	2000      	movs	r0, #0
   2e6bc:	f000 bec0 	b.w	2f440 <bt_le_scan_update>
   2e6c0:	200000fc 	.word	0x200000fc

0002e6c4 <init_work>:

static void init_work(struct k_work *work)
{
   2e6c4:	b510      	push	{r4, lr}
	int err;

	err = bt_init();
   2e6c6:	f7f7 fe87 	bl	263d8 <bt_init>
	if (ready_cb) {
   2e6ca:	4b03      	ldr	r3, [pc, #12]	; (2e6d8 <init_work+0x14>)
   2e6cc:	681b      	ldr	r3, [r3, #0]
   2e6ce:	b113      	cbz	r3, 2e6d6 <init_work+0x12>
		ready_cb(err);
	}
}
   2e6d0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		ready_cb(err);
   2e6d4:	4718      	bx	r3
}
   2e6d6:	bd10      	pop	{r4, pc}
   2e6d8:	20003bb4 	.word	0x20003bb4

0002e6dc <bt_enable>:
	}
}
#endif /* !CONFIG_BT_RECV_BLOCKING */

int bt_enable(bt_ready_cb_t cb)
{
   2e6dc:	b570      	push	{r4, r5, r6, lr}
	int err;

	if (!bt_dev.drv) {
   2e6de:	4d28      	ldr	r5, [pc, #160]	; (2e780 <bt_enable+0xa4>)
   2e6e0:	f8d5 3154 	ldr.w	r3, [r5, #340]	; 0x154
{
   2e6e4:	b088      	sub	sp, #32
   2e6e6:	4606      	mov	r6, r0
	if (!bt_dev.drv) {
   2e6e8:	2b00      	cmp	r3, #0
   2e6ea:	d043      	beq.n	2e774 <bt_enable+0x98>
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   2e6ec:	f06f 0102 	mvn.w	r1, #2
   2e6f0:	f105 00cc 	add.w	r0, r5, #204	; 0xcc
   2e6f4:	f01c fdb9 	bl	4b26a <atomic_and.isra.0>
	old = atomic_or(ATOMIC_ELEM(target, bit), mask);
   2e6f8:	2101      	movs	r1, #1
   2e6fa:	f01c fd04 	bl	4b106 <atomic_or>
		return -ENODEV;
	}

	atomic_clear_bit(bt_dev.flags, BT_DEV_DISABLE);

	if (atomic_test_and_set_bit(bt_dev.flags, BT_DEV_ENABLE)) {
   2e6fe:	07c3      	lsls	r3, r0, #31
   2e700:	d43b      	bmi.n	2e77a <bt_enable+0x9e>
		return -EALREADY;
	}

	if (IS_ENABLED(CONFIG_BT_SETTINGS)) {
		err = bt_settings_init();
   2e702:	f01c fc79 	bl	4aff8 <bt_settings_init>
		if (err) {
   2e706:	4604      	mov	r4, r0
   2e708:	bb88      	cbnz	r0, 2e76e <bt_enable+0x92>
		if (err) {
			BT_WARN("Failed to set device name (%d)", err);
		}
	}

	ready_cb = cb;
   2e70a:	4b1e      	ldr	r3, [pc, #120]	; (2e784 <bt_enable+0xa8>)
   2e70c:	601e      	str	r6, [r3, #0]
	return z_impl_k_sem_init(sem, initial_count, limit);
   2e70e:	2201      	movs	r2, #1
   2e710:	4611      	mov	r1, r2
   2e712:	f505 7090 	add.w	r0, r5, #288	; 0x120
   2e716:	f021 fbaf 	bl	4fe78 <z_impl_k_sem_init>
	z_impl_k_queue_init(queue);
   2e71a:	f505 709e 	add.w	r0, r5, #316	; 0x13c
   2e71e:	f021 fb2b 	bl	4fd78 <z_impl_k_queue_init>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   2e722:	2200      	movs	r2, #0
   2e724:	2300      	movs	r3, #0
   2e726:	e9cd 2306 	strd	r2, r3, [sp, #24]
   2e72a:	f06f 0308 	mvn.w	r3, #8
   2e72e:	e9cd 4302 	strd	r4, r3, [sp, #8]
   2e732:	e9cd 4400 	strd	r4, r4, [sp]
   2e736:	4b14      	ldr	r3, [pc, #80]	; (2e788 <bt_enable+0xac>)
   2e738:	4914      	ldr	r1, [pc, #80]	; (2e78c <bt_enable+0xb0>)
   2e73a:	9404      	str	r4, [sp, #16]
   2e73c:	f44f 6280 	mov.w	r2, #1024	; 0x400
   2e740:	4813      	ldr	r0, [pc, #76]	; (2e790 <bt_enable+0xb4>)
   2e742:	f018 fadb 	bl	46cfc <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread, str);
   2e746:	4913      	ldr	r1, [pc, #76]	; (2e794 <bt_enable+0xb8>)
   2e748:	4811      	ldr	r0, [pc, #68]	; (2e790 <bt_enable+0xb4>)
   2e74a:	f021 fa88 	bl	4fc5e <z_impl_k_thread_name_set>
			   CONFIG_BT_RX_STACK_SIZE,
			   K_PRIO_COOP(CONFIG_BT_RX_PRIO), NULL);
	k_thread_name_set(&bt_workq.thread, "BT RX");
#endif

	err = bt_dev.drv->open();
   2e74e:	f8d5 3154 	ldr.w	r3, [r5, #340]	; 0x154
   2e752:	68db      	ldr	r3, [r3, #12]
   2e754:	4798      	blx	r3
	if (err) {
   2e756:	4604      	mov	r4, r0
   2e758:	b948      	cbnz	r0, 2e76e <bt_enable+0x92>
		return err;
	}

	bt_monitor_send(BT_MONITOR_OPEN_INDEX, NULL, 0);

	if (!cb) {
   2e75a:	b926      	cbnz	r6, 2e766 <bt_enable+0x8a>
		return bt_init();
	}

	k_work_submit(&bt_dev.init);
	return 0;
}
   2e75c:	b008      	add	sp, #32
   2e75e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return bt_init();
   2e762:	f7f7 be39 	b.w	263d8 <bt_init>
	k_work_submit(&bt_dev.init);
   2e766:	f105 00bc 	add.w	r0, r5, #188	; 0xbc
   2e76a:	f018 fea3 	bl	474b4 <k_work_submit>
}
   2e76e:	4620      	mov	r0, r4
   2e770:	b008      	add	sp, #32
   2e772:	bd70      	pop	{r4, r5, r6, pc}
		return -ENODEV;
   2e774:	f06f 0412 	mvn.w	r4, #18
   2e778:	e7f9      	b.n	2e76e <bt_enable+0x92>
		return -EALREADY;
   2e77a:	f06f 0477 	mvn.w	r4, #119	; 0x77
   2e77e:	e7f6      	b.n	2e76e <bt_enable+0x92>
   2e780:	20000030 	.word	0x20000030
   2e784:	20003bb4 	.word	0x20003bb4
   2e788:	0002dd2d 	.word	0x0002dd2d
   2e78c:	200078e0 	.word	0x200078e0
   2e790:	200017a8 	.word	0x200017a8
   2e794:	000536d2 	.word	0x000536d2

0002e798 <bt_is_ready>:
   2e798:	4b04      	ldr	r3, [pc, #16]	; (2e7ac <bt_is_ready+0x14>)
   2e79a:	f3bf 8f5b 	dmb	ish
   2e79e:	6818      	ldr	r0, [r3, #0]
   2e7a0:	f3bf 8f5b 	dmb	ish
}

bool bt_is_ready(void)
{
	return atomic_test_bit(bt_dev.flags, BT_DEV_READY);
}
   2e7a4:	f3c0 0080 	ubfx	r0, r0, #2, #1
   2e7a8:	4770      	bx	lr
   2e7aa:	bf00      	nop
   2e7ac:	200000fc 	.word	0x200000fc

0002e7b0 <bt_get_name>:
#if defined(CONFIG_BT_DEVICE_NAME_DYNAMIC)
	return bt_dev.name;
#else
	return CONFIG_BT_DEVICE_NAME;
#endif
}
   2e7b0:	4800      	ldr	r0, [pc, #0]	; (2e7b4 <bt_get_name+0x4>)
   2e7b2:	4770      	bx	lr
   2e7b4:	00053270 	.word	0x00053270

0002e7b8 <id_find>:
		*count = bt_dev.id_count;
	}
}

static int id_find(const bt_addr_le_t *addr)
{
   2e7b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint8_t id;

	for (id = 0U; id < bt_dev.id_count; id++) {
   2e7ba:	4f0b      	ldr	r7, [pc, #44]	; (2e7e8 <id_find+0x30>)
{
   2e7bc:	4606      	mov	r6, r0
	for (id = 0U; id < bt_dev.id_count; id++) {
   2e7be:	2500      	movs	r5, #0
   2e7c0:	79fb      	ldrb	r3, [r7, #7]
   2e7c2:	b2ec      	uxtb	r4, r5
   2e7c4:	42a3      	cmp	r3, r4
   2e7c6:	d802      	bhi.n	2e7ce <id_find+0x16>
		if (!bt_addr_le_cmp(addr, &bt_dev.id_addr[id])) {
			return id;
		}
	}

	return -ENOENT;
   2e7c8:	f06f 0001 	mvn.w	r0, #1
   2e7cc:	e00a      	b.n	2e7e4 <id_find+0x2c>
		if (!bt_addr_le_cmp(addr, &bt_dev.id_addr[id])) {
   2e7ce:	ebc4 01c4 	rsb	r1, r4, r4, lsl #3
   2e7d2:	2207      	movs	r2, #7
   2e7d4:	4439      	add	r1, r7
   2e7d6:	4630      	mov	r0, r6
   2e7d8:	f01c fb3f 	bl	4ae5a <memcmp>
   2e7dc:	3501      	adds	r5, #1
   2e7de:	2800      	cmp	r0, #0
   2e7e0:	d1ee      	bne.n	2e7c0 <id_find+0x8>
   2e7e2:	4620      	mov	r0, r4
}
   2e7e4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2e7e6:	bf00      	nop
   2e7e8:	20000030 	.word	0x20000030

0002e7ec <set_random_address>:
{
   2e7ec:	b538      	push	{r3, r4, r5, lr}
	return memcmp(a, b, sizeof(*a));
   2e7ee:	4913      	ldr	r1, [pc, #76]	; (2e83c <set_random_address+0x50>)
   2e7f0:	2206      	movs	r2, #6
   2e7f2:	4605      	mov	r5, r0
   2e7f4:	f01c fb31 	bl	4ae5a <memcmp>
	if (!bt_addr_cmp(addr, &bt_dev.random_addr.a)) {
   2e7f8:	b1d8      	cbz	r0, 2e832 <set_random_address+0x46>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_RANDOM_ADDRESS, sizeof(*addr));
   2e7fa:	2106      	movs	r1, #6
   2e7fc:	f242 0005 	movw	r0, #8197	; 0x2005
   2e800:	f7ff fb34 	bl	2de6c <bt_hci_cmd_create>
	if (!buf) {
   2e804:	4604      	mov	r4, r0
   2e806:	b1b0      	cbz	r0, 2e836 <set_random_address+0x4a>
	return net_buf_simple_add_mem(&buf->b, mem, len);
   2e808:	2206      	movs	r2, #6
   2e80a:	4629      	mov	r1, r5
   2e80c:	3008      	adds	r0, #8
   2e80e:	f020 fad7 	bl	4edc0 <net_buf_simple_add_mem>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_RANDOM_ADDRESS, buf, NULL);
   2e812:	2200      	movs	r2, #0
   2e814:	4621      	mov	r1, r4
   2e816:	f242 0005 	movw	r0, #8197	; 0x2005
   2e81a:	f7ff fb83 	bl	2df24 <bt_hci_cmd_send_sync>
	if (err) {
   2e81e:	b948      	cbnz	r0, 2e834 <set_random_address+0x48>
	memcpy(dst, src, sizeof(*dst));
   2e820:	2206      	movs	r2, #6
   2e822:	4806      	ldr	r0, [pc, #24]	; (2e83c <set_random_address+0x50>)
   2e824:	4629      	mov	r1, r5
   2e826:	f01c fb28 	bl	4ae7a <memcpy>
	bt_dev.random_addr.type = BT_ADDR_LE_RANDOM;
   2e82a:	4b05      	ldr	r3, [pc, #20]	; (2e840 <set_random_address+0x54>)
   2e82c:	2201      	movs	r2, #1
   2e82e:	f883 2060 	strb.w	r2, [r3, #96]	; 0x60
		return 0;
   2e832:	2000      	movs	r0, #0
}
   2e834:	bd38      	pop	{r3, r4, r5, pc}
		return -ENOBUFS;
   2e836:	f06f 0068 	mvn.w	r0, #104	; 0x68
   2e83a:	e7fb      	b.n	2e834 <set_random_address+0x48>
   2e83c:	20000091 	.word	0x20000091
   2e840:	20000030 	.word	0x20000030

0002e844 <id_create.constprop.0>:

static int id_create(uint8_t id, bt_addr_le_t *addr, uint8_t *irk)
   2e844:	b537      	push	{r0, r1, r2, r4, r5, lr}
   2e846:	4604      	mov	r4, r0
{
	if (addr && bt_addr_le_cmp(addr, BT_ADDR_LE_ANY)) {
   2e848:	460d      	mov	r5, r1
   2e84a:	b1b1      	cbz	r1, 2e87a <id_create.constprop.0+0x36>
	return memcmp(a, b, sizeof(*a));
   2e84c:	4916      	ldr	r1, [pc, #88]	; (2e8a8 <id_create.constprop.0+0x64>)
   2e84e:	2207      	movs	r2, #7
   2e850:	4628      	mov	r0, r5
   2e852:	f01c fb02 	bl	4ae5a <memcmp>
   2e856:	b180      	cbz	r0, 2e87a <id_create.constprop.0+0x36>
		bt_addr_le_copy(&bt_dev.id_addr[id], addr);
   2e858:	4814      	ldr	r0, [pc, #80]	; (2e8ac <id_create.constprop.0+0x68>)
   2e85a:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
   2e85e:	4629      	mov	r1, r5
   2e860:	4420      	add	r0, r4
		} while (id_find(&new_addr) >= 0);

		bt_addr_le_copy(&bt_dev.id_addr[id], &new_addr);

		if (addr) {
			bt_addr_le_copy(addr, &bt_dev.id_addr[id]);
   2e862:	f01c ffb9 	bl	4b7d8 <bt_addr_le_copy>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
   2e866:	4812      	ldr	r0, [pc, #72]	; (2e8b0 <id_create.constprop.0+0x6c>)
   2e868:	f01c ffb9 	bl	4b7de <atomic_get>
#endif
	/* Only store if stack was already initialized. Before initialization
	 * we don't know the flash content, so it's potentially harmful to
	 * try to write anything there.
	 */
	if (IS_ENABLED(CONFIG_BT_SETTINGS) &&
   2e86c:	0743      	lsls	r3, r0, #29
   2e86e:	d501      	bpl.n	2e874 <id_create.constprop.0+0x30>
	    atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
		bt_settings_save_id();
   2e870:	f7fe ffea 	bl	2d848 <bt_settings_save_id>
	}

	return 0;
   2e874:	2000      	movs	r0, #0
}
   2e876:	b003      	add	sp, #12
   2e878:	bd30      	pop	{r4, r5, pc}
			err = bt_addr_le_create_static(&new_addr);
   2e87a:	4668      	mov	r0, sp
   2e87c:	f01c fc07 	bl	4b08e <bt_addr_le_create_static>
			if (err) {
   2e880:	2800      	cmp	r0, #0
   2e882:	d1f8      	bne.n	2e876 <id_create.constprop.0+0x32>
		} while (id_find(&new_addr) >= 0);
   2e884:	4668      	mov	r0, sp
   2e886:	f7ff ff97 	bl	2e7b8 <id_find>
   2e88a:	2800      	cmp	r0, #0
   2e88c:	daf5      	bge.n	2e87a <id_create.constprop.0+0x36>
		bt_addr_le_copy(&bt_dev.id_addr[id], &new_addr);
   2e88e:	4b07      	ldr	r3, [pc, #28]	; (2e8ac <id_create.constprop.0+0x68>)
   2e890:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
   2e894:	441c      	add	r4, r3
   2e896:	4669      	mov	r1, sp
   2e898:	4620      	mov	r0, r4
   2e89a:	f01c ff9d 	bl	4b7d8 <bt_addr_le_copy>
		if (addr) {
   2e89e:	2d00      	cmp	r5, #0
   2e8a0:	d0e1      	beq.n	2e866 <id_create.constprop.0+0x22>
			bt_addr_le_copy(addr, &bt_dev.id_addr[id]);
   2e8a2:	4621      	mov	r1, r4
   2e8a4:	4628      	mov	r0, r5
   2e8a6:	e7dc      	b.n	2e862 <id_create.constprop.0+0x1e>
   2e8a8:	00053517 	.word	0x00053517
   2e8ac:	20000030 	.word	0x20000030
   2e8b0:	200000fc 	.word	0x200000fc

0002e8b4 <bt_id_adv_random_addr_check>:
{
   2e8b4:	b508      	push	{r3, lr}
   2e8b6:	4603      	mov	r3, r0
   2e8b8:	4814      	ldr	r0, [pc, #80]	; (2e90c <bt_id_adv_random_addr_check+0x58>)
   2e8ba:	4a14      	ldr	r2, [pc, #80]	; (2e90c <bt_id_adv_random_addr_check+0x58>)
   2e8bc:	f01c ff8f 	bl	4b7de <atomic_get>
	if (!(atomic_test_bit(bt_dev.flags, BT_DEV_INITIATING) ||
   2e8c0:	f410 5f80 	tst.w	r0, #4096	; 0x1000
   2e8c4:	d006      	beq.n	2e8d4 <bt_id_adv_random_addr_check+0x20>
   2e8c6:	4811      	ldr	r0, [pc, #68]	; (2e90c <bt_id_adv_random_addr_check+0x58>)
   2e8c8:	f01c ff89 	bl	4b7de <atomic_get>
	} else if (IS_ENABLED(CONFIG_BT_SCAN_WITH_IDENTITY) &&
   2e8cc:	0640      	lsls	r0, r0, #25
   2e8ce:	d407      	bmi.n	2e8e0 <bt_id_adv_random_addr_check+0x2c>
	return true;
   2e8d0:	2001      	movs	r0, #1
}
   2e8d2:	bd08      	pop	{r3, pc}
   2e8d4:	4610      	mov	r0, r2
   2e8d6:	f01c ff82 	bl	4b7de <atomic_get>
	if (!(atomic_test_bit(bt_dev.flags, BT_DEV_INITIATING) ||
   2e8da:	0641      	lsls	r1, r0, #25
   2e8dc:	d4f3      	bmi.n	2e8c6 <bt_id_adv_random_addr_check+0x12>
   2e8de:	e7f7      	b.n	2e8d0 <bt_id_adv_random_addr_check+0x1c>
		   atomic_test_bit(bt_dev.flags, BT_DEV_SCANNING) &&
   2e8e0:	f812 2ccc 	ldrb.w	r2, [r2, #-204]
   2e8e4:	2a01      	cmp	r2, #1
   2e8e6:	d1f3      	bne.n	2e8d0 <bt_id_adv_random_addr_check+0x1c>
		if (!(param->options & BT_LE_ADV_OPT_CONNECTABLE) &&
   2e8e8:	685a      	ldr	r2, [r3, #4]
   2e8ea:	f002 0205 	and.w	r2, r2, #5
   2e8ee:	2a04      	cmp	r2, #4
   2e8f0:	d00a      	beq.n	2e908 <bt_id_adv_random_addr_check+0x54>
		} else if (bt_dev.id_addr[param->id].type ==
   2e8f2:	7818      	ldrb	r0, [r3, #0]
   2e8f4:	4a06      	ldr	r2, [pc, #24]	; (2e910 <bt_id_adv_random_addr_check+0x5c>)
   2e8f6:	ebc0 03c0 	rsb	r3, r0, r0, lsl #3
   2e8fa:	5cd3      	ldrb	r3, [r2, r3]
   2e8fc:	2b01      	cmp	r3, #1
   2e8fe:	d1e7      	bne.n	2e8d0 <bt_id_adv_random_addr_check+0x1c>
			   BT_ADDR_LE_RANDOM &&
   2e900:	fab0 f080 	clz	r0, r0
   2e904:	0940      	lsrs	r0, r0, #5
   2e906:	e7e4      	b.n	2e8d2 <bt_id_adv_random_addr_check+0x1e>
			return false;
   2e908:	2000      	movs	r0, #0
   2e90a:	e7e2      	b.n	2e8d2 <bt_id_adv_random_addr_check+0x1e>
   2e90c:	200000fc 	.word	0x200000fc
   2e910:	20000030 	.word	0x20000030

0002e914 <bt_id_pending_keys_update>:
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   2e914:	4b0a      	ldr	r3, [pc, #40]	; (2e940 <bt_id_pending_keys_update+0x2c>)
   2e916:	f3bf 8f5b 	dmb	ish
   2e91a:	e853 2f00 	ldrex	r2, [r3]
   2e91e:	f422 4100 	bic.w	r1, r2, #32768	; 0x8000
   2e922:	e843 1000 	strex	r0, r1, [r3]
   2e926:	2800      	cmp	r0, #0
   2e928:	d1f7      	bne.n	2e91a <bt_id_pending_keys_update+0x6>
   2e92a:	f3bf 8f5b 	dmb	ish
	if (atomic_test_and_clear_bit(bt_dev.flags, BT_DEV_ID_PENDING)) {
   2e92e:	0413      	lsls	r3, r2, #16
   2e930:	d504      	bpl.n	2e93c <bt_id_pending_keys_update+0x28>
			bt_keys_foreach_type(BT_KEYS_IRK, pending_id_update, NULL);
   2e932:	4904      	ldr	r1, [pc, #16]	; (2e944 <bt_id_pending_keys_update+0x30>)
   2e934:	2200      	movs	r2, #0
   2e936:	2002      	movs	r0, #2
   2e938:	f005 bc90 	b.w	3425c <bt_keys_foreach_type>
}
   2e93c:	4770      	bx	lr
   2e93e:	bf00      	nop
   2e940:	200000fc 	.word	0x200000fc
   2e944:	0004b93b 	.word	0x0004b93b

0002e948 <bt_id_add>:
{
   2e948:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	if (!bt_dev.le.rl_size || bt_dev.le.rl_entries > bt_dev.le.rl_size) {
   2e94c:	4c4e      	ldr	r4, [pc, #312]	; (2ea88 <bt_id_add+0x140>)
   2e94e:	f894 2118 	ldrb.w	r2, [r4, #280]	; 0x118
   2e952:	f894 3119 	ldrb.w	r3, [r4, #281]	; 0x119
{
   2e956:	4605      	mov	r5, r0
	if (!bt_dev.le.rl_size || bt_dev.le.rl_entries > bt_dev.le.rl_size) {
   2e958:	b10a      	cbz	r2, 2e95e <bt_id_add+0x16>
   2e95a:	429a      	cmp	r2, r3
   2e95c:	d209      	bcs.n	2e972 <bt_id_add+0x2a>
		bt_dev.le.rl_entries++;
   2e95e:	3301      	adds	r3, #1
   2e960:	f884 3119 	strb.w	r3, [r4, #281]	; 0x119
		keys->state |= BT_KEYS_ID_ADDED;
   2e964:	7a2b      	ldrb	r3, [r5, #8]
   2e966:	f043 0304 	orr.w	r3, r3, #4
   2e96a:	722b      	strb	r3, [r5, #8]
}
   2e96c:	b002      	add	sp, #8
   2e96e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	conn = bt_conn_lookup_state_le(BT_ID_DEFAULT, NULL, BT_CONN_CONNECTING);
   2e972:	2100      	movs	r1, #0
   2e974:	2206      	movs	r2, #6
   2e976:	4608      	mov	r0, r1
   2e978:	f001 fc1c 	bl	301b4 <bt_conn_lookup_state_le>
	if (conn) {
   2e97c:	f104 03cc 	add.w	r3, r4, #204	; 0xcc
   2e980:	4606      	mov	r6, r0
   2e982:	b1a0      	cbz	r0, 2e9ae <bt_id_add+0x66>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   2e984:	f3bf 8f5b 	dmb	ish
   2e988:	e853 1f00 	ldrex	r1, [r3]
   2e98c:	f441 4100 	orr.w	r1, r1, #32768	; 0x8000
   2e990:	e843 1200 	strex	r2, r1, [r3]
   2e994:	2a00      	cmp	r2, #0
   2e996:	d1f7      	bne.n	2e988 <bt_id_add+0x40>
   2e998:	f3bf 8f5b 	dmb	ish
	keys->state |= flag;
   2e99c:	7a2b      	ldrb	r3, [r5, #8]
   2e99e:	f043 0301 	orr.w	r3, r3, #1
   2e9a2:	722b      	strb	r3, [r5, #8]
}
   2e9a4:	b002      	add	sp, #8
   2e9a6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		bt_conn_unref(conn);
   2e9aa:	f01d ba0c 	b.w	4bdc6 <bt_conn_unref>
   2e9ae:	4618      	mov	r0, r3
   2e9b0:	f01c ff15 	bl	4b7de <atomic_get>
		bt_le_ext_adv_foreach(adv_pause_enabled, NULL);
   2e9b4:	4631      	mov	r1, r6
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
   2e9b6:	f3c0 1780 	ubfx	r7, r0, #6, #1
   2e9ba:	4834      	ldr	r0, [pc, #208]	; (2ea8c <bt_id_add+0x144>)
   2e9bc:	f000 fac6 	bl	2ef4c <bt_le_ext_adv_foreach>
	if (scan_enabled) {
   2e9c0:	b117      	cbz	r7, 2e9c8 <bt_id_add+0x80>
		bt_le_scan_set_enable(BT_HCI_LE_SCAN_DISABLE);
   2e9c2:	4630      	mov	r0, r6
   2e9c4:	f01d f927 	bl	4bc16 <bt_le_scan_set_enable>
	if (bt_dev.le.rl_entries) {
   2e9c8:	f894 3119 	ldrb.w	r3, [r4, #281]	; 0x119
   2e9cc:	b9b3      	cbnz	r3, 2e9fc <bt_id_add+0xb4>
	if (bt_dev.le.rl_entries == bt_dev.le.rl_size) {
   2e9ce:	f894 2119 	ldrb.w	r2, [r4, #281]	; 0x119
   2e9d2:	f894 3118 	ldrb.w	r3, [r4, #280]	; 0x118
   2e9d6:	429a      	cmp	r2, r3
   2e9d8:	d123      	bne.n	2ea22 <bt_id_add+0xda>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_CLEAR_RL, NULL, NULL);
   2e9da:	2200      	movs	r2, #0
   2e9dc:	4611      	mov	r1, r2
   2e9de:	f242 0029 	movw	r0, #8233	; 0x2029
   2e9e2:	f7ff fa9f 	bl	2df24 <bt_hci_cmd_send_sync>
		if (err) {
   2e9e6:	b970      	cbnz	r0, 2ea06 <bt_id_add+0xbe>
		bt_dev.le.rl_entries++;
   2e9e8:	f894 3119 	ldrb.w	r3, [r4, #281]	; 0x119
   2e9ec:	3301      	adds	r3, #1
   2e9ee:	f884 3119 	strb.w	r3, [r4, #281]	; 0x119
		keys->state |= BT_KEYS_ID_ADDED;
   2e9f2:	7a2b      	ldrb	r3, [r5, #8]
   2e9f4:	f043 0304 	orr.w	r3, r3, #4
   2e9f8:	722b      	strb	r3, [r5, #8]
		goto done;
   2e9fa:	e004      	b.n	2ea06 <bt_id_add+0xbe>
		err = addr_res_enable(BT_HCI_ADDR_RES_DISABLE);
   2e9fc:	2000      	movs	r0, #0
   2e9fe:	f01c ff45 	bl	4b88c <addr_res_enable>
		if (err) {
   2ea02:	2800      	cmp	r0, #0
   2ea04:	d0e3      	beq.n	2e9ce <bt_id_add+0x86>
	addr_res_enable(BT_HCI_ADDR_RES_ENABLE);
   2ea06:	2001      	movs	r0, #1
   2ea08:	f01c ff40 	bl	4b88c <addr_res_enable>
	if (scan_enabled) {
   2ea0c:	b117      	cbz	r7, 2ea14 <bt_id_add+0xcc>
		bt_le_scan_set_enable(BT_HCI_LE_SCAN_ENABLE);
   2ea0e:	2001      	movs	r0, #1
   2ea10:	f01d f901 	bl	4bc16 <bt_le_scan_set_enable>
		bt_le_ext_adv_foreach(adv_unpause_enabled, NULL);
   2ea14:	481e      	ldr	r0, [pc, #120]	; (2ea90 <bt_id_add+0x148>)
   2ea16:	2100      	movs	r1, #0
}
   2ea18:	b002      	add	sp, #8
   2ea1a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		bt_le_ext_adv_foreach(adv_unpause_enabled, NULL);
   2ea1e:	f000 ba95 	b.w	2ef4c <bt_le_ext_adv_foreach>
	err = hci_id_add(keys->id, &keys->addr, keys->irk.val);
   2ea22:	462a      	mov	r2, r5
   2ea24:	f105 0801 	add.w	r8, r5, #1
   2ea28:	f812 0b2a 	ldrb.w	r0, [r2], #42
   2ea2c:	4641      	mov	r1, r8
   2ea2e:	f01c fedc 	bl	4b7ea <hci_id_add>
	if (err) {
   2ea32:	4606      	mov	r6, r0
   2ea34:	2800      	cmp	r0, #0
   2ea36:	d1e6      	bne.n	2ea06 <bt_id_add+0xbe>
	bt_dev.le.rl_entries++;
   2ea38:	f894 3119 	ldrb.w	r3, [r4, #281]	; 0x119
   2ea3c:	3301      	adds	r3, #1
   2ea3e:	f884 3119 	strb.w	r3, [r4, #281]	; 0x119
	keys->state |= BT_KEYS_ID_ADDED;
   2ea42:	7a2b      	ldrb	r3, [r5, #8]
   2ea44:	f043 0304 	orr.w	r3, r3, #4
   2ea48:	722b      	strb	r3, [r5, #8]
	if (!BT_CMD_TEST(bt_dev.supported_commands, 39, 2)) {
   2ea4a:	f894 309f 	ldrb.w	r3, [r4, #159]	; 0x9f
   2ea4e:	075b      	lsls	r3, r3, #29
   2ea50:	d5d9      	bpl.n	2ea06 <bt_id_add+0xbe>
	bt_addr_le_copy(&cp.id_addr, addr);
   2ea52:	4641      	mov	r1, r8
   2ea54:	4668      	mov	r0, sp
   2ea56:	f01c febf 	bl	4b7d8 <bt_addr_le_copy>
	cp.mode = mode;
   2ea5a:	2301      	movs	r3, #1
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_PRIVACY_MODE, sizeof(cp));
   2ea5c:	2108      	movs	r1, #8
   2ea5e:	f242 004e 	movw	r0, #8270	; 0x204e
	cp.mode = mode;
   2ea62:	f88d 3007 	strb.w	r3, [sp, #7]
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_PRIVACY_MODE, sizeof(cp));
   2ea66:	f7ff fa01 	bl	2de6c <bt_hci_cmd_create>
	if (!buf) {
   2ea6a:	4604      	mov	r4, r0
   2ea6c:	2800      	cmp	r0, #0
   2ea6e:	d0ca      	beq.n	2ea06 <bt_id_add+0xbe>
   2ea70:	2208      	movs	r2, #8
   2ea72:	4669      	mov	r1, sp
   2ea74:	4410      	add	r0, r2
   2ea76:	f020 f9a3 	bl	4edc0 <net_buf_simple_add_mem>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_PRIVACY_MODE, buf, NULL);
   2ea7a:	4632      	mov	r2, r6
   2ea7c:	4621      	mov	r1, r4
   2ea7e:	f242 004e 	movw	r0, #8270	; 0x204e
   2ea82:	f7ff fa4f 	bl	2df24 <bt_hci_cmd_send_sync>
	if (err) {
   2ea86:	e7be      	b.n	2ea06 <bt_id_add+0xbe>
   2ea88:	20000030 	.word	0x20000030
   2ea8c:	0004b8bd 	.word	0x0004b8bd
   2ea90:	0004b849 	.word	0x0004b849

0002ea94 <bt_id_del>:
{
   2ea94:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	if (!bt_dev.le.rl_size ||
   2ea98:	4d45      	ldr	r5, [pc, #276]	; (2ebb0 <bt_id_del+0x11c>)
   2ea9a:	f895 2118 	ldrb.w	r2, [r5, #280]	; 0x118
	    bt_dev.le.rl_entries > bt_dev.le.rl_size + 1) {
   2ea9e:	f895 3119 	ldrb.w	r3, [r5, #281]	; 0x119
{
   2eaa2:	4604      	mov	r4, r0
	if (!bt_dev.le.rl_size ||
   2eaa4:	b112      	cbz	r2, 2eaac <bt_id_del+0x18>
	    bt_dev.le.rl_entries > bt_dev.le.rl_size + 1) {
   2eaa6:	3201      	adds	r2, #1
	if (!bt_dev.le.rl_size ||
   2eaa8:	4293      	cmp	r3, r2
   2eaaa:	dd08      	ble.n	2eabe <bt_id_del+0x2a>
		bt_dev.le.rl_entries--;
   2eaac:	3b01      	subs	r3, #1
   2eaae:	f885 3119 	strb.w	r3, [r5, #281]	; 0x119
		keys->state &= ~BT_KEYS_ID_ADDED;
   2eab2:	7a23      	ldrb	r3, [r4, #8]
   2eab4:	f023 0304 	bic.w	r3, r3, #4
   2eab8:	7223      	strb	r3, [r4, #8]
}
   2eaba:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	conn = bt_conn_lookup_state_le(BT_ID_DEFAULT, NULL, BT_CONN_CONNECTING);
   2eabe:	2100      	movs	r1, #0
   2eac0:	2206      	movs	r2, #6
   2eac2:	4608      	mov	r0, r1
   2eac4:	f001 fb76 	bl	301b4 <bt_conn_lookup_state_le>
	if (conn) {
   2eac8:	f105 03cc 	add.w	r3, r5, #204	; 0xcc
   2eacc:	4606      	mov	r6, r0
   2eace:	b198      	cbz	r0, 2eaf8 <bt_id_del+0x64>
   2ead0:	f3bf 8f5b 	dmb	ish
   2ead4:	e853 1f00 	ldrex	r1, [r3]
   2ead8:	f441 4100 	orr.w	r1, r1, #32768	; 0x8000
   2eadc:	e843 1200 	strex	r2, r1, [r3]
   2eae0:	2a00      	cmp	r2, #0
   2eae2:	d1f7      	bne.n	2ead4 <bt_id_del+0x40>
   2eae4:	f3bf 8f5b 	dmb	ish
	keys->state |= flag;
   2eae8:	7a23      	ldrb	r3, [r4, #8]
   2eaea:	f043 0302 	orr.w	r3, r3, #2
   2eaee:	7223      	strb	r3, [r4, #8]
}
   2eaf0:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		bt_conn_unref(conn);
   2eaf4:	f01d b967 	b.w	4bdc6 <bt_conn_unref>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
   2eaf8:	4618      	mov	r0, r3
   2eafa:	f01c fe70 	bl	4b7de <atomic_get>
		bt_le_ext_adv_foreach(adv_pause_enabled, NULL);
   2eafe:	4631      	mov	r1, r6
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
   2eb00:	f3c0 1880 	ubfx	r8, r0, #6, #1
   2eb04:	482b      	ldr	r0, [pc, #172]	; (2ebb4 <bt_id_del+0x120>)
   2eb06:	f000 fa21 	bl	2ef4c <bt_le_ext_adv_foreach>
	if (scan_enabled) {
   2eb0a:	f1b8 0f00 	cmp.w	r8, #0
   2eb0e:	d002      	beq.n	2eb16 <bt_id_del+0x82>
		bt_le_scan_set_enable(BT_HCI_LE_SCAN_DISABLE);
   2eb10:	4630      	mov	r0, r6
   2eb12:	f01d f880 	bl	4bc16 <bt_le_scan_set_enable>
	err = addr_res_enable(BT_HCI_ADDR_RES_DISABLE);
   2eb16:	2000      	movs	r0, #0
   2eb18:	f01c feb8 	bl	4b88c <addr_res_enable>
	if (err) {
   2eb1c:	4607      	mov	r7, r0
   2eb1e:	b988      	cbnz	r0, 2eb44 <bt_id_del+0xb0>
	if (bt_dev.le.rl_entries > bt_dev.le.rl_size) {
   2eb20:	f895 3119 	ldrb.w	r3, [r5, #281]	; 0x119
   2eb24:	f895 2118 	ldrb.w	r2, [r5, #280]	; 0x118
   2eb28:	429a      	cmp	r2, r3
   2eb2a:	d21d      	bcs.n	2eb68 <bt_id_del+0xd4>
		bt_dev.le.rl_entries--;
   2eb2c:	3b01      	subs	r3, #1
   2eb2e:	f885 3119 	strb.w	r3, [r5, #281]	; 0x119
		keys->state &= ~BT_KEYS_ID_ADDED;
   2eb32:	7a23      	ldrb	r3, [r4, #8]
			bt_keys_foreach_type(BT_KEYS_IRK, keys_add_id, NULL);
   2eb34:	4920      	ldr	r1, [pc, #128]	; (2ebb8 <bt_id_del+0x124>)
		keys->state &= ~BT_KEYS_ID_ADDED;
   2eb36:	f023 0304 	bic.w	r3, r3, #4
			bt_keys_foreach_type(BT_KEYS_IRK, keys_add_id, NULL);
   2eb3a:	4602      	mov	r2, r0
		keys->state &= ~BT_KEYS_ID_ADDED;
   2eb3c:	7223      	strb	r3, [r4, #8]
			bt_keys_foreach_type(BT_KEYS_IRK, keys_add_id, NULL);
   2eb3e:	2002      	movs	r0, #2
   2eb40:	f005 fb8c 	bl	3425c <bt_keys_foreach_type>
	if (bt_dev.le.rl_entries) {
   2eb44:	f895 3119 	ldrb.w	r3, [r5, #281]	; 0x119
   2eb48:	b113      	cbz	r3, 2eb50 <bt_id_del+0xbc>
		addr_res_enable(BT_HCI_ADDR_RES_ENABLE);
   2eb4a:	2001      	movs	r0, #1
   2eb4c:	f01c fe9e 	bl	4b88c <addr_res_enable>
	if (scan_enabled) {
   2eb50:	f1b8 0f00 	cmp.w	r8, #0
   2eb54:	d002      	beq.n	2eb5c <bt_id_del+0xc8>
		bt_le_scan_set_enable(BT_HCI_LE_SCAN_ENABLE);
   2eb56:	2001      	movs	r0, #1
   2eb58:	f01d f85d 	bl	4bc16 <bt_le_scan_set_enable>
}
   2eb5c:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		bt_le_ext_adv_foreach(adv_unpause_enabled, NULL);
   2eb60:	4816      	ldr	r0, [pc, #88]	; (2ebbc <bt_id_del+0x128>)
   2eb62:	2100      	movs	r1, #0
   2eb64:	f000 b9f2 	b.w	2ef4c <bt_le_ext_adv_foreach>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_REM_DEV_FROM_RL, sizeof(*cp));
   2eb68:	2107      	movs	r1, #7
   2eb6a:	f242 0028 	movw	r0, #8232	; 0x2028
   2eb6e:	f7ff f97d 	bl	2de6c <bt_hci_cmd_create>
	err = hci_id_del(&keys->addr);
   2eb72:	f104 0901 	add.w	r9, r4, #1
	if (!buf) {
   2eb76:	4606      	mov	r6, r0
   2eb78:	2800      	cmp	r0, #0
   2eb7a:	d0e3      	beq.n	2eb44 <bt_id_del+0xb0>
	return net_buf_simple_add(&buf->b, len);
   2eb7c:	2107      	movs	r1, #7
   2eb7e:	3008      	adds	r0, #8
   2eb80:	f020 f918 	bl	4edb4 <net_buf_simple_add>
	bt_addr_le_copy(&cp->peer_id_addr, addr);
   2eb84:	4649      	mov	r1, r9
   2eb86:	f01c fe27 	bl	4b7d8 <bt_addr_le_copy>
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_REM_DEV_FROM_RL, buf, NULL);
   2eb8a:	463a      	mov	r2, r7
   2eb8c:	4631      	mov	r1, r6
   2eb8e:	f242 0028 	movw	r0, #8232	; 0x2028
   2eb92:	f7ff f9c7 	bl	2df24 <bt_hci_cmd_send_sync>
	if (err) {
   2eb96:	2800      	cmp	r0, #0
   2eb98:	d1d4      	bne.n	2eb44 <bt_id_del+0xb0>
	bt_dev.le.rl_entries--;
   2eb9a:	f895 3119 	ldrb.w	r3, [r5, #281]	; 0x119
   2eb9e:	3b01      	subs	r3, #1
   2eba0:	f885 3119 	strb.w	r3, [r5, #281]	; 0x119
	keys->state &= ~BT_KEYS_ID_ADDED;
   2eba4:	7a23      	ldrb	r3, [r4, #8]
   2eba6:	f023 0304 	bic.w	r3, r3, #4
   2ebaa:	7223      	strb	r3, [r4, #8]
   2ebac:	e7ca      	b.n	2eb44 <bt_id_del+0xb0>
   2ebae:	bf00      	nop
   2ebb0:	20000030 	.word	0x20000030
   2ebb4:	0004b8bd 	.word	0x0004b8bd
   2ebb8:	0004b877 	.word	0x0004b877
   2ebbc:	0004b849 	.word	0x0004b849

0002ebc0 <bt_id_create>:

int bt_id_create(bt_addr_le_t *addr, uint8_t *irk)
{
   2ebc0:	b570      	push	{r4, r5, r6, lr}
   2ebc2:	460d      	mov	r5, r1
	int new_id, err;

	if (addr && bt_addr_le_cmp(addr, BT_ADDR_LE_ANY)) {
   2ebc4:	4604      	mov	r4, r0
   2ebc6:	b918      	cbnz	r0, 2ebd0 <bt_id_create+0x10>
		if (id_find(addr) >= 0) {
			return -EALREADY;
		}
	}

	if (!IS_ENABLED(CONFIG_BT_PRIVACY) && irk) {
   2ebc8:	b1c5      	cbz	r5, 2ebfc <bt_id_create+0x3c>
			return -EINVAL;
   2ebca:	f06f 0015 	mvn.w	r0, #21
	if (err) {
		return err;
	}

	return new_id;
}
   2ebce:	bd70      	pop	{r4, r5, r6, pc}
   2ebd0:	491b      	ldr	r1, [pc, #108]	; (2ec40 <bt_id_create+0x80>)
   2ebd2:	2207      	movs	r2, #7
   2ebd4:	f01c f941 	bl	4ae5a <memcmp>
	if (addr && bt_addr_le_cmp(addr, BT_ADDR_LE_ANY)) {
   2ebd8:	2800      	cmp	r0, #0
   2ebda:	d0f5      	beq.n	2ebc8 <bt_id_create+0x8>
		if (addr->type != BT_ADDR_LE_RANDOM ||
   2ebdc:	7823      	ldrb	r3, [r4, #0]
   2ebde:	2b01      	cmp	r3, #1
   2ebe0:	d1f3      	bne.n	2ebca <bt_id_create+0xa>
   2ebe2:	79a3      	ldrb	r3, [r4, #6]
   2ebe4:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   2ebe8:	2bc0      	cmp	r3, #192	; 0xc0
   2ebea:	d1ee      	bne.n	2ebca <bt_id_create+0xa>
		if (id_find(addr) >= 0) {
   2ebec:	4620      	mov	r0, r4
   2ebee:	f7ff fde3 	bl	2e7b8 <id_find>
   2ebf2:	2800      	cmp	r0, #0
   2ebf4:	dbe8      	blt.n	2ebc8 <bt_id_create+0x8>
			return -EALREADY;
   2ebf6:	f06f 0077 	mvn.w	r0, #119	; 0x77
   2ebfa:	e7e8      	b.n	2ebce <bt_id_create+0xe>
	if (bt_dev.id_count == ARRAY_SIZE(bt_dev.id_addr)) {
   2ebfc:	4e11      	ldr	r6, [pc, #68]	; (2ec44 <bt_id_create+0x84>)
   2ebfe:	79f3      	ldrb	r3, [r6, #7]
   2ec00:	2b01      	cmp	r3, #1
   2ec02:	d01a      	beq.n	2ec3a <bt_id_create+0x7a>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
   2ec04:	f106 00cc 	add.w	r0, r6, #204	; 0xcc
   2ec08:	f01c fde9 	bl	4b7de <atomic_get>
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_ENABLE)) {
   2ec0c:	07c3      	lsls	r3, r0, #31
   2ec0e:	d50a      	bpl.n	2ec26 <bt_id_create+0x66>
	new_id = bt_dev.id_count++;
   2ec10:	79f5      	ldrb	r5, [r6, #7]
	err = id_create(new_id, addr, irk);
   2ec12:	4621      	mov	r1, r4
	new_id = bt_dev.id_count++;
   2ec14:	1c6b      	adds	r3, r5, #1
	err = id_create(new_id, addr, irk);
   2ec16:	4628      	mov	r0, r5
	new_id = bt_dev.id_count++;
   2ec18:	71f3      	strb	r3, [r6, #7]
	err = id_create(new_id, addr, irk);
   2ec1a:	f7ff fe13 	bl	2e844 <id_create.constprop.0>
	new_id = bt_dev.id_count++;
   2ec1e:	2800      	cmp	r0, #0
   2ec20:	bf08      	it	eq
   2ec22:	4628      	moveq	r0, r5
   2ec24:	e7d3      	b.n	2ebce <bt_id_create+0xe>
		if (!(addr && bt_addr_le_cmp(addr, BT_ADDR_LE_ANY))) {
   2ec26:	2c00      	cmp	r4, #0
   2ec28:	d0cf      	beq.n	2ebca <bt_id_create+0xa>
   2ec2a:	4905      	ldr	r1, [pc, #20]	; (2ec40 <bt_id_create+0x80>)
   2ec2c:	2207      	movs	r2, #7
   2ec2e:	4620      	mov	r0, r4
   2ec30:	f01c f913 	bl	4ae5a <memcmp>
   2ec34:	2800      	cmp	r0, #0
   2ec36:	d1eb      	bne.n	2ec10 <bt_id_create+0x50>
   2ec38:	e7c7      	b.n	2ebca <bt_id_create+0xa>
		return -ENOMEM;
   2ec3a:	f06f 000b 	mvn.w	r0, #11
   2ec3e:	e7c6      	b.n	2ebce <bt_id_create+0xe>
   2ec40:	00053517 	.word	0x00053517
   2ec44:	20000030 	.word	0x20000030

0002ec48 <bt_id_read_public_addr>:
#endif /* defined(CONFIG_BT_HCI_VS_EXT) */
}
#endif /* defined(CONFIG_BT_PRIVACY) */

uint8_t bt_id_read_public_addr(bt_addr_le_t *addr)
{
   2ec48:	b573      	push	{r0, r1, r4, r5, r6, lr}
   2ec4a:	4605      	mov	r5, r0
	struct bt_hci_rp_read_bd_addr *rp;
	struct net_buf *rsp;
	int err;

	/* Read Bluetooth Address */
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_BD_ADDR, NULL, &rsp);
   2ec4c:	aa01      	add	r2, sp, #4
   2ec4e:	2100      	movs	r1, #0
   2ec50:	f241 0009 	movw	r0, #4105	; 0x1009
   2ec54:	f7ff f966 	bl	2df24 <bt_hci_cmd_send_sync>
	if (err) {
   2ec58:	4606      	mov	r6, r0
   2ec5a:	b958      	cbnz	r0, 2ec74 <bt_id_read_public_addr+0x2c>
		BT_WARN("Failed to read public address");
		return 0U;
	}

	rp = (void *)rsp->data;
   2ec5c:	9b01      	ldr	r3, [sp, #4]
	return memcmp(a, b, sizeof(*a));
   2ec5e:	4910      	ldr	r1, [pc, #64]	; (2eca0 <bt_id_read_public_addr+0x58>)

	if (!bt_addr_cmp(&rp->bdaddr, BT_ADDR_ANY) ||
   2ec60:	689c      	ldr	r4, [r3, #8]
   2ec62:	3401      	adds	r4, #1
   2ec64:	2206      	movs	r2, #6
   2ec66:	4620      	mov	r0, r4
   2ec68:	f01c f8f7 	bl	4ae5a <memcmp>
   2ec6c:	b928      	cbnz	r0, 2ec7a <bt_id_read_public_addr+0x32>
	    !bt_addr_cmp(&rp->bdaddr, BT_ADDR_NONE)) {
		BT_DBG("Controller has no public address");
		net_buf_unref(rsp);
   2ec6e:	9801      	ldr	r0, [sp, #4]
   2ec70:	f013 fdea 	bl	42848 <net_buf_unref>
		return 0U;
   2ec74:	2000      	movs	r0, #0
	bt_addr_copy(&addr->a, &rp->bdaddr);
	addr->type = BT_ADDR_LE_PUBLIC;

	net_buf_unref(rsp);
	return 1U;
}
   2ec76:	b002      	add	sp, #8
   2ec78:	bd70      	pop	{r4, r5, r6, pc}
   2ec7a:	490a      	ldr	r1, [pc, #40]	; (2eca4 <bt_id_read_public_addr+0x5c>)
   2ec7c:	2206      	movs	r2, #6
   2ec7e:	4620      	mov	r0, r4
   2ec80:	f01c f8eb 	bl	4ae5a <memcmp>
	if (!bt_addr_cmp(&rp->bdaddr, BT_ADDR_ANY) ||
   2ec84:	2800      	cmp	r0, #0
   2ec86:	d0f2      	beq.n	2ec6e <bt_id_read_public_addr+0x26>
	memcpy(dst, src, sizeof(*dst));
   2ec88:	2206      	movs	r2, #6
   2ec8a:	4621      	mov	r1, r4
   2ec8c:	1c68      	adds	r0, r5, #1
   2ec8e:	f01c f8f4 	bl	4ae7a <memcpy>
	net_buf_unref(rsp);
   2ec92:	9801      	ldr	r0, [sp, #4]
	addr->type = BT_ADDR_LE_PUBLIC;
   2ec94:	702e      	strb	r6, [r5, #0]
	net_buf_unref(rsp);
   2ec96:	f013 fdd7 	bl	42848 <net_buf_unref>
	return 1U;
   2ec9a:	2001      	movs	r0, #1
   2ec9c:	e7eb      	b.n	2ec76 <bt_id_read_public_addr+0x2e>
   2ec9e:	bf00      	nop
   2eca0:	00053524 	.word	0x00053524
   2eca4:	0005351e 	.word	0x0005351e

0002eca8 <bt_setup_public_id_addr>:

int bt_setup_public_id_addr(void)
{
   2eca8:	b507      	push	{r0, r1, r2, lr}
	bt_addr_le_t addr;
	uint8_t *irk = NULL;

	bt_dev.id_count = bt_id_read_public_addr(&addr);
   2ecaa:	4668      	mov	r0, sp
   2ecac:	f7ff ffcc 	bl	2ec48 <bt_id_read_public_addr>
   2ecb0:	4b04      	ldr	r3, [pc, #16]	; (2ecc4 <bt_setup_public_id_addr+0x1c>)
   2ecb2:	71d8      	strb	r0, [r3, #7]

	if (!bt_dev.id_count) {
   2ecb4:	b118      	cbz	r0, 2ecbe <bt_setup_public_id_addr+0x16>
		if (IS_ENABLED(CONFIG_BT_SETTINGS)) {
			atomic_set_bit(bt_dev.flags, BT_DEV_STORE_ID);
		}
	}

	return id_create(BT_ID_DEFAULT, &addr, irk);
   2ecb6:	4669      	mov	r1, sp
   2ecb8:	2000      	movs	r0, #0
   2ecba:	f7ff fdc3 	bl	2e844 <id_create.constprop.0>
}
   2ecbe:	b003      	add	sp, #12
   2ecc0:	f85d fb04 	ldr.w	pc, [sp], #4
   2ecc4:	20000030 	.word	0x20000030

0002ecc8 <bt_read_static_addr>:

#if defined(CONFIG_BT_HCI_VS_EXT)
uint8_t bt_read_static_addr(struct bt_hci_vs_static_addr addrs[], uint8_t size)
{
   2ecc8:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	struct bt_hci_rp_vs_read_static_addrs *rp;
	struct net_buf *rsp;
	int err, i;
	uint8_t cnt;

	if (!BT_VS_CMD_READ_STATIC_ADDRS(bt_dev.vs_commands)) {
   2eccc:	4b15      	ldr	r3, [pc, #84]	; (2ed24 <bt_read_static_addr+0x5c>)
   2ecce:	f893 30ba 	ldrb.w	r3, [r3, #186]	; 0xba
   2ecd2:	07db      	lsls	r3, r3, #31
{
   2ecd4:	4607      	mov	r7, r0
   2ecd6:	460e      	mov	r6, r1
	if (!BT_VS_CMD_READ_STATIC_ADDRS(bt_dev.vs_commands)) {
   2ecd8:	d404      	bmi.n	2ece4 <bt_read_static_addr+0x1c>
		BT_WARN("Read Static Addresses command not available");
		return 0;
   2ecda:	2500      	movs	r5, #0
	if (!cnt) {
		BT_WARN("No static addresses stored in controller");
	}

	return cnt;
}
   2ecdc:	4628      	mov	r0, r5
   2ecde:	b002      	add	sp, #8
   2ece0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_STATIC_ADDRS, NULL, &rsp);
   2ece4:	aa01      	add	r2, sp, #4
   2ece6:	2100      	movs	r1, #0
   2ece8:	f64f 4009 	movw	r0, #64521	; 0xfc09
   2ecec:	f7ff f91a 	bl	2df24 <bt_hci_cmd_send_sync>
	if (err) {
   2ecf0:	4604      	mov	r4, r0
   2ecf2:	2800      	cmp	r0, #0
   2ecf4:	d1f1      	bne.n	2ecda <bt_read_static_addr+0x12>
	rp = (void *)rsp->data;
   2ecf6:	9b01      	ldr	r3, [sp, #4]
   2ecf8:	689b      	ldr	r3, [r3, #8]
	cnt = MIN(rp->num_addrs, size);
   2ecfa:	785d      	ldrb	r5, [r3, #1]
   2ecfc:	42b5      	cmp	r5, r6
   2ecfe:	bf28      	it	cs
   2ed00:	4635      	movcs	r5, r6
		memcpy(&addrs[i], rp->a, sizeof(struct bt_hci_vs_static_addr));
   2ed02:	f04f 0816 	mov.w	r8, #22
   2ed06:	1c9e      	adds	r6, r3, #2
	for (i = 0; i < cnt; i++) {
   2ed08:	42a5      	cmp	r5, r4
   2ed0a:	dc03      	bgt.n	2ed14 <bt_read_static_addr+0x4c>
	net_buf_unref(rsp);
   2ed0c:	9801      	ldr	r0, [sp, #4]
   2ed0e:	f013 fd9b 	bl	42848 <net_buf_unref>
	if (!cnt) {
   2ed12:	e7e3      	b.n	2ecdc <bt_read_static_addr+0x14>
		memcpy(&addrs[i], rp->a, sizeof(struct bt_hci_vs_static_addr));
   2ed14:	fb08 7004 	mla	r0, r8, r4, r7
   2ed18:	2216      	movs	r2, #22
   2ed1a:	4631      	mov	r1, r6
   2ed1c:	f01c f8ad 	bl	4ae7a <memcpy>
	for (i = 0; i < cnt; i++) {
   2ed20:	3401      	adds	r4, #1
   2ed22:	e7f1      	b.n	2ed08 <bt_read_static_addr+0x40>
   2ed24:	20000030 	.word	0x20000030

0002ed28 <bt_setup_random_id_addr>:
#endif /* CONFIG_BT_HCI_VS_EXT */

int bt_setup_random_id_addr(void)
{
   2ed28:	b5f0      	push	{r4, r5, r6, r7, lr}
#if defined(CONFIG_BT_HCI_VS_EXT) || defined(CONFIG_BT_CTLR)
	/* Only read the addresses if the user has not already configured one or
	 * more identities (!bt_dev.id_count).
	 */
	if (!bt_dev.id_count) {
   2ed2a:	4e15      	ldr	r6, [pc, #84]	; (2ed80 <bt_setup_random_id_addr+0x58>)
   2ed2c:	79f4      	ldrb	r4, [r6, #7]
{
   2ed2e:	b089      	sub	sp, #36	; 0x24
	if (!bt_dev.id_count) {
   2ed30:	b92c      	cbnz	r4, 2ed3e <bt_setup_random_id_addr+0x16>
		struct bt_hci_vs_static_addr addrs[CONFIG_BT_ID_MAX];

		bt_dev.id_count = bt_read_static_addr(addrs, CONFIG_BT_ID_MAX);
   2ed32:	2101      	movs	r1, #1
   2ed34:	a802      	add	r0, sp, #8
   2ed36:	f7ff ffc7 	bl	2ecc8 <bt_read_static_addr>
   2ed3a:	71f0      	strb	r0, [r6, #7]

		if (bt_dev.id_count) {
   2ed3c:	b9c8      	cbnz	r0, 2ed72 <bt_setup_random_id_addr+0x4a>

	if (IS_ENABLED(CONFIG_BT_PRIVACY) && IS_ENABLED(CONFIG_BT_SETTINGS)) {
		atomic_set_bit(bt_dev.flags, BT_DEV_STORE_ID);
	}

	return bt_id_create(NULL, NULL);
   2ed3e:	2100      	movs	r1, #0
   2ed40:	4608      	mov	r0, r1
}
   2ed42:	b009      	add	sp, #36	; 0x24
   2ed44:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	return bt_id_create(NULL, NULL);
   2ed48:	f7ff bf3a 	b.w	2ebc0 <bt_id_create>
   2ed4c:	ab02      	add	r3, sp, #8
   2ed4e:	fb07 3105 	mla	r1, r7, r5, r3
   2ed52:	2206      	movs	r2, #6
   2ed54:	f10d 0001 	add.w	r0, sp, #1
   2ed58:	f01c f88f 	bl	4ae7a <memcpy>
				addr.type = BT_ADDR_LE_RANDOM;
   2ed5c:	2301      	movs	r3, #1
				err = id_create(i, &addr, irk);
   2ed5e:	4669      	mov	r1, sp
   2ed60:	4628      	mov	r0, r5
				addr.type = BT_ADDR_LE_RANDOM;
   2ed62:	f88d 3000 	strb.w	r3, [sp]
				err = id_create(i, &addr, irk);
   2ed66:	f7ff fd6d 	bl	2e844 <id_create.constprop.0>
				if (err) {
   2ed6a:	3401      	adds	r4, #1
   2ed6c:	b110      	cbz	r0, 2ed74 <bt_setup_random_id_addr+0x4c>
}
   2ed6e:	b009      	add	sp, #36	; 0x24
   2ed70:	bdf0      	pop	{r4, r5, r6, r7, pc}
				bt_addr_copy(&addr.a, &addrs[i].bdaddr);
   2ed72:	2716      	movs	r7, #22
			for (uint8_t i = 0; i < bt_dev.id_count; i++) {
   2ed74:	79f3      	ldrb	r3, [r6, #7]
   2ed76:	b2e5      	uxtb	r5, r4
   2ed78:	42ab      	cmp	r3, r5
   2ed7a:	d8e7      	bhi.n	2ed4c <bt_setup_random_id_addr+0x24>
			return 0;
   2ed7c:	2000      	movs	r0, #0
   2ed7e:	e7f6      	b.n	2ed6e <bt_setup_random_id_addr+0x46>
   2ed80:	20000030 	.word	0x20000030

0002ed84 <bt_id_set_create_conn_own_addr>:
	return true;
#endif
}

int bt_id_set_create_conn_own_addr(bool use_filter, uint8_t *own_addr_type)
{
   2ed84:	b538      	push	{r3, r4, r5, lr}

		/* If Static Random address is used as Identity address we
		 * need to restore it before creating connection. Otherwise
		 * NRPA used for active scan could be used for connection.
		 */
		if (addr->type == BT_ADDR_LE_RANDOM) {
   2ed86:	4c07      	ldr	r4, [pc, #28]	; (2eda4 <bt_id_set_create_conn_own_addr+0x20>)
   2ed88:	7823      	ldrb	r3, [r4, #0]
   2ed8a:	2b01      	cmp	r3, #1
{
   2ed8c:	460d      	mov	r5, r1
		if (addr->type == BT_ADDR_LE_RANDOM) {
   2ed8e:	d003      	beq.n	2ed98 <bt_id_set_create_conn_own_addr+0x14>
			if (err) {
				return err;
			}
		}

		*own_addr_type = addr->type;
   2ed90:	7823      	ldrb	r3, [r4, #0]
   2ed92:	702b      	strb	r3, [r5, #0]
	}

	return 0;
   2ed94:	2000      	movs	r0, #0
}
   2ed96:	bd38      	pop	{r3, r4, r5, pc}
			err = set_random_address(&addr->a);
   2ed98:	1c60      	adds	r0, r4, #1
   2ed9a:	f7ff fd27 	bl	2e7ec <set_random_address>
			if (err) {
   2ed9e:	2800      	cmp	r0, #0
   2eda0:	d0f6      	beq.n	2ed90 <bt_id_set_create_conn_own_addr+0xc>
   2eda2:	e7f8      	b.n	2ed96 <bt_id_set_create_conn_own_addr+0x12>
   2eda4:	20000030 	.word	0x20000030

0002eda8 <bt_id_set_scan_own_addr>:
			*own_addr_type = BT_HCI_OWN_ADDR_RPA_OR_RANDOM;
		} else {
			*own_addr_type = BT_ADDR_LE_RANDOM;
		}
	} else {
		*own_addr_type = bt_dev.id_addr[0].type;
   2eda8:	4804      	ldr	r0, [pc, #16]	; (2edbc <bt_id_set_scan_own_addr+0x14>)
   2edaa:	7803      	ldrb	r3, [r0, #0]
   2edac:	700b      	strb	r3, [r1, #0]
				BT_WARN("Ignoring failure to set address for passive scan (%d)",
					err);
			}

			*own_addr_type = BT_ADDR_LE_RANDOM;
		} else if (IS_ENABLED(CONFIG_BT_SCAN_WITH_IDENTITY) &&
   2edae:	2b01      	cmp	r3, #1
   2edb0:	d102      	bne.n	2edb8 <bt_id_set_scan_own_addr+0x10>
			/* If scanning with Identity Address we must set the
			 * random identity address for both active and passive
			 * scanner in order to receive adv reports that are
			 * directed towards this identity.
			 */
			err = set_random_address(&bt_dev.id_addr[0].a);
   2edb2:	3001      	adds	r0, #1
   2edb4:	f7ff bd1a 	b.w	2e7ec <set_random_address>
			}
		}
	}

	return 0;
}
   2edb8:	2000      	movs	r0, #0
   2edba:	4770      	bx	lr
   2edbc:	20000030 	.word	0x20000030

0002edc0 <bt_id_set_adv_own_addr>:
#endif /* defined(CONFIG_BT_OBSERVER) */

int bt_id_set_adv_own_addr(struct bt_le_ext_adv *adv, uint32_t options,
			   bool dir_adv, uint8_t *own_addr_type)
{
   2edc0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	int err = 0;

	/* Set which local identity address we're advertising with */
	id_addr = &bt_dev.id_addr[adv->id];

	if (options & BT_LE_ADV_OPT_CONNECTABLE) {
   2edc4:	07cf      	lsls	r7, r1, #31
	id_addr = &bt_dev.id_addr[adv->id];
   2edc6:	7804      	ldrb	r4, [r0, #0]
{
   2edc8:	460e      	mov	r6, r1
   2edca:	4690      	mov	r8, r2
   2edcc:	461d      	mov	r5, r3
	if (options & BT_LE_ADV_OPT_CONNECTABLE) {
   2edce:	d52e      	bpl.n	2ee2e <_flash_used+0x12>
		if (dir_adv && (options & BT_LE_ADV_OPT_DIR_ADDR_RPA) &&
   2edd0:	4f21      	ldr	r7, [pc, #132]	; (2ee58 <_flash_used+0x3c>)
   2edd2:	b1a2      	cbz	r2, 2edfe <bt_id_set_adv_own_addr+0x3e>
   2edd4:	0688      	lsls	r0, r1, #26
   2edd6:	d40b      	bmi.n	2edf0 <bt_id_set_adv_own_addr+0x30>
			 * If Static Random address is used as Identity
			 * address we need to restore it before advertising
			 * is enabled. Otherwise NRPA used for active scan
			 * could be used for advertising.
			 */
			if (id_addr->type == BT_ADDR_LE_RANDOM) {
   2edd8:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
   2eddc:	5cf8      	ldrb	r0, [r7, r3]
   2edde:	2801      	cmp	r0, #1
   2ede0:	d014      	beq.n	2ee0c <bt_id_set_adv_own_addr+0x4c>
				if (err) {
					return err;
				}
			}

			*own_addr_type = id_addr->type;
   2ede2:	7028      	strb	r0, [r5, #0]

			if (dir_adv && (options & BT_LE_ADV_OPT_DIR_ADDR_RPA)) {
   2ede4:	06b2      	lsls	r2, r6, #26
   2ede6:	d51f      	bpl.n	2ee28 <_flash_used+0xc>
				*own_addr_type |= BT_HCI_OWN_ADDR_RPA_MASK;
   2ede8:	f040 0002 	orr.w	r0, r0, #2
   2edec:	7028      	strb	r0, [r5, #0]
   2edee:	e01b      	b.n	2ee28 <_flash_used+0xc>
		if (dir_adv && (options & BT_LE_ADV_OPT_DIR_ADDR_RPA) &&
   2edf0:	f897 30d0 	ldrb.w	r3, [r7, #208]	; 0xd0
   2edf4:	0659      	lsls	r1, r3, #25
   2edf6:	d4ef      	bmi.n	2edd8 <bt_id_set_adv_own_addr+0x18>
			return -ENOTSUP;
   2edf8:	f06f 0085 	mvn.w	r0, #133	; 0x85
   2edfc:	e015      	b.n	2ee2a <_flash_used+0xe>
			if (id_addr->type == BT_ADDR_LE_RANDOM) {
   2edfe:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
   2ee02:	5cfb      	ldrb	r3, [r7, r3]
   2ee04:	2b01      	cmp	r3, #1
   2ee06:	d001      	beq.n	2ee0c <bt_id_set_adv_own_addr+0x4c>
		if (options & BT_LE_ADV_OPT_USE_IDENTITY) {
			if (id_addr->type == BT_ADDR_LE_RANDOM) {
				err = bt_id_set_adv_random_addr(adv, &id_addr->a);
			}

			*own_addr_type = id_addr->type;
   2ee08:	702b      	strb	r3, [r5, #0]
		} else {
			err = bt_id_set_adv_private_addr(adv);
			*own_addr_type = BT_ADDR_LE_RANDOM;
		}

		if (err) {
   2ee0a:	e00d      	b.n	2ee28 <_flash_used+0xc>
				err = bt_id_set_adv_random_addr(adv, &id_addr->a);
   2ee0c:	2007      	movs	r0, #7
   2ee0e:	fb00 7004 	mla	r0, r0, r4, r7
		return set_random_address(addr);
   2ee12:	3001      	adds	r0, #1
   2ee14:	f7ff fcea 	bl	2e7ec <set_random_address>
				if (err) {
   2ee18:	b938      	cbnz	r0, 2ee2a <_flash_used+0xe>
			*own_addr_type = id_addr->type;
   2ee1a:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
   2ee1e:	5d38      	ldrb	r0, [r7, r4]
   2ee20:	7028      	strb	r0, [r5, #0]
			if (dir_adv && (options & BT_LE_ADV_OPT_DIR_ADDR_RPA)) {
   2ee22:	f1b8 0f00 	cmp.w	r8, #0
   2ee26:	d1dd      	bne.n	2ede4 <bt_id_set_adv_own_addr+0x24>
			return err;
		}
	}

	return 0;
   2ee28:	2000      	movs	r0, #0
}
   2ee2a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (options & BT_LE_ADV_OPT_USE_IDENTITY) {
   2ee2e:	074b      	lsls	r3, r1, #29
   2ee30:	d50e      	bpl.n	2ee50 <_flash_used+0x34>
			if (id_addr->type == BT_ADDR_LE_RANDOM) {
   2ee32:	4e09      	ldr	r6, [pc, #36]	; (2ee58 <_flash_used+0x3c>)
   2ee34:	ebc4 07c4 	rsb	r7, r4, r4, lsl #3
   2ee38:	5df3      	ldrb	r3, [r6, r7]
   2ee3a:	2b01      	cmp	r3, #1
   2ee3c:	d1e4      	bne.n	2ee08 <bt_id_set_adv_own_addr+0x48>
				err = bt_id_set_adv_random_addr(adv, &id_addr->a);
   2ee3e:	2007      	movs	r0, #7
   2ee40:	fb10 3004 	smlabb	r0, r0, r4, r3
		return set_random_address(addr);
   2ee44:	4430      	add	r0, r6
   2ee46:	f7ff fcd1 	bl	2e7ec <set_random_address>
			*own_addr_type = id_addr->type;
   2ee4a:	5df3      	ldrb	r3, [r6, r7]
   2ee4c:	702b      	strb	r3, [r5, #0]
		if (err) {
   2ee4e:	e7ec      	b.n	2ee2a <_flash_used+0xe>
			err = bt_id_set_adv_private_addr(adv);
   2ee50:	f01c fd58 	bl	4b904 <bt_id_set_adv_private_addr>
			if (scan_enabled) {
   2ee54:	2301      	movs	r3, #1
   2ee56:	e7f9      	b.n	2ee4c <_flash_used+0x30>
   2ee58:	20000030 	.word	0x20000030

0002ee5c <le_adv_start_add_conn>:
	return channel_map;
}

static int le_adv_start_add_conn(const struct bt_le_ext_adv *adv,
				 struct bt_conn **out_conn)
{
   2ee5c:	b570      	push	{r4, r5, r6, lr}
	struct bt_conn *conn;

	bt_dev.adv_conn_id = adv->id;
   2ee5e:	4605      	mov	r5, r0
   2ee60:	4b16      	ldr	r3, [pc, #88]	; (2eebc <le_adv_start_add_conn+0x60>)
   2ee62:	f815 2b09 	ldrb.w	r2, [r5], #9
   2ee66:	f883 2067 	strb.w	r2, [r3, #103]	; 0x67
{
   2ee6a:	4604      	mov	r4, r0
   2ee6c:	460e      	mov	r6, r1
	return memcmp(a, b, sizeof(*a));
   2ee6e:	2207      	movs	r2, #7
   2ee70:	4913      	ldr	r1, [pc, #76]	; (2eec0 <le_adv_start_add_conn+0x64>)
   2ee72:	4628      	mov	r0, r5
   2ee74:	f01b fff1 	bl	4ae5a <memcmp>
   2ee78:	4603      	mov	r3, r0
   2ee7a:	7820      	ldrb	r0, [r4, #0]

	if (!bt_addr_le_cmp(&adv->target_addr, BT_ADDR_LE_ANY)) {
   2ee7c:	b96b      	cbnz	r3, 2ee9a <le_adv_start_add_conn+0x3e>
		/* Undirected advertising */
		conn = bt_conn_add_le(adv->id, BT_ADDR_LE_NONE);
   2ee7e:	4911      	ldr	r1, [pc, #68]	; (2eec4 <le_adv_start_add_conn+0x68>)
   2ee80:	f001 f958 	bl	30134 <bt_conn_add_le>
		if (!conn) {
   2ee84:	4604      	mov	r4, r0
   2ee86:	b910      	cbnz	r0, 2ee8e <le_adv_start_add_conn+0x32>
			return -ENOMEM;
   2ee88:	f06f 000b 	mvn.w	r0, #11
	}

	bt_conn_set_state(conn, BT_CONN_CONNECTING_DIR_ADV);
	*out_conn = conn;
	return 0;
}
   2ee8c:	bd70      	pop	{r4, r5, r6, pc}
		bt_conn_set_state(conn, BT_CONN_CONNECTING_ADV);
   2ee8e:	2104      	movs	r1, #4
   2ee90:	f000 ff60 	bl	2fd54 <bt_conn_set_state>
		*out_conn = conn;
   2ee94:	6034      	str	r4, [r6, #0]
		return 0;
   2ee96:	2000      	movs	r0, #0
   2ee98:	e7f8      	b.n	2ee8c <le_adv_start_add_conn+0x30>
	if (bt_conn_exists_le(adv->id, &adv->target_addr)) {
   2ee9a:	4629      	mov	r1, r5
   2ee9c:	f01d f864 	bl	4bf68 <bt_conn_exists_le>
   2eea0:	b940      	cbnz	r0, 2eeb4 <le_adv_start_add_conn+0x58>
	conn = bt_conn_add_le(adv->id, &adv->target_addr);
   2eea2:	7820      	ldrb	r0, [r4, #0]
   2eea4:	4629      	mov	r1, r5
   2eea6:	f001 f945 	bl	30134 <bt_conn_add_le>
	if (!conn) {
   2eeaa:	4604      	mov	r4, r0
   2eeac:	2800      	cmp	r0, #0
   2eeae:	d0eb      	beq.n	2ee88 <le_adv_start_add_conn+0x2c>
	bt_conn_set_state(conn, BT_CONN_CONNECTING_DIR_ADV);
   2eeb0:	2105      	movs	r1, #5
   2eeb2:	e7ed      	b.n	2ee90 <le_adv_start_add_conn+0x34>
		return -EINVAL;
   2eeb4:	f06f 0015 	mvn.w	r0, #21
   2eeb8:	e7e8      	b.n	2ee8c <le_adv_start_add_conn+0x30>
   2eeba:	bf00      	nop
   2eebc:	20000030 	.word	0x20000030
   2eec0:	00053517 	.word	0x00053517
   2eec4:	00053510 	.word	0x00053510

0002eec8 <valid_adv_param>:
{
   2eec8:	b538      	push	{r3, r4, r5, lr}
	if (param->options & BT_LE_ADV_OPT_EXT_ADV) {
   2eeca:	6843      	ldr	r3, [r0, #4]
{
   2eecc:	4604      	mov	r4, r0
	if (param->options & BT_LE_ADV_OPT_EXT_ADV) {
   2eece:	0558      	lsls	r0, r3, #21
   2eed0:	d501      	bpl.n	2eed6 <valid_adv_param+0xe>
		return false;
   2eed2:	2000      	movs	r0, #0
}
   2eed4:	bd38      	pop	{r3, r4, r5, pc}
	if (param->peer && !(param->options & BT_LE_ADV_OPT_CONNECTABLE)) {
   2eed6:	6922      	ldr	r2, [r4, #16]
   2eed8:	b10a      	cbz	r2, 2eede <valid_adv_param+0x16>
   2eeda:	07d9      	lsls	r1, r3, #31
   2eedc:	d5f9      	bpl.n	2eed2 <valid_adv_param+0xa>
	if (param->id >= bt_dev.id_count ||
   2eede:	4d19      	ldr	r5, [pc, #100]	; (2ef44 <valid_adv_param+0x7c>)
   2eee0:	7820      	ldrb	r0, [r4, #0]
   2eee2:	79eb      	ldrb	r3, [r5, #7]
   2eee4:	4283      	cmp	r3, r0
   2eee6:	d9f4      	bls.n	2eed2 <valid_adv_param+0xa>
	    !bt_addr_le_cmp(&bt_dev.id_addr[param->id], BT_ADDR_LE_ANY)) {
   2eee8:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
   2eeec:	4916      	ldr	r1, [pc, #88]	; (2ef48 <valid_adv_param+0x80>)
   2eeee:	2207      	movs	r2, #7
   2eef0:	4428      	add	r0, r5
   2eef2:	f01b ffb2 	bl	4ae5a <memcmp>
	if (param->id >= bt_dev.id_count ||
   2eef6:	2800      	cmp	r0, #0
   2eef8:	d0eb      	beq.n	2eed2 <valid_adv_param+0xa>
	if (!(param->options & BT_LE_ADV_OPT_CONNECTABLE)) {
   2eefa:	6860      	ldr	r0, [r4, #4]
   2eefc:	07c2      	lsls	r2, r0, #31
   2eefe:	d406      	bmi.n	2ef0e <valid_adv_param+0x46>
		if (bt_dev.hci_version < BT_HCI_VERSION_5_0 &&
   2ef00:	f895 3068 	ldrb.w	r3, [r5, #104]	; 0x68
   2ef04:	2b08      	cmp	r3, #8
   2ef06:	d802      	bhi.n	2ef0e <valid_adv_param+0x46>
   2ef08:	68a3      	ldr	r3, [r4, #8]
   2ef0a:	2b9f      	cmp	r3, #159	; 0x9f
   2ef0c:	d9e1      	bls.n	2eed2 <valid_adv_param+0xa>
	if ((param->options & (BT_LE_ADV_OPT_DIR_MODE_LOW_DUTY |
   2ef0e:	f010 0f30 	tst.w	r0, #48	; 0x30
   2ef12:	d002      	beq.n	2ef1a <valid_adv_param+0x52>
			       BT_LE_ADV_OPT_DIR_ADDR_RPA)) &&
   2ef14:	6923      	ldr	r3, [r4, #16]
   2ef16:	2b00      	cmp	r3, #0
   2ef18:	d0db      	beq.n	2eed2 <valid_adv_param+0xa>
	if ((param->options & BT_LE_ADV_OPT_DIR_MODE_LOW_DUTY) ||
   2ef1a:	06c3      	lsls	r3, r0, #27
   2ef1c:	d401      	bmi.n	2ef22 <valid_adv_param+0x5a>
   2ef1e:	6923      	ldr	r3, [r4, #16]
   2ef20:	b943      	cbnz	r3, 2ef34 <valid_adv_param+0x6c>
		if (param->interval_min > param->interval_max ||
   2ef22:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
   2ef26:	429a      	cmp	r2, r3
   2ef28:	d8d3      	bhi.n	2eed2 <valid_adv_param+0xa>
   2ef2a:	2a1f      	cmp	r2, #31
   2ef2c:	d9d1      	bls.n	2eed2 <valid_adv_param+0xa>
		    param->interval_min < 0x0020 ||
   2ef2e:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
   2ef32:	d8ce      	bhi.n	2eed2 <valid_adv_param+0xa>
	    (param->options & BT_LE_ADV_OPT_DISABLE_CHAN_38) &&
   2ef34:	f400 3060 	and.w	r0, r0, #229376	; 0x38000
	if ((param->options & BT_LE_ADV_OPT_DISABLE_CHAN_37) &&
   2ef38:	f5b0 3060 	subs.w	r0, r0, #229376	; 0x38000
   2ef3c:	bf18      	it	ne
   2ef3e:	2001      	movne	r0, #1
   2ef40:	e7c8      	b.n	2eed4 <valid_adv_param+0xc>
   2ef42:	bf00      	nop
   2ef44:	20000030 	.word	0x20000030
   2ef48:	00053517 	.word	0x00053517

0002ef4c <bt_le_ext_adv_foreach>:
{
   2ef4c:	4603      	mov	r3, r0
	func(&bt_dev.adv, data);
   2ef4e:	4801      	ldr	r0, [pc, #4]	; (2ef54 <bt_le_ext_adv_foreach+0x8>)
   2ef50:	4718      	bx	r3
   2ef52:	bf00      	nop
   2ef54:	20000048 	.word	0x20000048

0002ef58 <bt_le_adv_lookup_legacy>:
}
   2ef58:	4800      	ldr	r0, [pc, #0]	; (2ef5c <bt_le_adv_lookup_legacy+0x4>)
   2ef5a:	4770      	bx	lr
   2ef5c:	20000048 	.word	0x20000048

0002ef60 <bt_le_adv_start_legacy>:

int bt_le_adv_start_legacy(struct bt_le_ext_adv *adv,
			   const struct bt_le_adv_param *param,
			   const struct bt_data *ad, size_t ad_len,
			   const struct bt_data *sd, size_t sd_len)
{
   2ef60:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	struct bt_hci_cp_le_set_adv_param set_param;
	struct bt_conn *conn = NULL;
	struct net_buf *buf;
	bool dir_adv = (param->peer != NULL), scannable = false;
   2ef64:	f8d1 9010 	ldr.w	r9, [r1, #16]
{
   2ef68:	b08d      	sub	sp, #52	; 0x34
   2ef6a:	469a      	mov	sl, r3
	struct bt_conn *conn = NULL;
   2ef6c:	2300      	movs	r3, #0
	bool dir_adv = (param->peer != NULL), scannable = false;
   2ef6e:	ebb9 0603 	subs.w	r6, r9, r3
{
   2ef72:	4605      	mov	r5, r0
   2ef74:	488d      	ldr	r0, [pc, #564]	; (2f1ac <bt_le_adv_start_legacy+0x24c>)
   2ef76:	9205      	str	r2, [sp, #20]
	bool dir_adv = (param->peer != NULL), scannable = false;
   2ef78:	bf18      	it	ne
   2ef7a:	2601      	movne	r6, #1
	struct bt_conn *conn = NULL;
   2ef7c:	9307      	str	r3, [sp, #28]
   2ef7e:	f01c fcfd 	bl	4b97c <atomic_get>
	enum adv_name_type name_type;

	int err;

	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
   2ef82:	0742      	lsls	r2, r0, #29
{
   2ef84:	460c      	mov	r4, r1
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
   2ef86:	f140 8106 	bpl.w	2f196 <bt_le_adv_start_legacy+0x236>
		return -EAGAIN;
	}

	if (!valid_adv_param(param)) {
   2ef8a:	4608      	mov	r0, r1
   2ef8c:	f7ff ff9c 	bl	2eec8 <valid_adv_param>
   2ef90:	b928      	cbnz	r0, 2ef9e <bt_le_adv_start_legacy+0x3e>
		return -EINVAL;
   2ef92:	f06f 0b15 	mvn.w	fp, #21

	atomic_set_bit_to(adv->flags, BT_ADV_USE_IDENTITY,
			  param->options & BT_LE_ADV_OPT_USE_IDENTITY);

	return 0;
}
   2ef96:	4658      	mov	r0, fp
   2ef98:	b00d      	add	sp, #52	; 0x34
   2ef9a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (!bt_id_adv_random_addr_check(param)) {
   2ef9e:	4620      	mov	r0, r4
   2efa0:	f7ff fc88 	bl	2e8b4 <bt_id_adv_random_addr_check>
   2efa4:	4680      	mov	r8, r0
   2efa6:	2800      	cmp	r0, #0
   2efa8:	d0f3      	beq.n	2ef92 <bt_le_adv_start_legacy+0x32>
	if (atomic_test_bit(adv->flags, BT_ADV_ENABLED)) {
   2efaa:	f105 0710 	add.w	r7, r5, #16
   2efae:	4638      	mov	r0, r7
   2efb0:	f01c fce4 	bl	4b97c <atomic_get>
   2efb4:	0643      	lsls	r3, r0, #25
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
   2efb6:	f3c0 1b80 	ubfx	fp, r0, #6, #1
   2efba:	f100 80ef 	bmi.w	2f19c <bt_le_adv_start_legacy+0x23c>
	(void)memset(&set_param, 0, sizeof(set_param));
   2efbe:	220f      	movs	r2, #15
   2efc0:	4659      	mov	r1, fp
   2efc2:	a808      	add	r0, sp, #32
   2efc4:	f01b ff64 	bl	4ae90 <memset>
	set_param.min_interval = sys_cpu_to_le16(param->interval_min);
   2efc8:	68a3      	ldr	r3, [r4, #8]
   2efca:	f8ad 3020 	strh.w	r3, [sp, #32]
	set_param.channel_map  = get_adv_channel_map(param->options);
   2efce:	6860      	ldr	r0, [r4, #4]
	set_param.max_interval = sys_cpu_to_le16(param->interval_max);
   2efd0:	68e3      	ldr	r3, [r4, #12]
   2efd2:	f8ad 3022 	strh.w	r3, [sp, #34]	; 0x22
	set_param.channel_map  = get_adv_channel_map(param->options);
   2efd6:	f01c fcc2 	bl	4b95e <get_adv_channel_map>
	if (adv->id != param->id) {
   2efda:	782a      	ldrb	r2, [r5, #0]
   2efdc:	7823      	ldrb	r3, [r4, #0]
	set_param.channel_map  = get_adv_channel_map(param->options);
   2efde:	f88d 002d 	strb.w	r0, [sp, #45]	; 0x2d
	if (adv->id != param->id) {
   2efe2:	429a      	cmp	r2, r3
	set_param.filter_policy = get_filter_policy(param->options);
   2efe4:	f88d b02e 	strb.w	fp, [sp, #46]	; 0x2e
	if (adv->id != param->id) {
   2efe8:	d004      	beq.n	2eff4 <bt_le_adv_start_legacy+0x94>
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   2efea:	4870      	ldr	r0, [pc, #448]	; (2f1ac <bt_le_adv_start_legacy+0x24c>)
   2efec:	f46f 5100 	mvn.w	r1, #8192	; 0x2000
   2eff0:	f01c fcca 	bl	4b988 <atomic_and>
	bt_dev.adv_conn_id = adv->id;
   2eff4:	4a6e      	ldr	r2, [pc, #440]	; (2f1b0 <bt_le_adv_start_legacy+0x250>)
	adv->id = param->id;
   2eff6:	7823      	ldrb	r3, [r4, #0]
   2eff8:	702b      	strb	r3, [r5, #0]
	bt_dev.adv_conn_id = adv->id;
   2effa:	f882 3067 	strb.w	r3, [r2, #103]	; 0x67
	err = bt_id_set_adv_own_addr(adv, param->options, dir_adv,
   2effe:	6861      	ldr	r1, [r4, #4]
   2f000:	f10d 0325 	add.w	r3, sp, #37	; 0x25
   2f004:	4632      	mov	r2, r6
   2f006:	4628      	mov	r0, r5
   2f008:	f7ff feda 	bl	2edc0 <bt_id_set_adv_own_addr>
	if (err) {
   2f00c:	4683      	mov	fp, r0
   2f00e:	2800      	cmp	r0, #0
   2f010:	d1c1      	bne.n	2ef96 <bt_le_adv_start_legacy+0x36>
		bt_addr_le_copy(&adv->target_addr, param->peer);
   2f012:	f105 0009 	add.w	r0, r5, #9
	memcpy(dst, src, sizeof(*dst));
   2f016:	2207      	movs	r2, #7
	if (dir_adv) {
   2f018:	f1b9 0f00 	cmp.w	r9, #0
   2f01c:	d013      	beq.n	2f046 <bt_le_adv_start_legacy+0xe6>
   2f01e:	6921      	ldr	r1, [r4, #16]
   2f020:	f01b ff2b 	bl	4ae7a <memcpy>
	name_type = get_adv_name_type_param(param);
   2f024:	4620      	mov	r0, r4
   2f026:	f01c fdab 	bl	4bb80 <get_adv_name_type_param>
	if (param->options & BT_LE_ADV_OPT_CONNECTABLE) {
   2f02a:	6862      	ldr	r2, [r4, #4]
	name_type = get_adv_name_type_param(param);
   2f02c:	4606      	mov	r6, r0
	if (param->options & BT_LE_ADV_OPT_CONNECTABLE) {
   2f02e:	07d0      	lsls	r0, r2, #31
   2f030:	d416      	bmi.n	2f060 <bt_le_adv_start_legacy+0x100>
	} else if ((param->options & BT_LE_ADV_OPT_SCANNABLE) || sd ||
   2f032:	0592      	lsls	r2, r2, #22
   2f034:	d403      	bmi.n	2f03e <bt_le_adv_start_legacy+0xde>
   2f036:	9b16      	ldr	r3, [sp, #88]	; 0x58
   2f038:	b90b      	cbnz	r3, 2f03e <bt_le_adv_start_legacy+0xde>
   2f03a:	2e02      	cmp	r6, #2
   2f03c:	d14d      	bne.n	2f0da <bt_le_adv_start_legacy+0x17a>
		set_param.type = BT_HCI_ADV_SCAN_IND;
   2f03e:	2302      	movs	r3, #2
   2f040:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
   2f044:	e01a      	b.n	2f07c <bt_le_adv_start_legacy+0x11c>
   2f046:	495b      	ldr	r1, [pc, #364]	; (2f1b4 <bt_le_adv_start_legacy+0x254>)
   2f048:	f01b ff17 	bl	4ae7a <memcpy>
	name_type = get_adv_name_type_param(param);
   2f04c:	4620      	mov	r0, r4
   2f04e:	f01c fd97 	bl	4bb80 <get_adv_name_type_param>
	if (param->options & BT_LE_ADV_OPT_CONNECTABLE) {
   2f052:	6862      	ldr	r2, [r4, #4]
   2f054:	07d1      	lsls	r1, r2, #31
	name_type = get_adv_name_type_param(param);
   2f056:	4606      	mov	r6, r0
	if (param->options & BT_LE_ADV_OPT_CONNECTABLE) {
   2f058:	d5eb      	bpl.n	2f032 <bt_le_adv_start_legacy+0xd2>
			set_param.type = BT_HCI_ADV_IND;
   2f05a:	f88d 9024 	strb.w	r9, [sp, #36]	; 0x24
   2f05e:	e00d      	b.n	2f07c <bt_le_adv_start_legacy+0x11c>
				set_param.type = BT_HCI_ADV_DIRECT_IND_LOW_DUTY;
   2f060:	f012 0f10 	tst.w	r2, #16
   2f064:	bf0c      	ite	eq
   2f066:	2201      	moveq	r2, #1
   2f068:	2204      	movne	r2, #4
   2f06a:	f88d 2024 	strb.w	r2, [sp, #36]	; 0x24
   2f06e:	6921      	ldr	r1, [r4, #16]
   2f070:	2207      	movs	r2, #7
   2f072:	f10d 0026 	add.w	r0, sp, #38	; 0x26
   2f076:	f01b ff00 	bl	4ae7a <memcpy>
	bool dir_adv = (param->peer != NULL), scannable = false;
   2f07a:	46d8      	mov	r8, fp
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_ADV_PARAM, sizeof(set_param));
   2f07c:	210f      	movs	r1, #15
   2f07e:	f242 0006 	movw	r0, #8198	; 0x2006
   2f082:	f7fe fef3 	bl	2de6c <bt_hci_cmd_create>
	if (!buf) {
   2f086:	4683      	mov	fp, r0
   2f088:	2800      	cmp	r0, #0
   2f08a:	f000 808a 	beq.w	2f1a2 <bt_le_adv_start_legacy+0x242>
	return net_buf_simple_add_mem(&buf->b, mem, len);
   2f08e:	220f      	movs	r2, #15
   2f090:	a908      	add	r1, sp, #32
   2f092:	3008      	adds	r0, #8
   2f094:	f01f fe94 	bl	4edc0 <net_buf_simple_add_mem>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_ADV_PARAM, buf, NULL);
   2f098:	2200      	movs	r2, #0
   2f09a:	4659      	mov	r1, fp
   2f09c:	f242 0006 	movw	r0, #8198	; 0x2006
   2f0a0:	f7fe ff40 	bl	2df24 <bt_hci_cmd_send_sync>
	if (err) {
   2f0a4:	2800      	cmp	r0, #0
   2f0a6:	d17f      	bne.n	2f1a8 <bt_le_adv_start_legacy+0x248>
	if (!dir_adv) {
   2f0a8:	f1b9 0f00 	cmp.w	r9, #0
   2f0ac:	d01b      	beq.n	2f0e6 <bt_le_adv_start_legacy+0x186>
	    (param->options & BT_LE_ADV_OPT_CONNECTABLE)) {
   2f0ae:	6863      	ldr	r3, [r4, #4]
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
   2f0b0:	07db      	lsls	r3, r3, #31
   2f0b2:	d426      	bmi.n	2f102 <bt_le_adv_start_legacy+0x1a2>
	return bt_le_adv_set_enable_legacy(adv, enable);
   2f0b4:	4628      	mov	r0, r5
   2f0b6:	2101      	movs	r1, #1
   2f0b8:	f01c fd72 	bl	4bba0 <bt_le_adv_set_enable_legacy>
		if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn) {
   2f0bc:	9d07      	ldr	r5, [sp, #28]
	if (err) {
   2f0be:	4683      	mov	fp, r0
   2f0c0:	2800      	cmp	r0, #0
   2f0c2:	d060      	beq.n	2f186 <bt_le_adv_start_legacy+0x226>
		if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn) {
   2f0c4:	2d00      	cmp	r5, #0
   2f0c6:	f43f af66 	beq.w	2ef96 <bt_le_adv_start_legacy+0x36>
			bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
   2f0ca:	4628      	mov	r0, r5
   2f0cc:	2100      	movs	r1, #0
   2f0ce:	f000 fe41 	bl	2fd54 <bt_conn_set_state>
			bt_conn_unref(conn);
   2f0d2:	4628      	mov	r0, r5
   2f0d4:	f01c fe77 	bl	4bdc6 <bt_conn_unref>
   2f0d8:	e75d      	b.n	2ef96 <bt_le_adv_start_legacy+0x36>
		set_param.type = BT_HCI_ADV_NONCONN_IND;
   2f0da:	2303      	movs	r3, #3
	bool dir_adv = (param->peer != NULL), scannable = false;
   2f0dc:	f8dd 8058 	ldr.w	r8, [sp, #88]	; 0x58
		set_param.type = BT_HCI_ADV_NONCONN_IND;
   2f0e0:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
   2f0e4:	e7ca      	b.n	2f07c <bt_le_adv_start_legacy+0x11c>
		err = le_adv_update(adv, ad, ad_len, sd, sd_len, false,
   2f0e6:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   2f0e8:	9300      	str	r3, [sp, #0]
   2f0ea:	e9cd 8601 	strd	r8, r6, [sp, #4]
   2f0ee:	9b16      	ldr	r3, [sp, #88]	; 0x58
   2f0f0:	9905      	ldr	r1, [sp, #20]
   2f0f2:	4652      	mov	r2, sl
   2f0f4:	4628      	mov	r0, r5
   2f0f6:	f01c fccc 	bl	4ba92 <le_adv_update.constprop.0>
		if (err) {
   2f0fa:	4683      	mov	fp, r0
   2f0fc:	2800      	cmp	r0, #0
   2f0fe:	d0d6      	beq.n	2f0ae <bt_le_adv_start_legacy+0x14e>
   2f100:	e749      	b.n	2ef96 <bt_le_adv_start_legacy+0x36>
		err = le_adv_start_add_conn(adv, &conn);
   2f102:	a907      	add	r1, sp, #28
   2f104:	4628      	mov	r0, r5
   2f106:	f7ff fea9 	bl	2ee5c <le_adv_start_add_conn>
		if (err) {
   2f10a:	4683      	mov	fp, r0
   2f10c:	2800      	cmp	r0, #0
   2f10e:	d0d1      	beq.n	2f0b4 <bt_le_adv_start_legacy+0x154>
			if (err == -ENOMEM && !dir_adv &&
   2f110:	f110 0f0c 	cmn.w	r0, #12
   2f114:	f47f af3f 	bne.w	2ef96 <bt_le_adv_start_legacy+0x36>
   2f118:	f1b9 0f00 	cmp.w	r9, #0
   2f11c:	f47f af3b 	bne.w	2ef96 <bt_le_adv_start_legacy+0x36>
			    !(param->options & BT_LE_ADV_OPT_ONE_TIME)) {
   2f120:	6862      	ldr	r2, [r4, #4]
			if (err == -ENOMEM && !dir_adv &&
   2f122:	0790      	lsls	r0, r2, #30
   2f124:	f53f af37 	bmi.w	2ef96 <bt_le_adv_start_legacy+0x36>
	atomic_set_bit_to(adv->flags, BT_ADV_PERSIST, !dir_adv &&
   2f128:	6863      	ldr	r3, [r4, #4]
   2f12a:	f083 0302 	eor.w	r3, r3, #2
   2f12e:	f3c3 0b40 	ubfx	fp, r3, #1, #1
   2f132:	f00b 0201 	and.w	r2, fp, #1
   2f136:	210d      	movs	r1, #13
   2f138:	4638      	mov	r0, r7
   2f13a:	f01c fc93 	bl	4ba64 <atomic_set_bit_to>
	atomic_set_bit_to(adv->flags, BT_ADV_INCLUDE_NAME_AD,
   2f13e:	1e73      	subs	r3, r6, #1
   2f140:	425a      	negs	r2, r3
   2f142:	415a      	adcs	r2, r3
   2f144:	2107      	movs	r1, #7
   2f146:	4638      	mov	r0, r7
   2f148:	f01c fc8c 	bl	4ba64 <atomic_set_bit_to>
	atomic_set_bit_to(adv->flags, BT_ADV_INCLUDE_NAME_SD,
   2f14c:	1eb1      	subs	r1, r6, #2
   2f14e:	424a      	negs	r2, r1
   2f150:	414a      	adcs	r2, r1
   2f152:	4638      	mov	r0, r7
   2f154:	2108      	movs	r1, #8
   2f156:	f01c fc85 	bl	4ba64 <atomic_set_bit_to>
	atomic_set_bit_to(adv->flags, BT_ADV_CONNECTABLE,
   2f15a:	6862      	ldr	r2, [r4, #4]
   2f15c:	2109      	movs	r1, #9
   2f15e:	f002 0201 	and.w	r2, r2, #1
   2f162:	4638      	mov	r0, r7
   2f164:	f01c fc7e 	bl	4ba64 <atomic_set_bit_to>
	atomic_set_bit_to(adv->flags, BT_ADV_SCANNABLE, scannable);
   2f168:	4642      	mov	r2, r8
   2f16a:	210a      	movs	r1, #10
   2f16c:	4638      	mov	r0, r7
   2f16e:	f01c fc79 	bl	4ba64 <atomic_set_bit_to>
	atomic_set_bit_to(adv->flags, BT_ADV_USE_IDENTITY,
   2f172:	6862      	ldr	r2, [r4, #4]
   2f174:	210c      	movs	r1, #12
   2f176:	f3c2 0280 	ubfx	r2, r2, #2, #1
   2f17a:	4638      	mov	r0, r7
   2f17c:	f01c fc72 	bl	4ba64 <atomic_set_bit_to>
	return 0;
   2f180:	f04f 0b00 	mov.w	fp, #0
   2f184:	e707      	b.n	2ef96 <bt_le_adv_start_legacy+0x36>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn) {
   2f186:	b115      	cbz	r5, 2f18e <bt_le_adv_start_legacy+0x22e>
		bt_conn_unref(conn);
   2f188:	4628      	mov	r0, r5
   2f18a:	f01c fe1c 	bl	4bdc6 <bt_conn_unref>
	atomic_set_bit_to(adv->flags, BT_ADV_PERSIST, !dir_adv &&
   2f18e:	f1b9 0f00 	cmp.w	r9, #0
   2f192:	d1ce      	bne.n	2f132 <bt_le_adv_start_legacy+0x1d2>
   2f194:	e7c8      	b.n	2f128 <bt_le_adv_start_legacy+0x1c8>
		return -EAGAIN;
   2f196:	f06f 0b0a 	mvn.w	fp, #10
   2f19a:	e6fc      	b.n	2ef96 <bt_le_adv_start_legacy+0x36>
		return -EALREADY;
   2f19c:	f06f 0b77 	mvn.w	fp, #119	; 0x77
   2f1a0:	e6f9      	b.n	2ef96 <bt_le_adv_start_legacy+0x36>
		return -ENOBUFS;
   2f1a2:	f06f 0b68 	mvn.w	fp, #104	; 0x68
   2f1a6:	e6f6      	b.n	2ef96 <bt_le_adv_start_legacy+0x36>
   2f1a8:	4683      	mov	fp, r0
   2f1aa:	e6f4      	b.n	2ef96 <bt_le_adv_start_legacy+0x36>
   2f1ac:	200000fc 	.word	0x200000fc
   2f1b0:	20000030 	.word	0x20000030
   2f1b4:	00053517 	.word	0x00053517

0002f1b8 <bt_le_adv_start>:
}

int bt_le_adv_start(const struct bt_le_adv_param *param,
		    const struct bt_data *ad, size_t ad_len,
		    const struct bt_data *sd, size_t sd_len)
{
   2f1b8:	b573      	push	{r0, r1, r4, r5, r6, lr}
   2f1ba:	4615      	mov	r5, r2

	if (IS_ENABLED(CONFIG_BT_EXT_ADV) &&
	    BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features)) {
		err = bt_le_adv_start_ext(adv, param, ad, ad_len, sd, sd_len);
	} else {
		err = bt_le_adv_start_legacy(adv, param, ad, ad_len, sd, sd_len);
   2f1bc:	9a06      	ldr	r2, [sp, #24]
{
   2f1be:	460c      	mov	r4, r1
		err = bt_le_adv_start_legacy(adv, param, ad, ad_len, sd, sd_len);
   2f1c0:	e9cd 3200 	strd	r3, r2, [sp]
   2f1c4:	462b      	mov	r3, r5
   2f1c6:	460a      	mov	r2, r1
   2f1c8:	4601      	mov	r1, r0
   2f1ca:	4811      	ldr	r0, [pc, #68]	; (2f210 <bt_le_adv_start+0x58>)
   2f1cc:	f7ff fec8 	bl	2ef60 <bt_le_adv_start_legacy>
   2f1d0:	4621      	mov	r1, r4
   2f1d2:	4606      	mov	r6, r0
	for (i = 0; i < ad_len; i++) {
   2f1d4:	2300      	movs	r3, #0
		if (ad[i].type == BT_DATA_FLAGS &&
   2f1d6:	f240 1001 	movw	r0, #257	; 0x101
	for (i = 0; i < ad_len; i++) {
   2f1da:	429d      	cmp	r5, r3
   2f1dc:	d102      	bne.n	2f1e4 <bt_le_adv_start+0x2c>
		k_work_reschedule(&adv->lim_adv_timeout_work,
				  K_SECONDS(CONFIG_BT_LIM_ADV_TIMEOUT));
	}

	return err;
}
   2f1de:	4630      	mov	r0, r6
   2f1e0:	b002      	add	sp, #8
   2f1e2:	bd70      	pop	{r4, r5, r6, pc}
		if (ad[i].type == BT_DATA_FLAGS &&
   2f1e4:	880a      	ldrh	r2, [r1, #0]
   2f1e6:	4282      	cmp	r2, r0
   2f1e8:	d104      	bne.n	2f1f4 <bt_le_adv_start+0x3c>
		    ad[i].data != NULL) {
   2f1ea:	684a      	ldr	r2, [r1, #4]
		    ad[i].data_len == sizeof(uint8_t) &&
   2f1ec:	b112      	cbz	r2, 2f1f4 <bt_le_adv_start+0x3c>
			if (ad[i].data[0] & BT_LE_AD_LIMITED) {
   2f1ee:	7812      	ldrb	r2, [r2, #0]
   2f1f0:	07d2      	lsls	r2, r2, #31
   2f1f2:	d402      	bmi.n	2f1fa <bt_le_adv_start+0x42>
	for (i = 0; i < ad_len; i++) {
   2f1f4:	3301      	adds	r3, #1
   2f1f6:	3108      	adds	r1, #8
   2f1f8:	e7ef      	b.n	2f1da <bt_le_adv_start+0x22>
		k_work_init_delayable(&adv->lim_adv_timeout_work, adv_timeout);
   2f1fa:	4906      	ldr	r1, [pc, #24]	; (2f214 <bt_le_adv_start+0x5c>)
   2f1fc:	4806      	ldr	r0, [pc, #24]	; (2f218 <bt_le_adv_start+0x60>)
   2f1fe:	f020 ff01 	bl	50004 <k_work_init_delayable>
		k_work_reschedule(&adv->lim_adv_timeout_work,
   2f202:	f44f 2270 	mov.w	r2, #983040	; 0xf0000
   2f206:	2300      	movs	r3, #0
   2f208:	4803      	ldr	r0, [pc, #12]	; (2f218 <bt_le_adv_start+0x60>)
   2f20a:	f018 f9ef 	bl	475ec <k_work_reschedule>
   2f20e:	e7e6      	b.n	2f1de <bt_le_adv_start+0x26>
   2f210:	20000048 	.word	0x20000048
   2f214:	0004bbf5 	.word	0x0004bbf5
   2f218:	20000060 	.word	0x20000060

0002f21c <bt_le_adv_stop>:

int bt_le_adv_stop(void)
{
   2f21c:	b510      	push	{r4, lr}
	if (!adv) {
		BT_ERR("No valid legacy adv");
		return 0;
	}

	(void)bt_le_lim_adv_cancel_timeout(adv);
   2f21e:	481a      	ldr	r0, [pc, #104]	; (2f288 <bt_le_adv_stop+0x6c>)
   2f220:	f01c fce5 	bl	4bbee <bt_le_lim_adv_cancel_timeout>
   2f224:	4819      	ldr	r0, [pc, #100]	; (2f28c <bt_le_adv_stop+0x70>)
   2f226:	f46f 5100 	mvn.w	r1, #8192	; 0x2000
   2f22a:	f01c fbad 	bl	4b988 <atomic_and>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
   2f22e:	4817      	ldr	r0, [pc, #92]	; (2f28c <bt_le_adv_stop+0x70>)
   2f230:	f01c fba4 	bl	4b97c <atomic_get>
   2f234:	4603      	mov	r3, r0
	/* Make sure advertising is not re-enabled later even if it's not
	 * currently enabled (i.e. BT_DEV_ADVERTISING is not set).
	 */
	atomic_clear_bit(adv->flags, BT_ADV_PERSIST);

	if (!atomic_test_bit(adv->flags, BT_ADV_ENABLED)) {
   2f236:	065a      	lsls	r2, r3, #25
   2f238:	f3c0 1080 	ubfx	r0, r0, #6, #1
   2f23c:	d523      	bpl.n	2f286 <bt_le_adv_stop+0x6a>
   2f23e:	4813      	ldr	r0, [pc, #76]	; (2f28c <bt_le_adv_stop+0x70>)
   2f240:	f01c fb9c 	bl	4b97c <atomic_get>
		 */
		bt_le_adv_delete_legacy();
		return 0;
	}

	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
   2f244:	0583      	lsls	r3, r0, #22
   2f246:	d514      	bpl.n	2f272 <bt_le_adv_stop+0x56>
	return memcmp(a, b, sizeof(*a));
   2f248:	4911      	ldr	r1, [pc, #68]	; (2f290 <bt_le_adv_stop+0x74>)
   2f24a:	4812      	ldr	r0, [pc, #72]	; (2f294 <bt_le_adv_stop+0x78>)
   2f24c:	2207      	movs	r2, #7
   2f24e:	f01b fe04 	bl	4ae5a <memcmp>
   2f252:	4b11      	ldr	r3, [pc, #68]	; (2f298 <bt_le_adv_stop+0x7c>)
	if (!bt_addr_le_cmp(&adv->target_addr, BT_ADDR_LE_ANY)) {
   2f254:	b998      	cbnz	r0, 2f27e <bt_le_adv_stop+0x62>
		conn = bt_conn_lookup_state_le(adv->id, BT_ADDR_LE_NONE,
   2f256:	4911      	ldr	r1, [pc, #68]	; (2f29c <bt_le_adv_stop+0x80>)
   2f258:	2204      	movs	r2, #4
		conn = bt_conn_lookup_state_le(adv->id, &adv->target_addr,
   2f25a:	7e18      	ldrb	r0, [r3, #24]
   2f25c:	f000 ffaa 	bl	301b4 <bt_conn_lookup_state_le>
   2f260:	4604      	mov	r4, r0
	if (conn) {
   2f262:	b130      	cbz	r0, 2f272 <bt_le_adv_stop+0x56>
		conn->err = status;
   2f264:	2100      	movs	r1, #0
   2f266:	7301      	strb	r1, [r0, #12]
		bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
   2f268:	f000 fd74 	bl	2fd54 <bt_conn_set_state>
		bt_conn_unref(conn);
   2f26c:	4620      	mov	r0, r4
   2f26e:	f01c fdaa 	bl	4bdc6 <bt_conn_unref>
		}
	}
#endif /* defined(CONFIG_BT_OBSERVER) */

	return 0;
}
   2f272:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		err = bt_le_adv_set_enable_legacy(adv, false);
   2f276:	4804      	ldr	r0, [pc, #16]	; (2f288 <bt_le_adv_stop+0x6c>)
   2f278:	2100      	movs	r1, #0
   2f27a:	f01c bc91 	b.w	4bba0 <bt_le_adv_set_enable_legacy>
		conn = bt_conn_lookup_state_le(adv->id, &adv->target_addr,
   2f27e:	2205      	movs	r2, #5
   2f280:	f103 0121 	add.w	r1, r3, #33	; 0x21
   2f284:	e7e9      	b.n	2f25a <bt_le_adv_stop+0x3e>
}
   2f286:	bd10      	pop	{r4, pc}
   2f288:	20000048 	.word	0x20000048
   2f28c:	20000058 	.word	0x20000058
   2f290:	00053517 	.word	0x00053517
   2f294:	20000051 	.word	0x20000051
   2f298:	20000030 	.word	0x20000030
   2f29c:	00053510 	.word	0x00053510

0002f2a0 <bt_le_adv_resume>:

#if defined(CONFIG_BT_PERIPHERAL)
void bt_le_adv_resume(void)
{
   2f2a0:	b573      	push	{r0, r1, r4, r5, r6, lr}
   2f2a2:	4c20      	ldr	r4, [pc, #128]	; (2f324 <bt_le_adv_resume+0x84>)
   2f2a4:	4620      	mov	r0, r4
   2f2a6:	f01c fb69 	bl	4b97c <atomic_get>
	if (!adv) {
		BT_DBG("No valid legacy adv");
		return;
	}

	if (!(atomic_test_bit(adv->flags, BT_ADV_PERSIST) &&
   2f2aa:	0480      	lsls	r0, r0, #18
   2f2ac:	d538      	bpl.n	2f320 <bt_le_adv_resume+0x80>
   2f2ae:	4620      	mov	r0, r4
   2f2b0:	f01c fb64 	bl	4b97c <atomic_get>
   2f2b4:	0641      	lsls	r1, r0, #25
   2f2b6:	d433      	bmi.n	2f320 <bt_le_adv_resume+0x80>
   2f2b8:	4620      	mov	r0, r4
   2f2ba:	f01c fb5f 	bl	4b97c <atomic_get>
	      !atomic_test_bit(adv->flags, BT_ADV_ENABLED))) {
		return;
	}

	if (!atomic_test_bit(adv->flags, BT_ADV_CONNECTABLE)) {
   2f2be:	0582      	lsls	r2, r0, #22
   2f2c0:	d52e      	bpl.n	2f320 <bt_le_adv_resume+0x80>
		return;
	}

	err = le_adv_start_add_conn(adv, &conn);
   2f2c2:	a901      	add	r1, sp, #4
   2f2c4:	f1a4 0010 	sub.w	r0, r4, #16
   2f2c8:	f7ff fdc8 	bl	2ee5c <le_adv_start_add_conn>
	if (err) {
   2f2cc:	4605      	mov	r5, r0
   2f2ce:	bb38      	cbnz	r0, 2f320 <bt_le_adv_resume+0x80>
	return bt_le_adv_set_enable_legacy(adv, enable);
   2f2d0:	2101      	movs	r1, #1
   2f2d2:	f1a4 0010 	sub.w	r0, r4, #16
   2f2d6:	f01c fc63 	bl	4bba0 <bt_le_adv_set_enable_legacy>
	}

	/* Since we don't give the application a reference to manage in
	 * this case, we need to release this reference here.
	 */
	bt_conn_unref(conn);
   2f2da:	9e01      	ldr	r6, [sp, #4]
	if (err) {
   2f2dc:	b928      	cbnz	r0, 2f2ea <bt_le_adv_resume+0x4a>
	bt_conn_unref(conn);
   2f2de:	4630      	mov	r0, r6
	if (persist_paused) {
		atomic_set_bit(adv->flags, BT_ADV_PERSIST);
	}
}
   2f2e0:	b002      	add	sp, #8
   2f2e2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	bt_conn_unref(conn);
   2f2e6:	f01c bd6e 	b.w	4bdc6 <bt_conn_unref>
		bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
   2f2ea:	4629      	mov	r1, r5
   2f2ec:	4630      	mov	r0, r6
   2f2ee:	f000 fd31 	bl	2fd54 <bt_conn_set_state>
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   2f2f2:	f46f 5100 	mvn.w	r1, #8192	; 0x2000
   2f2f6:	4620      	mov	r0, r4
   2f2f8:	f01c fb46 	bl	4b988 <atomic_and>
   2f2fc:	4605      	mov	r5, r0
	bt_conn_unref(conn);
   2f2fe:	4630      	mov	r0, r6
   2f300:	f01c fd61 	bl	4bdc6 <bt_conn_unref>
	if (persist_paused) {
   2f304:	04ab      	lsls	r3, r5, #18
   2f306:	d50b      	bpl.n	2f320 <bt_le_adv_resume+0x80>
   2f308:	f3bf 8f5b 	dmb	ish
   2f30c:	e854 3f00 	ldrex	r3, [r4]
   2f310:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
   2f314:	e844 3200 	strex	r2, r3, [r4]
   2f318:	2a00      	cmp	r2, #0
   2f31a:	d1f7      	bne.n	2f30c <bt_le_adv_resume+0x6c>
   2f31c:	f3bf 8f5b 	dmb	ish
}
   2f320:	b002      	add	sp, #8
   2f322:	bd70      	pop	{r4, r5, r6, pc}
   2f324:	20000058 	.word	0x20000058

0002f328 <bt_le_scan_set_enable_legacy>:

	return 0;
}

static int bt_le_scan_set_enable_legacy(uint8_t enable)
{
   2f328:	b530      	push	{r4, r5, lr}
	struct bt_hci_cp_le_set_scan_enable *cp;
	struct bt_hci_cmd_state_set state;
	struct net_buf *buf;
	int err;

	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_SCAN_ENABLE, sizeof(*cp));
   2f32a:	2102      	movs	r1, #2
{
   2f32c:	b087      	sub	sp, #28
   2f32e:	4604      	mov	r4, r0
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_SCAN_ENABLE, sizeof(*cp));
   2f330:	f242 000c 	movw	r0, #8204	; 0x200c
   2f334:	f7fe fd9a 	bl	2de6c <bt_hci_cmd_create>
	if (!buf) {
   2f338:	4605      	mov	r5, r0
   2f33a:	b318      	cbz	r0, 2f384 <bt_le_scan_set_enable_legacy+0x5c>
	return net_buf_simple_add(&buf->b, len);
   2f33c:	2102      	movs	r1, #2
   2f33e:	3008      	adds	r0, #8
   2f340:	f01f fd38 	bl	4edb4 <net_buf_simple_add>
		return -ENOBUFS;
	}

	cp = net_buf_add(buf, sizeof(*cp));

	if (enable == BT_HCI_LE_SCAN_ENABLE) {
   2f344:	2c01      	cmp	r4, #1
   2f346:	d11b      	bne.n	2f380 <bt_le_scan_set_enable_legacy+0x58>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   2f348:	f3bf 8f5b 	dmb	ish
   2f34c:	4b0f      	ldr	r3, [pc, #60]	; (2f38c <bt_le_scan_set_enable_legacy+0x64>)
   2f34e:	681b      	ldr	r3, [r3, #0]
   2f350:	f3bf 8f5b 	dmb	ish
		cp->filter_dup = atomic_test_bit(bt_dev.flags,
   2f354:	f3c3 2340 	ubfx	r3, r3, #9, #1
   2f358:	7043      	strb	r3, [r0, #1]
		cp->filter_dup = BT_HCI_LE_SCAN_FILTER_DUP_DISABLE;
	}

	cp->enable = enable;

	bt_hci_cmd_state_set_init(buf, &state, bt_dev.flags, BT_DEV_SCANNING,
   2f35a:	1e63      	subs	r3, r4, #1
	cp->enable = enable;
   2f35c:	7004      	strb	r4, [r0, #0]
	bt_hci_cmd_state_set_init(buf, &state, bt_dev.flags, BT_DEV_SCANNING,
   2f35e:	425c      	negs	r4, r3
   2f360:	415c      	adcs	r4, r3
   2f362:	4a0a      	ldr	r2, [pc, #40]	; (2f38c <bt_le_scan_set_enable_legacy+0x64>)
   2f364:	9400      	str	r4, [sp, #0]
   2f366:	a903      	add	r1, sp, #12
   2f368:	4628      	mov	r0, r5
   2f36a:	2306      	movs	r3, #6
   2f36c:	f7fe fd6c 	bl	2de48 <bt_hci_cmd_state_set_init>
				  enable == BT_HCI_LE_SCAN_ENABLE);

	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_SCAN_ENABLE, buf, NULL);
   2f370:	2200      	movs	r2, #0
   2f372:	4629      	mov	r1, r5
   2f374:	f242 000c 	movw	r0, #8204	; 0x200c
   2f378:	f7fe fdd4 	bl	2df24 <bt_hci_cmd_send_sync>
	if (err) {
		return err;
	}

	return 0;
}
   2f37c:	b007      	add	sp, #28
   2f37e:	bd30      	pop	{r4, r5, pc}
   2f380:	2300      	movs	r3, #0
   2f382:	e7e9      	b.n	2f358 <bt_le_scan_set_enable_legacy+0x30>
		return -ENOBUFS;
   2f384:	f06f 0068 	mvn.w	r0, #104	; 0x68
   2f388:	e7f8      	b.n	2f37c <bt_le_scan_set_enable_legacy+0x54>
   2f38a:	bf00      	nop
   2f38c:	200000fc 	.word	0x200000fc

0002f390 <start_le_scan_legacy>:

	return 0;
}

static int start_le_scan_legacy(uint8_t scan_type, uint16_t interval, uint16_t window)
{
   2f390:	b573      	push	{r0, r1, r4, r5, r6, lr}
   2f392:	4605      	mov	r5, r0
   2f394:	4614      	mov	r4, r2
   2f396:	460e      	mov	r6, r1
	struct bt_hci_cp_le_set_scan_param set_param;
	struct net_buf *buf;
	int err;
	bool active_scan;

	(void)memset(&set_param, 0, sizeof(set_param));
   2f398:	2207      	movs	r2, #7
   2f39a:	2100      	movs	r1, #0
   2f39c:	4668      	mov	r0, sp
   2f39e:	f01b fd77 	bl	4ae90 <memset>

	if (IS_ENABLED(CONFIG_BT_FILTER_ACCEPT_LIST) &&
	    atomic_test_bit(bt_dev.flags, BT_DEV_SCAN_FILTERED)) {
		set_param.filter_policy = BT_HCI_LE_SCAN_FP_BASIC_FILTER;
	} else {
		set_param.filter_policy = BT_HCI_LE_SCAN_FP_BASIC_NO_FILTER;
   2f3a2:	2300      	movs	r3, #0
   2f3a4:	f88d 3006 	strb.w	r3, [sp, #6]
	}

	active_scan = scan_type == BT_HCI_LE_SCAN_ACTIVE;
	err = bt_id_set_scan_own_addr(active_scan, &set_param.addr_type);
   2f3a8:	1e6b      	subs	r3, r5, #1
   2f3aa:	4258      	negs	r0, r3
   2f3ac:	f10d 0105 	add.w	r1, sp, #5
   2f3b0:	4158      	adcs	r0, r3
	set_param.window = sys_cpu_to_le16(window);
   2f3b2:	f8ad 4003 	strh.w	r4, [sp, #3]
	set_param.scan_type = scan_type;
   2f3b6:	f88d 5000 	strb.w	r5, [sp]
	set_param.interval = sys_cpu_to_le16(interval);
   2f3ba:	f8ad 6001 	strh.w	r6, [sp, #1]
	err = bt_id_set_scan_own_addr(active_scan, &set_param.addr_type);
   2f3be:	f7ff fcf3 	bl	2eda8 <bt_id_set_scan_own_addr>
	if (err) {
   2f3c2:	4604      	mov	r4, r0
   2f3c4:	bb38      	cbnz	r0, 2f416 <start_le_scan_legacy+0x86>
		return err;
	}

	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_SCAN_PARAM, sizeof(set_param));
   2f3c6:	2107      	movs	r1, #7
   2f3c8:	f242 000b 	movw	r0, #8203	; 0x200b
   2f3cc:	f7fe fd4e 	bl	2de6c <bt_hci_cmd_create>
	if (!buf) {
   2f3d0:	4606      	mov	r6, r0
   2f3d2:	b348      	cbz	r0, 2f428 <start_le_scan_legacy+0x98>
	return net_buf_simple_add_mem(&buf->b, mem, len);
   2f3d4:	2207      	movs	r2, #7
   2f3d6:	4669      	mov	r1, sp
   2f3d8:	3008      	adds	r0, #8
   2f3da:	f01f fcf1 	bl	4edc0 <net_buf_simple_add_mem>
		return -ENOBUFS;
	}

	net_buf_add_mem(buf, &set_param, sizeof(set_param));

	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_SCAN_PARAM, buf, NULL);
   2f3de:	4622      	mov	r2, r4
   2f3e0:	4631      	mov	r1, r6
   2f3e2:	f242 000b 	movw	r0, #8203	; 0x200b
   2f3e6:	f7fe fd9d 	bl	2df24 <bt_hci_cmd_send_sync>
	if (err) {
   2f3ea:	4604      	mov	r4, r0
   2f3ec:	b998      	cbnz	r0, 2f416 <start_le_scan_legacy+0x86>
	return bt_le_scan_set_enable_legacy(enable);
   2f3ee:	2001      	movs	r0, #1
   2f3f0:	f7ff ff9a 	bl	2f328 <bt_le_scan_set_enable_legacy>
		return err;
	}

	err = bt_le_scan_set_enable(BT_HCI_LE_SCAN_ENABLE);
	if (err) {
   2f3f4:	4604      	mov	r4, r0
   2f3f6:	b970      	cbnz	r0, 2f416 <start_le_scan_legacy+0x86>
	if (val) {
   2f3f8:	2d01      	cmp	r5, #1
   2f3fa:	d10f      	bne.n	2f41c <start_le_scan_legacy+0x8c>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   2f3fc:	f3bf 8f5b 	dmb	ish
   2f400:	4b0b      	ldr	r3, [pc, #44]	; (2f430 <start_le_scan_legacy+0xa0>)
   2f402:	e853 1f00 	ldrex	r1, [r3]
   2f406:	f441 7180 	orr.w	r1, r1, #256	; 0x100
   2f40a:	e843 1200 	strex	r2, r1, [r3]
   2f40e:	2a00      	cmp	r2, #0
   2f410:	d1f7      	bne.n	2f402 <start_le_scan_legacy+0x72>
   2f412:	f3bf 8f5b 	dmb	ish
	}

	atomic_set_bit_to(bt_dev.flags, BT_DEV_ACTIVE_SCAN, active_scan);

	return 0;
}
   2f416:	4620      	mov	r0, r4
   2f418:	b002      	add	sp, #8
   2f41a:	bd70      	pop	{r4, r5, r6, pc}
		(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   2f41c:	f46f 7180 	mvn.w	r1, #256	; 0x100
   2f420:	4803      	ldr	r0, [pc, #12]	; (2f430 <start_le_scan_legacy+0xa0>)
   2f422:	f01c fbe9 	bl	4bbf8 <atomic_and>
   2f426:	e7f6      	b.n	2f416 <start_le_scan_legacy+0x86>
		return -ENOBUFS;
   2f428:	f06f 0468 	mvn.w	r4, #104	; 0x68
   2f42c:	e7f3      	b.n	2f416 <start_le_scan_legacy+0x86>
   2f42e:	bf00      	nop
   2f430:	200000fc 	.word	0x200000fc

0002f434 <bt_scan_reset>:
	scan_dev_found_cb = NULL;
   2f434:	4b01      	ldr	r3, [pc, #4]	; (2f43c <bt_scan_reset+0x8>)
   2f436:	2200      	movs	r2, #0
   2f438:	601a      	str	r2, [r3, #0]
}
   2f43a:	4770      	bx	lr
   2f43c:	20003bc0 	.word	0x20003bc0

0002f440 <bt_le_scan_update>:

	return start_le_scan_legacy(BT_HCI_LE_SCAN_PASSIVE, interval, window);
}

int bt_le_scan_update(bool fast_scan)
{
   2f440:	b570      	push	{r4, r5, r6, lr}
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   2f442:	4d21      	ldr	r5, [pc, #132]	; (2f4c8 <bt_le_scan_update+0x88>)
   2f444:	f3bf 8f5b 	dmb	ish
   2f448:	682b      	ldr	r3, [r5, #0]
   2f44a:	f3bf 8f5b 	dmb	ish
	if (atomic_test_bit(bt_dev.flags, BT_DEV_EXPLICIT_SCAN)) {
   2f44e:	061a      	lsls	r2, r3, #24
{
   2f450:	4606      	mov	r6, r0
	if (atomic_test_bit(bt_dev.flags, BT_DEV_EXPLICIT_SCAN)) {
   2f452:	f3c3 10c0 	ubfx	r0, r3, #7, #1
   2f456:	d434      	bmi.n	2f4c2 <bt_le_scan_update+0x82>
   2f458:	f3bf 8f5b 	dmb	ish
   2f45c:	682b      	ldr	r3, [r5, #0]
   2f45e:	f3bf 8f5b 	dmb	ish
		return 0;
	}

	if (atomic_test_bit(bt_dev.flags, BT_DEV_SCANNING)) {
   2f462:	065b      	lsls	r3, r3, #25
   2f464:	d426      	bmi.n	2f4b4 <bt_le_scan_update+0x74>

	if (IS_ENABLED(CONFIG_BT_CENTRAL)) {
		struct bt_conn *conn;

		/* don't restart scan if we have pending connection */
		conn = bt_conn_lookup_state_le(BT_ID_DEFAULT, NULL,
   2f466:	2100      	movs	r1, #0
   2f468:	2206      	movs	r2, #6
   2f46a:	4608      	mov	r0, r1
   2f46c:	f000 fea2 	bl	301b4 <bt_conn_lookup_state_le>
					       BT_CONN_CONNECTING);
		if (conn) {
   2f470:	4604      	mov	r4, r0
   2f472:	bb20      	cbnz	r0, 2f4be <bt_le_scan_update+0x7e>
			bt_conn_unref(conn);
			return 0;
		}

		conn = bt_conn_lookup_state_le(BT_ID_DEFAULT, NULL,
   2f474:	2202      	movs	r2, #2
   2f476:	4601      	mov	r1, r0
   2f478:	f000 fe9c 	bl	301b4 <bt_conn_lookup_state_le>
					       BT_CONN_CONNECTING_SCAN);
		if (conn) {
   2f47c:	b308      	cbz	r0, 2f4c2 <bt_le_scan_update+0x82>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   2f47e:	f3bf 8f5b 	dmb	ish
   2f482:	e855 3f00 	ldrex	r3, [r5]
   2f486:	f443 7300 	orr.w	r3, r3, #512	; 0x200
   2f48a:	e845 3200 	strex	r2, r3, [r5]
   2f48e:	2a00      	cmp	r2, #0
   2f490:	d1f7      	bne.n	2f482 <bt_le_scan_update+0x42>
   2f492:	f3bf 8f5b 	dmb	ish
			atomic_set_bit(bt_dev.flags, BT_DEV_SCAN_FILTER_DUP);

			bt_conn_unref(conn);
   2f496:	f01c fc96 	bl	4bdc6 <bt_conn_unref>
		window = BT_GAP_SCAN_FAST_WINDOW;
   2f49a:	2e00      	cmp	r6, #0
	return start_le_scan_legacy(BT_HCI_LE_SCAN_PASSIVE, interval, window);
   2f49c:	4620      	mov	r0, r4
   2f49e:	bf08      	it	eq
   2f4a0:	2212      	moveq	r2, #18
		return start_passive_scan(fast_scan);
	}
#endif

	return 0;
}
   2f4a2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return start_le_scan_legacy(BT_HCI_LE_SCAN_PASSIVE, interval, window);
   2f4a6:	bf16      	itet	ne
   2f4a8:	2230      	movne	r2, #48	; 0x30
   2f4aa:	f44f 6100 	moveq.w	r1, #2048	; 0x800
   2f4ae:	2160      	movne	r1, #96	; 0x60
   2f4b0:	f7ff bf6e 	b.w	2f390 <start_le_scan_legacy>
	return bt_le_scan_set_enable_legacy(enable);
   2f4b4:	f7ff ff38 	bl	2f328 <bt_le_scan_set_enable_legacy>
		if (err) {
   2f4b8:	2800      	cmp	r0, #0
   2f4ba:	d0d4      	beq.n	2f466 <bt_le_scan_update+0x26>
}
   2f4bc:	bd70      	pop	{r4, r5, r6, pc}
			bt_conn_unref(conn);
   2f4be:	f01c fc82 	bl	4bdc6 <bt_conn_unref>
		return 0;
   2f4c2:	2000      	movs	r0, #0
   2f4c4:	e7fa      	b.n	2f4bc <bt_le_scan_update+0x7c>
   2f4c6:	bf00      	nop
   2f4c8:	200000fc 	.word	0x200000fc

0002f4cc <bt_hci_le_adv_report>:
#endif /* CONFIG_BT_DF_CONNECTIONLESS_CTE_RX */
#endif /* defined(CONFIG_BT_PER_ADV_SYNC) */
#endif /* defined(CONFIG_BT_EXT_ADV) */

void bt_hci_le_adv_report(struct net_buf *buf)
{
   2f4cc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 *
 * @return The 8-bit removed value
 */
static inline uint8_t net_buf_pull_u8(struct net_buf *buf)
{
	return net_buf_simple_pull_u8(&buf->b);
   2f4d0:	f100 0608 	add.w	r6, r0, #8
   2f4d4:	b08b      	sub	sp, #44	; 0x2c
   2f4d6:	4604      	mov	r4, r0
   2f4d8:	4630      	mov	r0, r6
   2f4da:	f01f fca4 	bl	4ee26 <net_buf_simple_pull_u8>
	if (scan_dev_found_cb) {
   2f4de:	f8df a1bc 	ldr.w	sl, [pc, #444]	; 2f69c <bt_hci_le_adv_report+0x1d0>
   2f4e2:	4680      	mov	r8, r0
	uint8_t num_reports = net_buf_pull_u8(buf);
	struct bt_hci_evt_le_advertising_info *evt;

	BT_DBG("Adv number of reports %u",  num_reports);

	while (num_reports--) {
   2f4e4:	f1b8 0f00 	cmp.w	r8, #0
   2f4e8:	d102      	bne.n	2f4f0 <bt_hci_le_adv_report+0x24>

		le_adv_recv(&evt->addr, &adv_info, &buf->b, evt->length);

		net_buf_pull(buf, evt->length + sizeof(adv_info.rssi));
	}
}
   2f4ea:	b00b      	add	sp, #44	; 0x2c
   2f4ec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (buf->len < sizeof(*evt)) {
   2f4f0:	89a3      	ldrh	r3, [r4, #12]
   2f4f2:	2b08      	cmp	r3, #8
   2f4f4:	d9f9      	bls.n	2f4ea <bt_hci_le_adv_report+0x1e>
	return net_buf_simple_pull_mem(&buf->b, len);
   2f4f6:	2109      	movs	r1, #9
   2f4f8:	4630      	mov	r0, r6
   2f4fa:	f01f fc8c 	bl	4ee16 <net_buf_simple_pull_mem>
		adv_info.primary_phy = BT_GAP_LE_PHY_1M;
   2f4fe:	2301      	movs	r3, #1
   2f500:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
		adv_info.tx_power = BT_GAP_TX_POWER_INVALID;
   2f504:	237f      	movs	r3, #127	; 0x7f
   2f506:	f88d 301e 	strb.w	r3, [sp, #30]
		adv_info.rssi = evt->data[evt->length];
   2f50a:	7a03      	ldrb	r3, [r0, #8]
   2f50c:	4403      	add	r3, r0
   2f50e:	4605      	mov	r5, r0
   2f510:	7a5b      	ldrb	r3, [r3, #9]
   2f512:	f88d 301d 	strb.w	r3, [sp, #29]
		adv_info.sid = BT_GAP_SID_INVALID;
   2f516:	23ff      	movs	r3, #255	; 0xff
   2f518:	f88d 301c 	strb.w	r3, [sp, #28]
		adv_info.interval = 0U;
   2f51c:	2300      	movs	r3, #0
   2f51e:	f8ad 3022 	strh.w	r3, [sp, #34]	; 0x22
		adv_info.adv_type = evt->evt_type;
   2f522:	7802      	ldrb	r2, [r0, #0]
   2f524:	f88d 201f 	strb.w	r2, [sp, #31]
	switch (evt_type) {
   2f528:	2a04      	cmp	r2, #4
   2f52a:	bf9c      	itt	ls
   2f52c:	4b5c      	ldrls	r3, [pc, #368]	; (2f6a0 <bt_hci_le_adv_report+0x1d4>)
   2f52e:	5c9b      	ldrbls	r3, [r3, r2]
		adv_info.adv_props = get_adv_props_legacy(evt->evt_type);
   2f530:	f8ad 3020 	strh.w	r3, [sp, #32]
		le_adv_recv(&evt->addr, &adv_info, &buf->b, evt->length);
   2f534:	7a03      	ldrb	r3, [r0, #8]
   2f536:	9301      	str	r3, [sp, #4]
	if (addr->type == BT_ADDR_LE_PUBLIC_ID ||
   2f538:	7843      	ldrb	r3, [r0, #1]
   2f53a:	1e9a      	subs	r2, r3, #2
   2f53c:	2a01      	cmp	r2, #1
		le_adv_recv(&evt->addr, &adv_info, &buf->b, evt->length);
   2f53e:	f100 0901 	add.w	r9, r0, #1
	if (addr->type == BT_ADDR_LE_PUBLIC_ID ||
   2f542:	d84e      	bhi.n	2f5e2 <bt_hci_le_adv_report+0x116>
	memcpy(dst, src, sizeof(*dst));
   2f544:	2207      	movs	r2, #7
   2f546:	4649      	mov	r1, r9
   2f548:	a804      	add	r0, sp, #16
   2f54a:	f01b fc96 	bl	4ae7a <memcpy>
		id_addr.type -= BT_ADDR_LE_PUBLIC_ID;
   2f54e:	f89d 3010 	ldrb.w	r3, [sp, #16]
   2f552:	3b02      	subs	r3, #2
   2f554:	f88d 3010 	strb.w	r3, [sp, #16]
	if (scan_dev_found_cb) {
   2f558:	f8da 3000 	ldr.w	r3, [sl]
   2f55c:	b1a3      	cbz	r3, 2f588 <bt_hci_le_adv_report+0xbc>
	state->offset = net_buf_simple_headroom(buf);
   2f55e:	4630      	mov	r0, r6
   2f560:	f01f fc71 	bl	4ee46 <net_buf_simple_headroom>
		buf->len = len;
   2f564:	9b01      	ldr	r3, [sp, #4]
	state->len = buf->len;
   2f566:	89a7      	ldrh	r7, [r4, #12]
		scan_dev_found_cb(&id_addr, info->rssi, info->adv_type, buf);
   2f568:	f89d 201f 	ldrb.w	r2, [sp, #31]
		buf->len = len;
   2f56c:	81a3      	strh	r3, [r4, #12]
	state->offset = net_buf_simple_headroom(buf);
   2f56e:	4683      	mov	fp, r0
		scan_dev_found_cb(&id_addr, info->rssi, info->adv_type, buf);
   2f570:	4633      	mov	r3, r6
   2f572:	f99d 101d 	ldrsb.w	r1, [sp, #29]
   2f576:	f8da c000 	ldr.w	ip, [sl]
   2f57a:	a804      	add	r0, sp, #16
   2f57c:	47e0      	blx	ip
	buf->data = buf->__buf + state->offset;
   2f57e:	6923      	ldr	r3, [r4, #16]
	buf->len = state->len;
   2f580:	81a7      	strh	r7, [r4, #12]
	buf->data = buf->__buf + state->offset;
   2f582:	fa13 f38b 	uxtah	r3, r3, fp
   2f586:	60a3      	str	r3, [r4, #8]
	info->addr = &id_addr;
   2f588:	ab04      	add	r3, sp, #16
   2f58a:	9306      	str	r3, [sp, #24]
	return list->head;
   2f58c:	4b45      	ldr	r3, [pc, #276]	; (2f6a4 <bt_hci_le_adv_report+0x1d8>)
   2f58e:	681b      	ldr	r3, [r3, #0]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&scan_cbs, listener, next, node) {
   2f590:	2b00      	cmp	r3, #0
   2f592:	d037      	beq.n	2f604 <bt_hci_le_adv_report+0x138>
	return node->next;
   2f594:	681a      	ldr	r2, [r3, #0]
   2f596:	b102      	cbz	r2, 2f59a <bt_hci_le_adv_report+0xce>
   2f598:	3a08      	subs	r2, #8
		if (listener->recv) {
   2f59a:	f853 1c08 	ldr.w	r1, [r3, #-8]
   2f59e:	b1b9      	cbz	r1, 2f5d0 <bt_hci_le_adv_report+0x104>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&scan_cbs, listener, next, node) {
   2f5a0:	4617      	mov	r7, r2
   2f5a2:	f1a3 0208 	sub.w	r2, r3, #8
	state->offset = net_buf_simple_headroom(buf);
   2f5a6:	4630      	mov	r0, r6
   2f5a8:	9203      	str	r2, [sp, #12]
   2f5aa:	f01f fc4c 	bl	4ee46 <net_buf_simple_headroom>
	state->len = buf->len;
   2f5ae:	89a3      	ldrh	r3, [r4, #12]
			listener->recv(info, buf);
   2f5b0:	9a03      	ldr	r2, [sp, #12]
   2f5b2:	9302      	str	r3, [sp, #8]
			buf->len = len;
   2f5b4:	9b01      	ldr	r3, [sp, #4]
   2f5b6:	81a3      	strh	r3, [r4, #12]
			listener->recv(info, buf);
   2f5b8:	6812      	ldr	r2, [r2, #0]
	state->offset = net_buf_simple_headroom(buf);
   2f5ba:	4683      	mov	fp, r0
   2f5bc:	4631      	mov	r1, r6
   2f5be:	a806      	add	r0, sp, #24
   2f5c0:	4790      	blx	r2
	buf->data = buf->__buf + state->offset;
   2f5c2:	6922      	ldr	r2, [r4, #16]
	buf->len = state->len;
   2f5c4:	9b02      	ldr	r3, [sp, #8]
   2f5c6:	81a3      	strh	r3, [r4, #12]
	buf->data = buf->__buf + state->offset;
   2f5c8:	fa12 f28b 	uxtah	r2, r2, fp
   2f5cc:	60a2      	str	r2, [r4, #8]
}
   2f5ce:	463a      	mov	r2, r7
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&scan_cbs, listener, next, node) {
   2f5d0:	b1c2      	cbz	r2, 2f604 <bt_hci_le_adv_report+0x138>
   2f5d2:	6897      	ldr	r7, [r2, #8]
   2f5d4:	6813      	ldr	r3, [r2, #0]
   2f5d6:	b19f      	cbz	r7, 2f600 <bt_hci_le_adv_report+0x134>
   2f5d8:	3f08      	subs	r7, #8
		if (listener->recv) {
   2f5da:	2b00      	cmp	r3, #0
   2f5dc:	d1e3      	bne.n	2f5a6 <bt_hci_le_adv_report+0xda>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&scan_cbs, listener, next, node) {
   2f5de:	463a      	mov	r2, r7
   2f5e0:	e7f7      	b.n	2f5d2 <bt_hci_le_adv_report+0x106>
	} else if (addr->type == BT_HCI_PEER_ADDR_ANONYMOUS) {
   2f5e2:	2bff      	cmp	r3, #255	; 0xff
   2f5e4:	d105      	bne.n	2f5f2 <bt_hci_le_adv_report+0x126>
   2f5e6:	4930      	ldr	r1, [pc, #192]	; (2f6a8 <bt_hci_le_adv_report+0x1dc>)
   2f5e8:	2207      	movs	r2, #7
   2f5ea:	a804      	add	r0, sp, #16
   2f5ec:	f01b fc45 	bl	4ae7a <memcpy>
}
   2f5f0:	e7b2      	b.n	2f558 <bt_hci_le_adv_report+0x8c>
		bt_addr_le_copy(&id_addr,
   2f5f2:	4649      	mov	r1, r9
   2f5f4:	2000      	movs	r0, #0
   2f5f6:	f01c f97d 	bl	4b8f4 <bt_lookup_id_addr>
	memcpy(dst, src, sizeof(*dst));
   2f5fa:	2207      	movs	r2, #7
   2f5fc:	4601      	mov	r1, r0
   2f5fe:	e7f4      	b.n	2f5ea <bt_hci_le_adv_report+0x11e>
		if (listener->recv) {
   2f600:	2b00      	cmp	r3, #0
   2f602:	d1d0      	bne.n	2f5a6 <bt_hci_le_adv_report+0xda>
	info->addr = NULL;
   2f604:	2300      	movs	r3, #0
   2f606:	9306      	str	r3, [sp, #24]
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   2f608:	4b28      	ldr	r3, [pc, #160]	; (2f6ac <bt_hci_le_adv_report+0x1e0>)
	check_pending_conn(&id_addr, addr, info->adv_props);
   2f60a:	f8bd 1020 	ldrh.w	r1, [sp, #32]
   2f60e:	f3bf 8f5b 	dmb	ish
   2f612:	681a      	ldr	r2, [r3, #0]
   2f614:	f3bf 8f5b 	dmb	ish
	if (atomic_test_bit(bt_dev.flags, BT_DEV_EXPLICIT_SCAN)) {
   2f618:	0610      	lsls	r0, r2, #24
   2f61a:	f3c2 1bc0 	ubfx	fp, r2, #7, #1
   2f61e:	d421      	bmi.n	2f664 <bt_hci_le_adv_report+0x198>
	if (!(adv_props & BT_HCI_LE_ADV_EVT_TYPE_CONN)) {
   2f620:	07ca      	lsls	r2, r1, #31
   2f622:	d51f      	bpl.n	2f664 <bt_hci_le_adv_report+0x198>
	conn = bt_conn_lookup_state_le(BT_ID_DEFAULT, id_addr,
   2f624:	2202      	movs	r2, #2
   2f626:	a904      	add	r1, sp, #16
   2f628:	4658      	mov	r0, fp
   2f62a:	f000 fdc3 	bl	301b4 <bt_conn_lookup_state_le>
	if (!conn) {
   2f62e:	4607      	mov	r7, r0
   2f630:	b1c0      	cbz	r0, 2f664 <bt_hci_le_adv_report+0x198>
   2f632:	f3bf 8f5b 	dmb	ish
   2f636:	4b1d      	ldr	r3, [pc, #116]	; (2f6ac <bt_hci_le_adv_report+0x1e0>)
   2f638:	681b      	ldr	r3, [r3, #0]
   2f63a:	f3bf 8f5b 	dmb	ish
	if (atomic_test_bit(bt_dev.flags, BT_DEV_SCANNING) &&
   2f63e:	065b      	lsls	r3, r3, #25
   2f640:	d41a      	bmi.n	2f678 <bt_hci_le_adv_report+0x1ac>
   2f642:	2207      	movs	r2, #7
   2f644:	4649      	mov	r1, r9
   2f646:	f107 0096 	add.w	r0, r7, #150	; 0x96
   2f64a:	f01b fc16 	bl	4ae7a <memcpy>
	if (bt_le_create_conn(conn)) {
   2f64e:	4638      	mov	r0, r7
   2f650:	f7fe fd00 	bl	2e054 <bt_le_create_conn>
   2f654:	b9a8      	cbnz	r0, 2f682 <bt_hci_le_adv_report+0x1b6>
	bt_conn_set_state(conn, BT_CONN_CONNECTING);
   2f656:	4638      	mov	r0, r7
   2f658:	2106      	movs	r1, #6
   2f65a:	f000 fb7b 	bl	2fd54 <bt_conn_set_state>
	bt_conn_unref(conn);
   2f65e:	4638      	mov	r0, r7
   2f660:	f01c fbb1 	bl	4bdc6 <bt_conn_unref>
		net_buf_pull(buf, evt->length + sizeof(adv_info.rssi));
   2f664:	7a29      	ldrb	r1, [r5, #8]
	return net_buf_simple_pull(&buf->b, len);
   2f666:	4630      	mov	r0, r6
   2f668:	3101      	adds	r1, #1
   2f66a:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
   2f66e:	f01f fbca 	bl	4ee06 <net_buf_simple_pull>
   2f672:	fa5f f888 	uxtb.w	r8, r8
   2f676:	e735      	b.n	2f4e4 <bt_hci_le_adv_report+0x18>
	return bt_le_scan_set_enable_legacy(enable);
   2f678:	4658      	mov	r0, fp
   2f67a:	f7ff fe55 	bl	2f328 <bt_le_scan_set_enable_legacy>
	if (atomic_test_bit(bt_dev.flags, BT_DEV_SCANNING) &&
   2f67e:	2800      	cmp	r0, #0
   2f680:	d0df      	beq.n	2f642 <bt_hci_le_adv_report+0x176>
	conn->err = BT_HCI_ERR_UNSPECIFIED;
   2f682:	231f      	movs	r3, #31
   2f684:	733b      	strb	r3, [r7, #12]
	bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
   2f686:	2100      	movs	r1, #0
   2f688:	4638      	mov	r0, r7
   2f68a:	f000 fb63 	bl	2fd54 <bt_conn_set_state>
	bt_conn_unref(conn);
   2f68e:	4638      	mov	r0, r7
   2f690:	f01c fb99 	bl	4bdc6 <bt_conn_unref>
	bt_le_scan_update(false);
   2f694:	2000      	movs	r0, #0
   2f696:	f7ff fed3 	bl	2f440 <bt_le_scan_update>
   2f69a:	e7e3      	b.n	2f664 <bt_hci_le_adv_report+0x198>
   2f69c:	20003bc0 	.word	0x20003bc0
   2f6a0:	00053705 	.word	0x00053705
   2f6a4:	20003bb8 	.word	0x20003bb8
   2f6a8:	00053517 	.word	0x00053517
   2f6ac:	200000fc 	.word	0x200000fc

0002f6b0 <bt_le_scan_start>:

	return true;
}

int bt_le_scan_start(const struct bt_le_scan_param *param, bt_le_scan_cb_t cb)
{
   2f6b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2f6b2:	4e3d      	ldr	r6, [pc, #244]	; (2f7a8 <bt_le_scan_start+0xf8>)
   2f6b4:	f3bf 8f5b 	dmb	ish
   2f6b8:	6833      	ldr	r3, [r6, #0]
   2f6ba:	f3bf 8f5b 	dmb	ish
	int err;

	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
   2f6be:	f013 0f04 	tst.w	r3, #4
{
   2f6c2:	4605      	mov	r5, r0
   2f6c4:	460f      	mov	r7, r1
   2f6c6:	4634      	mov	r4, r6
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
   2f6c8:	d06a      	beq.n	2f7a0 <bt_le_scan_start+0xf0>
	if (param->type != BT_HCI_LE_SCAN_PASSIVE &&
   2f6ca:	7802      	ldrb	r2, [r0, #0]
   2f6cc:	2a01      	cmp	r2, #1
   2f6ce:	d903      	bls.n	2f6d8 <bt_le_scan_start+0x28>
		return -EAGAIN;
	}

	/* Check that the parameters have valid values */
	if (!valid_le_scan_param(param)) {
		return -EINVAL;
   2f6d0:	f06f 0415 	mvn.w	r4, #21
	}

	scan_dev_found_cb = cb;

	return 0;
}
   2f6d4:	4620      	mov	r0, r4
   2f6d6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (param->options & ~(BT_LE_SCAN_OPT_FILTER_DUPLICATE |
   2f6d8:	6843      	ldr	r3, [r0, #4]
   2f6da:	2b0f      	cmp	r3, #15
   2f6dc:	d8f8      	bhi.n	2f6d0 <bt_le_scan_start+0x20>
	if (param->interval < 0x0004 || param->interval > 0x4000) {
   2f6de:	8900      	ldrh	r0, [r0, #8]
   2f6e0:	1f03      	subs	r3, r0, #4
   2f6e2:	b29b      	uxth	r3, r3
   2f6e4:	f643 7cfc 	movw	ip, #16380	; 0x3ffc
   2f6e8:	4563      	cmp	r3, ip
   2f6ea:	d8f1      	bhi.n	2f6d0 <bt_le_scan_start+0x20>
	if (param->window < 0x0004 || param->window > 0x4000) {
   2f6ec:	8969      	ldrh	r1, [r5, #10]
   2f6ee:	1f0b      	subs	r3, r1, #4
   2f6f0:	b29b      	uxth	r3, r3
   2f6f2:	4563      	cmp	r3, ip
   2f6f4:	d8ec      	bhi.n	2f6d0 <bt_le_scan_start+0x20>
	if (param->window > param->interval) {
   2f6f6:	4288      	cmp	r0, r1
   2f6f8:	d3ea      	bcc.n	2f6d0 <bt_le_scan_start+0x20>
	if (param->type && !bt_id_scan_random_addr_check()) {
   2f6fa:	b98a      	cbnz	r2, 2f720 <bt_le_scan_start+0x70>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   2f6fc:	f3bf 8f5b 	dmb	ish
   2f700:	e854 0f00 	ldrex	r0, [r4]
   2f704:	f040 0380 	orr.w	r3, r0, #128	; 0x80
   2f708:	e844 3200 	strex	r2, r3, [r4]
   2f70c:	2a00      	cmp	r2, #0
   2f70e:	d1f7      	bne.n	2f700 <bt_le_scan_start+0x50>
   2f710:	f3bf 8f5b 	dmb	ish
	if (atomic_test_and_set_bit(bt_dev.flags, BT_DEV_EXPLICIT_SCAN)) {
   2f714:	f010 0080 	ands.w	r0, r0, #128	; 0x80
   2f718:	d007      	beq.n	2f72a <bt_le_scan_start+0x7a>
		return -EALREADY;
   2f71a:	f06f 0477 	mvn.w	r4, #119	; 0x77
   2f71e:	e7d9      	b.n	2f6d4 <bt_le_scan_start+0x24>
	if (param->type && !bt_id_scan_random_addr_check()) {
   2f720:	f01c f902 	bl	4b928 <bt_id_scan_random_addr_check>
   2f724:	2800      	cmp	r0, #0
   2f726:	d1e9      	bne.n	2f6fc <bt_le_scan_start+0x4c>
   2f728:	e7d2      	b.n	2f6d0 <bt_le_scan_start+0x20>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   2f72a:	f3bf 8f5b 	dmb	ish
   2f72e:	6833      	ldr	r3, [r6, #0]
   2f730:	f3bf 8f5b 	dmb	ish
	if (atomic_test_bit(bt_dev.flags, BT_DEV_SCANNING)) {
   2f734:	065a      	lsls	r2, r3, #25
   2f736:	d509      	bpl.n	2f74c <bt_le_scan_start+0x9c>
	return bt_le_scan_set_enable_legacy(enable);
   2f738:	f7ff fdf6 	bl	2f328 <bt_le_scan_set_enable_legacy>
		if (err) {
   2f73c:	4604      	mov	r4, r0
   2f73e:	b128      	cbz	r0, 2f74c <bt_le_scan_start+0x9c>
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   2f740:	f06f 0180 	mvn.w	r1, #128	; 0x80
   2f744:	4818      	ldr	r0, [pc, #96]	; (2f7a8 <bt_le_scan_start+0xf8>)
   2f746:	f01c fa57 	bl	4bbf8 <atomic_and>
		return err;
   2f74a:	e7c3      	b.n	2f6d4 <bt_le_scan_start+0x24>
	atomic_set_bit_to(bt_dev.flags, BT_DEV_SCAN_FILTER_DUP,
   2f74c:	686b      	ldr	r3, [r5, #4]
	if (val) {
   2f74e:	07db      	lsls	r3, r3, #31
   2f750:	d515      	bpl.n	2f77e <bt_le_scan_start+0xce>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   2f752:	f3bf 8f5b 	dmb	ish
   2f756:	e856 3f00 	ldrex	r3, [r6]
   2f75a:	f443 7300 	orr.w	r3, r3, #512	; 0x200
   2f75e:	e846 3200 	strex	r2, r3, [r6]
   2f762:	2a00      	cmp	r2, #0
   2f764:	d1f7      	bne.n	2f756 <bt_le_scan_start+0xa6>
   2f766:	f3bf 8f5b 	dmb	ish
		if (param->timeout) {
   2f76a:	89ab      	ldrh	r3, [r5, #12]
   2f76c:	b16b      	cbz	r3, 2f78a <bt_le_scan_start+0xda>
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   2f76e:	480e      	ldr	r0, [pc, #56]	; (2f7a8 <bt_le_scan_start+0xf8>)
   2f770:	f06f 0180 	mvn.w	r1, #128	; 0x80
   2f774:	f01c fa40 	bl	4bbf8 <atomic_and>
			return -ENOTSUP;
   2f778:	f06f 0485 	mvn.w	r4, #133	; 0x85
   2f77c:	e7aa      	b.n	2f6d4 <bt_le_scan_start+0x24>
		(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   2f77e:	f46f 7100 	mvn.w	r1, #512	; 0x200
   2f782:	4809      	ldr	r0, [pc, #36]	; (2f7a8 <bt_le_scan_start+0xf8>)
   2f784:	f01c fa38 	bl	4bbf8 <atomic_and>
   2f788:	e7ef      	b.n	2f76a <bt_le_scan_start+0xba>
		err = start_le_scan_legacy(param->type, param->interval,
   2f78a:	896a      	ldrh	r2, [r5, #10]
   2f78c:	8929      	ldrh	r1, [r5, #8]
   2f78e:	7828      	ldrb	r0, [r5, #0]
   2f790:	f7ff fdfe 	bl	2f390 <start_le_scan_legacy>
	if (err) {
   2f794:	4604      	mov	r4, r0
   2f796:	2800      	cmp	r0, #0
   2f798:	d1d2      	bne.n	2f740 <bt_le_scan_start+0x90>
	scan_dev_found_cb = cb;
   2f79a:	4b04      	ldr	r3, [pc, #16]	; (2f7ac <bt_le_scan_start+0xfc>)
   2f79c:	601f      	str	r7, [r3, #0]
	return 0;
   2f79e:	e799      	b.n	2f6d4 <bt_le_scan_start+0x24>
		return -EAGAIN;
   2f7a0:	f06f 040a 	mvn.w	r4, #10
   2f7a4:	e796      	b.n	2f6d4 <bt_le_scan_start+0x24>
   2f7a6:	bf00      	nop
   2f7a8:	200000fc 	.word	0x200000fc
   2f7ac:	20003bc0 	.word	0x20003bc0

0002f7b0 <bt_le_scan_stop>:

int bt_le_scan_stop(void)
{
   2f7b0:	b508      	push	{r3, lr}
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   2f7b2:	4808      	ldr	r0, [pc, #32]	; (2f7d4 <bt_le_scan_stop+0x24>)
   2f7b4:	f06f 0180 	mvn.w	r1, #128	; 0x80
   2f7b8:	f01c fa1e 	bl	4bbf8 <atomic_and>
	/* Return if active scanning is already disabled */
	if (!atomic_test_and_clear_bit(bt_dev.flags, BT_DEV_EXPLICIT_SCAN)) {
   2f7bc:	0603      	lsls	r3, r0, #24
   2f7be:	d506      	bpl.n	2f7ce <bt_le_scan_stop+0x1e>
	scan_dev_found_cb = NULL;
   2f7c0:	4b05      	ldr	r3, [pc, #20]	; (2f7d8 <bt_le_scan_stop+0x28>)
   2f7c2:	2000      	movs	r0, #0
   2f7c4:	6018      	str	r0, [r3, #0]
		bt_id_pending_keys_update();
#endif
	}

	return bt_le_scan_update(false);
}
   2f7c6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	return bt_le_scan_update(false);
   2f7ca:	f7ff be39 	b.w	2f440 <bt_le_scan_update>
}
   2f7ce:	f06f 0077 	mvn.w	r0, #119	; 0x77
   2f7d2:	bd08      	pop	{r3, pc}
   2f7d4:	200000fc 	.word	0x200000fc
   2f7d8:	20003bc0 	.word	0x20003bc0

0002f7dc <bt_pub_key_is_debug>:
	0x5c, 0x15, 0x52, 0x5a, 0xbf, 0x9a, 0x32, 0x63,
	0x6d, 0xeb, 0x2a, 0x65, 0x49, 0x9c, 0x80, 0xdc
};

bool bt_pub_key_is_debug(uint8_t *pub_key)
{
   2f7dc:	b508      	push	{r3, lr}
	return memcmp(pub_key, debug_public_key, BT_PUB_KEY_LEN) == 0;
   2f7de:	4904      	ldr	r1, [pc, #16]	; (2f7f0 <bt_pub_key_is_debug+0x14>)
   2f7e0:	2240      	movs	r2, #64	; 0x40
   2f7e2:	f01b fb3a 	bl	4ae5a <memcmp>
}
   2f7e6:	fab0 f080 	clz	r0, r0
   2f7ea:	0940      	lsrs	r0, r0, #5
   2f7ec:	bd08      	pop	{r3, pc}
   2f7ee:	bf00      	nop
   2f7f0:	0005370a 	.word	0x0005370a

0002f7f4 <bt_pub_key_gen>:

int bt_pub_key_gen(struct bt_pub_key_cb *new_cb)
{
   2f7f4:	b570      	push	{r4, r5, r6, lr}
	 * We check for both "LE Read Local P-256 Public Key" and
	 * "LE Generate DH Key" support here since both commands are needed for
	 * ECC support. If "LE Generate DH Key" is not supported then there
	 * is no point in reading local public key.
	 */
	if (!BT_CMD_TEST(bt_dev.supported_commands, 34, 1) ||
   2f7f6:	4b31      	ldr	r3, [pc, #196]	; (2f8bc <bt_pub_key_gen+0xc8>)
   2f7f8:	f893 309a 	ldrb.w	r3, [r3, #154]	; 0x9a
   2f7fc:	f003 0306 	and.w	r3, r3, #6
   2f800:	2b06      	cmp	r3, #6
   2f802:	d152      	bne.n	2f8aa <bt_pub_key_gen+0xb6>
			new_cb->func(debug_public_key);
			return 0;
		}
	}

	if (!new_cb) {
   2f804:	2800      	cmp	r0, #0
   2f806:	d053      	beq.n	2f8b0 <bt_pub_key_gen+0xbc>
	return list->head;
   2f808:	4e2d      	ldr	r6, [pc, #180]	; (2f8c0 <bt_pub_key_gen+0xcc>)
   2f80a:	6832      	ldr	r2, [r6, #0]
		return -EINVAL;
	}

	SYS_SLIST_FOR_EACH_CONTAINER(&pub_key_cb_slist, cb, node) {
   2f80c:	b132      	cbz	r2, 2f81c <bt_pub_key_gen+0x28>
   2f80e:	1f13      	subs	r3, r2, #4
		if (cb == new_cb) {
   2f810:	4283      	cmp	r3, r0
   2f812:	d050      	beq.n	2f8b6 <bt_pub_key_gen+0xc2>
	return node->next;
   2f814:	685b      	ldr	r3, [r3, #4]
	SYS_SLIST_FOR_EACH_CONTAINER(&pub_key_cb_slist, cb, node) {
   2f816:	b10b      	cbz	r3, 2f81c <bt_pub_key_gen+0x28>
   2f818:	3b04      	subs	r3, #4
   2f81a:	e7f9      	b.n	2f810 <bt_pub_key_gen+0x1c>
	parent->next = child;
   2f81c:	6042      	str	r2, [r0, #4]
Z_GENLIST_PREPEND(slist, snode)
   2f81e:	6872      	ldr	r2, [r6, #4]
			BT_WARN("Callback already registered");
			return -EALREADY;
		}
	}

	sys_slist_prepend(&pub_key_cb_slist, &new_cb->node);
   2f820:	1d03      	adds	r3, r0, #4
	list->head = node;
   2f822:	6033      	str	r3, [r6, #0]
Z_GENLIST_PREPEND(slist, snode)
   2f824:	b902      	cbnz	r2, 2f828 <bt_pub_key_gen+0x34>
	list->tail = node;
   2f826:	6073      	str	r3, [r6, #4]
   2f828:	4c26      	ldr	r4, [pc, #152]	; (2f8c4 <bt_pub_key_gen+0xd0>)
   2f82a:	f3bf 8f5b 	dmb	ish
   2f82e:	e854 2f00 	ldrex	r2, [r4]
   2f832:	f042 0320 	orr.w	r3, r2, #32
   2f836:	e844 3100 	strex	r1, r3, [r4]
   2f83a:	2900      	cmp	r1, #0
   2f83c:	d1f7      	bne.n	2f82e <bt_pub_key_gen+0x3a>
   2f83e:	f3bf 8f5b 	dmb	ish

	if (atomic_test_and_set_bit(bt_dev.flags, BT_DEV_PUB_KEY_BUSY)) {
   2f842:	f012 0220 	ands.w	r2, r2, #32
   2f846:	d002      	beq.n	2f84e <bt_pub_key_gen+0x5a>

		sys_slist_init(&pub_key_cb_slist);
		return err;
	}

	return 0;
   2f848:	2500      	movs	r5, #0
}
   2f84a:	4628      	mov	r0, r5
   2f84c:	bd70      	pop	{r4, r5, r6, pc}
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   2f84e:	f3bf 8f5b 	dmb	ish
   2f852:	e854 3f00 	ldrex	r3, [r4]
   2f856:	f023 0310 	bic.w	r3, r3, #16
   2f85a:	e844 3100 	strex	r1, r3, [r4]
   2f85e:	2900      	cmp	r1, #0
   2f860:	d1f7      	bne.n	2f852 <bt_pub_key_gen+0x5e>
   2f862:	f3bf 8f5b 	dmb	ish
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_P256_PUBLIC_KEY, NULL, NULL);
   2f866:	4611      	mov	r1, r2
   2f868:	f242 0025 	movw	r0, #8229	; 0x2025
   2f86c:	f7fe fb5a 	bl	2df24 <bt_hci_cmd_send_sync>
	if (err) {
   2f870:	4605      	mov	r5, r0
   2f872:	2800      	cmp	r0, #0
   2f874:	d0e8      	beq.n	2f848 <bt_pub_key_gen+0x54>
   2f876:	f3bf 8f5b 	dmb	ish
   2f87a:	e854 3f00 	ldrex	r3, [r4]
   2f87e:	f023 0320 	bic.w	r3, r3, #32
   2f882:	e844 3200 	strex	r2, r3, [r4]
   2f886:	2a00      	cmp	r2, #0
   2f888:	d1f7      	bne.n	2f87a <bt_pub_key_gen+0x86>
   2f88a:	f3bf 8f5b 	dmb	ish
	return list->head;
   2f88e:	6834      	ldr	r4, [r6, #0]
		SYS_SLIST_FOR_EACH_CONTAINER(&pub_key_cb_slist, cb, node) {
   2f890:	b13c      	cbz	r4, 2f8a2 <bt_pub_key_gen+0xae>
			if (cb->func) {
   2f892:	f854 3c04 	ldr.w	r3, [r4, #-4]
		SYS_SLIST_FOR_EACH_CONTAINER(&pub_key_cb_slist, cb, node) {
   2f896:	3c04      	subs	r4, #4
			if (cb->func) {
   2f898:	b10b      	cbz	r3, 2f89e <bt_pub_key_gen+0xaa>
				cb->func(NULL);
   2f89a:	2000      	movs	r0, #0
   2f89c:	4798      	blx	r3
	return node->next;
   2f89e:	6864      	ldr	r4, [r4, #4]
   2f8a0:	e7f6      	b.n	2f890 <bt_pub_key_gen+0x9c>
	list->head = NULL;
   2f8a2:	2300      	movs	r3, #0
	list->tail = NULL;
   2f8a4:	e9c6 3300 	strd	r3, r3, [r6]
		return err;
   2f8a8:	e7cf      	b.n	2f84a <bt_pub_key_gen+0x56>
		return -ENOTSUP;
   2f8aa:	f06f 0585 	mvn.w	r5, #133	; 0x85
   2f8ae:	e7cc      	b.n	2f84a <bt_pub_key_gen+0x56>
		return -EINVAL;
   2f8b0:	f06f 0515 	mvn.w	r5, #21
   2f8b4:	e7c9      	b.n	2f84a <bt_pub_key_gen+0x56>
			return -EALREADY;
   2f8b6:	f06f 0577 	mvn.w	r5, #119	; 0x77
   2f8ba:	e7c6      	b.n	2f84a <bt_pub_key_gen+0x56>
   2f8bc:	20000030 	.word	0x20000030
   2f8c0:	20003bc8 	.word	0x20003bc8
   2f8c4:	200000fc 	.word	0x200000fc

0002f8c8 <bt_pub_key_get>:
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   2f8c8:	4b05      	ldr	r3, [pc, #20]	; (2f8e0 <bt_pub_key_get+0x18>)
   2f8ca:	f3bf 8f5b 	dmb	ish
   2f8ce:	681b      	ldr	r3, [r3, #0]
	if (atomic_test_bit(bt_dev.flags, BT_DEV_HAS_PUB_KEY)) {
		return pub_key;
	}

	return NULL;
}
   2f8d0:	4804      	ldr	r0, [pc, #16]	; (2f8e4 <bt_pub_key_get+0x1c>)
   2f8d2:	f3bf 8f5b 	dmb	ish
	return NULL;
   2f8d6:	f013 0f10 	tst.w	r3, #16
}
   2f8da:	bf08      	it	eq
   2f8dc:	2000      	moveq	r0, #0
   2f8de:	4770      	bx	lr
   2f8e0:	200000fc 	.word	0x200000fc
   2f8e4:	20006b67 	.word	0x20006b67

0002f8e8 <bt_dh_key_gen>:

	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_GENERATE_DHKEY_V2, buf, NULL);
}

int bt_dh_key_gen(const uint8_t remote_pk[BT_PUB_KEY_LEN], bt_dh_key_cb_t cb)
{
   2f8e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	int err;

	if (dh_key_cb == cb) {
   2f8ea:	4d1f      	ldr	r5, [pc, #124]	; (2f968 <bt_dh_key_gen+0x80>)
   2f8ec:	682b      	ldr	r3, [r5, #0]
   2f8ee:	428b      	cmp	r3, r1
{
   2f8f0:	4606      	mov	r6, r0
	if (dh_key_cb == cb) {
   2f8f2:	d032      	beq.n	2f95a <bt_dh_key_gen+0x72>
		return -EALREADY;
	}

	if (dh_key_cb || atomic_test_bit(bt_dev.flags, BT_DEV_PUB_KEY_BUSY)) {
   2f8f4:	b113      	cbz	r3, 2f8fc <bt_dh_key_gen+0x14>
		return -EBUSY;
   2f8f6:	f06f 000f 	mvn.w	r0, #15
		BT_WARN("Failed to generate DHKey (err %d)", err);
		return err;
	}

	return 0;
}
   2f8fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2f8fc:	4b1b      	ldr	r3, [pc, #108]	; (2f96c <bt_dh_key_gen+0x84>)
   2f8fe:	f3bf 8f5b 	dmb	ish
   2f902:	681a      	ldr	r2, [r3, #0]
   2f904:	f3bf 8f5b 	dmb	ish
	if (dh_key_cb || atomic_test_bit(bt_dev.flags, BT_DEV_PUB_KEY_BUSY)) {
   2f908:	f3c2 1740 	ubfx	r7, r2, #5, #1
   2f90c:	0692      	lsls	r2, r2, #26
   2f90e:	d4f2      	bmi.n	2f8f6 <bt_dh_key_gen+0xe>
   2f910:	f3bf 8f5b 	dmb	ish
   2f914:	681b      	ldr	r3, [r3, #0]
   2f916:	f3bf 8f5b 	dmb	ish
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_HAS_PUB_KEY)) {
   2f91a:	06db      	lsls	r3, r3, #27
   2f91c:	d520      	bpl.n	2f960 <bt_dh_key_gen+0x78>
	dh_key_cb = cb;
   2f91e:	6029      	str	r1, [r5, #0]
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_GENERATE_DHKEY, sizeof(*cp));
   2f920:	f242 0026 	movw	r0, #8230	; 0x2026
   2f924:	2140      	movs	r1, #64	; 0x40
   2f926:	f7fe faa1 	bl	2de6c <bt_hci_cmd_create>
	if (!buf) {
   2f92a:	4604      	mov	r4, r0
   2f92c:	b190      	cbz	r0, 2f954 <bt_dh_key_gen+0x6c>
	return net_buf_simple_add(&buf->b, len);
   2f92e:	2140      	movs	r1, #64	; 0x40
   2f930:	3008      	adds	r0, #8
   2f932:	f01f fa3f 	bl	4edb4 <net_buf_simple_add>
	memcpy(cp->key, remote_pk, sizeof(cp->key));
   2f936:	2240      	movs	r2, #64	; 0x40
   2f938:	4631      	mov	r1, r6
   2f93a:	f01b fa9e 	bl	4ae7a <memcpy>
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_GENERATE_DHKEY, buf, NULL);
   2f93e:	463a      	mov	r2, r7
   2f940:	4621      	mov	r1, r4
   2f942:	f242 0026 	movw	r0, #8230	; 0x2026
   2f946:	f7fe faed 	bl	2df24 <bt_hci_cmd_send_sync>
	if (err) {
   2f94a:	2800      	cmp	r0, #0
   2f94c:	d0d5      	beq.n	2f8fa <bt_dh_key_gen+0x12>
		dh_key_cb = NULL;
   2f94e:	2300      	movs	r3, #0
   2f950:	602b      	str	r3, [r5, #0]
		return err;
   2f952:	e7d2      	b.n	2f8fa <bt_dh_key_gen+0x12>
		return -ENOBUFS;
   2f954:	f06f 0068 	mvn.w	r0, #104	; 0x68
   2f958:	e7f9      	b.n	2f94e <bt_dh_key_gen+0x66>
		return -EALREADY;
   2f95a:	f06f 0077 	mvn.w	r0, #119	; 0x77
   2f95e:	e7cc      	b.n	2f8fa <bt_dh_key_gen+0x12>
		return -EADDRNOTAVAIL;
   2f960:	f06f 007c 	mvn.w	r0, #124	; 0x7c
   2f964:	e7c9      	b.n	2f8fa <bt_dh_key_gen+0x12>
   2f966:	bf00      	nop
   2f968:	20003bc4 	.word	0x20003bc4
   2f96c:	200000fc 	.word	0x200000fc

0002f970 <bt_hci_evt_le_pkey_complete>:

void bt_hci_evt_le_pkey_complete(struct net_buf *buf)
{
   2f970:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   2f972:	4c1b      	ldr	r4, [pc, #108]	; (2f9e0 <bt_hci_evt_le_pkey_complete+0x70>)
	struct bt_hci_evt_le_p256_public_key_complete *evt = (void *)buf->data;
   2f974:	6886      	ldr	r6, [r0, #8]
   2f976:	f3bf 8f5b 	dmb	ish
   2f97a:	e854 3f00 	ldrex	r3, [r4]
   2f97e:	f023 0320 	bic.w	r3, r3, #32
   2f982:	e844 3200 	strex	r2, r3, [r4]
   2f986:	2a00      	cmp	r2, #0
   2f988:	d1f7      	bne.n	2f97a <bt_hci_evt_le_pkey_complete+0xa>
   2f98a:	f3bf 8f5b 	dmb	ish

	BT_DBG("status: 0x%02x", evt->status);

	atomic_clear_bit(bt_dev.flags, BT_DEV_PUB_KEY_BUSY);

	if (!evt->status) {
   2f98e:	7833      	ldrb	r3, [r6, #0]
   2f990:	b983      	cbnz	r3, 2f9b4 <bt_hci_evt_le_pkey_complete+0x44>
		memcpy(pub_key, evt->key, BT_PUB_KEY_LEN);
   2f992:	4814      	ldr	r0, [pc, #80]	; (2f9e4 <bt_hci_evt_le_pkey_complete+0x74>)
   2f994:	2240      	movs	r2, #64	; 0x40
   2f996:	1c71      	adds	r1, r6, #1
   2f998:	f01b fa6f 	bl	4ae7a <memcpy>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   2f99c:	f3bf 8f5b 	dmb	ish
   2f9a0:	e854 3f00 	ldrex	r3, [r4]
   2f9a4:	f043 0310 	orr.w	r3, r3, #16
   2f9a8:	e844 3200 	strex	r2, r3, [r4]
   2f9ac:	2a00      	cmp	r2, #0
   2f9ae:	d1f7      	bne.n	2f9a0 <bt_hci_evt_le_pkey_complete+0x30>
   2f9b0:	f3bf 8f5b 	dmb	ish
	return list->head;
   2f9b4:	4d0c      	ldr	r5, [pc, #48]	; (2f9e8 <bt_hci_evt_le_pkey_complete+0x78>)
   2f9b6:	682c      	ldr	r4, [r5, #0]
		atomic_set_bit(bt_dev.flags, BT_DEV_HAS_PUB_KEY);
	}

	SYS_SLIST_FOR_EACH_CONTAINER(&pub_key_cb_slist, cb, node) {
   2f9b8:	b16c      	cbz	r4, 2f9d6 <bt_hci_evt_le_pkey_complete+0x66>
		if (cb->func) {
			cb->func(evt->status ? NULL : pub_key);
   2f9ba:	4f0a      	ldr	r7, [pc, #40]	; (2f9e4 <bt_hci_evt_le_pkey_complete+0x74>)
	SYS_SLIST_FOR_EACH_CONTAINER(&pub_key_cb_slist, cb, node) {
   2f9bc:	3c04      	subs	r4, #4
		if (cb->func) {
   2f9be:	6823      	ldr	r3, [r4, #0]
   2f9c0:	b12b      	cbz	r3, 2f9ce <bt_hci_evt_le_pkey_complete+0x5e>
			cb->func(evt->status ? NULL : pub_key);
   2f9c2:	7832      	ldrb	r2, [r6, #0]
   2f9c4:	2a00      	cmp	r2, #0
   2f9c6:	bf0c      	ite	eq
   2f9c8:	4638      	moveq	r0, r7
   2f9ca:	2000      	movne	r0, #0
   2f9cc:	4798      	blx	r3
	return node->next;
   2f9ce:	6864      	ldr	r4, [r4, #4]
	SYS_SLIST_FOR_EACH_CONTAINER(&pub_key_cb_slist, cb, node) {
   2f9d0:	b10c      	cbz	r4, 2f9d6 <bt_hci_evt_le_pkey_complete+0x66>
   2f9d2:	3c04      	subs	r4, #4
   2f9d4:	e7f3      	b.n	2f9be <bt_hci_evt_le_pkey_complete+0x4e>
	list->head = NULL;
   2f9d6:	2300      	movs	r3, #0
	list->tail = NULL;
   2f9d8:	e9c5 3300 	strd	r3, r3, [r5]
		}
	}

	sys_slist_init(&pub_key_cb_slist);
}
   2f9dc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2f9de:	bf00      	nop
   2f9e0:	200000fc 	.word	0x200000fc
   2f9e4:	20006b67 	.word	0x20006b67
   2f9e8:	20003bc8 	.word	0x20003bc8

0002f9ec <bt_hci_evt_le_dhkey_complete>:
{
	struct bt_hci_evt_le_generate_dhkey_complete *evt = (void *)buf->data;

	BT_DBG("status: 0x%02x", evt->status);

	if (dh_key_cb) {
   2f9ec:	4905      	ldr	r1, [pc, #20]	; (2fa04 <bt_hci_evt_le_dhkey_complete+0x18>)
   2f9ee:	680b      	ldr	r3, [r1, #0]
   2f9f0:	b133      	cbz	r3, 2fa00 <bt_hci_evt_le_dhkey_complete+0x14>
	struct bt_hci_evt_le_generate_dhkey_complete *evt = (void *)buf->data;
   2f9f2:	6882      	ldr	r2, [r0, #8]
		bt_dh_key_cb_t cb = dh_key_cb;

		dh_key_cb = NULL;
   2f9f4:	2000      	movs	r0, #0
   2f9f6:	6008      	str	r0, [r1, #0]
		cb(evt->status ? NULL : evt->dhkey);
   2f9f8:	7811      	ldrb	r1, [r2, #0]
   2f9fa:	b901      	cbnz	r1, 2f9fe <bt_hci_evt_le_dhkey_complete+0x12>
   2f9fc:	1c50      	adds	r0, r2, #1
   2f9fe:	4718      	bx	r3
	}
}
   2fa00:	4770      	bx	lr
   2fa02:	bf00      	nop
   2fa04:	20003bc4 	.word	0x20003bc4

0002fa08 <notify_connected>:
		return -ENOTCONN;
	}
}

static void notify_connected(struct bt_conn *conn)
{
   2fa08:	b570      	push	{r4, r5, r6, lr}
	struct bt_conn_cb *cb;

	for (cb = callback_list; cb; cb = cb->_next) {
   2fa0a:	4b0b      	ldr	r3, [pc, #44]	; (2fa38 <notify_connected+0x30>)
   2fa0c:	681d      	ldr	r5, [r3, #0]
{
   2fa0e:	4604      	mov	r4, r0
	for (cb = callback_list; cb; cb = cb->_next) {
   2fa10:	b925      	cbnz	r5, 2fa1c <notify_connected+0x14>
		if (cb->connected) {
			cb->connected(conn, conn->err);
		}
	}

	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
   2fa12:	4d0a      	ldr	r5, [pc, #40]	; (2fa3c <notify_connected+0x34>)
   2fa14:	4e0a      	ldr	r6, [pc, #40]	; (2fa40 <notify_connected+0x38>)
   2fa16:	42b5      	cmp	r5, r6
   2fa18:	d307      	bcc.n	2fa2a <notify_connected+0x22>
		if (cb->connected) {
			cb->connected(conn, conn->err);
		}
	}
}
   2fa1a:	bd70      	pop	{r4, r5, r6, pc}
		if (cb->connected) {
   2fa1c:	682b      	ldr	r3, [r5, #0]
   2fa1e:	b113      	cbz	r3, 2fa26 <notify_connected+0x1e>
			cb->connected(conn, conn->err);
   2fa20:	7b21      	ldrb	r1, [r4, #12]
   2fa22:	4620      	mov	r0, r4
   2fa24:	4798      	blx	r3
	for (cb = callback_list; cb; cb = cb->_next) {
   2fa26:	69ed      	ldr	r5, [r5, #28]
   2fa28:	e7f2      	b.n	2fa10 <notify_connected+0x8>
		if (cb->connected) {
   2fa2a:	682b      	ldr	r3, [r5, #0]
   2fa2c:	b113      	cbz	r3, 2fa34 <notify_connected+0x2c>
			cb->connected(conn, conn->err);
   2fa2e:	7b21      	ldrb	r1, [r4, #12]
   2fa30:	4620      	mov	r0, r4
   2fa32:	4798      	blx	r3
	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
   2fa34:	3520      	adds	r5, #32
   2fa36:	e7ee      	b.n	2fa16 <notify_connected+0xe>
   2fa38:	20003c00 	.word	0x20003c00
   2fa3c:	00050c78 	.word	0x00050c78
   2fa40:	00050c78 	.word	0x00050c78

0002fa44 <tx_notify>:
{
   2fa44:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	k_fifo_put(&free_tx, tx);
   2fa48:	4f15      	ldr	r7, [pc, #84]	; (2faa0 <tx_notify+0x5c>)
{
   2fa4a:	4604      	mov	r4, r0
	tx->cb = NULL;
   2fa4c:	f04f 0800 	mov.w	r8, #0
	__asm__ volatile(
   2fa50:	f04f 0220 	mov.w	r2, #32
   2fa54:	f3ef 8311 	mrs	r3, BASEPRI
   2fa58:	f382 8812 	msr	BASEPRI_MAX, r2
   2fa5c:	f3bf 8f6f 	isb	sy
	return list->head;
   2fa60:	6a21      	ldr	r1, [r4, #32]
		if (!sys_slist_is_empty(&conn->tx_complete)) {
   2fa62:	b929      	cbnz	r1, 2fa70 <tx_notify+0x2c>
	__asm__ volatile(
   2fa64:	f383 8811 	msr	BASEPRI, r3
   2fa68:	f3bf 8f6f 	isb	sy
}
   2fa6c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 *
 * @return A pointer to the first node of the list
 */
static inline sys_snode_t *sys_slist_get_not_empty(sys_slist_t *list);

Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   2fa70:	6a60      	ldr	r0, [r4, #36]	; 0x24
	return node->next;
   2fa72:	680a      	ldr	r2, [r1, #0]
	list->head = node;
   2fa74:	6222      	str	r2, [r4, #32]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   2fa76:	4281      	cmp	r1, r0
	list->tail = node;
   2fa78:	bf08      	it	eq
   2fa7a:	6262      	streq	r2, [r4, #36]	; 0x24
   2fa7c:	f383 8811 	msr	BASEPRI, r3
   2fa80:	f3bf 8f6f 	isb	sy
		user_data = tx->user_data;
   2fa84:	e9d1 5601 	ldrd	r5, r6, [r1, #4]
	tx->pending_no_cb = 0U;
   2fa88:	f8c1 800c 	str.w	r8, [r1, #12]
	tx->user_data = NULL;
   2fa8c:	e9c1 8801 	strd	r8, r8, [r1, #4]
	k_fifo_put(&free_tx, tx);
   2fa90:	4638      	mov	r0, r7
   2fa92:	f020 f99d 	bl	4fdd0 <k_queue_append>
		cb(conn, user_data, 0);
   2fa96:	2200      	movs	r2, #0
   2fa98:	4631      	mov	r1, r6
   2fa9a:	4620      	mov	r0, r4
   2fa9c:	47a8      	blx	r5
	while (1) {
   2fa9e:	e7d7      	b.n	2fa50 <tx_notify+0xc>
   2faa0:	200012b4 	.word	0x200012b4

0002faa4 <conn_tx_destroy>:
{
   2faa4:	b570      	push	{r4, r5, r6, lr}
	void *user_data = tx->user_data;
   2faa6:	e9d1 5601 	ldrd	r5, r6, [r1, #4]
	tx->cb = NULL;
   2faaa:	2200      	movs	r2, #0
	tx->user_data = NULL;
   2faac:	e9c1 2201 	strd	r2, r2, [r1, #4]
{
   2fab0:	4604      	mov	r4, r0
	tx->pending_no_cb = 0U;
   2fab2:	60ca      	str	r2, [r1, #12]
	k_fifo_put(&free_tx, tx);
   2fab4:	4805      	ldr	r0, [pc, #20]	; (2facc <conn_tx_destroy+0x28>)
   2fab6:	f020 f98b 	bl	4fdd0 <k_queue_append>
	cb(conn, user_data, -ESHUTDOWN);
   2faba:	4631      	mov	r1, r6
   2fabc:	4620      	mov	r0, r4
   2fabe:	462b      	mov	r3, r5
   2fac0:	f06f 026d 	mvn.w	r2, #109	; 0x6d
}
   2fac4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	cb(conn, user_data, -ESHUTDOWN);
   2fac8:	4718      	bx	r3
   2faca:	bf00      	nop
   2facc:	200012b4 	.word	0x200012b4

0002fad0 <send_frag>:
{
   2fad0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   2fad4:	4604      	mov	r4, r0
	struct bt_conn_tx *tx = tx_data(buf)->tx;
   2fad6:	694d      	ldr	r5, [r1, #20]
{
   2fad8:	460e      	mov	r6, r1
   2fada:	4617      	mov	r7, r2
   2fadc:	4699      	mov	r9, r3
	return z_impl_k_sem_take(sem, timeout);
   2fade:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2fae2:	483e      	ldr	r0, [pc, #248]	; (2fbdc <send_frag+0x10c>)
   2fae4:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   2fae8:	f017 fb6c 	bl	471c4 <z_impl_k_sem_take>
	if (conn->state != BT_CONN_CONNECTED) {
   2faec:	7b63      	ldrb	r3, [r4, #13]
   2faee:	2b07      	cmp	r3, #7
   2faf0:	d167      	bne.n	2fbc2 <send_frag+0xf2>
	__asm__ volatile(
   2faf2:	f04f 0320 	mov.w	r3, #32
   2faf6:	f3ef 8211 	mrs	r2, BASEPRI
   2fafa:	f383 8812 	msr	BASEPRI_MAX, r3
   2fafe:	f3bf 8f6f 	isb	sy
	if (tx) {
   2fb02:	2d00      	cmp	r5, #0
   2fb04:	d03e      	beq.n	2fb84 <send_frag+0xb4>
	parent->next = child;
   2fb06:	2300      	movs	r3, #0
   2fb08:	602b      	str	r3, [r5, #0]
	return list->tail;
   2fb0a:	69a3      	ldr	r3, [r4, #24]
Z_GENLIST_APPEND(slist, snode)
   2fb0c:	2b00      	cmp	r3, #0
   2fb0e:	d136      	bne.n	2fb7e <send_frag+0xae>
	list->head = node;
   2fb10:	e9c4 5505 	strd	r5, r5, [r4, #20]
	__asm__ volatile(
   2fb14:	f382 8811 	msr	BASEPRI, r2
   2fb18:	f3bf 8f6f 	isb	sy
	return net_buf_simple_push(&buf->b, len);
   2fb1c:	2104      	movs	r1, #4
   2fb1e:	f106 0008 	add.w	r0, r6, #8
   2fb22:	f01f f968 	bl	4edf6 <net_buf_simple_push>
	hdr->handle = sys_cpu_to_le16(bt_acl_handle_pack(conn->handle, flags));
   2fb26:	8823      	ldrh	r3, [r4, #0]
   2fb28:	f007 07fd 	and.w	r7, r7, #253	; 0xfd
   2fb2c:	ea43 3707 	orr.w	r7, r3, r7, lsl #12
   2fb30:	8007      	strh	r7, [r0, #0]
	hdr->len = sys_cpu_to_le16(buf->len - sizeof(*hdr));
   2fb32:	89b3      	ldrh	r3, [r6, #12]
   2fb34:	3b04      	subs	r3, #4
   2fb36:	8043      	strh	r3, [r0, #2]
	((struct bt_buf_data *)net_buf_user_data(buf))->type = type;
   2fb38:	2302      	movs	r3, #2
   2fb3a:	7533      	strb	r3, [r6, #20]
	return bt_send(buf);
   2fb3c:	4630      	mov	r0, r6
   2fb3e:	f01b fde0 	bl	4b702 <bt_send>
	if (err) {
   2fb42:	2800      	cmp	r0, #0
   2fb44:	d047      	beq.n	2fbd6 <send_frag+0x106>
	__asm__ volatile(
   2fb46:	f04f 0320 	mov.w	r3, #32
   2fb4a:	f3ef 8711 	mrs	r7, BASEPRI
   2fb4e:	f383 8812 	msr	BASEPRI_MAX, r3
   2fb52:	f3bf 8f6f 	isb	sy
		if (tx) {
   2fb56:	b315      	cbz	r5, 2fb9e <send_frag+0xce>
			sys_slist_find_and_remove(&conn->tx_pending, &tx->node);
   2fb58:	4629      	mov	r1, r5
   2fb5a:	f104 0014 	add.w	r0, r4, #20
   2fb5e:	f01c f85c 	bl	4bc1a <sys_slist_find_and_remove>
	__asm__ volatile(
   2fb62:	f387 8811 	msr	BASEPRI, r7
   2fb66:	f3bf 8f6f 	isb	sy
	z_impl_k_sem_give(sem);
   2fb6a:	481c      	ldr	r0, [pc, #112]	; (2fbdc <send_frag+0x10c>)
   2fb6c:	f017 fb04 	bl	47178 <z_impl_k_sem_give>
		tx_data(buf)->tx = NULL;
   2fb70:	2300      	movs	r3, #0
   2fb72:	6173      	str	r3, [r6, #20]
		conn_tx_destroy(conn, tx);
   2fb74:	4629      	mov	r1, r5
   2fb76:	4620      	mov	r0, r4
   2fb78:	f7ff ff94 	bl	2faa4 <conn_tx_destroy>
   2fb7c:	e01b      	b.n	2fbb6 <send_frag+0xe6>
	parent->next = child;
   2fb7e:	601d      	str	r5, [r3, #0]
	list->tail = node;
   2fb80:	61a5      	str	r5, [r4, #24]
}
   2fb82:	e7c7      	b.n	2fb14 <send_frag+0x44>
	return list->tail;
   2fb84:	69a3      	ldr	r3, [r4, #24]
		if (tail_tx) {
   2fb86:	b133      	cbz	r3, 2fb96 <send_frag+0xc6>
			pending_no_cb = &tail_tx->pending_no_cb;
   2fb88:	f103 080c 	add.w	r8, r3, #12
   2fb8c:	68db      	ldr	r3, [r3, #12]
		(*pending_no_cb)++;
   2fb8e:	3301      	adds	r3, #1
   2fb90:	f8c8 3000 	str.w	r3, [r8]
   2fb94:	e7be      	b.n	2fb14 <send_frag+0x44>
			pending_no_cb = &conn->pending_no_cb;
   2fb96:	69e3      	ldr	r3, [r4, #28]
   2fb98:	f104 081c 	add.w	r8, r4, #28
   2fb9c:	e7f7      	b.n	2fb8e <send_frag+0xbe>
			(*pending_no_cb)--;
   2fb9e:	f8d8 3000 	ldr.w	r3, [r8]
   2fba2:	3b01      	subs	r3, #1
   2fba4:	f8c8 3000 	str.w	r3, [r8]
   2fba8:	f387 8811 	msr	BASEPRI, r7
   2fbac:	f3bf 8f6f 	isb	sy
   2fbb0:	480a      	ldr	r0, [pc, #40]	; (2fbdc <send_frag+0x10c>)
   2fbb2:	f017 fae1 	bl	47178 <z_impl_k_sem_give>
	if (always_consume) {
   2fbb6:	f1b9 0f00 	cmp.w	r9, #0
   2fbba:	d108      	bne.n	2fbce <send_frag+0xfe>
	return false;
   2fbbc:	2000      	movs	r0, #0
}
   2fbbe:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   2fbc2:	4806      	ldr	r0, [pc, #24]	; (2fbdc <send_frag+0x10c>)
   2fbc4:	f017 fad8 	bl	47178 <z_impl_k_sem_give>
	if (tx) {
   2fbc8:	2d00      	cmp	r5, #0
   2fbca:	d1d1      	bne.n	2fb70 <send_frag+0xa0>
   2fbcc:	e7f3      	b.n	2fbb6 <send_frag+0xe6>
		net_buf_unref(buf);
   2fbce:	4630      	mov	r0, r6
   2fbd0:	f012 fe3a 	bl	42848 <net_buf_unref>
   2fbd4:	e7f2      	b.n	2fbbc <send_frag+0xec>
	return true;
   2fbd6:	2001      	movs	r0, #1
   2fbd8:	e7f1      	b.n	2fbbe <send_frag+0xee>
   2fbda:	bf00      	nop
   2fbdc:	20000130 	.word	0x20000130

0002fbe0 <bt_conn_get_pkts>:
}
   2fbe0:	4800      	ldr	r0, [pc, #0]	; (2fbe4 <bt_conn_get_pkts+0x4>)
   2fbe2:	4770      	bx	lr
   2fbe4:	20000130 	.word	0x20000130

0002fbe8 <bt_conn_new>:
{
   2fbe8:	b538      	push	{r3, r4, r5, lr}
	for (i = 0; i < size; i++) {
   2fbea:	2200      	movs	r2, #0
   2fbec:	4604      	mov	r4, r0
   2fbee:	428a      	cmp	r2, r1
   2fbf0:	d102      	bne.n	2fbf8 <bt_conn_new+0x10>
		if (atomic_cas(&conns[i].ref, 0, 1)) {
   2fbf2:	2400      	movs	r4, #0
}
   2fbf4:	4620      	mov	r0, r4
   2fbf6:	bd38      	pop	{r3, r4, r5, pc}
	return __atomic_compare_exchange_n(target, &old_value, new_value,
   2fbf8:	f104 03bc 	add.w	r3, r4, #188	; 0xbc
   2fbfc:	2001      	movs	r0, #1
   2fbfe:	f3bf 8f5b 	dmb	ish
   2fc02:	e853 5f00 	ldrex	r5, [r3]
   2fc06:	2d00      	cmp	r5, #0
   2fc08:	d104      	bne.n	2fc14 <bt_conn_new+0x2c>
   2fc0a:	e843 0c00 	strex	ip, r0, [r3]
   2fc0e:	f1bc 0f00 	cmp.w	ip, #0
   2fc12:	d1f6      	bne.n	2fc02 <bt_conn_new+0x1a>
   2fc14:	f3bf 8f5b 	dmb	ish
		if (atomic_cas(&conns[i].ref, 0, 1)) {
   2fc18:	d002      	beq.n	2fc20 <bt_conn_new+0x38>
   2fc1a:	34c0      	adds	r4, #192	; 0xc0
	for (i = 0; i < size; i++) {
   2fc1c:	4402      	add	r2, r0
   2fc1e:	e7e6      	b.n	2fbee <bt_conn_new+0x6>
	if (!conn) {
   2fc20:	2c00      	cmp	r4, #0
   2fc22:	d0e6      	beq.n	2fbf2 <bt_conn_new+0xa>
	(void)memset(conn, 0, offsetof(struct bt_conn, ref));
   2fc24:	22bc      	movs	r2, #188	; 0xbc
   2fc26:	2100      	movs	r1, #0
   2fc28:	4620      	mov	r0, r4
   2fc2a:	f01b f931 	bl	4ae90 <memset>
	k_work_init_delayable(&conn->deferred_work, deferred_work);
   2fc2e:	f104 0058 	add.w	r0, r4, #88	; 0x58
   2fc32:	4904      	ldr	r1, [pc, #16]	; (2fc44 <bt_conn_new+0x5c>)
   2fc34:	f020 f9e6 	bl	50004 <k_work_init_delayable>
	k_work_init(&conn->tx_complete_work, tx_complete_work);
   2fc38:	4903      	ldr	r1, [pc, #12]	; (2fc48 <bt_conn_new+0x60>)
   2fc3a:	f104 0028 	add.w	r0, r4, #40	; 0x28
   2fc3e:	f020 f99d 	bl	4ff7c <k_work_init>
	return conn;
   2fc42:	e7d7      	b.n	2fbf4 <bt_conn_new+0xc>
   2fc44:	00030525 	.word	0x00030525
   2fc48:	0004bc99 	.word	0x0004bc99

0002fc4c <bt_conn_send_cb>:
{
   2fc4c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2fc4e:	461f      	mov	r7, r3
	if (conn->state != BT_CONN_CONNECTED) {
   2fc50:	7b43      	ldrb	r3, [r0, #13]
   2fc52:	2b07      	cmp	r3, #7
{
   2fc54:	4604      	mov	r4, r0
   2fc56:	460e      	mov	r6, r1
   2fc58:	4615      	mov	r5, r2
	if (conn->state != BT_CONN_CONNECTED) {
   2fc5a:	d11b      	bne.n	2fc94 <bt_conn_send_cb+0x48>
	if (cb) {
   2fc5c:	b342      	cbz	r2, 2fcb0 <bt_conn_send_cb+0x64>
	return z_impl_z_current_get();
   2fc5e:	f017 ffb1 	bl	47bc4 <z_impl_z_current_get>
	if (k_current_get() == &k_sys_work_q.thread) {
   2fc62:	4b16      	ldr	r3, [pc, #88]	; (2fcbc <bt_conn_send_cb+0x70>)
   2fc64:	4283      	cmp	r3, r0
	return z_impl_k_queue_get(queue, timeout);
   2fc66:	4816      	ldr	r0, [pc, #88]	; (2fcc0 <bt_conn_send_cb+0x74>)
   2fc68:	bf07      	ittee	eq
   2fc6a:	2200      	moveq	r2, #0
   2fc6c:	2300      	moveq	r3, #0
   2fc6e:	f04f 32ff 	movne.w	r2, #4294967295	; 0xffffffff
   2fc72:	f04f 33ff 	movne.w	r3, #4294967295	; 0xffffffff
   2fc76:	f017 fa4b 	bl	47110 <z_impl_k_queue_get>
   2fc7a:	4601      	mov	r1, r0
		if (!tx) {
   2fc7c:	b1d0      	cbz	r0, 2fcb4 <bt_conn_send_cb+0x68>
		if (conn->state != BT_CONN_CONNECTED) {
   2fc7e:	7b63      	ldrb	r3, [r4, #13]
   2fc80:	2b07      	cmp	r3, #7
   2fc82:	f04f 0200 	mov.w	r2, #0
   2fc86:	d008      	beq.n	2fc9a <bt_conn_send_cb+0x4e>
	tx->user_data = NULL;
   2fc88:	e9c0 2201 	strd	r2, r2, [r0, #4]
	tx->pending_no_cb = 0U;
   2fc8c:	60c2      	str	r2, [r0, #12]
	k_fifo_put(&free_tx, tx);
   2fc8e:	480c      	ldr	r0, [pc, #48]	; (2fcc0 <bt_conn_send_cb+0x74>)
   2fc90:	f020 f89e 	bl	4fdd0 <k_queue_append>
		return -ENOTCONN;
   2fc94:	f06f 007f 	mvn.w	r0, #127	; 0x7f
}
   2fc98:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		tx->user_data = user_data;
   2fc9a:	e9c0 5701 	strd	r5, r7, [r0, #4]
		tx->pending_no_cb = 0U;
   2fc9e:	60c2      	str	r2, [r0, #12]
		tx_data(buf)->tx = tx;
   2fca0:	6171      	str	r1, [r6, #20]
	net_buf_put(&conn->tx_queue, buf);
   2fca2:	f104 0038 	add.w	r0, r4, #56	; 0x38
   2fca6:	4631      	mov	r1, r6
   2fca8:	f01f f845 	bl	4ed36 <net_buf_put>
	return 0;
   2fcac:	2000      	movs	r0, #0
   2fcae:	e7f3      	b.n	2fc98 <bt_conn_send_cb+0x4c>
   2fcb0:	4611      	mov	r1, r2
   2fcb2:	e7f5      	b.n	2fca0 <bt_conn_send_cb+0x54>
			return -ENOBUFS;
   2fcb4:	f06f 0068 	mvn.w	r0, #104	; 0x68
   2fcb8:	e7ee      	b.n	2fc98 <bt_conn_send_cb+0x4c>
   2fcba:	bf00      	nop
   2fcbc:	20003678 	.word	0x20003678
   2fcc0:	200012b4 	.word	0x200012b4

0002fcc4 <bt_conn_prepare_events>:
{
   2fcc4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   2fcc8:	4606      	mov	r6, r0
		(void) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_POLL_SIGNAL_INIT);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_poll_signal_init(sig);
   2fcca:	481c      	ldr	r0, [pc, #112]	; (2fd3c <bt_conn_prepare_events+0x78>)
   2fccc:	4c1c      	ldr	r4, [pc, #112]	; (2fd40 <bt_conn_prepare_events+0x7c>)
   2fcce:	f020 fcda 	bl	50686 <z_impl_k_poll_signal_init>
	k_poll_event_init(&events[ev_count++], K_POLL_TYPE_SIGNAL,
   2fcd2:	4b1a      	ldr	r3, [pc, #104]	; (2fd3c <bt_conn_prepare_events+0x78>)
   2fcd4:	2200      	movs	r2, #0
   2fcd6:	2101      	movs	r1, #1
   2fcd8:	4630      	mov	r0, r6
   2fcda:	f020 fcb7 	bl	5064c <k_poll_event_init>
	for (i = 0; i < ARRAY_SIZE(acl_conns); i++) {
   2fcde:	2700      	movs	r7, #0
	k_poll_event_init(&events[ev_count++], K_POLL_TYPE_SIGNAL,
   2fce0:	2501      	movs	r5, #1
		if (!conn_prepare_events(conn, &events[ev_count])) {
   2fce2:	f04f 0914 	mov.w	r9, #20
	if (!atomic_get(&conn->ref)) {
   2fce6:	f104 00bc 	add.w	r0, r4, #188	; 0xbc
		if (!conn_prepare_events(conn, &events[ev_count])) {
   2fcea:	fb09 6805 	mla	r8, r9, r5, r6
	if (!atomic_get(&conn->ref)) {
   2fcee:	f01b ffbe 	bl	4bc6e <atomic_get>
   2fcf2:	b158      	cbz	r0, 2fd0c <bt_conn_prepare_events+0x48>
	if (conn->state == BT_CONN_DISCONNECTED &&
   2fcf4:	7b63      	ldrb	r3, [r4, #13]
   2fcf6:	b98b      	cbnz	r3, 2fd1c <bt_conn_prepare_events+0x58>
   2fcf8:	f06f 0140 	mvn.w	r1, #64	; 0x40
   2fcfc:	1d20      	adds	r0, r4, #4
   2fcfe:	f01b ffa7 	bl	4bc50 <atomic_and>
   2fd02:	0643      	lsls	r3, r0, #25
   2fd04:	d50a      	bpl.n	2fd1c <bt_conn_prepare_events+0x58>
		conn_cleanup(conn);
   2fd06:	4620      	mov	r0, r4
   2fd08:	f01b ffd2 	bl	4bcb0 <conn_cleanup>
	for (i = 0; i < ARRAY_SIZE(acl_conns); i++) {
   2fd0c:	3701      	adds	r7, #1
   2fd0e:	2f06      	cmp	r7, #6
   2fd10:	f104 04c0 	add.w	r4, r4, #192	; 0xc0
   2fd14:	d1e7      	bne.n	2fce6 <bt_conn_prepare_events+0x22>
}
   2fd16:	4628      	mov	r0, r5
   2fd18:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if (conn->state != BT_CONN_CONNECTED) {
   2fd1c:	7b63      	ldrb	r3, [r4, #13]
   2fd1e:	2b07      	cmp	r3, #7
   2fd20:	d1f4      	bne.n	2fd0c <bt_conn_prepare_events+0x48>
	k_poll_event_init(&events[0],
   2fd22:	f104 0338 	add.w	r3, r4, #56	; 0x38
   2fd26:	2200      	movs	r2, #0
   2fd28:	2104      	movs	r1, #4
   2fd2a:	4640      	mov	r0, r8
   2fd2c:	f020 fc8e 	bl	5064c <k_poll_event_init>
	events[0].tag = BT_EVENT_CONN_TX_QUEUE;
   2fd30:	2301      	movs	r3, #1
   2fd32:	f888 300c 	strb.w	r3, [r8, #12]
			ev_count++;
   2fd36:	441d      	add	r5, r3
   2fd38:	e7e8      	b.n	2fd0c <bt_conn_prepare_events+0x48>
   2fd3a:	bf00      	nop
   2fd3c:	20000694 	.word	0x20000694
   2fd40:	20001828 	.word	0x20001828

0002fd44 <bt_conn_lookup_handle>:
{
   2fd44:	4602      	mov	r2, r0
	conn = conn_lookup_handle(acl_conns, ARRAY_SIZE(acl_conns), handle);
   2fd46:	2106      	movs	r1, #6
   2fd48:	4801      	ldr	r0, [pc, #4]	; (2fd50 <bt_conn_lookup_handle+0xc>)
   2fd4a:	f01c b855 	b.w	4bdf8 <conn_lookup_handle>
   2fd4e:	bf00      	nop
   2fd50:	20001828 	.word	0x20001828

0002fd54 <bt_conn_set_state>:
{
   2fd54:	b570      	push	{r4, r5, r6, lr}
	if (conn->state == state) {
   2fd56:	7b45      	ldrb	r5, [r0, #13]
   2fd58:	428d      	cmp	r5, r1
{
   2fd5a:	4604      	mov	r4, r0
	if (conn->state == state) {
   2fd5c:	f000 80ad 	beq.w	2feba <bt_conn_set_state+0x166>
	conn->state = state;
   2fd60:	7341      	strb	r1, [r0, #13]
	switch (old_state) {
   2fd62:	b15d      	cbz	r5, 2fd7c <bt_conn_set_state+0x28>
   2fd64:	2d06      	cmp	r5, #6
   2fd66:	d00f      	beq.n	2fd88 <bt_conn_set_state+0x34>
	switch (conn->state) {
   2fd68:	7b63      	ldrb	r3, [r4, #13]
   2fd6a:	2b07      	cmp	r3, #7
   2fd6c:	f200 80a5 	bhi.w	2feba <bt_conn_set_state+0x166>
   2fd70:	e8df f003 	tbb	[pc, r3]
   2fd74:	a3a31142 	.word	0xa3a31142
   2fd78:	287ea3a3 	.word	0x287ea3a3
		if (conn->type != BT_CONN_TYPE_ISO) {
   2fd7c:	7883      	ldrb	r3, [r0, #2]
   2fd7e:	2b08      	cmp	r3, #8
   2fd80:	d0f2      	beq.n	2fd68 <bt_conn_set_state+0x14>
			bt_conn_ref(conn);
   2fd82:	f01c f805 	bl	4bd90 <bt_conn_ref>
   2fd86:	e7ef      	b.n	2fd68 <bt_conn_set_state+0x14>
		if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
   2fd88:	7883      	ldrb	r3, [r0, #2]
   2fd8a:	2b01      	cmp	r3, #1
   2fd8c:	d1ec      	bne.n	2fd68 <bt_conn_set_state+0x14>
			k_work_cancel_delayable(&conn->deferred_work);
   2fd8e:	3058      	adds	r0, #88	; 0x58
   2fd90:	f020 f946 	bl	50020 <k_work_cancel_delayable>
   2fd94:	e7e8      	b.n	2fd68 <bt_conn_set_state+0x14>
	z_impl_k_sem_give(sem);
   2fd96:	4d58      	ldr	r5, [pc, #352]	; (2fef8 <bt_conn_set_state+0x1a4>)
		tx->pending_no_cb = 0U;
   2fd98:	2600      	movs	r6, #0
	__asm__ volatile(
   2fd9a:	f04f 0220 	mov.w	r2, #32
   2fd9e:	f3ef 8311 	mrs	r3, BASEPRI
   2fda2:	f382 8812 	msr	BASEPRI_MAX, r2
   2fda6:	f3bf 8f6f 	isb	sy
		if (conn->pending_no_cb) {
   2fdaa:	69e2      	ldr	r2, [r4, #28]
   2fdac:	2a00      	cmp	r2, #0
   2fdae:	d07e      	beq.n	2feae <bt_conn_set_state+0x15a>
			conn->pending_no_cb--;
   2fdb0:	3a01      	subs	r2, #1
   2fdb2:	61e2      	str	r2, [r4, #28]
	__asm__ volatile(
   2fdb4:	f383 8811 	msr	BASEPRI, r3
   2fdb8:	f3bf 8f6f 	isb	sy
   2fdbc:	4628      	mov	r0, r5
   2fdbe:	f017 f9db 	bl	47178 <z_impl_k_sem_give>
}
   2fdc2:	e7ea      	b.n	2fd9a <bt_conn_set_state+0x46>
		if (conn->type == BT_CONN_TYPE_SCO) {
   2fdc4:	78a3      	ldrb	r3, [r4, #2]
   2fdc6:	2b04      	cmp	r3, #4
   2fdc8:	d077      	beq.n	2feba <bt_conn_set_state+0x166>
	z_impl_k_queue_init(queue);
   2fdca:	f104 0038 	add.w	r0, r4, #56	; 0x38
   2fdce:	f01f ffd3 	bl	4fd78 <z_impl_k_queue_init>
		union { uintptr_t x; int val; } parm1 = { .val = result };
		return (int) arch_syscall_invoke2(parm0.x, parm1.x, K_SYSCALL_K_POLL_SIGNAL_RAISE);
	}
#endif
	compiler_barrier();
	return z_impl_k_poll_signal_raise(sig, result);
   2fdd2:	484a      	ldr	r0, [pc, #296]	; (2fefc <bt_conn_set_state+0x1a8>)
   2fdd4:	2100      	movs	r1, #0
   2fdd6:	f018 f9d9 	bl	4818c <z_impl_k_poll_signal_raise>
	list->head = NULL;
   2fdda:	2300      	movs	r3, #0
	list->tail = NULL;
   2fddc:	e9c4 3314 	strd	r3, r3, [r4, #80]	; 0x50
		if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
   2fde0:	78e3      	ldrb	r3, [r4, #3]
   2fde2:	2b01      	cmp	r3, #1
   2fde4:	d169      	bne.n	2feba <bt_conn_set_state+0x166>
			k_work_schedule(&conn->deferred_work,
   2fde6:	f44f 3220 	mov.w	r2, #163840	; 0x28000
   2fdea:	2300      	movs	r3, #0
   2fdec:	f104 0058 	add.w	r0, r4, #88	; 0x58
}
   2fdf0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			k_work_schedule(&conn->deferred_work,
   2fdf4:	f017 bbc6 	b.w	47584 <k_work_schedule>
		if (conn->type == BT_CONN_TYPE_SCO) {
   2fdf8:	78a3      	ldrb	r3, [r4, #2]
   2fdfa:	2b04      	cmp	r3, #4
   2fdfc:	d104      	bne.n	2fe08 <bt_conn_set_state+0xb4>
			bt_conn_unref(conn);
   2fdfe:	4620      	mov	r0, r4
}
   2fe00:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			bt_conn_unref(conn);
   2fe04:	f01b bfdf 	b.w	4bdc6 <bt_conn_unref>
		switch (old_state) {
   2fe08:	3d01      	subs	r5, #1
   2fe0a:	2d05      	cmp	r5, #5
   2fe0c:	d855      	bhi.n	2feba <bt_conn_set_state+0x166>
   2fe0e:	a301      	add	r3, pc, #4	; (adr r3, 2fe14 <bt_conn_set_state+0xc0>)
   2fe10:	f853 f025 	ldr.w	pc, [r3, r5, lsl #2]
   2fe14:	0002fe2d 	.word	0x0002fe2d
   2fe18:	0002fe63 	.word	0x0002fe63
   2fe1c:	0002fdff 	.word	0x0002fdff
   2fe20:	0002fdff 	.word	0x0002fdff
   2fe24:	0002fe63 	.word	0x0002fe63
   2fe28:	0002fe63 	.word	0x0002fe63
			tx_notify(conn);
   2fe2c:	4620      	mov	r0, r4
   2fe2e:	f7ff fe09 	bl	2fa44 <tx_notify>
			if ((conn->type == BT_CONN_TYPE_LE) &&
   2fe32:	78a3      	ldrb	r3, [r4, #2]
   2fe34:	2b01      	cmp	r3, #1
   2fe36:	d10a      	bne.n	2fe4e <bt_conn_set_state+0xfa>
			    (k_work_delayable_busy_get(&conn->deferred_work) &
   2fe38:	f104 0558 	add.w	r5, r4, #88	; 0x58
   2fe3c:	4628      	mov	r0, r5
   2fe3e:	f020 f8ed 	bl	5001c <k_work_delayable_busy_get>
			if ((conn->type == BT_CONN_TYPE_LE) &&
   2fe42:	f010 0f0c 	tst.w	r0, #12
   2fe46:	d002      	beq.n	2fe4e <bt_conn_set_state+0xfa>
				k_work_cancel_delayable(&conn->deferred_work);
   2fe48:	4628      	mov	r0, r5
   2fe4a:	f020 f8e9 	bl	50020 <k_work_cancel_delayable>
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
   2fe4e:	2140      	movs	r1, #64	; 0x40
   2fe50:	1d20      	adds	r0, r4, #4
   2fe52:	f01b ff12 	bl	4bc7a <atomic_or>
   2fe56:	4829      	ldr	r0, [pc, #164]	; (2fefc <bt_conn_set_state+0x1a8>)
}
   2fe58:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   2fe5c:	2100      	movs	r1, #0
   2fe5e:	f018 b995 	b.w	4818c <z_impl_k_poll_signal_raise>
			if (conn->err) {
   2fe62:	7b23      	ldrb	r3, [r4, #12]
   2fe64:	2b00      	cmp	r3, #0
   2fe66:	d0ca      	beq.n	2fdfe <bt_conn_set_state+0xaa>
				notify_connected(conn);
   2fe68:	4620      	mov	r0, r4
   2fe6a:	f7ff fdcd 	bl	2fa08 <notify_connected>
   2fe6e:	e7c6      	b.n	2fdfe <bt_conn_set_state+0xaa>
		if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
   2fe70:	78a3      	ldrb	r3, [r4, #2]
   2fe72:	2b01      	cmp	r3, #1
   2fe74:	d121      	bne.n	2feba <bt_conn_set_state+0x166>
					K_MSEC(10 * bt_dev.create_param.timeout));
   2fe76:	4b22      	ldr	r3, [pc, #136]	; (2ff00 <bt_conn_set_state+0x1ac>)
   2fe78:	8a98      	ldrh	r0, [r3, #20]
			k_work_schedule(&conn->deferred_work,
   2fe7a:	3458      	adds	r4, #88	; 0x58
					K_MSEC(10 * bt_dev.create_param.timeout));
   2fe7c:	b1a8      	cbz	r0, 2feaa <bt_conn_set_state+0x156>
   2fe7e:	230a      	movs	r3, #10
   2fe80:	4358      	muls	r0, r3
   2fe82:	2100      	movs	r1, #0
			return ((t * to_hz + off) / from_hz);
   2fe84:	03c9      	lsls	r1, r1, #15
   2fe86:	ea41 4150 	orr.w	r1, r1, r0, lsr #17
   2fe8a:	f240 33e7 	movw	r3, #999	; 0x3e7
   2fe8e:	03c0      	lsls	r0, r0, #15
   2fe90:	18c0      	adds	r0, r0, r3
   2fe92:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   2fe96:	f04f 0300 	mov.w	r3, #0
   2fe9a:	f141 0100 	adc.w	r1, r1, #0
   2fe9e:	f7f6 f92f 	bl	26100 <__aeabi_uldivmod>
   2fea2:	4602      	mov	r2, r0
   2fea4:	460b      	mov	r3, r1
			k_work_schedule(&conn->deferred_work,
   2fea6:	4620      	mov	r0, r4
   2fea8:	e7a2      	b.n	2fdf0 <bt_conn_set_state+0x9c>
					K_MSEC(10 * bt_dev.create_param.timeout));
   2feaa:	4601      	mov	r1, r0
   2feac:	e7ea      	b.n	2fe84 <bt_conn_set_state+0x130>
	return list->head;
   2feae:	6961      	ldr	r1, [r4, #20]
 *
 * @return A pointer to the first node of the list (or NULL if empty)
 */
static inline sys_snode_t *sys_slist_get(sys_slist_t *list);

Z_GENLIST_GET(slist, snode)
   2feb0:	b921      	cbnz	r1, 2febc <bt_conn_set_state+0x168>
   2feb2:	f383 8811 	msr	BASEPRI, r3
   2feb6:	f3bf 8f6f 	isb	sy
}
   2feba:	bd70      	pop	{r4, r5, r6, pc}
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   2febc:	69a0      	ldr	r0, [r4, #24]
	return node->next;
   2febe:	680a      	ldr	r2, [r1, #0]
	list->head = node;
   2fec0:	6162      	str	r2, [r4, #20]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   2fec2:	4281      	cmp	r1, r0
	list->tail = node;
   2fec4:	bf08      	it	eq
   2fec6:	61a2      	streq	r2, [r4, #24]
   2fec8:	f383 8811 	msr	BASEPRI, r3
   2fecc:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
   2fed0:	f04f 0220 	mov.w	r2, #32
   2fed4:	f3ef 8311 	mrs	r3, BASEPRI
   2fed8:	f382 8812 	msr	BASEPRI_MAX, r2
   2fedc:	f3bf 8f6f 	isb	sy
		conn->pending_no_cb = tx->pending_no_cb;
   2fee0:	68ca      	ldr	r2, [r1, #12]
   2fee2:	61e2      	str	r2, [r4, #28]
		tx->pending_no_cb = 0U;
   2fee4:	60ce      	str	r6, [r1, #12]
	__asm__ volatile(
   2fee6:	f383 8811 	msr	BASEPRI, r3
   2feea:	f3bf 8f6f 	isb	sy
		conn_tx_destroy(conn, tx);
   2feee:	4620      	mov	r0, r4
   2fef0:	f7ff fdd8 	bl	2faa4 <conn_tx_destroy>
   2fef4:	e762      	b.n	2fdbc <bt_conn_set_state+0x68>
   2fef6:	bf00      	nop
   2fef8:	20000130 	.word	0x20000130
   2fefc:	20000694 	.word	0x20000694
   2ff00:	20000030 	.word	0x20000030

0002ff04 <bt_conn_index>:
		index = conn - acl_conns;
   2ff04:	4b03      	ldr	r3, [pc, #12]	; (2ff14 <bt_conn_index+0x10>)
   2ff06:	1ac0      	subs	r0, r0, r3
   2ff08:	4b03      	ldr	r3, [pc, #12]	; (2ff18 <bt_conn_index+0x14>)
   2ff0a:	1180      	asrs	r0, r0, #6
   2ff0c:	4358      	muls	r0, r3
}
   2ff0e:	b2c0      	uxtb	r0, r0
   2ff10:	4770      	bx	lr
   2ff12:	bf00      	nop
   2ff14:	20001828 	.word	0x20001828
   2ff18:	aaaaaaab 	.word	0xaaaaaaab

0002ff1c <bt_conn_create_pdu_timeout>:
{
   2ff1c:	b538      	push	{r3, r4, r5, lr}
   2ff1e:	460d      	mov	r5, r1
	return net_buf_alloc_fixed(pool, timeout);
   2ff20:	4906      	ldr	r1, [pc, #24]	; (2ff3c <bt_conn_create_pdu_timeout+0x20>)
   2ff22:	2800      	cmp	r0, #0
   2ff24:	bf08      	it	eq
   2ff26:	4608      	moveq	r0, r1
   2ff28:	f01e fedc 	bl	4ece4 <net_buf_alloc_fixed>
	if (!buf) {
   2ff2c:	4604      	mov	r4, r0
   2ff2e:	b118      	cbz	r0, 2ff38 <bt_conn_create_pdu_timeout+0x1c>
	net_buf_simple_reserve(&buf->b, reserve);
   2ff30:	1d29      	adds	r1, r5, #4
   2ff32:	3008      	adds	r0, #8
   2ff34:	f01e fefb 	bl	4ed2e <net_buf_simple_reserve>
}
   2ff38:	4620      	mov	r0, r4
   2ff3a:	bd38      	pop	{r3, r4, r5, pc}
   2ff3c:	200012e4 	.word	0x200012e4

0002ff40 <notify_le_param_updated>:
	}
}
#endif /* defined(CONFIG_BT_REMOTE_INFO) */

void notify_le_param_updated(struct bt_conn *conn)
{
   2ff40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct bt_conn_cb *cb;

	/* If new connection parameters meet requirement of pending
	 * parameters don't send peripheral conn param request anymore on timeout
	 */
	if (atomic_test_bit(conn->flags, BT_CONN_PERIPHERAL_PARAM_SET) &&
   2ff42:	1d03      	adds	r3, r0, #4
{
   2ff44:	4604      	mov	r4, r0
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
   2ff46:	4618      	mov	r0, r3
   2ff48:	f01b fe91 	bl	4bc6e <atomic_get>
	if (atomic_test_bit(conn->flags, BT_CONN_PERIPHERAL_PARAM_SET) &&
   2ff4c:	05c2      	lsls	r2, r0, #23
   2ff4e:	d512      	bpl.n	2ff76 <notify_le_param_updated+0x36>
	    conn->le.interval >= conn->le.interval_min &&
   2ff50:	f8b4 209e 	ldrh.w	r2, [r4, #158]	; 0x9e
	if (atomic_test_bit(conn->flags, BT_CONN_PERIPHERAL_PARAM_SET) &&
   2ff54:	f8b4 10a0 	ldrh.w	r1, [r4, #160]	; 0xa0
   2ff58:	4291      	cmp	r1, r2
   2ff5a:	d80c      	bhi.n	2ff76 <notify_le_param_updated+0x36>
	    conn->le.interval >= conn->le.interval_min &&
   2ff5c:	f8b4 10a2 	ldrh.w	r1, [r4, #162]	; 0xa2
   2ff60:	4291      	cmp	r1, r2
   2ff62:	d308      	bcc.n	2ff76 <notify_le_param_updated+0x36>
	    conn->le.interval <= conn->le.interval_max &&
	    conn->le.latency == conn->le.pending_latency &&
   2ff64:	e9d4 1229 	ldrd	r1, r2, [r4, #164]	; 0xa4
   2ff68:	4291      	cmp	r1, r2
   2ff6a:	d104      	bne.n	2ff76 <notify_le_param_updated+0x36>
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   2ff6c:	f46f 7180 	mvn.w	r1, #256	; 0x100
   2ff70:	4618      	mov	r0, r3
   2ff72:	f01b fe6d 	bl	4bc50 <atomic_and>
	    conn->le.timeout == conn->le.pending_timeout) {
		atomic_clear_bit(conn->flags, BT_CONN_PERIPHERAL_PARAM_SET);
	}

	for (cb = callback_list; cb; cb = cb->_next) {
   2ff76:	4b10      	ldr	r3, [pc, #64]	; (2ffb8 <notify_le_param_updated+0x78>)
   2ff78:	681d      	ldr	r5, [r3, #0]
   2ff7a:	b925      	cbnz	r5, 2ff86 <notify_le_param_updated+0x46>
					     conn->le.latency,
					     conn->le.timeout);
		}
	}

	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
   2ff7c:	4d0f      	ldr	r5, [pc, #60]	; (2ffbc <notify_le_param_updated+0x7c>)
   2ff7e:	4f10      	ldr	r7, [pc, #64]	; (2ffc0 <notify_le_param_updated+0x80>)
   2ff80:	42bd      	cmp	r5, r7
   2ff82:	d30c      	bcc.n	2ff9e <notify_le_param_updated+0x5e>
			cb->le_param_updated(conn, conn->le.interval,
					     conn->le.latency,
					     conn->le.timeout);
		}
	}
}
   2ff84:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (cb->le_param_updated) {
   2ff86:	68ee      	ldr	r6, [r5, #12]
   2ff88:	b13e      	cbz	r6, 2ff9a <notify_le_param_updated+0x5a>
			cb->le_param_updated(conn, conn->le.interval,
   2ff8a:	f8b4 30a6 	ldrh.w	r3, [r4, #166]	; 0xa6
   2ff8e:	f8b4 20a4 	ldrh.w	r2, [r4, #164]	; 0xa4
   2ff92:	f8b4 109e 	ldrh.w	r1, [r4, #158]	; 0x9e
   2ff96:	4620      	mov	r0, r4
   2ff98:	47b0      	blx	r6
	for (cb = callback_list; cb; cb = cb->_next) {
   2ff9a:	69ed      	ldr	r5, [r5, #28]
   2ff9c:	e7ed      	b.n	2ff7a <notify_le_param_updated+0x3a>
		if (cb->le_param_updated) {
   2ff9e:	68ee      	ldr	r6, [r5, #12]
   2ffa0:	b13e      	cbz	r6, 2ffb2 <notify_le_param_updated+0x72>
			cb->le_param_updated(conn, conn->le.interval,
   2ffa2:	f8b4 30a6 	ldrh.w	r3, [r4, #166]	; 0xa6
   2ffa6:	f8b4 20a4 	ldrh.w	r2, [r4, #164]	; 0xa4
   2ffaa:	f8b4 109e 	ldrh.w	r1, [r4, #158]	; 0x9e
   2ffae:	4620      	mov	r0, r4
   2ffb0:	47b0      	blx	r6
	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
   2ffb2:	3520      	adds	r5, #32
   2ffb4:	e7e4      	b.n	2ff80 <notify_le_param_updated+0x40>
   2ffb6:	bf00      	nop
   2ffb8:	20003c00 	.word	0x20003c00
   2ffbc:	00050c78 	.word	0x00050c78
   2ffc0:	00050c78 	.word	0x00050c78

0002ffc4 <notify_le_phy_updated>:
}
#endif

#if defined(CONFIG_BT_USER_PHY_UPDATE)
void notify_le_phy_updated(struct bt_conn *conn)
{
   2ffc4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct bt_conn_cb *cb;

	for (cb = callback_list; cb; cb = cb->_next) {
   2ffc6:	4b0d      	ldr	r3, [pc, #52]	; (2fffc <notify_le_phy_updated+0x38>)
   2ffc8:	681d      	ldr	r5, [r3, #0]
{
   2ffca:	4604      	mov	r4, r0
		if (cb->le_phy_updated) {
			cb->le_phy_updated(conn, &conn->le.phy);
   2ffcc:	f100 06b8 	add.w	r6, r0, #184	; 0xb8
	for (cb = callback_list; cb; cb = cb->_next) {
   2ffd0:	b935      	cbnz	r5, 2ffe0 <notify_le_phy_updated+0x1c>
		}
	}

	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
   2ffd2:	4d0b      	ldr	r5, [pc, #44]	; (30000 <notify_le_phy_updated+0x3c>)
   2ffd4:	4e0b      	ldr	r6, [pc, #44]	; (30004 <notify_le_phy_updated+0x40>)
		if (cb->le_phy_updated) {
			cb->le_phy_updated(conn, &conn->le.phy);
   2ffd6:	f104 07b8 	add.w	r7, r4, #184	; 0xb8
	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
   2ffda:	42b5      	cmp	r5, r6
   2ffdc:	d307      	bcc.n	2ffee <notify_le_phy_updated+0x2a>
		}
	}
}
   2ffde:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (cb->le_phy_updated) {
   2ffe0:	69ab      	ldr	r3, [r5, #24]
   2ffe2:	b113      	cbz	r3, 2ffea <notify_le_phy_updated+0x26>
			cb->le_phy_updated(conn, &conn->le.phy);
   2ffe4:	4631      	mov	r1, r6
   2ffe6:	4620      	mov	r0, r4
   2ffe8:	4798      	blx	r3
	for (cb = callback_list; cb; cb = cb->_next) {
   2ffea:	69ed      	ldr	r5, [r5, #28]
   2ffec:	e7f0      	b.n	2ffd0 <notify_le_phy_updated+0xc>
		if (cb->le_phy_updated) {
   2ffee:	69ab      	ldr	r3, [r5, #24]
   2fff0:	b113      	cbz	r3, 2fff8 <notify_le_phy_updated+0x34>
			cb->le_phy_updated(conn, &conn->le.phy);
   2fff2:	4639      	mov	r1, r7
   2fff4:	4620      	mov	r0, r4
   2fff6:	4798      	blx	r3
	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
   2fff8:	3520      	adds	r5, #32
   2fffa:	e7ee      	b.n	2ffda <notify_le_phy_updated+0x16>
   2fffc:	20003c00 	.word	0x20003c00
   30000:	00050c78 	.word	0x00050c78
   30004:	00050c78 	.word	0x00050c78

00030008 <le_param_req>:
#endif

bool le_param_req(struct bt_conn *conn, struct bt_le_conn_param *param)
{
   30008:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   3000c:	4607      	mov	r7, r0
	struct bt_conn_cb *cb;

	if (!bt_le_conn_params_valid(param)) {
   3000e:	4608      	mov	r0, r1
{
   30010:	460c      	mov	r4, r1
	if (!bt_le_conn_params_valid(param)) {
   30012:	f01b faee 	bl	4b5f2 <bt_le_conn_params_valid>
   30016:	4605      	mov	r5, r0
   30018:	b918      	cbnz	r0, 30022 <le_param_req+0x1a>
		return false;
   3001a:	2500      	movs	r5, #0
		}
	}

	/* Default to accepting if there's no app callback */
	return true;
}
   3001c:	4628      	mov	r0, r5
   3001e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	for (cb = callback_list; cb; cb = cb->_next) {
   30022:	4b13      	ldr	r3, [pc, #76]	; (30070 <le_param_req+0x68>)
   30024:	681e      	ldr	r6, [r3, #0]
   30026:	b946      	cbnz	r6, 3003a <le_param_req+0x32>
	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
   30028:	4e12      	ldr	r6, [pc, #72]	; (30074 <le_param_req+0x6c>)
   3002a:	f8df 804c 	ldr.w	r8, [pc, #76]	; 30078 <le_param_req+0x70>
   3002e:	4546      	cmp	r6, r8
   30030:	d2f4      	bcs.n	3001c <le_param_req+0x14>
		if (!cb->le_param_req) {
   30032:	68b3      	ldr	r3, [r6, #8]
   30034:	b983      	cbnz	r3, 30058 <le_param_req+0x50>
	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
   30036:	3620      	adds	r6, #32
   30038:	e7f9      	b.n	3002e <le_param_req+0x26>
		if (!cb->le_param_req) {
   3003a:	68b3      	ldr	r3, [r6, #8]
   3003c:	b90b      	cbnz	r3, 30042 <le_param_req+0x3a>
	for (cb = callback_list; cb; cb = cb->_next) {
   3003e:	69f6      	ldr	r6, [r6, #28]
   30040:	e7f1      	b.n	30026 <le_param_req+0x1e>
		if (!cb->le_param_req(conn, param)) {
   30042:	4621      	mov	r1, r4
   30044:	4638      	mov	r0, r7
   30046:	4798      	blx	r3
   30048:	2800      	cmp	r0, #0
   3004a:	d0e6      	beq.n	3001a <le_param_req+0x12>
		if (!bt_le_conn_params_valid(param)) {
   3004c:	4620      	mov	r0, r4
   3004e:	f01b fad0 	bl	4b5f2 <bt_le_conn_params_valid>
   30052:	2800      	cmp	r0, #0
   30054:	d1f3      	bne.n	3003e <le_param_req+0x36>
   30056:	e7e0      	b.n	3001a <le_param_req+0x12>
		if (!cb->le_param_req(conn, param)) {
   30058:	4621      	mov	r1, r4
   3005a:	4638      	mov	r0, r7
   3005c:	4798      	blx	r3
   3005e:	2800      	cmp	r0, #0
   30060:	d0db      	beq.n	3001a <le_param_req+0x12>
		if (!bt_le_conn_params_valid(param)) {
   30062:	4620      	mov	r0, r4
   30064:	f01b fac5 	bl	4b5f2 <bt_le_conn_params_valid>
   30068:	2800      	cmp	r0, #0
   3006a:	d1e4      	bne.n	30036 <le_param_req+0x2e>
   3006c:	e7d5      	b.n	3001a <le_param_req+0x12>
   3006e:	bf00      	nop
   30070:	20003c00 	.word	0x20003c00
   30074:	00050c78 	.word	0x00050c78
   30078:	00050c78 	.word	0x00050c78

0003007c <bt_conn_identity_resolved>:

#endif /* CONFIG_BT_BREDR */

#if defined(CONFIG_BT_SMP)
void bt_conn_identity_resolved(struct bt_conn *conn)
{
   3007c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	const bt_addr_le_t *rpa;
	struct bt_conn_cb *cb;

	if (conn->role == BT_HCI_ROLE_CENTRAL) {
   30080:	78c3      	ldrb	r3, [r0, #3]
{
   30082:	4604      	mov	r4, r0
	if (conn->role == BT_HCI_ROLE_CENTRAL) {
   30084:	b973      	cbnz	r3, 300a4 <bt_conn_identity_resolved+0x28>
		rpa = &conn->le.resp_addr;
   30086:	f100 0696 	add.w	r6, r0, #150	; 0x96
	} else {
		rpa = &conn->le.init_addr;
	}

	for (cb = callback_list; cb; cb = cb->_next) {
   3008a:	4b10      	ldr	r3, [pc, #64]	; (300cc <bt_conn_identity_resolved+0x50>)
   3008c:	681d      	ldr	r5, [r3, #0]
		if (cb->identity_resolved) {
			cb->identity_resolved(conn, rpa, &conn->le.dst);
   3008e:	f104 0788 	add.w	r7, r4, #136	; 0x88
	for (cb = callback_list; cb; cb = cb->_next) {
   30092:	b955      	cbnz	r5, 300aa <bt_conn_identity_resolved+0x2e>
		}
	}

	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
   30094:	4d0e      	ldr	r5, [pc, #56]	; (300d0 <bt_conn_identity_resolved+0x54>)
   30096:	4f0f      	ldr	r7, [pc, #60]	; (300d4 <bt_conn_identity_resolved+0x58>)
		if (cb->identity_resolved) {
			cb->identity_resolved(conn, rpa, &conn->le.dst);
   30098:	f104 0888 	add.w	r8, r4, #136	; 0x88
	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
   3009c:	42bd      	cmp	r5, r7
   3009e:	d30c      	bcc.n	300ba <bt_conn_identity_resolved+0x3e>
		}
	}
}
   300a0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		rpa = &conn->le.init_addr;
   300a4:	f100 068f 	add.w	r6, r0, #143	; 0x8f
   300a8:	e7ef      	b.n	3008a <bt_conn_identity_resolved+0xe>
		if (cb->identity_resolved) {
   300aa:	692b      	ldr	r3, [r5, #16]
   300ac:	b11b      	cbz	r3, 300b6 <bt_conn_identity_resolved+0x3a>
			cb->identity_resolved(conn, rpa, &conn->le.dst);
   300ae:	463a      	mov	r2, r7
   300b0:	4631      	mov	r1, r6
   300b2:	4620      	mov	r0, r4
   300b4:	4798      	blx	r3
	for (cb = callback_list; cb; cb = cb->_next) {
   300b6:	69ed      	ldr	r5, [r5, #28]
   300b8:	e7eb      	b.n	30092 <bt_conn_identity_resolved+0x16>
		if (cb->identity_resolved) {
   300ba:	692b      	ldr	r3, [r5, #16]
   300bc:	b11b      	cbz	r3, 300c6 <bt_conn_identity_resolved+0x4a>
			cb->identity_resolved(conn, rpa, &conn->le.dst);
   300be:	4642      	mov	r2, r8
   300c0:	4631      	mov	r1, r6
   300c2:	4620      	mov	r0, r4
   300c4:	4798      	blx	r3
	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
   300c6:	3520      	adds	r5, #32
   300c8:	e7e8      	b.n	3009c <bt_conn_identity_resolved+0x20>
   300ca:	bf00      	nop
   300cc:	20003c00 	.word	0x20003c00
   300d0:	00050c78 	.word	0x00050c78
   300d4:	00050c78 	.word	0x00050c78

000300d8 <bt_conn_security_changed>:
	conn->required_sec_level = conn->sec_level;
}

void bt_conn_security_changed(struct bt_conn *conn, uint8_t hci_err,
			      enum bt_security_err err)
{
   300d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	conn->required_sec_level = conn->sec_level;
   300da:	7a43      	ldrb	r3, [r0, #9]
   300dc:	7283      	strb	r3, [r0, #10]
{
   300de:	4604      	mov	r4, r0
   300e0:	4616      	mov	r6, r2
	struct bt_conn_cb *cb;

	reset_pairing(conn);
	bt_l2cap_security_changed(conn, hci_err);
   300e2:	f01b ffef 	bl	4c0c4 <bt_l2cap_security_changed>
	if (IS_ENABLED(CONFIG_BT_ISO_CENTRAL)) {
		bt_iso_security_changed(conn, hci_err);
	}

	for (cb = callback_list; cb; cb = cb->_next) {
   300e6:	4b0c      	ldr	r3, [pc, #48]	; (30118 <bt_conn_security_changed+0x40>)
   300e8:	681d      	ldr	r5, [r3, #0]
   300ea:	b925      	cbnz	r5, 300f6 <bt_conn_security_changed+0x1e>
		if (cb->security_changed) {
			cb->security_changed(conn, conn->sec_level, err);
		}
	}

	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
   300ec:	4d0b      	ldr	r5, [pc, #44]	; (3011c <bt_conn_security_changed+0x44>)
   300ee:	4f0c      	ldr	r7, [pc, #48]	; (30120 <bt_conn_security_changed+0x48>)
   300f0:	42bd      	cmp	r5, r7
   300f2:	d308      	bcc.n	30106 <bt_conn_security_changed+0x2e>
		}
#endif /* CONFIG_BT_BREDR */

	}
#endif
}
   300f4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (cb->security_changed) {
   300f6:	696b      	ldr	r3, [r5, #20]
   300f8:	b11b      	cbz	r3, 30102 <bt_conn_security_changed+0x2a>
			cb->security_changed(conn, conn->sec_level, err);
   300fa:	7a61      	ldrb	r1, [r4, #9]
   300fc:	4632      	mov	r2, r6
   300fe:	4620      	mov	r0, r4
   30100:	4798      	blx	r3
	for (cb = callback_list; cb; cb = cb->_next) {
   30102:	69ed      	ldr	r5, [r5, #28]
   30104:	e7f1      	b.n	300ea <bt_conn_security_changed+0x12>
		if (cb->security_changed) {
   30106:	696b      	ldr	r3, [r5, #20]
   30108:	b11b      	cbz	r3, 30112 <bt_conn_security_changed+0x3a>
			cb->security_changed(conn, conn->sec_level, err);
   3010a:	7a61      	ldrb	r1, [r4, #9]
   3010c:	4632      	mov	r2, r6
   3010e:	4620      	mov	r0, r4
   30110:	4798      	blx	r3
	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
   30112:	3520      	adds	r5, #32
   30114:	e7ec      	b.n	300f0 <bt_conn_security_changed+0x18>
   30116:	bf00      	nop
   30118:	20003c00 	.word	0x20003c00
   3011c:	00050c78 	.word	0x00050c78
   30120:	00050c78 	.word	0x00050c78

00030124 <bt_conn_cb_register>:
}
#endif /* CONFIG_BT_SMP */

void bt_conn_cb_register(struct bt_conn_cb *cb)
{
	cb->_next = callback_list;
   30124:	4b02      	ldr	r3, [pc, #8]	; (30130 <bt_conn_cb_register+0xc>)
   30126:	681a      	ldr	r2, [r3, #0]
   30128:	61c2      	str	r2, [r0, #28]
	callback_list = cb;
   3012a:	6018      	str	r0, [r3, #0]
}
   3012c:	4770      	bx	lr
   3012e:	bf00      	nop
   30130:	20003c00 	.word	0x20003c00

00030134 <bt_conn_add_le>:

	return false;
}

struct bt_conn *bt_conn_add_le(uint8_t id, const bt_addr_le_t *peer)
{
   30134:	b570      	push	{r4, r5, r6, lr}
   30136:	4606      	mov	r6, r0
   30138:	460d      	mov	r5, r1
	return bt_conn_new(acl_conns, ARRAY_SIZE(acl_conns));
   3013a:	480a      	ldr	r0, [pc, #40]	; (30164 <bt_conn_add_le+0x30>)
   3013c:	2106      	movs	r1, #6
   3013e:	f7ff fd53 	bl	2fbe8 <bt_conn_new>
	struct bt_conn *conn = acl_conn_new();

	if (!conn) {
   30142:	4604      	mov	r4, r0
   30144:	b160      	cbz	r0, 30160 <bt_conn_add_le+0x2c>
		return NULL;
	}

	conn->id = id;
   30146:	7206      	strb	r6, [r0, #8]
   30148:	2207      	movs	r2, #7
   3014a:	4629      	mov	r1, r5
   3014c:	3088      	adds	r0, #136	; 0x88
   3014e:	f01a fe94 	bl	4ae7a <memcpy>
	bt_addr_le_copy(&conn->le.dst, peer);
#if defined(CONFIG_BT_SMP)
	conn->sec_level = BT_SECURITY_L1;
   30152:	2301      	movs	r3, #1
   30154:	7263      	strb	r3, [r4, #9]
	conn->required_sec_level = BT_SECURITY_L1;
   30156:	72a3      	strb	r3, [r4, #10]
#endif /* CONFIG_BT_SMP */
	conn->type = BT_CONN_TYPE_LE;
   30158:	70a3      	strb	r3, [r4, #2]
	conn->le.interval_min = BT_GAP_INIT_CONN_INT_MIN;
   3015a:	4b03      	ldr	r3, [pc, #12]	; (30168 <bt_conn_add_le+0x34>)
   3015c:	f8c4 30a0 	str.w	r3, [r4, #160]	; 0xa0
	conn->le.interval_max = BT_GAP_INIT_CONN_INT_MAX;

	return conn;
}
   30160:	4620      	mov	r0, r4
   30162:	bd70      	pop	{r4, r5, r6, pc}
   30164:	20001828 	.word	0x20001828
   30168:	00280018 	.word	0x00280018

0003016c <bt_conn_lookup_addr_le>:

	return bt_addr_le_cmp(peer, &conn->le.init_addr) == 0;
}

struct bt_conn *bt_conn_lookup_addr_le(uint8_t id, const bt_addr_le_t *peer)
{
   3016c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   30170:	4e0f      	ldr	r6, [pc, #60]	; (301b0 <bt_conn_lookup_addr_le+0x44>)
   30172:	4607      	mov	r7, r0
   30174:	4688      	mov	r8, r1
	int i;

	for (i = 0; i < ARRAY_SIZE(acl_conns); i++) {
   30176:	2500      	movs	r5, #0
		struct bt_conn *conn = bt_conn_ref(&acl_conns[i]);
   30178:	4630      	mov	r0, r6
   3017a:	f01b fe09 	bl	4bd90 <bt_conn_ref>

		if (!conn) {
   3017e:	4604      	mov	r4, r0
   30180:	b120      	cbz	r0, 3018c <bt_conn_lookup_addr_le+0x20>
			continue;
		}

		if (conn->type != BT_CONN_TYPE_LE) {
   30182:	7883      	ldrb	r3, [r0, #2]
   30184:	2b01      	cmp	r3, #1
   30186:	d00a      	beq.n	3019e <bt_conn_lookup_addr_le+0x32>
			bt_conn_unref(conn);
			continue;
		}

		if (!bt_conn_is_peer_addr_le(conn, id, peer)) {
			bt_conn_unref(conn);
   30188:	f01b fe1d 	bl	4bdc6 <bt_conn_unref>
	for (i = 0; i < ARRAY_SIZE(acl_conns); i++) {
   3018c:	3501      	adds	r5, #1
   3018e:	2d06      	cmp	r5, #6
   30190:	f106 06c0 	add.w	r6, r6, #192	; 0xc0
   30194:	d1f0      	bne.n	30178 <bt_conn_lookup_addr_le+0xc>
		}

		return conn;
	}

	return NULL;
   30196:	2400      	movs	r4, #0
}
   30198:	4620      	mov	r0, r4
   3019a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (!bt_conn_is_peer_addr_le(conn, id, peer)) {
   3019e:	4642      	mov	r2, r8
   301a0:	4639      	mov	r1, r7
   301a2:	f01b fec1 	bl	4bf28 <bt_conn_is_peer_addr_le>
   301a6:	2800      	cmp	r0, #0
   301a8:	d1f6      	bne.n	30198 <bt_conn_lookup_addr_le+0x2c>
			bt_conn_unref(conn);
   301aa:	4620      	mov	r0, r4
   301ac:	e7ec      	b.n	30188 <bt_conn_lookup_addr_le+0x1c>
   301ae:	bf00      	nop
   301b0:	20001828 	.word	0x20001828

000301b4 <bt_conn_lookup_state_le>:

struct bt_conn *bt_conn_lookup_state_le(uint8_t id, const bt_addr_le_t *peer,
					const bt_conn_state_t state)
{
   301b4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	int i;

	for (i = 0; i < ARRAY_SIZE(acl_conns); i++) {
		struct bt_conn *conn = bt_conn_ref(&acl_conns[i]);
   301b8:	f8df a050 	ldr.w	sl, [pc, #80]	; 3020c <bt_conn_lookup_state_le+0x58>
{
   301bc:	4606      	mov	r6, r0
   301be:	460f      	mov	r7, r1
   301c0:	4690      	mov	r8, r2
	for (i = 0; i < ARRAY_SIZE(acl_conns); i++) {
   301c2:	2500      	movs	r5, #0
		struct bt_conn *conn = bt_conn_ref(&acl_conns[i]);
   301c4:	f04f 09c0 	mov.w	r9, #192	; 0xc0
   301c8:	fb09 a005 	mla	r0, r9, r5, sl
   301cc:	f01b fde0 	bl	4bd90 <bt_conn_ref>

		if (!conn) {
   301d0:	4604      	mov	r4, r0
   301d2:	b120      	cbz	r0, 301de <bt_conn_lookup_state_le+0x2a>
			continue;
		}

		if (conn->type != BT_CONN_TYPE_LE) {
   301d4:	7883      	ldrb	r3, [r0, #2]
   301d6:	2b01      	cmp	r3, #1
   301d8:	d006      	beq.n	301e8 <bt_conn_lookup_state_le+0x34>
			bt_conn_unref(conn);
			continue;
		}

		if (!(conn->state == state && conn->id == id)) {
			bt_conn_unref(conn);
   301da:	f01b fdf4 	bl	4bdc6 <bt_conn_unref>
	for (i = 0; i < ARRAY_SIZE(acl_conns); i++) {
   301de:	3501      	adds	r5, #1
   301e0:	2d06      	cmp	r5, #6
   301e2:	d1f1      	bne.n	301c8 <bt_conn_lookup_state_le+0x14>
		}

		return conn;
	}

	return NULL;
   301e4:	2400      	movs	r4, #0
   301e6:	e00d      	b.n	30204 <bt_conn_lookup_state_le+0x50>
		if (peer && !bt_conn_is_peer_addr_le(conn, id, peer)) {
   301e8:	b137      	cbz	r7, 301f8 <bt_conn_lookup_state_le+0x44>
   301ea:	463a      	mov	r2, r7
   301ec:	4631      	mov	r1, r6
   301ee:	f01b fe9b 	bl	4bf28 <bt_conn_is_peer_addr_le>
   301f2:	b908      	cbnz	r0, 301f8 <bt_conn_lookup_state_le+0x44>
			bt_conn_unref(conn);
   301f4:	4620      	mov	r0, r4
   301f6:	e7f0      	b.n	301da <bt_conn_lookup_state_le+0x26>
		if (!(conn->state == state && conn->id == id)) {
   301f8:	7b63      	ldrb	r3, [r4, #13]
   301fa:	4543      	cmp	r3, r8
   301fc:	d1fa      	bne.n	301f4 <bt_conn_lookup_state_le+0x40>
   301fe:	7a23      	ldrb	r3, [r4, #8]
   30200:	42b3      	cmp	r3, r6
   30202:	d1f7      	bne.n	301f4 <bt_conn_lookup_state_le+0x40>
}
   30204:	4620      	mov	r0, r4
   30206:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   3020a:	bf00      	nop
   3020c:	20001828 	.word	0x20001828

00030210 <bt_conn_get_info>:
		return 0;
	}
}

int bt_conn_get_info(const struct bt_conn *conn, struct bt_conn_info *info)
{
   30210:	b510      	push	{r4, lr}
	info->type = conn->type;
   30212:	7883      	ldrb	r3, [r0, #2]
   30214:	700b      	strb	r3, [r1, #0]
	info->role = conn->role;
   30216:	78c3      	ldrb	r3, [r0, #3]
   30218:	704b      	strb	r3, [r1, #1]
	info->id = conn->id;
   3021a:	7a03      	ldrb	r3, [r0, #8]
   3021c:	708b      	strb	r3, [r1, #2]
	switch (state) {
   3021e:	7b43      	ldrb	r3, [r0, #13]
   30220:	3b02      	subs	r3, #2
   30222:	b2db      	uxtb	r3, r3
   30224:	2b06      	cmp	r3, #6
   30226:	bf98      	it	ls
   30228:	4c28      	ldrls	r4, [pc, #160]	; (302cc <bt_conn_get_info+0xbc>)
{
   3022a:	4602      	mov	r2, r0
   3022c:	f04f 0000 	mov.w	r0, #0
	info->state = conn_internal_to_public_state(conn->state);
   30230:	bf8c      	ite	hi
   30232:	4603      	movhi	r3, r0
   30234:	5ce3      	ldrbls	r3, [r4, r3]
	info->security.flags = 0;
   30236:	f881 0023 	strb.w	r0, [r1, #35]	; 0x23
	info->state = conn_internal_to_public_state(conn->state);
   3023a:	f881 3020 	strb.w	r3, [r1, #32]
	return conn->sec_level;
   3023e:	7a53      	ldrb	r3, [r2, #9]
	info->security.level = bt_conn_get_security(conn);
   30240:	f881 3021 	strb.w	r3, [r1, #33]	; 0x21
#if defined(CONFIG_BT_SMP) || defined(CONFIG_BT_BREDR)
	info->security.enc_key_size = bt_conn_enc_key_size(conn);
   30244:	4610      	mov	r0, r2
   30246:	f01b fe3d 	bl	4bec4 <bt_conn_enc_key_size>
   3024a:	f881 0022 	strb.w	r0, [r1, #34]	; 0x22
#else
	info->security.enc_key_size = 0;
#endif /* CONFIG_BT_SMP || CONFIG_BT_BREDR */

	switch (conn->type) {
   3024e:	7893      	ldrb	r3, [r2, #2]
   30250:	2b01      	cmp	r3, #1
   30252:	d137      	bne.n	302c4 <bt_conn_get_info+0xb4>
	case BT_CONN_TYPE_LE:
		info->le.dst = &conn->le.dst;
   30254:	f102 0388 	add.w	r3, r2, #136	; 0x88
   30258:	608b      	str	r3, [r1, #8]
		info->le.src = &bt_dev.id_addr[conn->id];
   3025a:	7a13      	ldrb	r3, [r2, #8]
   3025c:	481c      	ldr	r0, [pc, #112]	; (302d0 <bt_conn_get_info+0xc0>)
   3025e:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
   30262:	4403      	add	r3, r0
   30264:	604b      	str	r3, [r1, #4]
		if (conn->role == BT_HCI_ROLE_CENTRAL) {
   30266:	78d4      	ldrb	r4, [r2, #3]
			info->le.local = &conn->le.init_addr;
			info->le.remote = &conn->le.resp_addr;
   30268:	f102 0396 	add.w	r3, r2, #150	; 0x96
			info->le.local = &conn->le.init_addr;
   3026c:	f102 008f 	add.w	r0, r2, #143	; 0x8f
		if (conn->role == BT_HCI_ROLE_CENTRAL) {
   30270:	b114      	cbz	r4, 30278 <bt_conn_get_info+0x68>
   30272:	461c      	mov	r4, r3
   30274:	4603      	mov	r3, r0
   30276:	4620      	mov	r0, r4
			info->le.remote = &conn->le.resp_addr;
   30278:	e9c1 0303 	strd	r0, r3, [r1, #12]
		} else {
			info->le.local = &conn->le.resp_addr;
			info->le.remote = &conn->le.init_addr;
		}
		info->le.interval = conn->le.interval;
   3027c:	f8b2 309e 	ldrh.w	r3, [r2, #158]	; 0x9e
   30280:	828b      	strh	r3, [r1, #20]
		info->le.latency = conn->le.latency;
   30282:	f8b2 30a4 	ldrh.w	r3, [r2, #164]	; 0xa4
   30286:	82cb      	strh	r3, [r1, #22]
		info->le.timeout = conn->le.timeout;
   30288:	f8b2 30a6 	ldrh.w	r3, [r2, #166]	; 0xa6
   3028c:	830b      	strh	r3, [r1, #24]
#if defined(CONFIG_BT_USER_PHY_UPDATE)
		info->le.phy = &conn->le.phy;
   3028e:	f102 03b8 	add.w	r3, r2, #184	; 0xb8
   30292:	61cb      	str	r3, [r1, #28]
#endif
#if defined(CONFIG_BT_USER_DATA_LEN_UPDATE)
		info->le.data_len = &conn->le.data_len;
#endif
		if (conn->le.keys && (conn->le.keys->flags & BT_KEYS_SC)) {
   30294:	f8d2 30b4 	ldr.w	r3, [r2, #180]	; 0xb4
   30298:	b12b      	cbz	r3, 302a6 <bt_conn_get_info+0x96>
   3029a:	7b5b      	ldrb	r3, [r3, #13]
   3029c:	06d8      	lsls	r0, r3, #27
			info->security.flags |= BT_SECURITY_FLAG_SC;
   3029e:	bf44      	itt	mi
   302a0:	2301      	movmi	r3, #1
   302a2:	f881 3023 	strbmi.w	r3, [r1, #35]	; 0x23
		}
		if (conn->le.keys && (conn->le.keys->flags & BT_KEYS_OOB)) {
   302a6:	f8d2 30b4 	ldr.w	r3, [r2, #180]	; 0xb4
   302aa:	b113      	cbz	r3, 302b2 <bt_conn_get_info+0xa2>
   302ac:	7b5b      	ldrb	r3, [r3, #13]
   302ae:	069b      	lsls	r3, r3, #26
   302b0:	d401      	bmi.n	302b6 <bt_conn_get_info+0xa6>
			info->security.flags |= BT_SECURITY_FLAG_OOB;
		}
		return 0;
   302b2:	2000      	movs	r0, #0
		return 0;
#endif
	}

	return -EINVAL;
}
   302b4:	bd10      	pop	{r4, pc}
			info->security.flags |= BT_SECURITY_FLAG_OOB;
   302b6:	f891 3023 	ldrb.w	r3, [r1, #35]	; 0x23
   302ba:	f043 0302 	orr.w	r3, r3, #2
   302be:	f881 3023 	strb.w	r3, [r1, #35]	; 0x23
   302c2:	e7f6      	b.n	302b2 <bt_conn_get_info+0xa2>
	return -EINVAL;
   302c4:	f06f 0015 	mvn.w	r0, #21
   302c8:	e7f4      	b.n	302b4 <bt_conn_get_info+0xa4>
   302ca:	bf00      	nop
   302cc:	0005377a 	.word	0x0005377a
   302d0:	20000030 	.word	0x20000030

000302d4 <bt_conn_le_create>:

int bt_conn_le_create(const bt_addr_le_t *peer,
		      const struct bt_conn_le_create_param *create_param,
		      const struct bt_le_conn_param *conn_param,
		      struct bt_conn **ret_conn)
{
   302d4:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   302d8:	4604      	mov	r4, r0
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
   302da:	4844      	ldr	r0, [pc, #272]	; (303ec <bt_conn_le_create+0x118>)
   302dc:	f01b fcc7 	bl	4bc6e <atomic_get>
   302e0:	460e      	mov	r6, r1
	struct bt_conn *conn;
	bt_addr_le_t dst;
	int err;

	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
   302e2:	0741      	lsls	r1, r0, #29
{
   302e4:	4615      	mov	r5, r2
   302e6:	461f      	mov	r7, r3
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
   302e8:	d405      	bmi.n	302f6 <bt_conn_le_create+0x22>
		return -EAGAIN;
   302ea:	f06f 050a 	mvn.w	r5, #10
		return err;
	}

	*ret_conn = conn;
	return 0;
}
   302ee:	4628      	mov	r0, r5
   302f0:	b002      	add	sp, #8
   302f2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (!bt_le_conn_params_valid(conn_param)) {
   302f6:	4610      	mov	r0, r2
   302f8:	f01b f97b 	bl	4b5f2 <bt_le_conn_params_valid>
   302fc:	b910      	cbnz	r0, 30304 <bt_conn_le_create+0x30>
		return -EINVAL;
   302fe:	f06f 0515 	mvn.w	r5, #21
   30302:	e7f4      	b.n	302ee <bt_conn_le_create+0x1a>
   30304:	4839      	ldr	r0, [pc, #228]	; (303ec <bt_conn_le_create+0x118>)
   30306:	f01b fcb2 	bl	4bc6e <atomic_get>
	if (atomic_test_bit(bt_dev.flags, BT_DEV_EXPLICIT_SCAN)) {
   3030a:	0602      	lsls	r2, r0, #24
   3030c:	d4ed      	bmi.n	302ea <bt_conn_le_create+0x16>
   3030e:	4837      	ldr	r0, [pc, #220]	; (303ec <bt_conn_le_create+0x118>)
   30310:	f01b fcad 	bl	4bc6e <atomic_get>
	if (atomic_test_bit(bt_dev.flags, BT_DEV_INITIATING)) {
   30314:	04c3      	lsls	r3, r0, #19
   30316:	f3c0 3800 	ubfx	r8, r0, #12, #1
   3031a:	d460      	bmi.n	303de <bt_conn_le_create+0x10a>
	if (!bt_id_scan_random_addr_check()) {
   3031c:	f01b fb04 	bl	4b928 <bt_id_scan_random_addr_check>
   30320:	2800      	cmp	r0, #0
   30322:	d0ec      	beq.n	302fe <bt_conn_le_create+0x2a>
	if (bt_conn_exists_le(BT_ID_DEFAULT, peer)) {
   30324:	4621      	mov	r1, r4
   30326:	4640      	mov	r0, r8
   30328:	f01b fe1e 	bl	4bf68 <bt_conn_exists_le>
   3032c:	2800      	cmp	r0, #0
   3032e:	d1e6      	bne.n	302fe <bt_conn_le_create+0x2a>
	if (peer->type == BT_ADDR_LE_PUBLIC_ID ||
   30330:	7823      	ldrb	r3, [r4, #0]
   30332:	3b02      	subs	r3, #2
   30334:	2b01      	cmp	r3, #1
   30336:	d847      	bhi.n	303c8 <bt_conn_le_create+0xf4>
   30338:	2207      	movs	r2, #7
   3033a:	4621      	mov	r1, r4
   3033c:	4668      	mov	r0, sp
   3033e:	f01a fd9c 	bl	4ae7a <memcpy>
		dst.type -= BT_ADDR_LE_PUBLIC_ID;
   30342:	f89d 3000 	ldrb.w	r3, [sp]
   30346:	3b02      	subs	r3, #2
   30348:	f88d 3000 	strb.w	r3, [sp]
	conn = bt_conn_add_le(BT_ID_DEFAULT, &dst);
   3034c:	4669      	mov	r1, sp
   3034e:	2000      	movs	r0, #0
   30350:	f7ff fef0 	bl	30134 <bt_conn_add_le>
	if (!conn) {
   30354:	4604      	mov	r4, r0
   30356:	2800      	cmp	r0, #0
   30358:	d044      	beq.n	303e4 <bt_conn_le_create+0x110>
	conn->le.interval_min = param->interval_min;
   3035a:	882b      	ldrh	r3, [r5, #0]
   3035c:	f8a0 30a0 	strh.w	r3, [r0, #160]	; 0xa0
	conn->le.interval_max = param->interval_max;
   30360:	886b      	ldrh	r3, [r5, #2]
   30362:	f8a0 30a2 	strh.w	r3, [r0, #162]	; 0xa2
	conn->le.latency = param->latency;
   30366:	88ab      	ldrh	r3, [r5, #4]
   30368:	f8a0 30a4 	strh.w	r3, [r0, #164]	; 0xa4
	conn->le.timeout = param->timeout;
   3036c:	88eb      	ldrh	r3, [r5, #6]
   3036e:	f8a0 30a6 	strh.w	r3, [r0, #166]	; 0xa6
	bt_dev.create_param = *param;
   30372:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
   30376:	4d1e      	ldr	r5, [pc, #120]	; (303f0 <bt_conn_le_create+0x11c>)
   30378:	f105 0c08 	add.w	ip, r5, #8
   3037c:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
		(bt_dev.create_param.timeout != 0) ?
   30380:	8aab      	ldrh	r3, [r5, #20]
	bt_dev.create_param.timeout =
   30382:	2b00      	cmp	r3, #0
   30384:	bf08      	it	eq
   30386:	f44f 7396 	moveq.w	r3, #300	; 0x12c
   3038a:	82ab      	strh	r3, [r5, #20]
		(bt_dev.create_param.interval_coded != 0) ?
   3038c:	8a2b      	ldrh	r3, [r5, #16]
	bt_dev.create_param.interval_coded =
   3038e:	b903      	cbnz	r3, 30392 <bt_conn_le_create+0xbe>
   30390:	89ab      	ldrh	r3, [r5, #12]
   30392:	822b      	strh	r3, [r5, #16]
		(bt_dev.create_param.window_coded != 0) ?
   30394:	8a6b      	ldrh	r3, [r5, #18]
	bt_dev.create_param.window_coded =
   30396:	b903      	cbnz	r3, 3039a <bt_conn_le_create+0xc6>
   30398:	89eb      	ldrh	r3, [r5, #14]
   3039a:	826b      	strh	r3, [r5, #18]
	bt_conn_set_state(conn, BT_CONN_CONNECTING);
   3039c:	2106      	movs	r1, #6
   3039e:	4620      	mov	r0, r4
   303a0:	f7ff fcd8 	bl	2fd54 <bt_conn_set_state>
	err = bt_le_create_conn(conn);
   303a4:	4620      	mov	r0, r4
   303a6:	f7fd fe55 	bl	2e054 <bt_le_create_conn>
	if (err) {
   303aa:	4605      	mov	r5, r0
   303ac:	b1a8      	cbz	r0, 303da <bt_conn_le_create+0x106>
		conn->err = 0;
   303ae:	2600      	movs	r6, #0
		bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
   303b0:	4631      	mov	r1, r6
   303b2:	4620      	mov	r0, r4
		conn->err = 0;
   303b4:	7326      	strb	r6, [r4, #12]
		bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
   303b6:	f7ff fccd 	bl	2fd54 <bt_conn_set_state>
		bt_conn_unref(conn);
   303ba:	4620      	mov	r0, r4
   303bc:	f01b fd03 	bl	4bdc6 <bt_conn_unref>
		bt_le_scan_update(false);
   303c0:	4630      	mov	r0, r6
   303c2:	f7ff f83d 	bl	2f440 <bt_le_scan_update>
		return err;
   303c6:	e792      	b.n	302ee <bt_conn_le_create+0x1a>
		bt_addr_le_copy(&dst, bt_lookup_id_addr(BT_ID_DEFAULT, peer));
   303c8:	4621      	mov	r1, r4
   303ca:	f01b fa93 	bl	4b8f4 <bt_lookup_id_addr>
   303ce:	2207      	movs	r2, #7
   303d0:	4601      	mov	r1, r0
   303d2:	4668      	mov	r0, sp
   303d4:	f01a fd51 	bl	4ae7a <memcpy>
}
   303d8:	e7b8      	b.n	3034c <bt_conn_le_create+0x78>
	*ret_conn = conn;
   303da:	603c      	str	r4, [r7, #0]
	return 0;
   303dc:	e787      	b.n	302ee <bt_conn_le_create+0x1a>
		return -EALREADY;
   303de:	f06f 0577 	mvn.w	r5, #119	; 0x77
   303e2:	e784      	b.n	302ee <bt_conn_le_create+0x1a>
		return -ENOMEM;
   303e4:	f06f 050b 	mvn.w	r5, #11
   303e8:	e781      	b.n	302ee <bt_conn_le_create+0x1a>
   303ea:	bf00      	nop
   303ec:	200000fc 	.word	0x200000fc
   303f0:	20000030 	.word	0x20000030

000303f4 <bt_le_set_auto_conn>:

#if !defined(CONFIG_BT_FILTER_ACCEPT_LIST)
int bt_le_set_auto_conn(const bt_addr_le_t *addr,
			const struct bt_le_conn_param *param)
{
   303f4:	b570      	push	{r4, r5, r6, lr}
   303f6:	4606      	mov	r6, r0
   303f8:	482f      	ldr	r0, [pc, #188]	; (304b8 <bt_le_set_auto_conn+0xc4>)
   303fa:	f01b fc38 	bl	4bc6e <atomic_get>
	struct bt_conn *conn;

	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
   303fe:	0740      	lsls	r0, r0, #29
{
   30400:	460d      	mov	r5, r1
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
   30402:	d553      	bpl.n	304ac <bt_le_set_auto_conn+0xb8>
		return -EAGAIN;
	}

	if (param && !bt_le_conn_params_valid(param)) {
   30404:	b929      	cbnz	r1, 30412 <bt_le_set_auto_conn+0x1e>
		return -EINVAL;
	}

	if (!bt_id_scan_random_addr_check()) {
   30406:	f01b fa8f 	bl	4b928 <bt_id_scan_random_addr_check>
   3040a:	b940      	cbnz	r0, 3041e <bt_le_set_auto_conn+0x2a>
		return -EINVAL;
   3040c:	f06f 0015 	mvn.w	r0, #21
	}

	bt_conn_unref(conn);

	return 0;
}
   30410:	bd70      	pop	{r4, r5, r6, pc}
	if (param && !bt_le_conn_params_valid(param)) {
   30412:	4608      	mov	r0, r1
   30414:	f01b f8ed 	bl	4b5f2 <bt_le_conn_params_valid>
   30418:	2800      	cmp	r0, #0
   3041a:	d1f4      	bne.n	30406 <bt_le_set_auto_conn+0x12>
   3041c:	e7f6      	b.n	3040c <bt_le_set_auto_conn+0x18>
	conn = bt_conn_lookup_addr_le(BT_ID_DEFAULT, addr);
   3041e:	4631      	mov	r1, r6
   30420:	2000      	movs	r0, #0
   30422:	f7ff fea3 	bl	3016c <bt_conn_lookup_addr_le>
	if (!conn) {
   30426:	4604      	mov	r4, r0
   30428:	b928      	cbnz	r0, 30436 <bt_le_set_auto_conn+0x42>
		conn = bt_conn_add_le(BT_ID_DEFAULT, addr);
   3042a:	4631      	mov	r1, r6
   3042c:	f7ff fe82 	bl	30134 <bt_conn_add_le>
		if (!conn) {
   30430:	4604      	mov	r4, r0
   30432:	2800      	cmp	r0, #0
   30434:	d03d      	beq.n	304b2 <bt_le_set_auto_conn+0xbe>
		if (!atomic_test_and_set_bit(conn->flags,
   30436:	1d20      	adds	r0, r4, #4
	if (param) {
   30438:	b33d      	cbz	r5, 3048a <bt_le_set_auto_conn+0x96>
	conn->le.interval_min = param->interval_min;
   3043a:	882b      	ldrh	r3, [r5, #0]
   3043c:	f8a4 30a0 	strh.w	r3, [r4, #160]	; 0xa0
	conn->le.interval_max = param->interval_max;
   30440:	886b      	ldrh	r3, [r5, #2]
   30442:	f8a4 30a2 	strh.w	r3, [r4, #162]	; 0xa2
	conn->le.latency = param->latency;
   30446:	88ab      	ldrh	r3, [r5, #4]
   30448:	f8a4 30a4 	strh.w	r3, [r4, #164]	; 0xa4
	conn->le.timeout = param->timeout;
   3044c:	88eb      	ldrh	r3, [r5, #6]
   3044e:	f8a4 30a6 	strh.w	r3, [r4, #166]	; 0xa6
	old = atomic_or(ATOMIC_ELEM(target, bit), mask);
   30452:	2101      	movs	r1, #1
   30454:	f01b fc11 	bl	4bc7a <atomic_or>
		if (!atomic_test_and_set_bit(conn->flags,
   30458:	07c1      	lsls	r1, r0, #31
   3045a:	d402      	bmi.n	30462 <bt_le_set_auto_conn+0x6e>
			bt_conn_ref(conn);
   3045c:	4620      	mov	r0, r4
   3045e:	f01b fc97 	bl	4bd90 <bt_conn_ref>
	if (conn->state == BT_CONN_DISCONNECTED &&
   30462:	7b63      	ldrb	r3, [r4, #13]
   30464:	b963      	cbnz	r3, 30480 <bt_le_set_auto_conn+0x8c>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
   30466:	4814      	ldr	r0, [pc, #80]	; (304b8 <bt_le_set_auto_conn+0xc4>)
   30468:	f01b fc01 	bl	4bc6e <atomic_get>
   3046c:	0743      	lsls	r3, r0, #29
   3046e:	d507      	bpl.n	30480 <bt_le_set_auto_conn+0x8c>
		if (param) {
   30470:	b11d      	cbz	r5, 3047a <bt_le_set_auto_conn+0x86>
			bt_conn_set_state(conn, BT_CONN_CONNECTING_SCAN);
   30472:	2102      	movs	r1, #2
   30474:	4620      	mov	r0, r4
   30476:	f7ff fc6d 	bl	2fd54 <bt_conn_set_state>
		bt_le_scan_update(false);
   3047a:	2000      	movs	r0, #0
   3047c:	f7fe ffe0 	bl	2f440 <bt_le_scan_update>
	bt_conn_unref(conn);
   30480:	4620      	mov	r0, r4
   30482:	f01b fca0 	bl	4bdc6 <bt_conn_unref>
	return 0;
   30486:	2000      	movs	r0, #0
   30488:	e7c2      	b.n	30410 <bt_le_set_auto_conn+0x1c>
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   3048a:	f06f 0101 	mvn.w	r1, #1
   3048e:	f01b fbdf 	bl	4bc50 <atomic_and>
		if (atomic_test_and_clear_bit(conn->flags,
   30492:	07c2      	lsls	r2, r0, #31
   30494:	d5e5      	bpl.n	30462 <bt_le_set_auto_conn+0x6e>
			bt_conn_unref(conn);
   30496:	4620      	mov	r0, r4
   30498:	f01b fc95 	bl	4bdc6 <bt_conn_unref>
			if (conn->state == BT_CONN_CONNECTING_SCAN) {
   3049c:	7b63      	ldrb	r3, [r4, #13]
   3049e:	2b02      	cmp	r3, #2
   304a0:	d1df      	bne.n	30462 <bt_le_set_auto_conn+0x6e>
				bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
   304a2:	4629      	mov	r1, r5
   304a4:	4620      	mov	r0, r4
   304a6:	f7ff fc55 	bl	2fd54 <bt_conn_set_state>
   304aa:	e7da      	b.n	30462 <bt_le_set_auto_conn+0x6e>
		return -EAGAIN;
   304ac:	f06f 000a 	mvn.w	r0, #10
   304b0:	e7ae      	b.n	30410 <bt_le_set_auto_conn+0x1c>
			return -ENOMEM;
   304b2:	f06f 000b 	mvn.w	r0, #11
   304b6:	e7ab      	b.n	30410 <bt_le_set_auto_conn+0x1c>
   304b8:	200000fc 	.word	0x200000fc

000304bc <send_conn_le_param_update>:
{
   304bc:	b538      	push	{r3, r4, r5, lr}
   304be:	4604      	mov	r4, r0
	if (!bt_le_conn_params_valid(param)) {
   304c0:	4608      	mov	r0, r1
{
   304c2:	460d      	mov	r5, r1
	if (!bt_le_conn_params_valid(param)) {
   304c4:	f01b f895 	bl	4b5f2 <bt_le_conn_params_valid>
   304c8:	b338      	cbz	r0, 3051a <send_conn_le_param_update+0x5e>
	if ((BT_FEAT_LE_CONN_PARAM_REQ_PROC(bt_dev.le.features) &&
   304ca:	4b15      	ldr	r3, [pc, #84]	; (30520 <send_conn_le_param_update+0x64>)
   304cc:	f893 30d0 	ldrb.w	r3, [r3, #208]	; 0xd0
   304d0:	0799      	lsls	r1, r3, #30
   304d2:	d407      	bmi.n	304e4 <send_conn_le_param_update+0x28>
	     !atomic_test_bit(conn->flags, BT_CONN_PERIPHERAL_PARAM_L2CAP)) ||
   304d4:	78e3      	ldrb	r3, [r4, #3]
   304d6:	b173      	cbz	r3, 304f6 <send_conn_le_param_update+0x3a>
	return bt_l2cap_update_conn_param(conn, param);
   304d8:	4629      	mov	r1, r5
   304da:	4620      	mov	r0, r4
}
   304dc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	return bt_l2cap_update_conn_param(conn, param);
   304e0:	f000 b9ee 	b.w	308c0 <bt_l2cap_update_conn_param>
	if ((BT_FEAT_LE_CONN_PARAM_REQ_PROC(bt_dev.le.features) &&
   304e4:	f894 30ac 	ldrb.w	r3, [r4, #172]	; 0xac
   304e8:	079a      	lsls	r2, r3, #30
   304ea:	d5f3      	bpl.n	304d4 <send_conn_le_param_update+0x18>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
   304ec:	1d20      	adds	r0, r4, #4
   304ee:	f01b fbbe 	bl	4bc6e <atomic_get>
	     BT_FEAT_LE_CONN_PARAM_REQ_PROC(conn->le.features) &&
   304f2:	0583      	lsls	r3, r0, #22
   304f4:	d4ee      	bmi.n	304d4 <send_conn_le_param_update+0x18>
		rc = bt_conn_le_conn_update(conn, param);
   304f6:	4629      	mov	r1, r5
   304f8:	4620      	mov	r0, r4
   304fa:	f01b fd76 	bl	4bfea <bt_conn_le_conn_update>
		if (rc == 0) {
   304fe:	b958      	cbnz	r0, 30518 <send_conn_le_param_update+0x5c>
			conn->le.interval_min = param->interval_min;
   30500:	882b      	ldrh	r3, [r5, #0]
   30502:	f8a4 30a0 	strh.w	r3, [r4, #160]	; 0xa0
			conn->le.interval_max = param->interval_max;
   30506:	886b      	ldrh	r3, [r5, #2]
   30508:	f8a4 30a2 	strh.w	r3, [r4, #162]	; 0xa2
			conn->le.pending_latency = param->latency;
   3050c:	88ab      	ldrh	r3, [r5, #4]
   3050e:	f8a4 30a8 	strh.w	r3, [r4, #168]	; 0xa8
			conn->le.pending_timeout = param->timeout;
   30512:	88eb      	ldrh	r3, [r5, #6]
   30514:	f8a4 30aa 	strh.w	r3, [r4, #170]	; 0xaa
}
   30518:	bd38      	pop	{r3, r4, r5, pc}
		return -EINVAL;
   3051a:	f06f 0015 	mvn.w	r0, #21
   3051e:	e7fb      	b.n	30518 <send_conn_le_param_update+0x5c>
   30520:	20000030 	.word	0x20000030

00030524 <deferred_work>:
{
   30524:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	if (conn->state == BT_CONN_DISCONNECTED) {
   30526:	f810 3c4b 	ldrb.w	r3, [r0, #-75]
{
   3052a:	4604      	mov	r4, r0
	struct bt_conn *conn = CONTAINER_OF(dwork, struct bt_conn, deferred_work);
   3052c:	f1a0 0558 	sub.w	r5, r0, #88	; 0x58
	if (conn->state == BT_CONN_DISCONNECTED) {
   30530:	b9fb      	cbnz	r3, 30572 <deferred_work+0x4e>
		bt_l2cap_disconnected(conn);
   30532:	4628      	mov	r0, r5
   30534:	f01b fdae 	bl	4c094 <bt_l2cap_disconnected>
	for (cb = callback_list; cb; cb = cb->_next) {
   30538:	4b24      	ldr	r3, [pc, #144]	; (305cc <deferred_work+0xa8>)
   3053a:	681e      	ldr	r6, [r3, #0]
   3053c:	b94e      	cbnz	r6, 30552 <deferred_work+0x2e>
	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
   3053e:	4e24      	ldr	r6, [pc, #144]	; (305d0 <deferred_work+0xac>)
   30540:	4f24      	ldr	r7, [pc, #144]	; (305d4 <deferred_work+0xb0>)
   30542:	42be      	cmp	r6, r7
   30544:	d30d      	bcc.n	30562 <deferred_work+0x3e>
		bt_conn_unref(conn);
   30546:	4628      	mov	r0, r5
}
   30548:	b003      	add	sp, #12
   3054a:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		bt_conn_unref(conn);
   3054e:	f01b bc3a 	b.w	4bdc6 <bt_conn_unref>
		if (cb->disconnected) {
   30552:	6873      	ldr	r3, [r6, #4]
   30554:	b11b      	cbz	r3, 3055e <deferred_work+0x3a>
			cb->disconnected(conn, conn->err);
   30556:	f814 1c4c 	ldrb.w	r1, [r4, #-76]
   3055a:	4628      	mov	r0, r5
   3055c:	4798      	blx	r3
	for (cb = callback_list; cb; cb = cb->_next) {
   3055e:	69f6      	ldr	r6, [r6, #28]
   30560:	e7ec      	b.n	3053c <deferred_work+0x18>
		if (cb->disconnected) {
   30562:	6873      	ldr	r3, [r6, #4]
   30564:	b11b      	cbz	r3, 3056e <deferred_work+0x4a>
			cb->disconnected(conn, conn->err);
   30566:	f814 1c4c 	ldrb.w	r1, [r4, #-76]
   3056a:	4628      	mov	r0, r5
   3056c:	4798      	blx	r3
	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
   3056e:	3620      	adds	r6, #32
   30570:	e7e7      	b.n	30542 <deferred_work+0x1e>
	if (conn->type != BT_CONN_TYPE_LE) {
   30572:	f810 3c56 	ldrb.w	r3, [r0, #-86]
   30576:	2b01      	cmp	r3, #1
   30578:	d125      	bne.n	305c6 <deferred_work+0xa2>
	if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
   3057a:	f810 3c55 	ldrb.w	r3, [r0, #-85]
   3057e:	b923      	cbnz	r3, 3058a <deferred_work+0x66>
}
   30580:	b003      	add	sp, #12
   30582:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		bt_le_create_conn_cancel();
   30586:	f7fd bdc3 	b.w	2e110 <bt_le_create_conn_cancel>
	if (atomic_test_and_clear_bit(conn->flags,
   3058a:	f1a0 0654 	sub.w	r6, r0, #84	; 0x54
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   3058e:	f46f 7180 	mvn.w	r1, #256	; 0x100
   30592:	4630      	mov	r0, r6
   30594:	f01b fb5c 	bl	4bc50 <atomic_and>
   30598:	05c3      	lsls	r3, r0, #23
   3059a:	d50e      	bpl.n	305ba <deferred_work+0x96>
		param = BT_LE_CONN_PARAM(conn->le.interval_min,
   3059c:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   3059e:	9300      	str	r3, [sp, #0]
   305a0:	6d23      	ldr	r3, [r4, #80]	; 0x50
   305a2:	9301      	str	r3, [sp, #4]
		send_conn_le_param_update(conn, param);
   305a4:	4669      	mov	r1, sp
   305a6:	4628      	mov	r0, r5
   305a8:	f7ff ff88 	bl	304bc <send_conn_le_param_update>
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
   305ac:	2180      	movs	r1, #128	; 0x80
   305ae:	4630      	mov	r0, r6
}
   305b0:	b003      	add	sp, #12
   305b2:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
   305b6:	f01b bb60 	b.w	4bc7a <atomic_or>
		param = BT_LE_CONN_PARAM(
   305ba:	4a07      	ldr	r2, [pc, #28]	; (305d8 <deferred_work+0xb4>)
   305bc:	6810      	ldr	r0, [r2, #0]
   305be:	6851      	ldr	r1, [r2, #4]
   305c0:	466b      	mov	r3, sp
   305c2:	c303      	stmia	r3!, {r0, r1}
   305c4:	e7ee      	b.n	305a4 <deferred_work+0x80>
}
   305c6:	b003      	add	sp, #12
   305c8:	bdf0      	pop	{r4, r5, r6, r7, pc}
   305ca:	bf00      	nop
   305cc:	20003c00 	.word	0x20003c00
   305d0:	00050c78 	.word	0x00050c78
   305d4:	00050c78 	.word	0x00050c78
   305d8:	00050dde 	.word	0x00050dde

000305dc <bt_conn_create_frag_timeout>:
						  k_timeout_t timeout,
						  const char *func, int line)
#else
struct net_buf *bt_conn_create_frag_timeout(size_t reserve, k_timeout_t timeout)
#endif
{
   305dc:	4601      	mov	r1, r0

#if defined(CONFIG_NET_BUF_LOG)
	return bt_conn_create_pdu_timeout_debug(pool, reserve, timeout,
						func, line);
#else
	return bt_conn_create_pdu_timeout(pool, reserve, timeout);
   305de:	4801      	ldr	r0, [pc, #4]	; (305e4 <bt_conn_create_frag_timeout+0x8>)
   305e0:	f7ff bc9c 	b.w	2ff1c <bt_conn_create_pdu_timeout>
   305e4:	2000133c 	.word	0x2000133c

000305e8 <create_frag>:
{
   305e8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   305ec:	4606      	mov	r6, r0
		frag = bt_conn_create_frag(0);
   305ee:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   305f2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   305f6:	2000      	movs	r0, #0
{
   305f8:	460c      	mov	r4, r1
		frag = bt_conn_create_frag(0);
   305fa:	f7ff ffef 	bl	305dc <bt_conn_create_frag_timeout>
	if (conn->state != BT_CONN_CONNECTED) {
   305fe:	7b73      	ldrb	r3, [r6, #13]
   30600:	2b07      	cmp	r3, #7
		frag = bt_conn_create_frag(0);
   30602:	4605      	mov	r5, r0
	if (conn->state != BT_CONN_CONNECTED) {
   30604:	f04f 0600 	mov.w	r6, #0
   30608:	d005      	beq.n	30616 <create_frag+0x2e>
		net_buf_unref(frag);
   3060a:	f012 f91d 	bl	42848 <net_buf_unref>
		return NULL;
   3060e:	4635      	mov	r5, r6
}
   30610:	4628      	mov	r0, r5
   30612:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	tx_data(frag)->tx = NULL;
   30616:	6146      	str	r6, [r0, #20]
 *
 * @return Number of bytes available at the end of the buffer.
 */
static inline size_t net_buf_tailroom(struct net_buf *buf)
{
	return net_buf_simple_tailroom(&buf->b);
   30618:	f100 0708 	add.w	r7, r0, #8
	return bt_dev.le.acl_mtu;
   3061c:	4e0c      	ldr	r6, [pc, #48]	; (30650 <create_frag+0x68>)
   3061e:	4638      	mov	r0, r7
	frag_len = MIN(conn_mtu(conn), net_buf_tailroom(frag));
   30620:	f8b6 80fc 	ldrh.w	r8, [r6, #252]	; 0xfc
   30624:	f01e fc13 	bl	4ee4e <net_buf_simple_tailroom>
   30628:	4580      	cmp	r8, r0
   3062a:	d20c      	bcs.n	30646 <create_frag+0x5e>
	return bt_dev.le.acl_mtu;
   3062c:	f8b6 60fc 	ldrh.w	r6, [r6, #252]	; 0xfc
	return net_buf_simple_add_mem(&buf->b, mem, len);
   30630:	f854 1f08 	ldr.w	r1, [r4, #8]!
   30634:	4632      	mov	r2, r6
   30636:	4638      	mov	r0, r7
   30638:	f01e fbc2 	bl	4edc0 <net_buf_simple_add_mem>
	return net_buf_simple_pull(&buf->b, len);
   3063c:	4631      	mov	r1, r6
   3063e:	4620      	mov	r0, r4
   30640:	f01e fbe1 	bl	4ee06 <net_buf_simple_pull>
   30644:	e7e4      	b.n	30610 <create_frag+0x28>
	return net_buf_simple_tailroom(&buf->b);
   30646:	4638      	mov	r0, r7
   30648:	f01e fc01 	bl	4ee4e <net_buf_simple_tailroom>
	frag_len = MIN(conn_mtu(conn), net_buf_tailroom(frag));
   3064c:	b286      	uxth	r6, r0
   3064e:	e7ef      	b.n	30630 <create_frag+0x48>
   30650:	20000030 	.word	0x20000030

00030654 <bt_conn_process_tx>:
{
   30654:	b570      	push	{r4, r5, r6, lr}
	if (conn->state == BT_CONN_DISCONNECTED &&
   30656:	7b43      	ldrb	r3, [r0, #13]
{
   30658:	4604      	mov	r4, r0
	if (conn->state == BT_CONN_DISCONNECTED &&
   3065a:	b95b      	cbnz	r3, 30674 <bt_conn_process_tx+0x20>
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   3065c:	f06f 0140 	mvn.w	r1, #64	; 0x40
   30660:	3004      	adds	r0, #4
   30662:	f01b faf5 	bl	4bc50 <atomic_and>
   30666:	0643      	lsls	r3, r0, #25
   30668:	d504      	bpl.n	30674 <bt_conn_process_tx+0x20>
		conn_cleanup(conn);
   3066a:	4620      	mov	r0, r4
}
   3066c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		conn_cleanup(conn);
   30670:	f01b bb1e 	b.w	4bcb0 <conn_cleanup>
	buf = net_buf_get(&conn->tx_queue, K_NO_WAIT);
   30674:	2200      	movs	r2, #0
   30676:	2300      	movs	r3, #0
   30678:	f104 0038 	add.w	r0, r4, #56	; 0x38
   3067c:	f01e fb37 	bl	4ecee <net_buf_get>
	BT_ASSERT(buf);
   30680:	4605      	mov	r5, r0
   30682:	b960      	cbnz	r0, 3069e <bt_conn_process_tx+0x4a>
   30684:	4a23      	ldr	r2, [pc, #140]	; (30714 <bt_conn_process_tx+0xc0>)
   30686:	4924      	ldr	r1, [pc, #144]	; (30718 <bt_conn_process_tx+0xc4>)
   30688:	4824      	ldr	r0, [pc, #144]	; (3071c <bt_conn_process_tx+0xc8>)
   3068a:	f240 330b 	movw	r3, #779	; 0x30b
   3068e:	f018 fcf9 	bl	49084 <assert_print>
   30692:	4040      	eors	r0, r0
   30694:	f380 8811 	msr	BASEPRI, r0
   30698:	f04f 0003 	mov.w	r0, #3
   3069c:	df02      	svc	2
	return bt_dev.le.acl_mtu;
   3069e:	4e20      	ldr	r6, [pc, #128]	; (30720 <bt_conn_process_tx+0xcc>)
	if (buf->len <= conn_mtu(conn)) {
   306a0:	89aa      	ldrh	r2, [r5, #12]
   306a2:	f8b6 30fc 	ldrh.w	r3, [r6, #252]	; 0xfc
   306a6:	429a      	cmp	r2, r3
   306a8:	d807      	bhi.n	306ba <bt_conn_process_tx+0x66>
		return send_frag(conn, buf, FRAG_SINGLE, false);
   306aa:	2300      	movs	r3, #0
   306ac:	2202      	movs	r2, #2
	return send_frag(conn, buf, FRAG_END, false);
   306ae:	4629      	mov	r1, r5
   306b0:	4620      	mov	r0, r4
   306b2:	f7ff fa0d 	bl	2fad0 <send_frag>
	if (!send_buf(conn, buf)) {
   306b6:	b968      	cbnz	r0, 306d4 <bt_conn_process_tx+0x80>
   306b8:	e005      	b.n	306c6 <bt_conn_process_tx+0x72>
	frag = create_frag(conn, buf);
   306ba:	4629      	mov	r1, r5
   306bc:	4620      	mov	r0, r4
   306be:	f7ff ff93 	bl	305e8 <create_frag>
	if (!frag) {
   306c2:	4601      	mov	r1, r0
   306c4:	b938      	cbnz	r0, 306d6 <bt_conn_process_tx+0x82>
		struct bt_conn_tx *tx = tx_data(buf)->tx;
   306c6:	696e      	ldr	r6, [r5, #20]
		tx_data(buf)->tx = NULL;
   306c8:	2300      	movs	r3, #0
   306ca:	616b      	str	r3, [r5, #20]
		net_buf_unref(buf);
   306cc:	4628      	mov	r0, r5
   306ce:	f012 f8bb 	bl	42848 <net_buf_unref>
		if (tx) {
   306d2:	b9ce      	cbnz	r6, 30708 <bt_conn_process_tx+0xb4>
}
   306d4:	bd70      	pop	{r4, r5, r6, pc}
	if (!send_frag(conn, frag, FRAG_START, true)) {
   306d6:	2301      	movs	r3, #1
   306d8:	2200      	movs	r2, #0
		if (!send_frag(conn, frag, FRAG_CONT, true)) {
   306da:	4620      	mov	r0, r4
   306dc:	f7ff f9f8 	bl	2fad0 <send_frag>
   306e0:	2800      	cmp	r0, #0
   306e2:	d0f0      	beq.n	306c6 <bt_conn_process_tx+0x72>
	while (buf->len > conn_mtu(conn)) {
   306e4:	89aa      	ldrh	r2, [r5, #12]
   306e6:	f8b6 30fc 	ldrh.w	r3, [r6, #252]	; 0xfc
   306ea:	429a      	cmp	r2, r3
   306ec:	d802      	bhi.n	306f4 <bt_conn_process_tx+0xa0>
	return send_frag(conn, buf, FRAG_END, false);
   306ee:	2300      	movs	r3, #0
   306f0:	2203      	movs	r2, #3
   306f2:	e7dc      	b.n	306ae <bt_conn_process_tx+0x5a>
		frag = create_frag(conn, buf);
   306f4:	4629      	mov	r1, r5
   306f6:	4620      	mov	r0, r4
   306f8:	f7ff ff76 	bl	305e8 <create_frag>
		if (!frag) {
   306fc:	4601      	mov	r1, r0
   306fe:	2800      	cmp	r0, #0
   30700:	d0e1      	beq.n	306c6 <bt_conn_process_tx+0x72>
		if (!send_frag(conn, frag, FRAG_CONT, true)) {
   30702:	2301      	movs	r3, #1
   30704:	461a      	mov	r2, r3
   30706:	e7e8      	b.n	306da <bt_conn_process_tx+0x86>
			conn_tx_destroy(conn, tx);
   30708:	4631      	mov	r1, r6
   3070a:	4620      	mov	r0, r4
}
   3070c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			conn_tx_destroy(conn, tx);
   30710:	f7ff b9c8 	b.w	2faa4 <conn_tx_destroy>
   30714:	0005374a 	.word	0x0005374a
   30718:	0005362b 	.word	0x0005362b
   3071c:	0005360e 	.word	0x0005360e
   30720:	20000030 	.word	0x20000030

00030724 <bt_conn_auth_cb_register>:
}

#if defined(CONFIG_BT_SMP) || defined(CONFIG_BT_BREDR)
int bt_conn_auth_cb_register(const struct bt_conn_auth_cb *cb)
{
	if (!cb) {
   30724:	4b0b      	ldr	r3, [pc, #44]	; (30754 <bt_conn_auth_cb_register+0x30>)
   30726:	b158      	cbz	r0, 30740 <bt_conn_auth_cb_register+0x1c>
		bt_auth = NULL;
		return 0;
	}

	if (bt_auth) {
   30728:	681a      	ldr	r2, [r3, #0]
   3072a:	b962      	cbnz	r2, 30746 <bt_conn_auth_cb_register+0x22>
	}

	/* The cancel callback must always be provided if the app provides
	 * interactive callbacks.
	 */
	if (!cb->cancel &&
   3072c:	6942      	ldr	r2, [r0, #20]
   3072e:	b93a      	cbnz	r2, 30740 <bt_conn_auth_cb_register+0x1c>
   30730:	6842      	ldr	r2, [r0, #4]
   30732:	b95a      	cbnz	r2, 3074c <bt_conn_auth_cb_register+0x28>
	    (cb->passkey_display || cb->passkey_entry || cb->passkey_confirm ||
   30734:	6882      	ldr	r2, [r0, #8]
   30736:	b94a      	cbnz	r2, 3074c <bt_conn_auth_cb_register+0x28>
   30738:	68c2      	ldr	r2, [r0, #12]
   3073a:	b93a      	cbnz	r2, 3074c <bt_conn_auth_cb_register+0x28>
   3073c:	6982      	ldr	r2, [r0, #24]
   3073e:	b92a      	cbnz	r2, 3074c <bt_conn_auth_cb_register+0x28>
#endif
	     cb->pairing_confirm)) {
		return -EINVAL;
	}

	bt_auth = cb;
   30740:	6018      	str	r0, [r3, #0]
		return 0;
   30742:	2000      	movs	r0, #0
   30744:	4770      	bx	lr
		return -EALREADY;
   30746:	f06f 0077 	mvn.w	r0, #119	; 0x77
   3074a:	4770      	bx	lr
		return -EINVAL;
   3074c:	f06f 0015 	mvn.w	r0, #21
	return 0;
}
   30750:	4770      	bx	lr
   30752:	bf00      	nop
   30754:	20003c0c 	.word	0x20003c0c

00030758 <bt_conn_auth_info_cb_register>:
}
#endif

int bt_conn_auth_info_cb_register(struct bt_conn_auth_info_cb *cb)
{
	CHECKIF(cb == NULL) {
   30758:	b168      	cbz	r0, 30776 <bt_conn_auth_info_cb_register+0x1e>
	parent->next = child;
   3075a:	2300      	movs	r3, #0
   3075c:	60c3      	str	r3, [r0, #12]
	return list->tail;
   3075e:	4b07      	ldr	r3, [pc, #28]	; (3077c <bt_conn_auth_info_cb_register+0x24>)
   30760:	6859      	ldr	r1, [r3, #4]
		return -EINVAL;
	}

	sys_slist_append(&bt_auth_info_cbs, &cb->node);
   30762:	f100 020c 	add.w	r2, r0, #12
Z_GENLIST_APPEND(slist, snode)
   30766:	b919      	cbnz	r1, 30770 <bt_conn_auth_info_cb_register+0x18>
	list->head = node;
   30768:	e9c3 2200 	strd	r2, r2, [r3]

	return 0;
   3076c:	2000      	movs	r0, #0
   3076e:	4770      	bx	lr
	parent->next = child;
   30770:	600a      	str	r2, [r1, #0]
	list->tail = node;
   30772:	605a      	str	r2, [r3, #4]
}
   30774:	e7fa      	b.n	3076c <bt_conn_auth_info_cb_register+0x14>
		return -EINVAL;
   30776:	f06f 0015 	mvn.w	r0, #21
}
   3077a:	4770      	bx	lr
   3077c:	20003c04 	.word	0x20003c04

00030780 <bt_conn_init>:

	return bt_conn_ref(&acl_conns[index]);
}

int bt_conn_init(void)
{
   30780:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	int err, i;

	for (i = 0; i < ARRAY_SIZE(conn_tx); i++) {
		k_fifo_put(&free_tx, &conn_tx[i]);
   30782:	4917      	ldr	r1, [pc, #92]	; (307e0 <bt_conn_init+0x60>)
   30784:	4817      	ldr	r0, [pc, #92]	; (307e4 <bt_conn_init+0x64>)
   30786:	f01f fb23 	bl	4fdd0 <k_queue_append>
   3078a:	4917      	ldr	r1, [pc, #92]	; (307e8 <bt_conn_init+0x68>)
   3078c:	4815      	ldr	r0, [pc, #84]	; (307e4 <bt_conn_init+0x64>)
   3078e:	f01f fb1f 	bl	4fdd0 <k_queue_append>
   30792:	4916      	ldr	r1, [pc, #88]	; (307ec <bt_conn_init+0x6c>)
   30794:	4813      	ldr	r0, [pc, #76]	; (307e4 <bt_conn_init+0x64>)
   30796:	f01f fb1b 	bl	4fdd0 <k_queue_append>
	}

	bt_att_init();
   3079a:	f000 fe0d 	bl	313b8 <bt_att_init>

	err = bt_smp_init();
   3079e:	f003 fce1 	bl	34164 <bt_smp_init>
	if (err) {
   307a2:	4605      	mov	r5, r0
   307a4:	b9d0      	cbnz	r0, 307dc <bt_conn_init+0x5c>
		return err;
	}

	bt_l2cap_init();
   307a6:	f01b fd67 	bl	4c278 <bt_l2cap_init>

	/* Initialize background scan */
	if (IS_ENABLED(CONFIG_BT_CENTRAL)) {
		for (i = 0; i < ARRAY_SIZE(acl_conns); i++) {
   307aa:	4f11      	ldr	r7, [pc, #68]	; (307f0 <bt_conn_init+0x70>)
   307ac:	462e      	mov	r6, r5
			struct bt_conn *conn = bt_conn_ref(&acl_conns[i]);
   307ae:	4638      	mov	r0, r7
   307b0:	f01b faee 	bl	4bd90 <bt_conn_ref>

			if (!conn) {
   307b4:	4604      	mov	r4, r0
   307b6:	b160      	cbz	r0, 307d2 <bt_conn_init+0x52>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
   307b8:	3004      	adds	r0, #4
   307ba:	f01b fa58 	bl	4bc6e <atomic_get>
				continue;
			}

#if !defined(CONFIG_BT_FILTER_ACCEPT_LIST)
			if (atomic_test_bit(conn->flags,
   307be:	07c3      	lsls	r3, r0, #31
   307c0:	d504      	bpl.n	307cc <bt_conn_init+0x4c>
					    BT_CONN_AUTO_CONNECT)) {
				/* Only the default identity is supported */
				conn->id = BT_ID_DEFAULT;
   307c2:	7225      	strb	r5, [r4, #8]
				bt_conn_set_state(conn,
   307c4:	2102      	movs	r1, #2
   307c6:	4620      	mov	r0, r4
   307c8:	f7ff fac4 	bl	2fd54 <bt_conn_set_state>
						  BT_CONN_CONNECTING_SCAN);
			}
#endif /* !defined(CONFIG_BT_FILTER_ACCEPT_LIST) */

			bt_conn_unref(conn);
   307cc:	4620      	mov	r0, r4
   307ce:	f01b fafa 	bl	4bdc6 <bt_conn_unref>
		for (i = 0; i < ARRAY_SIZE(acl_conns); i++) {
   307d2:	3601      	adds	r6, #1
   307d4:	2e06      	cmp	r6, #6
   307d6:	f107 07c0 	add.w	r7, r7, #192	; 0xc0
   307da:	d1e8      	bne.n	307ae <bt_conn_init+0x2e>
		}
	}

	return 0;
}
   307dc:	4628      	mov	r0, r5
   307de:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   307e0:	20003bd0 	.word	0x20003bd0
   307e4:	200012b4 	.word	0x200012b4
   307e8:	20003be0 	.word	0x20003be0
   307ec:	20003bf0 	.word	0x20003bf0
   307f0:	20001828 	.word	0x20001828

000307f4 <l2cap_accept>:
	(void)k_work_cancel_delayable(&le_chan->rtx_work);
#endif /* CONFIG_BT_L2CAP_DYNAMIC_CHANNEL */
}

static int l2cap_accept(struct bt_conn *conn, struct bt_l2cap_chan **chan)
{
   307f4:	b530      	push	{r4, r5, lr}
	BT_DBG("conn %p handle %u", conn, conn->handle);

	for (i = 0; i < ARRAY_SIZE(bt_l2cap_pool); i++) {
		struct bt_l2cap *l2cap = &bt_l2cap_pool[i];

		if (l2cap->chan.chan.conn) {
   307f6:	4c09      	ldr	r4, [pc, #36]	; (3081c <l2cap_accept+0x28>)
	for (i = 0; i < ARRAY_SIZE(bt_l2cap_pool); i++) {
   307f8:	2300      	movs	r3, #0
   307fa:	258c      	movs	r5, #140	; 0x8c
		if (l2cap->chan.chan.conn) {
   307fc:	fb05 f003 	mul.w	r0, r5, r3
   30800:	1902      	adds	r2, r0, r4
   30802:	5820      	ldr	r0, [r4, r0]
   30804:	b128      	cbz	r0, 30812 <l2cap_accept+0x1e>
	for (i = 0; i < ARRAY_SIZE(bt_l2cap_pool); i++) {
   30806:	3301      	adds	r3, #1
   30808:	2b06      	cmp	r3, #6
   3080a:	d1f7      	bne.n	307fc <l2cap_accept+0x8>
		return 0;
	}

	BT_ERR("No available L2CAP context for conn %p", conn);

	return -ENOMEM;
   3080c:	f06f 000b 	mvn.w	r0, #11
}
   30810:	bd30      	pop	{r4, r5, pc}
		l2cap->chan.chan.ops = &ops;
   30812:	4b03      	ldr	r3, [pc, #12]	; (30820 <l2cap_accept+0x2c>)
   30814:	6053      	str	r3, [r2, #4]
		*chan = &l2cap->chan.chan;
   30816:	600a      	str	r2, [r1, #0]
		return 0;
   30818:	e7fa      	b.n	30810 <l2cap_accept+0x1c>
   3081a:	bf00      	nop
   3081c:	20003c10 	.word	0x20003c10
   30820:	00051e10 	.word	0x00051e10

00030824 <bt_l2cap_connected>:
{
   30824:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	STRUCT_SECTION_FOREACH(bt_l2cap_fixed_chan, fchan) {
   30826:	4d24      	ldr	r5, [pc, #144]	; (308b8 <bt_l2cap_connected+0x94>)
   30828:	4f24      	ldr	r7, [pc, #144]	; (308bc <bt_l2cap_connected+0x98>)
{
   3082a:	4604      	mov	r4, r0
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   3082c:	2600      	movs	r6, #0
	STRUCT_SECTION_FOREACH(bt_l2cap_fixed_chan, fchan) {
   3082e:	42bd      	cmp	r5, r7
   30830:	d301      	bcc.n	30836 <bt_l2cap_connected+0x12>
}
   30832:	b003      	add	sp, #12
   30834:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (fchan->accept(conn, &chan) < 0) {
   30836:	686b      	ldr	r3, [r5, #4]
   30838:	a901      	add	r1, sp, #4
   3083a:	4620      	mov	r0, r4
   3083c:	4798      	blx	r3
   3083e:	2800      	cmp	r0, #0
   30840:	db34      	blt.n	308ac <bt_l2cap_connected+0x88>
		le_chan = BT_L2CAP_LE_CHAN(chan);
   30842:	9b01      	ldr	r3, [sp, #4]
		le_chan->rx.cid = fchan->cid;
   30844:	882a      	ldrh	r2, [r5, #0]
   30846:	829a      	strh	r2, [r3, #20]
		le_chan->tx.cid = fchan->cid;
   30848:	849a      	strh	r2, [r3, #36]	; 0x24
   3084a:	f103 0210 	add.w	r2, r3, #16
		if (!l2cap_chan_add(conn, chan, fchan->destroy)) {
   3084e:	68a8      	ldr	r0, [r5, #8]
   30850:	f3bf 8f5b 	dmb	ish
   30854:	e852 1f00 	ldrex	r1, [r2]
   30858:	e842 6c00 	strex	ip, r6, [r2]
   3085c:	f1bc 0f00 	cmp.w	ip, #0
   30860:	d1f8      	bne.n	30854 <bt_l2cap_connected+0x30>
   30862:	f3bf 8f5b 	dmb	ish
	parent->next = child;
   30866:	609e      	str	r6, [r3, #8]
	return list->tail;
   30868:	6d61      	ldr	r1, [r4, #84]	; 0x54
	sys_slist_append(&conn->channels, &chan->node);
   3086a:	f103 0208 	add.w	r2, r3, #8
Z_GENLIST_APPEND(slist, snode)
   3086e:	b9f9      	cbnz	r1, 308b0 <bt_l2cap_connected+0x8c>
	list->head = node;
   30870:	e9c4 2214 	strd	r2, r2, [r4, #80]	; 0x50
	chan->conn = conn;
   30874:	601c      	str	r4, [r3, #0]
	chan->destroy = destroy;
   30876:	60d8      	str	r0, [r3, #12]
		if (chan->ops->connected) {
   30878:	9801      	ldr	r0, [sp, #4]
   3087a:	6843      	ldr	r3, [r0, #4]
   3087c:	681b      	ldr	r3, [r3, #0]
   3087e:	b103      	cbz	r3, 30882 <bt_l2cap_connected+0x5e>
			chan->ops->connected(chan);
   30880:	4798      	blx	r3
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   30882:	9b01      	ldr	r3, [sp, #4]
   30884:	f3bf 8f5b 	dmb	ish
   30888:	3310      	adds	r3, #16
   3088a:	e853 1f00 	ldrex	r1, [r3]
   3088e:	f041 0101 	orr.w	r1, r1, #1
   30892:	e843 1200 	strex	r2, r1, [r3]
   30896:	2a00      	cmp	r2, #0
   30898:	d1f7      	bne.n	3088a <bt_l2cap_connected+0x66>
   3089a:	f3bf 8f5b 	dmb	ish
		if (chan->ops->status) {
   3089e:	9801      	ldr	r0, [sp, #4]
   308a0:	6843      	ldr	r3, [r0, #4]
   308a2:	69db      	ldr	r3, [r3, #28]
   308a4:	b113      	cbz	r3, 308ac <bt_l2cap_connected+0x88>
			chan->ops->status(chan, chan->status);
   308a6:	f100 0110 	add.w	r1, r0, #16
   308aa:	4798      	blx	r3
	STRUCT_SECTION_FOREACH(bt_l2cap_fixed_chan, fchan) {
   308ac:	350c      	adds	r5, #12
   308ae:	e7be      	b.n	3082e <bt_l2cap_connected+0xa>
	parent->next = child;
   308b0:	600a      	str	r2, [r1, #0]
	list->tail = node;
   308b2:	6562      	str	r2, [r4, #84]	; 0x54
}
   308b4:	e7de      	b.n	30874 <bt_l2cap_connected+0x50>
   308b6:	bf00      	nop
   308b8:	00050c54 	.word	0x00050c54
   308bc:	00050c78 	.word	0x00050c78

000308c0 <bt_l2cap_update_conn_param>:
{
   308c0:	b573      	push	{r0, r1, r4, r5, r6, lr}
	ident++;
   308c2:	4b17      	ldr	r3, [pc, #92]	; (30920 <bt_l2cap_update_conn_param+0x60>)
{
   308c4:	460e      	mov	r6, r1
	ident++;
   308c6:	7819      	ldrb	r1, [r3, #0]
   308c8:	3101      	adds	r1, #1
   308ca:	b2c9      	uxtb	r1, r1
   308cc:	2901      	cmp	r1, #1
   308ce:	bf38      	it	cc
   308d0:	2101      	movcc	r1, #1
{
   308d2:	4605      	mov	r5, r0
	buf = l2cap_create_le_sig_pdu(NULL, BT_L2CAP_CONN_PARAM_REQ,
   308d4:	2208      	movs	r2, #8
   308d6:	2012      	movs	r0, #18
	ident++;
   308d8:	7019      	strb	r1, [r3, #0]
	buf = l2cap_create_le_sig_pdu(NULL, BT_L2CAP_CONN_PARAM_REQ,
   308da:	f01b fbaf 	bl	4c03c <l2cap_create_le_sig_pdu.constprop.0>
	if (!buf) {
   308de:	4604      	mov	r4, r0
   308e0:	b1d0      	cbz	r0, 30918 <bt_l2cap_update_conn_param+0x58>
	return net_buf_simple_add(&buf->b, len);
   308e2:	2108      	movs	r1, #8
   308e4:	4408      	add	r0, r1
   308e6:	f01e fa65 	bl	4edb4 <net_buf_simple_add>
	req->min_interval = sys_cpu_to_le16(param->interval_min);
   308ea:	8833      	ldrh	r3, [r6, #0]
   308ec:	8003      	strh	r3, [r0, #0]
	req->max_interval = sys_cpu_to_le16(param->interval_max);
   308ee:	8873      	ldrh	r3, [r6, #2]
   308f0:	8043      	strh	r3, [r0, #2]
	req->latency = sys_cpu_to_le16(param->latency);
   308f2:	88b3      	ldrh	r3, [r6, #4]
   308f4:	8083      	strh	r3, [r0, #4]
	req->timeout = sys_cpu_to_le16(param->timeout);
   308f6:	88f3      	ldrh	r3, [r6, #6]
   308f8:	80c3      	strh	r3, [r0, #6]
		     bt_conn_tx_cb_t cb, void *user_data);

static inline int bt_l2cap_send(struct bt_conn *conn, uint16_t cid,
				struct net_buf *buf)
{
	return bt_l2cap_send_cb(conn, cid, buf, NULL, NULL);
   308fa:	2300      	movs	r3, #0
   308fc:	4628      	mov	r0, r5
   308fe:	9300      	str	r3, [sp, #0]
   30900:	4622      	mov	r2, r4
   30902:	2105      	movs	r1, #5
   30904:	f01b fbfe 	bl	4c104 <bt_l2cap_send_cb>
	if (err) {
   30908:	4605      	mov	r5, r0
   3090a:	b110      	cbz	r0, 30912 <bt_l2cap_update_conn_param+0x52>
		net_buf_unref(buf);
   3090c:	4620      	mov	r0, r4
   3090e:	f011 ff9b 	bl	42848 <net_buf_unref>
}
   30912:	4628      	mov	r0, r5
   30914:	b002      	add	sp, #8
   30916:	bd70      	pop	{r4, r5, r6, pc}
		return -ENOMEM;
   30918:	f06f 050b 	mvn.w	r5, #11
   3091c:	e7f9      	b.n	30912 <bt_l2cap_update_conn_param+0x52>
   3091e:	bf00      	nop
   30920:	20006ba7 	.word	0x20006ba7

00030924 <att_op_get_type>:
#endif /* CONFIG_BT_GATT_CLIENT */
};

static att_type_t att_op_get_type(uint8_t op)
{
	switch (op) {
   30924:	2823      	cmp	r0, #35	; 0x23
   30926:	d81f      	bhi.n	30968 <att_op_get_type+0x44>
   30928:	281a      	cmp	r0, #26
   3092a:	d804      	bhi.n	30936 <att_op_get_type+0x12>
   3092c:	1e43      	subs	r3, r0, #1
   3092e:	2b18      	cmp	r3, #24
   30930:	d90e      	bls.n	30950 <att_op_get_type+0x2c>

	if (op & ATT_CMD_MASK) {
		return ATT_COMMAND;
	}

	return ATT_UNKNOWN;
   30932:	2006      	movs	r0, #6
   30934:	4770      	bx	lr
	switch (op) {
   30936:	f1a0 031b 	sub.w	r3, r0, #27
   3093a:	2b08      	cmp	r3, #8
   3093c:	d81e      	bhi.n	3097c <att_op_get_type+0x58>
   3093e:	e8df f003 	tbb	[pc, r3]
   30942:	1d05      	.short	0x1d05
   30944:	191d231b 	.word	0x191d231b
   30948:	1d25      	.short	0x1d25
   3094a:	05          	.byte	0x05
   3094b:	00          	.byte	0x00
		return ATT_NOTIFICATION;
   3094c:	2003      	movs	r0, #3
   3094e:	4770      	bx	lr
	switch (op) {
   30950:	4a0f      	ldr	r2, [pc, #60]	; (30990 <att_op_get_type+0x6c>)
   30952:	2301      	movs	r3, #1
   30954:	4083      	lsls	r3, r0
   30956:	401a      	ands	r2, r3
   30958:	b9c2      	cbnz	r2, 3098c <att_op_get_type+0x68>
   3095a:	4a0e      	ldr	r2, [pc, #56]	; (30994 <att_op_get_type+0x70>)
   3095c:	401a      	ands	r2, r3
	return ATT_UNKNOWN;
   3095e:	2a00      	cmp	r2, #0
   30960:	bf14      	ite	ne
   30962:	2001      	movne	r0, #1
   30964:	2006      	moveq	r0, #6
   30966:	4770      	bx	lr
	switch (op) {
   30968:	f000 037f 	and.w	r3, r0, #127	; 0x7f
   3096c:	2b52      	cmp	r3, #82	; 0x52
   3096e:	d105      	bne.n	3097c <att_op_get_type+0x58>
		return ATT_COMMAND;
   30970:	2000      	movs	r0, #0
}
   30972:	4770      	bx	lr
		return ATT_REQUEST;
   30974:	2001      	movs	r0, #1
   30976:	4770      	bx	lr
		return ATT_INDICATION;
   30978:	2005      	movs	r0, #5
   3097a:	4770      	bx	lr
		return ATT_COMMAND;
   3097c:	f010 0f40 	tst.w	r0, #64	; 0x40
   30980:	bf0c      	ite	eq
   30982:	2006      	moveq	r0, #6
   30984:	2000      	movne	r0, #0
   30986:	4770      	bx	lr
	switch (op) {
   30988:	2004      	movs	r0, #4
   3098a:	4770      	bx	lr
		return ATT_RESPONSE;
   3098c:	2002      	movs	r0, #2
   3098e:	4770      	bx	lr
   30990:	028aaaaa 	.word	0x028aaaaa
   30994:	01455554 	.word	0x01455554

00030998 <bt_att_released>:
	/* Prepend back to the list as it could not be sent */
	sys_slist_prepend(&chan->att->reqs, node);
}

static void bt_att_released(struct bt_l2cap_chan *ch)
{
   30998:	b507      	push	{r0, r1, r2, lr}
	struct bt_att_chan *chan = ATT_CHAN(ch);
   3099a:	3804      	subs	r0, #4
   3099c:	9001      	str	r0, [sp, #4]

	BT_DBG("chan %p", chan);

	k_mem_slab_free(&chan_slab, (void **)&chan);
   3099e:	a901      	add	r1, sp, #4
   309a0:	4802      	ldr	r0, [pc, #8]	; (309ac <bt_att_released+0x14>)
   309a2:	f01f f92d 	bl	4fc00 <k_mem_slab_free>
}
   309a6:	b003      	add	sp, #12
   309a8:	f85d fb04 	ldr.w	pc, [sp], #4
   309ac:	2000108c 	.word	0x2000108c

000309b0 <tx_meta_data_free>:
{
   309b0:	b510      	push	{r4, lr}
	(void)memset(data, 0, sizeof(*data));
   309b2:	2100      	movs	r1, #0
{
   309b4:	4604      	mov	r4, r0
	(void)memset(data, 0, sizeof(*data));
   309b6:	2214      	movs	r2, #20
   309b8:	f01a fa6a 	bl	4ae90 <memset>
	k_fifo_put(&free_att_tx_meta_data, data);
   309bc:	4621      	mov	r1, r4
   309be:	4802      	ldr	r0, [pc, #8]	; (309c8 <tx_meta_data_free+0x18>)
}
   309c0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	k_fifo_put(&free_att_tx_meta_data, data);
   309c4:	f01f ba04 	b.w	4fdd0 <k_queue_append>
   309c8:	2000129c 	.word	0x2000129c

000309cc <chan_send>:
{
   309cc:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   309d0:	4606      	mov	r6, r0
	struct bt_att_tx_meta_data *data = bt_att_tx_meta_data(buf);
   309d2:	f8d1 8014 	ldr.w	r8, [r1, #20]
	hdr = (void *)buf->data;
   309d6:	688b      	ldr	r3, [r1, #8]
{
   309d8:	460c      	mov	r4, r1
	if (!atomic_test_bit(chan->flags, ATT_CONNECTED)) {
   309da:	3090      	adds	r0, #144	; 0x90
   309dc:	2102      	movs	r1, #2
   309de:	f01b fc7e 	bl	4c2de <atomic_test_bit>
   309e2:	2800      	cmp	r0, #0
   309e4:	d039      	beq.n	30a5a <chan_send+0x8e>
	if (hdr->code == BT_ATT_OP_SIGNED_WRITE_CMD) {
   309e6:	781b      	ldrb	r3, [r3, #0]
   309e8:	2bd2      	cmp	r3, #210	; 0xd2
   309ea:	d110      	bne.n	30a0e <chan_send+0x42>
		err = bt_smp_sign(chan->att->conn, buf);
   309ec:	6833      	ldr	r3, [r6, #0]
   309ee:	4621      	mov	r1, r4
   309f0:	6818      	ldr	r0, [r3, #0]
   309f2:	f01d fe88 	bl	4e706 <bt_smp_sign>
		if (err) {
   309f6:	4605      	mov	r5, r0
   309f8:	b148      	cbz	r0, 30a0e <chan_send+0x42>
			tx_meta_data_free(bt_att_tx_meta_data(buf));
   309fa:	6960      	ldr	r0, [r4, #20]
   309fc:	f7ff ffd8 	bl	309b0 <tx_meta_data_free>
			net_buf_unref(buf);
   30a00:	4620      	mov	r0, r4
   30a02:	f011 ff21 	bl	42848 <net_buf_unref>
}
   30a06:	4628      	mov	r0, r5
   30a08:	b003      	add	sp, #12
   30a0a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	state->offset = net_buf_simple_headroom(buf);
   30a0e:	f104 0008 	add.w	r0, r4, #8
   30a12:	f01e fa18 	bl	4ee46 <net_buf_simple_headroom>
	state->len = buf->len;
   30a16:	f8b4 900c 	ldrh.w	r9, [r4, #12]
	data->att_chan = chan;
   30a1a:	f8c8 6000 	str.w	r6, [r8]
	err = bt_l2cap_send_cb(chan->att->conn, BT_L2CAP_CID_ATT,
   30a1e:	6833      	ldr	r3, [r6, #0]
   30a20:	681d      	ldr	r5, [r3, #0]
	const att_type_t op_type = att_op_get_type(buf->data[0]);
   30a22:	68a3      	ldr	r3, [r4, #8]
	state->offset = net_buf_simple_headroom(buf);
   30a24:	4607      	mov	r7, r0
   30a26:	7818      	ldrb	r0, [r3, #0]
   30a28:	f7ff ff7c 	bl	30924 <att_op_get_type>
	switch (op_type) {
   30a2c:	2805      	cmp	r0, #5
   30a2e:	bf96      	itet	ls
   30a30:	4b0b      	ldrls	r3, [pc, #44]	; (30a60 <chan_send+0x94>)
	const att_type_t op_type = att_op_get_type(buf->data[0]);
   30a32:	4b0c      	ldrhi	r3, [pc, #48]	; (30a64 <chan_send+0x98>)
   30a34:	f853 3020 	ldrls.w	r3, [r3, r0, lsl #2]
	err = bt_l2cap_send_cb(chan->att->conn, BT_L2CAP_CID_ATT,
   30a38:	f8cd 8000 	str.w	r8, [sp]
   30a3c:	4628      	mov	r0, r5
   30a3e:	4622      	mov	r2, r4
   30a40:	2104      	movs	r1, #4
   30a42:	f01b fb5f 	bl	4c104 <bt_l2cap_send_cb>
	if (err) {
   30a46:	4605      	mov	r5, r0
   30a48:	2800      	cmp	r0, #0
   30a4a:	d0dc      	beq.n	30a06 <chan_send+0x3a>
	buf->data = buf->__buf + state->offset;
   30a4c:	6923      	ldr	r3, [r4, #16]
	buf->len = state->len;
   30a4e:	f8a4 900c 	strh.w	r9, [r4, #12]
	buf->data = buf->__buf + state->offset;
   30a52:	fa13 f787 	uxtah	r7, r3, r7
   30a56:	60a7      	str	r7, [r4, #8]
}
   30a58:	e7d5      	b.n	30a06 <chan_send+0x3a>
		return -EINVAL;
   30a5a:	f06f 0515 	mvn.w	r5, #21
   30a5e:	e7d2      	b.n	30a06 <chan_send+0x3a>
   30a60:	00051e38 	.word	0x00051e38
   30a64:	0004c9cf 	.word	0x0004c9cf

00030a68 <read_group_cb>:
{
   30a68:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
   30a6c:	4605      	mov	r5, r0
   30a6e:	460e      	mov	r6, r1
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY) &&
   30a70:	f04f 0800 	mov.w	r8, #0
   30a74:	f44f 5320 	mov.w	r3, #10240	; 0x2800
   30a78:	6800      	ldr	r0, [r0, #0]
	struct bt_att_chan *chan = data->chan;
   30a7a:	6817      	ldr	r7, [r2, #0]
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY) &&
   30a7c:	f88d 8008 	strb.w	r8, [sp, #8]
   30a80:	a902      	add	r1, sp, #8
{
   30a82:	4614      	mov	r4, r2
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY) &&
   30a84:	f8ad 300a 	strh.w	r3, [sp, #10]
   30a88:	f01a fab8 	bl	4affc <bt_uuid_cmp>
   30a8c:	b1a0      	cbz	r0, 30ab8 <read_group_cb+0x50>
	    bt_uuid_cmp(attr->uuid, BT_UUID_GATT_SECONDARY)) {
   30a8e:	f642 0301 	movw	r3, #10241	; 0x2801
   30a92:	6828      	ldr	r0, [r5, #0]
   30a94:	f88d 800c 	strb.w	r8, [sp, #12]
   30a98:	a903      	add	r1, sp, #12
   30a9a:	f8ad 300e 	strh.w	r3, [sp, #14]
   30a9e:	f01a faad 	bl	4affc <bt_uuid_cmp>
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY) &&
   30aa2:	b148      	cbz	r0, 30ab8 <read_group_cb+0x50>
		if (data->group &&
   30aa4:	6923      	ldr	r3, [r4, #16]
   30aa6:	b11b      	cbz	r3, 30ab0 <read_group_cb+0x48>
   30aa8:	885a      	ldrh	r2, [r3, #2]
   30aaa:	42b2      	cmp	r2, r6
   30aac:	d200      	bcs.n	30ab0 <read_group_cb+0x48>
			data->group->end_handle = sys_cpu_to_le16(handle);
   30aae:	805e      	strh	r6, [r3, #2]
		return BT_GATT_ITER_CONTINUE;
   30ab0:	2001      	movs	r0, #1
}
   30ab2:	b004      	add	sp, #16
   30ab4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (bt_uuid_cmp(attr->uuid, data->uuid)) {
   30ab8:	6861      	ldr	r1, [r4, #4]
   30aba:	6828      	ldr	r0, [r5, #0]
   30abc:	f01a fa9e 	bl	4affc <bt_uuid_cmp>
   30ac0:	b110      	cbz	r0, 30ac8 <read_group_cb+0x60>
		data->group = NULL;
   30ac2:	2300      	movs	r3, #0
   30ac4:	6123      	str	r3, [r4, #16]
		return BT_GATT_ITER_CONTINUE;
   30ac6:	e7f3      	b.n	30ab0 <read_group_cb+0x48>
	if (data->rsp->len &&
   30ac8:	68e3      	ldr	r3, [r4, #12]
	    chan->chan.tx.mtu - data->buf->len < data->rsp->len) {
   30aca:	68a0      	ldr	r0, [r4, #8]
	if (data->rsp->len &&
   30acc:	781a      	ldrb	r2, [r3, #0]
   30ace:	b132      	cbz	r2, 30ade <read_group_cb+0x76>
	    chan->chan.tx.mtu - data->buf->len < data->rsp->len) {
   30ad0:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
   30ad2:	8981      	ldrh	r1, [r0, #12]
   30ad4:	1a5b      	subs	r3, r3, r1
	if (data->rsp->len &&
   30ad6:	4293      	cmp	r3, r2
   30ad8:	da01      	bge.n	30ade <read_group_cb+0x76>
		return BT_GATT_ITER_STOP;
   30ada:	2000      	movs	r0, #0
   30adc:	e7e9      	b.n	30ab2 <read_group_cb+0x4a>
	return net_buf_simple_add(&buf->b, len);
   30ade:	2104      	movs	r1, #4
   30ae0:	3008      	adds	r0, #8
   30ae2:	f01e f967 	bl	4edb4 <net_buf_simple_add>
	data->group = net_buf_add(data->buf, sizeof(*data->group));
   30ae6:	6120      	str	r0, [r4, #16]
	data->group->start_handle = sys_cpu_to_le16(handle);
   30ae8:	8006      	strh	r6, [r0, #0]
	data->group->end_handle = sys_cpu_to_le16(handle);
   30aea:	6923      	ldr	r3, [r4, #16]
   30aec:	805e      	strh	r6, [r3, #2]
	read = att_chan_read(chan, attr, data->buf, 0, attr_read_group_cb,
   30aee:	4b08      	ldr	r3, [pc, #32]	; (30b10 <read_group_cb+0xa8>)
   30af0:	9300      	str	r3, [sp, #0]
   30af2:	9401      	str	r4, [sp, #4]
   30af4:	68a2      	ldr	r2, [r4, #8]
   30af6:	2300      	movs	r3, #0
   30af8:	4629      	mov	r1, r5
   30afa:	4638      	mov	r0, r7
   30afc:	f01b fdb1 	bl	4c662 <att_chan_read>
	if (read < 0) {
   30b00:	2800      	cmp	r0, #0
   30b02:	dbea      	blt.n	30ada <read_group_cb+0x72>
	if (!data->group) {
   30b04:	6920      	ldr	r0, [r4, #16]
   30b06:	3800      	subs	r0, #0
   30b08:	bf18      	it	ne
   30b0a:	2001      	movne	r0, #1
   30b0c:	e7d1      	b.n	30ab2 <read_group_cb+0x4a>
   30b0e:	bf00      	nop
   30b10:	0004c611 	.word	0x0004c611

00030b14 <bt_att_accept>:

}
#endif /* CONFIG_BT_EATT */

static int bt_att_accept(struct bt_conn *conn, struct bt_l2cap_chan **ch)
{
   30b14:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	struct bt_att *att;
	struct bt_att_chan *chan;

	BT_DBG("conn %p handle %u", conn, conn->handle);

	if (k_mem_slab_alloc(&att_slab, (void **)&att, K_NO_WAIT)) {
   30b16:	2300      	movs	r3, #0
{
   30b18:	4604      	mov	r4, r0
   30b1a:	460e      	mov	r6, r1
	if (k_mem_slab_alloc(&att_slab, (void **)&att, K_NO_WAIT)) {
   30b1c:	4829      	ldr	r0, [pc, #164]	; (30bc4 <bt_att_accept+0xb0>)
   30b1e:	2200      	movs	r2, #0
   30b20:	4669      	mov	r1, sp
   30b22:	f016 f88d 	bl	46c40 <k_mem_slab_alloc>
   30b26:	4605      	mov	r5, r0
   30b28:	2800      	cmp	r0, #0
   30b2a:	d143      	bne.n	30bb4 <bt_att_accept+0xa0>
	return z_impl_z_current_get();
   30b2c:	f017 f84a 	bl	47bc4 <z_impl_z_current_get>
		BT_ERR("No available ATT context for conn %p", conn);
		return -ENOMEM;
	}

	att_handle_rsp_thread = k_current_get();
   30b30:	4b25      	ldr	r3, [pc, #148]	; (30bc8 <bt_att_accept+0xb4>)

	(void)memset(att, 0, sizeof(*att));
   30b32:	4629      	mov	r1, r5
	att_handle_rsp_thread = k_current_get();
   30b34:	6018      	str	r0, [r3, #0]
	(void)memset(att, 0, sizeof(*att));
   30b36:	222c      	movs	r2, #44	; 0x2c
   30b38:	9800      	ldr	r0, [sp, #0]
   30b3a:	f01a f9a9 	bl	4ae90 <memset>
	att->conn = conn;
   30b3e:	9b00      	ldr	r3, [sp, #0]
	if (k_mem_slab_alloc(&chan_slab, (void **)&chan, K_NO_WAIT)) {
   30b40:	4822      	ldr	r0, [pc, #136]	; (30bcc <bt_att_accept+0xb8>)
	att->conn = conn;
   30b42:	601c      	str	r4, [r3, #0]
	sys_slist_init(&att->reqs);
   30b44:	9c00      	ldr	r4, [sp, #0]
	SYS_SLIST_FOR_EACH_CONTAINER(&att->chans, chan, node) {
   30b46:	9501      	str	r5, [sp, #4]
	list->tail = NULL;
   30b48:	e9c4 5501 	strd	r5, r5, [r4, #4]
   30b4c:	e9c4 5509 	strd	r5, r5, [r4, #36]	; 0x24
	if (k_mem_slab_alloc(&chan_slab, (void **)&chan, K_NO_WAIT)) {
   30b50:	2200      	movs	r2, #0
   30b52:	2300      	movs	r3, #0
   30b54:	a901      	add	r1, sp, #4
   30b56:	f016 f873 	bl	46c40 <k_mem_slab_alloc>
   30b5a:	4605      	mov	r5, r0
   30b5c:	bb50      	cbnz	r0, 30bb4 <bt_att_accept+0xa0>
	(void)memset(chan, 0, sizeof(*chan));
   30b5e:	4601      	mov	r1, r0
   30b60:	22e8      	movs	r2, #232	; 0xe8
   30b62:	9801      	ldr	r0, [sp, #4]
   30b64:	f01a f994 	bl	4ae90 <memset>
	chan->chan.chan.ops = &ops;
   30b68:	9801      	ldr	r0, [sp, #4]
   30b6a:	4b19      	ldr	r3, [pc, #100]	; (30bd0 <bt_att_accept+0xbc>)
   30b6c:	6083      	str	r3, [r0, #8]
	z_impl_k_queue_init(queue);
   30b6e:	3098      	adds	r0, #152	; 0x98
   30b70:	f01f f902 	bl	4fd78 <z_impl_k_queue_init>
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   30b74:	9b01      	ldr	r3, [sp, #4]
   30b76:	f3bf 8f5b 	dmb	ish
   30b7a:	3390      	adds	r3, #144	; 0x90
   30b7c:	e853 2f00 	ldrex	r2, [r3]
   30b80:	e843 5100 	strex	r1, r5, [r3]
   30b84:	2900      	cmp	r1, #0
   30b86:	d1f9      	bne.n	30b7c <bt_att_accept+0x68>
   30b88:	f3bf 8f5b 	dmb	ish
	chan->att = att;
   30b8c:	9b01      	ldr	r3, [sp, #4]
   30b8e:	601c      	str	r4, [r3, #0]
	if (sys_slist_is_empty(&att->chans)) {
   30b90:	6a63      	ldr	r3, [r4, #36]	; 0x24
	att_chan_attach(att, chan);
   30b92:	9f01      	ldr	r7, [sp, #4]
	if (sys_slist_is_empty(&att->chans)) {
   30b94:	b91b      	cbnz	r3, 30b9e <bt_att_accept+0x8a>
   30b96:	f104 000c 	add.w	r0, r4, #12
   30b9a:	f01f f8ed 	bl	4fd78 <z_impl_k_queue_init>
	return list->head;
   30b9e:	6a62      	ldr	r2, [r4, #36]	; 0x24
	parent->next = child;
   30ba0:	f8c7 20e0 	str.w	r2, [r7, #224]	; 0xe0
Z_GENLIST_PREPEND(slist, snode)
   30ba4:	6aa2      	ldr	r2, [r4, #40]	; 0x28
	sys_slist_prepend(&att->chans, &chan->node);
   30ba6:	f107 03e0 	add.w	r3, r7, #224	; 0xe0
	list->head = node;
   30baa:	6263      	str	r3, [r4, #36]	; 0x24
Z_GENLIST_PREPEND(slist, snode)
   30bac:	b902      	cbnz	r2, 30bb0 <bt_att_accept+0x9c>
	list->tail = node;
   30bae:	62a3      	str	r3, [r4, #40]	; 0x28
	return chan;
   30bb0:	9b01      	ldr	r3, [sp, #4]
	k_work_init_delayable(&att->eatt.connection_work,
			      att_enhanced_connection_work_handler);
#endif /* CONFIG_BT_EATT */

	chan = att_chan_new(att, 0);
	if (!chan) {
   30bb2:	b923      	cbnz	r3, 30bbe <bt_att_accept+0xaa>
		return -ENOMEM;
   30bb4:	f06f 050b 	mvn.w	r5, #11
	}

	*ch = &chan->chan.chan;

	return 0;
}
   30bb8:	4628      	mov	r0, r5
   30bba:	b003      	add	sp, #12
   30bbc:	bdf0      	pop	{r4, r5, r6, r7, pc}
	*ch = &chan->chan.chan;
   30bbe:	3304      	adds	r3, #4
   30bc0:	6033      	str	r3, [r6, #0]
	return 0;
   30bc2:	e7f9      	b.n	30bb8 <bt_att_accept+0xa4>
   30bc4:	20001070 	.word	0x20001070
   30bc8:	20003f94 	.word	0x20003f94
   30bcc:	2000108c 	.word	0x2000108c
   30bd0:	200006a4 	.word	0x200006a4

00030bd4 <read_type_cb>:
{
   30bd4:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
	struct bt_att_chan *chan = data->chan;
   30bd8:	6817      	ldr	r7, [r2, #0]
{
   30bda:	4605      	mov	r5, r0
   30bdc:	4688      	mov	r8, r1
	if (bt_uuid_cmp(attr->uuid, data->uuid)) {
   30bde:	6800      	ldr	r0, [r0, #0]
   30be0:	6851      	ldr	r1, [r2, #4]
	struct bt_conn *conn = chan->chan.chan.conn;
   30be2:	687e      	ldr	r6, [r7, #4]
{
   30be4:	4614      	mov	r4, r2
	if (bt_uuid_cmp(attr->uuid, data->uuid)) {
   30be6:	f01a fa09 	bl	4affc <bt_uuid_cmp>
   30bea:	4681      	mov	r9, r0
   30bec:	2800      	cmp	r0, #0
   30bee:	d13c      	bne.n	30c6a <read_type_cb+0x96>
	data->err = bt_gatt_check_perm(conn, attr, BT_GATT_PERM_READ_MASK);
   30bf0:	4630      	mov	r0, r6
   30bf2:	2295      	movs	r2, #149	; 0x95
   30bf4:	4629      	mov	r1, r5
   30bf6:	f01c fd01 	bl	4d5fc <bt_gatt_check_perm>
   30bfa:	4606      	mov	r6, r0
   30bfc:	7520      	strb	r0, [r4, #20]
	if (data->err) {
   30bfe:	b140      	cbz	r0, 30c12 <read_type_cb+0x3e>
		if (data->rsp->len) {
   30c00:	68e3      	ldr	r3, [r4, #12]
   30c02:	781b      	ldrb	r3, [r3, #0]
   30c04:	b10b      	cbz	r3, 30c0a <read_type_cb+0x36>
			data->err = 0x00;
   30c06:	f884 9014 	strb.w	r9, [r4, #20]
		return BT_GATT_ITER_STOP;
   30c0a:	2000      	movs	r0, #0
}
   30c0c:	b003      	add	sp, #12
   30c0e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	data->item = net_buf_add(net_buf_frag_last(data->buf),
   30c12:	68a0      	ldr	r0, [r4, #8]
   30c14:	f01e f8a0 	bl	4ed58 <net_buf_frag_last>
   30c18:	2102      	movs	r1, #2
   30c1a:	3008      	adds	r0, #8
   30c1c:	f01e f8ca 	bl	4edb4 <net_buf_simple_add>
	read = att_chan_read(chan, attr, data->buf, 0, attr_read_type_cb, data);
   30c20:	4b13      	ldr	r3, [pc, #76]	; (30c70 <read_type_cb+0x9c>)
	data->item = net_buf_add(net_buf_frag_last(data->buf),
   30c22:	6120      	str	r0, [r4, #16]
	data->item->handle = sys_cpu_to_le16(handle);
   30c24:	f8a0 8000 	strh.w	r8, [r0]
	read = att_chan_read(chan, attr, data->buf, 0, attr_read_type_cb, data);
   30c28:	9300      	str	r3, [sp, #0]
   30c2a:	9401      	str	r4, [sp, #4]
   30c2c:	68a2      	ldr	r2, [r4, #8]
   30c2e:	4633      	mov	r3, r6
   30c30:	4629      	mov	r1, r5
   30c32:	4638      	mov	r0, r7
   30c34:	f01b fd15 	bl	4c662 <att_chan_read>
	if (read < 0) {
   30c38:	2800      	cmp	r0, #0
   30c3a:	da07      	bge.n	30c4c <read_type_cb+0x78>
	if (err < 0 && err >= -0xff) {
   30c3c:	f110 0fff 	cmn.w	r0, #255	; 0xff
		return -err;
   30c40:	bf26      	itte	cs
   30c42:	4240      	negcs	r0, r0
   30c44:	b2c0      	uxtbcs	r0, r0
	return BT_ATT_ERR_UNLIKELY;
   30c46:	200e      	movcc	r0, #14
		data->err = err_to_att(read);
   30c48:	7520      	strb	r0, [r4, #20]
		return BT_GATT_ITER_STOP;
   30c4a:	e7de      	b.n	30c0a <read_type_cb+0x36>
	if (!data->item) {
   30c4c:	6923      	ldr	r3, [r4, #16]
   30c4e:	2b00      	cmp	r3, #0
   30c50:	d0db      	beq.n	30c0a <read_type_cb+0x36>
	return chan->chan.tx.mtu - net_buf_frags_len(data->buf) >
   30c52:	68a0      	ldr	r0, [r4, #8]
   30c54:	f01b fb1b 	bl	4c28e <net_buf_frags_len>
   30c58:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
   30c5a:	1a18      	subs	r0, r3, r0
	       data->rsp->len ? BT_GATT_ITER_CONTINUE : BT_GATT_ITER_STOP;
   30c5c:	68e3      	ldr	r3, [r4, #12]
   30c5e:	781b      	ldrb	r3, [r3, #0]
   30c60:	4298      	cmp	r0, r3
   30c62:	bf94      	ite	ls
   30c64:	2000      	movls	r0, #0
   30c66:	2001      	movhi	r0, #1
   30c68:	e7d0      	b.n	30c0c <read_type_cb+0x38>
		return BT_GATT_ITER_CONTINUE;
   30c6a:	2001      	movs	r0, #1
   30c6c:	e7ce      	b.n	30c0c <read_type_cb+0x38>
   30c6e:	bf00      	nop
   30c70:	0004c29f 	.word	0x0004c29f

00030c74 <bt_att_connected>:
{
   30c74:	b510      	push	{r4, lr}
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   30c76:	f100 038c 	add.w	r3, r0, #140	; 0x8c
   30c7a:	4604      	mov	r4, r0
   30c7c:	f3bf 8f5b 	dmb	ish
   30c80:	e853 1f00 	ldrex	r1, [r3]
   30c84:	f041 0104 	orr.w	r1, r1, #4
   30c88:	e843 1200 	strex	r2, r1, [r3]
   30c8c:	2a00      	cmp	r2, #0
   30c8e:	d1f7      	bne.n	30c80 <bt_att_connected+0xc>
   30c90:	f3bf 8f5b 	dmb	ish
		le_chan->tx.mtu = BT_ATT_DEFAULT_LE_MTU;
   30c94:	2317      	movs	r3, #23
   30c96:	84e3      	strh	r3, [r4, #38]	; 0x26
		le_chan->rx.mtu = BT_ATT_DEFAULT_LE_MTU;
   30c98:	82e3      	strh	r3, [r4, #22]
	att_chan_mtu_updated(att_chan);
   30c9a:	1f20      	subs	r0, r4, #4
   30c9c:	f01b fb69 	bl	4c372 <att_chan_mtu_updated>
	k_work_init_delayable(&att_chan->timeout_work, att_timeout);
   30ca0:	f104 00ac 	add.w	r0, r4, #172	; 0xac
   30ca4:	4903      	ldr	r1, [pc, #12]	; (30cb4 <bt_att_connected+0x40>)
   30ca6:	f01f f9ad 	bl	50004 <k_work_init_delayable>
	bt_gatt_connected(le_chan->chan.conn);
   30caa:	6820      	ldr	r0, [r4, #0]
}
   30cac:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	bt_gatt_connected(le_chan->chan.conn);
   30cb0:	f002 b82a 	b.w	32d08 <bt_gatt_connected>
   30cb4:	0004cd4b 	.word	0x0004cd4b

00030cb8 <bt_att_chan_create_pdu>:
{
   30cb8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (len + sizeof(op) > chan->chan.tx.mtu) {
   30cba:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
   30cbc:	3201      	adds	r2, #1
   30cbe:	429a      	cmp	r2, r3
{
   30cc0:	460d      	mov	r5, r1
	if (len + sizeof(op) > chan->chan.tx.mtu) {
   30cc2:	d81b      	bhi.n	30cfc <bt_att_chan_create_pdu+0x44>
	switch (att_op_get_type(op)) {
   30cc4:	4608      	mov	r0, r1
   30cc6:	f7ff fe2d 	bl	30924 <att_op_get_type>
   30cca:	2802      	cmp	r0, #2
   30ccc:	d019      	beq.n	30d02 <bt_att_chan_create_pdu+0x4a>
   30cce:	2804      	cmp	r0, #4
   30cd0:	d017      	beq.n	30d02 <bt_att_chan_create_pdu+0x4a>
		timeout = K_FOREVER;
   30cd2:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
   30cd6:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
	buf = bt_l2cap_create_pdu_timeout(NULL, 0, timeout);
   30cda:	2100      	movs	r1, #0
   30cdc:	4632      	mov	r2, r6
   30cde:	463b      	mov	r3, r7
   30ce0:	4608      	mov	r0, r1
   30ce2:	f01b fa0c 	bl	4c0fe <bt_l2cap_create_pdu_timeout>
	if (!buf) {
   30ce6:	4604      	mov	r4, r0
   30ce8:	b140      	cbz	r0, 30cfc <bt_att_chan_create_pdu+0x44>
	return z_impl_k_queue_get(queue, timeout);
   30cea:	480c      	ldr	r0, [pc, #48]	; (30d1c <bt_att_chan_create_pdu+0x64>)
   30cec:	4632      	mov	r2, r6
   30cee:	463b      	mov	r3, r7
   30cf0:	f016 fa0e 	bl	47110 <z_impl_k_queue_get>
	if (!data) {
   30cf4:	b948      	cbnz	r0, 30d0a <bt_att_chan_create_pdu+0x52>
		net_buf_unref(buf);
   30cf6:	4620      	mov	r0, r4
   30cf8:	f011 fda6 	bl	42848 <net_buf_unref>
		return NULL;
   30cfc:	2400      	movs	r4, #0
}
   30cfe:	4620      	mov	r0, r4
   30d00:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	switch (att_op_get_type(op)) {
   30d02:	f44f 2670 	mov.w	r6, #983040	; 0xf0000
   30d06:	2700      	movs	r7, #0
   30d08:	e7e7      	b.n	30cda <bt_att_chan_create_pdu+0x22>
	bt_att_tx_meta_data(buf) = data;
   30d0a:	6160      	str	r0, [r4, #20]
   30d0c:	2101      	movs	r1, #1
   30d0e:	f104 0008 	add.w	r0, r4, #8
   30d12:	f01e f84f 	bl	4edb4 <net_buf_simple_add>
	hdr->code = op;
   30d16:	7005      	strb	r5, [r0, #0]
	return buf;
   30d18:	e7f1      	b.n	30cfe <bt_att_chan_create_pdu+0x46>
   30d1a:	bf00      	nop
   30d1c:	2000129c 	.word	0x2000129c

00030d20 <bt_att_recv>:
{
   30d20:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (buf->len < sizeof(*hdr)) {
   30d24:	898b      	ldrh	r3, [r1, #12]
{
   30d26:	4605      	mov	r5, r0
   30d28:	460c      	mov	r4, r1
	if (buf->len < sizeof(*hdr)) {
   30d2a:	2b00      	cmp	r3, #0
   30d2c:	d05d      	beq.n	30dea <bt_att_recv+0xca>
	return net_buf_simple_pull_mem(&buf->b, len);
   30d2e:	2101      	movs	r1, #1
   30d30:	f104 0008 	add.w	r0, r4, #8
   30d34:	f01e f86f 	bl	4ee16 <net_buf_simple_pull_mem>
	if (!att_chan->att) {
   30d38:	f855 3c04 	ldr.w	r3, [r5, #-4]
   30d3c:	4680      	mov	r8, r0
   30d3e:	2b00      	cmp	r3, #0
   30d40:	d053      	beq.n	30dea <bt_att_recv+0xca>
		if (hdr->code == handlers[i].op) {
   30d42:	7801      	ldrb	r1, [r0, #0]
   30d44:	4e2b      	ldr	r6, [pc, #172]	; (30df4 <bt_att_recv+0xd4>)
	struct bt_att_chan *att_chan = ATT_CHAN(chan);
   30d46:	1f2f      	subs	r7, r5, #4
	for (i = 0, handler = NULL; i < ARRAY_SIZE(handlers); i++) {
   30d48:	2300      	movs	r3, #0
		if (hdr->code == handlers[i].op) {
   30d4a:	f816 2033 	ldrb.w	r2, [r6, r3, lsl #3]
   30d4e:	428a      	cmp	r2, r1
   30d50:	ea4f 0ac3 	mov.w	sl, r3, lsl #3
   30d54:	eb06 0bc3 	add.w	fp, r6, r3, lsl #3
   30d58:	d11e      	bne.n	30d98 <bt_att_recv+0x78>
		if (handler->type == ATT_REQUEST &&
   30d5a:	f89b 9002 	ldrb.w	r9, [fp, #2]
   30d5e:	f1b9 0f01 	cmp.w	r9, #1
   30d62:	d129      	bne.n	30db8 <bt_att_recv+0x98>
		    atomic_test_and_set_bit(att_chan->flags, ATT_PENDING_RSP)) {
   30d64:	2100      	movs	r1, #0
   30d66:	f105 008c 	add.w	r0, r5, #140	; 0x8c
   30d6a:	f01b fe14 	bl	4c996 <atomic_test_and_set_bit>
		if (handler->type == ATT_REQUEST &&
   30d6e:	2800      	cmp	r0, #0
   30d70:	d13b      	bne.n	30dea <bt_att_recv+0xca>
	if (buf->len < handler->expect_len) {
   30d72:	89a2      	ldrh	r2, [r4, #12]
   30d74:	f89b 3001 	ldrb.w	r3, [fp, #1]
   30d78:	429a      	cmp	r2, r3
   30d7a:	d339      	bcc.n	30df0 <bt_att_recv+0xd0>
		err = handler->func(att_chan, buf);
   30d7c:	4456      	add	r6, sl
   30d7e:	4621      	mov	r1, r4
   30d80:	6873      	ldr	r3, [r6, #4]
   30d82:	4638      	mov	r0, r7
   30d84:	4798      	blx	r3
	if (handler->type == ATT_REQUEST && err) {
   30d86:	f1b9 0f01 	cmp.w	r9, #1
		err = handler->func(att_chan, buf);
   30d8a:	4603      	mov	r3, r0
	if (handler->type == ATT_REQUEST && err) {
   30d8c:	d12d      	bne.n	30dea <bt_att_recv+0xca>
   30d8e:	b360      	cbz	r0, 30dea <bt_att_recv+0xca>
		send_err_rsp(att_chan, hdr->code, 0, err);
   30d90:	f898 1000 	ldrb.w	r1, [r8]
	if (!req) {
   30d94:	b349      	cbz	r1, 30dea <bt_att_recv+0xca>
   30d96:	e00a      	b.n	30dae <bt_att_recv+0x8e>
	for (i = 0, handler = NULL; i < ARRAY_SIZE(handlers); i++) {
   30d98:	3301      	adds	r3, #1
   30d9a:	2b1e      	cmp	r3, #30
   30d9c:	d1d5      	bne.n	30d4a <bt_att_recv+0x2a>
		if (att_op_get_type(hdr->code) != ATT_COMMAND &&
   30d9e:	4608      	mov	r0, r1
   30da0:	f7ff fdc0 	bl	30924 <att_op_get_type>
   30da4:	b308      	cbz	r0, 30dea <bt_att_recv+0xca>
   30da6:	2805      	cmp	r0, #5
   30da8:	d01f      	beq.n	30dea <bt_att_recv+0xca>
	if (!req) {
   30daa:	b1f1      	cbz	r1, 30dea <bt_att_recv+0xca>
   30dac:	2306      	movs	r3, #6
   30dae:	2200      	movs	r2, #0
   30db0:	4638      	mov	r0, r7
   30db2:	f01b fe94 	bl	4cade <send_err_rsp.part.0>
   30db6:	e018      	b.n	30dea <bt_att_recv+0xca>
		} else if (handler->type == ATT_INDICATION &&
   30db8:	f1b9 0f05 	cmp.w	r9, #5
   30dbc:	d00a      	beq.n	30dd4 <bt_att_recv+0xb4>
	if (buf->len < handler->expect_len) {
   30dbe:	89a2      	ldrh	r2, [r4, #12]
   30dc0:	f89b 3001 	ldrb.w	r3, [fp, #1]
   30dc4:	429a      	cmp	r2, r3
   30dc6:	d310      	bcc.n	30dea <bt_att_recv+0xca>
		err = handler->func(att_chan, buf);
   30dc8:	f8db 3004 	ldr.w	r3, [fp, #4]
   30dcc:	4621      	mov	r1, r4
   30dce:	4638      	mov	r0, r7
   30dd0:	4798      	blx	r3
	if (handler->type == ATT_REQUEST && err) {
   30dd2:	e00a      	b.n	30dea <bt_att_recv+0xca>
			   atomic_test_and_set_bit(att_chan->flags,
   30dd4:	2101      	movs	r1, #1
   30dd6:	f105 008c 	add.w	r0, r5, #140	; 0x8c
   30dda:	f01b fddc 	bl	4c996 <atomic_test_and_set_bit>
		} else if (handler->type == ATT_INDICATION &&
   30dde:	b920      	cbnz	r0, 30dea <bt_att_recv+0xca>
	if (buf->len < handler->expect_len) {
   30de0:	f89b 2001 	ldrb.w	r2, [fp, #1]
   30de4:	89a3      	ldrh	r3, [r4, #12]
   30de6:	429a      	cmp	r2, r3
   30de8:	d9c8      	bls.n	30d7c <bt_att_recv+0x5c>
}
   30dea:	2000      	movs	r0, #0
   30dec:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		err = BT_ATT_ERR_INVALID_PDU;
   30df0:	2304      	movs	r3, #4
   30df2:	e7cd      	b.n	30d90 <bt_att_recv+0x70>
   30df4:	00051e50 	.word	0x00051e50

00030df8 <att_write_rsp.constprop.0>:
static uint8_t att_write_rsp(struct bt_att_chan *chan, uint8_t req, uint8_t rsp,
   30df8:	b5f0      	push	{r4, r5, r6, r7, lr}
   30dfa:	461e      	mov	r6, r3
	if (!bt_gatt_change_aware(chan->att->conn, req ? true : false)) {
   30dfc:	6803      	ldr	r3, [r0, #0]
   30dfe:	460d      	mov	r5, r1
   30e00:	3900      	subs	r1, #0
static uint8_t att_write_rsp(struct bt_att_chan *chan, uint8_t req, uint8_t rsp,
   30e02:	b087      	sub	sp, #28
   30e04:	4604      	mov	r4, r0
	if (!bt_gatt_change_aware(chan->att->conn, req ? true : false)) {
   30e06:	bf18      	it	ne
   30e08:	2101      	movne	r1, #1
   30e0a:	6818      	ldr	r0, [r3, #0]
static uint8_t att_write_rsp(struct bt_att_chan *chan, uint8_t req, uint8_t rsp,
   30e0c:	4617      	mov	r7, r2
	if (!bt_gatt_change_aware(chan->att->conn, req ? true : false)) {
   30e0e:	f01c ffcc 	bl	4ddaa <bt_gatt_change_aware>
   30e12:	b948      	cbnz	r0, 30e28 <att_write_rsp.constprop.0+0x30>
		if (!atomic_test_and_set_bit(chan->flags, ATT_OUT_OF_SYNC_SENT)) {
   30e14:	2105      	movs	r1, #5
   30e16:	f104 0090 	add.w	r0, r4, #144	; 0x90
   30e1a:	f01b fdbc 	bl	4c996 <atomic_test_and_set_bit>
   30e1e:	2800      	cmp	r0, #0
   30e20:	d048      	beq.n	30eb4 <att_write_rsp.constprop.0+0xbc>
			return 0;
   30e22:	2000      	movs	r0, #0
}
   30e24:	b007      	add	sp, #28
   30e26:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (!handle) {
   30e28:	2e00      	cmp	r6, #0
   30e2a:	d045      	beq.n	30eb8 <att_write_rsp.constprop.0+0xc0>
	(void)memset(&data, 0, sizeof(data));
   30e2c:	2218      	movs	r2, #24
   30e2e:	2100      	movs	r1, #0
   30e30:	4668      	mov	r0, sp
   30e32:	f01a f82d 	bl	4ae90 <memset>
	if (rsp) {
   30e36:	bb67      	cbnz	r7, 30e92 <att_write_rsp.constprop.0+0x9a>
	data.conn = chan->att->conn;
   30e38:	6823      	ldr	r3, [r4, #0]
	bt_gatt_foreach_attr(handle, handle, write_cb, &data);
   30e3a:	4a20      	ldr	r2, [pc, #128]	; (30ebc <att_write_rsp.constprop.0+0xc4>)
	data.conn = chan->att->conn;
   30e3c:	681b      	ldr	r3, [r3, #0]
   30e3e:	9300      	str	r3, [sp, #0]
	data.offset = offset;
   30e40:	2300      	movs	r3, #0
   30e42:	f8ad 3012 	strh.w	r3, [sp, #18]
	data.value = value;
   30e46:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   30e48:	9303      	str	r3, [sp, #12]
	data.len = len;
   30e4a:	f8bd 3034 	ldrh.w	r3, [sp, #52]	; 0x34
   30e4e:	f8ad 3010 	strh.w	r3, [sp, #16]
	data.err = BT_ATT_ERR_INVALID_HANDLE;
   30e52:	2301      	movs	r3, #1
   30e54:	f88d 3014 	strb.w	r3, [sp, #20]
	bt_gatt_foreach_attr(handle, handle, write_cb, &data);
   30e58:	4631      	mov	r1, r6
   30e5a:	466b      	mov	r3, sp
   30e5c:	4630      	mov	r0, r6
	data.req = req;
   30e5e:	f88d 5008 	strb.w	r5, [sp, #8]
	bt_gatt_foreach_attr(handle, handle, write_cb, &data);
   30e62:	f01b faea 	bl	4c43a <bt_gatt_foreach_attr>
	if (data.err) {
   30e66:	f89d 3014 	ldrb.w	r3, [sp, #20]
   30e6a:	b1e3      	cbz	r3, 30ea6 <att_write_rsp.constprop.0+0xae>
		if (rsp) {
   30e6c:	2f00      	cmp	r7, #0
   30e6e:	d0d8      	beq.n	30e22 <att_write_rsp.constprop.0+0x2a>
			tx_meta_data_free(bt_att_tx_meta_data(data.buf));
   30e70:	9b01      	ldr	r3, [sp, #4]
   30e72:	6958      	ldr	r0, [r3, #20]
   30e74:	f7ff fd9c 	bl	309b0 <tx_meta_data_free>
			net_buf_unref(data.buf);
   30e78:	9801      	ldr	r0, [sp, #4]
   30e7a:	f011 fce5 	bl	42848 <net_buf_unref>
			send_err_rsp(chan, req, handle, data.err);
   30e7e:	f89d 3014 	ldrb.w	r3, [sp, #20]
	if (!req) {
   30e82:	2d00      	cmp	r5, #0
   30e84:	d0cd      	beq.n	30e22 <att_write_rsp.constprop.0+0x2a>
   30e86:	4632      	mov	r2, r6
   30e88:	4629      	mov	r1, r5
   30e8a:	4620      	mov	r0, r4
   30e8c:	f01b fe27 	bl	4cade <send_err_rsp.part.0>
   30e90:	e7c7      	b.n	30e22 <att_write_rsp.constprop.0+0x2a>
		data.buf = bt_att_chan_create_pdu(chan, rsp, 0);
   30e92:	2200      	movs	r2, #0
   30e94:	4639      	mov	r1, r7
   30e96:	4620      	mov	r0, r4
   30e98:	f7ff ff0e 	bl	30cb8 <bt_att_chan_create_pdu>
   30e9c:	9001      	str	r0, [sp, #4]
		if (!data.buf) {
   30e9e:	2800      	cmp	r0, #0
   30ea0:	d1ca      	bne.n	30e38 <att_write_rsp.constprop.0+0x40>
			return BT_ATT_ERR_UNLIKELY;
   30ea2:	200e      	movs	r0, #14
   30ea4:	e7be      	b.n	30e24 <att_write_rsp.constprop.0+0x2c>
	if (data.buf) {
   30ea6:	9901      	ldr	r1, [sp, #4]
   30ea8:	2900      	cmp	r1, #0
   30eaa:	d0ba      	beq.n	30e22 <att_write_rsp.constprop.0+0x2a>
		bt_att_chan_send_rsp(chan, data.buf);
   30eac:	4620      	mov	r0, r4
   30eae:	f01b fa52 	bl	4c356 <bt_att_chan_send_rsp>
   30eb2:	e7b6      	b.n	30e22 <att_write_rsp.constprop.0+0x2a>
			return BT_ATT_ERR_DB_OUT_OF_SYNC;
   30eb4:	2012      	movs	r0, #18
   30eb6:	e7b5      	b.n	30e24 <att_write_rsp.constprop.0+0x2c>
		return BT_ATT_ERR_INVALID_HANDLE;
   30eb8:	2001      	movs	r0, #1
   30eba:	e7b3      	b.n	30e24 <att_write_rsp.constprop.0+0x2c>
   30ebc:	0004c3d9 	.word	0x0004c3d9

00030ec0 <att_read_group_req>:
{
   30ec0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint8_t uuid_len = buf->len - sizeof(*req);
   30ec4:	898e      	ldrh	r6, [r1, #12]
   30ec6:	3e04      	subs	r6, #4
   30ec8:	b2f6      	uxtb	r6, r6
	if (uuid_len != 2 && uuid_len != 16) {
   30eca:	2e02      	cmp	r6, #2
{
   30ecc:	4604      	mov	r4, r0
   30ece:	b08c      	sub	sp, #48	; 0x30
   30ed0:	4608      	mov	r0, r1
	if (uuid_len != 2 && uuid_len != 16) {
   30ed2:	d001      	beq.n	30ed8 <att_read_group_req+0x18>
   30ed4:	2e10      	cmp	r6, #16
   30ed6:	d16a      	bne.n	30fae <att_read_group_req+0xee>
   30ed8:	2104      	movs	r1, #4
   30eda:	3008      	adds	r0, #8
   30edc:	f01d ff9b 	bl	4ee16 <net_buf_simple_pull_mem>
	if (!bt_uuid_create(&u.uuid, req->uuid, uuid_len)) {
   30ee0:	f10d 0808 	add.w	r8, sp, #8
	start_handle = sys_le16_to_cpu(req->start_handle);
   30ee4:	8805      	ldrh	r5, [r0, #0]
	end_handle = sys_le16_to_cpu(req->end_handle);
   30ee6:	8847      	ldrh	r7, [r0, #2]
	if (!bt_uuid_create(&u.uuid, req->uuid, uuid_len)) {
   30ee8:	1d01      	adds	r1, r0, #4
   30eea:	4632      	mov	r2, r6
   30eec:	4640      	mov	r0, r8
   30eee:	f01a f8b3 	bl	4b058 <bt_uuid_create>
   30ef2:	2800      	cmp	r0, #0
   30ef4:	d05d      	beq.n	30fb2 <att_read_group_req+0xf2>
	if (!start || !end) {
   30ef6:	2d00      	cmp	r5, #0
   30ef8:	d03a      	beq.n	30f70 <att_read_group_req+0xb0>
   30efa:	2600      	movs	r6, #0
   30efc:	2f00      	cmp	r7, #0
   30efe:	d036      	beq.n	30f6e <att_read_group_req+0xae>
	if (start > end) {
   30f00:	42bd      	cmp	r5, r7
   30f02:	d835      	bhi.n	30f70 <att_read_group_req+0xb0>
	if (bt_uuid_cmp(&u.uuid, BT_UUID_GATT_PRIMARY) &&
   30f04:	f44f 5320 	mov.w	r3, #10240	; 0x2800
   30f08:	a901      	add	r1, sp, #4
   30f0a:	4640      	mov	r0, r8
   30f0c:	f88d 6004 	strb.w	r6, [sp, #4]
   30f10:	f8ad 3006 	strh.w	r3, [sp, #6]
   30f14:	f01a f872 	bl	4affc <bt_uuid_cmp>
   30f18:	bb70      	cbnz	r0, 30f78 <att_read_group_req+0xb8>
	struct bt_conn *conn = chan->chan.chan.conn;
   30f1a:	6866      	ldr	r6, [r4, #4]
	(void)memset(&data, 0, sizeof(data));
   30f1c:	2214      	movs	r2, #20
   30f1e:	2100      	movs	r1, #0
   30f20:	a807      	add	r0, sp, #28
   30f22:	f019 ffb5 	bl	4ae90 <memset>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_GROUP_RSP,
   30f26:	2201      	movs	r2, #1
   30f28:	2111      	movs	r1, #17
   30f2a:	4630      	mov	r0, r6
   30f2c:	f01b fe1a 	bl	4cb64 <bt_att_create_pdu>
   30f30:	9009      	str	r0, [sp, #36]	; 0x24
	if (!data.buf) {
   30f32:	2800      	cmp	r0, #0
   30f34:	d03d      	beq.n	30fb2 <att_read_group_req+0xf2>
	return net_buf_simple_add(&buf->b, len);
   30f36:	2101      	movs	r1, #1
   30f38:	3008      	adds	r0, #8
	data.uuid = uuid;
   30f3a:	e9cd 4807 	strd	r4, r8, [sp, #28]
   30f3e:	f01d ff39 	bl	4edb4 <net_buf_simple_add>
	data.rsp->len = 0U;
   30f42:	2300      	movs	r3, #0
	data.rsp = net_buf_add(data.buf, sizeof(*data.rsp));
   30f44:	900a      	str	r0, [sp, #40]	; 0x28
	bt_gatt_foreach_attr(start_handle, end_handle, read_group_cb, &data);
   30f46:	4a1c      	ldr	r2, [pc, #112]	; (30fb8 <att_read_group_req+0xf8>)
	data.rsp->len = 0U;
   30f48:	7003      	strb	r3, [r0, #0]
	bt_gatt_foreach_attr(start_handle, end_handle, read_group_cb, &data);
   30f4a:	4639      	mov	r1, r7
	data.group = NULL;
   30f4c:	930b      	str	r3, [sp, #44]	; 0x2c
	bt_gatt_foreach_attr(start_handle, end_handle, read_group_cb, &data);
   30f4e:	4628      	mov	r0, r5
   30f50:	ab07      	add	r3, sp, #28
   30f52:	f01b fa72 	bl	4c43a <bt_gatt_foreach_attr>
	if (!data.rsp->len) {
   30f56:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   30f58:	781b      	ldrb	r3, [r3, #0]
   30f5a:	bb1b      	cbnz	r3, 30fa4 <att_read_group_req+0xe4>
		tx_meta_data_free(bt_att_tx_meta_data(data.buf));
   30f5c:	9b09      	ldr	r3, [sp, #36]	; 0x24
   30f5e:	6958      	ldr	r0, [r3, #20]
   30f60:	f7ff fd26 	bl	309b0 <tx_meta_data_free>
		net_buf_unref(data.buf);
   30f64:	9809      	ldr	r0, [sp, #36]	; 0x24
   30f66:	f011 fc6f 	bl	42848 <net_buf_unref>
	if (!req) {
   30f6a:	230a      	movs	r3, #10
   30f6c:	e001      	b.n	30f72 <att_read_group_req+0xb2>
			*err = 0U;
   30f6e:	463d      	mov	r5, r7
	if (!req) {
   30f70:	2301      	movs	r3, #1
   30f72:	462a      	mov	r2, r5
   30f74:	2110      	movs	r1, #16
   30f76:	e00e      	b.n	30f96 <att_read_group_req+0xd6>
	    bt_uuid_cmp(&u.uuid, BT_UUID_GATT_SECONDARY)) {
   30f78:	f642 0301 	movw	r3, #10241	; 0x2801
   30f7c:	a907      	add	r1, sp, #28
   30f7e:	4640      	mov	r0, r8
   30f80:	f88d 601c 	strb.w	r6, [sp, #28]
   30f84:	f8ad 301e 	strh.w	r3, [sp, #30]
   30f88:	f01a f838 	bl	4affc <bt_uuid_cmp>
	if (bt_uuid_cmp(&u.uuid, BT_UUID_GATT_PRIMARY) &&
   30f8c:	2800      	cmp	r0, #0
   30f8e:	d0c4      	beq.n	30f1a <att_read_group_req+0x5a>
	if (!req) {
   30f90:	2310      	movs	r3, #16
   30f92:	462a      	mov	r2, r5
   30f94:	4619      	mov	r1, r3
   30f96:	4620      	mov	r0, r4
   30f98:	f01b fda1 	bl	4cade <send_err_rsp.part.0>
		return 0;
   30f9c:	2000      	movs	r0, #0
}
   30f9e:	b00c      	add	sp, #48	; 0x30
   30fa0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	bt_att_chan_send_rsp(chan, data.buf);
   30fa4:	9909      	ldr	r1, [sp, #36]	; 0x24
   30fa6:	4620      	mov	r0, r4
   30fa8:	f01b f9d5 	bl	4c356 <bt_att_chan_send_rsp>
	return 0;
   30fac:	e7f6      	b.n	30f9c <att_read_group_req+0xdc>
		return BT_ATT_ERR_INVALID_PDU;
   30fae:	2004      	movs	r0, #4
   30fb0:	e7f5      	b.n	30f9e <att_read_group_req+0xde>
		return BT_ATT_ERR_UNLIKELY;
   30fb2:	200e      	movs	r0, #14
   30fb4:	e7f3      	b.n	30f9e <att_read_group_req+0xde>
   30fb6:	bf00      	nop
   30fb8:	00030a69 	.word	0x00030a69

00030fbc <att_read_mult_vl_req>:
{
   30fbc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	struct bt_conn *conn = chan->chan.chan.conn;
   30fc0:	6846      	ldr	r6, [r0, #4]
{
   30fc2:	b085      	sub	sp, #20
   30fc4:	4604      	mov	r4, r0
   30fc6:	460d      	mov	r5, r1
	if (!bt_gatt_change_aware(conn, true)) {
   30fc8:	4630      	mov	r0, r6
   30fca:	2101      	movs	r1, #1
   30fcc:	f01c feed 	bl	4ddaa <bt_gatt_change_aware>
   30fd0:	b950      	cbnz	r0, 30fe8 <att_read_mult_vl_req+0x2c>
		if (!atomic_test_and_set_bit(chan->flags, ATT_OUT_OF_SYNC_SENT)) {
   30fd2:	2105      	movs	r1, #5
   30fd4:	f104 0090 	add.w	r0, r4, #144	; 0x90
   30fd8:	f01b fcdd 	bl	4c996 <atomic_test_and_set_bit>
   30fdc:	2800      	cmp	r0, #0
   30fde:	d13b      	bne.n	31058 <att_read_mult_vl_req+0x9c>
			return BT_ATT_ERR_DB_OUT_OF_SYNC;
   30fe0:	2012      	movs	r0, #18
}
   30fe2:	b005      	add	sp, #20
   30fe4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	(void)memset(&data, 0, sizeof(data));
   30fe8:	2210      	movs	r2, #16
   30fea:	2100      	movs	r1, #0
   30fec:	4668      	mov	r0, sp
   30fee:	f019 ff4f 	bl	4ae90 <memset>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_MULT_VL_RSP, 0);
   30ff2:	2200      	movs	r2, #0
   30ff4:	2121      	movs	r1, #33	; 0x21
   30ff6:	4630      	mov	r0, r6
   30ff8:	f01b fdb4 	bl	4cb64 <bt_att_create_pdu>
   30ffc:	9002      	str	r0, [sp, #8]
	if (!data.buf) {
   30ffe:	b368      	cbz	r0, 3105c <att_read_mult_vl_req+0xa0>
		bt_gatt_foreach_attr(handle, handle, read_vl_cb, &data);
   31000:	f8df 905c 	ldr.w	r9, [pc, #92]	; 31060 <att_read_mult_vl_req+0xa4>
	data.chan = chan;
   31004:	9400      	str	r4, [sp, #0]
	return net_buf_simple_pull_le16(&buf->b);
   31006:	f105 0708 	add.w	r7, r5, #8
		data.err = BT_ATT_ERR_INVALID_HANDLE;
   3100a:	f04f 0801 	mov.w	r8, #1
	while (buf->len >= sizeof(uint16_t)) {
   3100e:	89ab      	ldrh	r3, [r5, #12]
   31010:	2b01      	cmp	r3, #1
   31012:	d804      	bhi.n	3101e <att_read_mult_vl_req+0x62>
	bt_att_chan_send_rsp(chan, data.buf);
   31014:	9902      	ldr	r1, [sp, #8]
   31016:	4620      	mov	r0, r4
   31018:	f01b f99d 	bl	4c356 <bt_att_chan_send_rsp>
	return 0;
   3101c:	e01c      	b.n	31058 <att_read_mult_vl_req+0x9c>
   3101e:	4638      	mov	r0, r7
   31020:	f01d ff09 	bl	4ee36 <net_buf_simple_pull_le16>
		bt_gatt_foreach_attr(handle, handle, read_vl_cb, &data);
   31024:	466b      	mov	r3, sp
   31026:	464a      	mov	r2, r9
   31028:	4601      	mov	r1, r0
   3102a:	4606      	mov	r6, r0
		data.err = BT_ATT_ERR_INVALID_HANDLE;
   3102c:	f88d 800c 	strb.w	r8, [sp, #12]
		bt_gatt_foreach_attr(handle, handle, read_vl_cb, &data);
   31030:	f01b fa03 	bl	4c43a <bt_gatt_foreach_attr>
		if (data.err) {
   31034:	f89d 300c 	ldrb.w	r3, [sp, #12]
   31038:	2b00      	cmp	r3, #0
   3103a:	d0e8      	beq.n	3100e <att_read_mult_vl_req+0x52>
			tx_meta_data_free(bt_att_tx_meta_data(data.buf));
   3103c:	9b02      	ldr	r3, [sp, #8]
   3103e:	6958      	ldr	r0, [r3, #20]
   31040:	f7ff fcb6 	bl	309b0 <tx_meta_data_free>
			net_buf_unref(data.buf);
   31044:	9802      	ldr	r0, [sp, #8]
   31046:	f011 fbff 	bl	42848 <net_buf_unref>
	if (!req) {
   3104a:	f89d 300c 	ldrb.w	r3, [sp, #12]
   3104e:	4632      	mov	r2, r6
   31050:	2120      	movs	r1, #32
   31052:	4620      	mov	r0, r4
   31054:	f01b fd43 	bl	4cade <send_err_rsp.part.0>
			return 0;
   31058:	2000      	movs	r0, #0
   3105a:	e7c2      	b.n	30fe2 <att_read_mult_vl_req+0x26>
		return BT_ATT_ERR_UNLIKELY;
   3105c:	200e      	movs	r0, #14
   3105e:	e7c0      	b.n	30fe2 <att_read_mult_vl_req+0x26>
   31060:	0004c7f5 	.word	0x0004c7f5

00031064 <att_read_mult_req>:
{
   31064:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	struct bt_conn *conn = chan->chan.chan.conn;
   31068:	6846      	ldr	r6, [r0, #4]
{
   3106a:	b085      	sub	sp, #20
   3106c:	4604      	mov	r4, r0
   3106e:	460d      	mov	r5, r1
	if (!bt_gatt_change_aware(conn, true)) {
   31070:	4630      	mov	r0, r6
   31072:	2101      	movs	r1, #1
   31074:	f01c fe99 	bl	4ddaa <bt_gatt_change_aware>
   31078:	b950      	cbnz	r0, 31090 <att_read_mult_req+0x2c>
		if (!atomic_test_and_set_bit(chan->flags, ATT_OUT_OF_SYNC_SENT)) {
   3107a:	2105      	movs	r1, #5
   3107c:	f104 0090 	add.w	r0, r4, #144	; 0x90
   31080:	f01b fc89 	bl	4c996 <atomic_test_and_set_bit>
   31084:	2800      	cmp	r0, #0
   31086:	d13b      	bne.n	31100 <att_read_mult_req+0x9c>
			return BT_ATT_ERR_DB_OUT_OF_SYNC;
   31088:	2012      	movs	r0, #18
}
   3108a:	b005      	add	sp, #20
   3108c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	(void)memset(&data, 0, sizeof(data));
   31090:	2210      	movs	r2, #16
   31092:	2100      	movs	r1, #0
   31094:	4668      	mov	r0, sp
   31096:	f019 fefb 	bl	4ae90 <memset>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_MULT_RSP, 0);
   3109a:	2200      	movs	r2, #0
   3109c:	210f      	movs	r1, #15
   3109e:	4630      	mov	r0, r6
   310a0:	f01b fd60 	bl	4cb64 <bt_att_create_pdu>
   310a4:	9002      	str	r0, [sp, #8]
	if (!data.buf) {
   310a6:	b368      	cbz	r0, 31104 <att_read_mult_req+0xa0>
		bt_gatt_foreach_attr(handle, handle, read_cb, &data);
   310a8:	f8df 905c 	ldr.w	r9, [pc, #92]	; 31108 <att_read_mult_req+0xa4>
	data.chan = chan;
   310ac:	9400      	str	r4, [sp, #0]
   310ae:	f105 0708 	add.w	r7, r5, #8
		data.err = BT_ATT_ERR_INVALID_HANDLE;
   310b2:	f04f 0801 	mov.w	r8, #1
	while (buf->len >= sizeof(uint16_t)) {
   310b6:	89ab      	ldrh	r3, [r5, #12]
   310b8:	2b01      	cmp	r3, #1
   310ba:	d804      	bhi.n	310c6 <att_read_mult_req+0x62>
	bt_att_chan_send_rsp(chan, data.buf);
   310bc:	9902      	ldr	r1, [sp, #8]
   310be:	4620      	mov	r0, r4
   310c0:	f01b f949 	bl	4c356 <bt_att_chan_send_rsp>
	return 0;
   310c4:	e01c      	b.n	31100 <att_read_mult_req+0x9c>
   310c6:	4638      	mov	r0, r7
   310c8:	f01d feb5 	bl	4ee36 <net_buf_simple_pull_le16>
		bt_gatt_foreach_attr(handle, handle, read_cb, &data);
   310cc:	466b      	mov	r3, sp
   310ce:	464a      	mov	r2, r9
   310d0:	4601      	mov	r1, r0
   310d2:	4606      	mov	r6, r0
		data.err = BT_ATT_ERR_INVALID_HANDLE;
   310d4:	f88d 800c 	strb.w	r8, [sp, #12]
		bt_gatt_foreach_attr(handle, handle, read_cb, &data);
   310d8:	f01b f9af 	bl	4c43a <bt_gatt_foreach_attr>
		if (data.err) {
   310dc:	f89d 300c 	ldrb.w	r3, [sp, #12]
   310e0:	2b00      	cmp	r3, #0
   310e2:	d0e8      	beq.n	310b6 <att_read_mult_req+0x52>
			tx_meta_data_free(bt_att_tx_meta_data(data.buf));
   310e4:	9b02      	ldr	r3, [sp, #8]
   310e6:	6958      	ldr	r0, [r3, #20]
   310e8:	f7ff fc62 	bl	309b0 <tx_meta_data_free>
			net_buf_unref(data.buf);
   310ec:	9802      	ldr	r0, [sp, #8]
   310ee:	f011 fbab 	bl	42848 <net_buf_unref>
	if (!req) {
   310f2:	f89d 300c 	ldrb.w	r3, [sp, #12]
   310f6:	4632      	mov	r2, r6
   310f8:	210e      	movs	r1, #14
   310fa:	4620      	mov	r0, r4
   310fc:	f01b fcef 	bl	4cade <send_err_rsp.part.0>
			return 0;
   31100:	2000      	movs	r0, #0
   31102:	e7c2      	b.n	3108a <att_read_mult_req+0x26>
		return BT_ATT_ERR_UNLIKELY;
   31104:	200e      	movs	r0, #14
   31106:	e7c0      	b.n	3108a <att_read_mult_req+0x26>
   31108:	0004c7af 	.word	0x0004c7af

0003110c <att_read_rsp>:
{
   3110c:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	struct bt_conn *conn = chan->chan.chan.conn;
   31110:	f8d0 8004 	ldr.w	r8, [r0, #4]
{
   31114:	4604      	mov	r4, r0
   31116:	460e      	mov	r6, r1
	if (!bt_gatt_change_aware(conn, true)) {
   31118:	4640      	mov	r0, r8
   3111a:	2101      	movs	r1, #1
{
   3111c:	4617      	mov	r7, r2
   3111e:	461d      	mov	r5, r3
	if (!bt_gatt_change_aware(conn, true)) {
   31120:	f01c fe43 	bl	4ddaa <bt_gatt_change_aware>
   31124:	b948      	cbnz	r0, 3113a <att_read_rsp+0x2e>
		if (!atomic_test_and_set_bit(chan->flags, ATT_OUT_OF_SYNC_SENT)) {
   31126:	2105      	movs	r1, #5
   31128:	f104 0090 	add.w	r0, r4, #144	; 0x90
   3112c:	f01b fc33 	bl	4c996 <atomic_test_and_set_bit>
   31130:	bb78      	cbnz	r0, 31192 <att_read_rsp+0x86>
			return BT_ATT_ERR_DB_OUT_OF_SYNC;
   31132:	2012      	movs	r0, #18
}
   31134:	b004      	add	sp, #16
   31136:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (!handle) {
   3113a:	b38d      	cbz	r5, 311a0 <att_read_rsp+0x94>
	(void)memset(&data, 0, sizeof(data));
   3113c:	2210      	movs	r2, #16
   3113e:	2100      	movs	r1, #0
   31140:	4668      	mov	r0, sp
   31142:	f019 fea5 	bl	4ae90 <memset>
	data.buf = bt_att_create_pdu(conn, rsp, 0);
   31146:	2200      	movs	r2, #0
   31148:	4639      	mov	r1, r7
   3114a:	4640      	mov	r0, r8
   3114c:	f01b fd0a 	bl	4cb64 <bt_att_create_pdu>
   31150:	9002      	str	r0, [sp, #8]
	if (!data.buf) {
   31152:	b338      	cbz	r0, 311a4 <att_read_rsp+0x98>
	data.offset = offset;
   31154:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
   31158:	f8ad 3004 	strh.w	r3, [sp, #4]
	data.err = BT_ATT_ERR_INVALID_HANDLE;
   3115c:	2301      	movs	r3, #1
   3115e:	f88d 300c 	strb.w	r3, [sp, #12]
	bt_gatt_foreach_attr(handle, handle, read_cb, &data);
   31162:	4a11      	ldr	r2, [pc, #68]	; (311a8 <att_read_rsp+0x9c>)
	data.chan = chan;
   31164:	9400      	str	r4, [sp, #0]
	bt_gatt_foreach_attr(handle, handle, read_cb, &data);
   31166:	466b      	mov	r3, sp
   31168:	4629      	mov	r1, r5
   3116a:	4628      	mov	r0, r5
   3116c:	f01b f965 	bl	4c43a <bt_gatt_foreach_attr>
	if (data.err) {
   31170:	f89d 300c 	ldrb.w	r3, [sp, #12]
   31174:	b17b      	cbz	r3, 31196 <att_read_rsp+0x8a>
		tx_meta_data_free(bt_att_tx_meta_data(data.buf));
   31176:	9b02      	ldr	r3, [sp, #8]
   31178:	6958      	ldr	r0, [r3, #20]
   3117a:	f7ff fc19 	bl	309b0 <tx_meta_data_free>
		net_buf_unref(data.buf);
   3117e:	9802      	ldr	r0, [sp, #8]
   31180:	f011 fb62 	bl	42848 <net_buf_unref>
	if (!req) {
   31184:	f89d 300c 	ldrb.w	r3, [sp, #12]
   31188:	462a      	mov	r2, r5
   3118a:	4631      	mov	r1, r6
   3118c:	4620      	mov	r0, r4
   3118e:	f01b fca6 	bl	4cade <send_err_rsp.part.0>
			return 0;
   31192:	2000      	movs	r0, #0
   31194:	e7ce      	b.n	31134 <att_read_rsp+0x28>
	bt_att_chan_send_rsp(chan, data.buf);
   31196:	9902      	ldr	r1, [sp, #8]
   31198:	4620      	mov	r0, r4
   3119a:	f01b f8dc 	bl	4c356 <bt_att_chan_send_rsp>
	return 0;
   3119e:	e7f8      	b.n	31192 <att_read_rsp+0x86>
		return BT_ATT_ERR_INVALID_HANDLE;
   311a0:	2001      	movs	r0, #1
   311a2:	e7c7      	b.n	31134 <att_read_rsp+0x28>
		return BT_ATT_ERR_UNLIKELY;
   311a4:	200e      	movs	r0, #14
   311a6:	e7c5      	b.n	31134 <att_read_rsp+0x28>
   311a8:	0004c7af 	.word	0x0004c7af

000311ac <att_read_type_req>:
{
   311ac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint8_t uuid_len = buf->len - sizeof(*req);
   311b0:	898d      	ldrh	r5, [r1, #12]
   311b2:	3d04      	subs	r5, #4
   311b4:	b2ed      	uxtb	r5, r5
	if (uuid_len != 2 && uuid_len != 16) {
   311b6:	2d02      	cmp	r5, #2
{
   311b8:	4604      	mov	r4, r0
   311ba:	b08c      	sub	sp, #48	; 0x30
   311bc:	4608      	mov	r0, r1
	if (uuid_len != 2 && uuid_len != 16) {
   311be:	d001      	beq.n	311c4 <att_read_type_req+0x18>
   311c0:	2d10      	cmp	r5, #16
   311c2:	d150      	bne.n	31266 <att_read_type_req+0xba>
	return net_buf_simple_pull_mem(&buf->b, len);
   311c4:	2104      	movs	r1, #4
   311c6:	3008      	adds	r0, #8
   311c8:	f01d fe25 	bl	4ee16 <net_buf_simple_pull_mem>
	if (!bt_uuid_create(&u.uuid, req->uuid, uuid_len)) {
   311cc:	f10d 0804 	add.w	r8, sp, #4
	start_handle = sys_le16_to_cpu(req->start_handle);
   311d0:	8806      	ldrh	r6, [r0, #0]
	end_handle = sys_le16_to_cpu(req->end_handle);
   311d2:	8847      	ldrh	r7, [r0, #2]
	if (!bt_uuid_create(&u.uuid, req->uuid, uuid_len)) {
   311d4:	1d01      	adds	r1, r0, #4
   311d6:	462a      	mov	r2, r5
   311d8:	4640      	mov	r0, r8
   311da:	f019 ff3d 	bl	4b058 <bt_uuid_create>
   311de:	b188      	cbz	r0, 31204 <att_read_type_req+0x58>
	if (!start || !end) {
   311e0:	b19e      	cbz	r6, 3120a <att_read_type_req+0x5e>
   311e2:	b18f      	cbz	r7, 31208 <att_read_type_req+0x5c>
	if (start > end) {
   311e4:	42b7      	cmp	r7, r6
   311e6:	d310      	bcc.n	3120a <att_read_type_req+0x5e>
	(void)memset(&data, 0, sizeof(data));
   311e8:	2218      	movs	r2, #24
	struct bt_conn *conn = chan->chan.chan.conn;
   311ea:	6865      	ldr	r5, [r4, #4]
	(void)memset(&data, 0, sizeof(data));
   311ec:	2100      	movs	r1, #0
   311ee:	eb0d 0002 	add.w	r0, sp, r2
   311f2:	f019 fe4d 	bl	4ae90 <memset>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_TYPE_RSP,
   311f6:	2201      	movs	r2, #1
   311f8:	2109      	movs	r1, #9
   311fa:	4628      	mov	r0, r5
   311fc:	f01b fcb2 	bl	4cb64 <bt_att_create_pdu>
   31200:	9008      	str	r0, [sp, #32]
	if (!data.buf) {
   31202:	b960      	cbnz	r0, 3121e <att_read_type_req+0x72>
		return BT_ATT_ERR_UNLIKELY;
   31204:	200e      	movs	r0, #14
   31206:	e007      	b.n	31218 <att_read_type_req+0x6c>
			*err = 0U;
   31208:	463e      	mov	r6, r7
	if (!req) {
   3120a:	2301      	movs	r3, #1
   3120c:	4632      	mov	r2, r6
   3120e:	2108      	movs	r1, #8
   31210:	4620      	mov	r0, r4
   31212:	f01b fc64 	bl	4cade <send_err_rsp.part.0>
		return 0;
   31216:	2000      	movs	r0, #0
}
   31218:	b00c      	add	sp, #48	; 0x30
   3121a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	return net_buf_simple_add(&buf->b, len);
   3121e:	2101      	movs	r1, #1
   31220:	3008      	adds	r0, #8
	data.uuid = uuid;
   31222:	e9cd 4806 	strd	r4, r8, [sp, #24]
   31226:	f01d fdc5 	bl	4edb4 <net_buf_simple_add>
	data.rsp->len = 0U;
   3122a:	2300      	movs	r3, #0
	data.rsp = net_buf_add(data.buf, sizeof(*data.rsp));
   3122c:	9009      	str	r0, [sp, #36]	; 0x24
	data.rsp->len = 0U;
   3122e:	7003      	strb	r3, [r0, #0]
	data.err = BT_ATT_ERR_ATTRIBUTE_NOT_FOUND;
   31230:	230a      	movs	r3, #10
   31232:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
	bt_gatt_foreach_attr(start_handle, end_handle, read_type_cb, &data);
   31236:	4a0d      	ldr	r2, [pc, #52]	; (3126c <att_read_type_req+0xc0>)
   31238:	ab06      	add	r3, sp, #24
   3123a:	4639      	mov	r1, r7
   3123c:	4630      	mov	r0, r6
   3123e:	f01b f8fc 	bl	4c43a <bt_gatt_foreach_attr>
	if (data.err) {
   31242:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
   31246:	b14b      	cbz	r3, 3125c <att_read_type_req+0xb0>
		tx_meta_data_free(bt_att_tx_meta_data(data.buf));
   31248:	9b08      	ldr	r3, [sp, #32]
   3124a:	6958      	ldr	r0, [r3, #20]
   3124c:	f7ff fbb0 	bl	309b0 <tx_meta_data_free>
		net_buf_unref(data.buf);
   31250:	9808      	ldr	r0, [sp, #32]
   31252:	f011 faf9 	bl	42848 <net_buf_unref>
	if (!req) {
   31256:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
   3125a:	e7d7      	b.n	3120c <att_read_type_req+0x60>
	bt_att_chan_send_rsp(chan, data.buf);
   3125c:	9908      	ldr	r1, [sp, #32]
   3125e:	4620      	mov	r0, r4
   31260:	f01b f879 	bl	4c356 <bt_att_chan_send_rsp>
	return 0;
   31264:	e7d7      	b.n	31216 <att_read_type_req+0x6a>
		return BT_ATT_ERR_INVALID_PDU;
   31266:	2004      	movs	r0, #4
   31268:	e7d6      	b.n	31218 <att_read_type_req+0x6c>
   3126a:	bf00      	nop
   3126c:	00030bd5 	.word	0x00030bd5

00031270 <att_find_type_req>:
{
   31270:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   31274:	460f      	mov	r7, r1
   31276:	b086      	sub	sp, #24
   31278:	4604      	mov	r4, r0
	return net_buf_simple_pull_mem(&buf->b, len);
   3127a:	2106      	movs	r1, #6
   3127c:	f107 0008 	add.w	r0, r7, #8
   31280:	f01d fdc9 	bl	4ee16 <net_buf_simple_pull_mem>
	start_handle = sys_le16_to_cpu(req->start_handle);
   31284:	8805      	ldrh	r5, [r0, #0]
	end_handle = sys_le16_to_cpu(req->end_handle);
   31286:	f8b0 8002 	ldrh.w	r8, [r0, #2]
	type = sys_le16_to_cpu(req->type);
   3128a:	8882      	ldrh	r2, [r0, #4]
	value = buf->data;
   3128c:	f8d7 9008 	ldr.w	r9, [r7, #8]
	if (!start || !end) {
   31290:	b1c5      	cbz	r5, 312c4 <att_find_type_req+0x54>
   31292:	2300      	movs	r3, #0
   31294:	f1b8 0f00 	cmp.w	r8, #0
   31298:	d013      	beq.n	312c2 <att_find_type_req+0x52>
	if (start > end) {
   3129a:	4545      	cmp	r5, r8
   3129c:	d812      	bhi.n	312c4 <att_find_type_req+0x54>
	if (bt_uuid_cmp(BT_UUID_DECLARE_16(type), BT_UUID_GATT_PRIMARY)) {
   3129e:	f88d 3000 	strb.w	r3, [sp]
   312a2:	f88d 3004 	strb.w	r3, [sp, #4]
   312a6:	a901      	add	r1, sp, #4
   312a8:	f44f 5320 	mov.w	r3, #10240	; 0x2800
   312ac:	4668      	mov	r0, sp
   312ae:	f8ad 2002 	strh.w	r2, [sp, #2]
   312b2:	f8ad 3006 	strh.w	r3, [sp, #6]
   312b6:	f019 fea1 	bl	4affc <bt_uuid_cmp>
   312ba:	4606      	mov	r6, r0
   312bc:	b160      	cbz	r0, 312d8 <att_find_type_req+0x68>
	if (!req) {
   312be:	230a      	movs	r3, #10
   312c0:	e001      	b.n	312c6 <att_find_type_req+0x56>
			*err = 0U;
   312c2:	4645      	mov	r5, r8
	if (!req) {
   312c4:	2301      	movs	r3, #1
   312c6:	462a      	mov	r2, r5
   312c8:	2106      	movs	r1, #6
   312ca:	4620      	mov	r0, r4
   312cc:	f01b fc07 	bl	4cade <send_err_rsp.part.0>
		return 0;
   312d0:	2000      	movs	r0, #0
}
   312d2:	b006      	add	sp, #24
   312d4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	struct bt_conn *conn = chan->chan.chan.conn;
   312d8:	f8d4 a004 	ldr.w	sl, [r4, #4]
	return att_find_type_rsp(chan, start_handle, end_handle, value,
   312dc:	7b3f      	ldrb	r7, [r7, #12]
	(void)memset(&data, 0, sizeof(data));
   312de:	4601      	mov	r1, r0
   312e0:	2214      	movs	r2, #20
   312e2:	a801      	add	r0, sp, #4
   312e4:	f019 fdd4 	bl	4ae90 <memset>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_FIND_TYPE_RSP, 0);
   312e8:	4632      	mov	r2, r6
   312ea:	2107      	movs	r1, #7
   312ec:	4650      	mov	r0, sl
   312ee:	f01b fc39 	bl	4cb64 <bt_att_create_pdu>
   312f2:	9002      	str	r0, [sp, #8]
	if (!data.buf) {
   312f4:	b1f8      	cbz	r0, 31336 <att_find_type_req+0xc6>
	data.err = BT_ATT_ERR_ATTRIBUTE_NOT_FOUND;
   312f6:	230a      	movs	r3, #10
   312f8:	f88d 3015 	strb.w	r3, [sp, #21]
	bt_gatt_foreach_attr(start_handle, end_handle, find_type_cb, &data);
   312fc:	4a0f      	ldr	r2, [pc, #60]	; (3133c <att_find_type_req+0xcc>)
	data.chan = chan;
   312fe:	9401      	str	r4, [sp, #4]
	bt_gatt_foreach_attr(start_handle, end_handle, find_type_cb, &data);
   31300:	ab01      	add	r3, sp, #4
   31302:	4641      	mov	r1, r8
   31304:	4628      	mov	r0, r5
	data.value = value;
   31306:	e9cd 6903 	strd	r6, r9, [sp, #12]
	data.value_len = value_len;
   3130a:	f88d 7014 	strb.w	r7, [sp, #20]
	bt_gatt_foreach_attr(start_handle, end_handle, find_type_cb, &data);
   3130e:	f01b f894 	bl	4c43a <bt_gatt_foreach_attr>
	if (data.err) {
   31312:	f89d 3015 	ldrb.w	r3, [sp, #21]
   31316:	b14b      	cbz	r3, 3132c <att_find_type_req+0xbc>
		tx_meta_data_free(bt_att_tx_meta_data(data.buf));
   31318:	9b02      	ldr	r3, [sp, #8]
   3131a:	6958      	ldr	r0, [r3, #20]
   3131c:	f7ff fb48 	bl	309b0 <tx_meta_data_free>
		net_buf_unref(data.buf);
   31320:	9802      	ldr	r0, [sp, #8]
   31322:	f011 fa91 	bl	42848 <net_buf_unref>
	if (!req) {
   31326:	f89d 3015 	ldrb.w	r3, [sp, #21]
   3132a:	e7cc      	b.n	312c6 <att_find_type_req+0x56>
	bt_att_chan_send_rsp(chan, data.buf);
   3132c:	9902      	ldr	r1, [sp, #8]
   3132e:	4620      	mov	r0, r4
   31330:	f01b f811 	bl	4c356 <bt_att_chan_send_rsp>
	return 0;
   31334:	e7cc      	b.n	312d0 <att_find_type_req+0x60>
		return BT_ATT_ERR_UNLIKELY;
   31336:	200e      	movs	r0, #14
	return att_find_type_rsp(chan, start_handle, end_handle, value,
   31338:	e7cb      	b.n	312d2 <att_find_type_req+0x62>
   3133a:	bf00      	nop
   3133c:	0004c451 	.word	0x0004c451

00031340 <att_find_info_req>:
{
   31340:	b5f0      	push	{r4, r5, r6, r7, lr}
	req = (void *)buf->data;
   31342:	688b      	ldr	r3, [r1, #8]
	start_handle = sys_le16_to_cpu(req->start_handle);
   31344:	881d      	ldrh	r5, [r3, #0]
	end_handle = sys_le16_to_cpu(req->end_handle);
   31346:	885e      	ldrh	r6, [r3, #2]
{
   31348:	b085      	sub	sp, #20
   3134a:	4604      	mov	r4, r0
	if (!start || !end) {
   3134c:	b195      	cbz	r5, 31374 <att_find_info_req+0x34>
   3134e:	b186      	cbz	r6, 31372 <att_find_info_req+0x32>
	if (start > end) {
   31350:	42b5      	cmp	r5, r6
   31352:	d80f      	bhi.n	31374 <att_find_info_req+0x34>
	struct bt_conn *conn = chan->chan.chan.conn;
   31354:	6847      	ldr	r7, [r0, #4]
	(void)memset(&data, 0, sizeof(data));
   31356:	2210      	movs	r2, #16
   31358:	2100      	movs	r1, #0
   3135a:	4668      	mov	r0, sp
   3135c:	f019 fd98 	bl	4ae90 <memset>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_FIND_INFO_RSP, 0);
   31360:	2200      	movs	r2, #0
   31362:	2105      	movs	r1, #5
   31364:	4638      	mov	r0, r7
   31366:	f01b fbfd 	bl	4cb64 <bt_att_create_pdu>
   3136a:	9001      	str	r0, [sp, #4]
	if (!data.buf) {
   3136c:	b958      	cbnz	r0, 31386 <att_find_info_req+0x46>
		return BT_ATT_ERR_UNLIKELY;
   3136e:	200e      	movs	r0, #14
	return att_find_info_rsp(chan, start_handle, end_handle);
   31370:	e007      	b.n	31382 <att_find_info_req+0x42>
			*err = 0U;
   31372:	4635      	mov	r5, r6
	if (!req) {
   31374:	2301      	movs	r3, #1
   31376:	462a      	mov	r2, r5
   31378:	2104      	movs	r1, #4
   3137a:	4620      	mov	r0, r4
   3137c:	f01b fbaf 	bl	4cade <send_err_rsp.part.0>
		return 0;
   31380:	2000      	movs	r0, #0
}
   31382:	b005      	add	sp, #20
   31384:	bdf0      	pop	{r4, r5, r6, r7, pc}
	bt_gatt_foreach_attr(start_handle, end_handle, find_info_cb, &data);
   31386:	466b      	mov	r3, sp
   31388:	4a0a      	ldr	r2, [pc, #40]	; (313b4 <att_find_info_req+0x74>)
	data.chan = chan;
   3138a:	9400      	str	r4, [sp, #0]
	bt_gatt_foreach_attr(start_handle, end_handle, find_info_cb, &data);
   3138c:	4631      	mov	r1, r6
   3138e:	4628      	mov	r0, r5
   31390:	f01b f853 	bl	4c43a <bt_gatt_foreach_attr>
	if (!data.rsp) {
   31394:	9b02      	ldr	r3, [sp, #8]
   31396:	b943      	cbnz	r3, 313aa <att_find_info_req+0x6a>
		tx_meta_data_free(bt_att_tx_meta_data(data.buf));
   31398:	9b01      	ldr	r3, [sp, #4]
   3139a:	6958      	ldr	r0, [r3, #20]
   3139c:	f7ff fb08 	bl	309b0 <tx_meta_data_free>
		net_buf_unref(data.buf);
   313a0:	9801      	ldr	r0, [sp, #4]
   313a2:	f011 fa51 	bl	42848 <net_buf_unref>
	if (!req) {
   313a6:	230a      	movs	r3, #10
   313a8:	e7e5      	b.n	31376 <att_find_info_req+0x36>
	bt_att_chan_send_rsp(chan, data.buf);
   313aa:	9901      	ldr	r1, [sp, #4]
   313ac:	4620      	mov	r0, r4
   313ae:	f01a ffd2 	bl	4c356 <bt_att_chan_send_rsp>
	return 0;
   313b2:	e7e5      	b.n	31380 <att_find_info_req+0x40>
   313b4:	0004c579 	.word	0x0004c579

000313b8 <bt_att_init>:
	bt_l2cap_register_ecred_cb(&cb);
#endif /* CONFIG_BT_EATT */
}

void bt_att_init(void)
{
   313b8:	b538      	push	{r3, r4, r5, lr}
	for (size_t i = 0; i < ARRAY_SIZE(tx_meta_data); i++) {
		k_fifo_put(&free_att_tx_meta_data, &tx_meta_data[i]);
   313ba:	4d0a      	ldr	r5, [pc, #40]	; (313e4 <bt_att_init+0x2c>)
   313bc:	4c0a      	ldr	r4, [pc, #40]	; (313e8 <bt_att_init+0x30>)
   313be:	4629      	mov	r1, r5
   313c0:	4620      	mov	r0, r4
   313c2:	f01e fd05 	bl	4fdd0 <k_queue_append>
   313c6:	f105 0114 	add.w	r1, r5, #20
   313ca:	4620      	mov	r0, r4
   313cc:	f01e fd00 	bl	4fdd0 <k_queue_append>
   313d0:	f105 0128 	add.w	r1, r5, #40	; 0x28
   313d4:	4620      	mov	r0, r4
   313d6:	f01e fcfb 	bl	4fdd0 <k_queue_append>
	bt_gatt_init();

	if (IS_ENABLED(CONFIG_BT_EATT)) {
		bt_eatt_init();
	}
}
   313da:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	bt_gatt_init();
   313de:	f000 bcfd 	b.w	31ddc <bt_gatt_init>
   313e2:	bf00      	nop
   313e4:	20003f58 	.word	0x20003f58
   313e8:	2000129c 	.word	0x2000129c

000313ec <bt_att_req_alloc>:
		bt_gatt_att_max_mtu_changed(att->conn, max_tx, max_rx);
	}
}

struct bt_att_req *bt_att_req_alloc(k_timeout_t timeout)
{
   313ec:	b537      	push	{r0, r1, r2, r4, r5, lr}
	struct bt_att_req *req = NULL;
   313ee:	2300      	movs	r3, #0
{
   313f0:	4605      	mov	r5, r0
   313f2:	460c      	mov	r4, r1
	struct bt_att_req *req = NULL;
   313f4:	9301      	str	r3, [sp, #4]
	return z_impl_z_current_get();
   313f6:	f016 fbe5 	bl	47bc4 <z_impl_z_current_get>

	if (k_current_get() == att_handle_rsp_thread) {
   313fa:	4b0b      	ldr	r3, [pc, #44]	; (31428 <bt_att_req_alloc+0x3c>)
   313fc:	681b      	ldr	r3, [r3, #0]
   313fe:	4283      	cmp	r3, r0
		/* No req will be fulfilled while blocking on the bt_recv thread.
		 * Blocking would cause deadlock.
		 */
		timeout = K_NO_WAIT;
   31400:	bf04      	itt	eq
   31402:	2500      	moveq	r5, #0
   31404:	462c      	moveq	r4, r5
	}

	/* Reserve space for request */
	if (k_mem_slab_alloc(&req_slab, (void **)&req, timeout)) {
   31406:	a901      	add	r1, sp, #4
   31408:	4808      	ldr	r0, [pc, #32]	; (3142c <bt_att_req_alloc+0x40>)
   3140a:	462a      	mov	r2, r5
   3140c:	4623      	mov	r3, r4
   3140e:	f015 fc17 	bl	46c40 <k_mem_slab_alloc>
   31412:	4601      	mov	r1, r0
   31414:	b930      	cbnz	r0, 31424 <bt_att_req_alloc+0x38>
		return NULL;
	}

	BT_DBG("req %p", req);

	memset(req, 0, sizeof(*req));
   31416:	9801      	ldr	r0, [sp, #4]
   31418:	221c      	movs	r2, #28
   3141a:	f019 fd39 	bl	4ae90 <memset>

	return req;
   3141e:	9801      	ldr	r0, [sp, #4]
}
   31420:	b003      	add	sp, #12
   31422:	bd30      	pop	{r4, r5, pc}
		return NULL;
   31424:	2000      	movs	r0, #0
   31426:	e7fb      	b.n	31420 <bt_att_req_alloc+0x34>
   31428:	20003f94 	.word	0x20003f94
   3142c:	200010c4 	.word	0x200010c4

00031430 <bt_att_req_free>:

void bt_att_req_free(struct bt_att_req *req)
{
   31430:	b507      	push	{r0, r1, r2, lr}
	BT_DBG("req %p", req);

	if (req->buf) {
   31432:	6883      	ldr	r3, [r0, #8]
{
   31434:	9001      	str	r0, [sp, #4]
	if (req->buf) {
   31436:	b14b      	cbz	r3, 3144c <bt_att_req_free+0x1c>
		tx_meta_data_free(bt_att_tx_meta_data(req->buf));
   31438:	6958      	ldr	r0, [r3, #20]
   3143a:	f7ff fab9 	bl	309b0 <tx_meta_data_free>
		net_buf_unref(req->buf);
   3143e:	9b01      	ldr	r3, [sp, #4]
   31440:	6898      	ldr	r0, [r3, #8]
   31442:	f011 fa01 	bl	42848 <net_buf_unref>
		req->buf = NULL;
   31446:	9b01      	ldr	r3, [sp, #4]
   31448:	2200      	movs	r2, #0
   3144a:	609a      	str	r2, [r3, #8]
	}

	k_mem_slab_free(&req_slab, (void **)&req);
   3144c:	4803      	ldr	r0, [pc, #12]	; (3145c <bt_att_req_free+0x2c>)
   3144e:	a901      	add	r1, sp, #4
   31450:	f01e fbd6 	bl	4fc00 <k_mem_slab_free>
}
   31454:	b003      	add	sp, #12
   31456:	f85d fb04 	ldr.w	pc, [sp], #4
   3145a:	bf00      	nop
   3145c:	200010c4 	.word	0x200010c4

00031460 <att_handle_rsp>:
{
   31460:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
   31464:	4604      	mov	r4, r0
	k_work_cancel_delayable(&chan->timeout_work);
   31466:	30b0      	adds	r0, #176	; 0xb0
{
   31468:	460e      	mov	r6, r1
   3146a:	4617      	mov	r7, r2
   3146c:	461d      	mov	r5, r3
	k_work_cancel_delayable(&chan->timeout_work);
   3146e:	f01e fdd7 	bl	50020 <k_work_cancel_delayable>
	if (!chan->req) {
   31472:	f8d4 0094 	ldr.w	r0, [r4, #148]	; 0x94
   31476:	b930      	cbnz	r0, 31486 <att_handle_rsp+0x26>
	att_req_send_process(chan->att);
   31478:	6820      	ldr	r0, [r4, #0]
   3147a:	f01b fa27 	bl	4c8cc <att_req_send_process>
}
   3147e:	2000      	movs	r0, #0
   31480:	b002      	add	sp, #8
   31482:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (chan->req == &cancel) {
   31486:	4b11      	ldr	r3, [pc, #68]	; (314cc <att_handle_rsp+0x6c>)
   31488:	4298      	cmp	r0, r3
   3148a:	f04f 0800 	mov.w	r8, #0
   3148e:	d102      	bne.n	31496 <att_handle_rsp+0x36>
		chan->req = NULL;
   31490:	f8c4 8094 	str.w	r8, [r4, #148]	; 0x94
   31494:	e7f0      	b.n	31478 <att_handle_rsp+0x18>
	func = chan->req->func;
   31496:	f8d0 9004 	ldr.w	r9, [r0, #4]
	chan->req->func = NULL;
   3149a:	f8c0 8004 	str.w	r8, [r0, #4]
	params = chan->req->user_data;
   3149e:	f8d4 0094 	ldr.w	r0, [r4, #148]	; 0x94
   314a2:	f8d0 a018 	ldr.w	sl, [r0, #24]
	bt_att_req_free(chan->req);
   314a6:	f7ff ffc3 	bl	31430 <bt_att_req_free>
	att_req_send_process(chan->att);
   314aa:	6820      	ldr	r0, [r4, #0]
	chan->req = NULL;
   314ac:	f8c4 8094 	str.w	r8, [r4, #148]	; 0x94
	att_req_send_process(chan->att);
   314b0:	f01b fa0c 	bl	4c8cc <att_req_send_process>
	if (func) {
   314b4:	f1b9 0f00 	cmp.w	r9, #0
   314b8:	d0e1      	beq.n	3147e <att_handle_rsp+0x1e>
		func(chan->att->conn, err, pdu, len, params);
   314ba:	6820      	ldr	r0, [r4, #0]
   314bc:	f8cd a000 	str.w	sl, [sp]
   314c0:	6800      	ldr	r0, [r0, #0]
   314c2:	463b      	mov	r3, r7
   314c4:	4632      	mov	r2, r6
   314c6:	4629      	mov	r1, r5
   314c8:	47c8      	blx	r9
   314ca:	e7d8      	b.n	3147e <att_handle_rsp+0x1e>
   314cc:	20003f98 	.word	0x20003f98

000314d0 <att_error_rsp>:
{
   314d0:	b570      	push	{r4, r5, r6, lr}
	if (!chan->req || chan->req == &cancel || !rsp->error) {
   314d2:	f8d0 3094 	ldr.w	r3, [r0, #148]	; 0x94
	rsp = (void *)buf->data;
   314d6:	688a      	ldr	r2, [r1, #8]
{
   314d8:	4605      	mov	r5, r0
	if (!chan->req || chan->req == &cancel || !rsp->error) {
   314da:	b313      	cbz	r3, 31522 <att_error_rsp+0x52>
   314dc:	4915      	ldr	r1, [pc, #84]	; (31534 <att_error_rsp+0x64>)
   314de:	428b      	cmp	r3, r1
   314e0:	d01f      	beq.n	31522 <att_error_rsp+0x52>
   314e2:	78d4      	ldrb	r4, [r2, #3]
   314e4:	b1ec      	cbz	r4, 31522 <att_error_rsp+0x52>
	switch (err) {
   314e6:	2c05      	cmp	r4, #5
	if (!att_change_security(chan->chan.chan.conn, err)) {
   314e8:	6840      	ldr	r0, [r0, #4]
	switch (err) {
   314ea:	d006      	beq.n	314fa <att_error_rsp+0x2a>
   314ec:	2c0f      	cmp	r4, #15
   314ee:	d119      	bne.n	31524 <att_error_rsp+0x54>
		if (conn->sec_level >= BT_SECURITY_L2)
   314f0:	7a43      	ldrb	r3, [r0, #9]
   314f2:	2b01      	cmp	r3, #1
   314f4:	d816      	bhi.n	31524 <att_error_rsp+0x54>
		sec = BT_SECURITY_L2;
   314f6:	2102      	movs	r1, #2
   314f8:	e007      	b.n	3150a <att_error_rsp+0x3a>
		if (conn->sec_level < BT_SECURITY_L2) {
   314fa:	7a43      	ldrb	r3, [r0, #9]
   314fc:	2b01      	cmp	r3, #1
   314fe:	d9fa      	bls.n	314f6 <att_error_rsp+0x26>
		} else if (conn->sec_level < BT_SECURITY_L3) {
   31500:	2b02      	cmp	r3, #2
   31502:	d00c      	beq.n	3151e <att_error_rsp+0x4e>
		} else if (conn->sec_level < BT_SECURITY_L4) {
   31504:	2b03      	cmp	r3, #3
   31506:	d10d      	bne.n	31524 <att_error_rsp+0x54>
			sec = BT_SECURITY_L4;
   31508:	2104      	movs	r1, #4
	return bt_conn_set_security(conn, sec);
   3150a:	f01a fce3 	bl	4bed4 <bt_conn_set_security>
	if (!att_change_security(chan->chan.chan.conn, err)) {
   3150e:	b948      	cbnz	r0, 31524 <att_error_rsp+0x54>
		chan->req->retrying = true;
   31510:	f8d5 2094 	ldr.w	r2, [r5, #148]	; 0x94
   31514:	7c13      	ldrb	r3, [r2, #16]
   31516:	f043 0301 	orr.w	r3, r3, #1
   3151a:	7413      	strb	r3, [r2, #16]
}
   3151c:	bd70      	pop	{r4, r5, r6, pc}
			sec = BT_SECURITY_L3;
   3151e:	2103      	movs	r1, #3
   31520:	e7f3      	b.n	3150a <att_error_rsp+0x3a>
		err = BT_ATT_ERR_UNLIKELY;
   31522:	240e      	movs	r4, #14
	return att_handle_rsp(chan, NULL, 0, err);
   31524:	2200      	movs	r2, #0
   31526:	4623      	mov	r3, r4
   31528:	4628      	mov	r0, r5
   3152a:	4611      	mov	r1, r2
}
   3152c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return att_handle_rsp(chan, NULL, 0, err);
   31530:	f7ff bf96 	b.w	31460 <att_handle_rsp>
   31534:	20003f98 	.word	0x20003f98

00031538 <bt_att_disconnected>:
{
   31538:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	struct bt_att *att = att_chan->att;
   3153c:	f850 6c04 	ldr.w	r6, [r0, #-4]
{
   31540:	4604      	mov	r4, r0
	if (!att_chan->att) {
   31542:	2e00      	cmp	r6, #0
   31544:	d056      	beq.n	315f4 <bt_att_disconnected+0xbc>
	sys_slist_find_and_remove(&chan->att->chans, &chan->node);
   31546:	f100 01dc 	add.w	r1, r0, #220	; 0xdc
   3154a:	f106 0024 	add.w	r0, r6, #36	; 0x24
   3154e:	f01b f913 	bl	4c778 <sys_slist_find_and_remove.isra.0>
	while ((buf = net_buf_get(&chan->tx_queue, K_NO_WAIT))) {
   31552:	1f27      	subs	r7, r4, #4
   31554:	f104 0894 	add.w	r8, r4, #148	; 0x94
   31558:	2200      	movs	r2, #0
   3155a:	2300      	movs	r3, #0
   3155c:	4640      	mov	r0, r8
   3155e:	f01d fbc6 	bl	4ecee <net_buf_get>
   31562:	4605      	mov	r5, r0
   31564:	bb28      	cbnz	r0, 315b2 <bt_att_disconnected+0x7a>
	if (chan->req) {
   31566:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
   3156a:	b12b      	cbz	r3, 31578 <bt_att_disconnected+0x40>
		att_handle_rsp(chan, NULL, 0, BT_ATT_ERR_UNLIKELY);
   3156c:	4602      	mov	r2, r0
   3156e:	4601      	mov	r1, r0
   31570:	230e      	movs	r3, #14
   31572:	4638      	mov	r0, r7
   31574:	f7ff ff74 	bl	31460 <att_handle_rsp>
	chan->att = NULL;
   31578:	2300      	movs	r3, #0
   3157a:	f844 3c04 	str.w	r3, [r4, #-4]
	if (!sys_slist_is_empty(&att->chans)) {
   3157e:	6a73      	ldr	r3, [r6, #36]	; 0x24
   31580:	2b00      	cmp	r3, #0
   31582:	d137      	bne.n	315f4 <bt_att_disconnected+0xbc>
	att_reset(att);
   31584:	9603      	str	r6, [sp, #12]
	while ((buf = net_buf_get(&att->tx_queue, K_NO_WAIT))) {
   31586:	9803      	ldr	r0, [sp, #12]
   31588:	2200      	movs	r2, #0
   3158a:	2300      	movs	r3, #0
   3158c:	300c      	adds	r0, #12
   3158e:	f01d fbae 	bl	4ecee <net_buf_get>
   31592:	4605      	mov	r5, r0
   31594:	b9a0      	cbnz	r0, 315c0 <bt_att_disconnected+0x88>
	while (!sys_slist_is_empty(&att->reqs)) {
   31596:	9803      	ldr	r0, [sp, #12]
	return list->head;
   31598:	6845      	ldr	r5, [r0, #4]
   3159a:	b9c5      	cbnz	r5, 315ce <bt_att_disconnected+0x96>
	att->conn = NULL;
   3159c:	6005      	str	r5, [r0, #0]
	k_mem_slab_free(&att_slab, (void **)&att);
   3159e:	a903      	add	r1, sp, #12
   315a0:	4816      	ldr	r0, [pc, #88]	; (315fc <bt_att_disconnected+0xc4>)
   315a2:	f01e fb2d 	bl	4fc00 <k_mem_slab_free>
	bt_gatt_disconnected(le_chan->chan.conn);
   315a6:	6820      	ldr	r0, [r4, #0]
}
   315a8:	b004      	add	sp, #16
   315aa:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	bt_gatt_disconnected(le_chan->chan.conn);
   315ae:	f001 bcfb 	b.w	32fa8 <bt_gatt_disconnected>
		tx_meta_data_free(bt_att_tx_meta_data(buf));
   315b2:	6968      	ldr	r0, [r5, #20]
   315b4:	f7ff f9fc 	bl	309b0 <tx_meta_data_free>
		net_buf_unref(buf);
   315b8:	4628      	mov	r0, r5
   315ba:	f011 f945 	bl	42848 <net_buf_unref>
   315be:	e7cb      	b.n	31558 <bt_att_disconnected+0x20>
		tx_meta_data_free(bt_att_tx_meta_data(buf));
   315c0:	6968      	ldr	r0, [r5, #20]
   315c2:	f7ff f9f5 	bl	309b0 <tx_meta_data_free>
		net_buf_unref(buf);
   315c6:	4628      	mov	r0, r5
   315c8:	f011 f93e 	bl	42848 <net_buf_unref>
   315cc:	e7db      	b.n	31586 <bt_att_disconnected+0x4e>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   315ce:	6882      	ldr	r2, [r0, #8]
	return node->next;
   315d0:	682b      	ldr	r3, [r5, #0]
	list->head = node;
   315d2:	6043      	str	r3, [r0, #4]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   315d4:	4295      	cmp	r5, r2
	list->tail = node;
   315d6:	bf08      	it	eq
   315d8:	6083      	streq	r3, [r0, #8]
		if (req->func) {
   315da:	686e      	ldr	r6, [r5, #4]
   315dc:	b136      	cbz	r6, 315ec <bt_att_disconnected+0xb4>
			req->func(att->conn, BT_ATT_ERR_UNLIKELY, NULL, 0,
   315de:	69ab      	ldr	r3, [r5, #24]
   315e0:	9300      	str	r3, [sp, #0]
   315e2:	2300      	movs	r3, #0
   315e4:	6800      	ldr	r0, [r0, #0]
   315e6:	461a      	mov	r2, r3
   315e8:	210e      	movs	r1, #14
   315ea:	47b0      	blx	r6
		bt_att_req_free(req);
   315ec:	4628      	mov	r0, r5
   315ee:	f7ff ff1f 	bl	31430 <bt_att_req_free>
   315f2:	e7d0      	b.n	31596 <bt_att_disconnected+0x5e>
}
   315f4:	b004      	add	sp, #16
   315f6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   315fa:	bf00      	nop
   315fc:	20001070 	.word	0x20001070

00031600 <bt_att_req_cancel>:

	return true;
}

void bt_att_req_cancel(struct bt_conn *conn, struct bt_att_req *req)
{
   31600:	b510      	push	{r4, lr}
   31602:	460c      	mov	r4, r1
	struct bt_att *att;
	struct bt_att_chan *chan, *tmp;

	BT_DBG("req %p", req);

	if (!conn || !req) {
   31604:	b338      	cbz	r0, 31656 <bt_att_req_cancel+0x56>
   31606:	b331      	cbz	r1, 31656 <bt_att_req_cancel+0x56>
		return;
	}

	att = att_get(conn);
   31608:	f01a fe5b 	bl	4c2c2 <att_get>
	if (!att) {
   3160c:	b318      	cbz	r0, 31656 <bt_att_req_cancel+0x56>
	return list->head;
   3160e:	6a43      	ldr	r3, [r0, #36]	; 0x24
		return;
	}

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   31610:	b1db      	cbz	r3, 3164a <bt_att_req_cancel+0x4a>
	return node->next;
   31612:	f853 29e0 	ldr.w	r2, [r3], #-224
   31616:	b102      	cbz	r2, 3161a <bt_att_req_cancel+0x1a>
   31618:	3ae0      	subs	r2, #224	; 0xe0
	if (chan->req != req) {
   3161a:	f8d3 1094 	ldr.w	r1, [r3, #148]	; 0x94
   3161e:	428c      	cmp	r4, r1
   31620:	d00b      	beq.n	3163a <bt_att_req_cancel+0x3a>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   31622:	b192      	cbz	r2, 3164a <bt_att_req_cancel+0x4a>
   31624:	4613      	mov	r3, r2
   31626:	f8d2 20e0 	ldr.w	r2, [r2, #224]	; 0xe0
   3162a:	2a00      	cmp	r2, #0
   3162c:	d0f5      	beq.n	3161a <bt_att_req_cancel+0x1a>
	if (chan->req != req) {
   3162e:	f8d3 1094 	ldr.w	r1, [r3, #148]	; 0x94
   31632:	428c      	cmp	r4, r1
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   31634:	f1a2 02e0 	sub.w	r2, r2, #224	; 0xe0
	if (chan->req != req) {
   31638:	d1f4      	bne.n	31624 <bt_att_req_cancel+0x24>
	chan->req = &cancel;
   3163a:	4a07      	ldr	r2, [pc, #28]	; (31658 <bt_att_req_cancel+0x58>)
   3163c:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
	bt_att_req_free(req);
   31640:	4620      	mov	r0, r4

	/* Remove request from the list */
	sys_slist_find_and_remove(&att->reqs, &req->node);

	bt_att_req_free(req);
}
   31642:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	bt_att_req_free(req);
   31646:	f7ff bef3 	b.w	31430 <bt_att_req_free>
	sys_slist_find_and_remove(&att->reqs, &req->node);
   3164a:	3004      	adds	r0, #4
   3164c:	4621      	mov	r1, r4
   3164e:	f01b f893 	bl	4c778 <sys_slist_find_and_remove.isra.0>
	bt_att_req_free(req);
   31652:	4620      	mov	r0, r4
   31654:	e7f5      	b.n	31642 <bt_att_req_cancel+0x42>
}
   31656:	bd10      	pop	{r4, pc}
   31658:	20003f98 	.word	0x20003f98

0003165c <db_hash_set>:

SETTINGS_STATIC_HANDLER_DEFINE(bt_cf, "bt/cf", NULL, cf_set, NULL, NULL);

static int db_hash_set(const char *name, size_t len_rd,
		       settings_read_cb read_cb, void *cb_arg)
{
   3165c:	b510      	push	{r4, lr}
	ssize_t len;

	len = read_cb(cb_arg, db_hash.stored_hash, sizeof(db_hash.stored_hash));
   3165e:	4904      	ldr	r1, [pc, #16]	; (31670 <db_hash_set+0x14>)
{
   31660:	4614      	mov	r4, r2
	len = read_cb(cb_arg, db_hash.stored_hash, sizeof(db_hash.stored_hash));
   31662:	4618      	mov	r0, r3
   31664:	2210      	movs	r2, #16
   31666:	47a0      	blx	r4

	BT_HEXDUMP_DBG(db_hash.stored_hash, sizeof(db_hash.stored_hash),
		       "Stored Hash: ");

	return 0;
}
   31668:	ea00 70e0 	and.w	r0, r0, r0, asr #31
   3166c:	bd10      	pop	{r4, pc}
   3166e:	bf00      	nop
   31670:	20001d00 	.word	0x20001d00

00031674 <find_cf_cfg>:
{
   31674:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   31678:	4c0e      	ldr	r4, [pc, #56]	; (316b4 <find_cf_cfg+0x40>)
			if (!bt_addr_le_cmp(&cfg->peer, BT_ADDR_LE_ANY)) {
   3167a:	f8df 803c 	ldr.w	r8, [pc, #60]	; 316b8 <find_cf_cfg+0x44>
{
   3167e:	4605      	mov	r5, r0
	for (i = 0; i < ARRAY_SIZE(cf_cfg); i++) {
   31680:	2600      	movs	r6, #0
		struct gatt_cf_cfg *cfg = &cf_cfg[i];
   31682:	4627      	mov	r7, r4
			if (!bt_addr_le_cmp(&cfg->peer, BT_ADDR_LE_ANY)) {
   31684:	1c62      	adds	r2, r4, #1
		if (!conn) {
   31686:	b96d      	cbnz	r5, 316a4 <find_cf_cfg+0x30>
			if (!bt_addr_le_cmp(&cfg->peer, BT_ADDR_LE_ANY)) {
   31688:	4641      	mov	r1, r8
   3168a:	4610      	mov	r0, r2
   3168c:	f01b fc81 	bl	4cf92 <bt_addr_le_cmp>
   31690:	b128      	cbz	r0, 3169e <find_cf_cfg+0x2a>
	for (i = 0; i < ARRAY_SIZE(cf_cfg); i++) {
   31692:	3601      	adds	r6, #1
   31694:	2e0c      	cmp	r6, #12
   31696:	f104 0410 	add.w	r4, r4, #16
   3169a:	d1f2      	bne.n	31682 <find_cf_cfg+0xe>
	return NULL;
   3169c:	2700      	movs	r7, #0
}
   3169e:	4638      	mov	r0, r7
   316a0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		} else if (bt_conn_is_peer_addr_le(conn, cfg->id, &cfg->peer)) {
   316a4:	7821      	ldrb	r1, [r4, #0]
   316a6:	4628      	mov	r0, r5
   316a8:	f01a fc3e 	bl	4bf28 <bt_conn_is_peer_addr_le>
   316ac:	2800      	cmp	r0, #0
   316ae:	d0f0      	beq.n	31692 <find_cf_cfg+0x1e>
   316b0:	e7f5      	b.n	3169e <find_cf_cfg+0x2a>
   316b2:	bf00      	nop
   316b4:	20004044 	.word	0x20004044
   316b8:	00053517 	.word	0x00053517

000316bc <find_sc_cfg>:
{
   316bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   316be:	4d0b      	ldr	r5, [pc, #44]	; (316ec <find_sc_cfg+0x30>)
   316c0:	4606      	mov	r6, r0
   316c2:	460f      	mov	r7, r1
   316c4:	2400      	movs	r4, #0
		if (id == sc_cfg[i].id &&
   316c6:	f815 3c01 	ldrb.w	r3, [r5, #-1]
   316ca:	42b3      	cmp	r3, r6
   316cc:	d107      	bne.n	316de <find_sc_cfg+0x22>
		    !bt_addr_le_cmp(&sc_cfg[i].peer, addr)) {
   316ce:	4639      	mov	r1, r7
   316d0:	4628      	mov	r0, r5
   316d2:	f01b fc5e 	bl	4cf92 <bt_addr_le_cmp>
		if (id == sc_cfg[i].id &&
   316d6:	b910      	cbnz	r0, 316de <find_sc_cfg+0x22>
			return &sc_cfg[i];
   316d8:	4805      	ldr	r0, [pc, #20]	; (316f0 <find_sc_cfg+0x34>)
   316da:	4420      	add	r0, r4
}
   316dc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	for (size_t i = 0; i < ARRAY_SIZE(sc_cfg); i++) {
   316de:	340c      	adds	r4, #12
   316e0:	2c90      	cmp	r4, #144	; 0x90
   316e2:	f105 050c 	add.w	r5, r5, #12
   316e6:	d1ee      	bne.n	316c6 <find_sc_cfg+0xa>
	return NULL;
   316e8:	2000      	movs	r0, #0
   316ea:	e7f7      	b.n	316dc <find_sc_cfg+0x20>
   316ec:	2000699d 	.word	0x2000699d
   316f0:	2000699c 	.word	0x2000699c

000316f4 <find_ccc_cfg>:
{
   316f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		} else if (!bt_addr_le_cmp(&cfg->peer, BT_ADDR_LE_ANY)) {
   316f6:	4f0d      	ldr	r7, [pc, #52]	; (3172c <find_ccc_cfg+0x38>)
{
   316f8:	4606      	mov	r6, r0
   316fa:	1c4c      	adds	r4, r1, #1
   316fc:	f101 053d 	add.w	r5, r1, #61	; 0x3d
		if (conn) {
   31700:	b146      	cbz	r6, 31714 <find_ccc_cfg+0x20>
			if (bt_conn_is_peer_addr_le(conn, cfg->id,
   31702:	f814 1c01 	ldrb.w	r1, [r4, #-1]
   31706:	4622      	mov	r2, r4
   31708:	4630      	mov	r0, r6
   3170a:	f01a fc0d 	bl	4bf28 <bt_conn_is_peer_addr_le>
   3170e:	b138      	cbz	r0, 31720 <find_ccc_cfg+0x2c>
		struct bt_gatt_ccc_cfg *cfg = &ccc->cfg[i];
   31710:	1e60      	subs	r0, r4, #1
}
   31712:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		} else if (!bt_addr_le_cmp(&cfg->peer, BT_ADDR_LE_ANY)) {
   31714:	4639      	mov	r1, r7
   31716:	4620      	mov	r0, r4
   31718:	f01b fc3b 	bl	4cf92 <bt_addr_le_cmp>
   3171c:	2800      	cmp	r0, #0
   3171e:	d0f7      	beq.n	31710 <find_ccc_cfg+0x1c>
	for (size_t i = 0; i < ARRAY_SIZE(ccc->cfg); i++) {
   31720:	340a      	adds	r4, #10
   31722:	42ac      	cmp	r4, r5
   31724:	d1ec      	bne.n	31700 <find_ccc_cfg+0xc>
	return NULL;
   31726:	2000      	movs	r0, #0
   31728:	e7f3      	b.n	31712 <find_ccc_cfg+0x1e>
   3172a:	bf00      	nop
   3172c:	00053517 	.word	0x00053517

00031730 <gatt_sub_find>:
{
   31730:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   31734:	4c0e      	ldr	r4, [pc, #56]	; (31770 <gatt_sub_find+0x40>)
			if (!bt_addr_le_cmp(&sub->peer, BT_ADDR_LE_ANY)) {
   31736:	f8df 803c 	ldr.w	r8, [pc, #60]	; 31774 <gatt_sub_find+0x44>
{
   3173a:	4605      	mov	r5, r0
	for (int i = 0; i < ARRAY_SIZE(subscriptions); i++) {
   3173c:	2600      	movs	r6, #0
		struct gatt_sub *sub = &subscriptions[i];
   3173e:	4627      	mov	r7, r4
			if (!bt_addr_le_cmp(&sub->peer, BT_ADDR_LE_ANY)) {
   31740:	1c62      	adds	r2, r4, #1
		if (!conn) {
   31742:	b96d      	cbnz	r5, 31760 <gatt_sub_find+0x30>
			if (!bt_addr_le_cmp(&sub->peer, BT_ADDR_LE_ANY)) {
   31744:	4641      	mov	r1, r8
   31746:	4610      	mov	r0, r2
   31748:	f01b fc23 	bl	4cf92 <bt_addr_le_cmp>
   3174c:	b128      	cbz	r0, 3175a <gatt_sub_find+0x2a>
	for (int i = 0; i < ARRAY_SIZE(subscriptions); i++) {
   3174e:	3601      	adds	r6, #1
   31750:	2e0c      	cmp	r6, #12
   31752:	f104 0410 	add.w	r4, r4, #16
   31756:	d1f2      	bne.n	3173e <gatt_sub_find+0xe>
	return NULL;
   31758:	2700      	movs	r7, #0
}
   3175a:	4638      	mov	r0, r7
   3175c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		} else if (bt_conn_is_peer_addr_le(conn, sub->id, &sub->peer)) {
   31760:	7821      	ldrb	r1, [r4, #0]
   31762:	4628      	mov	r0, r5
   31764:	f01a fbe0 	bl	4bf28 <bt_conn_is_peer_addr_le>
   31768:	2800      	cmp	r0, #0
   3176a:	d0f0      	beq.n	3174e <gatt_sub_find+0x1e>
   3176c:	e7f5      	b.n	3175a <gatt_sub_find+0x2a>
   3176e:	bf00      	nop
   31770:	20004114 	.word	0x20004114
   31774:	00053517 	.word	0x00053517

00031778 <find_cf_cfg_by_addr>:
{
   31778:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   3177a:	4d0b      	ldr	r5, [pc, #44]	; (317a8 <find_cf_cfg_by_addr+0x30>)
   3177c:	4606      	mov	r6, r0
   3177e:	460f      	mov	r7, r1
   31780:	2400      	movs	r4, #0
			if (id == cf_cfg[i].id &&
   31782:	f815 3c01 	ldrb.w	r3, [r5, #-1]
   31786:	42b3      	cmp	r3, r6
   31788:	d107      	bne.n	3179a <find_cf_cfg_by_addr+0x22>
			    !bt_addr_le_cmp(addr, &cf_cfg[i].peer)) {
   3178a:	4629      	mov	r1, r5
   3178c:	4638      	mov	r0, r7
   3178e:	f01b fc00 	bl	4cf92 <bt_addr_le_cmp>
			if (id == cf_cfg[i].id &&
   31792:	b910      	cbnz	r0, 3179a <find_cf_cfg_by_addr+0x22>
				return &cf_cfg[i];
   31794:	4805      	ldr	r0, [pc, #20]	; (317ac <find_cf_cfg_by_addr+0x34>)
   31796:	4420      	add	r0, r4
}
   31798:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		for (i = 0; i < ARRAY_SIZE(cf_cfg); i++) {
   3179a:	3410      	adds	r4, #16
   3179c:	2cc0      	cmp	r4, #192	; 0xc0
   3179e:	f105 0510 	add.w	r5, r5, #16
   317a2:	d1ee      	bne.n	31782 <find_cf_cfg_by_addr+0xa>
	return NULL;
   317a4:	2000      	movs	r0, #0
   317a6:	e7f7      	b.n	31798 <find_cf_cfg_by_addr+0x20>
   317a8:	20004045 	.word	0x20004045
   317ac:	20004044 	.word	0x20004044

000317b0 <gatt_sub_remove>:
{
   317b0:	b538      	push	{r3, r4, r5, lr}
   317b2:	460c      	mov	r4, r1
	if (params) {
   317b4:	4619      	mov	r1, r3
   317b6:	b16b      	cbz	r3, 317d4 <gatt_sub_remove+0x24>
		sys_slist_remove(&sub->list, prev, &params->node);
   317b8:	f103 0520 	add.w	r5, r3, #32
   317bc:	6a1b      	ldr	r3, [r3, #32]
 */
static inline void sys_slist_remove(sys_slist_t *list,
				    sys_snode_t *prev_node,
				    sys_snode_t *node);

Z_GENLIST_REMOVE(slist, snode)
   317be:	b98a      	cbnz	r2, 317e4 <gatt_sub_remove+0x34>
   317c0:	68e2      	ldr	r2, [r4, #12]
	list->head = node;
   317c2:	60a3      	str	r3, [r4, #8]
Z_GENLIST_REMOVE(slist, snode)
   317c4:	4295      	cmp	r5, r2
   317c6:	d100      	bne.n	317ca <gatt_sub_remove+0x1a>
	list->tail = node;
   317c8:	60e3      	str	r3, [r4, #12]
	parent->next = child;
   317ca:	2300      	movs	r3, #0
		params->notify(conn, params, NULL, 0);
   317cc:	680d      	ldr	r5, [r1, #0]
   317ce:	620b      	str	r3, [r1, #32]
   317d0:	461a      	mov	r2, r3
   317d2:	47a8      	blx	r5
	if (gatt_sub_is_empty(sub)) {
   317d4:	68a3      	ldr	r3, [r4, #8]
   317d6:	b95b      	cbnz	r3, 317f0 <gatt_sub_remove+0x40>
	bt_addr_le_copy(&sub->peer, BT_ADDR_LE_ANY);
   317d8:	1c60      	adds	r0, r4, #1
   317da:	4906      	ldr	r1, [pc, #24]	; (317f4 <gatt_sub_remove+0x44>)
}
   317dc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	bt_addr_le_copy(&sub->peer, BT_ADDR_LE_ANY);
   317e0:	f01b bc09 	b.w	4cff6 <bt_addr_le_copy>
   317e4:	6013      	str	r3, [r2, #0]
Z_GENLIST_REMOVE(slist, snode)
   317e6:	68e3      	ldr	r3, [r4, #12]
   317e8:	429d      	cmp	r5, r3
	list->tail = node;
   317ea:	bf08      	it	eq
   317ec:	60e2      	streq	r2, [r4, #12]
}
   317ee:	e7ec      	b.n	317ca <gatt_sub_remove+0x1a>
}
   317f0:	bd38      	pop	{r3, r4, r5, pc}
   317f2:	bf00      	nop
   317f4:	00053517 	.word	0x00053517

000317f8 <ccc_load>:
{
   317f8:	b570      	push	{r4, r5, r6, lr}
	if (attr->write != bt_gatt_attr_write_ccc) {
   317fa:	4b20      	ldr	r3, [pc, #128]	; (3187c <ccc_load+0x84>)
{
   317fc:	4614      	mov	r4, r2
	if (attr->write != bt_gatt_attr_write_ccc) {
   317fe:	6882      	ldr	r2, [r0, #8]
   31800:	429a      	cmp	r2, r3
   31802:	d10f      	bne.n	31824 <ccc_load+0x2c>
	if (!load->entry) {
   31804:	68a5      	ldr	r5, [r4, #8]
	ccc = attr->user_data;
   31806:	68c6      	ldr	r6, [r0, #12]
	if (!load->entry) {
   31808:	b975      	cbnz	r5, 31828 <ccc_load+0x30>
	cfg = ccc_find_cfg(ccc, addr, id);
   3180a:	7922      	ldrb	r2, [r4, #4]
   3180c:	6821      	ldr	r1, [r4, #0]
   3180e:	4630      	mov	r0, r6
   31810:	f01b fbc2 	bl	4cf98 <ccc_find_cfg>
	if (!cfg) {
   31814:	4604      	mov	r4, r0
   31816:	b128      	cbz	r0, 31824 <ccc_load+0x2c>
	bt_addr_le_copy(&cfg->peer, BT_ADDR_LE_ANY);
   31818:	4919      	ldr	r1, [pc, #100]	; (31880 <ccc_load+0x88>)
   3181a:	3001      	adds	r0, #1
   3181c:	f01b fbeb 	bl	4cff6 <bt_addr_le_copy>
	cfg->id = 0U;
   31820:	7025      	strb	r5, [r4, #0]
	cfg->value = 0U;
   31822:	8125      	strh	r5, [r4, #8]
		return BT_GATT_ITER_CONTINUE;
   31824:	2001      	movs	r0, #1
}
   31826:	bd70      	pop	{r4, r5, r6, pc}
	} else if (!load->count) {
   31828:	68e0      	ldr	r0, [r4, #12]
   3182a:	2800      	cmp	r0, #0
   3182c:	d0fb      	beq.n	31826 <ccc_load+0x2e>
	if (load->entry->handle != handle) {
   3182e:	882b      	ldrh	r3, [r5, #0]
   31830:	428b      	cmp	r3, r1
   31832:	d00a      	beq.n	3184a <ccc_load+0x52>
		if (load->entry->handle < handle) {
   31834:	d2f6      	bcs.n	31824 <ccc_load+0x2c>
	load->count--;
   31836:	68e0      	ldr	r0, [r4, #12]
	load->entry++;
   31838:	68a3      	ldr	r3, [r4, #8]
	load->count--;
   3183a:	3801      	subs	r0, #1
	load->entry++;
   3183c:	3304      	adds	r3, #4
	load->count--;
   3183e:	60e0      	str	r0, [r4, #12]
	return load->count ? BT_GATT_ITER_CONTINUE : BT_GATT_ITER_STOP;
   31840:	3800      	subs	r0, #0
	load->entry++;
   31842:	60a3      	str	r3, [r4, #8]
	return load->count ? BT_GATT_ITER_CONTINUE : BT_GATT_ITER_STOP;
   31844:	bf18      	it	ne
   31846:	2001      	movne	r0, #1
   31848:	e7ed      	b.n	31826 <ccc_load+0x2e>
	cfg = ccc_find_cfg(ccc, load->addr_with_id.addr, load->addr_with_id.id);
   3184a:	7922      	ldrb	r2, [r4, #4]
   3184c:	6821      	ldr	r1, [r4, #0]
   3184e:	4630      	mov	r0, r6
   31850:	f01b fba2 	bl	4cf98 <ccc_find_cfg>
	if (!cfg) {
   31854:	4605      	mov	r5, r0
   31856:	b968      	cbnz	r0, 31874 <ccc_load+0x7c>
		cfg = ccc_find_cfg(ccc, BT_ADDR_LE_ANY, 0);
   31858:	4602      	mov	r2, r0
   3185a:	4909      	ldr	r1, [pc, #36]	; (31880 <ccc_load+0x88>)
   3185c:	4630      	mov	r0, r6
   3185e:	f01b fb9b 	bl	4cf98 <ccc_find_cfg>
		if (!cfg) {
   31862:	4605      	mov	r5, r0
   31864:	2800      	cmp	r0, #0
   31866:	d0e6      	beq.n	31836 <ccc_load+0x3e>
		bt_addr_le_copy(&cfg->peer, load->addr_with_id.addr);
   31868:	6821      	ldr	r1, [r4, #0]
   3186a:	3001      	adds	r0, #1
   3186c:	f01b fbc3 	bl	4cff6 <bt_addr_le_copy>
		cfg->id = load->addr_with_id.id;
   31870:	7923      	ldrb	r3, [r4, #4]
   31872:	702b      	strb	r3, [r5, #0]
	cfg->value = load->entry->value;
   31874:	68a3      	ldr	r3, [r4, #8]
   31876:	885b      	ldrh	r3, [r3, #2]
   31878:	812b      	strh	r3, [r5, #8]
   3187a:	e7dc      	b.n	31836 <ccc_load+0x3e>
   3187c:	00031c69 	.word	0x00031c69
   31880:	00053517 	.word	0x00053517

00031884 <sc_store>:
{
   31884:	b570      	push	{r4, r5, r6, lr}
	if (cfg->id) {
   31886:	4605      	mov	r5, r0
{
   31888:	b08c      	sub	sp, #48	; 0x30
	if (cfg->id) {
   3188a:	f815 2b01 	ldrb.w	r2, [r5], #1
{
   3188e:	4604      	mov	r4, r0
	if (cfg->id) {
   31890:	b19a      	cbz	r2, 318ba <sc_store+0x36>
		u8_to_dec(id_str, sizeof(id_str), cfg->id);
   31892:	ae02      	add	r6, sp, #8
   31894:	2104      	movs	r1, #4
   31896:	4630      	mov	r0, r6
   31898:	f017 f839 	bl	4890e <u8_to_dec>
		bt_settings_encode_key(key, sizeof(key), "sc",
   3189c:	9600      	str	r6, [sp, #0]
		bt_settings_encode_key(key, sizeof(key), "sc",
   3189e:	462b      	mov	r3, r5
   318a0:	a803      	add	r0, sp, #12
   318a2:	4a07      	ldr	r2, [pc, #28]	; (318c0 <sc_store+0x3c>)
   318a4:	2124      	movs	r1, #36	; 0x24
   318a6:	f7fb ff9f 	bl	2d7e8 <bt_settings_encode_key>
	err = settings_save_one(key, (char *)&cfg->data, sizeof(cfg->data));
   318aa:	2204      	movs	r2, #4
   318ac:	f104 0108 	add.w	r1, r4, #8
   318b0:	a803      	add	r0, sp, #12
   318b2:	f7fa fdf3 	bl	2c49c <settings_save_one>
}
   318b6:	b00c      	add	sp, #48	; 0x30
   318b8:	bd70      	pop	{r4, r5, r6, pc}
		bt_settings_encode_key(key, sizeof(key), "sc",
   318ba:	9200      	str	r2, [sp, #0]
   318bc:	e7ef      	b.n	3189e <sc_store+0x1a>
   318be:	bf00      	nop
   318c0:	00053799 	.word	0x00053799

000318c4 <sc_save>:
{
   318c4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   318c8:	4680      	mov	r8, r0
   318ca:	460f      	mov	r7, r1
   318cc:	4616      	mov	r6, r2
   318ce:	461d      	mov	r5, r3
	cfg = find_sc_cfg(id, peer);
   318d0:	f7ff fef4 	bl	316bc <find_sc_cfg>
	if (!cfg) {
   318d4:	4604      	mov	r4, r0
   318d6:	b948      	cbnz	r0, 318ec <sc_save+0x28>
		cfg = find_sc_cfg(BT_ID_DEFAULT, BT_ADDR_LE_ANY);
   318d8:	4912      	ldr	r1, [pc, #72]	; (31924 <sc_save+0x60>)
   318da:	f7ff feef 	bl	316bc <find_sc_cfg>
		if (!cfg) {
   318de:	4604      	mov	r4, r0
   318e0:	b1c8      	cbz	r0, 31916 <sc_save+0x52>
		cfg->id = id;
   318e2:	f800 8b01 	strb.w	r8, [r0], #1
		bt_addr_le_copy(&cfg->peer, peer);
   318e6:	4639      	mov	r1, r7
   318e8:	f01b fb85 	bl	4cff6 <bt_addr_le_copy>
	if (!(cfg->data.start || cfg->data.end)) {
   318ec:	8922      	ldrh	r2, [r4, #8]
   318ee:	8963      	ldrh	r3, [r4, #10]
   318f0:	b96a      	cbnz	r2, 3190e <sc_save+0x4a>
   318f2:	b973      	cbnz	r3, 31912 <sc_save+0x4e>
		cfg->data.start = start;
   318f4:	8126      	strh	r6, [r4, #8]
		*end = new_end;
   318f6:	8165      	strh	r5, [r4, #10]
	    modified && bt_addr_le_is_bonded(cfg->id, &cfg->peer)) {
   318f8:	4621      	mov	r1, r4
   318fa:	f811 0b01 	ldrb.w	r0, [r1], #1
   318fe:	f019 ff05 	bl	4b70c <bt_addr_le_is_bonded>
   31902:	b140      	cbz	r0, 31916 <sc_save+0x52>
		sc_store(cfg);
   31904:	4620      	mov	r0, r4
}
   31906:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		sc_store(cfg);
   3190a:	f7ff bfbb 	b.w	31884 <sc_store>
	if (new_start >= *start && new_end <= *end) {
   3190e:	4296      	cmp	r6, r2
   31910:	d303      	bcc.n	3191a <sc_save+0x56>
   31912:	429d      	cmp	r5, r3
   31914:	d8ef      	bhi.n	318f6 <sc_save+0x32>
}
   31916:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (*end < new_end) {
   3191a:	429d      	cmp	r5, r3
		*start = new_start;
   3191c:	8126      	strh	r6, [r4, #8]
	if (*end < new_end) {
   3191e:	d9eb      	bls.n	318f8 <sc_save+0x34>
   31920:	e7e9      	b.n	318f6 <sc_save+0x32>
   31922:	bf00      	nop
   31924:	00053517 	.word	0x00053517

00031928 <sc_set>:
{
   31928:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
   3192c:	460e      	mov	r6, r1
   3192e:	4617      	mov	r7, r2
   31930:	4698      	mov	r8, r3
	if (!name) {
   31932:	4605      	mov	r5, r0
   31934:	b928      	cbnz	r0, 31942 <sc_set+0x1a>
		return -EINVAL;
   31936:	f06f 0415 	mvn.w	r4, #21
}
   3193a:	4620      	mov	r0, r4
   3193c:	b004      	add	sp, #16
   3193e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	err = bt_settings_decode_key(name, &addr);
   31942:	a902      	add	r1, sp, #8
   31944:	f019 fb34 	bl	4afb0 <bt_settings_decode_key>
	if (err) {
   31948:	4604      	mov	r4, r0
   3194a:	2800      	cmp	r0, #0
   3194c:	d1f3      	bne.n	31936 <sc_set+0xe>
	settings_name_next(name, &next);
   3194e:	a901      	add	r1, sp, #4
   31950:	4628      	mov	r0, r5
   31952:	f017 ff06 	bl	49762 <settings_name_next>
	if (!next) {
   31956:	9801      	ldr	r0, [sp, #4]
   31958:	b9d0      	cbnz	r0, 31990 <sc_set+0x68>
	cfg = find_sc_cfg(id, &addr);
   3195a:	a902      	add	r1, sp, #8
   3195c:	2000      	movs	r0, #0
   3195e:	f7ff fead 	bl	316bc <find_sc_cfg>
	if (!cfg && len_rd) {
   31962:	4605      	mov	r5, r0
   31964:	b9d8      	cbnz	r0, 3199e <sc_set+0x76>
   31966:	2e00      	cmp	r6, #0
   31968:	d0e7      	beq.n	3193a <sc_set+0x12>
		cfg = find_sc_cfg(BT_ID_DEFAULT, BT_ADDR_LE_ANY);
   3196a:	4912      	ldr	r1, [pc, #72]	; (319b4 <sc_set+0x8c>)
   3196c:	f7ff fea6 	bl	316bc <find_sc_cfg>
		if (!cfg) {
   31970:	4605      	mov	r5, r0
   31972:	b1d8      	cbz	r0, 319ac <sc_set+0x84>
		cfg->id = id;
   31974:	2300      	movs	r3, #0
   31976:	f800 3b01 	strb.w	r3, [r0], #1
		bt_addr_le_copy(&cfg->peer, &addr);
   3197a:	a902      	add	r1, sp, #8
   3197c:	f01b fb3b 	bl	4cff6 <bt_addr_le_copy>
		len = read_cb(cb_arg, &cfg->data, sizeof(cfg->data));
   31980:	2204      	movs	r2, #4
   31982:	f105 0108 	add.w	r1, r5, #8
   31986:	4640      	mov	r0, r8
   31988:	47b8      	blx	r7
		if (len < 0) {
   3198a:	ea00 74e0 	and.w	r4, r0, r0, asr #31
   3198e:	e7d4      	b.n	3193a <sc_set+0x12>
		unsigned long next_id = strtoul(next, NULL, 10);
   31990:	220a      	movs	r2, #10
   31992:	4621      	mov	r1, r4
   31994:	f019 f928 	bl	4abe8 <strtoul>
		if (next_id >= CONFIG_BT_ID_MAX) {
   31998:	2800      	cmp	r0, #0
   3199a:	d0de      	beq.n	3195a <sc_set+0x32>
   3199c:	e7cb      	b.n	31936 <sc_set+0xe>
	if (len_rd) {
   3199e:	2e00      	cmp	r6, #0
   319a0:	d1ee      	bne.n	31980 <sc_set+0x58>
		memset(cfg, 0, sizeof(*cfg));
   319a2:	220c      	movs	r2, #12
   319a4:	4631      	mov	r1, r6
   319a6:	f019 fa73 	bl	4ae90 <memset>
		BT_DBG("Removed SC for %s", bt_addr_le_str(&addr));
   319aa:	e7c6      	b.n	3193a <sc_set+0x12>
			return -ENOMEM;
   319ac:	f06f 040b 	mvn.w	r4, #11
   319b0:	e7c3      	b.n	3193a <sc_set+0x12>
   319b2:	bf00      	nop
   319b4:	00053517 	.word	0x00053517

000319b8 <db_hash_commit>:

static int db_hash_commit(void)
{
   319b8:	b508      	push	{r3, lr}
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
   319ba:	2108      	movs	r1, #8
   319bc:	4805      	ldr	r0, [pc, #20]	; (319d4 <db_hash_commit+0x1c>)
   319be:	f01b fb0b 	bl	4cfd8 <atomic_or>
	atomic_set_bit(gatt_sc.flags, DB_HASH_LOAD);
	/* Reschedule work to calculate and compare against the Hash value
	 * loaded from flash.
	 */
	if (IS_ENABLED(CONFIG_BT_LONG_WQ)) {
		err = bt_long_wq_reschedule(&db_hash.work, K_NO_WAIT);
   319c2:	2200      	movs	r2, #0
   319c4:	2300      	movs	r3, #0
   319c6:	4804      	ldr	r0, [pc, #16]	; (319d8 <db_hash_commit+0x20>)
   319c8:	f7fb ff9e 	bl	2d908 <bt_long_wq_reschedule>
	if (err) {
		BT_ERR("Unable to reschedule database hash process (err %d)", err);
	}

	return err;
}
   319cc:	ea00 70e0 	and.w	r0, r0, r0, asr #31
   319d0:	bd08      	pop	{r3, pc}
   319d2:	bf00      	nop
   319d4:	20001db8 	.word	0x20001db8
   319d8:	20001d10 	.word	0x20001d10

000319dc <clear_cf_cfg>:
{
   319dc:	b510      	push	{r4, lr}
	bt_addr_le_copy(&cfg->peer, BT_ADDR_LE_ANY);
   319de:	490c      	ldr	r1, [pc, #48]	; (31a10 <clear_cf_cfg+0x34>)
{
   319e0:	4604      	mov	r4, r0
	bt_addr_le_copy(&cfg->peer, BT_ADDR_LE_ANY);
   319e2:	3001      	adds	r0, #1
   319e4:	f01b fb07 	bl	4cff6 <bt_addr_le_copy>
	memset(cfg->data, 0, sizeof(cfg->data));
   319e8:	f104 0008 	add.w	r0, r4, #8
   319ec:	2201      	movs	r2, #1
   319ee:	2100      	movs	r1, #0
   319f0:	f019 fa4e 	bl	4ae90 <memset>
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   319f4:	f3bf 8f5b 	dmb	ish
   319f8:	340c      	adds	r4, #12
   319fa:	2300      	movs	r3, #0
   319fc:	e854 2f00 	ldrex	r2, [r4]
   31a00:	e844 3100 	strex	r1, r3, [r4]
   31a04:	2900      	cmp	r1, #0
   31a06:	d1f9      	bne.n	319fc <clear_cf_cfg+0x20>
   31a08:	f3bf 8f5b 	dmb	ish
}
   31a0c:	bd10      	pop	{r4, pc}
   31a0e:	bf00      	nop
   31a10:	00053517 	.word	0x00053517

00031a14 <remove_peer_from_attr>:
#endif /*CONFIG_BT_GATT_CACHING */
#endif /* CONFIG_BT_SETTINGS */

static uint8_t remove_peer_from_attr(const struct bt_gatt_attr *attr,
				     uint16_t handle, void *user_data)
{
   31a14:	b508      	push	{r3, lr}
   31a16:	4613      	mov	r3, r2
	const struct addr_with_id *addr_with_id = user_data;
	struct _bt_gatt_ccc *ccc;
	struct bt_gatt_ccc_cfg *cfg;

	/* Check if attribute is a CCC */
	if (attr->write != bt_gatt_attr_write_ccc) {
   31a18:	6881      	ldr	r1, [r0, #8]
   31a1a:	4a07      	ldr	r2, [pc, #28]	; (31a38 <remove_peer_from_attr+0x24>)
   31a1c:	4291      	cmp	r1, r2
   31a1e:	d109      	bne.n	31a34 <remove_peer_from_attr+0x20>
	}

	ccc = attr->user_data;

	/* Check if there is a cfg for the peer */
	cfg = ccc_find_cfg(ccc, addr_with_id->addr, addr_with_id->id);
   31a20:	791a      	ldrb	r2, [r3, #4]
   31a22:	6819      	ldr	r1, [r3, #0]
   31a24:	68c0      	ldr	r0, [r0, #12]
   31a26:	f01b fab7 	bl	4cf98 <ccc_find_cfg>
	if (cfg) {
   31a2a:	b118      	cbz	r0, 31a34 <remove_peer_from_attr+0x20>
		memset(cfg, 0, sizeof(*cfg));
   31a2c:	220a      	movs	r2, #10
   31a2e:	2100      	movs	r1, #0
   31a30:	f019 fa2e 	bl	4ae90 <memset>
	}

	return BT_GATT_ITER_CONTINUE;
}
   31a34:	2001      	movs	r0, #1
   31a36:	bd08      	pop	{r3, pc}
   31a38:	00031c69 	.word	0x00031c69

00031a3c <convert_to_id_on_match>:
{
   31a3c:	b570      	push	{r4, r5, r6, lr}
	if (attr->write != bt_gatt_attr_write_ccc) {
   31a3e:	4b0b      	ldr	r3, [pc, #44]	; (31a6c <convert_to_id_on_match+0x30>)
{
   31a40:	4616      	mov	r6, r2
	if (attr->write != bt_gatt_attr_write_ccc) {
   31a42:	6882      	ldr	r2, [r0, #8]
   31a44:	429a      	cmp	r2, r3
   31a46:	d10e      	bne.n	31a66 <convert_to_id_on_match+0x2a>
   31a48:	68c5      	ldr	r5, [r0, #12]
	for (size_t i = 0; i < ARRAY_SIZE(ccc->cfg); i++) {
   31a4a:	1c6c      	adds	r4, r5, #1
   31a4c:	353d      	adds	r5, #61	; 0x3d
		if (bt_addr_le_cmp(&ccc->cfg[i].peer, match->private_addr) == 0) {
   31a4e:	6831      	ldr	r1, [r6, #0]
   31a50:	4620      	mov	r0, r4
   31a52:	f01b fa9e 	bl	4cf92 <bt_addr_le_cmp>
   31a56:	b918      	cbnz	r0, 31a60 <convert_to_id_on_match+0x24>
			bt_addr_le_copy(&ccc->cfg[i].peer, match->id_addr);
   31a58:	6871      	ldr	r1, [r6, #4]
   31a5a:	4620      	mov	r0, r4
   31a5c:	f01b facb 	bl	4cff6 <bt_addr_le_copy>
	for (size_t i = 0; i < ARRAY_SIZE(ccc->cfg); i++) {
   31a60:	340a      	adds	r4, #10
   31a62:	42ac      	cmp	r4, r5
   31a64:	d1f3      	bne.n	31a4e <convert_to_id_on_match+0x12>
}
   31a66:	2001      	movs	r0, #1
   31a68:	bd70      	pop	{r4, r5, r6, pc}
   31a6a:	bf00      	nop
   31a6c:	00031c69 	.word	0x00031c69

00031a70 <ccc_save>:
{
   31a70:	b538      	push	{r3, r4, r5, lr}
	if (attr->write != bt_gatt_attr_write_ccc) {
   31a72:	4b0c      	ldr	r3, [pc, #48]	; (31aa4 <ccc_save+0x34>)
{
   31a74:	4614      	mov	r4, r2
	if (attr->write != bt_gatt_attr_write_ccc) {
   31a76:	6882      	ldr	r2, [r0, #8]
   31a78:	429a      	cmp	r2, r3
{
   31a7a:	460d      	mov	r5, r1
	if (attr->write != bt_gatt_attr_write_ccc) {
   31a7c:	d10f      	bne.n	31a9e <ccc_save+0x2e>
	cfg = ccc_find_cfg(ccc, save->addr_with_id.addr, save->addr_with_id.id);
   31a7e:	7922      	ldrb	r2, [r4, #4]
   31a80:	6821      	ldr	r1, [r4, #0]
   31a82:	68c0      	ldr	r0, [r0, #12]
   31a84:	f01b fa88 	bl	4cf98 <ccc_find_cfg>
	if (!cfg) {
   31a88:	b148      	cbz	r0, 31a9e <ccc_save+0x2e>
	save->store[save->count].handle = handle;
   31a8a:	f8d4 30c8 	ldr.w	r3, [r4, #200]	; 0xc8
   31a8e:	eb04 0283 	add.w	r2, r4, r3, lsl #2
	save->count++;
   31a92:	3301      	adds	r3, #1
	save->store[save->count].handle = handle;
   31a94:	8115      	strh	r5, [r2, #8]
	save->store[save->count].value = cfg->value;
   31a96:	8901      	ldrh	r1, [r0, #8]
   31a98:	8151      	strh	r1, [r2, #10]
	save->count++;
   31a9a:	f8c4 30c8 	str.w	r3, [r4, #200]	; 0xc8
}
   31a9e:	2001      	movs	r0, #1
   31aa0:	bd38      	pop	{r3, r4, r5, pc}
   31aa2:	bf00      	nop
   31aa4:	00031c69 	.word	0x00031c69

00031aa8 <bt_gatt_store_cf.isra.0>:
static int bt_gatt_store_cf(struct bt_conn *conn)
   31aa8:	b5f0      	push	{r4, r5, r6, r7, lr}
   31aaa:	b08d      	sub	sp, #52	; 0x34
   31aac:	4605      	mov	r5, r0
	cfg = find_cf_cfg(conn);
   31aae:	f7ff fde1 	bl	31674 <find_cf_cfg>
					       &conn->le.dst, id_str);
   31ab2:	f105 0688 	add.w	r6, r5, #136	; 0x88
	if (!cfg) {
   31ab6:	4604      	mov	r4, r0
   31ab8:	b300      	cbz	r0, 31afc <bt_gatt_store_cf.isra.0+0x54>
		if (conn->id) {
   31aba:	7a2a      	ldrb	r2, [r5, #8]
		str = (char *)cfg->data;
   31abc:	3408      	adds	r4, #8
		if (conn->id) {
   31abe:	b16a      	cbz	r2, 31adc <bt_gatt_store_cf.isra.0+0x34>
			u8_to_dec(id_str, sizeof(id_str), conn->id);
   31ac0:	af02      	add	r7, sp, #8
   31ac2:	2104      	movs	r1, #4
   31ac4:	4638      	mov	r0, r7
   31ac6:	f016 ff22 	bl	4890e <u8_to_dec>
			bt_settings_encode_key(key, sizeof(key), "cf",
   31aca:	4633      	mov	r3, r6
   31acc:	4a0d      	ldr	r2, [pc, #52]	; (31b04 <bt_gatt_store_cf.isra.0+0x5c>)
   31ace:	9700      	str	r7, [sp, #0]
   31ad0:	2124      	movs	r1, #36	; 0x24
   31ad2:	a803      	add	r0, sp, #12
   31ad4:	f7fb fe88 	bl	2d7e8 <bt_settings_encode_key>
	if (!cfg || !conn->id) {
   31ad8:	7a2b      	ldrb	r3, [r5, #8]
   31ada:	b98b      	cbnz	r3, 31b00 <bt_gatt_store_cf.isra.0+0x58>
		len = 0;
   31adc:	2501      	movs	r5, #1
		bt_settings_encode_key(key, sizeof(key), "cf",
   31ade:	2300      	movs	r3, #0
   31ae0:	9300      	str	r3, [sp, #0]
   31ae2:	4a08      	ldr	r2, [pc, #32]	; (31b04 <bt_gatt_store_cf.isra.0+0x5c>)
   31ae4:	4633      	mov	r3, r6
   31ae6:	2124      	movs	r1, #36	; 0x24
   31ae8:	a803      	add	r0, sp, #12
   31aea:	f7fb fe7d 	bl	2d7e8 <bt_settings_encode_key>
	err = settings_save_one(key, str, len);
   31aee:	462a      	mov	r2, r5
   31af0:	4621      	mov	r1, r4
   31af2:	a803      	add	r0, sp, #12
   31af4:	f7fa fcd2 	bl	2c49c <settings_save_one>
}
   31af8:	b00d      	add	sp, #52	; 0x34
   31afa:	bdf0      	pop	{r4, r5, r6, r7, pc}
		len = 0;
   31afc:	4605      	mov	r5, r0
   31afe:	e7ee      	b.n	31ade <bt_gatt_store_cf.isra.0+0x36>
   31b00:	2501      	movs	r5, #1
   31b02:	e7f4      	b.n	31aee <bt_gatt_store_cf.isra.0+0x46>
   31b04:	00053793 	.word	0x00053793

00031b08 <bt_gatt_clear_sc>:
{
   31b08:	b570      	push	{r4, r5, r6, lr}
   31b0a:	b08c      	sub	sp, #48	; 0x30
	cfg = find_sc_cfg(id, (bt_addr_le_t *)addr);
   31b0c:	f7ff fdd6 	bl	316bc <find_sc_cfg>
	if (!cfg) {
   31b10:	4604      	mov	r4, r0
   31b12:	b1b8      	cbz	r0, 31b44 <bt_gatt_clear_sc+0x3c>
		if (cfg->id) {
   31b14:	4605      	mov	r5, r0
   31b16:	f815 2b01 	ldrb.w	r2, [r5], #1
   31b1a:	b1b2      	cbz	r2, 31b4a <bt_gatt_clear_sc+0x42>
			u8_to_dec(id_str, sizeof(id_str), cfg->id);
   31b1c:	ae02      	add	r6, sp, #8
   31b1e:	2104      	movs	r1, #4
   31b20:	4630      	mov	r0, r6
   31b22:	f016 fef4 	bl	4890e <u8_to_dec>
			bt_settings_encode_key(key, sizeof(key), "sc",
   31b26:	9600      	str	r6, [sp, #0]
			bt_settings_encode_key(key, sizeof(key), "sc",
   31b28:	4a09      	ldr	r2, [pc, #36]	; (31b50 <bt_gatt_clear_sc+0x48>)
   31b2a:	2124      	movs	r1, #36	; 0x24
   31b2c:	462b      	mov	r3, r5
   31b2e:	a803      	add	r0, sp, #12
   31b30:	f7fb fe5a 	bl	2d7e8 <bt_settings_encode_key>
		err = settings_delete(key);
   31b34:	a803      	add	r0, sp, #12
   31b36:	f017 fdec 	bl	49712 <settings_delete>
	memset(cfg, 0, sizeof(*cfg));
   31b3a:	220c      	movs	r2, #12
   31b3c:	2100      	movs	r1, #0
   31b3e:	4620      	mov	r0, r4
   31b40:	f019 f9a6 	bl	4ae90 <memset>
}
   31b44:	2000      	movs	r0, #0
   31b46:	b00c      	add	sp, #48	; 0x30
   31b48:	bd70      	pop	{r4, r5, r6, pc}
			bt_settings_encode_key(key, sizeof(key), "sc",
   31b4a:	9200      	str	r2, [sp, #0]
   31b4c:	e7ec      	b.n	31b28 <bt_gatt_clear_sc+0x20>
   31b4e:	bf00      	nop
   31b50:	00053799 	.word	0x00053799

00031b54 <read_ppcp>:
{
   31b54:	b513      	push	{r0, r1, r4, lr}
   31b56:	f8bd 1010 	ldrh.w	r1, [sp, #16]
	ppcp.latency = sys_cpu_to_le16(CONFIG_BT_PERIPHERAL_PREF_LATENCY);
   31b5a:	4c0b      	ldr	r4, [pc, #44]	; (31b88 <read_ppcp+0x34>)
{
   31b5c:	4610      	mov	r0, r2
	ppcp.latency = sys_cpu_to_le16(CONFIG_BT_PERIPHERAL_PREF_LATENCY);
   31b5e:	4a0b      	ldr	r2, [pc, #44]	; (31b8c <read_ppcp+0x38>)
	if (offset > value_len) {
   31b60:	2908      	cmp	r1, #8
	ppcp.latency = sys_cpu_to_le16(CONFIG_BT_PERIPHERAL_PREF_LATENCY);
   31b62:	e9cd 4200 	strd	r4, r2, [sp]
	if (offset > value_len) {
   31b66:	d80b      	bhi.n	31b80 <read_ppcp+0x2c>
	len = MIN(buf_len, value_len - offset);
   31b68:	f1c1 0408 	rsb	r4, r1, #8
   31b6c:	429c      	cmp	r4, r3
   31b6e:	bfa8      	it	ge
   31b70:	461c      	movge	r4, r3
	memcpy(buf, (uint8_t *)value + offset, len);
   31b72:	4622      	mov	r2, r4
   31b74:	4469      	add	r1, sp
   31b76:	f019 f980 	bl	4ae7a <memcpy>
}
   31b7a:	4620      	mov	r0, r4
   31b7c:	b002      	add	sp, #8
   31b7e:	bd10      	pop	{r4, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   31b80:	f06f 0406 	mvn.w	r4, #6
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &ppcp,
   31b84:	e7f9      	b.n	31b7a <read_ppcp+0x26>
   31b86:	bf00      	nop
   31b88:	000c0006 	.word	0x000c0006
   31b8c:	0190001e 	.word	0x0190001e

00031b90 <gatt_write_ccc>:
{
   31b90:	b507      	push	{r0, r1, r2, lr}
	return gatt_req_send(conn, gatt_write_ccc_rsp, params,
   31b92:	2312      	movs	r3, #18
{
   31b94:	460a      	mov	r2, r1
	return gatt_req_send(conn, gatt_write_ccc_rsp, params,
   31b96:	2104      	movs	r1, #4
   31b98:	e9cd 3100 	strd	r3, r1, [sp]
   31b9c:	4b03      	ldr	r3, [pc, #12]	; (31bac <gatt_write_ccc+0x1c>)
   31b9e:	4904      	ldr	r1, [pc, #16]	; (31bb0 <gatt_write_ccc+0x20>)
   31ba0:	f01b fc43 	bl	4d42a <gatt_req_send.constprop.0>
}
   31ba4:	b003      	add	sp, #12
   31ba6:	f85d fb04 	ldr.w	pc, [sp], #4
   31baa:	bf00      	nop
   31bac:	0004d4ab 	.word	0x0004d4ab
   31bb0:	0004d0a3 	.word	0x0004d0a3

00031bb4 <disconnected_cb>:
{
   31bb4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (attr->write != bt_gatt_attr_write_ccc) {
   31bb8:	4b28      	ldr	r3, [pc, #160]	; (31c5c <disconnected_cb+0xa8>)
{
   31bba:	4616      	mov	r6, r2
	if (attr->write != bt_gatt_attr_write_ccc) {
   31bbc:	6882      	ldr	r2, [r0, #8]
   31bbe:	429a      	cmp	r2, r3
{
   31bc0:	4607      	mov	r7, r0
	if (attr->write != bt_gatt_attr_write_ccc) {
   31bc2:	d12f      	bne.n	31c24 <disconnected_cb+0x70>
	ccc = attr->user_data;
   31bc4:	68c5      	ldr	r5, [r0, #12]
	if (!ccc->value) {
   31bc6:	8fab      	ldrh	r3, [r5, #60]	; 0x3c
   31bc8:	b363      	cbz	r3, 31c24 <disconnected_cb+0x70>
				if (ccc == &sc_ccc) {
   31bca:	f8df b094 	ldr.w	fp, [pc, #148]	; 31c60 <disconnected_cb+0xac>
   31bce:	1c6c      	adds	r4, r5, #1
   31bd0:	f105 0a3d 	add.w	sl, r5, #61	; 0x3d
	value_used = false;
   31bd4:	f04f 0800 	mov.w	r8, #0
			if (!bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
   31bd8:	f106 0988 	add.w	r9, r6, #136	; 0x88
		if (!cfg->value) {
   31bdc:	f8b4 3007 	ldrh.w	r3, [r4, #7]
   31be0:	b19b      	cbz	r3, 31c0a <disconnected_cb+0x56>
		if (!bt_conn_is_peer_addr_le(conn, cfg->id, &cfg->peer)) {
   31be2:	f814 1c01 	ldrb.w	r1, [r4, #-1]
   31be6:	4622      	mov	r2, r4
   31be8:	4630      	mov	r0, r6
   31bea:	f01a f99d 	bl	4bf28 <bt_conn_is_peer_addr_le>
   31bee:	b9e0      	cbnz	r0, 31c2a <disconnected_cb+0x76>
			tmp = bt_conn_lookup_addr_le(cfg->id, &cfg->peer);
   31bf0:	f814 0c01 	ldrb.w	r0, [r4, #-1]
   31bf4:	4621      	mov	r1, r4
   31bf6:	f7fe fab9 	bl	3016c <bt_conn_lookup_addr_le>
			if (tmp) {
   31bfa:	b130      	cbz	r0, 31c0a <disconnected_cb+0x56>
				if (tmp->state == BT_CONN_CONNECTED) {
   31bfc:	7b43      	ldrb	r3, [r0, #13]
					value_used = true;
   31bfe:	2b07      	cmp	r3, #7
   31c00:	bf08      	it	eq
   31c02:	f04f 0801 	moveq.w	r8, #1
				bt_conn_unref(tmp);
   31c06:	f01a f8de 	bl	4bdc6 <bt_conn_unref>
	for (i = 0; i < ARRAY_SIZE(ccc->cfg); i++) {
   31c0a:	340a      	adds	r4, #10
   31c0c:	4554      	cmp	r4, sl
   31c0e:	d1e5      	bne.n	31bdc <disconnected_cb+0x28>
	if (!value_used) {
   31c10:	f1b8 0f00 	cmp.w	r8, #0
   31c14:	d106      	bne.n	31c24 <disconnected_cb+0x70>
		if (ccc->cfg_changed) {
   31c16:	6c2b      	ldr	r3, [r5, #64]	; 0x40
		ccc->value = 0U;
   31c18:	f8a5 803c 	strh.w	r8, [r5, #60]	; 0x3c
		if (ccc->cfg_changed) {
   31c1c:	b113      	cbz	r3, 31c24 <disconnected_cb+0x70>
			ccc->cfg_changed(attr, ccc->value);
   31c1e:	4641      	mov	r1, r8
   31c20:	4638      	mov	r0, r7
   31c22:	4798      	blx	r3
}
   31c24:	2001      	movs	r0, #1
   31c26:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (!bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
   31c2a:	7a30      	ldrb	r0, [r6, #8]
   31c2c:	4649      	mov	r1, r9
   31c2e:	f019 fd6d 	bl	4b70c <bt_addr_le_is_bonded>
   31c32:	b970      	cbnz	r0, 31c52 <disconnected_cb+0x9e>
				if (ccc == &sc_ccc) {
   31c34:	455d      	cmp	r5, fp
   31c36:	d102      	bne.n	31c3e <disconnected_cb+0x8a>
					sc_clear(conn);
   31c38:	4630      	mov	r0, r6
   31c3a:	f01b fb25 	bl	4d288 <sc_clear>
	bt_addr_le_copy(&cfg->peer, BT_ADDR_LE_ANY);
   31c3e:	4909      	ldr	r1, [pc, #36]	; (31c64 <disconnected_cb+0xb0>)
   31c40:	4620      	mov	r0, r4
   31c42:	f01b f9d8 	bl	4cff6 <bt_addr_le_copy>
	cfg->id = 0U;
   31c46:	2300      	movs	r3, #0
   31c48:	f804 3c01 	strb.w	r3, [r4, #-1]
	cfg->value = 0U;
   31c4c:	f8a4 3007 	strh.w	r3, [r4, #7]
}
   31c50:	e7db      	b.n	31c0a <disconnected_cb+0x56>
				bt_addr_le_copy(&cfg->peer, &conn->le.dst);
   31c52:	4649      	mov	r1, r9
   31c54:	4620      	mov	r0, r4
   31c56:	f01b f9ce 	bl	4cff6 <bt_addr_le_copy>
   31c5a:	e7d6      	b.n	31c0a <disconnected_cb+0x56>
   31c5c:	00031c69 	.word	0x00031c69
   31c60:	20000704 	.word	0x20000704
   31c64:	00053517 	.word	0x00053517

00031c68 <bt_gatt_attr_write_ccc>:
{
   31c68:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   31c6c:	461f      	mov	r7, r3
   31c6e:	f8bd 3020 	ldrh.w	r3, [sp, #32]
	struct _bt_gatt_ccc *ccc = attr->user_data;
   31c72:	f8d1 900c 	ldr.w	r9, [r1, #12]
{
   31c76:	4605      	mov	r5, r0
   31c78:	4688      	mov	r8, r1
	if (offset) {
   31c7a:	2b00      	cmp	r3, #0
   31c7c:	d160      	bne.n	31d40 <bt_gatt_attr_write_ccc+0xd8>
	if (!len || len > sizeof(uint16_t)) {
   31c7e:	1e7b      	subs	r3, r7, #1
   31c80:	2b01      	cmp	r3, #1
   31c82:	d860      	bhi.n	31d46 <bt_gatt_attr_write_ccc+0xde>
	if (len < sizeof(uint16_t)) {
   31c84:	2f01      	cmp	r7, #1
	cfg = find_ccc_cfg(conn, ccc);
   31c86:	4649      	mov	r1, r9
		value = *(uint8_t *)buf;
   31c88:	7816      	ldrb	r6, [r2, #0]
   31c8a:	bf18      	it	ne
   31c8c:	8816      	ldrhne	r6, [r2, #0]
	cfg = find_ccc_cfg(conn, ccc);
   31c8e:	f7ff fd31 	bl	316f4 <find_ccc_cfg>
	if (!cfg) {
   31c92:	4604      	mov	r4, r0
   31c94:	b980      	cbnz	r0, 31cb8 <bt_gatt_attr_write_ccc+0x50>
		if (!value) {
   31c96:	b916      	cbnz	r6, 31c9e <bt_gatt_attr_write_ccc+0x36>
			return len;
   31c98:	4638      	mov	r0, r7
}
   31c9a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		cfg = find_ccc_cfg(NULL, ccc);
   31c9e:	4649      	mov	r1, r9
   31ca0:	f7ff fd28 	bl	316f4 <find_ccc_cfg>
		if (!cfg) {
   31ca4:	4604      	mov	r4, r0
   31ca6:	2800      	cmp	r0, #0
   31ca8:	d050      	beq.n	31d4c <bt_gatt_attr_write_ccc+0xe4>
		bt_addr_le_copy(&cfg->peer, &conn->le.dst);
   31caa:	f105 0188 	add.w	r1, r5, #136	; 0x88
   31cae:	3001      	adds	r0, #1
   31cb0:	f01b f9a1 	bl	4cff6 <bt_addr_le_copy>
		cfg->id = conn->id;
   31cb4:	7a2b      	ldrb	r3, [r5, #8]
   31cb6:	7023      	strb	r3, [r4, #0]
	if (ccc->cfg_write) {
   31cb8:	f8d9 3044 	ldr.w	r3, [r9, #68]	; 0x44
   31cbc:	bba3      	cbnz	r3, 31d28 <bt_gatt_attr_write_ccc+0xc0>
	value_changed = cfg->value != value;
   31cbe:	f8b4 a008 	ldrh.w	sl, [r4, #8]
	cfg->value = value;
   31cc2:	8126      	strh	r6, [r4, #8]
	if (cfg->value != ccc->value) {
   31cc4:	f8b9 303c 	ldrh.w	r3, [r9, #60]	; 0x3c
   31cc8:	42b3      	cmp	r3, r6
   31cca:	d003      	beq.n	31cd4 <bt_gatt_attr_write_ccc+0x6c>
		gatt_ccc_changed(attr, ccc);
   31ccc:	4649      	mov	r1, r9
   31cce:	4640      	mov	r0, r8
   31cd0:	f01b f8dc 	bl	4ce8c <gatt_ccc_changed>
	if (value_changed) {
   31cd4:	45b2      	cmp	sl, r6
   31cd6:	d01e      	beq.n	31d16 <bt_gatt_attr_write_ccc+0xae>
	return (conn == gatt_ccc_store.conn_list[bt_conn_index(conn)]);
   31cd8:	4628      	mov	r0, r5
   31cda:	f7fe f913 	bl	2ff04 <bt_conn_index>
   31cde:	f8df 8074 	ldr.w	r8, [pc, #116]	; 31d54 <bt_gatt_attr_write_ccc+0xec>
	if ((!gatt_ccc_conn_is_queued(conn)) &&
   31ce2:	f858 3020 	ldr.w	r3, [r8, r0, lsl #2]
   31ce6:	429d      	cmp	r5, r3
   31ce8:	d015      	beq.n	31d16 <bt_gatt_attr_write_ccc+0xae>
	    bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
   31cea:	7a28      	ldrb	r0, [r5, #8]
   31cec:	f105 0188 	add.w	r1, r5, #136	; 0x88
   31cf0:	f019 fd0c 	bl	4b70c <bt_addr_le_is_bonded>
	if ((!gatt_ccc_conn_is_queued(conn)) &&
   31cf4:	b178      	cbz	r0, 31d16 <bt_gatt_attr_write_ccc+0xae>
		gatt_ccc_store.conn_list[bt_conn_index(conn)] =
   31cf6:	4628      	mov	r0, r5
   31cf8:	f7fe f904 	bl	2ff04 <bt_conn_index>
   31cfc:	4681      	mov	r9, r0
			bt_conn_ref(conn);
   31cfe:	4628      	mov	r0, r5
   31d00:	f01a f846 	bl	4bd90 <bt_conn_ref>
		k_work_reschedule(&gatt_ccc_store.work, CCC_STORE_DELAY);
   31d04:	f44f 4200 	mov.w	r2, #32768	; 0x8000
		gatt_ccc_store.conn_list[bt_conn_index(conn)] =
   31d08:	f848 0029 	str.w	r0, [r8, r9, lsl #2]
		k_work_reschedule(&gatt_ccc_store.work, CCC_STORE_DELAY);
   31d0c:	2300      	movs	r3, #0
   31d0e:	f108 0018 	add.w	r0, r8, #24
   31d12:	f015 fc6b 	bl	475ec <k_work_reschedule>
	if (!value) {
   31d16:	2e00      	cmp	r6, #0
   31d18:	d1be      	bne.n	31c98 <bt_gatt_attr_write_ccc+0x30>
	bt_addr_le_copy(&cfg->peer, BT_ADDR_LE_ANY);
   31d1a:	490f      	ldr	r1, [pc, #60]	; (31d58 <bt_gatt_attr_write_ccc+0xf0>)
   31d1c:	1c60      	adds	r0, r4, #1
   31d1e:	f01b f96a 	bl	4cff6 <bt_addr_le_copy>
	cfg->id = 0U;
   31d22:	7026      	strb	r6, [r4, #0]
	cfg->value = 0U;
   31d24:	8126      	strh	r6, [r4, #8]
}
   31d26:	e7b7      	b.n	31c98 <bt_gatt_attr_write_ccc+0x30>
		ssize_t write = ccc->cfg_write(conn, attr, value);
   31d28:	4632      	mov	r2, r6
   31d2a:	4641      	mov	r1, r8
   31d2c:	4628      	mov	r0, r5
   31d2e:	4798      	blx	r3
		if (write < 0) {
   31d30:	2800      	cmp	r0, #0
   31d32:	dbb2      	blt.n	31c9a <bt_gatt_attr_write_ccc+0x32>
		if (write != sizeof(value) && write != 1) {
   31d34:	3801      	subs	r0, #1
   31d36:	2801      	cmp	r0, #1
   31d38:	d9c1      	bls.n	31cbe <bt_gatt_attr_write_ccc+0x56>
			return BT_GATT_ERR(BT_ATT_ERR_UNLIKELY);
   31d3a:	f06f 000d 	mvn.w	r0, #13
   31d3e:	e7ac      	b.n	31c9a <bt_gatt_attr_write_ccc+0x32>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   31d40:	f06f 0006 	mvn.w	r0, #6
   31d44:	e7a9      	b.n	31c9a <bt_gatt_attr_write_ccc+0x32>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
   31d46:	f06f 000c 	mvn.w	r0, #12
   31d4a:	e7a6      	b.n	31c9a <bt_gatt_attr_write_ccc+0x32>
			return BT_GATT_ERR(BT_ATT_ERR_INSUFFICIENT_RESOURCES);
   31d4c:	f06f 0010 	mvn.w	r0, #16
   31d50:	e7a3      	b.n	31c9a <bt_gatt_attr_write_ccc+0x32>
   31d52:	bf00      	nop
   31d54:	20001ca8 	.word	0x20001ca8
   31d58:	00053517 	.word	0x00053517

00031d5c <sc_commit>:
{
   31d5c:	b508      	push	{r3, lr}
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   31d5e:	4809      	ldr	r0, [pc, #36]	; (31d84 <sc_commit+0x28>)
   31d60:	f06f 0102 	mvn.w	r1, #2
   31d64:	f01b f98e 	bl	4d084 <atomic_and>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
   31d68:	4806      	ldr	r0, [pc, #24]	; (31d84 <sc_commit+0x28>)
   31d6a:	f01b f92f 	bl	4cfcc <atomic_get>
	if (atomic_test_bit(gatt_sc.flags, SC_RANGE_CHANGED)) {
   31d6e:	07c3      	lsls	r3, r0, #31
   31d70:	d505      	bpl.n	31d7e <sc_commit+0x22>
	k_work_reschedule(&gatt_sc.work, timeout);
   31d72:	4805      	ldr	r0, [pc, #20]	; (31d88 <sc_commit+0x2c>)
   31d74:	f44f 72a4 	mov.w	r2, #328	; 0x148
   31d78:	2300      	movs	r3, #0
   31d7a:	f015 fc37 	bl	475ec <k_work_reschedule>
}
   31d7e:	2000      	movs	r0, #0
   31d80:	bd08      	pop	{r3, pc}
   31d82:	bf00      	nop
   31d84:	20001db8 	.word	0x20001db8
   31d88:	20001d88 	.word	0x20001d88

00031d8c <sc_indicate_rsp>:
{
   31d8c:	b510      	push	{r4, lr}
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   31d8e:	f06f 0102 	mvn.w	r1, #2
   31d92:	4604      	mov	r4, r0
   31d94:	480f      	ldr	r0, [pc, #60]	; (31dd4 <sc_indicate_rsp+0x48>)
   31d96:	f01b f975 	bl	4d084 <atomic_and>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
   31d9a:	480e      	ldr	r0, [pc, #56]	; (31dd4 <sc_indicate_rsp+0x48>)
   31d9c:	f01b f916 	bl	4cfcc <atomic_get>
	if (atomic_test_bit(gatt_sc.flags, SC_RANGE_CHANGED)) {
   31da0:	07c2      	lsls	r2, r0, #31
   31da2:	d504      	bpl.n	31dae <sc_indicate_rsp+0x22>
	k_work_reschedule(&gatt_sc.work, timeout);
   31da4:	480c      	ldr	r0, [pc, #48]	; (31dd8 <sc_indicate_rsp+0x4c>)
   31da6:	2200      	movs	r2, #0
   31da8:	2300      	movs	r3, #0
   31daa:	f015 fc1f 	bl	475ec <k_work_reschedule>
	if (bt_att_fixed_chan_only(conn)) {
   31dae:	4620      	mov	r0, r4
   31db0:	f01b f83b 	bl	4ce2a <bt_att_fixed_chan_only>
   31db4:	b160      	cbz	r0, 31dd0 <sc_indicate_rsp+0x44>
		cfg = find_cf_cfg(conn);
   31db6:	4620      	mov	r0, r4
   31db8:	f7ff fc5c 	bl	31674 <find_cf_cfg>
		if (cfg && CF_ROBUST_CACHING(cfg)) {
   31dbc:	b140      	cbz	r0, 31dd0 <sc_indicate_rsp+0x44>
   31dbe:	7a03      	ldrb	r3, [r0, #8]
   31dc0:	07db      	lsls	r3, r3, #31
   31dc2:	d505      	bpl.n	31dd0 <sc_indicate_rsp+0x44>
}
   31dc4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
   31dc8:	2101      	movs	r1, #1
   31dca:	300c      	adds	r0, #12
   31dcc:	f01b b904 	b.w	4cfd8 <atomic_or>
   31dd0:	bd10      	pop	{r4, pc}
   31dd2:	bf00      	nop
   31dd4:	20001db8 	.word	0x20001db8
   31dd8:	20001d88 	.word	0x20001d88

00031ddc <bt_gatt_init>:
{
   31ddc:	b510      	push	{r4, lr}
	return __atomic_compare_exchange_n(target, &old_value, new_value,
   31dde:	4b26      	ldr	r3, [pc, #152]	; (31e78 <bt_gatt_init+0x9c>)
   31de0:	f3bf 8f5b 	dmb	ish
   31de4:	2201      	movs	r2, #1
   31de6:	e853 1f00 	ldrex	r1, [r3]
   31dea:	2900      	cmp	r1, #0
   31dec:	d103      	bne.n	31df6 <bt_gatt_init+0x1a>
   31dee:	e843 2000 	strex	r0, r2, [r3]
   31df2:	2800      	cmp	r0, #0
   31df4:	d1f7      	bne.n	31de6 <bt_gatt_init+0xa>
   31df6:	f3bf 8f5b 	dmb	ish
	if (!atomic_cas(&init, 0, 1)) {
   31dfa:	d13b      	bne.n	31e74 <bt_gatt_init+0x98>
   31dfc:	f3bf 8f5b 	dmb	ish
   31e00:	4b1e      	ldr	r3, [pc, #120]	; (31e7c <bt_gatt_init+0xa0>)
   31e02:	e853 1f00 	ldrex	r1, [r3]
   31e06:	2900      	cmp	r1, #0
   31e08:	d103      	bne.n	31e12 <bt_gatt_init+0x36>
   31e0a:	e843 2000 	strex	r0, r2, [r3]
   31e0e:	2800      	cmp	r0, #0
   31e10:	d1f7      	bne.n	31e02 <bt_gatt_init+0x26>
   31e12:	f3bf 8f5b 	dmb	ish
	if (!atomic_cas(&service_init, 0, 1)) {
   31e16:	d108      	bne.n	31e2a <bt_gatt_init+0x4e>
   31e18:	4919      	ldr	r1, [pc, #100]	; (31e80 <bt_gatt_init+0xa4>)
	STRUCT_SECTION_FOREACH(bt_gatt_service_static, svc) {
   31e1a:	4a1a      	ldr	r2, [pc, #104]	; (31e84 <bt_gatt_init+0xa8>)
   31e1c:	880b      	ldrh	r3, [r1, #0]
   31e1e:	4c1a      	ldr	r4, [pc, #104]	; (31e88 <bt_gatt_init+0xac>)
	if (!atomic_cas(&service_init, 0, 1)) {
   31e20:	2000      	movs	r0, #0
	STRUCT_SECTION_FOREACH(bt_gatt_service_static, svc) {
   31e22:	42a2      	cmp	r2, r4
   31e24:	d320      	bcc.n	31e68 <bt_gatt_init+0x8c>
   31e26:	b100      	cbz	r0, 31e2a <bt_gatt_init+0x4e>
   31e28:	800b      	strh	r3, [r1, #0]
	list->head = NULL;
   31e2a:	4b18      	ldr	r3, [pc, #96]	; (31e8c <bt_gatt_init+0xb0>)
	k_work_init_delayable(&db_hash.work, db_hash_process);
   31e2c:	4918      	ldr	r1, [pc, #96]	; (31e90 <bt_gatt_init+0xb4>)
   31e2e:	4819      	ldr	r0, [pc, #100]	; (31e94 <bt_gatt_init+0xb8>)
   31e30:	2200      	movs	r2, #0
	list->tail = NULL;
   31e32:	e9c3 2200 	strd	r2, r2, [r3]
   31e36:	f01e f8e5 	bl	50004 <k_work_init_delayable>
		bt_long_wq_schedule(&db_hash.work, DB_HASH_TIMEOUT);
   31e3a:	f44f 72a4 	mov.w	r2, #328	; 0x148
   31e3e:	2300      	movs	r3, #0
   31e40:	4814      	ldr	r0, [pc, #80]	; (31e94 <bt_gatt_init+0xb8>)
   31e42:	f7fb fd5b 	bl	2d8fc <bt_long_wq_schedule>
	k_work_init_delayable(&gatt_sc.work, sc_process);
   31e46:	4914      	ldr	r1, [pc, #80]	; (31e98 <bt_gatt_init+0xbc>)
   31e48:	4814      	ldr	r0, [pc, #80]	; (31e9c <bt_gatt_init+0xc0>)
   31e4a:	f01e f8db 	bl	50004 <k_work_init_delayable>
   31e4e:	2102      	movs	r1, #2
   31e50:	4813      	ldr	r0, [pc, #76]	; (31ea0 <bt_gatt_init+0xc4>)
   31e52:	f01b f8c1 	bl	4cfd8 <atomic_or>
	k_work_init_delayable(&gatt_ccc_store.work, ccc_delayed_store);
   31e56:	4813      	ldr	r0, [pc, #76]	; (31ea4 <bt_gatt_init+0xc8>)
   31e58:	4913      	ldr	r1, [pc, #76]	; (31ea8 <bt_gatt_init+0xcc>)
   31e5a:	f01e f8d3 	bl	50004 <k_work_init_delayable>
}
   31e5e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	bt_conn_cb_register(&gatt_conn_cb);
   31e62:	4812      	ldr	r0, [pc, #72]	; (31eac <bt_gatt_init+0xd0>)
   31e64:	f7fe b95e 	b.w	30124 <bt_conn_cb_register>
		last_static_handle += svc->attr_count;
   31e68:	6850      	ldr	r0, [r2, #4]
   31e6a:	4403      	add	r3, r0
   31e6c:	b29b      	uxth	r3, r3
	STRUCT_SECTION_FOREACH(bt_gatt_service_static, svc) {
   31e6e:	3208      	adds	r2, #8
   31e70:	2001      	movs	r0, #1
   31e72:	e7d6      	b.n	31e22 <bt_gatt_init+0x46>
}
   31e74:	bd10      	pop	{r4, pc}
   31e76:	bf00      	nop
   31e78:	20004108 	.word	0x20004108
   31e7c:	20004104 	.word	0x20004104
   31e80:	20006a2c 	.word	0x20006a2c
   31e84:	00050c78 	.word	0x00050c78
   31e88:	00050ca0 	.word	0x00050ca0
   31e8c:	2000410c 	.word	0x2000410c
   31e90:	000320b5 	.word	0x000320b5
   31e94:	20001d10 	.word	0x20001d10
   31e98:	000323dd 	.word	0x000323dd
   31e9c:	20001d88 	.word	0x20001d88
   31ea0:	20001db8 	.word	0x20001db8
   31ea4:	20001cc0 	.word	0x20001cc0
   31ea8:	0004de13 	.word	0x0004de13
   31eac:	200006cc 	.word	0x200006cc

00031eb0 <bt_gatt_attr_get_handle>:
{
   31eb0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (!attr) {
   31eb4:	4603      	mov	r3, r0
   31eb6:	b148      	cbz	r0, 31ecc <bt_gatt_attr_get_handle+0x1c>
	if (attr->handle) {
   31eb8:	8a00      	ldrh	r0, [r0, #16]
   31eba:	b938      	cbnz	r0, 31ecc <bt_gatt_attr_get_handle+0x1c>
	STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
   31ebc:	4912      	ldr	r1, [pc, #72]	; (31f08 <bt_gatt_attr_get_handle+0x58>)
   31ebe:	f8df e04c 	ldr.w	lr, [pc, #76]	; 31f0c <bt_gatt_attr_get_handle+0x5c>
	uint16_t handle = 1;
   31ec2:	2401      	movs	r4, #1
		    (attr > &static_svc->attrs[static_svc->attr_count - 1])) {
   31ec4:	f04f 0c14 	mov.w	ip, #20
	STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
   31ec8:	4571      	cmp	r1, lr
   31eca:	d301      	bcc.n	31ed0 <bt_gatt_attr_get_handle+0x20>
}
   31ecc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		    (attr > &static_svc->attrs[static_svc->attr_count - 1])) {
   31ed0:	e9d1 7600 	ldrd	r7, r6, [r1]
		if ((attr < &static_svc->attrs[0]) ||
   31ed4:	42bb      	cmp	r3, r7
   31ed6:	d304      	bcc.n	31ee2 <bt_gatt_attr_get_handle+0x32>
		    (attr > &static_svc->attrs[static_svc->attr_count - 1])) {
   31ed8:	fb0c 7206 	mla	r2, ip, r6, r7
   31edc:	3a14      	subs	r2, #20
		if ((attr < &static_svc->attrs[0]) ||
   31ede:	4293      	cmp	r3, r2
   31ee0:	d90e      	bls.n	31f00 <bt_gatt_attr_get_handle+0x50>
			handle += static_svc->attr_count;
   31ee2:	4434      	add	r4, r6
   31ee4:	b2a2      	uxth	r2, r4
	STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
   31ee6:	3108      	adds	r1, #8
   31ee8:	4614      	mov	r4, r2
   31eea:	e7ed      	b.n	31ec8 <bt_gatt_attr_get_handle+0x18>
			if (attr == &static_svc->attrs[i]) {
   31eec:	fb0c 7805 	mla	r8, ip, r5, r7
   31ef0:	4543      	cmp	r3, r8
   31ef2:	d007      	beq.n	31f04 <bt_gatt_attr_get_handle+0x54>
		for (size_t i = 0; i < static_svc->attr_count; i++, handle++) {
   31ef4:	3501      	adds	r5, #1
   31ef6:	1962      	adds	r2, r4, r5
   31ef8:	42b5      	cmp	r5, r6
   31efa:	b292      	uxth	r2, r2
   31efc:	d1f6      	bne.n	31eec <bt_gatt_attr_get_handle+0x3c>
   31efe:	e7f2      	b.n	31ee6 <bt_gatt_attr_get_handle+0x36>
   31f00:	2500      	movs	r5, #0
   31f02:	e7f8      	b.n	31ef6 <bt_gatt_attr_get_handle+0x46>
   31f04:	4610      	mov	r0, r2
   31f06:	e7e1      	b.n	31ecc <bt_gatt_attr_get_handle+0x1c>
   31f08:	00050c78 	.word	0x00050c78
   31f0c:	00050ca0 	.word	0x00050ca0

00031f10 <bt_gatt_foreach_attr_type>:
{
   31f10:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   31f14:	f8bd 5030 	ldrh.w	r5, [sp, #48]	; 0x30
   31f18:	9100      	str	r1, [sp, #0]
   31f1a:	4699      	mov	r9, r3
		num_matches = UINT16_MAX;
   31f1c:	f64f 73ff 	movw	r3, #65535	; 0xffff
   31f20:	2d00      	cmp	r5, #0
   31f22:	bf08      	it	eq
   31f24:	461d      	moveq	r5, r3
	if (start_handle <= last_static_handle) {
   31f26:	4b24      	ldr	r3, [pc, #144]	; (31fb8 <bt_gatt_foreach_attr_type+0xa8>)
   31f28:	881b      	ldrh	r3, [r3, #0]
   31f2a:	4283      	cmp	r3, r0
{
   31f2c:	4607      	mov	r7, r0
   31f2e:	4690      	mov	r8, r2
	if (start_handle <= last_static_handle) {
   31f30:	d23c      	bcs.n	31fac <bt_gatt_foreach_attr_type+0x9c>
}
   31f32:	b003      	add	sp, #12
   31f34:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (handle + static_svc->attr_count < start_handle) {
   31f38:	6873      	ldr	r3, [r6, #4]
   31f3a:	4423      	add	r3, r4
   31f3c:	42bb      	cmp	r3, r7
   31f3e:	d232      	bcs.n	31fa6 <bt_gatt_foreach_attr_type+0x96>
				handle += static_svc->attr_count;
   31f40:	b29c      	uxth	r4, r3
		STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
   31f42:	3608      	adds	r6, #8
   31f44:	4b1d      	ldr	r3, [pc, #116]	; (31fbc <bt_gatt_foreach_attr_type+0xac>)
   31f46:	429e      	cmp	r6, r3
   31f48:	d3f6      	bcc.n	31f38 <bt_gatt_foreach_attr_type+0x28>
   31f4a:	e7f2      	b.n	31f32 <bt_gatt_foreach_attr_type+0x22>
	if (uuid && bt_uuid_cmp(uuid, attr->uuid)) {
   31f4c:	5889      	ldr	r1, [r1, r2]
   31f4e:	9301      	str	r3, [sp, #4]
   31f50:	4640      	mov	r0, r8
   31f52:	f019 f853 	bl	4affc <bt_uuid_cmp>
   31f56:	9b01      	ldr	r3, [sp, #4]
   31f58:	b190      	cbz	r0, 31f80 <bt_gatt_foreach_attr_type+0x70>
			for (i = 0; i < static_svc->attr_count; i++, handle++) {
   31f5a:	3401      	adds	r4, #1
   31f5c:	f10a 0a01 	add.w	sl, sl, #1
   31f60:	b2a4      	uxth	r4, r4
   31f62:	6873      	ldr	r3, [r6, #4]
   31f64:	4553      	cmp	r3, sl
   31f66:	d9ec      	bls.n	31f42 <bt_gatt_foreach_attr_type+0x32>
	if (handle > end_handle) {
   31f68:	9b00      	ldr	r3, [sp, #0]
   31f6a:	429c      	cmp	r4, r3
   31f6c:	d8e1      	bhi.n	31f32 <bt_gatt_foreach_attr_type+0x22>
	if (handle < start_handle) {
   31f6e:	42bc      	cmp	r4, r7
				if (gatt_foreach_iter(&static_svc->attrs[i],
   31f70:	6831      	ldr	r1, [r6, #0]
	if (handle < start_handle) {
   31f72:	d3f2      	bcc.n	31f5a <bt_gatt_foreach_attr_type+0x4a>
				if (gatt_foreach_iter(&static_svc->attrs[i],
   31f74:	fb0b f20a 	mul.w	r2, fp, sl
   31f78:	188b      	adds	r3, r1, r2
	if (uuid && bt_uuid_cmp(uuid, attr->uuid)) {
   31f7a:	f1b8 0f00 	cmp.w	r8, #0
   31f7e:	d1e5      	bne.n	31f4c <bt_gatt_foreach_attr_type+0x3c>
	if (attr_data && attr_data != attr->user_data) {
   31f80:	f1b9 0f00 	cmp.w	r9, #0
   31f84:	d10b      	bne.n	31f9e <bt_gatt_foreach_attr_type+0x8e>
	*num_matches -= 1;
   31f86:	3d01      	subs	r5, #1
   31f88:	b2ad      	uxth	r5, r5
	result = func(attr, handle, user_data);
   31f8a:	4618      	mov	r0, r3
   31f8c:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   31f8e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   31f90:	4621      	mov	r1, r4
   31f92:	4798      	blx	r3
	if (!*num_matches) {
   31f94:	2d00      	cmp	r5, #0
   31f96:	d0cc      	beq.n	31f32 <bt_gatt_foreach_attr_type+0x22>
				if (gatt_foreach_iter(&static_svc->attrs[i],
   31f98:	2800      	cmp	r0, #0
   31f9a:	d1de      	bne.n	31f5a <bt_gatt_foreach_attr_type+0x4a>
   31f9c:	e7c9      	b.n	31f32 <bt_gatt_foreach_attr_type+0x22>
	if (attr_data && attr_data != attr->user_data) {
   31f9e:	68da      	ldr	r2, [r3, #12]
   31fa0:	4591      	cmp	r9, r2
   31fa2:	d1da      	bne.n	31f5a <bt_gatt_foreach_attr_type+0x4a>
   31fa4:	e7ef      	b.n	31f86 <bt_gatt_foreach_attr_type+0x76>
			for (i = 0; i < static_svc->attr_count; i++, handle++) {
   31fa6:	f04f 0a00 	mov.w	sl, #0
   31faa:	e7da      	b.n	31f62 <bt_gatt_foreach_attr_type+0x52>
		STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
   31fac:	4e04      	ldr	r6, [pc, #16]	; (31fc0 <bt_gatt_foreach_attr_type+0xb0>)
		uint16_t handle = 1;
   31fae:	2401      	movs	r4, #1
				if (gatt_foreach_iter(&static_svc->attrs[i],
   31fb0:	f04f 0b14 	mov.w	fp, #20
   31fb4:	e7c6      	b.n	31f44 <bt_gatt_foreach_attr_type+0x34>
   31fb6:	bf00      	nop
   31fb8:	20006a2c 	.word	0x20006a2c
   31fbc:	00050ca0 	.word	0x00050ca0
   31fc0:	00050c78 	.word	0x00050c78

00031fc4 <db_hash_gen>:
{
   31fc4:	b530      	push	{r4, r5, lr}
   31fc6:	b0c9      	sub	sp, #292	; 0x124
	uint8_t key[16] = {};
   31fc8:	2400      	movs	r4, #0
{
   31fca:	4605      	mov	r5, r0
	if (tc_cmac_setup(&state.state, key, &sched) == TC_CRYPTO_FAIL) {
   31fcc:	aa1c      	add	r2, sp, #112	; 0x70
   31fce:	4669      	mov	r1, sp
   31fd0:	a804      	add	r0, sp, #16
	uint8_t key[16] = {};
   31fd2:	e9cd 4400 	strd	r4, r4, [sp]
   31fd6:	e9cd 4402 	strd	r4, r4, [sp, #8]
	if (tc_cmac_setup(&state.state, key, &sched) == TC_CRYPTO_FAIL) {
   31fda:	f018 fd07 	bl	4a9ec <tc_cmac_setup>
   31fde:	b308      	cbz	r0, 32024 <db_hash_gen+0x60>
	bt_gatt_foreach_attr(0x0001, 0xffff, gen_hash_m, &state);
   31fe0:	f64f 71ff 	movw	r1, #65535	; 0xffff
   31fe4:	2001      	movs	r0, #1
   31fe6:	4a10      	ldr	r2, [pc, #64]	; (32028 <db_hash_gen+0x64>)
   31fe8:	ab04      	add	r3, sp, #16
   31fea:	f01b fafc 	bl	4d5e6 <bt_gatt_foreach_attr>
	if (tc_cmac_final(db_hash.hash, &state.state) == TC_CRYPTO_FAIL) {
   31fee:	480f      	ldr	r0, [pc, #60]	; (3202c <db_hash_gen+0x68>)
   31ff0:	a904      	add	r1, sp, #16
   31ff2:	f018 fd90 	bl	4ab16 <tc_cmac_final>
   31ff6:	b1a8      	cbz	r0, 32024 <db_hash_gen+0x60>
   31ff8:	4b0c      	ldr	r3, [pc, #48]	; (3202c <db_hash_gen+0x68>)
   31ffa:	f103 0210 	add.w	r2, r3, #16
 */
static inline void sys_mem_swap(void *buf, size_t length)
{
	size_t i;

	for (i = 0; i < (length/2); i++) {
   31ffe:	3401      	adds	r4, #1
		uint8_t tmp = ((uint8_t *)buf)[i];
   32000:	7819      	ldrb	r1, [r3, #0]

		((uint8_t *)buf)[i] = ((uint8_t *)buf)[length - 1 - i];
   32002:	f812 0d01 	ldrb.w	r0, [r2, #-1]!
   32006:	f803 0b01 	strb.w	r0, [r3], #1
	for (i = 0; i < (length/2); i++) {
   3200a:	2c08      	cmp	r4, #8
		((uint8_t *)buf)[length - 1 - i] = tmp;
   3200c:	7011      	strb	r1, [r2, #0]
	for (i = 0; i < (length/2); i++) {
   3200e:	d1f6      	bne.n	31ffe <db_hash_gen+0x3a>
	if (IS_ENABLED(CONFIG_BT_SETTINGS) && store) {
   32010:	b125      	cbz	r5, 3201c <db_hash_gen+0x58>
	err = settings_save_one("bt/hash", &db_hash.hash, sizeof(db_hash.hash));
   32012:	4906      	ldr	r1, [pc, #24]	; (3202c <db_hash_gen+0x68>)
   32014:	4806      	ldr	r0, [pc, #24]	; (32030 <db_hash_gen+0x6c>)
   32016:	2210      	movs	r2, #16
   32018:	f7fa fa40 	bl	2c49c <settings_save_one>
   3201c:	4805      	ldr	r0, [pc, #20]	; (32034 <db_hash_gen+0x70>)
   3201e:	2104      	movs	r1, #4
   32020:	f01a ffda 	bl	4cfd8 <atomic_or>
}
   32024:	b049      	add	sp, #292	; 0x124
   32026:	bd30      	pop	{r4, r5, pc}
   32028:	0004ceed 	.word	0x0004ceed
   3202c:	20001cf0 	.word	0x20001cf0
   32030:	00053781 	.word	0x00053781
   32034:	20001db8 	.word	0x20001db8

00032038 <db_hash_read>:
{
   32038:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	(void)k_work_cancel_delayable_sync(&db_hash.work, &db_hash.sync);
   3203a:	491b      	ldr	r1, [pc, #108]	; (320a8 <db_hash_read+0x70>)
{
   3203c:	f8bd 6018 	ldrh.w	r6, [sp, #24]
   32040:	4604      	mov	r4, r0
	(void)k_work_cancel_delayable_sync(&db_hash.work, &db_hash.sync);
   32042:	f1a1 0030 	sub.w	r0, r1, #48	; 0x30
{
   32046:	4615      	mov	r5, r2
   32048:	461f      	mov	r7, r3
	(void)k_work_cancel_delayable_sync(&db_hash.work, &db_hash.sync);
   3204a:	f01d fffd 	bl	50048 <k_work_cancel_delayable_sync>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
   3204e:	4817      	ldr	r0, [pc, #92]	; (320ac <db_hash_read+0x74>)
   32050:	f01a ffbc 	bl	4cfcc <atomic_get>
	if (!atomic_test_bit(gatt_sc.flags, DB_HASH_VALID)) {
   32054:	0741      	lsls	r1, r0, #29
   32056:	d402      	bmi.n	3205e <db_hash_read+0x26>
		db_hash_gen(true);
   32058:	2001      	movs	r0, #1
   3205a:	f7ff ffb3 	bl	31fc4 <db_hash_gen>
	cfg = find_cf_cfg(conn);
   3205e:	4620      	mov	r0, r4
   32060:	f7ff fb08 	bl	31674 <find_cf_cfg>
	if (cfg &&
   32064:	b168      	cbz	r0, 32082 <db_hash_read+0x4a>
   32066:	7a03      	ldrb	r3, [r0, #8]
   32068:	07da      	lsls	r2, r3, #31
   3206a:	d50a      	bpl.n	32082 <db_hash_read+0x4a>
	    !atomic_test_bit(cfg->flags, CF_CHANGE_AWARE)) {
   3206c:	f100 040c 	add.w	r4, r0, #12
   32070:	4620      	mov	r0, r4
   32072:	f01a ffab 	bl	4cfcc <atomic_get>
	    CF_ROBUST_CACHING(cfg) &&
   32076:	07c3      	lsls	r3, r0, #31
   32078:	d403      	bmi.n	32082 <db_hash_read+0x4a>
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
   3207a:	2102      	movs	r1, #2
   3207c:	4620      	mov	r0, r4
   3207e:	f01a ffab 	bl	4cfd8 <atomic_or>
	if (offset > value_len) {
   32082:	2e10      	cmp	r6, #16
   32084:	d80c      	bhi.n	320a0 <db_hash_read+0x68>
	len = MIN(buf_len, value_len - offset);
   32086:	f1c6 0410 	rsb	r4, r6, #16
	memcpy(buf, (uint8_t *)value + offset, len);
   3208a:	4909      	ldr	r1, [pc, #36]	; (320b0 <db_hash_read+0x78>)
	len = MIN(buf_len, value_len - offset);
   3208c:	42bc      	cmp	r4, r7
   3208e:	bfa8      	it	ge
   32090:	463c      	movge	r4, r7
	memcpy(buf, (uint8_t *)value + offset, len);
   32092:	4622      	mov	r2, r4
   32094:	4431      	add	r1, r6
   32096:	4628      	mov	r0, r5
   32098:	f018 feef 	bl	4ae7a <memcpy>
}
   3209c:	4620      	mov	r0, r4
   3209e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   320a0:	f06f 0406 	mvn.w	r4, #6
	return bt_gatt_attr_read(conn, attr, buf, len, offset, db_hash.hash,
   320a4:	e7fa      	b.n	3209c <db_hash_read+0x64>
   320a6:	bf00      	nop
   320a8:	20001d40 	.word	0x20001d40
   320ac:	20001db8 	.word	0x20001db8
   320b0:	20001cf0 	.word	0x20001cf0

000320b4 <db_hash_process>:
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   320b4:	f06f 0108 	mvn.w	r1, #8
{
   320b8:	b508      	push	{r3, lr}
   320ba:	4828      	ldr	r0, [pc, #160]	; (3215c <db_hash_process+0xa8>)
   320bc:	f01a ffe2 	bl	4d084 <atomic_and>
	if (atomic_test_and_clear_bit(gatt_sc.flags, DB_HASH_LOAD)) {
   320c0:	0701      	lsls	r1, r0, #28
   320c2:	d545      	bpl.n	32150 <db_hash_process+0x9c>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
   320c4:	4825      	ldr	r0, [pc, #148]	; (3215c <db_hash_process+0xa8>)
   320c6:	f01a ff81 	bl	4cfcc <atomic_get>
   320ca:	4603      	mov	r3, r0
		if (!atomic_test_bit(gatt_sc.flags, DB_HASH_VALID)) {
   320cc:	075a      	lsls	r2, r3, #29
   320ce:	f3c0 0080 	ubfx	r0, r0, #2, #1
   320d2:	d401      	bmi.n	320d8 <db_hash_process+0x24>
			db_hash_gen(false);
   320d4:	f7ff ff76 	bl	31fc4 <db_hash_gen>
		if (!memcmp(db_hash.stored_hash, db_hash.hash,
   320d8:	4921      	ldr	r1, [pc, #132]	; (32160 <db_hash_process+0xac>)
   320da:	2210      	movs	r2, #16
   320dc:	1888      	adds	r0, r1, r2
   320de:	f018 febc 	bl	4ae5a <memcmp>
   320e2:	b948      	cbnz	r0, 320f8 <db_hash_process+0x44>
			k_work_cancel_delayable(&gatt_sc.work);
   320e4:	481f      	ldr	r0, [pc, #124]	; (32164 <db_hash_process+0xb0>)
   320e6:	f01d ff9b 	bl	50020 <k_work_cancel_delayable>
}
   320ea:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   320ee:	481b      	ldr	r0, [pc, #108]	; (3215c <db_hash_process+0xa8>)
   320f0:	f06f 0101 	mvn.w	r1, #1
   320f4:	f01a bfc6 	b.w	4d084 <atomic_and>
	old = atomic_or(ATOMIC_ELEM(target, bit), mask);
   320f8:	4818      	ldr	r0, [pc, #96]	; (3215c <db_hash_process+0xa8>)
   320fa:	2101      	movs	r1, #1
   320fc:	f01a ff6c 	bl	4cfd8 <atomic_or>
	if (!atomic_test_and_set_bit(gatt_sc.flags, SC_RANGE_CHANGED)) {
   32100:	f010 0f01 	tst.w	r0, #1
   32104:	4b18      	ldr	r3, [pc, #96]	; (32168 <db_hash_process+0xb4>)
   32106:	d113      	bne.n	32130 <db_hash_process+0x7c>
		gatt_sc.start = start;
   32108:	4a18      	ldr	r2, [pc, #96]	; (3216c <db_hash_process+0xb8>)
   3210a:	619a      	str	r2, [r3, #24]
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
   3210c:	4813      	ldr	r0, [pc, #76]	; (3215c <db_hash_process+0xa8>)
   3210e:	f01a ff5d 	bl	4cfcc <atomic_get>
	if (atomic_test_bit(gatt_sc.flags, SC_INDICATE_PENDING)) {
   32112:	0783      	lsls	r3, r0, #30
   32114:	d405      	bmi.n	32122 <db_hash_process+0x6e>
	k_work_reschedule(&gatt_sc.work, timeout);
   32116:	4813      	ldr	r0, [pc, #76]	; (32164 <db_hash_process+0xb0>)
   32118:	f44f 72a4 	mov.w	r2, #328	; 0x148
   3211c:	2300      	movs	r3, #0
   3211e:	f015 fa65 	bl	475ec <k_work_reschedule>
}
   32122:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	err = settings_save_one("bt/hash", &db_hash.hash, sizeof(db_hash.hash));
   32126:	490e      	ldr	r1, [pc, #56]	; (32160 <db_hash_process+0xac>)
   32128:	4811      	ldr	r0, [pc, #68]	; (32170 <db_hash_process+0xbc>)
   3212a:	2210      	movs	r2, #16
   3212c:	f7fa b9b6 	b.w	2c49c <settings_save_one>
	if (new_start >= *start && new_end <= *end) {
   32130:	8b1a      	ldrh	r2, [r3, #24]
   32132:	8b58      	ldrh	r0, [r3, #26]
   32134:	2a01      	cmp	r2, #1
   32136:	f64f 72ff 	movw	r2, #65535	; 0xffff
   3213a:	d805      	bhi.n	32148 <db_hash_process+0x94>
   3213c:	4290      	cmp	r0, r2
   3213e:	d0f0      	beq.n	32122 <db_hash_process+0x6e>
		*end = new_end;
   32140:	f64f 72ff 	movw	r2, #65535	; 0xffff
   32144:	835a      	strh	r2, [r3, #26]
   32146:	e7e1      	b.n	3210c <db_hash_process+0x58>
	if (*end < new_end) {
   32148:	4290      	cmp	r0, r2
		*start = new_start;
   3214a:	8319      	strh	r1, [r3, #24]
	if (*end < new_end) {
   3214c:	d0de      	beq.n	3210c <db_hash_process+0x58>
   3214e:	e7f7      	b.n	32140 <db_hash_process+0x8c>
}
   32150:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	db_hash_gen(true);
   32154:	2001      	movs	r0, #1
   32156:	f7ff bf35 	b.w	31fc4 <db_hash_gen>
   3215a:	bf00      	nop
   3215c:	20001db8 	.word	0x20001db8
   32160:	20001cf0 	.word	0x20001cf0
   32164:	20001d88 	.word	0x20001d88
   32168:	20001d68 	.word	0x20001d68
   3216c:	ffff0001 	.word	0xffff0001
   32170:	00053781 	.word	0x00053781

00032174 <ccc_set_direct>:
{
   32174:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   32178:	b0b8      	sub	sp, #224	; 0xe0
   3217a:	460c      	mov	r4, r1
   3217c:	4616      	mov	r6, r2
		if (!settings_name_steq((const char *)param, "bt/ccc", &name)) {
   3217e:	4921      	ldr	r1, [pc, #132]	; (32204 <ccc_set_direct+0x90>)
   32180:	983e      	ldr	r0, [sp, #248]	; 0xf8
   32182:	466a      	mov	r2, sp
{
   32184:	461f      	mov	r7, r3
		if (!settings_name_steq((const char *)param, "bt/ccc", &name)) {
   32186:	f017 fac8 	bl	4971a <settings_name_steq>
   3218a:	2800      	cmp	r0, #0
   3218c:	d037      	beq.n	321fe <ccc_set_direct+0x8a>
		return ccc_set(name, len, read_cb, cb_arg);
   3218e:	9d00      	ldr	r5, [sp, #0]
		settings_name_next(name, &next);
   32190:	a901      	add	r1, sp, #4
   32192:	4628      	mov	r0, r5
   32194:	f017 fae5 	bl	49762 <settings_name_next>
		if (!name) {
   32198:	b165      	cbz	r5, 321b4 <ccc_set_direct+0x40>
		} else if (!next) {
   3219a:	9801      	ldr	r0, [sp, #4]
   3219c:	b970      	cbnz	r0, 321bc <ccc_set_direct+0x48>
		err = bt_settings_decode_key(name, &addr);
   3219e:	f10d 0808 	add.w	r8, sp, #8
			load.addr_with_id.id = BT_ID_DEFAULT;
   321a2:	2300      	movs	r3, #0
		err = bt_settings_decode_key(name, &addr);
   321a4:	4628      	mov	r0, r5
   321a6:	4641      	mov	r1, r8
			load.addr_with_id.id = BT_ID_DEFAULT;
   321a8:	f88d 3014 	strb.w	r3, [sp, #20]
		err = bt_settings_decode_key(name, &addr);
   321ac:	f018 ff00 	bl	4afb0 <bt_settings_decode_key>
		if (err) {
   321b0:	4605      	mov	r5, r0
   321b2:	b150      	cbz	r0, 321ca <ccc_set_direct+0x56>
			return -EINVAL;
   321b4:	f06f 0415 	mvn.w	r4, #21
   321b8:	4625      	mov	r5, r4
   321ba:	e01a      	b.n	321f2 <ccc_set_direct+0x7e>
			unsigned long next_id = strtoul(next, NULL, 10);
   321bc:	220a      	movs	r2, #10
   321be:	2100      	movs	r1, #0
   321c0:	f018 fd12 	bl	4abe8 <strtoul>
			if (next_id >= CONFIG_BT_ID_MAX) {
   321c4:	2800      	cmp	r0, #0
   321c6:	d0ea      	beq.n	3219e <ccc_set_direct+0x2a>
   321c8:	e7f4      	b.n	321b4 <ccc_set_direct+0x40>
		load.addr_with_id.addr = &addr;
   321ca:	f8cd 8010 	str.w	r8, [sp, #16]
		if (len_rd) {
   321ce:	b1a4      	cbz	r4, 321fa <ccc_set_direct+0x86>
			len = read_cb(cb_arg, ccc_store, sizeof(ccc_store));
   321d0:	22c0      	movs	r2, #192	; 0xc0
   321d2:	a908      	add	r1, sp, #32
   321d4:	4638      	mov	r0, r7
   321d6:	47b0      	blx	r6
			if (len < 0) {
   321d8:	1e04      	subs	r4, r0, #0
   321da:	dbed      	blt.n	321b8 <ccc_set_direct+0x44>
			load.count = len / sizeof(*ccc_store);
   321dc:	08a4      	lsrs	r4, r4, #2
			for (size_t i = 0; i < load.count; i++) {
   321de:	ab08      	add	r3, sp, #32
			load.count = len / sizeof(*ccc_store);
   321e0:	e9cd 3406 	strd	r3, r4, [sp, #24]
		bt_gatt_foreach_attr(0x0001, 0xffff, ccc_load, &load);
   321e4:	4a08      	ldr	r2, [pc, #32]	; (32208 <ccc_set_direct+0x94>)
   321e6:	ab04      	add	r3, sp, #16
   321e8:	f64f 71ff 	movw	r1, #65535	; 0xffff
   321ec:	2001      	movs	r0, #1
   321ee:	f01b f9fa 	bl	4d5e6 <bt_gatt_foreach_attr>
}
   321f2:	4628      	mov	r0, r5
   321f4:	b038      	add	sp, #224	; 0xe0
   321f6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   321fa:	4623      	mov	r3, r4
   321fc:	e7f0      	b.n	321e0 <ccc_set_direct+0x6c>
			return -EINVAL;
   321fe:	f06f 0515 	mvn.w	r5, #21
   32202:	e7f6      	b.n	321f2 <ccc_set_direct+0x7e>
   32204:	00053789 	.word	0x00053789
   32208:	000317f9 	.word	0x000317f9

0003220c <bt_gatt_attr_next>:
{
   3220c:	b507      	push	{r0, r1, r2, lr}
	struct bt_gatt_attr *next = NULL;
   3220e:	2300      	movs	r3, #0
   32210:	9301      	str	r3, [sp, #4]
	uint16_t handle = bt_gatt_attr_get_handle(attr);
   32212:	f7ff fe4d 	bl	31eb0 <bt_gatt_attr_get_handle>
	bt_gatt_foreach_attr(handle + 1, handle + 1, find_next, &next);
   32216:	1c41      	adds	r1, r0, #1
   32218:	b289      	uxth	r1, r1
   3221a:	4608      	mov	r0, r1
   3221c:	4a03      	ldr	r2, [pc, #12]	; (3222c <bt_gatt_attr_next+0x20>)
   3221e:	ab01      	add	r3, sp, #4
   32220:	f01b f9e1 	bl	4d5e6 <bt_gatt_foreach_attr>
}
   32224:	9801      	ldr	r0, [sp, #4]
   32226:	b003      	add	sp, #12
   32228:	f85d fb04 	ldr.w	pc, [sp], #4
   3222c:	0004ce87 	.word	0x0004ce87

00032230 <gatt_indicate>:
{
   32230:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   32234:	4615      	mov	r5, r2
   32236:	4689      	mov	r9, r1
	if (bt_gatt_check_perm(conn, params->attr, BT_GATT_PERM_READ_ENCRYPT_MASK)) {
   32238:	2294      	movs	r2, #148	; 0x94
   3223a:	6869      	ldr	r1, [r5, #4]
{
   3223c:	4606      	mov	r6, r0
	if (bt_gatt_check_perm(conn, params->attr, BT_GATT_PERM_READ_ENCRYPT_MASK)) {
   3223e:	f01b f9dd 	bl	4d5fc <bt_gatt_check_perm>
   32242:	4680      	mov	r8, r0
   32244:	2800      	cmp	r0, #0
   32246:	d148      	bne.n	322da <gatt_indicate+0xaa>
		if (!bt_gatt_is_subscribed(conn, params->attr, BT_GATT_CCC_INDICATE)) {
   32248:	6869      	ldr	r1, [r5, #4]
   3224a:	2202      	movs	r2, #2
   3224c:	4630      	mov	r0, r6
   3224e:	f01b fa09 	bl	4d664 <bt_gatt_is_subscribed>
   32252:	2800      	cmp	r0, #0
   32254:	d044      	beq.n	322e0 <gatt_indicate+0xb0>
	req = bt_att_req_alloc(BT_ATT_TIMEOUT);
   32256:	f44f 2070 	mov.w	r0, #983040	; 0xf0000
   3225a:	2100      	movs	r1, #0
	len = sizeof(*ind) + params->len;
   3225c:	8aaf      	ldrh	r7, [r5, #20]
	req = bt_att_req_alloc(BT_ATT_TIMEOUT);
   3225e:	f7ff f8c5 	bl	313ec <bt_att_req_alloc>
	len = sizeof(*ind) + params->len;
   32262:	3702      	adds	r7, #2
	if (!req) {
   32264:	4604      	mov	r4, r0
   32266:	b180      	cbz	r0, 3228a <gatt_indicate+0x5a>
	req->func = func;
   32268:	4b1f      	ldr	r3, [pc, #124]	; (322e8 <gatt_indicate+0xb8>)
	req->len = len;
   3226a:	6147      	str	r7, [r0, #20]
	req->att_op = op;
   3226c:	211d      	movs	r1, #29
   3226e:	7441      	strb	r1, [r0, #17]
	req->encode = encode;
   32270:	f8c0 800c 	str.w	r8, [r0, #12]
	req->func = func;
   32274:	6043      	str	r3, [r0, #4]
	req->user_data = params;
   32276:	6185      	str	r5, [r0, #24]
	buf = bt_att_create_pdu(conn, BT_ATT_OP_INDICATE, len);
   32278:	463a      	mov	r2, r7
   3227a:	4630      	mov	r0, r6
   3227c:	f01a fc72 	bl	4cb64 <bt_att_create_pdu>
	if (!buf) {
   32280:	4607      	mov	r7, r0
   32282:	b938      	cbnz	r0, 32294 <gatt_indicate+0x64>
		bt_att_req_free(req);
   32284:	4620      	mov	r0, r4
   32286:	f7ff f8d3 	bl	31430 <bt_att_req_free>
		return -ENOMEM;
   3228a:	f06f 050b 	mvn.w	r5, #11
}
   3228e:	4628      	mov	r0, r5
   32290:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	bt_att_set_tx_meta_data(buf, NULL, NULL, BT_ATT_CHAN_OPT(params));
   32294:	2301      	movs	r3, #1
   32296:	4642      	mov	r2, r8
   32298:	4641      	mov	r1, r8
	return net_buf_simple_add(&buf->b, len);
   3229a:	f107 0a08 	add.w	sl, r7, #8
   3229e:	f01a fdeb 	bl	4ce78 <bt_att_set_tx_meta_data>
   322a2:	2102      	movs	r1, #2
   322a4:	4650      	mov	r0, sl
   322a6:	f01c fd85 	bl	4edb4 <net_buf_simple_add>
	ind->handle = sys_cpu_to_le16(handle);
   322aa:	4680      	mov	r8, r0
   322ac:	4650      	mov	r0, sl
   322ae:	f828 9b02 	strh.w	r9, [r8], #2
   322b2:	8aa9      	ldrh	r1, [r5, #20]
   322b4:	f01c fd7e 	bl	4edb4 <net_buf_simple_add>
	memcpy(ind->value, params->data, params->len);
   322b8:	8aaa      	ldrh	r2, [r5, #20]
   322ba:	6929      	ldr	r1, [r5, #16]
   322bc:	4640      	mov	r0, r8
   322be:	f018 fddc 	bl	4ae7a <memcpy>
	req->buf = buf;
   322c2:	60a7      	str	r7, [r4, #8]
	err = bt_att_req_send(conn, req);
   322c4:	4621      	mov	r1, r4
   322c6:	4630      	mov	r0, r6
   322c8:	f01a fd80 	bl	4cdcc <bt_att_req_send>
	if (err) {
   322cc:	4605      	mov	r5, r0
   322ce:	2800      	cmp	r0, #0
   322d0:	d0dd      	beq.n	3228e <gatt_indicate+0x5e>
		bt_att_req_free(req);
   322d2:	4620      	mov	r0, r4
   322d4:	f7ff f8ac 	bl	31430 <bt_att_req_free>
   322d8:	e7d9      	b.n	3228e <gatt_indicate+0x5e>
		return -EPERM;
   322da:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   322de:	e7d6      	b.n	3228e <gatt_indicate+0x5e>
			return -EINVAL;
   322e0:	f06f 0515 	mvn.w	r5, #21
   322e4:	e7d3      	b.n	3228e <gatt_indicate+0x5e>
   322e6:	bf00      	nop
   322e8:	0004cebb 	.word	0x0004cebb

000322ec <bt_gatt_indicate>:
{
   322ec:	b530      	push	{r4, r5, lr}
   322ee:	4604      	mov	r4, r0
   322f0:	b08b      	sub	sp, #44	; 0x2c
   322f2:	4837      	ldr	r0, [pc, #220]	; (323d0 <bt_gatt_indicate+0xe4>)
   322f4:	f01a fe6a 	bl	4cfcc <atomic_get>
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
   322f8:	0742      	lsls	r2, r0, #29
{
   322fa:	460d      	mov	r5, r1
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
   322fc:	d561      	bpl.n	323c2 <bt_gatt_indicate+0xd6>
	if (conn && conn->state != BT_CONN_CONNECTED) {
   322fe:	b114      	cbz	r4, 32306 <bt_gatt_indicate+0x1a>
   32300:	7b63      	ldrb	r3, [r4, #13]
   32302:	2b07      	cmp	r3, #7
   32304:	d160      	bne.n	323c8 <bt_gatt_indicate+0xdc>
	data.attr = params->attr;
   32306:	6868      	ldr	r0, [r5, #4]
   32308:	9005      	str	r0, [sp, #20]
	data.handle = bt_gatt_attr_get_handle(data.attr);
   3230a:	f7ff fdd1 	bl	31eb0 <bt_gatt_attr_get_handle>
	if (params->uuid) {
   3230e:	682a      	ldr	r2, [r5, #0]
	data.handle = bt_gatt_attr_get_handle(data.attr);
   32310:	f8ad 0018 	strh.w	r0, [sp, #24]
	if (params->uuid) {
   32314:	b33a      	cbz	r2, 32366 <bt_gatt_indicate+0x7a>
	bt_gatt_foreach_attr_type(found->handle, 0xffff, uuid, NULL, 1,
   32316:	a905      	add	r1, sp, #20
   32318:	9102      	str	r1, [sp, #8]
   3231a:	492e      	ldr	r1, [pc, #184]	; (323d4 <bt_gatt_indicate+0xe8>)
   3231c:	9101      	str	r1, [sp, #4]
   3231e:	2101      	movs	r1, #1
	found->attr = NULL;
   32320:	2300      	movs	r3, #0
	bt_gatt_foreach_attr_type(found->handle, 0xffff, uuid, NULL, 1,
   32322:	9100      	str	r1, [sp, #0]
   32324:	f64f 71ff 	movw	r1, #65535	; 0xffff
	found->attr = NULL;
   32328:	9305      	str	r3, [sp, #20]
	bt_gatt_foreach_attr_type(found->handle, 0xffff, uuid, NULL, 1,
   3232a:	f7ff fdf1 	bl	31f10 <bt_gatt_foreach_attr_type>
	return found->attr ? true : false;
   3232e:	9b05      	ldr	r3, [sp, #20]
		if (!gatt_find_by_uuid(&data, params->uuid)) {
   32330:	b91b      	cbnz	r3, 3233a <bt_gatt_indicate+0x4e>
			return -ENOENT;
   32332:	f06f 0001 	mvn.w	r0, #1
}
   32336:	b00b      	add	sp, #44	; 0x2c
   32338:	bd30      	pop	{r4, r5, pc}
		params->attr = data.attr;
   3233a:	606b      	str	r3, [r5, #4]
	if (!bt_uuid_cmp(data.attr->uuid, BT_UUID_GATT_CHRC)) {
   3233c:	9b05      	ldr	r3, [sp, #20]
   3233e:	6818      	ldr	r0, [r3, #0]
   32340:	2300      	movs	r3, #0
   32342:	f88d 3010 	strb.w	r3, [sp, #16]
   32346:	a904      	add	r1, sp, #16
   32348:	f642 0303 	movw	r3, #10243	; 0x2803
   3234c:	f8ad 3012 	strh.w	r3, [sp, #18]
   32350:	f018 fe54 	bl	4affc <bt_uuid_cmp>
   32354:	b970      	cbnz	r0, 32374 <bt_gatt_indicate+0x88>
		struct bt_gatt_chrc *chrc = data.attr->user_data;
   32356:	9805      	ldr	r0, [sp, #20]
		if (!(chrc->properties & BT_GATT_CHRC_INDICATE)) {
   32358:	68c3      	ldr	r3, [r0, #12]
   3235a:	799b      	ldrb	r3, [r3, #6]
   3235c:	069b      	lsls	r3, r3, #26
   3235e:	d405      	bmi.n	3236c <bt_gatt_indicate+0x80>
			return -EINVAL;
   32360:	f06f 0015 	mvn.w	r0, #21
   32364:	e7e7      	b.n	32336 <bt_gatt_indicate+0x4a>
		if (!data.handle) {
   32366:	2800      	cmp	r0, #0
   32368:	d1e8      	bne.n	3233c <bt_gatt_indicate+0x50>
   3236a:	e7e2      	b.n	32332 <bt_gatt_indicate+0x46>
		data.handle = bt_gatt_attr_value_handle(data.attr);
   3236c:	f01b f8ed 	bl	4d54a <bt_gatt_attr_value_handle>
   32370:	f8ad 0018 	strh.w	r0, [sp, #24]
		return gatt_indicate(conn, data.handle, params);
   32374:	f8bd 0018 	ldrh.w	r0, [sp, #24]
	if (conn) {
   32378:	b13c      	cbz	r4, 3238a <bt_gatt_indicate+0x9e>
		params->_ref = 1;
   3237a:	2301      	movs	r3, #1
		return gatt_indicate(conn, data.handle, params);
   3237c:	4601      	mov	r1, r0
		params->_ref = 1;
   3237e:	75ab      	strb	r3, [r5, #22]
		return gatt_indicate(conn, data.handle, params);
   32380:	462a      	mov	r2, r5
   32382:	4620      	mov	r0, r4
   32384:	f7ff ff54 	bl	32230 <gatt_indicate>
   32388:	e7d5      	b.n	32336 <bt_gatt_indicate+0x4a>
	data.err = -ENOTCONN;
   3238a:	f06f 037f 	mvn.w	r3, #127	; 0x7f
   3238e:	9307      	str	r3, [sp, #28]
	data.type = BT_GATT_CCC_INDICATE;
   32390:	2302      	movs	r3, #2
   32392:	f8ad 3020 	strh.w	r3, [sp, #32]
	bt_gatt_foreach_attr_type(data.handle, 0xffff, BT_UUID_GATT_CCC, NULL,
   32396:	f642 1302 	movw	r3, #10498	; 0x2902
   3239a:	f8ad 3012 	strh.w	r3, [sp, #18]
   3239e:	ab05      	add	r3, sp, #20
	params->_ref = 0;
   323a0:	75ac      	strb	r4, [r5, #22]
	bt_gatt_foreach_attr_type(data.handle, 0xffff, BT_UUID_GATT_CCC, NULL,
   323a2:	9302      	str	r3, [sp, #8]
   323a4:	4b0c      	ldr	r3, [pc, #48]	; (323d8 <bt_gatt_indicate+0xec>)
   323a6:	9301      	str	r3, [sp, #4]
   323a8:	2301      	movs	r3, #1
   323aa:	9300      	str	r3, [sp, #0]
   323ac:	aa04      	add	r2, sp, #16
   323ae:	4623      	mov	r3, r4
   323b0:	f64f 71ff 	movw	r1, #65535	; 0xffff
	data.ind_params = params;
   323b4:	9509      	str	r5, [sp, #36]	; 0x24
	bt_gatt_foreach_attr_type(data.handle, 0xffff, BT_UUID_GATT_CCC, NULL,
   323b6:	f88d 4010 	strb.w	r4, [sp, #16]
   323ba:	f7ff fda9 	bl	31f10 <bt_gatt_foreach_attr_type>
	return data.err;
   323be:	9807      	ldr	r0, [sp, #28]
   323c0:	e7b9      	b.n	32336 <bt_gatt_indicate+0x4a>
		return -EAGAIN;
   323c2:	f06f 000a 	mvn.w	r0, #10
   323c6:	e7b6      	b.n	32336 <bt_gatt_indicate+0x4a>
		return -ENOTCONN;
   323c8:	f06f 007f 	mvn.w	r0, #127	; 0x7f
   323cc:	e7b3      	b.n	32336 <bt_gatt_indicate+0x4a>
   323ce:	bf00      	nop
   323d0:	200000fc 	.word	0x200000fc
   323d4:	0004cee1 	.word	0x0004cee1
   323d8:	00032605 	.word	0x00032605

000323dc <sc_process>:
{
   323dc:	b573      	push	{r0, r1, r4, r5, r6, lr}
	atomic_clear_bit(sc->flags, SC_RANGE_CHANGED);
   323de:	f100 0530 	add.w	r5, r0, #48	; 0x30
{
   323e2:	4604      	mov	r4, r0
	sc_range[0] = sys_cpu_to_le16(sc->start);
   323e4:	f850 3c08 	ldr.w	r3, [r0, #-8]
   323e8:	9301      	str	r3, [sp, #4]
	atomic_clear_bit(sc->flags, SC_RANGE_CHANGED);
   323ea:	f1a0 0620 	sub.w	r6, r0, #32
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   323ee:	f06f 0101 	mvn.w	r1, #1
   323f2:	4628      	mov	r0, r5
   323f4:	f01a fe46 	bl	4d084 <atomic_and>
	sc->params.attr = &_1_gatt_svc.attrs[2];
   323f8:	4b0d      	ldr	r3, [pc, #52]	; (32430 <sc_process+0x54>)
   323fa:	f844 3c1c 	str.w	r3, [r4, #-28]
	sc->params.func = sc_indicate_rsp;
   323fe:	4b0d      	ldr	r3, [pc, #52]	; (32434 <sc_process+0x58>)
   32400:	f844 3c18 	str.w	r3, [r4, #-24]
	sc->params.data = &sc_range[0];
   32404:	ab01      	add	r3, sp, #4
	sc->start = 0U;
   32406:	2000      	movs	r0, #0
	sc->params.data = &sc_range[0];
   32408:	f844 3c10 	str.w	r3, [r4, #-16]
	sc->params.len = sizeof(sc_range);
   3240c:	2304      	movs	r3, #4
	sc->start = 0U;
   3240e:	f824 0c08 	strh.w	r0, [r4, #-8]
	sc->end = 0U;
   32412:	f824 0c06 	strh.w	r0, [r4, #-6]
	sc->params.len = sizeof(sc_range);
   32416:	f824 3c0c 	strh.w	r3, [r4, #-12]
	if (bt_gatt_indicate(NULL, &sc->params)) {
   3241a:	4631      	mov	r1, r6
   3241c:	f7ff ff66 	bl	322ec <bt_gatt_indicate>
   32420:	b918      	cbnz	r0, 3242a <sc_process+0x4e>
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
   32422:	2102      	movs	r1, #2
   32424:	4628      	mov	r0, r5
   32426:	f01a fdd7 	bl	4cfd8 <atomic_or>
}
   3242a:	b002      	add	sp, #8
   3242c:	bd70      	pop	{r4, r5, r6, pc}
   3242e:	bf00      	nop
   32430:	00051f68 	.word	0x00051f68
   32434:	00031d8d 	.word	0x00031d8d

00032438 <update_ccc>:
{
   32438:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	if (attr->write != bt_gatt_attr_write_ccc) {
   3243c:	4b32      	ldr	r3, [pc, #200]	; (32508 <update_ccc+0xd0>)
	struct bt_conn *conn = data->conn;
   3243e:	6814      	ldr	r4, [r2, #0]
{
   32440:	4617      	mov	r7, r2
	if (attr->write != bt_gatt_attr_write_ccc) {
   32442:	6882      	ldr	r2, [r0, #8]
   32444:	429a      	cmp	r2, r3
{
   32446:	4606      	mov	r6, r0
	if (attr->write != bt_gatt_attr_write_ccc) {
   32448:	d159      	bne.n	324fe <update_ccc+0xc6>
	ccc = attr->user_data;
   3244a:	f8d0 800c 	ldr.w	r8, [r0, #12]
	for (i = 0; i < ARRAY_SIZE(ccc->cfg); i++) {
   3244e:	f108 0501 	add.w	r5, r8, #1
   32452:	f108 093d 	add.w	r9, r8, #61	; 0x3d
		if (!cfg->value ||
   32456:	f8b5 3007 	ldrh.w	r3, [r5, #7]
   3245a:	b1fb      	cbz	r3, 3249c <update_ccc+0x64>
		    !bt_conn_is_peer_addr_le(conn, cfg->id, &cfg->peer)) {
   3245c:	f815 1c01 	ldrb.w	r1, [r5, #-1]
   32460:	462a      	mov	r2, r5
   32462:	4620      	mov	r0, r4
   32464:	f019 fd60 	bl	4bf28 <bt_conn_is_peer_addr_le>
		if (!cfg->value ||
   32468:	b1c0      	cbz	r0, 3249c <update_ccc+0x64>
		err = bt_gatt_check_perm(conn, attr, BT_GATT_PERM_WRITE_MASK);
   3246a:	f44f 7295 	mov.w	r2, #298	; 0x12a
   3246e:	4631      	mov	r1, r6
   32470:	4620      	mov	r0, r4
   32472:	f01b f8c3 	bl	4d5fc <bt_gatt_check_perm>
		if (err) {
   32476:	b1a8      	cbz	r0, 324a4 <update_ccc+0x6c>
			if (err == BT_ATT_ERR_WRITE_NOT_PERMITTED) {
   32478:	2803      	cmp	r0, #3
   3247a:	d00f      	beq.n	3249c <update_ccc+0x64>
			sec = BT_SECURITY_L2;
   3247c:	2805      	cmp	r0, #5
			    bt_conn_get_security(conn) < sec) {
   3247e:	4620      	mov	r0, r4
			sec = BT_SECURITY_L2;
   32480:	bf0c      	ite	eq
   32482:	f04f 0a03 	moveq.w	sl, #3
   32486:	f04f 0a02 	movne.w	sl, #2
			    bt_conn_get_security(conn) < sec) {
   3248a:	f019 fd4b 	bl	4bf24 <bt_conn_get_security>
			if (IS_ENABLED(CONFIG_BT_SMP) &&
   3248e:	4582      	cmp	sl, r0
   32490:	d908      	bls.n	324a4 <update_ccc+0x6c>
				if (data->sec < sec) {
   32492:	793b      	ldrb	r3, [r7, #4]
   32494:	4553      	cmp	r3, sl
   32496:	d201      	bcs.n	3249c <update_ccc+0x64>
					data->sec = sec;
   32498:	f887 a004 	strb.w	sl, [r7, #4]
	for (i = 0; i < ARRAY_SIZE(ccc->cfg); i++) {
   3249c:	350a      	adds	r5, #10
   3249e:	454d      	cmp	r5, r9
   324a0:	d1d9      	bne.n	32456 <update_ccc+0x1e>
   324a2:	e02c      	b.n	324fe <update_ccc+0xc6>
		gatt_ccc_changed(attr, ccc);
   324a4:	4641      	mov	r1, r8
   324a6:	4630      	mov	r0, r6
   324a8:	f01a fcf0 	bl	4ce8c <gatt_ccc_changed>
		if (IS_ENABLED(CONFIG_BT_GATT_SERVICE_CHANGED) &&
   324ac:	4b17      	ldr	r3, [pc, #92]	; (3250c <update_ccc+0xd4>)
   324ae:	4598      	cmp	r8, r3
   324b0:	d125      	bne.n	324fe <update_ccc+0xc6>
	cfg = find_sc_cfg(conn->id, &conn->le.dst);
   324b2:	7a20      	ldrb	r0, [r4, #8]
   324b4:	f104 0188 	add.w	r1, r4, #136	; 0x88
   324b8:	f7ff f900 	bl	316bc <find_sc_cfg>
	if (!cfg) {
   324bc:	b1f8      	cbz	r0, 324fe <update_ccc+0xc6>
	if (!(cfg->data.start || cfg->data.end)) {
   324be:	8902      	ldrh	r2, [r0, #8]
   324c0:	8943      	ldrh	r3, [r0, #10]
   324c2:	ea53 0102 	orrs.w	r1, r3, r2
   324c6:	d01a      	beq.n	324fe <update_ccc+0xc6>
	index = bt_conn_index(conn);
   324c8:	4620      	mov	r0, r4
	sc_range[0] = sys_cpu_to_le16(cfg->data.start);
   324ca:	f8ad 2004 	strh.w	r2, [sp, #4]
	sc_range[1] = sys_cpu_to_le16(cfg->data.end);
   324ce:	f8ad 3006 	strh.w	r3, [sp, #6]
	index = bt_conn_index(conn);
   324d2:	f7fd fd17 	bl	2ff04 <bt_conn_index>
	sc_restore_params[index].attr = &_1_gatt_svc.attrs[2];
   324d6:	490e      	ldr	r1, [pc, #56]	; (32510 <update_ccc+0xd8>)
   324d8:	4a0e      	ldr	r2, [pc, #56]	; (32514 <update_ccc+0xdc>)
   324da:	2318      	movs	r3, #24
   324dc:	fb03 1300 	mla	r3, r3, r0, r1
	if (bt_gatt_indicate(conn, &sc_restore_params[index])) {
   324e0:	b200      	sxth	r0, r0
	sc_restore_params[index].attr = &_1_gatt_svc.attrs[2];
   324e2:	605a      	str	r2, [r3, #4]
	sc_restore_params[index].func = sc_restore_rsp;
   324e4:	4a0c      	ldr	r2, [pc, #48]	; (32518 <update_ccc+0xe0>)
   324e6:	609a      	str	r2, [r3, #8]
	sc_restore_params[index].data = &sc_range[0];
   324e8:	aa01      	add	r2, sp, #4
	if (bt_gatt_indicate(conn, &sc_restore_params[index])) {
   324ea:	eb00 0040 	add.w	r0, r0, r0, lsl #1
	sc_restore_params[index].data = &sc_range[0];
   324ee:	611a      	str	r2, [r3, #16]
	sc_restore_params[index].len = sizeof(sc_range);
   324f0:	2204      	movs	r2, #4
	if (bt_gatt_indicate(conn, &sc_restore_params[index])) {
   324f2:	eb01 01c0 	add.w	r1, r1, r0, lsl #3
	sc_restore_params[index].len = sizeof(sc_range);
   324f6:	829a      	strh	r2, [r3, #20]
	if (bt_gatt_indicate(conn, &sc_restore_params[index])) {
   324f8:	4620      	mov	r0, r4
   324fa:	f7ff fef7 	bl	322ec <bt_gatt_indicate>
}
   324fe:	2001      	movs	r0, #1
   32500:	b002      	add	sp, #8
   32502:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   32506:	bf00      	nop
   32508:	00031c69 	.word	0x00031c69
   3250c:	20000704 	.word	0x20000704
   32510:	20003fb4 	.word	0x20003fb4
   32514:	00051f68 	.word	0x00051f68
   32518:	0004d4d5 	.word	0x0004d4d5

0003251c <bt_gatt_notify_cb>:
{
   3251c:	b530      	push	{r4, r5, lr}
   3251e:	4604      	mov	r4, r0
   32520:	b08b      	sub	sp, #44	; 0x2c
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
   32522:	4835      	ldr	r0, [pc, #212]	; (325f8 <bt_gatt_notify_cb+0xdc>)
   32524:	f01a fd52 	bl	4cfcc <atomic_get>
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
   32528:	0742      	lsls	r2, r0, #29
{
   3252a:	460d      	mov	r5, r1
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
   3252c:	d55d      	bpl.n	325ea <bt_gatt_notify_cb+0xce>
	if (conn && conn->state != BT_CONN_CONNECTED) {
   3252e:	b114      	cbz	r4, 32536 <bt_gatt_notify_cb+0x1a>
   32530:	7b63      	ldrb	r3, [r4, #13]
   32532:	2b07      	cmp	r3, #7
   32534:	d15c      	bne.n	325f0 <bt_gatt_notify_cb+0xd4>
	data.attr = params->attr;
   32536:	6868      	ldr	r0, [r5, #4]
   32538:	9005      	str	r0, [sp, #20]
	data.handle = bt_gatt_attr_get_handle(data.attr);
   3253a:	f7ff fcb9 	bl	31eb0 <bt_gatt_attr_get_handle>
	if (params->uuid) {
   3253e:	682a      	ldr	r2, [r5, #0]
	data.handle = bt_gatt_attr_get_handle(data.attr);
   32540:	f8ad 0018 	strh.w	r0, [sp, #24]
	if (params->uuid) {
   32544:	b33a      	cbz	r2, 32596 <bt_gatt_notify_cb+0x7a>
	bt_gatt_foreach_attr_type(found->handle, 0xffff, uuid, NULL, 1,
   32546:	a905      	add	r1, sp, #20
   32548:	9102      	str	r1, [sp, #8]
   3254a:	492c      	ldr	r1, [pc, #176]	; (325fc <bt_gatt_notify_cb+0xe0>)
   3254c:	9101      	str	r1, [sp, #4]
   3254e:	2101      	movs	r1, #1
	found->attr = NULL;
   32550:	2300      	movs	r3, #0
	bt_gatt_foreach_attr_type(found->handle, 0xffff, uuid, NULL, 1,
   32552:	9100      	str	r1, [sp, #0]
   32554:	f64f 71ff 	movw	r1, #65535	; 0xffff
	found->attr = NULL;
   32558:	9305      	str	r3, [sp, #20]
	bt_gatt_foreach_attr_type(found->handle, 0xffff, uuid, NULL, 1,
   3255a:	f7ff fcd9 	bl	31f10 <bt_gatt_foreach_attr_type>
	return found->attr ? true : false;
   3255e:	9b05      	ldr	r3, [sp, #20]
		if (!gatt_find_by_uuid(&data, params->uuid)) {
   32560:	b91b      	cbnz	r3, 3256a <bt_gatt_notify_cb+0x4e>
			return -ENOENT;
   32562:	f06f 0001 	mvn.w	r0, #1
}
   32566:	b00b      	add	sp, #44	; 0x2c
   32568:	bd30      	pop	{r4, r5, pc}
		params->attr = data.attr;
   3256a:	606b      	str	r3, [r5, #4]
	if (!bt_uuid_cmp(data.attr->uuid, BT_UUID_GATT_CHRC)) {
   3256c:	9b05      	ldr	r3, [sp, #20]
   3256e:	6818      	ldr	r0, [r3, #0]
   32570:	2300      	movs	r3, #0
   32572:	f88d 3010 	strb.w	r3, [sp, #16]
   32576:	a904      	add	r1, sp, #16
   32578:	f642 0303 	movw	r3, #10243	; 0x2803
   3257c:	f8ad 3012 	strh.w	r3, [sp, #18]
   32580:	f018 fd3c 	bl	4affc <bt_uuid_cmp>
   32584:	b970      	cbnz	r0, 325a4 <bt_gatt_notify_cb+0x88>
		struct bt_gatt_chrc *chrc = data.attr->user_data;
   32586:	9805      	ldr	r0, [sp, #20]
		if (!(chrc->properties & BT_GATT_CHRC_NOTIFY)) {
   32588:	68c3      	ldr	r3, [r0, #12]
   3258a:	799b      	ldrb	r3, [r3, #6]
   3258c:	06db      	lsls	r3, r3, #27
   3258e:	d405      	bmi.n	3259c <bt_gatt_notify_cb+0x80>
			return -EINVAL;
   32590:	f06f 0015 	mvn.w	r0, #21
   32594:	e7e7      	b.n	32566 <bt_gatt_notify_cb+0x4a>
		if (!data.handle) {
   32596:	2800      	cmp	r0, #0
   32598:	d1e8      	bne.n	3256c <bt_gatt_notify_cb+0x50>
   3259a:	e7e2      	b.n	32562 <bt_gatt_notify_cb+0x46>
		data.handle = bt_gatt_attr_value_handle(data.attr);
   3259c:	f01a ffd5 	bl	4d54a <bt_gatt_attr_value_handle>
   325a0:	f8ad 0018 	strh.w	r0, [sp, #24]
		return gatt_notify(conn, data.handle, params);
   325a4:	f8bd 0018 	ldrh.w	r0, [sp, #24]
	if (conn) {
   325a8:	b12c      	cbz	r4, 325b6 <bt_gatt_notify_cb+0x9a>
		return gatt_notify(conn, data.handle, params);
   325aa:	4601      	mov	r1, r0
   325ac:	462a      	mov	r2, r5
   325ae:	4620      	mov	r0, r4
   325b0:	f01b f8df 	bl	4d772 <gatt_notify>
   325b4:	e7d7      	b.n	32566 <bt_gatt_notify_cb+0x4a>
	bt_gatt_foreach_attr_type(data.handle, 0xffff, BT_UUID_GATT_CCC, NULL,
   325b6:	f642 1202 	movw	r2, #10498	; 0x2902
   325ba:	f8ad 2012 	strh.w	r2, [sp, #18]
   325be:	aa05      	add	r2, sp, #20
	data.err = -ENOTCONN;
   325c0:	f06f 037f 	mvn.w	r3, #127	; 0x7f
	bt_gatt_foreach_attr_type(data.handle, 0xffff, BT_UUID_GATT_CCC, NULL,
   325c4:	9202      	str	r2, [sp, #8]
   325c6:	4a0e      	ldr	r2, [pc, #56]	; (32600 <bt_gatt_notify_cb+0xe4>)
	data.err = -ENOTCONN;
   325c8:	9307      	str	r3, [sp, #28]
	data.type = BT_GATT_CCC_NOTIFY;
   325ca:	2301      	movs	r3, #1
	bt_gatt_foreach_attr_type(data.handle, 0xffff, BT_UUID_GATT_CCC, NULL,
   325cc:	e9cd 3200 	strd	r3, r2, [sp]
	data.type = BT_GATT_CCC_NOTIFY;
   325d0:	f8ad 3020 	strh.w	r3, [sp, #32]
	bt_gatt_foreach_attr_type(data.handle, 0xffff, BT_UUID_GATT_CCC, NULL,
   325d4:	aa04      	add	r2, sp, #16
   325d6:	4623      	mov	r3, r4
   325d8:	f64f 71ff 	movw	r1, #65535	; 0xffff
	data.nfy_params = params;
   325dc:	9509      	str	r5, [sp, #36]	; 0x24
	bt_gatt_foreach_attr_type(data.handle, 0xffff, BT_UUID_GATT_CCC, NULL,
   325de:	f88d 4010 	strb.w	r4, [sp, #16]
   325e2:	f7ff fc95 	bl	31f10 <bt_gatt_foreach_attr_type>
	return data.err;
   325e6:	9807      	ldr	r0, [sp, #28]
   325e8:	e7bd      	b.n	32566 <bt_gatt_notify_cb+0x4a>
		return -EAGAIN;
   325ea:	f06f 000a 	mvn.w	r0, #10
   325ee:	e7ba      	b.n	32566 <bt_gatt_notify_cb+0x4a>
		return -ENOTCONN;
   325f0:	f06f 007f 	mvn.w	r0, #127	; 0x7f
   325f4:	e7b7      	b.n	32566 <bt_gatt_notify_cb+0x4a>
   325f6:	bf00      	nop
   325f8:	200000fc 	.word	0x200000fc
   325fc:	0004cee1 	.word	0x0004cee1
   32600:	00032605 	.word	0x00032605

00032604 <notify_cb>:
{
   32604:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (attr->write != bt_gatt_attr_write_ccc) {
   32608:	4b41      	ldr	r3, [pc, #260]	; (32710 <notify_cb+0x10c>)
{
   3260a:	4615      	mov	r5, r2
	if (attr->write != bt_gatt_attr_write_ccc) {
   3260c:	6882      	ldr	r2, [r0, #8]
   3260e:	429a      	cmp	r2, r3
{
   32610:	4680      	mov	r8, r0
	if (attr->write != bt_gatt_attr_write_ccc) {
   32612:	d139      	bne.n	32688 <notify_cb+0x84>
	ccc = attr->user_data;
   32614:	f8d0 a00c 	ldr.w	sl, [r0, #12]
	if (IS_ENABLED(CONFIG_BT_GATT_SERVICE_CHANGED) && ccc == &sc_ccc) {
   32618:	4b3e      	ldr	r3, [pc, #248]	; (32714 <notify_cb+0x110>)
   3261a:	459a      	cmp	sl, r3
   3261c:	d11c      	bne.n	32658 <notify_cb+0x54>
   3261e:	4c3e      	ldr	r4, [pc, #248]	; (32718 <notify_cb+0x114>)
			if (!bt_addr_le_cmp(&cfg->peer, BT_ADDR_LE_ANY)) {
   32620:	4f3e      	ldr	r7, [pc, #248]	; (3271c <notify_cb+0x118>)
		for (i = 0; i < ARRAY_SIZE(sc_cfg); i++) {
   32622:	2600      	movs	r6, #0
			if (!bt_addr_le_cmp(&cfg->peer, BT_ADDR_LE_ANY)) {
   32624:	4639      	mov	r1, r7
   32626:	4620      	mov	r0, r4
   32628:	f01a fcb3 	bl	4cf92 <bt_addr_le_cmp>
   3262c:	b178      	cbz	r0, 3264e <notify_cb+0x4a>
			conn = bt_conn_lookup_state_le(cfg->id, &cfg->peer,
   3262e:	f814 0c01 	ldrb.w	r0, [r4, #-1]
   32632:	2207      	movs	r2, #7
   32634:	4621      	mov	r1, r4
   32636:	f7fd fdbd 	bl	301b4 <bt_conn_lookup_state_le>
			if (!conn) {
   3263a:	bb40      	cbnz	r0, 3268e <notify_cb+0x8a>
				sc = (struct sc_data *)data->ind_params->data;
   3263c:	692b      	ldr	r3, [r5, #16]
				sc_save(cfg->id, &cfg->peer,
   3263e:	f814 0c01 	ldrb.w	r0, [r4, #-1]
				sc = (struct sc_data *)data->ind_params->data;
   32642:	691a      	ldr	r2, [r3, #16]
				sc_save(cfg->id, &cfg->peer,
   32644:	4621      	mov	r1, r4
   32646:	8853      	ldrh	r3, [r2, #2]
   32648:	8812      	ldrh	r2, [r2, #0]
   3264a:	f7ff f93b 	bl	318c4 <sc_save>
		for (i = 0; i < ARRAY_SIZE(sc_cfg); i++) {
   3264e:	3601      	adds	r6, #1
   32650:	2e0c      	cmp	r6, #12
   32652:	f104 040c 	add.w	r4, r4, #12
   32656:	d1e5      	bne.n	32624 <notify_cb+0x20>
	for (i = 0; i < ARRAY_SIZE(ccc->cfg); i++) {
   32658:	f10a 0601 	add.w	r6, sl, #1
   3265c:	f10a 0b3d 	add.w	fp, sl, #61	; 0x3d
		if (cfg->value != data->type) {
   32660:	f8b6 2007 	ldrh.w	r2, [r6, #7]
   32664:	89ab      	ldrh	r3, [r5, #12]
   32666:	429a      	cmp	r2, r3
   32668:	d10b      	bne.n	32682 <notify_cb+0x7e>
		conn = bt_conn_lookup_addr_le(cfg->id, &cfg->peer);
   3266a:	f816 0c01 	ldrb.w	r0, [r6, #-1]
   3266e:	4631      	mov	r1, r6
   32670:	f7fd fd7c 	bl	3016c <bt_conn_lookup_addr_le>
		if (!conn) {
   32674:	4604      	mov	r4, r0
   32676:	b120      	cbz	r0, 32682 <notify_cb+0x7e>
		if (conn->state != BT_CONN_CONNECTED) {
   32678:	7b43      	ldrb	r3, [r0, #13]
   3267a:	2b07      	cmp	r3, #7
   3267c:	d00a      	beq.n	32694 <notify_cb+0x90>
			bt_conn_unref(conn);
   3267e:	f019 fba2 	bl	4bdc6 <bt_conn_unref>
	for (i = 0; i < ARRAY_SIZE(ccc->cfg); i++) {
   32682:	360a      	adds	r6, #10
   32684:	45b3      	cmp	fp, r6
   32686:	d1eb      	bne.n	32660 <notify_cb+0x5c>
		return BT_GATT_ITER_CONTINUE;
   32688:	f04f 0901 	mov.w	r9, #1
   3268c:	e03c      	b.n	32708 <notify_cb+0x104>
			bt_conn_unref(conn);
   3268e:	f019 fb9a 	bl	4bdc6 <bt_conn_unref>
   32692:	e7dc      	b.n	3264e <notify_cb+0x4a>
		if (ccc->cfg_match && !ccc->cfg_match(conn, attr)) {
   32694:	f8da 3048 	ldr.w	r3, [sl, #72]	; 0x48
   32698:	b123      	cbz	r3, 326a4 <notify_cb+0xa0>
   3269a:	4641      	mov	r1, r8
   3269c:	4798      	blx	r3
   3269e:	b908      	cbnz	r0, 326a4 <notify_cb+0xa0>
			bt_conn_unref(conn);
   326a0:	4620      	mov	r0, r4
   326a2:	e7ec      	b.n	3267e <notify_cb+0x7a>
		if (bt_gatt_check_perm(conn, attr, BT_GATT_PERM_READ_ENCRYPT_MASK)) {
   326a4:	2294      	movs	r2, #148	; 0x94
   326a6:	4641      	mov	r1, r8
   326a8:	4620      	mov	r0, r4
   326aa:	f01a ffa7 	bl	4d5fc <bt_gatt_check_perm>
   326ae:	4681      	mov	r9, r0
   326b0:	2800      	cmp	r0, #0
   326b2:	d1f5      	bne.n	326a0 <notify_cb+0x9c>
		if ((data->type == BT_GATT_CCC_INDICATE) &&
   326b4:	89ab      	ldrh	r3, [r5, #12]
   326b6:	2b02      	cmp	r3, #2
   326b8:	d115      	bne.n	326e6 <notify_cb+0xe2>
   326ba:	f8b6 3007 	ldrh.w	r3, [r6, #7]
   326be:	079a      	lsls	r2, r3, #30
   326c0:	d405      	bmi.n	326ce <notify_cb+0xca>
		bt_conn_unref(conn);
   326c2:	4620      	mov	r0, r4
   326c4:	f019 fb7f 	bl	4bdc6 <bt_conn_unref>
		data->err = 0;
   326c8:	2300      	movs	r3, #0
   326ca:	60ab      	str	r3, [r5, #8]
   326cc:	e7d9      	b.n	32682 <notify_cb+0x7e>
			err = gatt_indicate(conn, data->handle, data->ind_params);
   326ce:	692a      	ldr	r2, [r5, #16]
   326d0:	88a9      	ldrh	r1, [r5, #4]
   326d2:	4620      	mov	r0, r4
   326d4:	f7ff fdac 	bl	32230 <gatt_indicate>
			if (err == 0) {
   326d8:	4607      	mov	r7, r0
   326da:	b980      	cbnz	r0, 326fe <notify_cb+0xfa>
				data->ind_params->_ref++;
   326dc:	692a      	ldr	r2, [r5, #16]
   326de:	7d93      	ldrb	r3, [r2, #22]
   326e0:	3301      	adds	r3, #1
   326e2:	7593      	strb	r3, [r2, #22]
		bt_conn_unref(conn);
   326e4:	e7ed      	b.n	326c2 <notify_cb+0xbe>
		} else if ((data->type == BT_GATT_CCC_NOTIFY) &&
   326e6:	2b01      	cmp	r3, #1
   326e8:	d1eb      	bne.n	326c2 <notify_cb+0xbe>
   326ea:	f8b6 3007 	ldrh.w	r3, [r6, #7]
   326ee:	07db      	lsls	r3, r3, #31
   326f0:	d5e7      	bpl.n	326c2 <notify_cb+0xbe>
			err = gatt_notify(conn, data->handle, data->nfy_params);
   326f2:	692a      	ldr	r2, [r5, #16]
   326f4:	88a9      	ldrh	r1, [r5, #4]
   326f6:	4620      	mov	r0, r4
   326f8:	f01b f83b 	bl	4d772 <gatt_notify>
   326fc:	4607      	mov	r7, r0
		bt_conn_unref(conn);
   326fe:	4620      	mov	r0, r4
   32700:	f019 fb61 	bl	4bdc6 <bt_conn_unref>
		if (err < 0) {
   32704:	2f00      	cmp	r7, #0
   32706:	dadf      	bge.n	326c8 <notify_cb+0xc4>
}
   32708:	4648      	mov	r0, r9
   3270a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   3270e:	bf00      	nop
   32710:	00031c69 	.word	0x00031c69
   32714:	20000704 	.word	0x20000704
   32718:	2000699d 	.word	0x2000699d
   3271c:	00053517 	.word	0x00053517

00032720 <bt_gatt_discover>:
{
   32720:	b570      	push	{r4, r5, r6, lr}
	if (conn->state != BT_CONN_CONNECTED) {
   32722:	7b43      	ldrb	r3, [r0, #13]
   32724:	2b07      	cmp	r3, #7
{
   32726:	b086      	sub	sp, #24
   32728:	4605      	mov	r5, r0
   3272a:	460c      	mov	r4, r1
	if (conn->state != BT_CONN_CONNECTED) {
   3272c:	f040 8099 	bne.w	32862 <bt_gatt_discover+0x142>
	switch (params->type) {
   32730:	7c0b      	ldrb	r3, [r1, #16]
   32732:	2b06      	cmp	r3, #6
   32734:	d867      	bhi.n	32806 <bt_gatt_discover+0xe6>
   32736:	e8df f003 	tbb	[pc, r3]
   3273a:	0404      	.short	0x0404
   3273c:	8d595151 	.word	0x8d595151
   32740:	20          	.byte	0x20
   32741:	00          	.byte	0x00
		if (params->uuid) {
   32742:	680b      	ldr	r3, [r1, #0]
   32744:	b18b      	cbz	r3, 3276a <bt_gatt_discover+0x4a>
	switch (params->uuid->type) {
   32746:	781b      	ldrb	r3, [r3, #0]
   32748:	b16b      	cbz	r3, 32766 <bt_gatt_discover+0x46>
   3274a:	2b02      	cmp	r3, #2
   3274c:	d15b      	bne.n	32806 <bt_gatt_discover+0xe6>
   3274e:	2316      	movs	r3, #22
	return gatt_req_send(conn, gatt_find_type_rsp, params,
   32750:	9301      	str	r3, [sp, #4]
   32752:	2306      	movs	r3, #6
   32754:	9300      	str	r3, [sp, #0]
   32756:	4944      	ldr	r1, [pc, #272]	; (32868 <bt_gatt_discover+0x148>)
   32758:	4b44      	ldr	r3, [pc, #272]	; (3286c <bt_gatt_discover+0x14c>)
   3275a:	4622      	mov	r2, r4
	return gatt_req_send(conn, gatt_read_group_rsp, params,
   3275c:	4628      	mov	r0, r5
   3275e:	f01a fe64 	bl	4d42a <gatt_req_send.constprop.0>
}
   32762:	b006      	add	sp, #24
   32764:	bd70      	pop	{r4, r5, r6, pc}
		len += BT_UUID_SIZE_16;
   32766:	2308      	movs	r3, #8
   32768:	e7f2      	b.n	32750 <bt_gatt_discover+0x30>
	return gatt_req_send(conn, gatt_read_group_rsp, params,
   3276a:	2310      	movs	r3, #16
   3276c:	2104      	movs	r1, #4
   3276e:	e9cd 3100 	strd	r3, r1, [sp]
   32772:	4622      	mov	r2, r4
   32774:	4b3e      	ldr	r3, [pc, #248]	; (32870 <bt_gatt_discover+0x150>)
   32776:	493f      	ldr	r1, [pc, #252]	; (32874 <bt_gatt_discover+0x154>)
   32778:	e7f0      	b.n	3275c <bt_gatt_discover+0x3c>
		if (!(params->uuid && params->uuid->type == BT_UUID_TYPE_16 &&
   3277a:	6808      	ldr	r0, [r1, #0]
   3277c:	2800      	cmp	r0, #0
   3277e:	d042      	beq.n	32806 <bt_gatt_discover+0xe6>
   32780:	7806      	ldrb	r6, [r0, #0]
   32782:	2e00      	cmp	r6, #0
   32784:	d13f      	bne.n	32806 <bt_gatt_discover+0xe6>
		      (!bt_uuid_cmp(params->uuid, BT_UUID_GATT_CEP) ||
   32786:	f44f 5324 	mov.w	r3, #10496	; 0x2900
   3278a:	a902      	add	r1, sp, #8
   3278c:	f88d 6008 	strb.w	r6, [sp, #8]
   32790:	f8ad 300a 	strh.w	r3, [sp, #10]
   32794:	f018 fc32 	bl	4affc <bt_uuid_cmp>
		if (!(params->uuid && params->uuid->type == BT_UUID_TYPE_16 &&
   32798:	b300      	cbz	r0, 327dc <bt_gatt_discover+0xbc>
		       !bt_uuid_cmp(params->uuid, BT_UUID_GATT_CCC) ||
   3279a:	f642 1302 	movw	r3, #10498	; 0x2902
   3279e:	6820      	ldr	r0, [r4, #0]
   327a0:	f88d 600c 	strb.w	r6, [sp, #12]
   327a4:	a903      	add	r1, sp, #12
   327a6:	f8ad 300e 	strh.w	r3, [sp, #14]
   327aa:	f018 fc27 	bl	4affc <bt_uuid_cmp>
		      (!bt_uuid_cmp(params->uuid, BT_UUID_GATT_CEP) ||
   327ae:	b1a8      	cbz	r0, 327dc <bt_gatt_discover+0xbc>
		       !bt_uuid_cmp(params->uuid, BT_UUID_GATT_SCC) ||
   327b0:	f642 1303 	movw	r3, #10499	; 0x2903
   327b4:	6820      	ldr	r0, [r4, #0]
   327b6:	f88d 6010 	strb.w	r6, [sp, #16]
   327ba:	a904      	add	r1, sp, #16
   327bc:	f8ad 3012 	strh.w	r3, [sp, #18]
   327c0:	f018 fc1c 	bl	4affc <bt_uuid_cmp>
		       !bt_uuid_cmp(params->uuid, BT_UUID_GATT_CCC) ||
   327c4:	b150      	cbz	r0, 327dc <bt_gatt_discover+0xbc>
		       !bt_uuid_cmp(params->uuid, BT_UUID_GATT_CPF)))) {
   327c6:	f642 1304 	movw	r3, #10500	; 0x2904
   327ca:	6820      	ldr	r0, [r4, #0]
   327cc:	f88d 6014 	strb.w	r6, [sp, #20]
   327d0:	a905      	add	r1, sp, #20
   327d2:	f8ad 3016 	strh.w	r3, [sp, #22]
   327d6:	f018 fc11 	bl	4affc <bt_uuid_cmp>
		       !bt_uuid_cmp(params->uuid, BT_UUID_GATT_SCC) ||
   327da:	b9a0      	cbnz	r0, 32806 <bt_gatt_discover+0xe6>
	return gatt_req_send(conn, gatt_read_type_rsp, params,
   327dc:	2308      	movs	r3, #8
   327de:	2204      	movs	r2, #4
   327e0:	e9cd 3200 	strd	r3, r2, [sp]
   327e4:	4924      	ldr	r1, [pc, #144]	; (32878 <bt_gatt_discover+0x158>)
   327e6:	4b25      	ldr	r3, [pc, #148]	; (3287c <bt_gatt_discover+0x15c>)
   327e8:	4622      	mov	r2, r4
   327ea:	e7b7      	b.n	3275c <bt_gatt_discover+0x3c>
		if (params->uuid &&
   327ec:	6808      	ldr	r0, [r1, #0]
   327ee:	b388      	cbz	r0, 32854 <bt_gatt_discover+0x134>
		    (!bt_uuid_cmp(params->uuid, BT_UUID_GATT_PRIMARY) ||
   327f0:	2600      	movs	r6, #0
   327f2:	f44f 5320 	mov.w	r3, #10240	; 0x2800
   327f6:	a902      	add	r1, sp, #8
   327f8:	f88d 6008 	strb.w	r6, [sp, #8]
   327fc:	f8ad 300a 	strh.w	r3, [sp, #10]
   32800:	f018 fbfc 	bl	4affc <bt_uuid_cmp>
		if (params->uuid &&
   32804:	b910      	cbnz	r0, 3280c <bt_gatt_discover+0xec>
			return -EINVAL;
   32806:	f06f 0015 	mvn.w	r0, #21
   3280a:	e7aa      	b.n	32762 <bt_gatt_discover+0x42>
		     !bt_uuid_cmp(params->uuid, BT_UUID_GATT_SECONDARY) ||
   3280c:	f642 0301 	movw	r3, #10241	; 0x2801
   32810:	6820      	ldr	r0, [r4, #0]
   32812:	f88d 600c 	strb.w	r6, [sp, #12]
   32816:	a903      	add	r1, sp, #12
   32818:	f8ad 300e 	strh.w	r3, [sp, #14]
   3281c:	f018 fbee 	bl	4affc <bt_uuid_cmp>
		    (!bt_uuid_cmp(params->uuid, BT_UUID_GATT_PRIMARY) ||
   32820:	2800      	cmp	r0, #0
   32822:	d0f0      	beq.n	32806 <bt_gatt_discover+0xe6>
		     !bt_uuid_cmp(params->uuid, BT_UUID_GATT_INCLUDE) ||
   32824:	f642 0302 	movw	r3, #10242	; 0x2802
   32828:	6820      	ldr	r0, [r4, #0]
   3282a:	f88d 6010 	strb.w	r6, [sp, #16]
   3282e:	a904      	add	r1, sp, #16
   32830:	f8ad 3012 	strh.w	r3, [sp, #18]
   32834:	f018 fbe2 	bl	4affc <bt_uuid_cmp>
		     !bt_uuid_cmp(params->uuid, BT_UUID_GATT_SECONDARY) ||
   32838:	2800      	cmp	r0, #0
   3283a:	d0e4      	beq.n	32806 <bt_gatt_discover+0xe6>
		     !bt_uuid_cmp(params->uuid, BT_UUID_GATT_CHRC))) {
   3283c:	f642 0303 	movw	r3, #10243	; 0x2803
   32840:	6820      	ldr	r0, [r4, #0]
   32842:	f88d 6014 	strb.w	r6, [sp, #20]
   32846:	a905      	add	r1, sp, #20
   32848:	f8ad 3016 	strh.w	r3, [sp, #22]
   3284c:	f018 fbd6 	bl	4affc <bt_uuid_cmp>
		     !bt_uuid_cmp(params->uuid, BT_UUID_GATT_INCLUDE) ||
   32850:	2800      	cmp	r0, #0
   32852:	d0d8      	beq.n	32806 <bt_gatt_discover+0xe6>
	return gatt_req_send(conn, gatt_find_info_rsp, params,
   32854:	2304      	movs	r3, #4
   32856:	e9cd 3300 	strd	r3, r3, [sp]
   3285a:	4909      	ldr	r1, [pc, #36]	; (32880 <bt_gatt_discover+0x160>)
   3285c:	4b09      	ldr	r3, [pc, #36]	; (32884 <bt_gatt_discover+0x164>)
   3285e:	4622      	mov	r2, r4
   32860:	e77c      	b.n	3275c <bt_gatt_discover+0x3c>
		return -ENOTCONN;
   32862:	f06f 007f 	mvn.w	r0, #127	; 0x7f
   32866:	e77c      	b.n	32762 <bt_gatt_discover+0x42>
   32868:	0004d82f 	.word	0x0004d82f
   3286c:	0004d23d 	.word	0x0004d23d
   32870:	0004d14d 	.word	0x0004d14d
   32874:	0004d8c9 	.word	0x0004d8c9
   32878:	00032889 	.word	0x00032889
   3287c:	0004d17d 	.word	0x0004d17d
   32880:	0004da47 	.word	0x0004da47
   32884:	0004d135 	.word	0x0004d135

00032888 <gatt_read_type_rsp>:
{
   32888:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   3288c:	b093      	sub	sp, #76	; 0x4c
   3288e:	4680      	mov	r8, r0
   32890:	9d1c      	ldr	r5, [sp, #112]	; 0x70
   32892:	4617      	mov	r7, r2
	if (err) {
   32894:	b131      	cbz	r1, 328a4 <gatt_read_type_rsp+0x1c>
		params->func(conn, NULL, params);
   32896:	686b      	ldr	r3, [r5, #4]
   32898:	462a      	mov	r2, r5
   3289a:	2100      	movs	r1, #0
}
   3289c:	b013      	add	sp, #76	; 0x4c
   3289e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	params->func(conn, NULL, params);
   328a2:	4718      	bx	r3
	if (params->type == BT_GATT_DISCOVER_INCLUDE) {
   328a4:	7c2a      	ldrb	r2, [r5, #16]
   328a6:	2a02      	cmp	r2, #2
   328a8:	d172      	bne.n	32990 <gatt_read_type_rsp+0x108>
	switch (rsp->len) {
   328aa:	7838      	ldrb	r0, [r7, #0]
   328ac:	2806      	cmp	r0, #6
   328ae:	d017      	beq.n	328e0 <gatt_read_type_rsp+0x58>
   328b0:	2808      	cmp	r0, #8
   328b2:	d10f      	bne.n	328d4 <gatt_read_type_rsp+0x4c>
	for (length--, pdu = rsp->data; length >= rsp->len;
   328b4:	1e5c      	subs	r4, r3, #1
		u.uuid.type = BT_UUID_TYPE_16;
   328b6:	f88d 1020 	strb.w	r1, [sp, #32]
	for (length--, pdu = rsp->data; length >= rsp->len;
   328ba:	b2a4      	uxth	r4, r4
   328bc:	f107 0b01 	add.w	fp, r7, #1
	uint16_t handle = 0U;
   328c0:	2600      	movs	r6, #0
			.uuid = BT_UUID_GATT_INCLUDE,
   328c2:	f642 0a02 	movw	sl, #10242	; 0x2802
	for (length--, pdu = rsp->data; length >= rsp->len;
   328c6:	783b      	ldrb	r3, [r7, #0]
   328c8:	42a3      	cmp	r3, r4
   328ca:	d90b      	bls.n	328e4 <gatt_read_type_rsp+0x5c>
	if (length == 0U && handle) {
   328cc:	b914      	cbnz	r4, 328d4 <gatt_read_type_rsp+0x4c>
   328ce:	2e00      	cmp	r6, #0
   328d0:	f040 8123 	bne.w	32b1a <gatt_read_type_rsp+0x292>
	params->func(conn, NULL, params);
   328d4:	686b      	ldr	r3, [r5, #4]
   328d6:	462a      	mov	r2, r5
   328d8:	2100      	movs	r1, #0
   328da:	4640      	mov	r0, r8
   328dc:	4798      	blx	r3
	if (!handle) {
   328de:	e03b      	b.n	32958 <gatt_read_type_rsp+0xd0>
	switch (rsp->len) {
   328e0:	4611      	mov	r1, r2
   328e2:	e7e7      	b.n	328b4 <gatt_read_type_rsp+0x2c>
		handle = sys_le16_to_cpu(data->handle);
   328e4:	f8bb 9000 	ldrh.w	r9, [fp]
   328e8:	fa1f f689 	uxth.w	r6, r9
		if (!handle) {
   328ec:	2e00      	cmp	r6, #0
   328ee:	d0f1      	beq.n	328d4 <gatt_read_type_rsp+0x4c>
		value.start_handle = sys_le16_to_cpu(incl->start_handle);
   328f0:	f8bb 0002 	ldrh.w	r0, [fp, #2]
   328f4:	f8ad 001c 	strh.w	r0, [sp, #28]
		switch (u.uuid.type) {
   328f8:	f89d 2020 	ldrb.w	r2, [sp, #32]
		value.end_handle = sys_le16_to_cpu(incl->end_handle);
   328fc:	f8bb 1004 	ldrh.w	r1, [fp, #4]
   32900:	f8ad 101e 	strh.w	r1, [sp, #30]
		switch (u.uuid.type) {
   32904:	b162      	cbz	r2, 32920 <gatt_read_type_rsp+0x98>
   32906:	2a02      	cmp	r2, #2
   32908:	d015      	beq.n	32936 <gatt_read_type_rsp+0xae>
		if (params->uuid && bt_uuid_cmp(&u.uuid, params->uuid)) {
   3290a:	6829      	ldr	r1, [r5, #0]
   3290c:	b339      	cbz	r1, 3295e <gatt_read_type_rsp+0xd6>
   3290e:	a808      	add	r0, sp, #32
   32910:	f018 fb74 	bl	4affc <bt_uuid_cmp>
   32914:	b318      	cbz	r0, 3295e <gatt_read_type_rsp+0xd6>
	     length -= rsp->len, pdu = (const uint8_t *)pdu + rsp->len) {
   32916:	783b      	ldrb	r3, [r7, #0]
   32918:	1ae4      	subs	r4, r4, r3
   3291a:	b2a4      	uxth	r4, r4
   3291c:	449b      	add	fp, r3
   3291e:	e7d2      	b.n	328c6 <gatt_read_type_rsp+0x3e>
			value.uuid = &u.uuid;
   32920:	aa08      	add	r2, sp, #32
   32922:	9206      	str	r2, [sp, #24]
			u.u16.val = sys_le16_to_cpu(incl->uuid16);
   32924:	f89b 2006 	ldrb.w	r2, [fp, #6]
   32928:	f89b 1007 	ldrb.w	r1, [fp, #7]
   3292c:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
   32930:	f8ad 2022 	strh.w	r2, [sp, #34]	; 0x22
			break;
   32934:	e7e9      	b.n	3290a <gatt_read_type_rsp+0x82>
	return gatt_req_send(conn, read_included_uuid_cb, params,
   32936:	230a      	movs	r3, #10
			params->_included.start_handle = value.start_handle;
   32938:	8168      	strh	r0, [r5, #10]
			params->_included.end_handle = value.end_handle;
   3293a:	81a9      	strh	r1, [r5, #12]
			params->_included.attr_handle = handle;
   3293c:	f8a5 9008 	strh.w	r9, [r5, #8]
	return gatt_req_send(conn, read_included_uuid_cb, params,
   32940:	497a      	ldr	r1, [pc, #488]	; (32b2c <gatt_read_type_rsp+0x2a4>)
   32942:	9201      	str	r2, [sp, #4]
   32944:	9300      	str	r3, [sp, #0]
   32946:	462a      	mov	r2, r5
   32948:	4b79      	ldr	r3, [pc, #484]	; (32b30 <gatt_read_type_rsp+0x2a8>)
   3294a:	4640      	mov	r0, r8
   3294c:	f01a fd6d 	bl	4d42a <gatt_req_send.constprop.0>
			return read_included_uuid(conn, params);
   32950:	b286      	uxth	r6, r0
	if (!handle) {
   32952:	2e00      	cmp	r6, #0
   32954:	f040 80e1 	bne.w	32b1a <gatt_read_type_rsp+0x292>
}
   32958:	b013      	add	sp, #76	; 0x4c
   3295a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			.uuid = BT_UUID_GATT_INCLUDE,
   3295e:	f04f 0300 	mov.w	r3, #0
		attr = (struct bt_gatt_attr) {
   32962:	2210      	movs	r2, #16
   32964:	2100      	movs	r1, #0
   32966:	a80e      	add	r0, sp, #56	; 0x38
			.uuid = BT_UUID_GATT_INCLUDE,
   32968:	f88d 3014 	strb.w	r3, [sp, #20]
   3296c:	f8ad a016 	strh.w	sl, [sp, #22]
		attr = (struct bt_gatt_attr) {
   32970:	f018 fa8e 	bl	4ae90 <memset>
   32974:	aa05      	add	r2, sp, #20
   32976:	920d      	str	r2, [sp, #52]	; 0x34
   32978:	aa06      	add	r2, sp, #24
   3297a:	9210      	str	r2, [sp, #64]	; 0x40
		if (params->func(conn, &attr, params) == BT_GATT_ITER_STOP) {
   3297c:	686b      	ldr	r3, [r5, #4]
		attr = (struct bt_gatt_attr) {
   3297e:	f8ad 9044 	strh.w	r9, [sp, #68]	; 0x44
		if (params->func(conn, &attr, params) == BT_GATT_ITER_STOP) {
   32982:	462a      	mov	r2, r5
   32984:	a90d      	add	r1, sp, #52	; 0x34
   32986:	4640      	mov	r0, r8
   32988:	4798      	blx	r3
   3298a:	2800      	cmp	r0, #0
   3298c:	d1c3      	bne.n	32916 <gatt_read_type_rsp+0x8e>
   3298e:	e7e3      	b.n	32958 <gatt_read_type_rsp+0xd0>
	} else if (params->type == BT_GATT_DISCOVER_CHARACTERISTIC) {
   32990:	2a03      	cmp	r2, #3
   32992:	d15b      	bne.n	32a4c <gatt_read_type_rsp+0x1c4>
	switch (rsp->len) {
   32994:	783a      	ldrb	r2, [r7, #0]
   32996:	2a07      	cmp	r2, #7
   32998:	d002      	beq.n	329a0 <gatt_read_type_rsp+0x118>
   3299a:	2a15      	cmp	r2, #21
   3299c:	d19a      	bne.n	328d4 <gatt_read_type_rsp+0x4c>
   3299e:	2102      	movs	r1, #2
	for (length--, pdu = rsp->data; length >= rsp->len;
   329a0:	1e5c      	subs	r4, r3, #1
		u.uuid.type = BT_UUID_TYPE_16;
   329a2:	f88d 1020 	strb.w	r1, [sp, #32]
	for (length--, pdu = rsp->data; length >= rsp->len;
   329a6:	b2a4      	uxth	r4, r4
   329a8:	f107 0901 	add.w	r9, r7, #1
	uint16_t handle = 0U;
   329ac:	2600      	movs	r6, #0
   329ae:	f10d 0a20 	add.w	sl, sp, #32
	for (length--, pdu = rsp->data; length >= rsp->len;
   329b2:	783b      	ldrb	r3, [r7, #0]
   329b4:	42a3      	cmp	r3, r4
   329b6:	d889      	bhi.n	328cc <gatt_read_type_rsp+0x44>
		handle = sys_le16_to_cpu(data->handle);
   329b8:	f8b9 b000 	ldrh.w	fp, [r9]
   329bc:	fa1f f68b 	uxth.w	r6, fp
		if (!handle) {
   329c0:	2e00      	cmp	r6, #0
   329c2:	d087      	beq.n	328d4 <gatt_read_type_rsp+0x4c>
		switch (u.uuid.type) {
   329c4:	f89d 3020 	ldrb.w	r3, [sp, #32]
   329c8:	b163      	cbz	r3, 329e4 <gatt_read_type_rsp+0x15c>
   329ca:	2b02      	cmp	r3, #2
   329cc:	d013      	beq.n	329f6 <gatt_read_type_rsp+0x16e>
		if (params->uuid && bt_uuid_cmp(&u.uuid, params->uuid)) {
   329ce:	6829      	ldr	r1, [r5, #0]
   329d0:	b1c9      	cbz	r1, 32a06 <gatt_read_type_rsp+0x17e>
   329d2:	4650      	mov	r0, sl
   329d4:	f018 fb12 	bl	4affc <bt_uuid_cmp>
   329d8:	b1a8      	cbz	r0, 32a06 <gatt_read_type_rsp+0x17e>
	     length -= rsp->len, pdu = (const uint8_t *)pdu + rsp->len) {
   329da:	783b      	ldrb	r3, [r7, #0]
   329dc:	1ae4      	subs	r4, r4, r3
   329de:	b2a4      	uxth	r4, r4
   329e0:	4499      	add	r9, r3
   329e2:	e7e6      	b.n	329b2 <gatt_read_type_rsp+0x12a>
			u.u16.val = sys_le16_to_cpu(chrc->uuid16);
   329e4:	f899 3005 	ldrb.w	r3, [r9, #5]
   329e8:	f899 2006 	ldrb.w	r2, [r9, #6]
   329ec:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   329f0:	f8ad 3022 	strh.w	r3, [sp, #34]	; 0x22
			break;
   329f4:	e7eb      	b.n	329ce <gatt_read_type_rsp+0x146>
			memcpy(u.u128.val, chrc->uuid, sizeof(chrc->uuid));
   329f6:	2210      	movs	r2, #16
   329f8:	f109 0105 	add.w	r1, r9, #5
   329fc:	f10d 0021 	add.w	r0, sp, #33	; 0x21
   32a00:	f018 fa3b 	bl	4ae7a <memcpy>
			break;
   32a04:	e7e3      	b.n	329ce <gatt_read_type_rsp+0x146>
		value = (struct bt_gatt_chrc)BT_GATT_CHRC_INIT(
   32a06:	f8b9 2003 	ldrh.w	r2, [r9, #3]
   32a0a:	f899 3002 	ldrb.w	r3, [r9, #2]
   32a0e:	f8ad 201c 	strh.w	r2, [sp, #28]
			.uuid = BT_UUID_GATT_CHRC,
   32a12:	2100      	movs	r1, #0
		value = (struct bt_gatt_chrc)BT_GATT_CHRC_INIT(
   32a14:	f88d 301e 	strb.w	r3, [sp, #30]
		attr = (struct bt_gatt_attr) {
   32a18:	2210      	movs	r2, #16
			.uuid = BT_UUID_GATT_CHRC,
   32a1a:	f642 0303 	movw	r3, #10243	; 0x2803
		attr = (struct bt_gatt_attr) {
   32a1e:	a80e      	add	r0, sp, #56	; 0x38
			.uuid = BT_UUID_GATT_CHRC,
   32a20:	f88d 1014 	strb.w	r1, [sp, #20]
   32a24:	f8ad 3016 	strh.w	r3, [sp, #22]
		value = (struct bt_gatt_chrc)BT_GATT_CHRC_INIT(
   32a28:	f8cd a018 	str.w	sl, [sp, #24]
		attr = (struct bt_gatt_attr) {
   32a2c:	f018 fa30 	bl	4ae90 <memset>
   32a30:	ab05      	add	r3, sp, #20
   32a32:	930d      	str	r3, [sp, #52]	; 0x34
   32a34:	ab06      	add	r3, sp, #24
   32a36:	9310      	str	r3, [sp, #64]	; 0x40
   32a38:	f8ad b044 	strh.w	fp, [sp, #68]	; 0x44
		if (params->func(conn, &attr, params) == BT_GATT_ITER_STOP) {
   32a3c:	686b      	ldr	r3, [r5, #4]
   32a3e:	462a      	mov	r2, r5
   32a40:	a90d      	add	r1, sp, #52	; 0x34
   32a42:	4640      	mov	r0, r8
   32a44:	4798      	blx	r3
   32a46:	2800      	cmp	r0, #0
   32a48:	d1c7      	bne.n	329da <gatt_read_type_rsp+0x152>
   32a4a:	e785      	b.n	32958 <gatt_read_type_rsp+0xd0>
	if (params->uuid->type != BT_UUID_TYPE_16) {
   32a4c:	682a      	ldr	r2, [r5, #0]
   32a4e:	7816      	ldrb	r6, [r2, #0]
   32a50:	b96e      	cbnz	r6, 32a6e <gatt_read_type_rsp+0x1e6>
	uuid_val = BT_UUID_16(params->uuid)->val;
   32a52:	f8b2 a002 	ldrh.w	sl, [r2, #2]
	for (length--, pdu = rsp->data; length >= rsp->len;
   32a56:	1e5c      	subs	r4, r3, #1
   32a58:	b2a4      	uxth	r4, r4
   32a5a:	f107 0901 	add.w	r9, r7, #1
		switch (uuid_val) {
   32a5e:	f5aa 5a24 	sub.w	sl, sl, #10496	; 0x2900
	for (length--, pdu = rsp->data; length >= rsp->len;
   32a62:	783b      	ldrb	r3, [r7, #0]
   32a64:	42a3      	cmp	r3, r4
   32a66:	d907      	bls.n	32a78 <gatt_read_type_rsp+0x1f0>
	if (length == 0U && handle) {
   32a68:	b90c      	cbnz	r4, 32a6e <gatt_read_type_rsp+0x1e6>
   32a6a:	2e00      	cmp	r6, #0
   32a6c:	d155      	bne.n	32b1a <gatt_read_type_rsp+0x292>
	params->func(conn, NULL, params);
   32a6e:	686b      	ldr	r3, [r5, #4]
   32a70:	462a      	mov	r2, r5
   32a72:	2100      	movs	r1, #0
   32a74:	4640      	mov	r0, r8
   32a76:	e711      	b.n	3289c <gatt_read_type_rsp+0x14>
		handle = sys_le16_to_cpu(data->handle);
   32a78:	f8b9 b000 	ldrh.w	fp, [r9]
   32a7c:	fa1f f68b 	uxth.w	r6, fp
		if (!handle) {
   32a80:	2e00      	cmp	r6, #0
   32a82:	d0f4      	beq.n	32a6e <gatt_read_type_rsp+0x1e6>
		switch (uuid_val) {
   32a84:	f1ba 0f04 	cmp.w	sl, #4
   32a88:	d8f1      	bhi.n	32a6e <gatt_read_type_rsp+0x1e6>
   32a8a:	a301      	add	r3, pc, #4	; (adr r3, 32a90 <gatt_read_type_rsp+0x208>)
   32a8c:	f853 f02a 	ldr.w	pc, [r3, sl, lsl #2]
   32a90:	00032aa5 	.word	0x00032aa5
   32a94:	00032a6f 	.word	0x00032a6f
   32a98:	00032aa5 	.word	0x00032aa5
   32a9c:	00032aa5 	.word	0x00032aa5
   32aa0:	00032ae1 	.word	0x00032ae1
			value.scc.flags = sys_get_le16(data->value);
   32aa4:	f8b9 3002 	ldrh.w	r3, [r9, #2]
   32aa8:	f8ad 3020 	strh.w	r3, [sp, #32]
			.uuid = params->uuid,
   32aac:	682b      	ldr	r3, [r5, #0]
   32aae:	9303      	str	r3, [sp, #12]
		attr = (struct bt_gatt_attr) {
   32ab0:	2210      	movs	r2, #16
   32ab2:	2100      	movs	r1, #0
   32ab4:	a80e      	add	r0, sp, #56	; 0x38
   32ab6:	f018 f9eb 	bl	4ae90 <memset>
   32aba:	9b03      	ldr	r3, [sp, #12]
   32abc:	930d      	str	r3, [sp, #52]	; 0x34
   32abe:	ab08      	add	r3, sp, #32
   32ac0:	9310      	str	r3, [sp, #64]	; 0x40
   32ac2:	f8ad b044 	strh.w	fp, [sp, #68]	; 0x44
		if (params->func(conn, &attr, params) == BT_GATT_ITER_STOP) {
   32ac6:	686b      	ldr	r3, [r5, #4]
   32ac8:	462a      	mov	r2, r5
   32aca:	a90d      	add	r1, sp, #52	; 0x34
   32acc:	4640      	mov	r0, r8
   32ace:	4798      	blx	r3
   32ad0:	2800      	cmp	r0, #0
   32ad2:	f43f af41 	beq.w	32958 <gatt_read_type_rsp+0xd0>
	     length -= rsp->len, pdu = (const uint8_t *)pdu + rsp->len) {
   32ad6:	783b      	ldrb	r3, [r7, #0]
   32ad8:	1ae4      	subs	r4, r4, r3
   32ada:	b2a4      	uxth	r4, r4
   32adc:	4499      	add	r9, r3
   32ade:	e7c0      	b.n	32a62 <gatt_read_type_rsp+0x1da>
			value.cpf.format = cpf->format;
   32ae0:	f899 3002 	ldrb.w	r3, [r9, #2]
   32ae4:	f88d 3020 	strb.w	r3, [sp, #32]
			value.cpf.exponent = cpf->exponent;
   32ae8:	f899 3003 	ldrb.w	r3, [r9, #3]
   32aec:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
			value.cpf.unit = sys_le16_to_cpu(cpf->unit);
   32af0:	f899 2005 	ldrb.w	r2, [r9, #5]
   32af4:	f899 3004 	ldrb.w	r3, [r9, #4]
   32af8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   32afc:	f8ad 3022 	strh.w	r3, [sp, #34]	; 0x22
			value.cpf.name_space = cpf->name_space;
   32b00:	f899 3006 	ldrb.w	r3, [r9, #6]
   32b04:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
			value.cpf.description = sys_le16_to_cpu(cpf->description);
   32b08:	f899 3007 	ldrb.w	r3, [r9, #7]
   32b0c:	f899 2008 	ldrb.w	r2, [r9, #8]
   32b10:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   32b14:	f8ad 3026 	strh.w	r3, [sp, #38]	; 0x26
			break;
   32b18:	e7c8      	b.n	32aac <gatt_read_type_rsp+0x224>
	gatt_discover_next(conn, handle, params);
   32b1a:	462a      	mov	r2, r5
   32b1c:	4631      	mov	r1, r6
   32b1e:	4640      	mov	r0, r8
}
   32b20:	b013      	add	sp, #76	; 0x4c
   32b22:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	gatt_discover_next(conn, handle, params);
   32b26:	f01a be64 	b.w	4d7f2 <gatt_discover_next>
   32b2a:	bf00      	nop
   32b2c:	0004d9bd 	.word	0x0004d9bd
   32b30:	0004d121 	.word	0x0004d121

00032b34 <bt_gatt_subscribe>:
{
   32b34:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	if (conn->state != BT_CONN_CONNECTED) {
   32b36:	7b43      	ldrb	r3, [r0, #13]
   32b38:	2b07      	cmp	r3, #7
{
   32b3a:	4606      	mov	r6, r0
   32b3c:	460c      	mov	r4, r1
	if (conn->state != BT_CONN_CONNECTED) {
   32b3e:	d168      	bne.n	32c12 <bt_gatt_subscribe+0xde>
	sub = gatt_sub_find(conn);
   32b40:	f7fe fdf6 	bl	31730 <gatt_sub_find>
	if (!sub) {
   32b44:	4605      	mov	r5, r0
   32b46:	b958      	cbnz	r0, 32b60 <bt_gatt_subscribe+0x2c>
		sub = gatt_sub_find(NULL);
   32b48:	f7fe fdf2 	bl	31730 <gatt_sub_find>
		if (sub) {
   32b4c:	4605      	mov	r5, r0
   32b4e:	2800      	cmp	r0, #0
   32b50:	d062      	beq.n	32c18 <bt_gatt_subscribe+0xe4>
			bt_addr_le_copy(&sub->peer, &conn->le.dst);
   32b52:	f106 0188 	add.w	r1, r6, #136	; 0x88
   32b56:	3001      	adds	r0, #1
   32b58:	f01a fa4d 	bl	4cff6 <bt_addr_le_copy>
			sub->id = conn->id;
   32b5c:	7a33      	ldrb	r3, [r6, #8]
   32b5e:	702b      	strb	r3, [r5, #0]
	return list->head;
   32b60:	68ab      	ldr	r3, [r5, #8]
	SYS_SLIST_FOR_EACH_CONTAINER(&sub->list, tmp, node) {
   32b62:	b1db      	cbz	r3, 32b9c <bt_gatt_subscribe+0x68>
   32b64:	3b20      	subs	r3, #32
   32b66:	2200      	movs	r2, #0
		if (tmp == params) {
   32b68:	429c      	cmp	r4, r3
   32b6a:	d058      	beq.n	32c1e <bt_gatt_subscribe+0xea>
		if (tmp->value_handle == params->value_handle &&
   32b6c:	8998      	ldrh	r0, [r3, #12]
   32b6e:	89a1      	ldrh	r1, [r4, #12]
   32b70:	4288      	cmp	r0, r1
   32b72:	d104      	bne.n	32b7e <bt_gatt_subscribe+0x4a>
   32b74:	8b18      	ldrh	r0, [r3, #24]
   32b76:	8b21      	ldrh	r1, [r4, #24]
			has_subscription = true;
   32b78:	4288      	cmp	r0, r1
   32b7a:	bf28      	it	cs
   32b7c:	2201      	movcs	r2, #1
	return node->next;
   32b7e:	6a1b      	ldr	r3, [r3, #32]
	SYS_SLIST_FOR_EACH_CONTAINER(&sub->list, tmp, node) {
   32b80:	b953      	cbnz	r3, 32b98 <bt_gatt_subscribe+0x64>
	if (!has_subscription) {
   32b82:	b15a      	cbz	r2, 32b9c <bt_gatt_subscribe+0x68>
	return list->head;
   32b84:	68aa      	ldr	r2, [r5, #8]
	parent->next = child;
   32b86:	6222      	str	r2, [r4, #32]
Z_GENLIST_PREPEND(slist, snode)
   32b88:	68ea      	ldr	r2, [r5, #12]
	sys_slist_prepend(&sub->list, &params->node);
   32b8a:	f104 0320 	add.w	r3, r4, #32
	list->head = node;
   32b8e:	60ab      	str	r3, [r5, #8]
Z_GENLIST_PREPEND(slist, snode)
   32b90:	b902      	cbnz	r2, 32b94 <bt_gatt_subscribe+0x60>
	list->tail = node;
   32b92:	60eb      	str	r3, [r5, #12]
	return 0;
   32b94:	2600      	movs	r6, #0
   32b96:	e02a      	b.n	32bee <bt_gatt_subscribe+0xba>
	SYS_SLIST_FOR_EACH_CONTAINER(&sub->list, tmp, node) {
   32b98:	3b20      	subs	r3, #32
   32b9a:	e7e5      	b.n	32b68 <bt_gatt_subscribe+0x34>
		if (!params->ccc_handle) {
   32b9c:	89e7      	ldrh	r7, [r4, #14]
   32b9e:	bb4f      	cbnz	r7, 32bf4 <bt_gatt_subscribe+0xc0>
	memcpy(&ccc_uuid, BT_UUID_GATT_CCC, sizeof(ccc_uuid));
   32ba0:	4d20      	ldr	r5, [pc, #128]	; (32c24 <bt_gatt_subscribe+0xf0>)
   32ba2:	f88d 7004 	strb.w	r7, [sp, #4]
   32ba6:	2204      	movs	r2, #4
   32ba8:	f642 1302 	movw	r3, #10498	; 0x2902
   32bac:	eb0d 0102 	add.w	r1, sp, r2
   32bb0:	4628      	mov	r0, r5
   32bb2:	f8ad 3006 	strh.w	r3, [sp, #6]
   32bb6:	f018 f960 	bl	4ae7a <memcpy>
	memset(params->disc_params, 0, sizeof(*params->disc_params));
   32bba:	2218      	movs	r2, #24
   32bbc:	4639      	mov	r1, r7
   32bbe:	6960      	ldr	r0, [r4, #20]
   32bc0:	f018 f966 	bl	4ae90 <memset>
	params->disc_params->sub_params = params;
   32bc4:	6963      	ldr	r3, [r4, #20]
   32bc6:	615c      	str	r4, [r3, #20]
	params->disc_params->uuid = &ccc_uuid.uuid;
   32bc8:	6963      	ldr	r3, [r4, #20]
   32bca:	601d      	str	r5, [r3, #0]
	params->disc_params->type = BT_GATT_DISCOVER_DESCRIPTOR;
   32bcc:	6963      	ldr	r3, [r4, #20]
   32bce:	2204      	movs	r2, #4
   32bd0:	741a      	strb	r2, [r3, #16]
	params->disc_params->start_handle = params->value_handle;
   32bd2:	6963      	ldr	r3, [r4, #20]
   32bd4:	89a2      	ldrh	r2, [r4, #12]
   32bd6:	811a      	strh	r2, [r3, #8]
	params->disc_params->end_handle = params->end_handle;
   32bd8:	6963      	ldr	r3, [r4, #20]
   32bda:	8a22      	ldrh	r2, [r4, #16]
   32bdc:	81da      	strh	r2, [r3, #14]
	params->disc_params->func = gatt_ccc_discover_cb;
   32bde:	6963      	ldr	r3, [r4, #20]
   32be0:	4a11      	ldr	r2, [pc, #68]	; (32c28 <bt_gatt_subscribe+0xf4>)
   32be2:	605a      	str	r2, [r3, #4]
	err = bt_gatt_discover(conn, params->disc_params);
   32be4:	4630      	mov	r0, r6
   32be6:	6961      	ldr	r1, [r4, #20]
   32be8:	f7ff fd9a 	bl	32720 <bt_gatt_discover>
   32bec:	4606      	mov	r6, r0
}
   32bee:	4630      	mov	r0, r6
   32bf0:	b003      	add	sp, #12
   32bf2:	bdf0      	pop	{r4, r5, r6, r7, pc}
		err = gatt_write_ccc(conn, params);
   32bf4:	4630      	mov	r0, r6
   32bf6:	4621      	mov	r1, r4
   32bf8:	f7fe ffca 	bl	31b90 <gatt_write_ccc>
		if (err) {
   32bfc:	4606      	mov	r6, r0
   32bfe:	2800      	cmp	r0, #0
   32c00:	d0c0      	beq.n	32b84 <bt_gatt_subscribe+0x50>
	if (gatt_sub_is_empty(sub)) {
   32c02:	68ab      	ldr	r3, [r5, #8]
   32c04:	2b00      	cmp	r3, #0
   32c06:	d1f2      	bne.n	32bee <bt_gatt_subscribe+0xba>
	bt_addr_le_copy(&sub->peer, BT_ADDR_LE_ANY);
   32c08:	4908      	ldr	r1, [pc, #32]	; (32c2c <bt_gatt_subscribe+0xf8>)
   32c0a:	1c68      	adds	r0, r5, #1
   32c0c:	f01a f9f3 	bl	4cff6 <bt_addr_le_copy>
}
   32c10:	e7ed      	b.n	32bee <bt_gatt_subscribe+0xba>
		return -ENOTCONN;
   32c12:	f06f 067f 	mvn.w	r6, #127	; 0x7f
   32c16:	e7ea      	b.n	32bee <bt_gatt_subscribe+0xba>
		return -ENOMEM;
   32c18:	f06f 060b 	mvn.w	r6, #11
   32c1c:	e7e7      	b.n	32bee <bt_gatt_subscribe+0xba>
			return -EALREADY;
   32c1e:	f06f 0677 	mvn.w	r6, #119	; 0x77
   32c22:	e7e4      	b.n	32bee <bt_gatt_subscribe+0xba>
   32c24:	20006998 	.word	0x20006998
   32c28:	0004dc11 	.word	0x0004dc11
   32c2c:	00053517 	.word	0x00053517

00032c30 <bt_gatt_unsubscribe>:
{
   32c30:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (conn->state != BT_CONN_CONNECTED) {
   32c34:	7b43      	ldrb	r3, [r0, #13]
   32c36:	2b07      	cmp	r3, #7
{
   32c38:	4607      	mov	r7, r0
   32c3a:	460d      	mov	r5, r1
	if (conn->state != BT_CONN_CONNECTED) {
   32c3c:	d15b      	bne.n	32cf6 <bt_gatt_unsubscribe+0xc6>
	sub = gatt_sub_find(conn);
   32c3e:	f7fe fd77 	bl	31730 <gatt_sub_find>
	if (!sub) {
   32c42:	4606      	mov	r6, r0
   32c44:	2800      	cmp	r0, #0
   32c46:	d059      	beq.n	32cfc <bt_gatt_unsubscribe+0xcc>
	return list->head;
   32c48:	6884      	ldr	r4, [r0, #8]
	SYS_SLIST_FOR_EACH_CONTAINER(&sub->list, tmp, node) {
   32c4a:	2c00      	cmp	r4, #0
   32c4c:	d056      	beq.n	32cfc <bt_gatt_unsubscribe+0xcc>
   32c4e:	2300      	movs	r3, #0
   32c50:	3c20      	subs	r4, #32
   32c52:	4698      	mov	r8, r3
		if (params == tmp) {
   32c54:	42a5      	cmp	r5, r4
   32c56:	d009      	beq.n	32c6c <bt_gatt_unsubscribe+0x3c>
		if (tmp->value_handle == params->value_handle) {
   32c58:	89a1      	ldrh	r1, [r4, #12]
   32c5a:	89aa      	ldrh	r2, [r5, #12]
			has_subscription = true;
   32c5c:	4291      	cmp	r1, r2
   32c5e:	bf08      	it	eq
   32c60:	f04f 0801 	moveq.w	r8, #1
	return node->next;
   32c64:	6a24      	ldr	r4, [r4, #32]
	SYS_SLIST_FOR_EACH_CONTAINER(&sub->list, tmp, node) {
   32c66:	b11c      	cbz	r4, 32c70 <bt_gatt_unsubscribe+0x40>
   32c68:	3c20      	subs	r4, #32
   32c6a:	e7f3      	b.n	32c54 <bt_gatt_unsubscribe+0x24>
			found = true;
   32c6c:	2301      	movs	r3, #1
   32c6e:	e7f9      	b.n	32c64 <bt_gatt_unsubscribe+0x34>
	if (!found) {
   32c70:	2b00      	cmp	r3, #0
   32c72:	d043      	beq.n	32cfc <bt_gatt_unsubscribe+0xcc>
   32c74:	f105 001c 	add.w	r0, r5, #28
   32c78:	f01a f9a8 	bl	4cfcc <atomic_get>
	if (atomic_test_bit(params->flags, BT_GATT_SUBSCRIBE_FLAG_WRITE_PENDING)) {
   32c7c:	0743      	lsls	r3, r0, #29
   32c7e:	d503      	bpl.n	32c88 <bt_gatt_unsubscribe+0x58>
		bt_gatt_cancel(conn, params);
   32c80:	4629      	mov	r1, r5
   32c82:	4638      	mov	r0, r7
   32c84:	f01a ffed 	bl	4dc62 <bt_gatt_cancel>
	if (!has_subscription) {
   32c88:	f1b8 0f00 	cmp.w	r8, #0
   32c8c:	d019      	beq.n	32cc2 <bt_gatt_unsubscribe+0x92>
	return list->head;
   32c8e:	68b3      	ldr	r3, [r6, #8]
	sys_slist_find_and_remove(&sub->list, &params->node);
   32c90:	f105 0220 	add.w	r2, r5, #32
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

/** @} */
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   32c94:	b153      	cbz	r3, 32cac <bt_gatt_unsubscribe+0x7c>
   32c96:	429a      	cmp	r2, r3
   32c98:	d123      	bne.n	32ce2 <bt_gatt_unsubscribe+0xb2>
	return node->next;
   32c9a:	6a2b      	ldr	r3, [r5, #32]
Z_GENLIST_REMOVE(slist, snode)
   32c9c:	b9dc      	cbnz	r4, 32cd6 <bt_gatt_unsubscribe+0xa6>
   32c9e:	68f1      	ldr	r1, [r6, #12]
	list->head = node;
   32ca0:	60b3      	str	r3, [r6, #8]
Z_GENLIST_REMOVE(slist, snode)
   32ca2:	428a      	cmp	r2, r1
   32ca4:	d100      	bne.n	32ca8 <bt_gatt_unsubscribe+0x78>
	list->tail = node;
   32ca6:	60f3      	str	r3, [r6, #12]
	parent->next = child;
   32ca8:	2300      	movs	r3, #0
   32caa:	622b      	str	r3, [r5, #32]
	if (gatt_sub_is_empty(sub)) {
   32cac:	68b3      	ldr	r3, [r6, #8]
   32cae:	b91b      	cbnz	r3, 32cb8 <bt_gatt_unsubscribe+0x88>
	bt_addr_le_copy(&sub->peer, BT_ADDR_LE_ANY);
   32cb0:	4914      	ldr	r1, [pc, #80]	; (32d04 <bt_gatt_unsubscribe+0xd4>)
   32cb2:	1c70      	adds	r0, r6, #1
   32cb4:	f01a f99f 	bl	4cff6 <bt_addr_le_copy>
	if (has_subscription) {
   32cb8:	f1b8 0f00 	cmp.w	r8, #0
   32cbc:	d114      	bne.n	32ce8 <bt_gatt_unsubscribe+0xb8>
	return 0;
   32cbe:	2000      	movs	r0, #0
   32cc0:	e007      	b.n	32cd2 <bt_gatt_unsubscribe+0xa2>
		params->value = 0x0000;
   32cc2:	f8a5 8018 	strh.w	r8, [r5, #24]
		err = gatt_write_ccc(conn, params);
   32cc6:	4629      	mov	r1, r5
   32cc8:	4638      	mov	r0, r7
   32cca:	f7fe ff61 	bl	31b90 <gatt_write_ccc>
		if (err) {
   32cce:	2800      	cmp	r0, #0
   32cd0:	d0dd      	beq.n	32c8e <bt_gatt_unsubscribe+0x5e>
}
   32cd2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   32cd6:	6023      	str	r3, [r4, #0]
Z_GENLIST_REMOVE(slist, snode)
   32cd8:	68f3      	ldr	r3, [r6, #12]
   32cda:	429a      	cmp	r2, r3
	list->tail = node;
   32cdc:	bf08      	it	eq
   32cde:	60f4      	streq	r4, [r6, #12]
}
   32ce0:	e7e2      	b.n	32ca8 <bt_gatt_unsubscribe+0x78>
	return node->next;
   32ce2:	461c      	mov	r4, r3
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   32ce4:	681b      	ldr	r3, [r3, #0]
   32ce6:	e7d5      	b.n	32c94 <bt_gatt_unsubscribe+0x64>
		params->notify(conn, params, NULL, 0);
   32ce8:	2300      	movs	r3, #0
   32cea:	682c      	ldr	r4, [r5, #0]
   32cec:	461a      	mov	r2, r3
   32cee:	4629      	mov	r1, r5
   32cf0:	4638      	mov	r0, r7
   32cf2:	47a0      	blx	r4
   32cf4:	e7e3      	b.n	32cbe <bt_gatt_unsubscribe+0x8e>
		return -ENOTCONN;
   32cf6:	f06f 007f 	mvn.w	r0, #127	; 0x7f
   32cfa:	e7ea      	b.n	32cd2 <bt_gatt_unsubscribe+0xa2>
		return -EINVAL;
   32cfc:	f06f 0015 	mvn.w	r0, #21
   32d00:	e7e7      	b.n	32cd2 <bt_gatt_unsubscribe+0xa2>
   32d02:	bf00      	nop
   32d04:	00053517 	.word	0x00053517

00032d08 <bt_gatt_connected>:
{
   32d08:	b570      	push	{r4, r5, r6, lr}
   32d0a:	b08e      	sub	sp, #56	; 0x38
	    bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
   32d0c:	f100 0688 	add.w	r6, r0, #136	; 0x88
{
   32d10:	4604      	mov	r4, r0
	data.conn = conn;
   32d12:	9003      	str	r0, [sp, #12]
	data.sec = BT_SECURITY_L1;
   32d14:	2301      	movs	r3, #1
	    bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
   32d16:	7a00      	ldrb	r0, [r0, #8]
	data.sec = BT_SECURITY_L1;
   32d18:	f88d 3010 	strb.w	r3, [sp, #16]
	    bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
   32d1c:	4631      	mov	r1, r6
   32d1e:	f018 fcf5 	bl	4b70c <bt_addr_le_is_bonded>
	if (IS_ENABLED(CONFIG_BT_SETTINGS_CCC_LAZY_LOADING) &&
   32d22:	b198      	cbz	r0, 32d4c <bt_gatt_connected+0x44>
		if (conn->id) {
   32d24:	7a22      	ldrb	r2, [r4, #8]
   32d26:	2a00      	cmp	r2, #0
   32d28:	d03b      	beq.n	32da2 <bt_gatt_connected+0x9a>
			u8_to_dec(id_str, sizeof(id_str), conn->id);
   32d2a:	ad02      	add	r5, sp, #8
   32d2c:	2104      	movs	r1, #4
   32d2e:	4628      	mov	r0, r5
   32d30:	f015 fded 	bl	4890e <u8_to_dec>
			bt_settings_encode_key(key, sizeof(key), "ccc",
   32d34:	9500      	str	r5, [sp, #0]
			bt_settings_encode_key(key, sizeof(key), "ccc",
   32d36:	4a1d      	ldr	r2, [pc, #116]	; (32dac <bt_gatt_connected+0xa4>)
   32d38:	2124      	movs	r1, #36	; 0x24
   32d3a:	a805      	add	r0, sp, #20
   32d3c:	4633      	mov	r3, r6
   32d3e:	f7fa fd53 	bl	2d7e8 <bt_settings_encode_key>
		settings_load_subtree_direct(key, ccc_set_direct, (void *)key);
   32d42:	aa05      	add	r2, sp, #20
   32d44:	491a      	ldr	r1, [pc, #104]	; (32db0 <bt_gatt_connected+0xa8>)
   32d46:	4610      	mov	r0, r2
   32d48:	f7f9 fc08 	bl	2c55c <settings_load_subtree_direct>
	bt_gatt_foreach_attr(0x0001, 0xffff, update_ccc, &data);
   32d4c:	ab03      	add	r3, sp, #12
   32d4e:	4a19      	ldr	r2, [pc, #100]	; (32db4 <bt_gatt_connected+0xac>)
   32d50:	f64f 71ff 	movw	r1, #65535	; 0xffff
   32d54:	2001      	movs	r0, #1
   32d56:	f01a fc46 	bl	4d5e6 <bt_gatt_foreach_attr>
	if (IS_ENABLED(CONFIG_BT_SMP) &&
   32d5a:	78e3      	ldrb	r3, [r4, #3]
   32d5c:	b94b      	cbnz	r3, 32d72 <bt_gatt_connected+0x6a>
	    bt_conn_get_security(conn) < data.sec) {
   32d5e:	4620      	mov	r0, r4
   32d60:	f019 f8e0 	bl	4bf24 <bt_conn_get_security>
   32d64:	f89d 1010 	ldrb.w	r1, [sp, #16]
	     IS_ENABLED(CONFIG_BT_GATT_AUTO_SEC_REQ)) &&
   32d68:	4288      	cmp	r0, r1
   32d6a:	d202      	bcs.n	32d72 <bt_gatt_connected+0x6a>
		int err = bt_conn_set_security(conn, data.sec);
   32d6c:	4620      	mov	r0, r4
   32d6e:	f019 f8b1 	bl	4bed4 <bt_conn_set_security>
	sub = gatt_sub_find(conn);
   32d72:	4620      	mov	r0, r4
   32d74:	f7fe fcdc 	bl	31730 <gatt_sub_find>
	if (!sub) {
   32d78:	b1a8      	cbz	r0, 32da6 <bt_gatt_connected+0x9e>
	return list->head;
   32d7a:	6885      	ldr	r5, [r0, #8]
	SYS_SLIST_FOR_EACH_CONTAINER(&sub->list, params, node) {
   32d7c:	b19d      	cbz	r5, 32da6 <bt_gatt_connected+0x9e>
		if (bt_addr_le_is_bonded(conn->id, &conn->le.dst) &&
   32d7e:	7a20      	ldrb	r0, [r4, #8]
   32d80:	4631      	mov	r1, r6
	SYS_SLIST_FOR_EACH_CONTAINER(&sub->list, params, node) {
   32d82:	3d20      	subs	r5, #32
		if (bt_addr_le_is_bonded(conn->id, &conn->le.dst) &&
   32d84:	f018 fcc2 	bl	4b70c <bt_addr_le_is_bonded>
   32d88:	b148      	cbz	r0, 32d9e <bt_gatt_connected+0x96>
   32d8a:	f105 001c 	add.w	r0, r5, #28
   32d8e:	f01a f91d 	bl	4cfcc <atomic_get>
   32d92:	0783      	lsls	r3, r0, #30
   32d94:	d403      	bmi.n	32d9e <bt_gatt_connected+0x96>
			gatt_write_ccc(conn, params);
   32d96:	4629      	mov	r1, r5
   32d98:	4620      	mov	r0, r4
   32d9a:	f7fe fef9 	bl	31b90 <gatt_write_ccc>
	return node->next;
   32d9e:	6a2d      	ldr	r5, [r5, #32]
   32da0:	e7ec      	b.n	32d7c <bt_gatt_connected+0x74>
			bt_settings_encode_key(key, sizeof(key), "ccc",
   32da2:	9200      	str	r2, [sp, #0]
   32da4:	e7c7      	b.n	32d36 <bt_gatt_connected+0x2e>
}
   32da6:	b00e      	add	sp, #56	; 0x38
   32da8:	bd70      	pop	{r4, r5, r6, pc}
   32daa:	bf00      	nop
   32dac:	0005378c 	.word	0x0005378c
   32db0:	00032175 	.word	0x00032175
   32db4:	00032439 	.word	0x00032439

00032db8 <bt_gatt_att_max_mtu_changed>:
{
   32db8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	return list->head;
   32dba:	4b08      	ldr	r3, [pc, #32]	; (32ddc <bt_gatt_att_max_mtu_changed+0x24>)
   32dbc:	681c      	ldr	r4, [r3, #0]
   32dbe:	4605      	mov	r5, r0
   32dc0:	460e      	mov	r6, r1
   32dc2:	4617      	mov	r7, r2
	SYS_SLIST_FOR_EACH_CONTAINER(&callback_list, cb, node) {
   32dc4:	b14c      	cbz	r4, 32dda <bt_gatt_att_max_mtu_changed+0x22>
		if (cb->att_mtu_updated) {
   32dc6:	f854 3c04 	ldr.w	r3, [r4, #-4]
	SYS_SLIST_FOR_EACH_CONTAINER(&callback_list, cb, node) {
   32dca:	3c04      	subs	r4, #4
		if (cb->att_mtu_updated) {
   32dcc:	b11b      	cbz	r3, 32dd6 <bt_gatt_att_max_mtu_changed+0x1e>
			cb->att_mtu_updated(conn, tx, rx);
   32dce:	463a      	mov	r2, r7
   32dd0:	4631      	mov	r1, r6
   32dd2:	4628      	mov	r0, r5
   32dd4:	4798      	blx	r3
	return node->next;
   32dd6:	6864      	ldr	r4, [r4, #4]
   32dd8:	e7f4      	b.n	32dc4 <bt_gatt_att_max_mtu_changed+0xc>
}
   32dda:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   32ddc:	2000410c 	.word	0x2000410c

00032de0 <bt_gatt_encrypt_change>:
{
   32de0:	b507      	push	{r0, r1, r2, lr}
	bt_gatt_foreach_attr(0x0001, 0xffff, update_ccc, &data);
   32de2:	4a06      	ldr	r2, [pc, #24]	; (32dfc <bt_gatt_encrypt_change+0x1c>)
	data.conn = conn;
   32de4:	9000      	str	r0, [sp, #0]
	bt_gatt_foreach_attr(0x0001, 0xffff, update_ccc, &data);
   32de6:	466b      	mov	r3, sp
	data.sec = BT_SECURITY_L1;
   32de8:	2001      	movs	r0, #1
	bt_gatt_foreach_attr(0x0001, 0xffff, update_ccc, &data);
   32dea:	f64f 71ff 	movw	r1, #65535	; 0xffff
	data.sec = BT_SECURITY_L1;
   32dee:	f88d 0004 	strb.w	r0, [sp, #4]
	bt_gatt_foreach_attr(0x0001, 0xffff, update_ccc, &data);
   32df2:	f01a fbf8 	bl	4d5e6 <bt_gatt_foreach_attr>
}
   32df6:	b003      	add	sp, #12
   32df8:	f85d fb04 	ldr.w	pc, [sp], #4
   32dfc:	00032439 	.word	0x00032439

00032e00 <bt_gatt_store_ccc>:
{
   32e00:	b570      	push	{r4, r5, r6, lr}
   32e02:	b0c0      	sub	sp, #256	; 0x100
	save.count = 0;
   32e04:	2300      	movs	r3, #0
{
   32e06:	4604      	mov	r4, r0
   32e08:	460d      	mov	r5, r1
	save.addr_with_id.addr = addr;
   32e0a:	910d      	str	r1, [sp, #52]	; 0x34
	save.addr_with_id.id = id;
   32e0c:	f88d 0038 	strb.w	r0, [sp, #56]	; 0x38
	save.count = 0;
   32e10:	933f      	str	r3, [sp, #252]	; 0xfc
	bt_gatt_foreach_attr(0x0001, 0xffff, ccc_save, &save);
   32e12:	4a11      	ldr	r2, [pc, #68]	; (32e58 <bt_gatt_store_ccc+0x58>)
   32e14:	ab0d      	add	r3, sp, #52	; 0x34
   32e16:	f64f 71ff 	movw	r1, #65535	; 0xffff
   32e1a:	2001      	movs	r0, #1
   32e1c:	f01a fbe3 	bl	4d5e6 <bt_gatt_foreach_attr>
	if (id) {
   32e20:	b1ac      	cbz	r4, 32e4e <bt_gatt_store_ccc+0x4e>
		u8_to_dec(id_str, sizeof(id_str), id);
   32e22:	ae03      	add	r6, sp, #12
   32e24:	4622      	mov	r2, r4
   32e26:	2104      	movs	r1, #4
   32e28:	4630      	mov	r0, r6
   32e2a:	f015 fd70 	bl	4890e <u8_to_dec>
		bt_settings_encode_key(key, sizeof(key), "ccc", addr, id_str);
   32e2e:	9600      	str	r6, [sp, #0]
		bt_settings_encode_key(key, sizeof(key), "ccc", addr, NULL);
   32e30:	4a0a      	ldr	r2, [pc, #40]	; (32e5c <bt_gatt_store_ccc+0x5c>)
   32e32:	462b      	mov	r3, r5
   32e34:	2124      	movs	r1, #36	; 0x24
   32e36:	a804      	add	r0, sp, #16
   32e38:	f7fa fcd6 	bl	2d7e8 <bt_settings_encode_key>
	if (save.count) {
   32e3c:	9a3f      	ldr	r2, [sp, #252]	; 0xfc
   32e3e:	b142      	cbz	r2, 32e52 <bt_gatt_store_ccc+0x52>
		len = save.count * sizeof(*save.store);
   32e40:	0092      	lsls	r2, r2, #2
		str = (char *)save.store;
   32e42:	a90f      	add	r1, sp, #60	; 0x3c
	err = settings_save_one(key, str, len);
   32e44:	a804      	add	r0, sp, #16
   32e46:	f7f9 fb29 	bl	2c49c <settings_save_one>
}
   32e4a:	b040      	add	sp, #256	; 0x100
   32e4c:	bd70      	pop	{r4, r5, r6, pc}
		bt_settings_encode_key(key, sizeof(key), "ccc", addr, NULL);
   32e4e:	9400      	str	r4, [sp, #0]
   32e50:	e7ee      	b.n	32e30 <bt_gatt_store_ccc+0x30>
		str = NULL;
   32e52:	4611      	mov	r1, r2
   32e54:	e7f6      	b.n	32e44 <bt_gatt_store_ccc+0x44>
   32e56:	bf00      	nop
   32e58:	00031a71 	.word	0x00031a71
   32e5c:	0005378c 	.word	0x0005378c

00032e60 <bt_gatt_identity_resolved>:
{
   32e60:	b513      	push	{r0, r1, r4, lr}
   32e62:	4604      	mov	r4, r0
	struct addr_match user_data = {
   32e64:	e9cd 1200 	strd	r1, r2, [sp]
	bt_gatt_foreach_attr(0x0001, 0xffff, convert_to_id_on_match, &user_data);
   32e68:	466b      	mov	r3, sp
   32e6a:	4a08      	ldr	r2, [pc, #32]	; (32e8c <bt_gatt_identity_resolved+0x2c>)
   32e6c:	f64f 71ff 	movw	r1, #65535	; 0xffff
   32e70:	2001      	movs	r0, #1
   32e72:	f01a fbb8 	bl	4d5e6 <bt_gatt_foreach_attr>
	bt_gatt_store_ccc(conn->id, &(conn->le.dst));
   32e76:	f104 0188 	add.w	r1, r4, #136	; 0x88
   32e7a:	7a20      	ldrb	r0, [r4, #8]
   32e7c:	f7ff ffc0 	bl	32e00 <bt_gatt_store_ccc>
	bt_gatt_store_cf(conn);
   32e80:	4620      	mov	r0, r4
   32e82:	f7fe fe11 	bl	31aa8 <bt_gatt_store_cf.isra.0>
}
   32e86:	b002      	add	sp, #8
   32e88:	bd10      	pop	{r4, pc}
   32e8a:	bf00      	nop
   32e8c:	00031a3d 	.word	0x00031a3d

00032e90 <bt_gatt_clear>:
		gatt_sub_remove(NULL, sub, prev, params);
	}
}

int bt_gatt_clear(uint8_t id, const bt_addr_le_t *addr)
{
   32e90:	b5f0      	push	{r4, r5, r6, r7, lr}
   32e92:	b08f      	sub	sp, #60	; 0x3c
	bt_gatt_foreach_attr(0x0001, 0xffff, remove_peer_from_attr,
   32e94:	ae03      	add	r6, sp, #12
{
   32e96:	4604      	mov	r4, r0
   32e98:	460d      	mov	r5, r1
	struct addr_with_id addr_with_id = {
   32e9a:	9103      	str	r1, [sp, #12]
   32e9c:	f88d 0010 	strb.w	r0, [sp, #16]
	bt_gatt_foreach_attr(0x0001, 0xffff, remove_peer_from_attr,
   32ea0:	4a3c      	ldr	r2, [pc, #240]	; (32f94 <bt_gatt_clear+0x104>)
   32ea2:	4633      	mov	r3, r6
   32ea4:	f64f 71ff 	movw	r1, #65535	; 0xffff
   32ea8:	2001      	movs	r0, #1
   32eaa:	f01a fb9c 	bl	4d5e6 <bt_gatt_foreach_attr>
		if (id) {
   32eae:	2c00      	cmp	r4, #0
   32eb0:	d03e      	beq.n	32f30 <bt_gatt_clear+0xa0>
			u8_to_dec(id_str, sizeof(id_str), id);
   32eb2:	af02      	add	r7, sp, #8
   32eb4:	4622      	mov	r2, r4
   32eb6:	2104      	movs	r1, #4
   32eb8:	4638      	mov	r0, r7
   32eba:	f015 fd28 	bl	4890e <u8_to_dec>
			bt_settings_encode_key(key, sizeof(key), "ccc",
   32ebe:	9700      	str	r7, [sp, #0]
			bt_settings_encode_key(key, sizeof(key), "ccc",
   32ec0:	4a35      	ldr	r2, [pc, #212]	; (32f98 <bt_gatt_clear+0x108>)
   32ec2:	462b      	mov	r3, r5
   32ec4:	2124      	movs	r1, #36	; 0x24
   32ec6:	a805      	add	r0, sp, #20
   32ec8:	f7fa fc8e 	bl	2d7e8 <bt_settings_encode_key>
		return settings_delete(key);
   32ecc:	a805      	add	r0, sp, #20
   32ece:	f016 fc20 	bl	49712 <settings_delete>
	int err;

	err = bt_gatt_clear_ccc(id, addr);
	if (err < 0) {
   32ed2:	2800      	cmp	r0, #0
   32ed4:	db2a      	blt.n	32f2c <bt_gatt_clear+0x9c>
		return err;
	}

	if (IS_ENABLED(CONFIG_BT_GATT_SERVICE_CHANGED)) {
		err = bt_gatt_clear_sc(id, addr);
   32ed6:	4629      	mov	r1, r5
   32ed8:	4620      	mov	r0, r4
   32eda:	f7fe fe15 	bl	31b08 <bt_gatt_clear_sc>
		if (err < 0) {
   32ede:	2800      	cmp	r0, #0
   32ee0:	db24      	blt.n	32f2c <bt_gatt_clear+0x9c>
	cfg = find_cf_cfg_by_addr(id, addr);
   32ee2:	4629      	mov	r1, r5
   32ee4:	4620      	mov	r0, r4
   32ee6:	f7fe fc47 	bl	31778 <find_cf_cfg_by_addr>
	if (cfg) {
   32eea:	b108      	cbz	r0, 32ef0 <bt_gatt_clear+0x60>
		clear_cf_cfg(cfg);
   32eec:	f7fe fd76 	bl	319dc <clear_cf_cfg>
		if (id) {
   32ef0:	b304      	cbz	r4, 32f34 <bt_gatt_clear+0xa4>
			u8_to_dec(id_str, sizeof(id_str), id);
   32ef2:	4622      	mov	r2, r4
   32ef4:	2104      	movs	r1, #4
   32ef6:	4630      	mov	r0, r6
   32ef8:	f015 fd09 	bl	4890e <u8_to_dec>
			bt_settings_encode_key(key, sizeof(key), "cf",
   32efc:	9600      	str	r6, [sp, #0]
			bt_settings_encode_key(key, sizeof(key), "cf",
   32efe:	4a27      	ldr	r2, [pc, #156]	; (32f9c <bt_gatt_clear+0x10c>)
   32f00:	462b      	mov	r3, r5
   32f02:	2124      	movs	r1, #36	; 0x24
   32f04:	a805      	add	r0, sp, #20
   32f06:	f7fa fc6f 	bl	2d7e8 <bt_settings_encode_key>
		return settings_delete(key);
   32f0a:	a805      	add	r0, sp, #20
   32f0c:	f016 fc01 	bl	49712 <settings_delete>
		}
	}

	if (IS_ENABLED(CONFIG_BT_GATT_CACHING)) {
		err = bt_gatt_clear_cf(id, addr);
		if (err < 0) {
   32f10:	2800      	cmp	r0, #0
   32f12:	db0b      	blt.n	32f2c <bt_gatt_clear+0x9c>
   32f14:	4f22      	ldr	r7, [pc, #136]	; (32fa0 <bt_gatt_clear+0x110>)
   32f16:	2600      	movs	r6, #0
		if (id == sub->id &&
   32f18:	f817 3c01 	ldrb.w	r3, [r7, #-1]
   32f1c:	42a3      	cmp	r3, r4
   32f1e:	d00b      	beq.n	32f38 <bt_gatt_clear+0xa8>
	for (int i = 0; i < ARRAY_SIZE(subscriptions); i++) {
   32f20:	3610      	adds	r6, #16
   32f22:	2ec0      	cmp	r6, #192	; 0xc0
   32f24:	f107 0710 	add.w	r7, r7, #16
   32f28:	d1f6      	bne.n	32f18 <bt_gatt_clear+0x88>

	if (IS_ENABLED(CONFIG_BT_GATT_CLIENT)) {
		bt_gatt_clear_subscriptions(id, addr);
	}

	return 0;
   32f2a:	2000      	movs	r0, #0
}
   32f2c:	b00f      	add	sp, #60	; 0x3c
   32f2e:	bdf0      	pop	{r4, r5, r6, r7, pc}
			bt_settings_encode_key(key, sizeof(key), "ccc",
   32f30:	9400      	str	r4, [sp, #0]
   32f32:	e7c5      	b.n	32ec0 <bt_gatt_clear+0x30>
			bt_settings_encode_key(key, sizeof(key), "cf",
   32f34:	9400      	str	r4, [sp, #0]
   32f36:	e7e2      	b.n	32efe <bt_gatt_clear+0x6e>
		    !bt_addr_le_cmp(addr, &sub->peer)) {
   32f38:	4639      	mov	r1, r7
   32f3a:	4628      	mov	r0, r5
   32f3c:	f01a f829 	bl	4cf92 <bt_addr_le_cmp>
		if (id == sub->id &&
   32f40:	2800      	cmp	r0, #0
   32f42:	d1ed      	bne.n	32f20 <bt_gatt_clear+0x90>
		struct gatt_sub *sub = &subscriptions[i];
   32f44:	4d17      	ldr	r5, [pc, #92]	; (32fa4 <bt_gatt_clear+0x114>)
   32f46:	4435      	add	r5, r6
	return list->head;
   32f48:	68ab      	ldr	r3, [r5, #8]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp,
   32f4a:	2b00      	cmp	r3, #0
   32f4c:	d0ed      	beq.n	32f2a <bt_gatt_clear+0x9a>
	return node->next;
   32f4e:	681c      	ldr	r4, [r3, #0]
   32f50:	b104      	cbz	r4, 32f54 <bt_gatt_clear+0xc4>
   32f52:	3c20      	subs	r4, #32
		params->value = 0U;
   32f54:	2700      	movs	r7, #0
   32f56:	f823 7c08 	strh.w	r7, [r3, #-8]
		gatt_sub_remove(NULL, sub, prev, params);
   32f5a:	463a      	mov	r2, r7
   32f5c:	3b20      	subs	r3, #32
   32f5e:	4629      	mov	r1, r5
   32f60:	4638      	mov	r0, r7
   32f62:	f7fe fc25 	bl	317b0 <gatt_sub_remove>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp,
   32f66:	b954      	cbnz	r4, 32f7e <bt_gatt_clear+0xee>
   32f68:	e7df      	b.n	32f2a <bt_gatt_clear+0x9a>
   32f6a:	f1a2 0620 	sub.w	r6, r2, #32
		gatt_sub_remove(NULL, sub, prev, params);
   32f6e:	2200      	movs	r2, #0
		params->value = 0U;
   32f70:	8327      	strh	r7, [r4, #24]
		gatt_sub_remove(NULL, sub, prev, params);
   32f72:	4623      	mov	r3, r4
   32f74:	4629      	mov	r1, r5
   32f76:	4610      	mov	r0, r2
   32f78:	f7fe fc1a 	bl	317b0 <gatt_sub_remove>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp,
   32f7c:	4634      	mov	r4, r6
   32f7e:	6a22      	ldr	r2, [r4, #32]
   32f80:	2a00      	cmp	r2, #0
   32f82:	d1f2      	bne.n	32f6a <bt_gatt_clear+0xda>
		params->value = 0U;
   32f84:	8322      	strh	r2, [r4, #24]
		gatt_sub_remove(NULL, sub, prev, params);
   32f86:	4623      	mov	r3, r4
   32f88:	4629      	mov	r1, r5
   32f8a:	4610      	mov	r0, r2
   32f8c:	f7fe fc10 	bl	317b0 <gatt_sub_remove>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp,
   32f90:	e7cb      	b.n	32f2a <bt_gatt_clear+0x9a>
   32f92:	bf00      	nop
   32f94:	00031a15 	.word	0x00031a15
   32f98:	0005378c 	.word	0x0005378c
   32f9c:	00053793 	.word	0x00053793
   32fa0:	20004115 	.word	0x20004115
   32fa4:	20004114 	.word	0x20004114

00032fa8 <bt_gatt_disconnected>:

void bt_gatt_disconnected(struct bt_conn *conn)
{
   32fa8:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	BT_DBG("conn %p", conn);
	bt_gatt_foreach_attr(0x0001, 0xffff, disconnected_cb, conn);
   32fac:	4603      	mov	r3, r0
   32fae:	4a49      	ldr	r2, [pc, #292]	; (330d4 <bt_gatt_disconnected+0x12c>)
	if (gatt_ccc_store.conn_list[index] != NULL) {
   32fb0:	4e49      	ldr	r6, [pc, #292]	; (330d8 <bt_gatt_disconnected+0x130>)
{
   32fb2:	4604      	mov	r4, r0
	bt_gatt_foreach_attr(0x0001, 0xffff, disconnected_cb, conn);
   32fb4:	f64f 71ff 	movw	r1, #65535	; 0xffff
   32fb8:	2001      	movs	r0, #1
   32fba:	f01a fb14 	bl	4d5e6 <bt_gatt_foreach_attr>
	uint8_t index = bt_conn_index(conn);
   32fbe:	4620      	mov	r0, r4
   32fc0:	f7fc ffa0 	bl	2ff04 <bt_conn_index>
   32fc4:	4605      	mov	r5, r0
	if (gatt_ccc_store.conn_list[index] != NULL) {
   32fc6:	f856 0020 	ldr.w	r0, [r6, r0, lsl #2]
   32fca:	b120      	cbz	r0, 32fd6 <bt_gatt_disconnected+0x2e>
		bt_conn_unref(gatt_ccc_store.conn_list[index]);
   32fcc:	f018 fefb 	bl	4bdc6 <bt_conn_unref>
		gatt_ccc_store.conn_list[index] = NULL;
   32fd0:	2300      	movs	r3, #0
   32fd2:	f846 3025 	str.w	r3, [r6, r5, lsl #2]
	for (size_t i = 0; i < CONFIG_BT_MAX_CONN; i++) {
   32fd6:	4a40      	ldr	r2, [pc, #256]	; (330d8 <bt_gatt_disconnected+0x130>)
   32fd8:	2300      	movs	r3, #0
		if (gatt_ccc_store.conn_list[i]) {
   32fda:	f852 1b04 	ldr.w	r1, [r2], #4
   32fde:	b929      	cbnz	r1, 32fec <bt_gatt_disconnected+0x44>
	for (size_t i = 0; i < CONFIG_BT_MAX_CONN; i++) {
   32fe0:	3301      	adds	r3, #1
   32fe2:	2b06      	cmp	r3, #6
   32fe4:	d1f9      	bne.n	32fda <bt_gatt_disconnected+0x32>

#if defined(CONFIG_BT_SETTINGS_CCC_STORE_ON_WRITE)
	gatt_ccc_conn_unqueue(conn);

	if (gatt_ccc_conn_queue_is_empty()) {
		k_work_cancel_delayable(&gatt_ccc_store.work);
   32fe6:	483d      	ldr	r0, [pc, #244]	; (330dc <bt_gatt_disconnected+0x134>)
   32fe8:	f01d f81a 	bl	50020 <k_work_cancel_delayable>
	}
#endif

	if (IS_ENABLED(CONFIG_BT_SETTINGS) &&
	    bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
   32fec:	f104 0688 	add.w	r6, r4, #136	; 0x88
   32ff0:	7a20      	ldrb	r0, [r4, #8]
   32ff2:	4631      	mov	r1, r6
   32ff4:	f018 fb8a 	bl	4b70c <bt_addr_le_is_bonded>
	if (IS_ENABLED(CONFIG_BT_SETTINGS) &&
   32ff8:	b130      	cbz	r0, 33008 <bt_gatt_disconnected+0x60>
		bt_gatt_store_ccc(conn->id, &conn->le.dst);
   32ffa:	7a20      	ldrb	r0, [r4, #8]
   32ffc:	4631      	mov	r1, r6
   32ffe:	f7ff feff 	bl	32e00 <bt_gatt_store_ccc>
		bt_gatt_store_cf(conn);
   33002:	4620      	mov	r0, r4
   33004:	f7fe fd50 	bl	31aa8 <bt_gatt_store_cf.isra.0>
	}

	/* Make sure to clear the CCC entry when using lazy loading */
	if (IS_ENABLED(CONFIG_BT_SETTINGS_CCC_LAZY_LOADING) &&
	    bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
   33008:	7a20      	ldrb	r0, [r4, #8]
   3300a:	4631      	mov	r1, r6
   3300c:	f018 fb7e 	bl	4b70c <bt_addr_le_is_bonded>
	if (IS_ENABLED(CONFIG_BT_SETTINGS_CCC_LAZY_LOADING) &&
   33010:	b150      	cbz	r0, 33028 <bt_gatt_disconnected+0x80>
		struct addr_with_id addr_with_id = {
   33012:	7a23      	ldrb	r3, [r4, #8]
   33014:	f88d 3004 	strb.w	r3, [sp, #4]
			.addr = &conn->le.dst,
			.id = conn->id,
		};
		bt_gatt_foreach_attr(0x0001, 0xffff,
   33018:	4a31      	ldr	r2, [pc, #196]	; (330e0 <bt_gatt_disconnected+0x138>)
		struct addr_with_id addr_with_id = {
   3301a:	9600      	str	r6, [sp, #0]
		bt_gatt_foreach_attr(0x0001, 0xffff,
   3301c:	466b      	mov	r3, sp
   3301e:	f64f 71ff 	movw	r1, #65535	; 0xffff
   33022:	2001      	movs	r0, #1
   33024:	f01a fadf 	bl	4d5e6 <bt_gatt_foreach_attr>
	sub = gatt_sub_find(conn);
   33028:	4620      	mov	r0, r4
   3302a:	f7fe fb81 	bl	31730 <gatt_sub_find>
	if (!sub) {
   3302e:	4607      	mov	r7, r0
   33030:	b940      	cbnz	r0, 33044 <bt_gatt_disconnected+0x9c>
	cfg = find_cf_cfg(conn);
   33032:	4620      	mov	r0, r4
   33034:	f7fe fb1e 	bl	31674 <find_cf_cfg>
	if (!cfg) {
   33038:	4605      	mov	r5, r0
   3303a:	2800      	cmp	r0, #0
   3303c:	d137      	bne.n	330ae <bt_gatt_disconnected+0x106>
#endif /* CONFIG_BT_GATT_CLIENT */

#if defined(CONFIG_BT_GATT_CACHING)
	remove_cf_cfg(conn);
#endif
}
   3303e:	b002      	add	sp, #8
   33040:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	return list->head;
   33044:	6885      	ldr	r5, [r0, #8]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp, node) {
   33046:	2d00      	cmp	r5, #0
   33048:	d0f3      	beq.n	33032 <bt_gatt_disconnected+0x8a>
	return node->next;
   3304a:	f855 8920 	ldr.w	r8, [r5], #-32
   3304e:	f1b8 0f00 	cmp.w	r8, #0
   33052:	d001      	beq.n	33058 <bt_gatt_disconnected+0xb0>
   33054:	f1a8 0820 	sub.w	r8, r8, #32
	for (size_t i = 0; i < CONFIG_BT_MAX_CONN; i++) {
   33058:	f04f 0900 	mov.w	r9, #0
			params->value = 0U;
   3305c:	46ca      	mov	sl, r9
   3305e:	e001      	b.n	33064 <bt_gatt_disconnected+0xbc>
	for (size_t i = 0; i < CONFIG_BT_MAX_CONN; i++) {
   33060:	4645      	mov	r5, r8
   33062:	4698      	mov	r8, r3
		if (!bt_addr_le_is_bonded(conn->id, &conn->le.dst) ||
   33064:	7a20      	ldrb	r0, [r4, #8]
   33066:	4631      	mov	r1, r6
   33068:	f018 fb50 	bl	4b70c <bt_addr_le_is_bonded>
   3306c:	b980      	cbnz	r0, 33090 <bt_gatt_disconnected+0xe8>
			params->value = 0U;
   3306e:	f8a5 a018 	strh.w	sl, [r5, #24]
			gatt_sub_remove(conn, sub, prev, params);
   33072:	462b      	mov	r3, r5
   33074:	464a      	mov	r2, r9
   33076:	4639      	mov	r1, r7
   33078:	4620      	mov	r0, r4
   3307a:	f7fe fb99 	bl	317b0 <gatt_sub_remove>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp, node) {
   3307e:	f1b8 0f00 	cmp.w	r8, #0
   33082:	d0d6      	beq.n	33032 <bt_gatt_disconnected+0x8a>
   33084:	f8d8 3020 	ldr.w	r3, [r8, #32]
   33088:	2b00      	cmp	r3, #0
   3308a:	d0e9      	beq.n	33060 <bt_gatt_disconnected+0xb8>
   3308c:	3b20      	subs	r3, #32
   3308e:	e7e7      	b.n	33060 <bt_gatt_disconnected+0xb8>
   33090:	f105 001c 	add.w	r0, r5, #28
   33094:	f019 ff9a 	bl	4cfcc <atomic_get>
		if (!bt_addr_le_is_bonded(conn->id, &conn->le.dst) ||
   33098:	07c3      	lsls	r3, r0, #31
   3309a:	d4e8      	bmi.n	3306e <bt_gatt_disconnected+0xc6>
	if (sub->peer.type == BT_ADDR_LE_PUBLIC) {
   3309c:	787b      	ldrb	r3, [r7, #1]
   3309e:	b11b      	cbz	r3, 330a8 <bt_gatt_disconnected+0x100>
	bt_addr_le_copy(&sub->peer, &conn->le.dst);
   330a0:	4631      	mov	r1, r6
   330a2:	1c78      	adds	r0, r7, #1
   330a4:	f019 ffa7 	bl	4cff6 <bt_addr_le_copy>
			prev = &params->node;
   330a8:	f105 0920 	add.w	r9, r5, #32
   330ac:	e7e7      	b.n	3307e <bt_gatt_disconnected+0xd6>
	if (!bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
   330ae:	7a20      	ldrb	r0, [r4, #8]
   330b0:	4631      	mov	r1, r6
   330b2:	f018 fb2b 	bl	4b70c <bt_addr_le_is_bonded>
   330b6:	b928      	cbnz	r0, 330c4 <bt_gatt_disconnected+0x11c>
		clear_cf_cfg(cfg);
   330b8:	4628      	mov	r0, r5
}
   330ba:	b002      	add	sp, #8
   330bc:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		clear_cf_cfg(cfg);
   330c0:	f7fe bc8c 	b.w	319dc <clear_cf_cfg>
		bt_addr_le_copy(&cfg->peer, &conn->le.dst);
   330c4:	4631      	mov	r1, r6
   330c6:	1c68      	adds	r0, r5, #1
}
   330c8:	b002      	add	sp, #8
   330ca:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		bt_addr_le_copy(&cfg->peer, &conn->le.dst);
   330ce:	f019 bf92 	b.w	4cff6 <bt_addr_le_copy>
   330d2:	bf00      	nop
   330d4:	00031bb5 	.word	0x00031bb5
   330d8:	20001ca8 	.word	0x20001ca8
   330dc:	20001cc0 	.word	0x20001cc0
   330e0:	00031a15 	.word	0x00031a15

000330e4 <bt_smp_accept>:
		conn->le.keys->flags &= ~BT_KEYS_SC;
	}
}

static int bt_smp_accept(struct bt_conn *conn, struct bt_l2cap_chan **chan)
{
   330e4:	b530      	push	{r4, r5, lr}
   330e6:	4c0c      	ldr	r4, [pc, #48]	; (33118 <bt_smp_accept+0x34>)
		.recv = bt_smp_recv,
	};

	BT_DBG("conn %p handle %u", conn, conn->handle);

	for (i = 0; i < ARRAY_SIZE(bt_smp_pool); i++) {
   330e8:	2300      	movs	r3, #0
   330ea:	4622      	mov	r2, r4
		struct bt_smp *smp = &bt_smp_pool[i];

		if (smp->chan.chan.conn) {
   330ec:	f8d4 00ec 	ldr.w	r0, [r4, #236]	; 0xec
   330f0:	b138      	cbz	r0, 33102 <bt_smp_accept+0x1e>
	for (i = 0; i < ARRAY_SIZE(bt_smp_pool); i++) {
   330f2:	3301      	adds	r3, #1
   330f4:	2b06      	cmp	r3, #6
   330f6:	f504 74d8 	add.w	r4, r4, #432	; 0x1b0
   330fa:	d1f7      	bne.n	330ec <bt_smp_accept+0x8>
		return 0;
	}

	BT_ERR("No available SMP context for conn %p", conn);

	return -ENOMEM;
   330fc:	f06f 000b 	mvn.w	r0, #11
}
   33100:	bd30      	pop	{r4, r5, pc}
		smp->chan.chan.ops = &ops;
   33102:	f44f 74d8 	mov.w	r4, #432	; 0x1b0
   33106:	4363      	muls	r3, r4
   33108:	18d4      	adds	r4, r2, r3
		*chan = &smp->chan.chan;
   3310a:	33ec      	adds	r3, #236	; 0xec
		smp->chan.chan.ops = &ops;
   3310c:	4d03      	ldr	r5, [pc, #12]	; (3311c <bt_smp_accept+0x38>)
   3310e:	f8c4 50f0 	str.w	r5, [r4, #240]	; 0xf0
		*chan = &smp->chan.chan;
   33112:	441a      	add	r2, r3
   33114:	600a      	str	r2, [r1, #0]
		return 0;
   33116:	e7f3      	b.n	33100 <bt_smp_accept+0x1c>
   33118:	20001dc0 	.word	0x20001dc0
   3311c:	0005206c 	.word	0x0005206c

00033120 <smp_find>:
		if (atomic_test_bit(bt_smp_pool[i].flags, flag)) {
   33120:	4a08      	ldr	r2, [pc, #32]	; (33144 <smp_find+0x24>)
{
   33122:	b510      	push	{r4, lr}
   33124:	4601      	mov	r1, r0
   33126:	2300      	movs	r3, #0
		if (atomic_test_bit(bt_smp_pool[i].flags, flag)) {
   33128:	1d14      	adds	r4, r2, #4
   3312a:	18e0      	adds	r0, r4, r3
   3312c:	f01a febd 	bl	4deaa <atomic_test_bit>
   33130:	b108      	cbz	r0, 33136 <smp_find+0x16>
			return &bt_smp_pool[i];
   33132:	1898      	adds	r0, r3, r2
}
   33134:	bd10      	pop	{r4, pc}
	for (int i = 0; i < ARRAY_SIZE(bt_smp_pool); i++) {
   33136:	f503 73d8 	add.w	r3, r3, #432	; 0x1b0
   3313a:	f5b3 6f22 	cmp.w	r3, #2592	; 0xa20
   3313e:	d1f4      	bne.n	3312a <smp_find+0xa>
   33140:	e7f8      	b.n	33134 <smp_find+0x14>
   33142:	bf00      	nop
   33144:	20001dc0 	.word	0x20001dc0

00033148 <latch_auth_cb>:
{
   33148:	b510      	push	{r4, lr}
	atomic_ptr_cas(&smp->auth_cb, BT_SMP_AUTH_CB_UNINITIALIZED, (atomic_ptr_val_t)bt_auth);
   3314a:	4a0c      	ldr	r2, [pc, #48]	; (3317c <latch_auth_cb+0x34>)
	return __atomic_compare_exchange_n(target, &old_value, new_value,
   3314c:	6811      	ldr	r1, [r2, #0]
   3314e:	4a0c      	ldr	r2, [pc, #48]	; (33180 <latch_auth_cb+0x38>)
   33150:	f3bf 8f5b 	dmb	ish
   33154:	f500 73d4 	add.w	r3, r0, #424	; 0x1a8
   33158:	e853 4f00 	ldrex	r4, [r3]
   3315c:	4294      	cmp	r4, r2
   3315e:	d104      	bne.n	3316a <latch_auth_cb+0x22>
   33160:	e843 1c00 	strex	ip, r1, [r3]
   33164:	f1bc 0f00 	cmp.w	ip, #0
   33168:	d1f6      	bne.n	33158 <latch_auth_cb+0x10>
   3316a:	f3bf 8f5b 	dmb	ish
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   3316e:	f3bf 8f5b 	dmb	ish
   33172:	f8d0 01a8 	ldr.w	r0, [r0, #424]	; 0x1a8
   33176:	f3bf 8f5b 	dmb	ish
}
   3317a:	bd10      	pop	{r4, pc}
   3317c:	20003c0c 	.word	0x20003c0c
   33180:	20001dc0 	.word	0x20001dc0

00033184 <get_io_capa>:
{
   33184:	b508      	push	{r3, lr}
	const struct bt_conn_auth_cb *smp_auth_cb = latch_auth_cb(smp);
   33186:	f7ff ffdf 	bl	33148 <latch_auth_cb>
	if (!smp_auth_cb) {
   3318a:	4603      	mov	r3, r0
   3318c:	b1c8      	cbz	r0, 331c2 <get_io_capa+0x3e>
	if (smp_auth_cb->passkey_display && smp_auth_cb->passkey_entry &&
   3318e:	e9d0 1201 	ldrd	r1, r2, [r0, #4]
   33192:	b921      	cbnz	r1, 3319e <get_io_capa+0x1a>
			return BT_SMP_IO_KEYBOARD_ONLY;
   33194:	2a00      	cmp	r2, #0
   33196:	bf0c      	ite	eq
   33198:	2003      	moveq	r0, #3
   3319a:	2002      	movne	r0, #2
   3319c:	e010      	b.n	331c0 <get_io_capa+0x3c>
	if (smp_auth_cb->passkey_display && smp_auth_cb->passkey_entry &&
   3319e:	b132      	cbz	r2, 331ae <get_io_capa+0x2a>
   331a0:	68c3      	ldr	r3, [r0, #12]
   331a2:	b913      	cbnz	r3, 331aa <get_io_capa+0x26>
	    (smp_auth_cb->passkey_confirm || !sc_supported)) {
   331a4:	4b09      	ldr	r3, [pc, #36]	; (331cc <get_io_capa+0x48>)
   331a6:	781b      	ldrb	r3, [r3, #0]
   331a8:	b933      	cbnz	r3, 331b8 <get_io_capa+0x34>
		return BT_SMP_IO_KEYBOARD_DISPLAY;
   331aa:	2004      	movs	r0, #4
   331ac:	e008      	b.n	331c0 <get_io_capa+0x3c>
	if (sc_supported && smp_auth_cb->passkey_display &&
   331ae:	4907      	ldr	r1, [pc, #28]	; (331cc <get_io_capa+0x48>)
   331b0:	7808      	ldrb	r0, [r1, #0]
   331b2:	b128      	cbz	r0, 331c0 <get_io_capa+0x3c>
   331b4:	68db      	ldr	r3, [r3, #12]
   331b6:	b933      	cbnz	r3, 331c6 <get_io_capa+0x42>
	if (smp_auth_cb->passkey_entry) {
   331b8:	3a00      	subs	r2, #0
   331ba:	bf18      	it	ne
   331bc:	2201      	movne	r2, #1
   331be:	0050      	lsls	r0, r2, #1
}
   331c0:	bd08      	pop	{r3, pc}
		return BT_SMP_IO_NO_INPUT_OUTPUT;
   331c2:	2003      	movs	r0, #3
   331c4:	e7fc      	b.n	331c0 <get_io_capa+0x3c>
		return BT_SMP_IO_DISPLAY_YESNO;
   331c6:	2001      	movs	r0, #1
   331c8:	e7fa      	b.n	331c0 <get_io_capa+0x3c>
   331ca:	bf00      	nop
   331cc:	20006ba8 	.word	0x20006ba8

000331d0 <get_auth>:
{
   331d0:	b510      	push	{r4, lr}
	if (sc_supported) {
   331d2:	4b0c      	ldr	r3, [pc, #48]	; (33204 <get_auth+0x34>)
   331d4:	781b      	ldrb	r3, [r3, #0]
   331d6:	b17b      	cbz	r3, 331f8 <get_auth+0x28>
		auth &= BT_SMP_AUTH_MASK_SC;
   331d8:	f001 040f 	and.w	r4, r1, #15
	if ((get_io_capa(smp) == BT_SMP_IO_NO_INPUT_OUTPUT) ||
   331dc:	f7ff ffd2 	bl	33184 <get_io_capa>
	if (bondable) {
   331e0:	4b09      	ldr	r3, [pc, #36]	; (33208 <get_auth+0x38>)
   331e2:	781b      	ldrb	r3, [r3, #0]
	if ((get_io_capa(smp) == BT_SMP_IO_NO_INPUT_OUTPUT) ||
   331e4:	2803      	cmp	r0, #3
		auth &= ~(BT_SMP_AUTH_MITM);
   331e6:	bf0c      	ite	eq
   331e8:	f004 040b 	andeq.w	r4, r4, #11
		auth |= BT_SMP_AUTH_MITM;
   331ec:	f044 0404 	orrne.w	r4, r4, #4
	if (bondable) {
   331f0:	b12b      	cbz	r3, 331fe <get_auth+0x2e>
		auth |= BT_SMP_AUTH_BONDING;
   331f2:	f044 0001 	orr.w	r0, r4, #1
}
   331f6:	bd10      	pop	{r4, pc}
		auth &= BT_SMP_AUTH_MASK;
   331f8:	f001 0407 	and.w	r4, r1, #7
   331fc:	e7ee      	b.n	331dc <get_auth+0xc>
		auth &= ~BT_SMP_AUTH_BONDING;
   331fe:	f004 00fe 	and.w	r0, r4, #254	; 0xfe
   33202:	e7f8      	b.n	331f6 <get_auth+0x26>
   33204:	20006ba8 	.word	0x20006ba8
   33208:	20000f9f 	.word	0x20000f9f

0003320c <get_pair_method>:
{
   3320c:	b538      	push	{r3, r4, r5, lr}
   3320e:	460c      	mov	r4, r1
	if ((req->auth_req & rsp->auth_req) & BT_SMP_AUTH_SC) {
   33210:	7b03      	ldrb	r3, [r0, #12]
   33212:	7cc1      	ldrb	r1, [r0, #19]
   33214:	ea03 0201 	and.w	r2, r3, r1
   33218:	0715      	lsls	r5, r2, #28
   3321a:	d504      	bpl.n	33226 <get_pair_method+0x1a>
		if ((req->oob_flag | rsp->oob_flag) & BT_SMP_OOB_DATA_MASK) {
   3321c:	7ac2      	ldrb	r2, [r0, #11]
   3321e:	7c85      	ldrb	r5, [r0, #18]
   33220:	432a      	orrs	r2, r5
   33222:	07d2      	lsls	r2, r2, #31
   33224:	d40e      	bmi.n	33244 <get_pair_method+0x38>
	if (remote_io > BT_SMP_IO_KEYBOARD_DISPLAY) {
   33226:	2c04      	cmp	r4, #4
   33228:	d80e      	bhi.n	33248 <get_pair_method+0x3c>
	if (!((req->auth_req | rsp->auth_req) & BT_SMP_AUTH_MITM)) {
   3322a:	430b      	orrs	r3, r1
   3322c:	f013 0304 	ands.w	r3, r3, #4
   33230:	d006      	beq.n	33240 <get_pair_method+0x34>
	return gen_method_sc[remote_io][get_io_capa(smp)];
   33232:	f7ff ffa7 	bl	33184 <get_io_capa>
   33236:	4b05      	ldr	r3, [pc, #20]	; (3324c <get_pair_method+0x40>)
   33238:	eb04 0484 	add.w	r4, r4, r4, lsl #2
   3323c:	4423      	add	r3, r4
   3323e:	5c1b      	ldrb	r3, [r3, r0]
}
   33240:	4618      	mov	r0, r3
   33242:	bd38      	pop	{r3, r4, r5, pc}
			return LE_SC_OOB;
   33244:	2305      	movs	r3, #5
   33246:	e7fb      	b.n	33240 <get_pair_method+0x34>
		return JUST_WORKS;
   33248:	2300      	movs	r3, #0
   3324a:	e7f9      	b.n	33240 <get_pair_method+0x34>
   3324c:	000537cc 	.word	0x000537cc

00033250 <sec_level_reachable>:
{
   33250:	b538      	push	{r3, r4, r5, lr}
   33252:	4605      	mov	r5, r0
	const struct bt_conn_auth_cb *smp_auth_cb = latch_auth_cb(smp);
   33254:	f7ff ff78 	bl	33148 <latch_auth_cb>
	switch (smp->chan.chan.conn->required_sec_level) {
   33258:	f8d5 30ec 	ldr.w	r3, [r5, #236]	; 0xec
   3325c:	7a9b      	ldrb	r3, [r3, #10]
   3325e:	2b03      	cmp	r3, #3
	const struct bt_conn_auth_cb *smp_auth_cb = latch_auth_cb(smp);
   33260:	4604      	mov	r4, r0
	switch (smp->chan.chan.conn->required_sec_level) {
   33262:	d00a      	beq.n	3327a <sec_level_reachable+0x2a>
   33264:	d805      	bhi.n	33272 <sec_level_reachable+0x22>
   33266:	3b01      	subs	r3, #1
   33268:	2b01      	cmp	r3, #1
   3326a:	bf8c      	ite	hi
   3326c:	2000      	movhi	r0, #0
   3326e:	2001      	movls	r0, #1
}
   33270:	bd38      	pop	{r3, r4, r5, pc}
	switch (smp->chan.chan.conn->required_sec_level) {
   33272:	2b04      	cmp	r3, #4
   33274:	d00f      	beq.n	33296 <sec_level_reachable+0x46>
   33276:	2000      	movs	r0, #0
   33278:	e7fa      	b.n	33270 <sec_level_reachable+0x20>
		return get_io_capa(smp) != BT_SMP_IO_NO_INPUT_OUTPUT ||
   3327a:	4628      	mov	r0, r5
   3327c:	f7ff ff82 	bl	33184 <get_io_capa>
   33280:	2803      	cmp	r0, #3
   33282:	d106      	bne.n	33292 <sec_level_reachable+0x42>
   33284:	2c00      	cmp	r4, #0
   33286:	d0f6      	beq.n	33276 <sec_level_reachable+0x26>
		       (smp_auth_cb && smp_auth_cb->oob_data_request);
   33288:	6920      	ldr	r0, [r4, #16]
   3328a:	3800      	subs	r0, #0
   3328c:	bf18      	it	ne
   3328e:	2001      	movne	r0, #1
   33290:	e7ee      	b.n	33270 <sec_level_reachable+0x20>
		return get_io_capa(smp) != BT_SMP_IO_NO_INPUT_OUTPUT ||
   33292:	2001      	movs	r0, #1
   33294:	e7ec      	b.n	33270 <sec_level_reachable+0x20>
		return (get_io_capa(smp) != BT_SMP_IO_NO_INPUT_OUTPUT ||
   33296:	4628      	mov	r0, r5
   33298:	f7ff ff74 	bl	33184 <get_io_capa>
		       (smp_auth_cb && smp_auth_cb->oob_data_request)) && sc_supported;
   3329c:	2803      	cmp	r0, #3
   3329e:	d102      	bne.n	332a6 <sec_level_reachable+0x56>
		return (get_io_capa(smp) != BT_SMP_IO_NO_INPUT_OUTPUT ||
   332a0:	b11c      	cbz	r4, 332aa <sec_level_reachable+0x5a>
		       (smp_auth_cb && smp_auth_cb->oob_data_request)) && sc_supported;
   332a2:	6924      	ldr	r4, [r4, #16]
   332a4:	b10c      	cbz	r4, 332aa <sec_level_reachable+0x5a>
   332a6:	4b02      	ldr	r3, [pc, #8]	; (332b0 <sec_level_reachable+0x60>)
   332a8:	781c      	ldrb	r4, [r3, #0]
   332aa:	f004 0001 	and.w	r0, r4, #1
   332ae:	e7df      	b.n	33270 <sec_level_reachable+0x20>
   332b0:	20006ba8 	.word	0x20006ba8

000332b4 <smp_g2>:
{
   332b4:	b5f0      	push	{r4, r5, r6, r7, lr}
   332b6:	b099      	sub	sp, #100	; 0x64
   332b8:	4614      	mov	r4, r2
   332ba:	460f      	mov	r7, r1
	sys_memcpy_swap(m, u, 32);
   332bc:	2220      	movs	r2, #32
   332be:	4601      	mov	r1, r0
   332c0:	a804      	add	r0, sp, #16
{
   332c2:	461e      	mov	r6, r3
   332c4:	9d1e      	ldr	r5, [sp, #120]	; 0x78
	sys_memcpy_swap(m, u, 32);
   332c6:	f01a fdc2 	bl	4de4e <sys_memcpy_swap>
	sys_memcpy_swap(m + 32, v, 32);
   332ca:	2220      	movs	r2, #32
   332cc:	4639      	mov	r1, r7
   332ce:	a80c      	add	r0, sp, #48	; 0x30
   332d0:	f01a fdbd 	bl	4de4e <sys_memcpy_swap>
	sys_memcpy_swap(m + 64, y, 16);
   332d4:	2210      	movs	r2, #16
   332d6:	4631      	mov	r1, r6
   332d8:	a814      	add	r0, sp, #80	; 0x50
   332da:	f01a fdb8 	bl	4de4e <sys_memcpy_swap>
	sys_memcpy_swap(xs, x, 16);
   332de:	4621      	mov	r1, r4
   332e0:	2210      	movs	r2, #16
   332e2:	4668      	mov	r0, sp
   332e4:	f01a fdb3 	bl	4de4e <sys_memcpy_swap>
	err = bt_smp_aes_cmac(xs, m, sizeof(m), xs);
   332e8:	466b      	mov	r3, sp
   332ea:	2250      	movs	r2, #80	; 0x50
   332ec:	a904      	add	r1, sp, #16
   332ee:	4618      	mov	r0, r3
   332f0:	f01a fe6f 	bl	4dfd2 <bt_smp_aes_cmac>
	if (err) {
   332f4:	4604      	mov	r4, r0
   332f6:	b960      	cbnz	r0, 33312 <smp_g2+0x5e>
	memcpy(passkey, xs + 12, 4);
   332f8:	2204      	movs	r2, #4
   332fa:	a903      	add	r1, sp, #12
   332fc:	4628      	mov	r0, r5
   332fe:	f017 fdbc 	bl	4ae7a <memcpy>
	*passkey = sys_be32_to_cpu(*passkey) % 1000000;
   33302:	682b      	ldr	r3, [r5, #0]
   33304:	4a04      	ldr	r2, [pc, #16]	; (33318 <smp_g2+0x64>)
   33306:	ba1b      	rev	r3, r3
   33308:	fbb3 f1f2 	udiv	r1, r3, r2
   3330c:	fb02 3311 	mls	r3, r2, r1, r3
   33310:	602b      	str	r3, [r5, #0]
}
   33312:	4620      	mov	r0, r4
   33314:	b019      	add	sp, #100	; 0x64
   33316:	bdf0      	pop	{r4, r5, r6, r7, pc}
   33318:	000f4240 	.word	0x000f4240

0003331c <smp_f5>:
{
   3331c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   33320:	b09a      	sub	sp, #104	; 0x68
   33322:	461d      	mov	r5, r3
   33324:	e9dd 9723 	ldrd	r9, r7, [sp, #140]	; 0x8c
	uint8_t m[53] = { 0x00, /* counter */
   33328:	4b2e      	ldr	r3, [pc, #184]	; (333e4 <smp_f5+0xc8>)
{
   3332a:	4616      	mov	r6, r2
	uint8_t m[53] = { 0x00, /* counter */
   3332c:	aa0c      	add	r2, sp, #48	; 0x30
{
   3332e:	4684      	mov	ip, r0
   33330:	468a      	mov	sl, r1
	uint8_t m[53] = { 0x00, /* counter */
   33332:	f103 0e30 	add.w	lr, r3, #48	; 0x30
   33336:	4690      	mov	r8, r2
   33338:	6818      	ldr	r0, [r3, #0]
   3333a:	6859      	ldr	r1, [r3, #4]
   3333c:	4614      	mov	r4, r2
   3333e:	c403      	stmia	r4!, {r0, r1}
   33340:	3308      	adds	r3, #8
   33342:	4573      	cmp	r3, lr
   33344:	4622      	mov	r2, r4
   33346:	d1f7      	bne.n	33338 <smp_f5+0x1c>
   33348:	6818      	ldr	r0, [r3, #0]
   3334a:	791b      	ldrb	r3, [r3, #4]
   3334c:	6020      	str	r0, [r4, #0]
   3334e:	7123      	strb	r3, [r4, #4]
	sys_memcpy_swap(ws, w, 32);
   33350:	4661      	mov	r1, ip
   33352:	2220      	movs	r2, #32
   33354:	a804      	add	r0, sp, #16
   33356:	f01a fd7a 	bl	4de4e <sys_memcpy_swap>
	err = bt_smp_aes_cmac(salt, ws, 32, t);
   3335a:	4823      	ldr	r0, [pc, #140]	; (333e8 <smp_f5+0xcc>)
   3335c:	466b      	mov	r3, sp
   3335e:	2220      	movs	r2, #32
   33360:	a904      	add	r1, sp, #16
   33362:	f01a fe36 	bl	4dfd2 <bt_smp_aes_cmac>
	if (err) {
   33366:	4604      	mov	r4, r0
   33368:	bbc0      	cbnz	r0, 333dc <smp_f5+0xc0>
	sys_memcpy_swap(m + 5, n1, 16);
   3336a:	2210      	movs	r2, #16
   3336c:	4651      	mov	r1, sl
   3336e:	f10d 0035 	add.w	r0, sp, #53	; 0x35
   33372:	f01a fd6c 	bl	4de4e <sys_memcpy_swap>
	sys_memcpy_swap(m + 21, n2, 16);
   33376:	2210      	movs	r2, #16
   33378:	4631      	mov	r1, r6
   3337a:	f10d 0045 	add.w	r0, sp, #69	; 0x45
   3337e:	f01a fd66 	bl	4de4e <sys_memcpy_swap>
	m[37] = a1->type;
   33382:	4629      	mov	r1, r5
	sys_memcpy_swap(m + 38, a1->a.val, 6);
   33384:	2206      	movs	r2, #6
	m[37] = a1->type;
   33386:	f811 3b01 	ldrb.w	r3, [r1], #1
   3338a:	f88d 3055 	strb.w	r3, [sp, #85]	; 0x55
	sys_memcpy_swap(m + 38, a1->a.val, 6);
   3338e:	f10d 0056 	add.w	r0, sp, #86	; 0x56
   33392:	f01a fd5c 	bl	4de4e <sys_memcpy_swap>
	m[44] = a2->type;
   33396:	9922      	ldr	r1, [sp, #136]	; 0x88
	sys_memcpy_swap(m + 45, a2->a.val, 6);
   33398:	2206      	movs	r2, #6
	m[44] = a2->type;
   3339a:	f811 3b01 	ldrb.w	r3, [r1], #1
   3339e:	f88d 305c 	strb.w	r3, [sp, #92]	; 0x5c
	sys_memcpy_swap(m + 45, a2->a.val, 6);
   333a2:	f10d 005d 	add.w	r0, sp, #93	; 0x5d
   333a6:	f01a fd52 	bl	4de4e <sys_memcpy_swap>
	err = bt_smp_aes_cmac(t, m, sizeof(m), mackey);
   333aa:	464b      	mov	r3, r9
   333ac:	2235      	movs	r2, #53	; 0x35
   333ae:	4641      	mov	r1, r8
   333b0:	4668      	mov	r0, sp
   333b2:	f01a fe0e 	bl	4dfd2 <bt_smp_aes_cmac>
	if (err) {
   333b6:	4604      	mov	r4, r0
   333b8:	b980      	cbnz	r0, 333dc <smp_f5+0xc0>
	sys_mem_swap(mackey, 16);
   333ba:	4648      	mov	r0, r9
   333bc:	f01a fe45 	bl	4e04a <sys_mem_swap.constprop.0>
	m[0] = 0x01;
   333c0:	2301      	movs	r3, #1
   333c2:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
	err = bt_smp_aes_cmac(t, m, sizeof(m), ltk);
   333c6:	2235      	movs	r2, #53	; 0x35
   333c8:	463b      	mov	r3, r7
   333ca:	4641      	mov	r1, r8
   333cc:	4668      	mov	r0, sp
   333ce:	f01a fe00 	bl	4dfd2 <bt_smp_aes_cmac>
	if (err) {
   333d2:	4604      	mov	r4, r0
   333d4:	b910      	cbnz	r0, 333dc <smp_f5+0xc0>
	sys_mem_swap(ltk, 16);
   333d6:	4638      	mov	r0, r7
   333d8:	f01a fe37 	bl	4e04a <sys_mem_swap.constprop.0>
}
   333dc:	4620      	mov	r0, r4
   333de:	b01a      	add	sp, #104	; 0x68
   333e0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   333e4:	00050de6 	.word	0x00050de6
   333e8:	000537bc 	.word	0x000537bc

000333ec <sc_smp_check_confirm>:
{
   333ec:	b530      	push	{r4, r5, lr}
	switch (smp->method) {
   333ee:	7a03      	ldrb	r3, [r0, #8]
{
   333f0:	b087      	sub	sp, #28
   333f2:	4604      	mov	r4, r0
	switch (smp->method) {
   333f4:	2b05      	cmp	r3, #5
   333f6:	d818      	bhi.n	3342a <sc_smp_check_confirm+0x3e>
   333f8:	e8df f003 	tbb	[pc, r3]
   333fc:	1a03031a 	.word	0x1a03031a
   33400:	2717      	.short	0x2717
		r = (smp->passkey >> smp->passkey_round) & 0x01;
   33402:	f890 20dc 	ldrb.w	r2, [r0, #220]	; 0xdc
   33406:	f8d0 30d8 	ldr.w	r3, [r0, #216]	; 0xd8
   3340a:	40d3      	lsrs	r3, r2
   3340c:	f003 0301 	and.w	r3, r3, #1
		r |= 0x80;
   33410:	f043 0380 	orr.w	r3, r3, #128	; 0x80
	if (smp_f4(smp->pkey, sc_public_key, smp->rrnd, r, cfm)) {
   33414:	490e      	ldr	r1, [pc, #56]	; (33450 <sc_smp_check_confirm+0x64>)
   33416:	ad02      	add	r5, sp, #8
   33418:	9500      	str	r5, [sp, #0]
   3341a:	6809      	ldr	r1, [r1, #0]
   3341c:	f104 0237 	add.w	r2, r4, #55	; 0x37
   33420:	f104 0057 	add.w	r0, r4, #87	; 0x57
   33424:	f01a fe6b 	bl	4e0fe <smp_f4>
   33428:	b120      	cbz	r0, 33434 <sc_smp_check_confirm+0x48>
		return BT_SMP_ERR_UNSPECIFIED;
   3342a:	2008      	movs	r0, #8
}
   3342c:	b007      	add	sp, #28
   3342e:	bd30      	pop	{r4, r5, pc}
	switch (smp->method) {
   33430:	2300      	movs	r3, #0
   33432:	e7ef      	b.n	33414 <sc_smp_check_confirm+0x28>
	if (memcmp(smp->pcnf, cfm, 16)) {
   33434:	2210      	movs	r2, #16
   33436:	4629      	mov	r1, r5
   33438:	f104 0017 	add.w	r0, r4, #23
   3343c:	f017 fd0d 	bl	4ae5a <memcmp>
   33440:	3800      	subs	r0, #0
   33442:	bf18      	it	ne
   33444:	2001      	movne	r0, #1
   33446:	0080      	lsls	r0, r0, #2
   33448:	e7f0      	b.n	3342c <sc_smp_check_confirm+0x40>
	switch (smp->method) {
   3344a:	2000      	movs	r0, #0
   3344c:	e7ee      	b.n	3342c <sc_smp_check_confirm+0x40>
   3344e:	bf00      	nop
   33450:	200041d4 	.word	0x200041d4

00033454 <display_passkey>:
{
   33454:	b570      	push	{r4, r5, r6, lr}
   33456:	4604      	mov	r4, r0
	struct bt_conn *conn = smp->chan.chan.conn;
   33458:	f8d0 60ec 	ldr.w	r6, [r0, #236]	; 0xec
	const struct bt_conn_auth_cb *smp_auth_cb = latch_auth_cb(smp);
   3345c:	f7ff fe74 	bl	33148 <latch_auth_cb>
		if (bt_rand(&smp->passkey, sizeof(smp->passkey))) {
   33460:	2104      	movs	r1, #4
	const struct bt_conn_auth_cb *smp_auth_cb = latch_auth_cb(smp);
   33462:	4605      	mov	r5, r0
		if (bt_rand(&smp->passkey, sizeof(smp->passkey))) {
   33464:	f104 00d8 	add.w	r0, r4, #216	; 0xd8
   33468:	f003 ffac 	bl	373c4 <bt_rand>
   3346c:	b9c0      	cbnz	r0, 334a0 <display_passkey+0x4c>
		smp->passkey %= 1000000;
   3346e:	f8d4 30d8 	ldr.w	r3, [r4, #216]	; 0xd8
   33472:	4a0c      	ldr	r2, [pc, #48]	; (334a4 <display_passkey+0x50>)
   33474:	fbb3 f1f2 	udiv	r1, r3, r2
   33478:	fb02 3311 	mls	r3, r2, r1, r3
   3347c:	f8c4 30d8 	str.w	r3, [r4, #216]	; 0xd8
	smp->passkey_round = 0U;
   33480:	f884 00dc 	strb.w	r0, [r4, #220]	; 0xdc
	if (smp_auth_cb && smp_auth_cb->passkey_display) {
   33484:	b155      	cbz	r5, 3349c <display_passkey+0x48>
   33486:	686b      	ldr	r3, [r5, #4]
   33488:	b143      	cbz	r3, 3349c <display_passkey+0x48>
		atomic_set_bit(smp->flags, SMP_FLAG_DISPLAY);
   3348a:	210b      	movs	r1, #11
   3348c:	1d20      	adds	r0, r4, #4
   3348e:	f01a fe5b 	bl	4e148 <atomic_set_bit>
		smp_auth_cb->passkey_display(conn, smp->passkey);
   33492:	686b      	ldr	r3, [r5, #4]
   33494:	f8d4 10d8 	ldr.w	r1, [r4, #216]	; 0xd8
   33498:	4630      	mov	r0, r6
   3349a:	4798      	blx	r3
	return 0;
   3349c:	2000      	movs	r0, #0
}
   3349e:	bd70      	pop	{r4, r5, r6, pc}
			return BT_SMP_ERR_UNSPECIFIED;
   334a0:	2008      	movs	r0, #8
   334a2:	e7fc      	b.n	3349e <display_passkey+0x4a>
   334a4:	000f4240 	.word	0x000f4240

000334a8 <smp_init>:
{
   334a8:	b538      	push	{r3, r4, r5, lr}
	(void)memset(smp, 0, offsetof(struct bt_smp, chan));
   334aa:	22ec      	movs	r2, #236	; 0xec
{
   334ac:	4605      	mov	r5, r0
	(void)memset(smp, 0, offsetof(struct bt_smp, chan));
   334ae:	2100      	movs	r1, #0
   334b0:	f017 fcee 	bl	4ae90 <memset>
	if (bt_rand(smp->prnd, 16)) {
   334b4:	2110      	movs	r1, #16
   334b6:	f105 0027 	add.w	r0, r5, #39	; 0x27
   334ba:	f003 ff83 	bl	373c4 <bt_rand>
   334be:	4604      	mov	r4, r0
   334c0:	b948      	cbnz	r0, 334d6 <smp_init+0x2e>
	atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_PAIRING_FAIL);
   334c2:	2105      	movs	r1, #5
   334c4:	4628      	mov	r0, r5
   334c6:	f01a fe3f 	bl	4e148 <atomic_set_bit>
	sc_public_key = bt_pub_key_get();
   334ca:	f7fc f9fd 	bl	2f8c8 <bt_pub_key_get>
   334ce:	4b03      	ldr	r3, [pc, #12]	; (334dc <smp_init+0x34>)
   334d0:	6018      	str	r0, [r3, #0]
}
   334d2:	4620      	mov	r0, r4
   334d4:	bd38      	pop	{r3, r4, r5, pc}
		return BT_SMP_ERR_UNSPECIFIED;
   334d6:	2408      	movs	r4, #8
   334d8:	e7fb      	b.n	334d2 <smp_init+0x2a>
   334da:	bf00      	nop
   334dc:	200041d4 	.word	0x200041d4

000334e0 <smp_dhkey_generate>:
{
   334e0:	b538      	push	{r3, r4, r5, lr}
	atomic_set_bit(smp->flags, SMP_FLAG_DHKEY_GEN);
   334e2:	1d05      	adds	r5, r0, #4
{
   334e4:	4604      	mov	r4, r0
	atomic_set_bit(smp->flags, SMP_FLAG_DHKEY_GEN);
   334e6:	2108      	movs	r1, #8
   334e8:	4628      	mov	r0, r5
   334ea:	f01a fe2d 	bl	4e148 <atomic_set_bit>
	err = bt_dh_key_gen(smp->pkey, bt_smp_dhkey_ready);
   334ee:	4906      	ldr	r1, [pc, #24]	; (33508 <smp_dhkey_generate+0x28>)
   334f0:	f104 0057 	add.w	r0, r4, #87	; 0x57
   334f4:	f7fc f9f8 	bl	2f8e8 <bt_dh_key_gen>
	if (err) {
   334f8:	b120      	cbz	r0, 33504 <smp_dhkey_generate+0x24>
		atomic_clear_bit(smp->flags, SMP_FLAG_DHKEY_GEN);
   334fa:	4628      	mov	r0, r5
   334fc:	2108      	movs	r1, #8
   334fe:	f01a fd59 	bl	4dfb4 <atomic_clear_bit>
		return BT_SMP_ERR_UNSPECIFIED;
   33502:	2008      	movs	r0, #8
}
   33504:	bd38      	pop	{r3, r4, r5, pc}
   33506:	bf00      	nop
   33508:	0004e8cd 	.word	0x0004e8cd

0003350c <smp_send_pairing_req>:
{
   3350c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   33510:	4605      	mov	r5, r0
	smp = smp_chan_get(conn);
   33512:	f01a fcc3 	bl	4de9c <smp_chan_get>
	if (!smp) {
   33516:	4604      	mov	r4, r0
   33518:	2800      	cmp	r0, #0
   3351a:	d072      	beq.n	33602 <smp_send_pairing_req+0xf6>
	if (atomic_test_bit(smp->flags, SMP_FLAG_TIMEOUT)) {
   3351c:	1d06      	adds	r6, r0, #4
   3351e:	2104      	movs	r1, #4
   33520:	4630      	mov	r0, r6
   33522:	f01a fcc2 	bl	4deaa <atomic_test_bit>
   33526:	2800      	cmp	r0, #0
   33528:	d16e      	bne.n	33608 <smp_send_pairing_req+0xfc>
	if (atomic_test_bit(smp->flags, SMP_FLAG_KEYS_DISTR)) {
   3352a:	2102      	movs	r1, #2
   3352c:	4630      	mov	r0, r6
   3352e:	f01a fcbc 	bl	4deaa <atomic_test_bit>
   33532:	2800      	cmp	r0, #0
   33534:	d163      	bne.n	335fe <smp_send_pairing_req+0xf2>
	if (atomic_test_bit(smp->flags, SMP_FLAG_PAIRING)) {
   33536:	2103      	movs	r1, #3
   33538:	4630      	mov	r0, r6
   3353a:	f01a fcb6 	bl	4deaa <atomic_test_bit>
   3353e:	b118      	cbz	r0, 33548 <smp_send_pairing_req+0x3c>
		return -EBUSY;
   33540:	f06f 000f 	mvn.w	r0, #15
}
   33544:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (atomic_test_bit(smp->flags, SMP_FLAG_ENC_PENDING)) {
   33548:	2101      	movs	r1, #1
   3354a:	4630      	mov	r0, r6
   3354c:	f01a fcad 	bl	4deaa <atomic_test_bit>
   33550:	2800      	cmp	r0, #0
   33552:	d1f5      	bne.n	33540 <smp_send_pairing_req+0x34>
	if (!sec_level_reachable(smp)) {
   33554:	4620      	mov	r0, r4
   33556:	f7ff fe7b 	bl	33250 <sec_level_reachable>
   3355a:	2800      	cmp	r0, #0
   3355c:	d057      	beq.n	3360e <smp_send_pairing_req+0x102>
	if (!conn->le.keys) {
   3355e:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
   33562:	b133      	cbz	r3, 33572 <smp_send_pairing_req+0x66>
	if (smp_init(smp)) {
   33564:	4620      	mov	r0, r4
   33566:	f7ff ff9f 	bl	334a8 <smp_init>
   3356a:	b170      	cbz	r0, 3358a <smp_send_pairing_req+0x7e>
		return -ENOBUFS;
   3356c:	f06f 0068 	mvn.w	r0, #104	; 0x68
   33570:	e7e8      	b.n	33544 <smp_send_pairing_req+0x38>
		conn->le.keys = bt_keys_get_addr(conn->id, &conn->le.dst);
   33572:	7a28      	ldrb	r0, [r5, #8]
   33574:	f105 0188 	add.w	r1, r5, #136	; 0x88
   33578:	f000 fe10 	bl	3419c <bt_keys_get_addr>
   3357c:	f8c5 00b4 	str.w	r0, [r5, #180]	; 0xb4
		if (!conn->le.keys) {
   33580:	2800      	cmp	r0, #0
   33582:	d1ef      	bne.n	33564 <smp_send_pairing_req+0x58>
			return -ENOMEM;
   33584:	f06f 000b 	mvn.w	r0, #11
   33588:	e7dc      	b.n	33544 <smp_send_pairing_req+0x38>
	req_buf = smp_create_pdu(smp, BT_SMP_CMD_PAIRING_REQ, sizeof(*req));
   3358a:	2101      	movs	r1, #1
   3358c:	4620      	mov	r0, r4
   3358e:	f01a fe1f 	bl	4e1d0 <smp_create_pdu.constprop.0>
	if (!req_buf) {
   33592:	4607      	mov	r7, r0
   33594:	2800      	cmp	r0, #0
   33596:	d0e9      	beq.n	3356c <smp_send_pairing_req+0x60>
   33598:	2106      	movs	r1, #6
   3359a:	3008      	adds	r0, #8
   3359c:	f01b fc0a 	bl	4edb4 <net_buf_simple_add>
	req->auth_req = get_auth(smp, BT_SMP_AUTH_DEFAULT);
   335a0:	2109      	movs	r1, #9
   335a2:	4605      	mov	r5, r0
   335a4:	4620      	mov	r0, r4
   335a6:	f7ff fe13 	bl	331d0 <get_auth>
   335aa:	70a8      	strb	r0, [r5, #2]
	req->io_capability = get_io_capa(smp);
   335ac:	4620      	mov	r0, r4
   335ae:	f7ff fde9 	bl	33184 <get_io_capa>
	req->oob_flag = oobd_present ? BT_SMP_OOB_PRESENT :
   335b2:	4b18      	ldr	r3, [pc, #96]	; (33614 <smp_send_pairing_req+0x108>)
	req->io_capability = get_io_capa(smp);
   335b4:	7028      	strb	r0, [r5, #0]
	req->oob_flag = oobd_present ? BT_SMP_OOB_PRESENT :
   335b6:	781b      	ldrb	r3, [r3, #0]
   335b8:	706b      	strb	r3, [r5, #1]
	req->max_key_size = BT_SMP_MAX_ENC_KEY_SIZE;
   335ba:	2310      	movs	r3, #16
   335bc:	70eb      	strb	r3, [r5, #3]
	req->resp_key_dist = RECV_KEYS;
   335be:	f04f 0803 	mov.w	r8, #3
	req->init_key_dist = SEND_KEYS;
   335c2:	2301      	movs	r3, #1
	smp->local_dist = SEND_KEYS;
   335c4:	f240 3201 	movw	r2, #769	; 0x301
	req->init_key_dist = SEND_KEYS;
   335c8:	712b      	strb	r3, [r5, #4]
	req->resp_key_dist = RECV_KEYS;
   335ca:	f885 8005 	strb.w	r8, [r5, #5]
	memcpy(smp->preq + 1, req, sizeof(*req));
   335ce:	4629      	mov	r1, r5
	smp->preq[0] = BT_SMP_CMD_PAIRING_REQ;
   335d0:	7263      	strb	r3, [r4, #9]
	smp->local_dist = SEND_KEYS;
   335d2:	f8a4 20e8 	strh.w	r2, [r4, #232]	; 0xe8
	memcpy(smp->preq + 1, req, sizeof(*req));
   335d6:	f104 000a 	add.w	r0, r4, #10
   335da:	2206      	movs	r2, #6
   335dc:	f017 fc4d 	bl	4ae7a <memcpy>
	smp_send(smp, req_buf, NULL, NULL);
   335e0:	4639      	mov	r1, r7
   335e2:	4620      	mov	r0, r4
   335e4:	f01a fd15 	bl	4e012 <smp_send.constprop.0>
	atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_PAIRING_RSP);
   335e8:	4620      	mov	r0, r4
   335ea:	2102      	movs	r1, #2
   335ec:	f01a fdac 	bl	4e148 <atomic_set_bit>
	atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_SECURITY_REQUEST);
   335f0:	210b      	movs	r1, #11
   335f2:	f01a fda9 	bl	4e148 <atomic_set_bit>
	atomic_set_bit(smp->flags, SMP_FLAG_PAIRING);
   335f6:	4641      	mov	r1, r8
   335f8:	4630      	mov	r0, r6
   335fa:	f01a fda5 	bl	4e148 <atomic_set_bit>
		return 0;
   335fe:	2000      	movs	r0, #0
   33600:	e7a0      	b.n	33544 <smp_send_pairing_req+0x38>
		return -ENOTCONN;
   33602:	f06f 007f 	mvn.w	r0, #127	; 0x7f
   33606:	e79d      	b.n	33544 <smp_send_pairing_req+0x38>
		return -EIO;
   33608:	f06f 0004 	mvn.w	r0, #4
   3360c:	e79a      	b.n	33544 <smp_send_pairing_req+0x38>
		return -EINVAL;
   3360e:	f06f 0015 	mvn.w	r0, #21
   33612:	e797      	b.n	33544 <smp_send_pairing_req+0x38>
   33614:	20006ba9 	.word	0x20006ba9

00033618 <smp_security_request>:
{
   33618:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	if (atomic_test_bit(smp->flags, SMP_FLAG_KEYS_DISTR)) {
   3361c:	1d05      	adds	r5, r0, #4
	struct bt_conn *conn = smp->chan.chan.conn;
   3361e:	f8d0 40ec 	ldr.w	r4, [r0, #236]	; 0xec
	struct bt_smp_security_request *req = (void *)buf->data;
   33622:	688b      	ldr	r3, [r1, #8]
{
   33624:	4606      	mov	r6, r0
	if (atomic_test_bit(smp->flags, SMP_FLAG_KEYS_DISTR)) {
   33626:	2102      	movs	r1, #2
   33628:	4628      	mov	r0, r5
   3362a:	f01a fc3e 	bl	4deaa <atomic_test_bit>
   3362e:	2800      	cmp	r0, #0
   33630:	d155      	bne.n	336de <smp_security_request+0xc6>
	if (atomic_test_bit(smp->flags, SMP_FLAG_PAIRING)) {
   33632:	2103      	movs	r1, #3
   33634:	4628      	mov	r0, r5
   33636:	f01a fc38 	bl	4deaa <atomic_test_bit>
   3363a:	2800      	cmp	r0, #0
   3363c:	d14f      	bne.n	336de <smp_security_request+0xc6>
	if (atomic_test_bit(smp->flags, SMP_FLAG_ENC_PENDING)) {
   3363e:	2101      	movs	r1, #1
   33640:	4628      	mov	r0, r5
   33642:	f01a fc32 	bl	4deaa <atomic_test_bit>
   33646:	2800      	cmp	r0, #0
   33648:	d149      	bne.n	336de <smp_security_request+0xc6>
	if (sc_supported) {
   3364a:	4a27      	ldr	r2, [pc, #156]	; (336e8 <smp_security_request+0xd0>)
   3364c:	7812      	ldrb	r2, [r2, #0]
   3364e:	2a00      	cmp	r2, #0
   33650:	d047      	beq.n	336e2 <smp_security_request+0xca>
		auth = req->auth_req & BT_SMP_AUTH_MASK_SC;
   33652:	781f      	ldrb	r7, [r3, #0]
	if (IS_ENABLED(CONFIG_BT_SMP_SC_PAIR_ONLY) &&
   33654:	073b      	lsls	r3, r7, #28
   33656:	d544      	bpl.n	336e2 <smp_security_request+0xca>
	if (conn->le.keys) {
   33658:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
   3365c:	b153      	cbz	r3, 33674 <smp_security_request+0x5c>
		if (!(conn->le.keys->keys & (BT_KEYS_LTK_P256 | BT_KEYS_LTK))) {
   3365e:	89db      	ldrh	r3, [r3, #14]
   33660:	f003 0324 	and.w	r3, r3, #36	; 0x24
   33664:	b9bb      	cbnz	r3, 33696 <smp_security_request+0x7e>
	if (smp_send_pairing_req(conn) < 0) {
   33666:	4620      	mov	r0, r4
   33668:	f7ff ff50 	bl	3350c <smp_send_pairing_req>
   3366c:	2800      	cmp	r0, #0
   3366e:	db2e      	blt.n	336ce <smp_security_request+0xb6>
	atomic_set_bit(smp->flags, SMP_FLAG_SEC_REQ);
   33670:	210f      	movs	r1, #15
   33672:	e031      	b.n	336d8 <smp_security_request+0xc0>
					     &conn->le.dst);
   33674:	f104 0888 	add.w	r8, r4, #136	; 0x88
		conn->le.keys = bt_keys_find(BT_KEYS_LTK_P256, conn->id,
   33678:	7a21      	ldrb	r1, [r4, #8]
   3367a:	4642      	mov	r2, r8
   3367c:	2020      	movs	r0, #32
   3367e:	f000 fe0d 	bl	3429c <bt_keys_find>
   33682:	f8c4 00b4 	str.w	r0, [r4, #180]	; 0xb4
		if (!conn->le.keys) {
   33686:	b930      	cbnz	r0, 33696 <smp_security_request+0x7e>
			conn->le.keys = bt_keys_find(BT_KEYS_LTK, conn->id,
   33688:	7a21      	ldrb	r1, [r4, #8]
   3368a:	4642      	mov	r2, r8
   3368c:	2004      	movs	r0, #4
   3368e:	f000 fe05 	bl	3429c <bt_keys_find>
   33692:	f8c4 00b4 	str.w	r0, [r4, #180]	; 0xb4
	if (!conn->le.keys) {
   33696:	f8d4 10b4 	ldr.w	r1, [r4, #180]	; 0xb4
   3369a:	2900      	cmp	r1, #0
   3369c:	d0e3      	beq.n	33666 <smp_security_request+0x4e>
	if ((auth & BT_SMP_AUTH_MITM) &&
   3369e:	0778      	lsls	r0, r7, #29
   336a0:	d506      	bpl.n	336b0 <smp_security_request+0x98>
   336a2:	7b4b      	ldrb	r3, [r1, #13]
   336a4:	07da      	lsls	r2, r3, #31
   336a6:	d403      	bmi.n	336b0 <smp_security_request+0x98>
		if (get_io_capa(smp) != BT_SMP_IO_NO_INPUT_OUTPUT) {
   336a8:	4630      	mov	r0, r6
   336aa:	f7ff fd6b 	bl	33184 <get_io_capa>
		goto pair;
   336ae:	e7da      	b.n	33666 <smp_security_request+0x4e>
	if ((auth & BT_SMP_AUTH_SC) &&
   336b0:	89cb      	ldrh	r3, [r1, #14]
   336b2:	069b      	lsls	r3, r3, #26
   336b4:	d5d7      	bpl.n	33666 <smp_security_request+0x4e>
	if (bt_conn_le_start_encryption(conn, conn->le.keys->ltk.rand,
   336b6:	7b0b      	ldrb	r3, [r1, #12]
   336b8:	9300      	str	r3, [sp, #0]
   336ba:	f101 0218 	add.w	r2, r1, #24
   336be:	f101 031a 	add.w	r3, r1, #26
   336c2:	4620      	mov	r0, r4
   336c4:	3110      	adds	r1, #16
   336c6:	f018 fbc2 	bl	4be4e <bt_conn_le_start_encryption>
   336ca:	2800      	cmp	r0, #0
   336cc:	da03      	bge.n	336d6 <smp_security_request+0xbe>
		return BT_SMP_ERR_UNSPECIFIED;
   336ce:	2008      	movs	r0, #8
}
   336d0:	b002      	add	sp, #8
   336d2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	atomic_set_bit(smp->flags, SMP_FLAG_ENC_PENDING);
   336d6:	2101      	movs	r1, #1
	atomic_set_bit(smp->flags, SMP_FLAG_SEC_REQ);
   336d8:	4628      	mov	r0, r5
   336da:	f01a fd35 	bl	4e148 <atomic_set_bit>
		return 0;
   336de:	2000      	movs	r0, #0
   336e0:	e7f6      	b.n	336d0 <smp_security_request+0xb8>
		return BT_SMP_ERR_AUTH_REQUIREMENTS;
   336e2:	2003      	movs	r0, #3
   336e4:	e7f4      	b.n	336d0 <smp_security_request+0xb8>
   336e6:	bf00      	nop
   336e8:	20006ba8 	.word	0x20006ba8

000336ec <sc_send_public_key>:
{
   336ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	req_buf = smp_create_pdu(smp, BT_SMP_CMD_PUBLIC_KEY, sizeof(*req));
   336ee:	210c      	movs	r1, #12
{
   336f0:	4605      	mov	r5, r0
	req_buf = smp_create_pdu(smp, BT_SMP_CMD_PUBLIC_KEY, sizeof(*req));
   336f2:	f01a fd6d 	bl	4e1d0 <smp_create_pdu.constprop.0>
	if (!req_buf) {
   336f6:	4604      	mov	r4, r0
   336f8:	b1a8      	cbz	r0, 33726 <sc_send_public_key+0x3a>
   336fa:	2140      	movs	r1, #64	; 0x40
   336fc:	3008      	adds	r0, #8
   336fe:	f01b fb59 	bl	4edb4 <net_buf_simple_add>
	memcpy(req->x, sc_public_key, sizeof(req->x));
   33702:	4f0a      	ldr	r7, [pc, #40]	; (3372c <sc_send_public_key+0x40>)
   33704:	2220      	movs	r2, #32
   33706:	6839      	ldr	r1, [r7, #0]
   33708:	4606      	mov	r6, r0
   3370a:	f017 fbb6 	bl	4ae7a <memcpy>
	memcpy(req->y, &sc_public_key[32], sizeof(req->y));
   3370e:	6839      	ldr	r1, [r7, #0]
   33710:	2220      	movs	r2, #32
   33712:	4411      	add	r1, r2
   33714:	18b0      	adds	r0, r6, r2
   33716:	f017 fbb0 	bl	4ae7a <memcpy>
	smp_send(smp, req_buf, NULL, NULL);
   3371a:	4628      	mov	r0, r5
   3371c:	4621      	mov	r1, r4
   3371e:	f01a fc78 	bl	4e012 <smp_send.constprop.0>
	return 0;
   33722:	2000      	movs	r0, #0
}
   33724:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return BT_SMP_ERR_UNSPECIFIED;
   33726:	2008      	movs	r0, #8
   33728:	e7fc      	b.n	33724 <sc_send_public_key+0x38>
   3372a:	bf00      	nop
   3372c:	200041d4 	.word	0x200041d4

00033730 <smp_send_pairing_confirm>:
{
   33730:	b573      	push	{r0, r1, r4, r5, r6, lr}
	switch (smp->method) {
   33732:	7a04      	ldrb	r4, [r0, #8]
   33734:	2c02      	cmp	r4, #2
{
   33736:	4605      	mov	r5, r0
	switch (smp->method) {
   33738:	d823      	bhi.n	33782 <smp_send_pairing_confirm+0x52>
   3373a:	b144      	cbz	r4, 3374e <smp_send_pairing_confirm+0x1e>
		r = (smp->passkey >> smp->passkey_round) & 0x01;
   3373c:	f890 30dc 	ldrb.w	r3, [r0, #220]	; 0xdc
   33740:	f8d0 40d8 	ldr.w	r4, [r0, #216]	; 0xd8
   33744:	40dc      	lsrs	r4, r3
   33746:	f004 0401 	and.w	r4, r4, #1
		r |= 0x80;
   3374a:	f044 0480 	orr.w	r4, r4, #128	; 0x80
	buf = smp_create_pdu(smp, BT_SMP_CMD_PAIRING_CONFIRM, sizeof(*req));
   3374e:	2103      	movs	r1, #3
   33750:	4628      	mov	r0, r5
   33752:	f01a fd3d 	bl	4e1d0 <smp_create_pdu.constprop.0>
	if (!buf) {
   33756:	4606      	mov	r6, r0
   33758:	b1a8      	cbz	r0, 33786 <smp_send_pairing_confirm+0x56>
   3375a:	2110      	movs	r1, #16
   3375c:	3008      	adds	r0, #8
   3375e:	f01b fb29 	bl	4edb4 <net_buf_simple_add>
	if (smp_f4(sc_public_key, smp->pkey, smp->prnd, r, req->val)) {
   33762:	9000      	str	r0, [sp, #0]
   33764:	480f      	ldr	r0, [pc, #60]	; (337a4 <smp_send_pairing_confirm+0x74>)
   33766:	4623      	mov	r3, r4
   33768:	6800      	ldr	r0, [r0, #0]
   3376a:	f105 0227 	add.w	r2, r5, #39	; 0x27
   3376e:	f105 0157 	add.w	r1, r5, #87	; 0x57
   33772:	f01a fcc4 	bl	4e0fe <smp_f4>
   33776:	4604      	mov	r4, r0
   33778:	b150      	cbz	r0, 33790 <smp_send_pairing_confirm+0x60>
		net_buf_unref(buf);
   3377a:	4630      	mov	r0, r6
   3377c:	f00f f864 	bl	42848 <net_buf_unref>
		return BT_SMP_ERR_UNSPECIFIED;
   33780:	e001      	b.n	33786 <smp_send_pairing_confirm+0x56>
	switch (smp->method) {
   33782:	2c03      	cmp	r4, #3
   33784:	d002      	beq.n	3378c <smp_send_pairing_confirm+0x5c>
		return BT_SMP_ERR_UNSPECIFIED;
   33786:	2008      	movs	r0, #8
}
   33788:	b002      	add	sp, #8
   3378a:	bd70      	pop	{r4, r5, r6, pc}
	switch (smp->method) {
   3378c:	2400      	movs	r4, #0
   3378e:	e7de      	b.n	3374e <smp_send_pairing_confirm+0x1e>
	smp_send(smp, buf, NULL, NULL);
   33790:	4631      	mov	r1, r6
   33792:	4628      	mov	r0, r5
   33794:	f01a fc3d 	bl	4e012 <smp_send.constprop.0>
	atomic_clear_bit(smp->flags, SMP_FLAG_CFM_DELAYED);
   33798:	1d28      	adds	r0, r5, #4
   3379a:	4621      	mov	r1, r4
   3379c:	f01a fc0a 	bl	4dfb4 <atomic_clear_bit>
	return 0;
   337a0:	4620      	mov	r0, r4
   337a2:	e7f1      	b.n	33788 <smp_send_pairing_confirm+0x58>
   337a4:	200041d4 	.word	0x200041d4

000337a8 <smp_pairing_random>:
{
   337a8:	b5f0      	push	{r4, r5, r6, r7, lr}
   337aa:	b085      	sub	sp, #20
   337ac:	4604      	mov	r4, r0
   337ae:	460f      	mov	r7, r1
	const struct bt_conn_auth_cb *smp_auth_cb = latch_auth_cb(smp);
   337b0:	f7ff fcca 	bl	33148 <latch_auth_cb>
	memcpy(smp->rrnd, req->val, sizeof(smp->rrnd));
   337b4:	f104 0637 	add.w	r6, r4, #55	; 0x37
   337b8:	68b9      	ldr	r1, [r7, #8]
	const struct bt_conn_auth_cb *smp_auth_cb = latch_auth_cb(smp);
   337ba:	4605      	mov	r5, r0
	memcpy(smp->rrnd, req->val, sizeof(smp->rrnd));
   337bc:	2210      	movs	r2, #16
   337be:	4630      	mov	r0, r6
   337c0:	f017 fb5b 	bl	4ae7a <memcpy>
	if (smp->chan.chan.conn->role == BT_HCI_ROLE_CENTRAL) {
   337c4:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
   337c8:	78db      	ldrb	r3, [r3, #3]
   337ca:	2b00      	cmp	r3, #0
   337cc:	d152      	bne.n	33874 <smp_pairing_random+0xcc>
		err = sc_smp_check_confirm(smp);
   337ce:	4620      	mov	r0, r4
   337d0:	f7ff fe0c 	bl	333ec <sc_smp_check_confirm>
		if (err) {
   337d4:	b940      	cbnz	r0, 337e8 <smp_pairing_random+0x40>
		switch (smp->method) {
   337d6:	7a23      	ldrb	r3, [r4, #8]
   337d8:	2b05      	cmp	r3, #5
   337da:	d804      	bhi.n	337e6 <smp_pairing_random+0x3e>
   337dc:	e8df f003 	tbb	[pc, r3]
   337e0:	06202038 	.word	0x06202038
   337e4:	3803      	.short	0x3803
				return BT_SMP_ERR_UNSPECIFIED;
   337e6:	2008      	movs	r0, #8
}
   337e8:	b005      	add	sp, #20
   337ea:	bdf0      	pop	{r4, r5, r6, r7, pc}
			if (smp_g2(sc_public_key, smp->pkey, smp->prnd,
   337ec:	ab03      	add	r3, sp, #12
   337ee:	485f      	ldr	r0, [pc, #380]	; (3396c <smp_pairing_random+0x1c4>)
   337f0:	9300      	str	r3, [sp, #0]
   337f2:	6800      	ldr	r0, [r0, #0]
   337f4:	4633      	mov	r3, r6
   337f6:	f104 0227 	add.w	r2, r4, #39	; 0x27
   337fa:	f104 0157 	add.w	r1, r4, #87	; 0x57
   337fe:	f7ff fd59 	bl	332b4 <smp_g2>
   33802:	2800      	cmp	r0, #0
   33804:	d1ef      	bne.n	337e6 <smp_pairing_random+0x3e>
			atomic_set_bit(smp->flags, SMP_FLAG_USER);
   33806:	210a      	movs	r1, #10
   33808:	1d20      	adds	r0, r4, #4
   3380a:	f01a fc9d 	bl	4e148 <atomic_set_bit>
			atomic_set_bit(smp->flags, SMP_FLAG_DHKEY_SEND);
   3380e:	2109      	movs	r1, #9
   33810:	f01a fc9a 	bl	4e148 <atomic_set_bit>
			smp_auth_cb->passkey_confirm(smp->chan.chan.conn, passkey);
   33814:	68eb      	ldr	r3, [r5, #12]
   33816:	9903      	ldr	r1, [sp, #12]
			smp_auth_cb->oob_data_request(smp->chan.chan.conn, &info);
   33818:	f8d4 00ec 	ldr.w	r0, [r4, #236]	; 0xec
   3381c:	4798      	blx	r3
			return 0;
   3381e:	e021      	b.n	33864 <smp_pairing_random+0xbc>
			smp->passkey_round++;
   33820:	f894 30dc 	ldrb.w	r3, [r4, #220]	; 0xdc
   33824:	3301      	adds	r3, #1
   33826:	b2db      	uxtb	r3, r3
			if (smp->passkey_round == 20U) {
   33828:	2b14      	cmp	r3, #20
			smp->passkey_round++;
   3382a:	f884 30dc 	strb.w	r3, [r4, #220]	; 0xdc
			if (smp->passkey_round == 20U) {
   3382e:	d00f      	beq.n	33850 <smp_pairing_random+0xa8>
			if (bt_rand(smp->prnd, 16)) {
   33830:	2110      	movs	r1, #16
   33832:	f104 0027 	add.w	r0, r4, #39	; 0x27
   33836:	f003 fdc5 	bl	373c4 <bt_rand>
   3383a:	2800      	cmp	r0, #0
   3383c:	d1d3      	bne.n	337e6 <smp_pairing_random+0x3e>
			atomic_set_bit(smp->allowed_cmds,
   3383e:	2103      	movs	r1, #3
   33840:	4620      	mov	r0, r4
   33842:	f01a fc81 	bl	4e148 <atomic_set_bit>
}
   33846:	b005      	add	sp, #20
   33848:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
			return smp_send_pairing_confirm(smp);
   3384c:	f7ff bf70 	b.w	33730 <smp_send_pairing_confirm>
		if (atomic_test_bit(smp->flags, SMP_FLAG_DHKEY_PENDING)) {
   33850:	1d23      	adds	r3, r4, #4
   33852:	2107      	movs	r1, #7
   33854:	4618      	mov	r0, r3
   33856:	f01a fb28 	bl	4deaa <atomic_test_bit>
   3385a:	b128      	cbz	r0, 33868 <smp_pairing_random+0xc0>
			atomic_set_bit(smp->flags, SMP_FLAG_DHKEY_SEND);
   3385c:	2109      	movs	r1, #9
   3385e:	4618      	mov	r0, r3
   33860:	f01a fc72 	bl	4e148 <atomic_set_bit>
			return 0;
   33864:	2000      	movs	r0, #0
   33866:	e7bf      	b.n	337e8 <smp_pairing_random+0x40>
		return compute_and_send_central_dhcheck(smp);
   33868:	4620      	mov	r0, r4
}
   3386a:	b005      	add	sp, #20
   3386c:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		return compute_and_send_central_dhcheck(smp);
   33870:	f01a bcfd 	b.w	4e26e <compute_and_send_central_dhcheck>
	switch (smp->method) {
   33874:	7a23      	ldrb	r3, [r4, #8]
   33876:	2b05      	cmp	r3, #5
   33878:	d8b5      	bhi.n	337e6 <smp_pairing_random+0x3e>
   3387a:	a201      	add	r2, pc, #4	; (adr r2, 33880 <smp_pairing_random+0xd8>)
   3387c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   33880:	000338c5 	.word	0x000338c5
   33884:	000338dd 	.word	0x000338dd
   33888:	000338dd 	.word	0x000338dd
   3388c:	00033899 	.word	0x00033899
   33890:	000337e7 	.word	0x000337e7
   33894:	0003392b 	.word	0x0003392b
		if (smp_g2(smp->pkey, sc_public_key, smp->rrnd, smp->prnd,
   33898:	ab03      	add	r3, sp, #12
   3389a:	4934      	ldr	r1, [pc, #208]	; (3396c <smp_pairing_random+0x1c4>)
   3389c:	9300      	str	r3, [sp, #0]
   3389e:	6809      	ldr	r1, [r1, #0]
   338a0:	f104 0327 	add.w	r3, r4, #39	; 0x27
   338a4:	4632      	mov	r2, r6
   338a6:	f104 0057 	add.w	r0, r4, #87	; 0x57
   338aa:	f7ff fd03 	bl	332b4 <smp_g2>
   338ae:	2800      	cmp	r0, #0
   338b0:	d199      	bne.n	337e6 <smp_pairing_random+0x3e>
		atomic_set_bit(smp->flags, SMP_FLAG_USER);
   338b2:	210a      	movs	r1, #10
   338b4:	1d20      	adds	r0, r4, #4
   338b6:	f01a fc47 	bl	4e148 <atomic_set_bit>
		smp_auth_cb->passkey_confirm(smp->chan.chan.conn, passkey);
   338ba:	68eb      	ldr	r3, [r5, #12]
   338bc:	9903      	ldr	r1, [sp, #12]
   338be:	f8d4 00ec 	ldr.w	r0, [r4, #236]	; 0xec
   338c2:	4798      	blx	r3
	atomic_set_bit(smp->allowed_cmds, BT_SMP_DHKEY_CHECK);
   338c4:	4620      	mov	r0, r4
   338c6:	210d      	movs	r1, #13
   338c8:	f01a fc3e 	bl	4e148 <atomic_set_bit>
	atomic_set_bit(smp->flags, SMP_FLAG_DHCHECK_WAIT);
   338cc:	1d20      	adds	r0, r4, #4
   338ce:	2110      	movs	r1, #16
   338d0:	f01a fc3a 	bl	4e148 <atomic_set_bit>
	return smp_send_pairing_random(smp);
   338d4:	4620      	mov	r0, r4
   338d6:	f01a fc9a 	bl	4e20e <smp_send_pairing_random>
   338da:	e785      	b.n	337e8 <smp_pairing_random+0x40>
		err = sc_smp_check_confirm(smp);
   338dc:	4620      	mov	r0, r4
   338de:	f7ff fd85 	bl	333ec <sc_smp_check_confirm>
		if (err) {
   338e2:	2800      	cmp	r0, #0
   338e4:	d180      	bne.n	337e8 <smp_pairing_random+0x40>
		atomic_set_bit(smp->allowed_cmds,
   338e6:	2103      	movs	r1, #3
   338e8:	4620      	mov	r0, r4
   338ea:	f01a fc2d 	bl	4e148 <atomic_set_bit>
		err = smp_send_pairing_random(smp);
   338ee:	f01a fc8e 	bl	4e20e <smp_send_pairing_random>
		if (err) {
   338f2:	2800      	cmp	r0, #0
   338f4:	f47f af78 	bne.w	337e8 <smp_pairing_random+0x40>
		smp->passkey_round++;
   338f8:	f894 30dc 	ldrb.w	r3, [r4, #220]	; 0xdc
   338fc:	3301      	adds	r3, #1
   338fe:	b2db      	uxtb	r3, r3
		if (smp->passkey_round == 20U) {
   33900:	2b14      	cmp	r3, #20
		smp->passkey_round++;
   33902:	f884 30dc 	strb.w	r3, [r4, #220]	; 0xdc
		if (smp->passkey_round == 20U) {
   33906:	d106      	bne.n	33916 <smp_pairing_random+0x16e>
			atomic_set_bit(smp->allowed_cmds, BT_SMP_DHKEY_CHECK);
   33908:	210d      	movs	r1, #13
   3390a:	4620      	mov	r0, r4
   3390c:	f01a fc1c 	bl	4e148 <atomic_set_bit>
			atomic_set_bit(smp->flags, SMP_FLAG_DHCHECK_WAIT);
   33910:	2110      	movs	r1, #16
   33912:	1d20      	adds	r0, r4, #4
   33914:	e7a4      	b.n	33860 <smp_pairing_random+0xb8>
		if (bt_rand(smp->prnd, 16)) {
   33916:	2110      	movs	r1, #16
   33918:	f104 0027 	add.w	r0, r4, #39	; 0x27
   3391c:	f003 fd52 	bl	373c4 <bt_rand>
   33920:	3800      	subs	r0, #0
   33922:	bf18      	it	ne
   33924:	2001      	movne	r0, #1
   33926:	00c0      	lsls	r0, r0, #3
   33928:	e75e      	b.n	337e8 <smp_pairing_random+0x40>
		if (bt_rand(smp->prnd, 16)) {
   3392a:	2110      	movs	r1, #16
   3392c:	f104 0027 	add.w	r0, r4, #39	; 0x27
   33930:	f003 fd48 	bl	373c4 <bt_rand>
   33934:	4606      	mov	r6, r0
   33936:	2800      	cmp	r0, #0
   33938:	f47f af55 	bne.w	337e6 <smp_pairing_random+0x3e>
		if (smp_auth_cb && smp_auth_cb->oob_data_request) {
   3393c:	b19d      	cbz	r5, 33966 <smp_pairing_random+0x1be>
   3393e:	692b      	ldr	r3, [r5, #16]
   33940:	b18b      	cbz	r3, 33966 <smp_pairing_random+0x1be>
			struct bt_conn_oob_info info = {
   33942:	4b0b      	ldr	r3, [pc, #44]	; (33970 <smp_pairing_random+0x1c8>)
			le_sc_oob_config_set(smp, &info);
   33944:	a903      	add	r1, sp, #12
			struct bt_conn_oob_info info = {
   33946:	f8b3 3035 	ldrh.w	r3, [r3, #53]	; 0x35
   3394a:	f8ad 300c 	strh.w	r3, [sp, #12]
			le_sc_oob_config_set(smp, &info);
   3394e:	4620      	mov	r0, r4
   33950:	f01a fa89 	bl	4de66 <le_sc_oob_config_set>
			atomic_set_bit(smp->flags, SMP_FLAG_OOB_PENDING);
   33954:	210c      	movs	r1, #12
			smp->oobd_remote = NULL;
   33956:	e9c4 6638 	strd	r6, r6, [r4, #224]	; 0xe0
			atomic_set_bit(smp->flags, SMP_FLAG_OOB_PENDING);
   3395a:	1d20      	adds	r0, r4, #4
   3395c:	f01a fbf4 	bl	4e148 <atomic_set_bit>
			smp_auth_cb->oob_data_request(smp->chan.chan.conn, &info);
   33960:	692b      	ldr	r3, [r5, #16]
   33962:	a903      	add	r1, sp, #12
   33964:	e758      	b.n	33818 <smp_pairing_random+0x70>
			return BT_SMP_ERR_OOB_NOT_AVAIL;
   33966:	2002      	movs	r0, #2
   33968:	e73e      	b.n	337e8 <smp_pairing_random+0x40>
   3396a:	bf00      	nop
   3396c:	200041d4 	.word	0x200041d4
   33970:	00050de6 	.word	0x00050de6

00033974 <smp_public_key_periph>:
{
   33974:	b570      	push	{r4, r5, r6, lr}
   33976:	4604      	mov	r4, r0
	const struct bt_conn_auth_cb *smp_auth_cb = latch_auth_cb(smp);
   33978:	f7ff fbe6 	bl	33148 <latch_auth_cb>
	if (!atomic_test_bit(smp->flags, SMP_FLAG_SC_DEBUG_KEY) &&
   3397c:	1d26      	adds	r6, r4, #4
	const struct bt_conn_auth_cb *smp_auth_cb = latch_auth_cb(smp);
   3397e:	4605      	mov	r5, r0
	if (!atomic_test_bit(smp->flags, SMP_FLAG_SC_DEBUG_KEY) &&
   33980:	210e      	movs	r1, #14
   33982:	4630      	mov	r0, r6
   33984:	f01a fa91 	bl	4deaa <atomic_test_bit>
   33988:	b120      	cbz	r0, 33994 <smp_public_key_periph+0x20>
	err = sc_send_public_key(smp);
   3398a:	4620      	mov	r0, r4
   3398c:	f7ff feae 	bl	336ec <sc_send_public_key>
	if (err) {
   33990:	b158      	cbz	r0, 339aa <smp_public_key_periph+0x36>
}
   33992:	bd70      	pop	{r4, r5, r6, pc}
	    memcmp(smp->pkey, sc_public_key, BT_PUB_KEY_COORD_LEN) == 0) {
   33994:	4b25      	ldr	r3, [pc, #148]	; (33a2c <smp_public_key_periph+0xb8>)
   33996:	2220      	movs	r2, #32
   33998:	6819      	ldr	r1, [r3, #0]
   3399a:	f104 0057 	add.w	r0, r4, #87	; 0x57
   3399e:	f017 fa5c 	bl	4ae5a <memcmp>
	if (!atomic_test_bit(smp->flags, SMP_FLAG_SC_DEBUG_KEY) &&
   339a2:	2800      	cmp	r0, #0
   339a4:	d1f1      	bne.n	3398a <smp_public_key_periph+0x16>
{
   339a6:	2008      	movs	r0, #8
   339a8:	e7f3      	b.n	33992 <smp_public_key_periph+0x1e>
	switch (smp->method) {
   339aa:	7a23      	ldrb	r3, [r4, #8]
   339ac:	2b05      	cmp	r3, #5
   339ae:	d8fa      	bhi.n	339a6 <smp_public_key_periph+0x32>
   339b0:	a201      	add	r2, pc, #4	; (adr r2, 339b8 <smp_public_key_periph+0x44>)
   339b2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   339b6:	bf00      	nop
   339b8:	000339d1 	.word	0x000339d1
   339bc:	00033a05 	.word	0x00033a05
   339c0:	000339eb 	.word	0x000339eb
   339c4:	000339d1 	.word	0x000339d1
   339c8:	000339a7 	.word	0x000339a7
   339cc:	00033a25 	.word	0x00033a25
		atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_PAIRING_RANDOM);
   339d0:	2104      	movs	r1, #4
   339d2:	4620      	mov	r0, r4
   339d4:	f01a fbb8 	bl	4e148 <atomic_set_bit>
		err = smp_send_pairing_confirm(smp);
   339d8:	f7ff feaa 	bl	33730 <smp_send_pairing_confirm>
		if (err) {
   339dc:	2800      	cmp	r0, #0
   339de:	d1d8      	bne.n	33992 <smp_public_key_periph+0x1e>
	return generate_dhkey(smp);
   339e0:	4620      	mov	r0, r4
}
   339e2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return generate_dhkey(smp);
   339e6:	f01a bbc3 	b.w	4e170 <generate_dhkey>
		err = display_passkey(smp);
   339ea:	4620      	mov	r0, r4
   339ec:	f7ff fd32 	bl	33454 <display_passkey>
		if (err) {
   339f0:	2800      	cmp	r0, #0
   339f2:	d1ce      	bne.n	33992 <smp_public_key_periph+0x1e>
		atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_PAIRING_CONFIRM);
   339f4:	2103      	movs	r1, #3
   339f6:	4620      	mov	r0, r4
   339f8:	f01a fba6 	bl	4e148 <atomic_set_bit>
		atomic_set_bit(smp->allowed_cmds, BT_SMP_KEYPRESS_NOTIFICATION);
   339fc:	210e      	movs	r1, #14
		atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_PAIRING_RANDOM);
   339fe:	f01a fba3 	bl	4e148 <atomic_set_bit>
		break;
   33a02:	e7ed      	b.n	339e0 <smp_public_key_periph+0x6c>
		atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_PAIRING_CONFIRM);
   33a04:	4620      	mov	r0, r4
   33a06:	2103      	movs	r1, #3
   33a08:	f01a fb9e 	bl	4e148 <atomic_set_bit>
		atomic_set_bit(smp->allowed_cmds, BT_SMP_KEYPRESS_NOTIFICATION);
   33a0c:	210e      	movs	r1, #14
   33a0e:	f01a fb9b 	bl	4e148 <atomic_set_bit>
		atomic_set_bit(smp->flags, SMP_FLAG_USER);
   33a12:	4630      	mov	r0, r6
   33a14:	210a      	movs	r1, #10
   33a16:	f01a fb97 	bl	4e148 <atomic_set_bit>
		smp_auth_cb->passkey_entry(smp->chan.chan.conn);
   33a1a:	68ab      	ldr	r3, [r5, #8]
   33a1c:	f8d4 00ec 	ldr.w	r0, [r4, #236]	; 0xec
   33a20:	4798      	blx	r3
		break;
   33a22:	e7dd      	b.n	339e0 <smp_public_key_periph+0x6c>
		atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_PAIRING_RANDOM);
   33a24:	2104      	movs	r1, #4
   33a26:	4620      	mov	r0, r4
   33a28:	e7e9      	b.n	339fe <smp_public_key_periph+0x8a>
   33a2a:	bf00      	nop
   33a2c:	200041d4 	.word	0x200041d4

00033a30 <smp_public_key>:
{
   33a30:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   33a34:	460e      	mov	r6, r1
   33a36:	4604      	mov	r4, r0
	const struct bt_conn_auth_cb *smp_auth_cb = latch_auth_cb(smp);
   33a38:	f7ff fb86 	bl	33148 <latch_auth_cb>
	struct bt_smp_public_key *req = (void *)buf->data;
   33a3c:	68b6      	ldr	r6, [r6, #8]
	memcpy(smp->pkey, req->x, BT_PUB_KEY_COORD_LEN);
   33a3e:	f104 0857 	add.w	r8, r4, #87	; 0x57
   33a42:	2220      	movs	r2, #32
   33a44:	4631      	mov	r1, r6
	const struct bt_conn_auth_cb *smp_auth_cb = latch_auth_cb(smp);
   33a46:	4605      	mov	r5, r0
	memcpy(smp->pkey, req->x, BT_PUB_KEY_COORD_LEN);
   33a48:	4640      	mov	r0, r8
   33a4a:	f017 fa16 	bl	4ae7a <memcpy>
	memcpy(&smp->pkey[BT_PUB_KEY_COORD_LEN], req->y, BT_PUB_KEY_COORD_LEN);
   33a4e:	2220      	movs	r2, #32
   33a50:	18b1      	adds	r1, r6, r2
   33a52:	f104 0077 	add.w	r0, r4, #119	; 0x77
   33a56:	f017 fa10 	bl	4ae7a <memcpy>
	if (bt_pub_key_is_debug(smp->pkey)) {
   33a5a:	4640      	mov	r0, r8
   33a5c:	f7fb febe 	bl	2f7dc <bt_pub_key_is_debug>
   33a60:	b990      	cbnz	r0, 33a88 <smp_public_key+0x58>
	    smp->chan.chan.conn->role == BT_HCI_ROLE_CENTRAL) {
   33a62:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
	if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
   33a66:	78db      	ldrb	r3, [r3, #3]
   33a68:	2b00      	cmp	r3, #0
   33a6a:	d17c      	bne.n	33b66 <smp_public_key+0x136>
		if (!atomic_test_bit(smp->flags, SMP_FLAG_SC_DEBUG_KEY) &&
   33a6c:	1d27      	adds	r7, r4, #4
   33a6e:	210e      	movs	r1, #14
   33a70:	4638      	mov	r0, r7
   33a72:	f01a fa1a 	bl	4deaa <atomic_test_bit>
   33a76:	b338      	cbz	r0, 33ac8 <smp_public_key+0x98>
		switch (smp->method) {
   33a78:	7a23      	ldrb	r3, [r4, #8]
   33a7a:	2b05      	cmp	r3, #5
   33a7c:	d82c      	bhi.n	33ad8 <smp_public_key+0xa8>
   33a7e:	e8df f003 	tbb	[pc, r3]
   33a82:	482d      	.short	0x482d
   33a84:	522b2d32 	.word	0x522b2d32
		atomic_set_bit(smp->flags, SMP_FLAG_SC_DEBUG_KEY);
   33a88:	210e      	movs	r1, #14
   33a8a:	1d20      	adds	r0, r4, #4
   33a8c:	f01a fb5c 	bl	4e148 <atomic_set_bit>
		if (!update_debug_keys_check(smp)) {
   33a90:	f8d4 60ec 	ldr.w	r6, [r4, #236]	; 0xec
	if (!conn->le.keys) {
   33a94:	f8d6 30b4 	ldr.w	r3, [r6, #180]	; 0xb4
   33a98:	b933      	cbnz	r3, 33aa8 <smp_public_key+0x78>
		conn->le.keys = bt_keys_get_addr(conn->id, &conn->le.dst);
   33a9a:	7a30      	ldrb	r0, [r6, #8]
   33a9c:	f106 0188 	add.w	r1, r6, #136	; 0x88
   33aa0:	f000 fb7c 	bl	3419c <bt_keys_get_addr>
   33aa4:	f8c6 00b4 	str.w	r0, [r6, #180]	; 0xb4
	if (!conn->le.keys ||
   33aa8:	f8d6 30b4 	ldr.w	r3, [r6, #180]	; 0xb4
   33aac:	2b00      	cmp	r3, #0
   33aae:	d0d8      	beq.n	33a62 <smp_public_key+0x32>
   33ab0:	89da      	ldrh	r2, [r3, #14]
   33ab2:	f002 0224 	and.w	r2, r2, #36	; 0x24
   33ab6:	2a00      	cmp	r2, #0
   33ab8:	d0d3      	beq.n	33a62 <smp_public_key+0x32>
	if (conn->le.keys->flags & BT_KEYS_DEBUG) {
   33aba:	7b5b      	ldrb	r3, [r3, #13]
   33abc:	079b      	lsls	r3, r3, #30
   33abe:	d4d0      	bmi.n	33a62 <smp_public_key+0x32>
			return BT_SMP_ERR_AUTH_REQUIREMENTS;
   33ac0:	2003      	movs	r0, #3
}
   33ac2:	b002      	add	sp, #8
   33ac4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		    memcmp(smp->pkey, sc_public_key, BT_PUB_KEY_COORD_LEN) == 0) {
   33ac8:	4b2f      	ldr	r3, [pc, #188]	; (33b88 <smp_public_key+0x158>)
   33aca:	2220      	movs	r2, #32
   33acc:	6819      	ldr	r1, [r3, #0]
   33ace:	4640      	mov	r0, r8
   33ad0:	f017 f9c3 	bl	4ae5a <memcmp>
		if (!atomic_test_bit(smp->flags, SMP_FLAG_SC_DEBUG_KEY) &&
   33ad4:	2800      	cmp	r0, #0
   33ad6:	d1cf      	bne.n	33a78 <smp_public_key+0x48>
			return BT_SMP_ERR_UNSPECIFIED;
   33ad8:	2008      	movs	r0, #8
   33ada:	e7f2      	b.n	33ac2 <smp_public_key+0x92>
			atomic_set_bit(smp->allowed_cmds,
   33adc:	2103      	movs	r1, #3
			atomic_set_bit(smp->allowed_cmds,
   33ade:	4620      	mov	r0, r4
   33ae0:	f01a fb32 	bl	4e148 <atomic_set_bit>
			break;
   33ae4:	e00f      	b.n	33b06 <smp_public_key+0xd6>
			err = display_passkey(smp);
   33ae6:	4620      	mov	r0, r4
   33ae8:	f7ff fcb4 	bl	33454 <display_passkey>
			if (err) {
   33aec:	2800      	cmp	r0, #0
   33aee:	d1e8      	bne.n	33ac2 <smp_public_key+0x92>
			atomic_set_bit(smp->allowed_cmds,
   33af0:	2103      	movs	r1, #3
   33af2:	4620      	mov	r0, r4
   33af4:	f01a fb28 	bl	4e148 <atomic_set_bit>
			atomic_set_bit(smp->allowed_cmds,
   33af8:	210e      	movs	r1, #14
   33afa:	f01a fb25 	bl	4e148 <atomic_set_bit>
			err = smp_send_pairing_confirm(smp);
   33afe:	f7ff fe17 	bl	33730 <smp_send_pairing_confirm>
			if (err) {
   33b02:	2800      	cmp	r0, #0
   33b04:	d1dd      	bne.n	33ac2 <smp_public_key+0x92>
		return generate_dhkey(smp);
   33b06:	4620      	mov	r0, r4
}
   33b08:	b002      	add	sp, #8
   33b0a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		return generate_dhkey(smp);
   33b0e:	f01a bb2f 	b.w	4e170 <generate_dhkey>
			atomic_set_bit(smp->flags, SMP_FLAG_USER);
   33b12:	210a      	movs	r1, #10
   33b14:	4638      	mov	r0, r7
   33b16:	f01a fb17 	bl	4e148 <atomic_set_bit>
			smp_auth_cb->passkey_entry(smp->chan.chan.conn);
   33b1a:	68ab      	ldr	r3, [r5, #8]
   33b1c:	f8d4 00ec 	ldr.w	r0, [r4, #236]	; 0xec
   33b20:	4798      	blx	r3
			atomic_set_bit(smp->allowed_cmds,
   33b22:	210e      	movs	r1, #14
   33b24:	e7db      	b.n	33ade <smp_public_key+0xae>
			if (bt_rand(smp->prnd, 16)) {
   33b26:	2110      	movs	r1, #16
   33b28:	f104 0027 	add.w	r0, r4, #39	; 0x27
   33b2c:	f003 fc4a 	bl	373c4 <bt_rand>
   33b30:	4606      	mov	r6, r0
   33b32:	2800      	cmp	r0, #0
   33b34:	d1d0      	bne.n	33ad8 <smp_public_key+0xa8>
			if (smp_auth_cb && smp_auth_cb->oob_data_request) {
   33b36:	b32d      	cbz	r5, 33b84 <smp_public_key+0x154>
   33b38:	692b      	ldr	r3, [r5, #16]
   33b3a:	b31b      	cbz	r3, 33b84 <smp_public_key+0x154>
				struct bt_conn_oob_info info = {
   33b3c:	4b13      	ldr	r3, [pc, #76]	; (33b8c <smp_public_key+0x15c>)
				le_sc_oob_config_set(smp, &info);
   33b3e:	a901      	add	r1, sp, #4
				struct bt_conn_oob_info info = {
   33b40:	f8b3 3035 	ldrh.w	r3, [r3, #53]	; 0x35
   33b44:	f8ad 3004 	strh.w	r3, [sp, #4]
				le_sc_oob_config_set(smp, &info);
   33b48:	4620      	mov	r0, r4
   33b4a:	f01a f98c 	bl	4de66 <le_sc_oob_config_set>
				atomic_set_bit(smp->flags,
   33b4e:	4638      	mov	r0, r7
				smp->oobd_remote = NULL;
   33b50:	e9c4 6638 	strd	r6, r6, [r4, #224]	; 0xe0
				atomic_set_bit(smp->flags,
   33b54:	210c      	movs	r1, #12
   33b56:	f01a faf7 	bl	4e148 <atomic_set_bit>
				smp_auth_cb->oob_data_request(smp->chan.chan.conn, &info);
   33b5a:	692b      	ldr	r3, [r5, #16]
   33b5c:	f8d4 00ec 	ldr.w	r0, [r4, #236]	; 0xec
   33b60:	a901      	add	r1, sp, #4
   33b62:	4798      	blx	r3
			break;
   33b64:	e7cf      	b.n	33b06 <smp_public_key+0xd6>
	if (!sc_public_key) {
   33b66:	4b08      	ldr	r3, [pc, #32]	; (33b88 <smp_public_key+0x158>)
   33b68:	681d      	ldr	r5, [r3, #0]
   33b6a:	b92d      	cbnz	r5, 33b78 <smp_public_key+0x148>
		atomic_set_bit(smp->flags, SMP_FLAG_PKEY_SEND);
   33b6c:	1d20      	adds	r0, r4, #4
   33b6e:	2106      	movs	r1, #6
   33b70:	f01a faea 	bl	4e148 <atomic_set_bit>
		return 0;
   33b74:	4628      	mov	r0, r5
   33b76:	e7a4      	b.n	33ac2 <smp_public_key+0x92>
	err = smp_public_key_periph(smp);
   33b78:	4620      	mov	r0, r4
}
   33b7a:	b002      	add	sp, #8
   33b7c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	err = smp_public_key_periph(smp);
   33b80:	f7ff bef8 	b.w	33974 <smp_public_key_periph>
				return BT_SMP_ERR_OOB_NOT_AVAIL;
   33b84:	2002      	movs	r0, #2
   33b86:	e79c      	b.n	33ac2 <smp_public_key+0x92>
   33b88:	200041d4 	.word	0x200041d4
   33b8c:	00050de6 	.word	0x00050de6

00033b90 <bt_smp_connected>:
{
   33b90:	b538      	push	{r3, r4, r5, lr}
	k_work_init_delayable(&smp->work, smp_timeout);
   33b92:	490b      	ldr	r1, [pc, #44]	; (33bc0 <bt_smp_connected+0x30>)
{
   33b94:	4604      	mov	r4, r0
	k_work_init_delayable(&smp->work, smp_timeout);
   33b96:	f1a0 05ec 	sub.w	r5, r0, #236	; 0xec
   33b9a:	308c      	adds	r0, #140	; 0x8c
   33b9c:	f01c fa32 	bl	50004 <k_work_init_delayable>
	smp_reset(smp);
   33ba0:	4628      	mov	r0, r5
   33ba2:	f01a fd15 	bl	4e5d0 <smp_reset>
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   33ba6:	f3bf 8f5b 	dmb	ish
   33baa:	4b06      	ldr	r3, [pc, #24]	; (33bc4 <bt_smp_connected+0x34>)
   33bac:	34bc      	adds	r4, #188	; 0xbc
   33bae:	e854 2f00 	ldrex	r2, [r4]
   33bb2:	e844 3100 	strex	r1, r3, [r4]
   33bb6:	2900      	cmp	r1, #0
   33bb8:	d1f9      	bne.n	33bae <bt_smp_connected+0x1e>
   33bba:	f3bf 8f5b 	dmb	ish
}
   33bbe:	bd38      	pop	{r3, r4, r5, pc}
   33bc0:	0004eb13 	.word	0x0004eb13
   33bc4:	20001dc0 	.word	0x20001dc0

00033bc8 <smp_pairing_accept_query>:
{
   33bc8:	b537      	push	{r0, r1, r2, r4, r5, lr}
   33bca:	4605      	mov	r5, r0
   33bcc:	460c      	mov	r4, r1
	const struct bt_conn_auth_cb *smp_auth_cb = latch_auth_cb(smp);
   33bce:	f7ff fabb 	bl	33148 <latch_auth_cb>
	if (smp_auth_cb && smp_auth_cb->pairing_accept) {
   33bd2:	4603      	mov	r3, r0
   33bd4:	b1f8      	cbz	r0, 33c16 <smp_pairing_accept_query+0x4e>
   33bd6:	6800      	ldr	r0, [r0, #0]
   33bd8:	b1e8      	cbz	r0, 33c16 <smp_pairing_accept_query+0x4e>
		const struct bt_conn_pairing_feat feat = {
   33bda:	7822      	ldrb	r2, [r4, #0]
   33bdc:	f88d 2000 	strb.w	r2, [sp]
   33be0:	7862      	ldrb	r2, [r4, #1]
   33be2:	f88d 2001 	strb.w	r2, [sp, #1]
   33be6:	78a2      	ldrb	r2, [r4, #2]
   33be8:	f88d 2002 	strb.w	r2, [sp, #2]
   33bec:	78e2      	ldrb	r2, [r4, #3]
   33bee:	f88d 2003 	strb.w	r2, [sp, #3]
   33bf2:	7922      	ldrb	r2, [r4, #4]
   33bf4:	f88d 2004 	strb.w	r2, [sp, #4]
   33bf8:	7962      	ldrb	r2, [r4, #5]
   33bfa:	f88d 2005 	strb.w	r2, [sp, #5]
		return smp_err_get(smp_auth_cb->pairing_accept(conn, &feat));
   33bfe:	681b      	ldr	r3, [r3, #0]
   33c00:	f8d5 00ec 	ldr.w	r0, [r5, #236]	; 0xec
   33c04:	4669      	mov	r1, sp
   33c06:	4798      	blx	r3
	switch (auth_err) {
   33c08:	3801      	subs	r0, #1
   33c0a:	b2c0      	uxtb	r0, r0
   33c0c:	2808      	cmp	r0, #8
   33c0e:	bf9a      	itte	ls
   33c10:	4b02      	ldrls	r3, [pc, #8]	; (33c1c <smp_pairing_accept_query+0x54>)
   33c12:	5c18      	ldrbls	r0, [r3, r0]
		return smp_err_get(smp_auth_cb->pairing_accept(conn, &feat));
   33c14:	2000      	movhi	r0, #0
}
   33c16:	b003      	add	sp, #12
   33c18:	bd30      	pop	{r4, r5, pc}
   33c1a:	bf00      	nop
   33c1c:	000537a4 	.word	0x000537a4

00033c20 <smp_pairing_rsp>:
{
   33c20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   33c22:	460e      	mov	r6, r1
	struct bt_conn *conn = smp->chan.chan.conn;
   33c24:	f8d0 50ec 	ldr.w	r5, [r0, #236]	; 0xec
{
   33c28:	4604      	mov	r4, r0
	const struct bt_conn_auth_cb *smp_auth_cb = latch_auth_cb(smp);
   33c2a:	f7ff fa8d 	bl	33148 <latch_auth_cb>
	struct bt_smp_pairing *rsp = (void *)buf->data;
   33c2e:	68b6      	ldr	r6, [r6, #8]
	if ((rsp->max_key_size > BT_SMP_MAX_ENC_KEY_SIZE) ||
   33c30:	78f3      	ldrb	r3, [r6, #3]
   33c32:	3b07      	subs	r3, #7
   33c34:	2b09      	cmp	r3, #9
   33c36:	d86e      	bhi.n	33d16 <smp_pairing_rsp+0xf6>
	smp->local_dist &= rsp->init_key_dist;
   33c38:	7932      	ldrb	r2, [r6, #4]
   33c3a:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
   33c3e:	4013      	ands	r3, r2
   33c40:	f884 30e8 	strb.w	r3, [r4, #232]	; 0xe8
	smp->remote_dist &= rsp->resp_key_dist;
   33c44:	7972      	ldrb	r2, [r6, #5]
   33c46:	f894 30e9 	ldrb.w	r3, [r4, #233]	; 0xe9
   33c4a:	4013      	ands	r3, r2
   33c4c:	f884 30e9 	strb.w	r3, [r4, #233]	; 0xe9
	smp->prsp[0] = BT_SMP_CMD_PAIRING_RSP;
   33c50:	2302      	movs	r3, #2
   33c52:	7423      	strb	r3, [r4, #16]
	memcpy(smp->prsp + 1, rsp, sizeof(*rsp));
   33c54:	2206      	movs	r2, #6
   33c56:	4631      	mov	r1, r6
   33c58:	f104 0011 	add.w	r0, r4, #17
   33c5c:	f017 f90d 	bl	4ae7a <memcpy>
	if ((rsp->auth_req & BT_SMP_AUTH_SC) &&
   33c60:	78b3      	ldrb	r3, [r6, #2]
   33c62:	071b      	lsls	r3, r3, #28
   33c64:	d506      	bpl.n	33c74 <smp_pairing_rsp+0x54>
   33c66:	7b23      	ldrb	r3, [r4, #12]
   33c68:	071f      	lsls	r7, r3, #28
   33c6a:	d503      	bpl.n	33c74 <smp_pairing_rsp+0x54>
		atomic_set_bit(smp->flags, SMP_FLAG_SC);
   33c6c:	2105      	movs	r1, #5
   33c6e:	1d20      	adds	r0, r4, #4
   33c70:	f01a fa6a 	bl	4e148 <atomic_set_bit>
	if ((rsp->auth_req & BT_SMP_AUTH_CT2) &&
   33c74:	78b3      	ldrb	r3, [r6, #2]
   33c76:	0698      	lsls	r0, r3, #26
   33c78:	d506      	bpl.n	33c88 <smp_pairing_rsp+0x68>
   33c7a:	7b23      	ldrb	r3, [r4, #12]
   33c7c:	0699      	lsls	r1, r3, #26
   33c7e:	d503      	bpl.n	33c88 <smp_pairing_rsp+0x68>
		atomic_set_bit(smp->flags, SMP_FLAG_CT2);
   33c80:	2114      	movs	r1, #20
   33c82:	1d20      	adds	r0, r4, #4
   33c84:	f01a fa60 	bl	4e148 <atomic_set_bit>
	if ((rsp->auth_req & BT_SMP_AUTH_BONDING) &&
   33c88:	78b3      	ldrb	r3, [r6, #2]
   33c8a:	07da      	lsls	r2, r3, #31
   33c8c:	d506      	bpl.n	33c9c <smp_pairing_rsp+0x7c>
   33c8e:	7b23      	ldrb	r3, [r4, #12]
   33c90:	07db      	lsls	r3, r3, #31
   33c92:	d503      	bpl.n	33c9c <smp_pairing_rsp+0x7c>
		atomic_set_bit(smp->flags, SMP_FLAG_BOND);
   33c94:	210d      	movs	r1, #13
   33c96:	1d20      	adds	r0, r4, #4
   33c98:	f01a fa56 	bl	4e148 <atomic_set_bit>
	smp->method = get_pair_method(smp, rsp->io_capability);
   33c9c:	7831      	ldrb	r1, [r6, #0]
   33c9e:	4620      	mov	r0, r4
   33ca0:	f7ff fab4 	bl	3320c <get_pair_method>
   33ca4:	7220      	strb	r0, [r4, #8]
	if (!update_keys_check(smp, conn->le.keys)) {
   33ca6:	f8d5 10b4 	ldr.w	r1, [r5, #180]	; 0xb4
   33caa:	4620      	mov	r0, r4
   33cac:	f01a f93d 	bl	4df2a <update_keys_check>
   33cb0:	b910      	cbnz	r0, 33cb8 <smp_pairing_rsp+0x98>
		return BT_SMP_ERR_AUTH_REQUIREMENTS;
   33cb2:	2503      	movs	r5, #3
}
   33cb4:	4628      	mov	r0, r5
   33cb6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	err = remote_sec_level_reachable(smp);
   33cb8:	4620      	mov	r0, r4
   33cba:	f01a f957 	bl	4df6c <remote_sec_level_reachable>
	if (err) {
   33cbe:	4605      	mov	r5, r0
   33cc0:	2800      	cmp	r0, #0
   33cc2:	d1f7      	bne.n	33cb4 <smp_pairing_rsp+0x94>
	if (!atomic_test_bit(smp->flags, SMP_FLAG_SC)) {
   33cc4:	1d27      	adds	r7, r4, #4
   33cc6:	2105      	movs	r1, #5
   33cc8:	4638      	mov	r0, r7
   33cca:	f01a f8ee 	bl	4deaa <atomic_test_bit>
   33cce:	2800      	cmp	r0, #0
   33cd0:	d0ef      	beq.n	33cb2 <smp_pairing_rsp+0x92>
	smp->remote_dist &= RECV_KEYS_SC;
   33cd2:	f894 30e9 	ldrb.w	r3, [r4, #233]	; 0xe9
	smp->local_dist &= SEND_KEYS_SC;
   33cd6:	f884 50e8 	strb.w	r5, [r4, #232]	; 0xe8
	smp->remote_dist &= RECV_KEYS_SC;
   33cda:	f003 0302 	and.w	r3, r3, #2
   33cde:	f884 30e9 	strb.w	r3, [r4, #233]	; 0xe9
		err = smp_pairing_accept_query(smp, rsp);
   33ce2:	4631      	mov	r1, r6
   33ce4:	4620      	mov	r0, r4
   33ce6:	f7ff ff6f 	bl	33bc8 <smp_pairing_accept_query>
		if (err) {
   33cea:	4605      	mov	r5, r0
   33cec:	2800      	cmp	r0, #0
   33cee:	d1e1      	bne.n	33cb4 <smp_pairing_rsp+0x94>
	if (!sc_public_key) {
   33cf0:	4b0a      	ldr	r3, [pc, #40]	; (33d1c <smp_pairing_rsp+0xfc>)
   33cf2:	681b      	ldr	r3, [r3, #0]
   33cf4:	b923      	cbnz	r3, 33d00 <smp_pairing_rsp+0xe0>
		atomic_set_bit(smp->flags, SMP_FLAG_PKEY_SEND);
   33cf6:	2106      	movs	r1, #6
   33cf8:	4638      	mov	r0, r7
   33cfa:	f01a fa25 	bl	4e148 <atomic_set_bit>
		return 0;
   33cfe:	e7d9      	b.n	33cb4 <smp_pairing_rsp+0x94>
	atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_PUBLIC_KEY);
   33d00:	4620      	mov	r0, r4
   33d02:	210c      	movs	r1, #12
   33d04:	f01a fa20 	bl	4e148 <atomic_set_bit>
	atomic_clear_bit(smp->allowed_cmds, BT_SMP_CMD_SECURITY_REQUEST);
   33d08:	210b      	movs	r1, #11
   33d0a:	f01a f953 	bl	4dfb4 <atomic_clear_bit>
}
   33d0e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	return sc_send_public_key(smp);
   33d12:	f7ff bceb 	b.w	336ec <sc_send_public_key>
		return BT_SMP_ERR_ENC_KEY_SIZE;
   33d16:	2506      	movs	r5, #6
   33d18:	e7cc      	b.n	33cb4 <smp_pairing_rsp+0x94>
   33d1a:	bf00      	nop
   33d1c:	200041d4 	.word	0x200041d4

00033d20 <smp_pairing_req>:
{
   33d20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   33d22:	460e      	mov	r6, r1
	struct bt_conn *conn = smp->chan.chan.conn;
   33d24:	f8d0 50ec 	ldr.w	r5, [r0, #236]	; 0xec
{
   33d28:	4604      	mov	r4, r0
	const struct bt_conn_auth_cb *smp_auth_cb = latch_auth_cb(smp);
   33d2a:	f7ff fa0d 	bl	33148 <latch_auth_cb>
	struct bt_smp_pairing *req = (void *)buf->data;
   33d2e:	68b6      	ldr	r6, [r6, #8]
	if ((req->max_key_size > BT_SMP_MAX_ENC_KEY_SIZE) ||
   33d30:	78f3      	ldrb	r3, [r6, #3]
   33d32:	3b07      	subs	r3, #7
   33d34:	2b09      	cmp	r3, #9
   33d36:	f200 80a1 	bhi.w	33e7c <smp_pairing_req+0x15c>
	if (!conn->le.keys) {
   33d3a:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
   33d3e:	b15b      	cbz	r3, 33d58 <smp_pairing_req+0x38>
	if (!atomic_test_bit(smp->flags, SMP_FLAG_SEC_REQ)) {
   33d40:	1d27      	adds	r7, r4, #4
   33d42:	210f      	movs	r1, #15
   33d44:	4638      	mov	r0, r7
   33d46:	f01a f8b0 	bl	4deaa <atomic_test_bit>
   33d4a:	b988      	cbnz	r0, 33d70 <smp_pairing_req+0x50>
		int ret = smp_init(smp);
   33d4c:	4620      	mov	r0, r4
   33d4e:	f7ff fbab 	bl	334a8 <smp_init>
		if (ret) {
   33d52:	b168      	cbz	r0, 33d70 <smp_pairing_req+0x50>
			return ret;
   33d54:	b2c5      	uxtb	r5, r0
   33d56:	e009      	b.n	33d6c <smp_pairing_req+0x4c>
		conn->le.keys = bt_keys_get_addr(conn->id, &conn->le.dst);
   33d58:	7a28      	ldrb	r0, [r5, #8]
   33d5a:	f105 0188 	add.w	r1, r5, #136	; 0x88
   33d5e:	f000 fa1d 	bl	3419c <bt_keys_get_addr>
   33d62:	f8c5 00b4 	str.w	r0, [r5, #180]	; 0xb4
		if (!conn->le.keys) {
   33d66:	2800      	cmp	r0, #0
   33d68:	d1ea      	bne.n	33d40 <smp_pairing_req+0x20>
			return BT_SMP_ERR_UNSPECIFIED;
   33d6a:	2508      	movs	r5, #8
}
   33d6c:	4628      	mov	r0, r5
   33d6e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	smp->preq[0] = BT_SMP_CMD_PAIRING_REQ;
   33d70:	2301      	movs	r3, #1
	memcpy(smp->preq + 1, req, sizeof(*req));
   33d72:	2206      	movs	r2, #6
	smp->preq[0] = BT_SMP_CMD_PAIRING_REQ;
   33d74:	7263      	strb	r3, [r4, #9]
	memcpy(smp->preq + 1, req, sizeof(*req));
   33d76:	4631      	mov	r1, r6
   33d78:	f104 000a 	add.w	r0, r4, #10
   33d7c:	f017 f87d 	bl	4ae7a <memcpy>
	smp->prsp[0] = BT_SMP_CMD_PAIRING_RSP;
   33d80:	2302      	movs	r3, #2
   33d82:	7423      	strb	r3, [r4, #16]
	rsp->auth_req = get_auth(smp, req->auth_req);
   33d84:	78b1      	ldrb	r1, [r6, #2]
   33d86:	4620      	mov	r0, r4
   33d88:	f7ff fa22 	bl	331d0 <get_auth>
   33d8c:	74e0      	strb	r0, [r4, #19]
	rsp->io_capability = get_io_capa(smp);
   33d8e:	4620      	mov	r0, r4
   33d90:	f7ff f9f8 	bl	33184 <get_io_capa>
	rsp->oob_flag = oobd_present ? BT_SMP_OOB_PRESENT :
   33d94:	4b3a      	ldr	r3, [pc, #232]	; (33e80 <smp_pairing_req+0x160>)
	rsp->io_capability = get_io_capa(smp);
   33d96:	7460      	strb	r0, [r4, #17]
	rsp->oob_flag = oobd_present ? BT_SMP_OOB_PRESENT :
   33d98:	781b      	ldrb	r3, [r3, #0]
   33d9a:	74a3      	strb	r3, [r4, #18]
	rsp->max_key_size = BT_SMP_MAX_ENC_KEY_SIZE;
   33d9c:	2310      	movs	r3, #16
   33d9e:	7523      	strb	r3, [r4, #20]
	rsp->init_key_dist = (req->init_key_dist & RECV_KEYS);
   33da0:	7933      	ldrb	r3, [r6, #4]
   33da2:	f003 0303 	and.w	r3, r3, #3
   33da6:	7563      	strb	r3, [r4, #21]
	rsp->resp_key_dist = (req->resp_key_dist & SEND_KEYS);
   33da8:	7973      	ldrb	r3, [r6, #5]
   33daa:	f003 0301 	and.w	r3, r3, #1
   33dae:	75a3      	strb	r3, [r4, #22]
	if ((rsp->auth_req & BT_SMP_AUTH_SC) &&
   33db0:	7ce3      	ldrb	r3, [r4, #19]
   33db2:	071a      	lsls	r2, r3, #28
   33db4:	d50c      	bpl.n	33dd0 <smp_pairing_req+0xb0>
   33db6:	78b3      	ldrb	r3, [r6, #2]
   33db8:	071b      	lsls	r3, r3, #28
   33dba:	d509      	bpl.n	33dd0 <smp_pairing_req+0xb0>
		atomic_set_bit(smp->flags, SMP_FLAG_SC);
   33dbc:	2105      	movs	r1, #5
   33dbe:	4638      	mov	r0, r7
   33dc0:	f01a f9c2 	bl	4e148 <atomic_set_bit>
		rsp->init_key_dist &= RECV_KEYS_SC;
   33dc4:	7d63      	ldrb	r3, [r4, #21]
   33dc6:	f003 0302 	and.w	r3, r3, #2
   33dca:	7563      	strb	r3, [r4, #21]
		rsp->resp_key_dist &= SEND_KEYS_SC;
   33dcc:	2300      	movs	r3, #0
   33dce:	75a3      	strb	r3, [r4, #22]
	if ((rsp->auth_req & BT_SMP_AUTH_CT2) &&
   33dd0:	7ce3      	ldrb	r3, [r4, #19]
   33dd2:	0698      	lsls	r0, r3, #26
   33dd4:	d506      	bpl.n	33de4 <smp_pairing_req+0xc4>
   33dd6:	78b3      	ldrb	r3, [r6, #2]
   33dd8:	0699      	lsls	r1, r3, #26
   33dda:	d503      	bpl.n	33de4 <smp_pairing_req+0xc4>
		atomic_set_bit(smp->flags, SMP_FLAG_CT2);
   33ddc:	2114      	movs	r1, #20
   33dde:	4638      	mov	r0, r7
   33de0:	f01a f9b2 	bl	4e148 <atomic_set_bit>
	smp->local_dist = rsp->resp_key_dist;
   33de4:	7da3      	ldrb	r3, [r4, #22]
   33de6:	f884 30e8 	strb.w	r3, [r4, #232]	; 0xe8
	smp->remote_dist = rsp->init_key_dist;
   33dea:	7d63      	ldrb	r3, [r4, #21]
   33dec:	f884 30e9 	strb.w	r3, [r4, #233]	; 0xe9
	if ((rsp->auth_req & BT_SMP_AUTH_BONDING) &&
   33df0:	7ce3      	ldrb	r3, [r4, #19]
   33df2:	07da      	lsls	r2, r3, #31
   33df4:	d506      	bpl.n	33e04 <smp_pairing_req+0xe4>
   33df6:	78b3      	ldrb	r3, [r6, #2]
   33df8:	07db      	lsls	r3, r3, #31
   33dfa:	d503      	bpl.n	33e04 <smp_pairing_req+0xe4>
		atomic_set_bit(smp->flags, SMP_FLAG_BOND);
   33dfc:	210d      	movs	r1, #13
   33dfe:	4638      	mov	r0, r7
   33e00:	f01a f9a2 	bl	4e148 <atomic_set_bit>
	atomic_set_bit(smp->flags, SMP_FLAG_PAIRING);
   33e04:	2103      	movs	r1, #3
   33e06:	4638      	mov	r0, r7
   33e08:	f01a f99e 	bl	4e148 <atomic_set_bit>
	smp->method = get_pair_method(smp, req->io_capability);
   33e0c:	7831      	ldrb	r1, [r6, #0]
   33e0e:	4620      	mov	r0, r4
   33e10:	f7ff f9fc 	bl	3320c <get_pair_method>
   33e14:	7220      	strb	r0, [r4, #8]
	if (!update_keys_check(smp, conn->le.keys)) {
   33e16:	f8d5 10b4 	ldr.w	r1, [r5, #180]	; 0xb4
   33e1a:	4620      	mov	r0, r4
   33e1c:	f01a f885 	bl	4df2a <update_keys_check>
   33e20:	b908      	cbnz	r0, 33e26 <smp_pairing_req+0x106>
		return BT_SMP_ERR_AUTH_REQUIREMENTS;
   33e22:	2503      	movs	r5, #3
   33e24:	e7a2      	b.n	33d6c <smp_pairing_req+0x4c>
	err = remote_sec_level_reachable(smp);
   33e26:	4620      	mov	r0, r4
   33e28:	f01a f8a0 	bl	4df6c <remote_sec_level_reachable>
	if (err) {
   33e2c:	4605      	mov	r5, r0
   33e2e:	2800      	cmp	r0, #0
   33e30:	d19c      	bne.n	33d6c <smp_pairing_req+0x4c>
	if (!atomic_test_bit(smp->flags, SMP_FLAG_SC)) {
   33e32:	2105      	movs	r1, #5
   33e34:	4638      	mov	r0, r7
   33e36:	f01a f838 	bl	4deaa <atomic_test_bit>
   33e3a:	2800      	cmp	r0, #0
   33e3c:	d0f1      	beq.n	33e22 <smp_pairing_req+0x102>
		err = smp_pairing_accept_query(smp, req);
   33e3e:	4631      	mov	r1, r6
   33e40:	4620      	mov	r0, r4
   33e42:	f7ff fec1 	bl	33bc8 <smp_pairing_accept_query>
		if (err) {
   33e46:	4605      	mov	r5, r0
   33e48:	2800      	cmp	r0, #0
   33e4a:	d18f      	bne.n	33d6c <smp_pairing_req+0x4c>
	atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_PUBLIC_KEY);
   33e4c:	210c      	movs	r1, #12
   33e4e:	4620      	mov	r0, r4
   33e50:	f01a f97a 	bl	4e148 <atomic_set_bit>
	rsp_buf = smp_create_pdu(smp, BT_SMP_CMD_PAIRING_RSP, sizeof(*rsp));
   33e54:	2102      	movs	r1, #2
   33e56:	f01a f9bb 	bl	4e1d0 <smp_create_pdu.constprop.0>
	if (!rsp_buf) {
   33e5a:	4606      	mov	r6, r0
   33e5c:	2800      	cmp	r0, #0
   33e5e:	d084      	beq.n	33d6a <smp_pairing_req+0x4a>
   33e60:	2106      	movs	r1, #6
   33e62:	3008      	adds	r0, #8
   33e64:	f01a ffa6 	bl	4edb4 <net_buf_simple_add>
	memcpy(rsp, smp->prsp + 1, sizeof(*rsp));
   33e68:	f104 0111 	add.w	r1, r4, #17
   33e6c:	2206      	movs	r2, #6
   33e6e:	f017 f804 	bl	4ae7a <memcpy>
	smp_send(smp, rsp_buf, NULL, NULL);
   33e72:	4631      	mov	r1, r6
   33e74:	4620      	mov	r0, r4
   33e76:	f01a f8cc 	bl	4e012 <smp_send.constprop.0>
	return 0;
   33e7a:	e777      	b.n	33d6c <smp_pairing_req+0x4c>
		return BT_SMP_ERR_ENC_KEY_SIZE;
   33e7c:	2506      	movs	r5, #6
   33e7e:	e775      	b.n	33d6c <smp_pairing_req+0x4c>
   33e80:	20006ba9 	.word	0x20006ba9

00033e84 <smp_pairing_complete>:
{
   33e84:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   33e86:	4606      	mov	r6, r0
	struct bt_conn *conn = smp->chan.chan.conn;
   33e88:	f8d0 50ec 	ldr.w	r5, [r0, #236]	; 0xec
		bool bond_flag = atomic_test_bit(smp->flags, SMP_FLAG_BOND);
   33e8c:	1d04      	adds	r4, r0, #4
	if (!status) {
   33e8e:	bb61      	cbnz	r1, 33eea <smp_pairing_complete+0x66>
		bool bond_flag = atomic_test_bit(smp->flags, SMP_FLAG_BOND);
   33e90:	210d      	movs	r1, #13
   33e92:	4620      	mov	r0, r4
   33e94:	f01a f809 	bl	4deaa <atomic_test_bit>
		if (bond_flag) {
   33e98:	4607      	mov	r7, r0
   33e9a:	b118      	cbz	r0, 33ea4 <smp_pairing_complete+0x20>
			bt_keys_store(conn->le.keys);
   33e9c:	f8d5 00b4 	ldr.w	r0, [r5, #180]	; 0xb4
   33ea0:	f000 faba 	bl	34418 <bt_keys_store>
	return list->head;
   33ea4:	4b36      	ldr	r3, [pc, #216]	; (33f80 <smp_pairing_complete+0xfc>)
   33ea6:	681b      	ldr	r3, [r3, #0]
		SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&bt_auth_info_cbs, listener,
   33ea8:	b19b      	cbz	r3, 33ed2 <smp_pairing_complete+0x4e>
	return node->next;
   33eaa:	681c      	ldr	r4, [r3, #0]
   33eac:	b104      	cbz	r4, 33eb0 <smp_pairing_complete+0x2c>
   33eae:	3c0c      	subs	r4, #12
			if (listener->pairing_complete) {
   33eb0:	f853 3c0c 	ldr.w	r3, [r3, #-12]
   33eb4:	b113      	cbz	r3, 33ebc <smp_pairing_complete+0x38>
				listener->pairing_complete(conn, bond_flag);
   33eb6:	4639      	mov	r1, r7
   33eb8:	4628      	mov	r0, r5
   33eba:	4798      	blx	r3
		SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&bt_auth_info_cbs, listener,
   33ebc:	b14c      	cbz	r4, 33ed2 <smp_pairing_complete+0x4e>
   33ebe:	4623      	mov	r3, r4
   33ec0:	68e4      	ldr	r4, [r4, #12]
   33ec2:	681b      	ldr	r3, [r3, #0]
   33ec4:	b11c      	cbz	r4, 33ece <smp_pairing_complete+0x4a>
   33ec6:	3c0c      	subs	r4, #12
			if (listener->pairing_complete) {
   33ec8:	2b00      	cmp	r3, #0
   33eca:	d1f4      	bne.n	33eb6 <smp_pairing_complete+0x32>
   33ecc:	e7f7      	b.n	33ebe <smp_pairing_complete+0x3a>
   33ece:	2b00      	cmp	r3, #0
   33ed0:	d1f1      	bne.n	33eb6 <smp_pairing_complete+0x32>
	smp_reset(smp);
   33ed2:	4630      	mov	r0, r6
   33ed4:	f01a fb7c 	bl	4e5d0 <smp_reset>
	if (conn->sec_level != conn->required_sec_level) {
   33ed8:	7a6a      	ldrb	r2, [r5, #9]
   33eda:	7aab      	ldrb	r3, [r5, #10]
   33edc:	429a      	cmp	r2, r3
   33ede:	d04d      	beq.n	33f7c <smp_pairing_complete+0xf8>
		bt_smp_start_security(conn);
   33ee0:	4628      	mov	r0, r5
}
   33ee2:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		bt_smp_start_security(conn);
   33ee6:	f01a bc11 	b.w	4e70c <bt_smp_start_security>
	switch (smp_err) {
   33eea:	3901      	subs	r1, #1
   33eec:	b2c9      	uxtb	r1, r1
   33eee:	290e      	cmp	r1, #14
   33ef0:	bf9c      	itt	ls
   33ef2:	4b24      	ldrls	r3, [pc, #144]	; (33f84 <smp_pairing_complete+0x100>)
   33ef4:	5c5f      	ldrbls	r7, [r3, r1]
		if (conn->le.keys &&
   33ef6:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
	if (!status) {
   33efa:	bf88      	it	hi
   33efc:	2709      	movhi	r7, #9
		if (conn->le.keys &&
   33efe:	b143      	cbz	r3, 33f12 <smp_pairing_complete+0x8e>
   33f00:	7b1b      	ldrb	r3, [r3, #12]
   33f02:	bb2b      	cbnz	r3, 33f50 <smp_pairing_complete+0xcc>
			bt_keys_clear(conn->le.keys);
   33f04:	f8d5 00b4 	ldr.w	r0, [r5, #180]	; 0xb4
   33f08:	f000 fa5e 	bl	343c8 <bt_keys_clear>
			conn->le.keys = NULL;
   33f0c:	2300      	movs	r3, #0
   33f0e:	f8c5 30b4 	str.w	r3, [r5, #180]	; 0xb4
		if (!atomic_test_bit(smp->flags, SMP_FLAG_KEYS_DISTR)) {
   33f12:	2102      	movs	r1, #2
   33f14:	4620      	mov	r0, r4
   33f16:	f019 ffc8 	bl	4deaa <atomic_test_bit>
   33f1a:	b940      	cbnz	r0, 33f2e <smp_pairing_complete+0xaa>
	switch (err) {
   33f1c:	2f07      	cmp	r7, #7
   33f1e:	bf96      	itet	ls
   33f20:	4b19      	ldrls	r3, [pc, #100]	; (33f88 <smp_pairing_complete+0x104>)
		if (!atomic_test_bit(smp->flags, SMP_FLAG_KEYS_DISTR)) {
   33f22:	211f      	movhi	r1, #31
   33f24:	5dd9      	ldrbls	r1, [r3, r7]
			bt_conn_security_changed(conn,
   33f26:	463a      	mov	r2, r7
   33f28:	4628      	mov	r0, r5
   33f2a:	f7fc f8d5 	bl	300d8 <bt_conn_security_changed>
		if (atomic_test_bit(smp->flags, SMP_FLAG_PAIRING)) {
   33f2e:	2103      	movs	r1, #3
   33f30:	4620      	mov	r0, r4
   33f32:	f019 ffba 	bl	4deaa <atomic_test_bit>
   33f36:	2800      	cmp	r0, #0
   33f38:	d0cb      	beq.n	33ed2 <smp_pairing_complete+0x4e>
	return list->head;
   33f3a:	4b11      	ldr	r3, [pc, #68]	; (33f80 <smp_pairing_complete+0xfc>)
   33f3c:	681b      	ldr	r3, [r3, #0]
			SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&bt_auth_info_cbs,
   33f3e:	2b00      	cmp	r3, #0
   33f40:	d0c7      	beq.n	33ed2 <smp_pairing_complete+0x4e>
	return node->next;
   33f42:	681c      	ldr	r4, [r3, #0]
   33f44:	b104      	cbz	r4, 33f48 <smp_pairing_complete+0xc4>
   33f46:	3c0c      	subs	r4, #12
				if (listener->pairing_failed) {
   33f48:	f853 3c08 	ldr.w	r3, [r3, #-8]
   33f4c:	b94b      	cbnz	r3, 33f62 <smp_pairing_complete+0xde>
   33f4e:	e00b      	b.n	33f68 <smp_pairing_complete+0xe4>
		     atomic_test_bit(smp->flags, SMP_FLAG_KEYS_DISTR))) {
   33f50:	2102      	movs	r1, #2
   33f52:	4620      	mov	r0, r4
   33f54:	f019 ffa9 	bl	4deaa <atomic_test_bit>
		    (!conn->le.keys->enc_size ||
   33f58:	2800      	cmp	r0, #0
   33f5a:	d1d3      	bne.n	33f04 <smp_pairing_complete+0x80>
   33f5c:	e7d9      	b.n	33f12 <smp_pairing_complete+0x8e>
			SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&bt_auth_info_cbs,
   33f5e:	3c0c      	subs	r4, #12
				if (listener->pairing_failed) {
   33f60:	b123      	cbz	r3, 33f6c <smp_pairing_complete+0xe8>
					listener->pairing_failed(conn, security_err);
   33f62:	4639      	mov	r1, r7
   33f64:	4628      	mov	r0, r5
   33f66:	4798      	blx	r3
			SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&bt_auth_info_cbs,
   33f68:	2c00      	cmp	r4, #0
   33f6a:	d0b2      	beq.n	33ed2 <smp_pairing_complete+0x4e>
   33f6c:	4623      	mov	r3, r4
   33f6e:	68e4      	ldr	r4, [r4, #12]
   33f70:	685b      	ldr	r3, [r3, #4]
   33f72:	2c00      	cmp	r4, #0
   33f74:	d1f3      	bne.n	33f5e <smp_pairing_complete+0xda>
				if (listener->pairing_failed) {
   33f76:	2b00      	cmp	r3, #0
   33f78:	d1f3      	bne.n	33f62 <smp_pairing_complete+0xde>
   33f7a:	e7aa      	b.n	33ed2 <smp_pairing_complete+0x4e>
}
   33f7c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   33f7e:	bf00      	nop
   33f80:	20003c04 	.word	0x20003c04
   33f84:	000537ad 	.word	0x000537ad
   33f88:	0005379c 	.word	0x0005379c

00033f8c <bt_smp_recv>:
{
   33f8c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (buf->len < sizeof(*hdr)) {
   33f8e:	898b      	ldrh	r3, [r1, #12]
{
   33f90:	4607      	mov	r7, r0
   33f92:	460d      	mov	r5, r1
	if (buf->len < sizeof(*hdr)) {
   33f94:	b393      	cbz	r3, 33ffc <bt_smp_recv+0x70>
	return net_buf_simple_pull_mem(&buf->b, len);
   33f96:	2101      	movs	r1, #1
   33f98:	f105 0008 	add.w	r0, r5, #8
   33f9c:	f01a ff3b 	bl	4ee16 <net_buf_simple_pull_mem>
	if (atomic_test_bit(smp->flags, SMP_FLAG_TIMEOUT)) {
   33fa0:	2104      	movs	r1, #4
   33fa2:	4606      	mov	r6, r0
   33fa4:	f1a7 00e8 	sub.w	r0, r7, #232	; 0xe8
   33fa8:	f1a7 04ec 	sub.w	r4, r7, #236	; 0xec
   33fac:	f019 ff7d 	bl	4deaa <atomic_test_bit>
   33fb0:	bb20      	cbnz	r0, 33ffc <bt_smp_recv+0x70>
	if (hdr->code >= ARRAY_SIZE(handlers)) {
   33fb2:	7831      	ldrb	r1, [r6, #0]
   33fb4:	290e      	cmp	r1, #14
   33fb6:	d821      	bhi.n	33ffc <bt_smp_recv+0x70>
	if (!handlers[hdr->code].func) {
   33fb8:	4f11      	ldr	r7, [pc, #68]	; (34000 <bt_smp_recv+0x74>)
   33fba:	f857 3031 	ldr.w	r3, [r7, r1, lsl #3]
   33fbe:	b923      	cbnz	r3, 33fca <bt_smp_recv+0x3e>
		smp_error(smp, BT_SMP_ERR_CMD_NOTSUPP);
   33fc0:	2107      	movs	r1, #7
		smp_error(smp, err);
   33fc2:	4620      	mov	r0, r4
   33fc4:	f01a fc4a 	bl	4e85c <smp_error>
   33fc8:	e018      	b.n	33ffc <bt_smp_recv+0x70>
	if (!atomic_test_and_clear_bit(smp->allowed_cmds, hdr->code)) {
   33fca:	4620      	mov	r0, r4
   33fcc:	f01a faea 	bl	4e5a4 <atomic_test_and_clear_bit>
   33fd0:	7833      	ldrb	r3, [r6, #0]
   33fd2:	b918      	cbnz	r0, 33fdc <bt_smp_recv+0x50>
		if (hdr->code != BT_SMP_CMD_PAIRING_FAIL) {
   33fd4:	2b05      	cmp	r3, #5
   33fd6:	d011      	beq.n	33ffc <bt_smp_recv+0x70>
			smp_error(smp, BT_SMP_ERR_UNSPECIFIED);
   33fd8:	2108      	movs	r1, #8
   33fda:	e7f2      	b.n	33fc2 <bt_smp_recv+0x36>
	if (buf->len != handlers[hdr->code].expect_len) {
   33fdc:	eb07 02c3 	add.w	r2, r7, r3, lsl #3
   33fe0:	89a9      	ldrh	r1, [r5, #12]
   33fe2:	7912      	ldrb	r2, [r2, #4]
   33fe4:	4291      	cmp	r1, r2
   33fe6:	d001      	beq.n	33fec <bt_smp_recv+0x60>
		smp_error(smp, BT_SMP_ERR_INVALID_PARAMS);
   33fe8:	210a      	movs	r1, #10
   33fea:	e7ea      	b.n	33fc2 <bt_smp_recv+0x36>
	err = handlers[hdr->code].func(smp, buf);
   33fec:	4629      	mov	r1, r5
   33fee:	f857 3033 	ldr.w	r3, [r7, r3, lsl #3]
   33ff2:	4620      	mov	r0, r4
   33ff4:	4798      	blx	r3
	if (err) {
   33ff6:	4601      	mov	r1, r0
   33ff8:	2800      	cmp	r0, #0
   33ffa:	d1e2      	bne.n	33fc2 <bt_smp_recv+0x36>
}
   33ffc:	2000      	movs	r0, #0
   33ffe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   34000:	00052094 	.word	0x00052094

00034004 <bt_smp_pkey_ready>:
{
   34004:	b538      	push	{r3, r4, r5, lr}
	sc_public_key = pkey;
   34006:	4b16      	ldr	r3, [pc, #88]	; (34060 <bt_smp_pkey_ready+0x5c>)
   34008:	6018      	str	r0, [r3, #0]
	if (!pkey) {
   3400a:	b1f0      	cbz	r0, 3404a <bt_smp_pkey_ready+0x46>
	z_impl_k_sem_give(sem);
   3400c:	4815      	ldr	r0, [pc, #84]	; (34064 <bt_smp_pkey_ready+0x60>)
   3400e:	4c16      	ldr	r4, [pc, #88]	; (34068 <bt_smp_pkey_ready+0x64>)
   34010:	f013 f8b2 	bl	47178 <z_impl_k_sem_give>
	for (i = 0; i < ARRAY_SIZE(bt_smp_pool); i++) {
   34014:	2500      	movs	r5, #0
		if (!atomic_test_bit(smp->flags, SMP_FLAG_PKEY_SEND)) {
   34016:	2106      	movs	r1, #6
   34018:	1d20      	adds	r0, r4, #4
   3401a:	f019 ff46 	bl	4deaa <atomic_test_bit>
   3401e:	b178      	cbz	r0, 34040 <bt_smp_pkey_ready+0x3c>
		    smp->chan.chan.conn->role == BT_HCI_ROLE_CENTRAL) {
   34020:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
		if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
   34024:	78db      	ldrb	r3, [r3, #3]
			err = sc_send_public_key(smp);
   34026:	4620      	mov	r0, r4
		if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
   34028:	b983      	cbnz	r3, 3404c <bt_smp_pkey_ready+0x48>
			err = sc_send_public_key(smp);
   3402a:	f7ff fb5f 	bl	336ec <sc_send_public_key>
			if (err) {
   3402e:	4601      	mov	r1, r0
   34030:	b110      	cbz	r0, 34038 <bt_smp_pkey_ready+0x34>
				smp_error(smp, err);
   34032:	4620      	mov	r0, r4
   34034:	f01a fc12 	bl	4e85c <smp_error>
			atomic_set_bit(smp->allowed_cmds,
   34038:	210c      	movs	r1, #12
   3403a:	4620      	mov	r0, r4
   3403c:	f01a f884 	bl	4e148 <atomic_set_bit>
	for (i = 0; i < ARRAY_SIZE(bt_smp_pool); i++) {
   34040:	3501      	adds	r5, #1
   34042:	2d06      	cmp	r5, #6
   34044:	f504 74d8 	add.w	r4, r4, #432	; 0x1b0
   34048:	d1e5      	bne.n	34016 <bt_smp_pkey_ready+0x12>
}
   3404a:	bd38      	pop	{r3, r4, r5, pc}
		err = smp_public_key_periph(smp);
   3404c:	f7ff fc92 	bl	33974 <smp_public_key_periph>
		if (err) {
   34050:	4601      	mov	r1, r0
   34052:	2800      	cmp	r0, #0
   34054:	d0f4      	beq.n	34040 <bt_smp_pkey_ready+0x3c>
			smp_error(smp, err);
   34056:	4620      	mov	r0, r4
   34058:	f01a fc00 	bl	4e85c <smp_error>
   3405c:	e7f0      	b.n	34040 <bt_smp_pkey_ready+0x3c>
   3405e:	bf00      	nop
   34060:	200041d4 	.word	0x200041d4
   34064:	20001284 	.word	0x20001284
   34068:	20001dc0 	.word	0x20001dc0

0003406c <bt_smp_encrypt_change>:
{
   3406c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct bt_conn *conn = chan->conn;
   34070:	4605      	mov	r5, r0
	if (!atomic_test_and_clear_bit(smp->flags, SMP_FLAG_ENC_PENDING)) {
   34072:	f1a0 06e8 	sub.w	r6, r0, #232	; 0xe8
{
   34076:	4604      	mov	r4, r0
   34078:	460f      	mov	r7, r1
	if (!atomic_test_and_clear_bit(smp->flags, SMP_FLAG_ENC_PENDING)) {
   3407a:	4630      	mov	r0, r6
   3407c:	2101      	movs	r1, #1
	struct bt_conn *conn = chan->conn;
   3407e:	f855 89ec 	ldr.w	r8, [r5], #-236
	if (!atomic_test_and_clear_bit(smp->flags, SMP_FLAG_ENC_PENDING)) {
   34082:	f01a fa8f 	bl	4e5a4 <atomic_test_and_clear_bit>
   34086:	2800      	cmp	r0, #0
   34088:	d05f      	beq.n	3414a <bt_smp_encrypt_change+0xde>
	if (hci_status) {
   3408a:	b1cf      	cbz	r7, 340c0 <bt_smp_encrypt_change+0x54>
		if (atomic_test_bit(smp->flags, SMP_FLAG_PAIRING)) {
   3408c:	2103      	movs	r1, #3
   3408e:	4630      	mov	r0, r6
   34090:	f019 ff0b 	bl	4deaa <atomic_test_bit>
   34094:	2800      	cmp	r0, #0
   34096:	d058      	beq.n	3414a <bt_smp_encrypt_change+0xde>
			uint8_t smp_err = smp_err_get(
   34098:	4638      	mov	r0, r7
   3409a:	f7fa fa01 	bl	2e4a0 <bt_security_err_get>
	switch (auth_err) {
   3409e:	3801      	subs	r0, #1
   340a0:	b2c0      	uxtb	r0, r0
   340a2:	2808      	cmp	r0, #8
   340a4:	bf9a      	itte	ls
   340a6:	4b2e      	ldrls	r3, [pc, #184]	; (34160 <bt_smp_encrypt_change+0xf4>)
   340a8:	5c1c      	ldrbls	r4, [r3, r0]
			uint8_t smp_err = smp_err_get(
   340aa:	2400      	movhi	r4, #0
			atomic_set_bit(smp->flags, SMP_FLAG_KEYS_DISTR);
   340ac:	2102      	movs	r1, #2
   340ae:	4630      	mov	r0, r6
   340b0:	f01a f84a 	bl	4e148 <atomic_set_bit>
			smp_pairing_complete(smp, smp_err);
   340b4:	4621      	mov	r1, r4
		smp_pairing_complete(smp, 0);
   340b6:	4628      	mov	r0, r5
}
   340b8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		smp_pairing_complete(smp, 0);
   340bc:	f7ff bee2 	b.w	33e84 <smp_pairing_complete>
	if (!conn->encrypt) {
   340c0:	f898 300b 	ldrb.w	r3, [r8, #11]
   340c4:	2b00      	cmp	r3, #0
   340c6:	d040      	beq.n	3414a <bt_smp_encrypt_change+0xde>
	if (!atomic_test_bit(smp->flags, SMP_FLAG_PAIRING)) {
   340c8:	2103      	movs	r1, #3
   340ca:	4630      	mov	r0, r6
   340cc:	f019 feed 	bl	4deaa <atomic_test_bit>
   340d0:	b920      	cbnz	r0, 340dc <bt_smp_encrypt_change+0x70>
		smp_reset(smp);
   340d2:	4628      	mov	r0, r5
}
   340d4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		smp_reset(smp);
   340d8:	f01a ba7a 	b.w	4e5d0 <smp_reset>
	if (atomic_test_bit(smp->flags, SMP_FLAG_SC)) {
   340dc:	2105      	movs	r1, #5
   340de:	4630      	mov	r0, r6
   340e0:	f019 fee3 	bl	4deaa <atomic_test_bit>
   340e4:	b1b8      	cbz	r0, 34116 <bt_smp_encrypt_change+0xaa>
		if ((smp->local_dist & BT_SMP_DIST_LINK_KEY) &&
   340e6:	f814 3c04 	ldrb.w	r3, [r4, #-4]
   340ea:	071f      	lsls	r7, r3, #28
   340ec:	d507      	bpl.n	340fe <bt_smp_encrypt_change+0x92>
   340ee:	f814 3c03 	ldrb.w	r3, [r4, #-3]
   340f2:	0718      	lsls	r0, r3, #28
   340f4:	d503      	bpl.n	340fe <bt_smp_encrypt_change+0x92>
			atomic_set_bit(smp->flags, SMP_FLAG_DERIVE_LK);
   340f6:	2111      	movs	r1, #17
   340f8:	4630      	mov	r0, r6
   340fa:	f01a f825 	bl	4e148 <atomic_set_bit>
		smp->local_dist &= ~BT_SMP_DIST_LINK_KEY;
   340fe:	f814 3c04 	ldrb.w	r3, [r4, #-4]
   34102:	f023 0308 	bic.w	r3, r3, #8
   34106:	f804 3c04 	strb.w	r3, [r4, #-4]
		smp->remote_dist &= ~BT_SMP_DIST_LINK_KEY;
   3410a:	f814 3c03 	ldrb.w	r3, [r4, #-3]
   3410e:	f023 0308 	bic.w	r3, r3, #8
   34112:	f804 3c03 	strb.w	r3, [r4, #-3]
	if (smp->remote_dist & BT_SMP_DIST_ENC_KEY) {
   34116:	f814 3c03 	ldrb.w	r3, [r4, #-3]
   3411a:	07d9      	lsls	r1, r3, #31
   3411c:	d517      	bpl.n	3414e <bt_smp_encrypt_change+0xe2>
		atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_ENCRYPT_INFO);
   3411e:	2106      	movs	r1, #6
		atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_SIGNING_INFO);
   34120:	4628      	mov	r0, r5
   34122:	f01a f811 	bl	4e148 <atomic_set_bit>
	atomic_set_bit(smp->flags, SMP_FLAG_KEYS_DISTR);
   34126:	2102      	movs	r1, #2
   34128:	4630      	mov	r0, r6
   3412a:	f01a f80d 	bl	4e148 <atomic_set_bit>
	if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
   3412e:	f898 3003 	ldrb.w	r3, [r8, #3]
   34132:	b913      	cbnz	r3, 3413a <bt_smp_encrypt_change+0xce>
	    conn->role == BT_HCI_ROLE_CENTRAL && smp->remote_dist) {
   34134:	f814 3c03 	ldrb.w	r3, [r4, #-3]
   34138:	b93b      	cbnz	r3, 3414a <bt_smp_encrypt_change+0xde>
	struct bt_keys *keys = conn->le.keys;
   3413a:	6823      	ldr	r3, [r4, #0]
	if (!keys) {
   3413c:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
   34140:	b11b      	cbz	r3, 3414a <bt_smp_encrypt_change+0xde>
	if (!smp->local_dist && !smp->remote_dist) {
   34142:	f834 1c04 	ldrh.w	r1, [r4, #-4]
   34146:	2900      	cmp	r1, #0
   34148:	d0b5      	beq.n	340b6 <bt_smp_encrypt_change+0x4a>
}
   3414a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	} else if (smp->remote_dist & BT_SMP_DIST_ID_KEY) {
   3414e:	079a      	lsls	r2, r3, #30
   34150:	d501      	bpl.n	34156 <bt_smp_encrypt_change+0xea>
		atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_IDENT_INFO);
   34152:	2108      	movs	r1, #8
   34154:	e7e4      	b.n	34120 <bt_smp_encrypt_change+0xb4>
	} else if (smp->remote_dist & BT_SMP_DIST_SIGN) {
   34156:	075b      	lsls	r3, r3, #29
   34158:	d5e5      	bpl.n	34126 <bt_smp_encrypt_change+0xba>
		atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_SIGNING_INFO);
   3415a:	210a      	movs	r1, #10
   3415c:	e7e0      	b.n	34120 <bt_smp_encrypt_change+0xb4>
   3415e:	bf00      	nop
   34160:	000537a4 	.word	0x000537a4

00034164 <bt_smp_init>:
BT_L2CAP_CHANNEL_DEFINE(smp_br_fixed_chan, BT_L2CAP_CID_BR_SMP,
			bt_smp_br_accept, NULL);
#endif /* CONFIG_BT_BREDR */

int bt_smp_init(void)
{
   34164:	b508      	push	{r3, lr}
	return BT_CMD_TEST(bt_dev.supported_commands, 34, 1) &&
   34166:	4b0a      	ldr	r3, [pc, #40]	; (34190 <bt_smp_init+0x2c>)
   34168:	f893 309a 	ldrb.w	r3, [r3, #154]	; 0x9a
   3416c:	f003 0306 	and.w	r3, r3, #6
   34170:	2b06      	cmp	r3, #6
   34172:	4b08      	ldr	r3, [pc, #32]	; (34194 <bt_smp_init+0x30>)
   34174:	bf0c      	ite	eq
   34176:	2201      	moveq	r2, #1
   34178:	2200      	movne	r2, #0
   3417a:	701a      	strb	r2, [r3, #0]
	static struct bt_pub_key_cb pub_key_cb = {
		.func           = bt_smp_pkey_ready,
	};

	sc_supported = le_sc_supported();
	if (IS_ENABLED(CONFIG_BT_SMP_SC_PAIR_ONLY) && !sc_supported) {
   3417c:	d104      	bne.n	34188 <bt_smp_init+0x24>
	}

	BT_DBG("LE SC %s", sc_supported ? "enabled" : "disabled");

	if (!IS_ENABLED(CONFIG_BT_SMP_OOB_LEGACY_PAIR_ONLY)) {
		bt_pub_key_gen(&pub_key_cb);
   3417e:	4806      	ldr	r0, [pc, #24]	; (34198 <bt_smp_init+0x34>)
   34180:	f7fb fb38 	bl	2f7f4 <bt_pub_key_gen>
	}

	return smp_self_test();
   34184:	2000      	movs	r0, #0
}
   34186:	bd08      	pop	{r3, pc}
		return -ENOENT;
   34188:	f06f 0001 	mvn.w	r0, #1
   3418c:	e7fb      	b.n	34186 <bt_smp_init+0x22>
   3418e:	bf00      	nop
   34190:	20000030 	.word	0x20000030
   34194:	20006ba8 	.word	0x20006ba8
   34198:	20000768 	.word	0x20000768

0003419c <bt_keys_get_addr>:
	return kdata.in_use;
}
#endif /* CONFIG_BT_KEYS_OVERWRITE_OLDEST */

struct bt_keys *bt_keys_get_addr(uint8_t id, const bt_addr_le_t *addr)
{
   3419c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   341a0:	4e1b      	ldr	r6, [pc, #108]	; (34210 <bt_keys_get_addr+0x74>)
	return memcmp(a, b, sizeof(*a));
   341a2:	f8df 9070 	ldr.w	r9, [pc, #112]	; 34214 <bt_keys_get_addr+0x78>
   341a6:	4680      	mov	r8, r0
   341a8:	460f      	mov	r7, r1

	__ASSERT_NO_MSG(addr != NULL);

	BT_DBG("%s", bt_addr_le_str(addr));

	for (i = 0; i < ARRAY_SIZE(key_pool); i++) {
   341aa:	2500      	movs	r5, #0
	size_t first_free_slot = ARRAY_SIZE(key_pool);
   341ac:	2406      	movs	r4, #6
		keys = &key_pool[i];

		if (keys->id == id && !bt_addr_le_cmp(&keys->addr, addr)) {
   341ae:	f816 3c01 	ldrb.w	r3, [r6, #-1]
   341b2:	4543      	cmp	r3, r8
   341b4:	d01d      	beq.n	341f2 <bt_keys_get_addr+0x56>
			return keys;
		}
		if (first_free_slot == ARRAY_SIZE(key_pool) &&
   341b6:	2c06      	cmp	r4, #6
   341b8:	d107      	bne.n	341ca <bt_keys_get_addr+0x2e>
   341ba:	2207      	movs	r2, #7
   341bc:	4649      	mov	r1, r9
   341be:	4630      	mov	r0, r6
   341c0:	f016 fe4b 	bl	4ae5a <memcmp>
   341c4:	2800      	cmp	r0, #0
   341c6:	bf08      	it	eq
   341c8:	462c      	moveq	r4, r5
	for (i = 0; i < ARRAY_SIZE(key_pool); i++) {
   341ca:	3501      	adds	r5, #1
   341cc:	2d06      	cmp	r5, #6
   341ce:	f106 0640 	add.w	r6, r6, #64	; 0x40
   341d2:	d1ec      	bne.n	341ae <bt_keys_get_addr+0x12>
			first_free_slot = oldest - &key_pool[0];
		}
	}

#endif  /* CONFIG_BT_KEYS_OVERWRITE_OLDEST */
	if (first_free_slot < ARRAY_SIZE(key_pool)) {
   341d4:	2c06      	cmp	r4, #6
   341d6:	d019      	beq.n	3420c <bt_keys_get_addr+0x70>
		keys = &key_pool[first_free_slot];
   341d8:	480f      	ldr	r0, [pc, #60]	; (34218 <bt_keys_get_addr+0x7c>)
   341da:	01a3      	lsls	r3, r4, #6
	memcpy(dst, src, sizeof(*dst));
   341dc:	2207      	movs	r2, #7
		keys->id = id;
   341de:	f800 8003 	strb.w	r8, [r0, r3]
		bt_addr_le_copy(&keys->addr, addr);
   341e2:	3301      	adds	r3, #1
		keys = &key_pool[first_free_slot];
   341e4:	eb00 1484 	add.w	r4, r0, r4, lsl #6
   341e8:	4639      	mov	r1, r7
   341ea:	4418      	add	r0, r3
   341ec:	f016 fe45 	bl	4ae7a <memcpy>
}
   341f0:	e009      	b.n	34206 <bt_keys_get_addr+0x6a>
	return memcmp(a, b, sizeof(*a));
   341f2:	2207      	movs	r2, #7
   341f4:	4639      	mov	r1, r7
   341f6:	4630      	mov	r0, r6
   341f8:	f016 fe2f 	bl	4ae5a <memcmp>
		if (keys->id == id && !bt_addr_le_cmp(&keys->addr, addr)) {
   341fc:	2800      	cmp	r0, #0
   341fe:	d1da      	bne.n	341b6 <bt_keys_get_addr+0x1a>
		keys = &key_pool[i];
   34200:	4c05      	ldr	r4, [pc, #20]	; (34218 <bt_keys_get_addr+0x7c>)
   34202:	eb04 1485 	add.w	r4, r4, r5, lsl #6
	}

	BT_DBG("unable to create keys for %s", bt_addr_le_str(addr));

	return NULL;
}
   34206:	4620      	mov	r0, r4
   34208:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	return NULL;
   3420c:	2400      	movs	r4, #0
   3420e:	e7fa      	b.n	34206 <bt_keys_get_addr+0x6a>
   34210:	200041d9 	.word	0x200041d9
   34214:	00053517 	.word	0x00053517
   34218:	200041d8 	.word	0x200041d8

0003421c <bt_foreach_bond>:

void bt_foreach_bond(uint8_t id, void (*func)(const struct bt_bond_info *info,
					   void *user_data),
		     void *user_data)
{
   3421c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   34220:	4c0d      	ldr	r4, [pc, #52]	; (34258 <bt_foreach_bond+0x3c>)
   34222:	4605      	mov	r5, r0
   34224:	460e      	mov	r6, r1
   34226:	4617      	mov	r7, r2
   34228:	f504 78c0 	add.w	r8, r4, #384	; 0x180
	__ASSERT_NO_MSG(func != NULL);

	for (i = 0; i < ARRAY_SIZE(key_pool); i++) {
		struct bt_keys *keys = &key_pool[i];

		if (keys->keys && keys->id == id) {
   3422c:	f8b4 300d 	ldrh.w	r3, [r4, #13]
   34230:	b15b      	cbz	r3, 3424a <bt_foreach_bond+0x2e>
   34232:	f814 3c01 	ldrb.w	r3, [r4, #-1]
   34236:	42ab      	cmp	r3, r5
   34238:	d107      	bne.n	3424a <bt_foreach_bond+0x2e>
	memcpy(dst, src, sizeof(*dst));
   3423a:	4621      	mov	r1, r4
   3423c:	2207      	movs	r2, #7
   3423e:	4668      	mov	r0, sp
   34240:	f016 fe1b 	bl	4ae7a <memcpy>
			struct bt_bond_info info;

			bt_addr_le_copy(&info.addr, &keys->addr);
			func(&info, user_data);
   34244:	4639      	mov	r1, r7
   34246:	4668      	mov	r0, sp
   34248:	47b0      	blx	r6
	for (i = 0; i < ARRAY_SIZE(key_pool); i++) {
   3424a:	3440      	adds	r4, #64	; 0x40
   3424c:	4544      	cmp	r4, r8
   3424e:	d1ed      	bne.n	3422c <bt_foreach_bond+0x10>
		}
	}
}
   34250:	b002      	add	sp, #8
   34252:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   34256:	bf00      	nop
   34258:	200041d9 	.word	0x200041d9

0003425c <bt_keys_foreach_type>:

void bt_keys_foreach_type(enum bt_keys_type type, void (*func)(struct bt_keys *keys, void *data),
			  void *data)
{
   3425c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   34260:	4c08      	ldr	r4, [pc, #32]	; (34284 <bt_keys_foreach_type+0x28>)
   34262:	4605      	mov	r5, r0
   34264:	460e      	mov	r6, r1
   34266:	4617      	mov	r7, r2
   34268:	f504 78c0 	add.w	r8, r4, #384	; 0x180
	int i;

	__ASSERT_NO_MSG(func != NULL);

	for (i = 0; i < ARRAY_SIZE(key_pool); i++) {
		if ((key_pool[i].keys & type)) {
   3426c:	89e3      	ldrh	r3, [r4, #14]
   3426e:	422b      	tst	r3, r5
   34270:	d002      	beq.n	34278 <bt_keys_foreach_type+0x1c>
			func(&key_pool[i], data);
   34272:	4639      	mov	r1, r7
   34274:	4620      	mov	r0, r4
   34276:	47b0      	blx	r6
	for (i = 0; i < ARRAY_SIZE(key_pool); i++) {
   34278:	3440      	adds	r4, #64	; 0x40
   3427a:	4544      	cmp	r4, r8
   3427c:	d1f6      	bne.n	3426c <bt_keys_foreach_type+0x10>
		}
	}
}
   3427e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   34282:	bf00      	nop
   34284:	200041d8 	.word	0x200041d8

00034288 <keys_commit>:

	bt_id_add(keys);
}

static int keys_commit(void)
{
   34288:	b508      	push	{r3, lr}
	 * the keys were already removed.
	 */
	if (IS_ENABLED(CONFIG_BT_CENTRAL) && IS_ENABLED(CONFIG_BT_PRIVACY)) {
		bt_keys_foreach_type(BT_KEYS_ALL, id_add, NULL);
	} else {
		bt_keys_foreach_type(BT_KEYS_IRK, id_add, NULL);
   3428a:	4903      	ldr	r1, [pc, #12]	; (34298 <keys_commit+0x10>)
   3428c:	2200      	movs	r2, #0
   3428e:	2002      	movs	r0, #2
   34290:	f7ff ffe4 	bl	3425c <bt_keys_foreach_type>
	}

	return 0;
}
   34294:	2000      	movs	r0, #0
   34296:	bd08      	pop	{r3, pc}
   34298:	0004ec35 	.word	0x0004ec35

0003429c <bt_keys_find>:
{
   3429c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   342a0:	4d0f      	ldr	r5, [pc, #60]	; (342e0 <bt_keys_find+0x44>)
   342a2:	4606      	mov	r6, r0
   342a4:	460f      	mov	r7, r1
   342a6:	4690      	mov	r8, r2
   342a8:	2400      	movs	r4, #0
		if ((key_pool[i].keys & type) && key_pool[i].id == id &&
   342aa:	f8b5 300d 	ldrh.w	r3, [r5, #13]
   342ae:	4233      	tst	r3, r6
   342b0:	d00d      	beq.n	342ce <bt_keys_find+0x32>
   342b2:	f815 3c01 	ldrb.w	r3, [r5, #-1]
   342b6:	42bb      	cmp	r3, r7
   342b8:	d109      	bne.n	342ce <bt_keys_find+0x32>
	return memcmp(a, b, sizeof(*a));
   342ba:	2207      	movs	r2, #7
   342bc:	4641      	mov	r1, r8
   342be:	4628      	mov	r0, r5
   342c0:	f016 fdcb 	bl	4ae5a <memcmp>
   342c4:	b918      	cbnz	r0, 342ce <bt_keys_find+0x32>
			return &key_pool[i];
   342c6:	4807      	ldr	r0, [pc, #28]	; (342e4 <bt_keys_find+0x48>)
   342c8:	4420      	add	r0, r4
}
   342ca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	for (i = 0; i < ARRAY_SIZE(key_pool); i++) {
   342ce:	3440      	adds	r4, #64	; 0x40
   342d0:	f5b4 7fc0 	cmp.w	r4, #384	; 0x180
   342d4:	f105 0540 	add.w	r5, r5, #64	; 0x40
   342d8:	d1e7      	bne.n	342aa <bt_keys_find+0xe>
	return NULL;
   342da:	2000      	movs	r0, #0
   342dc:	e7f5      	b.n	342ca <bt_keys_find+0x2e>
   342de:	bf00      	nop
   342e0:	200041d9 	.word	0x200041d9
   342e4:	200041d8 	.word	0x200041d8

000342e8 <bt_keys_find_irk>:
{
   342e8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (addr->type != BT_ADDR_LE_RANDOM) {
   342ec:	780b      	ldrb	r3, [r1, #0]
   342ee:	2b01      	cmp	r3, #1
   342f0:	4607      	mov	r7, r0
   342f2:	460d      	mov	r5, r1
   342f4:	d002      	beq.n	342fc <bt_keys_find_irk+0x14>
		return NULL;
   342f6:	2000      	movs	r0, #0
}
   342f8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (!bt_addr_le_is_rpa(addr)) {
   342fc:	798b      	ldrb	r3, [r1, #6]
   342fe:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   34302:	2b40      	cmp	r3, #64	; 0x40
   34304:	d1f7      	bne.n	342f6 <bt_keys_find_irk+0xe>
   34306:	4e1e      	ldr	r6, [pc, #120]	; (34380 <bt_keys_find_irk+0x98>)
   34308:	2400      	movs	r4, #0
		    !bt_addr_cmp(&addr->a, &key_pool[i].irk.rpa)) {
   3430a:	f101 0801 	add.w	r8, r1, #1
		if (!(key_pool[i].keys & BT_KEYS_IRK)) {
   3430e:	f836 3c2c 	ldrh.w	r3, [r6, #-44]
   34312:	079a      	lsls	r2, r3, #30
   34314:	d50c      	bpl.n	34330 <bt_keys_find_irk+0x48>
		if (key_pool[i].id == id &&
   34316:	f816 3c3a 	ldrb.w	r3, [r6, #-58]
   3431a:	42bb      	cmp	r3, r7
   3431c:	d108      	bne.n	34330 <bt_keys_find_irk+0x48>
	return memcmp(a, b, sizeof(*a));
   3431e:	2206      	movs	r2, #6
   34320:	4631      	mov	r1, r6
   34322:	4640      	mov	r0, r8
   34324:	f016 fd99 	bl	4ae5a <memcmp>
   34328:	b910      	cbnz	r0, 34330 <bt_keys_find_irk+0x48>
			return &key_pool[i];
   3432a:	4816      	ldr	r0, [pc, #88]	; (34384 <bt_keys_find_irk+0x9c>)
   3432c:	4420      	add	r0, r4
   3432e:	e7e3      	b.n	342f8 <bt_keys_find_irk+0x10>
	for (i = 0; i < ARRAY_SIZE(key_pool); i++) {
   34330:	3440      	adds	r4, #64	; 0x40
   34332:	f5b4 7fc0 	cmp.w	r4, #384	; 0x180
   34336:	f106 0640 	add.w	r6, r6, #64	; 0x40
   3433a:	d1e8      	bne.n	3430e <bt_keys_find_irk+0x26>
   3433c:	4e12      	ldr	r6, [pc, #72]	; (34388 <bt_keys_find_irk+0xa0>)
   3433e:	2400      	movs	r4, #0
		if (bt_rpa_irk_matches(key_pool[i].irk.val, &addr->a)) {
   34340:	3501      	adds	r5, #1
		if (!(key_pool[i].keys & BT_KEYS_IRK)) {
   34342:	f836 3c1c 	ldrh.w	r3, [r6, #-28]
   34346:	079b      	lsls	r3, r3, #30
   34348:	d512      	bpl.n	34370 <bt_keys_find_irk+0x88>
		if (key_pool[i].id != id) {
   3434a:	f816 3c2a 	ldrb.w	r3, [r6, #-42]
   3434e:	42bb      	cmp	r3, r7
   34350:	d10e      	bne.n	34370 <bt_keys_find_irk+0x88>
		if (bt_rpa_irk_matches(key_pool[i].irk.val, &addr->a)) {
   34352:	4629      	mov	r1, r5
   34354:	4630      	mov	r0, r6
   34356:	f016 fdc3 	bl	4aee0 <bt_rpa_irk_matches>
   3435a:	b148      	cbz	r0, 34370 <bt_keys_find_irk+0x88>
			bt_addr_copy(&key_pool[i].irk.rpa, &addr->a);
   3435c:	4e09      	ldr	r6, [pc, #36]	; (34384 <bt_keys_find_irk+0x9c>)
   3435e:	f104 003a 	add.w	r0, r4, #58	; 0x3a
	memcpy(dst, src, sizeof(*dst));
   34362:	2206      	movs	r2, #6
   34364:	4629      	mov	r1, r5
   34366:	4430      	add	r0, r6
   34368:	f016 fd87 	bl	4ae7a <memcpy>
			return &key_pool[i];
   3436c:	19a0      	adds	r0, r4, r6
   3436e:	e7c3      	b.n	342f8 <bt_keys_find_irk+0x10>
	for (i = 0; i < ARRAY_SIZE(key_pool); i++) {
   34370:	3440      	adds	r4, #64	; 0x40
   34372:	f5b4 7fc0 	cmp.w	r4, #384	; 0x180
   34376:	f106 0640 	add.w	r6, r6, #64	; 0x40
   3437a:	d1e2      	bne.n	34342 <bt_keys_find_irk+0x5a>
   3437c:	e7bb      	b.n	342f6 <bt_keys_find_irk+0xe>
   3437e:	bf00      	nop
   34380:	20004212 	.word	0x20004212
   34384:	200041d8 	.word	0x200041d8
   34388:	20004202 	.word	0x20004202

0003438c <bt_keys_find_addr>:
{
   3438c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   3438e:	4d0c      	ldr	r5, [pc, #48]	; (343c0 <bt_keys_find_addr+0x34>)
   34390:	4606      	mov	r6, r0
   34392:	460f      	mov	r7, r1
   34394:	2400      	movs	r4, #0
		if (key_pool[i].id == id &&
   34396:	f815 3c01 	ldrb.w	r3, [r5, #-1]
   3439a:	42b3      	cmp	r3, r6
   3439c:	d108      	bne.n	343b0 <bt_keys_find_addr+0x24>
	return memcmp(a, b, sizeof(*a));
   3439e:	2207      	movs	r2, #7
   343a0:	4639      	mov	r1, r7
   343a2:	4628      	mov	r0, r5
   343a4:	f016 fd59 	bl	4ae5a <memcmp>
   343a8:	b910      	cbnz	r0, 343b0 <bt_keys_find_addr+0x24>
			return &key_pool[i];
   343aa:	4806      	ldr	r0, [pc, #24]	; (343c4 <bt_keys_find_addr+0x38>)
   343ac:	4420      	add	r0, r4
}
   343ae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	for (i = 0; i < ARRAY_SIZE(key_pool); i++) {
   343b0:	3440      	adds	r4, #64	; 0x40
   343b2:	f5b4 7fc0 	cmp.w	r4, #384	; 0x180
   343b6:	f105 0540 	add.w	r5, r5, #64	; 0x40
   343ba:	d1ec      	bne.n	34396 <bt_keys_find_addr+0xa>
	return NULL;
   343bc:	2000      	movs	r0, #0
   343be:	e7f6      	b.n	343ae <bt_keys_find_addr+0x22>
   343c0:	200041d9 	.word	0x200041d9
   343c4:	200041d8 	.word	0x200041d8

000343c8 <bt_keys_clear>:
{
   343c8:	b570      	push	{r4, r5, r6, lr}
	if (keys->state & BT_KEYS_ID_ADDED) {
   343ca:	7a03      	ldrb	r3, [r0, #8]
   343cc:	075b      	lsls	r3, r3, #29
{
   343ce:	b08c      	sub	sp, #48	; 0x30
   343d0:	4604      	mov	r4, r0
	if (keys->state & BT_KEYS_ID_ADDED) {
   343d2:	d501      	bpl.n	343d8 <bt_keys_clear+0x10>
		bt_id_del(keys);
   343d4:	f7fa fb5e 	bl	2ea94 <bt_id_del>
		if (keys->id) {
   343d8:	4625      	mov	r5, r4
   343da:	f815 2b01 	ldrb.w	r2, [r5], #1
   343de:	b1b2      	cbz	r2, 3440e <bt_keys_clear+0x46>
			u8_to_dec(id, sizeof(id), keys->id);
   343e0:	ae02      	add	r6, sp, #8
   343e2:	2104      	movs	r1, #4
   343e4:	4630      	mov	r0, r6
   343e6:	f014 fa92 	bl	4890e <u8_to_dec>
			bt_settings_encode_key(key, sizeof(key), "keys",
   343ea:	9600      	str	r6, [sp, #0]
			bt_settings_encode_key(key, sizeof(key), "keys",
   343ec:	4a09      	ldr	r2, [pc, #36]	; (34414 <bt_keys_clear+0x4c>)
   343ee:	462b      	mov	r3, r5
   343f0:	2124      	movs	r1, #36	; 0x24
   343f2:	a803      	add	r0, sp, #12
   343f4:	f7f9 f9f8 	bl	2d7e8 <bt_settings_encode_key>
		settings_delete(key);
   343f8:	a803      	add	r0, sp, #12
   343fa:	f015 f98a 	bl	49712 <settings_delete>
	(void)memset(keys, 0, sizeof(*keys));
   343fe:	2240      	movs	r2, #64	; 0x40
   34400:	2100      	movs	r1, #0
   34402:	4620      	mov	r0, r4
}
   34404:	b00c      	add	sp, #48	; 0x30
   34406:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	(void)memset(keys, 0, sizeof(*keys));
   3440a:	f016 bd41 	b.w	4ae90 <memset>
			bt_settings_encode_key(key, sizeof(key), "keys",
   3440e:	9200      	str	r2, [sp, #0]
   34410:	e7ec      	b.n	343ec <bt_keys_clear+0x24>
   34412:	bf00      	nop
   34414:	000537e8 	.word	0x000537e8

00034418 <bt_keys_store>:
{
   34418:	b570      	push	{r4, r5, r6, lr}
	if (keys->id) {
   3441a:	4605      	mov	r5, r0
{
   3441c:	b08c      	sub	sp, #48	; 0x30
	if (keys->id) {
   3441e:	f815 2b01 	ldrb.w	r2, [r5], #1
{
   34422:	4604      	mov	r4, r0
	if (keys->id) {
   34424:	b19a      	cbz	r2, 3444e <bt_keys_store+0x36>
		u8_to_dec(id, sizeof(id), keys->id);
   34426:	ae02      	add	r6, sp, #8
   34428:	2104      	movs	r1, #4
   3442a:	4630      	mov	r0, r6
   3442c:	f014 fa6f 	bl	4890e <u8_to_dec>
		bt_settings_encode_key(key, sizeof(key), "keys", &keys->addr,
   34430:	9600      	str	r6, [sp, #0]
		bt_settings_encode_key(key, sizeof(key), "keys", &keys->addr,
   34432:	462b      	mov	r3, r5
   34434:	a803      	add	r0, sp, #12
   34436:	4a07      	ldr	r2, [pc, #28]	; (34454 <bt_keys_store+0x3c>)
   34438:	2124      	movs	r1, #36	; 0x24
   3443a:	f7f9 f9d5 	bl	2d7e8 <bt_settings_encode_key>
	err = settings_save_one(key, keys->storage_start, BT_KEYS_STORAGE_LEN);
   3443e:	2234      	movs	r2, #52	; 0x34
   34440:	f104 010c 	add.w	r1, r4, #12
   34444:	a803      	add	r0, sp, #12
   34446:	f7f8 f829 	bl	2c49c <settings_save_one>
}
   3444a:	b00c      	add	sp, #48	; 0x30
   3444c:	bd70      	pop	{r4, r5, r6, pc}
		bt_settings_encode_key(key, sizeof(key), "keys", &keys->addr,
   3444e:	9200      	str	r2, [sp, #0]
   34450:	e7ef      	b.n	34432 <bt_keys_store+0x1a>
   34452:	bf00      	nop
   34454:	000537e8 	.word	0x000537e8

00034458 <mem_init>:

#include "mem.h"

void mem_init(void *mem_pool, uint16_t mem_size, uint16_t mem_count,
	      void **mem_head)
{
   34458:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   3445c:	4616      	mov	r6, r2
	*mem_head = mem_pool;

	/* Store free mem_count after the list's next pointer at an 32-bit
	 * aligned memory location to ensure atomic read/write (in ARM for now).
	 */
	*((uint16_t *)MROUND((uint8_t *)mem_pool + sizeof(mem_pool))) = mem_count;
   3445e:	1dc2      	adds	r2, r0, #7
   34460:	f022 0203 	bic.w	r2, r2, #3

	/* Initialize next pointers to form a free list,
	 * next pointer is stored in the first 32-bit of each block
	 */
	(void)memset(((uint8_t *)mem_pool + (mem_size * (--mem_count))), 0,
   34464:	1e75      	subs	r5, r6, #1
{
   34466:	460f      	mov	r7, r1
	(void)memset(((uint8_t *)mem_pool + (mem_size * (--mem_count))), 0,
   34468:	b2ad      	uxth	r5, r5
	*mem_head = mem_pool;
   3446a:	6018      	str	r0, [r3, #0]
{
   3446c:	b082      	sub	sp, #8
   3446e:	4604      	mov	r4, r0
	*((uint16_t *)MROUND((uint8_t *)mem_pool + sizeof(mem_pool))) = mem_count;
   34470:	8016      	strh	r6, [r2, #0]
	(void)memset(((uint8_t *)mem_pool + (mem_size * (--mem_count))), 0,
   34472:	2100      	movs	r1, #0
   34474:	2204      	movs	r2, #4
   34476:	fb07 0005 	mla	r0, r7, r5, r0
   3447a:	f016 fd09 	bl	4ae90 <memset>
		     sizeof(mem_pool));
	while (mem_count--) {
   3447e:	b1bd      	cbz	r5, 344b0 <mem_init+0x58>
   34480:	3e02      	subs	r6, #2
   34482:	b2b6      	uxth	r6, r6
   34484:	fb06 7307 	mla	r3, r6, r7, r7
   34488:	fb06 f807 	mul.w	r8, r6, r7
   3448c:	441c      	add	r4, r3
   3448e:	eba8 0803 	sub.w	r8, r8, r3
   34492:	2500      	movs	r5, #0
		uint32_t next;

		next = (uint32_t)((uint8_t *) mem_pool +
			       (mem_size * (mem_count + 1)));
		memcpy(((uint8_t *)mem_pool + (mem_size * mem_count)),
   34494:	2204      	movs	r2, #4
   34496:	eb04 0008 	add.w	r0, r4, r8
   3449a:	eb0d 0102 	add.w	r1, sp, r2
		next = (uint32_t)((uint8_t *) mem_pool +
   3449e:	9401      	str	r4, [sp, #4]
		memcpy(((uint8_t *)mem_pool + (mem_size * mem_count)),
   344a0:	f016 fceb 	bl	4ae7a <memcpy>
	while (mem_count--) {
   344a4:	42b5      	cmp	r5, r6
   344a6:	eba4 0407 	sub.w	r4, r4, r7
   344aa:	f105 0501 	add.w	r5, r5, #1
   344ae:	d1f1      	bne.n	34494 <mem_init+0x3c>
		       (void *)&next, sizeof(next));
	}
}
   344b0:	b002      	add	sp, #8
   344b2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   344b6:	bf00      	nop

000344b8 <mem_acquire>:

void *mem_acquire(void **mem_head)
{
   344b8:	b570      	push	{r4, r5, r6, lr}
	if (*mem_head) {
   344ba:	6805      	ldr	r5, [r0, #0]
{
   344bc:	b082      	sub	sp, #8
	if (*mem_head) {
   344be:	b19d      	cbz	r5, 344e8 <mem_acquire+0x30>
		uint16_t free_count;
		void *head;
		void *mem;

		/* Get the free count from the list and decrement it */
		free_count = *((uint16_t *)MROUND((uint8_t *)*mem_head +
   344c0:	1deb      	adds	r3, r5, #7
   344c2:	f023 0303 	bic.w	r3, r3, #3
					       sizeof(mem_head)));
		free_count--;

		mem = *mem_head;
		memcpy(&head, mem, sizeof(head));
   344c6:	2204      	movs	r2, #4
   344c8:	4604      	mov	r4, r0
   344ca:	4629      	mov	r1, r5
   344cc:	eb0d 0002 	add.w	r0, sp, r2
		free_count = *((uint16_t *)MROUND((uint8_t *)*mem_head +
   344d0:	881e      	ldrh	r6, [r3, #0]
		memcpy(&head, mem, sizeof(head));
   344d2:	f016 fcd2 	bl	4ae7a <memcpy>

		/* Store free mem_count after the list's next pointer */
		if (head) {
   344d6:	9b01      	ldr	r3, [sp, #4]
   344d8:	b12b      	cbz	r3, 344e6 <mem_acquire+0x2e>
			*((uint16_t *)MROUND((uint8_t *)head + sizeof(head))) =
   344da:	3307      	adds	r3, #7
   344dc:	f023 0303 	bic.w	r3, r3, #3
		free_count--;
   344e0:	3e01      	subs	r6, #1
			*((uint16_t *)MROUND((uint8_t *)head + sizeof(head))) =
   344e2:	801e      	strh	r6, [r3, #0]
				free_count;
		}

		*mem_head = head;
   344e4:	9b01      	ldr	r3, [sp, #4]
   344e6:	6023      	str	r3, [r4, #0]
		return mem;
	}

	return NULL;
}
   344e8:	4628      	mov	r0, r5
   344ea:	b002      	add	sp, #8
   344ec:	bd70      	pop	{r4, r5, r6, pc}
   344ee:	bf00      	nop

000344f0 <mem_release>:

void mem_release(void *mem, void **mem_head)
{
   344f0:	b570      	push	{r4, r5, r6, lr}
	uint16_t free_count = 0U;

	/* Get the free count from the list and increment it */
	if (*mem_head) {
   344f2:	680b      	ldr	r3, [r1, #0]
{
   344f4:	460c      	mov	r4, r1
   344f6:	4605      	mov	r5, r0
	if (*mem_head) {
   344f8:	b183      	cbz	r3, 3451c <mem_release+0x2c>
		free_count = *((uint16_t *)MROUND((uint8_t *)*mem_head +
   344fa:	3307      	adds	r3, #7
   344fc:	f023 0303 	bic.w	r3, r3, #3
					       sizeof(mem_head)));
	}
	free_count++;
   34500:	881e      	ldrh	r6, [r3, #0]
   34502:	3601      	adds	r6, #1
   34504:	b2b6      	uxth	r6, r6

	memcpy(mem, mem_head, sizeof(mem));
   34506:	2204      	movs	r2, #4
   34508:	4621      	mov	r1, r4
   3450a:	4628      	mov	r0, r5
   3450c:	f016 fcb5 	bl	4ae7a <memcpy>

	/* Store free mem_count after the list's next pointer */
	*((uint16_t *)MROUND((uint8_t *)mem + sizeof(mem))) = free_count;
   34510:	1deb      	adds	r3, r5, #7
   34512:	f023 0303 	bic.w	r3, r3, #3
   34516:	801e      	strh	r6, [r3, #0]

	*mem_head = mem;
   34518:	6025      	str	r5, [r4, #0]
}
   3451a:	bd70      	pop	{r4, r5, r6, pc}
   3451c:	2601      	movs	r6, #1
   3451e:	e7f2      	b.n	34506 <mem_release+0x16>

00034520 <mem_get>:
}

void *mem_get(void *mem_pool, uint16_t mem_size, uint16_t index)
{
	return ((void *)((uint8_t *)mem_pool + (mem_size * index)));
}
   34520:	fb02 0001 	mla	r0, r2, r1, r0
   34524:	4770      	bx	lr
   34526:	bf00      	nop

00034528 <mem_index_get>:

uint16_t mem_index_get(void *mem, void *mem_pool, uint16_t mem_size)
{
	return ((uint8_t *)mem - (uint8_t *)mem_pool) / mem_size;
   34528:	1a40      	subs	r0, r0, r1
   3452a:	fb90 f0f2 	sdiv	r0, r0, r2
}
   3452e:	b280      	uxth	r0, r0
   34530:	4770      	bx	lr
   34532:	bf00      	nop

00034534 <mem_rcopy>:
 * @details Example: [ 0x11 0x22 0x33 ] -> [ 0x33 0x22 0x11 ]
 */
void mem_rcopy(uint8_t *dst, uint8_t const *src, uint16_t len)
{
	src += len;
	while (len--) {
   34534:	1e53      	subs	r3, r2, #1
	src += len;
   34536:	4411      	add	r1, r2
	while (len--) {
   34538:	b29b      	uxth	r3, r3
   3453a:	b142      	cbz	r2, 3454e <mem_rcopy+0x1a>
   3453c:	43db      	mvns	r3, r3
   3453e:	3801      	subs	r0, #1
   34540:	18ca      	adds	r2, r1, r3
		*dst++ = *--src;
   34542:	f811 3d01 	ldrb.w	r3, [r1, #-1]!
   34546:	f800 3f01 	strb.w	r3, [r0, #1]!
	while (len--) {
   3454a:	4291      	cmp	r1, r2
   3454c:	d1f9      	bne.n	34542 <mem_rcopy+0xe>
	}
}
   3454e:	4770      	bx	lr

00034550 <mem_nz>:
 * @brief Determine if src[0..len-1] contains one or more non-zero bytes
 * @return 0 if all bytes are zero; otherwise 1
 */
uint8_t mem_nz(uint8_t *src, uint16_t len)
{
	while (len--) {
   34550:	4401      	add	r1, r0
   34552:	e002      	b.n	3455a <mem_nz+0xa>
		if (*src++) {
   34554:	f810 3b01 	ldrb.w	r3, [r0], #1
   34558:	b91b      	cbnz	r3, 34562 <mem_nz+0x12>
	while (len--) {
   3455a:	4288      	cmp	r0, r1
   3455c:	d1fa      	bne.n	34554 <mem_nz+0x4>
			return 1;
		}
	}

	return 0;
   3455e:	2000      	movs	r0, #0
   34560:	4770      	bx	lr
			return 1;
   34562:	2001      	movs	r0, #1
}
   34564:	4770      	bx	lr
   34566:	bf00      	nop

00034568 <memq_init>:
 * @return          Initial link-element
 */
memq_link_t *memq_init(memq_link_t *link, memq_link_t **head, memq_link_t **tail)
{
	/* Head and tail pointer to the initial link - forms an empty queue */
	*head = *tail = link;
   34568:	6010      	str	r0, [r2, #0]
   3456a:	6008      	str	r0, [r1, #0]

	return link;
}
   3456c:	4770      	bx	lr
   3456e:	bf00      	nop

00034570 <memq_deinit>:
memq_link_t *memq_deinit(memq_link_t **head, memq_link_t **tail)
{
	memq_link_t *old_head;

	/* If head and tail are not equal, then queue is not empty */
	if (*head != *tail) {
   34570:	680a      	ldr	r2, [r1, #0]
{
   34572:	4603      	mov	r3, r0
	if (*head != *tail) {
   34574:	6800      	ldr	r0, [r0, #0]
   34576:	4290      	cmp	r0, r2
		return NULL;
	}

	old_head = *head;
	*head = *tail = NULL;
   34578:	bf05      	ittet	eq
   3457a:	2200      	moveq	r2, #0
   3457c:	600a      	streq	r2, [r1, #0]
		return NULL;
   3457e:	2000      	movne	r0, #0
	*head = *tail = NULL;
   34580:	601a      	streq	r2, [r3, #0]

	return old_head;
}
   34582:	4770      	bx	lr

00034584 <memq_enqueue>:
 * @return             New tail. Note: Does not point to the new mem
 */
memq_link_t *memq_enqueue(memq_link_t *link, void *mem, memq_link_t **tail)
{
	/* Let the old tail element point to the new tail element */
	(*tail)->next = link;
   34584:	f8d2 c000 	ldr.w	ip, [r2]
   34588:	f8cc 0000 	str.w	r0, [ip]

	/* Let the old tail element point the the new memory */
	(*tail)->mem = mem;
   3458c:	f8d2 c000 	ldr.w	ip, [r2]
   34590:	f8cc 1004 	str.w	r1, [ip, #4]

	/* Update the tail-pointer to point to the new tail element.
	 * The new tail-element is not expected to point to anything sensible
	 */
	cpu_dmb(); /* Ensure data accesses are synchronized */
	*tail = link; /* Commit: enqueue of memq node */
   34594:	6010      	str	r0, [r2, #0]

	return link;
}
   34596:	4770      	bx	lr

00034598 <memq_peek>:
 * @return         head or NULL if queue is empty
 */
memq_link_t *memq_peek(memq_link_t *head, memq_link_t *tail, void **mem)
{
	/* If head and tail are equal, then queue empty */
	if (head == tail) {
   34598:	4288      	cmp	r0, r1
   3459a:	d003      	beq.n	345a4 <memq_peek+0xc>
		return NULL;
	}

	/* Extract the head link-element's memory */
	if (mem) {
   3459c:	b11a      	cbz	r2, 345a6 <memq_peek+0xe>
		*mem = head->mem;
   3459e:	6843      	ldr	r3, [r0, #4]
   345a0:	6013      	str	r3, [r2, #0]
   345a2:	4770      	bx	lr
		return NULL;
   345a4:	2000      	movs	r0, #0
	}

	return head; /* queue was not empty */
}
   345a6:	4770      	bx	lr

000345a8 <memq_dequeue>:
memq_link_t *memq_dequeue(memq_link_t *tail, memq_link_t **head, void **mem)
{
	memq_link_t *old_head;

	/* Use memq peek to get the old head and its mem */
	old_head = memq_peek(*head, tail, mem);
   345a8:	680b      	ldr	r3, [r1, #0]
	if (head == tail) {
   345aa:	4283      	cmp	r3, r0
   345ac:	d009      	beq.n	345c2 <memq_dequeue+0x1a>
	if (mem) {
   345ae:	b12a      	cbz	r2, 345bc <memq_dequeue+0x14>
		*mem = head->mem;
   345b0:	6858      	ldr	r0, [r3, #4]
   345b2:	6010      	str	r0, [r2, #0]
	if (old_head == NULL) {
		return NULL; /* queue is empty */
	}

	/* Update the head-pointer to point to the new head element */
	*head = old_head->next;
   345b4:	681a      	ldr	r2, [r3, #0]
   345b6:	600a      	str	r2, [r1, #0]

	return old_head;
}
   345b8:	4618      	mov	r0, r3
   345ba:	4770      	bx	lr
	if (old_head == NULL) {
   345bc:	2b00      	cmp	r3, #0
   345be:	d1f9      	bne.n	345b4 <memq_dequeue+0xc>
   345c0:	e7fa      	b.n	345b8 <memq_dequeue+0x10>
		return NULL; /* queue is empty */
   345c2:	2300      	movs	r3, #0
   345c4:	e7f8      	b.n	345b8 <memq_dequeue+0x10>
   345c6:	bf00      	nop

000345c8 <mayfly_init>:
#if defined(MAYFLY_UT)
static uint8_t _state;
#endif /* MAYFLY_UT */

void mayfly_init(void)
{
   345c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   345cc:	f8df 8030 	ldr.w	r8, [pc, #48]	; 34600 <mayfly_init+0x38>
   345d0:	4e0c      	ldr	r6, [pc, #48]	; (34604 <mayfly_init+0x3c>)
   345d2:	270c      	movs	r7, #12
	callee_id = MAYFLY_CALLEE_COUNT;
	while (callee_id--) {
		uint8_t caller_id;

		caller_id = MAYFLY_CALLER_COUNT;
		while (caller_id--) {
   345d4:	f106 0430 	add.w	r4, r6, #48	; 0x30
{
   345d8:	4645      	mov	r5, r8
			memq_init(&mfl[callee_id][caller_id],
   345da:	1d22      	adds	r2, r4, #4
   345dc:	4621      	mov	r1, r4
   345de:	4628      	mov	r0, r5
		while (caller_id--) {
   345e0:	3c0c      	subs	r4, #12
			memq_init(&mfl[callee_id][caller_id],
   345e2:	f7ff ffc1 	bl	34568 <memq_init>
		while (caller_id--) {
   345e6:	42a6      	cmp	r6, r4
   345e8:	f1a5 0508 	sub.w	r5, r5, #8
   345ec:	d1f5      	bne.n	345da <mayfly_init+0x12>
	while (callee_id--) {
   345ee:	3f04      	subs	r7, #4
   345f0:	1d3b      	adds	r3, r7, #4
   345f2:	f1a8 0820 	sub.w	r8, r8, #32
   345f6:	f1a6 0630 	sub.w	r6, r6, #48	; 0x30
   345fa:	d1eb      	bne.n	345d4 <mayfly_init+0xc>
				  &mft[callee_id][caller_id].head,
				  &mft[callee_id][caller_id].tail);
		}
	}
}
   345fc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   34600:	200043d4 	.word	0x200043d4
   34604:	20004460 	.word	0x20004460

00034608 <mayfly_enable>:

void mayfly_enable(uint8_t caller_id, uint8_t callee_id, uint8_t enable)
{
   34608:	b410      	push	{r4}
   3460a:	4603      	mov	r3, r0
   3460c:	468c      	mov	ip, r1
	if (enable) {
   3460e:	b19a      	cbz	r2, 34638 <mayfly_enable+0x30>
		if (mft[callee_id][caller_id].enable_req ==
   34610:	eb01 0141 	add.w	r1, r1, r1, lsl #1
   34614:	4814      	ldr	r0, [pc, #80]	; (34668 <mayfly_enable+0x60>)
   34616:	eb03 0443 	add.w	r4, r3, r3, lsl #1
   3461a:	0109      	lsls	r1, r1, #4
   3461c:	eb01 0184 	add.w	r1, r1, r4, lsl #2
   34620:	4401      	add	r1, r0
   34622:	7a48      	ldrb	r0, [r1, #9]
   34624:	7a0c      	ldrb	r4, [r1, #8]
   34626:	42a0      	cmp	r0, r4
		    mft[callee_id][caller_id].enable_ack) {
			mft[callee_id][caller_id].enable_req++;
   34628:	bf04      	itt	eq
   3462a:	3001      	addeq	r0, #1
   3462c:	7208      	strbeq	r0, [r1, #8]

			/* pend the callee for execution */
			mayfly_pend(caller_id, callee_id);
		}
	}
}
   3462e:	bc10      	pop	{r4}
		mayfly_enable_cb(caller_id, callee_id, enable);
   34630:	4661      	mov	r1, ip
   34632:	4618      	mov	r0, r3
   34634:	f00d be6e 	b.w	42314 <mayfly_enable_cb>
		if (mft[callee_id][caller_id].disable_req ==
   34638:	eb01 0241 	add.w	r2, r1, r1, lsl #1
   3463c:	4c0a      	ldr	r4, [pc, #40]	; (34668 <mayfly_enable+0x60>)
   3463e:	0112      	lsls	r2, r2, #4
   34640:	eb00 0340 	add.w	r3, r0, r0, lsl #1
   34644:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   34648:	4423      	add	r3, r4
   3464a:	7a9c      	ldrb	r4, [r3, #10]
   3464c:	7ada      	ldrb	r2, [r3, #11]
   3464e:	42a2      	cmp	r2, r4
   34650:	d001      	beq.n	34656 <mayfly_enable+0x4e>
}
   34652:	bc10      	pop	{r4}
   34654:	4770      	bx	lr
			mft[callee_id][caller_id].disable_req++;
   34656:	3201      	adds	r2, #1
   34658:	729a      	strb	r2, [r3, #10]
			mfp[callee_id] = 1U;
   3465a:	4b04      	ldr	r3, [pc, #16]	; (3466c <mayfly_enable+0x64>)
   3465c:	2201      	movs	r2, #1
   3465e:	545a      	strb	r2, [r3, r1]
}
   34660:	bc10      	pop	{r4}
			mayfly_pend(caller_id, callee_id);
   34662:	f00d bead 	b.w	423c0 <mayfly_pend>
   34666:	bf00      	nop
   34668:	200043dc 	.word	0x200043dc
   3466c:	20004358 	.word	0x20004358

00034670 <mayfly_enqueue>:

uint32_t mayfly_enqueue(uint8_t caller_id, uint8_t callee_id, uint8_t chain,
			struct mayfly *m)
{
   34670:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   34672:	4606      	mov	r6, r0
   34674:	461c      	mov	r4, r3
   34676:	460d      	mov	r5, r1
	uint8_t state;
	uint8_t ack;

	chain = chain || !mayfly_prio_is_equal(caller_id, callee_id) ||
		!mayfly_is_enabled(caller_id, callee_id) ||
   34678:	b302      	cbz	r2, 346bc <mayfly_enqueue+0x4c>

	/* shadow the ack */
	ack = m->_ack;

	/* already in queue */
	state = (m->_req - ack) & 0x03;
   3467a:	7822      	ldrb	r2, [r4, #0]
	ack = m->_ack;
   3467c:	7863      	ldrb	r3, [r4, #1]
	state = (m->_req - ack) & 0x03;
   3467e:	1ad2      	subs	r2, r2, r3
	if (state != 0U) {
   34680:	f012 0203 	ands.w	r2, r2, #3
   34684:	d13a      	bne.n	346fc <mayfly_enqueue+0x8c>
   34686:	4f27      	ldr	r7, [pc, #156]	; (34724 <mayfly_enqueue+0xb4>)
   34688:	0071      	lsls	r1, r6, #1
   3468a:	ea4f 0c45 	mov.w	ip, r5, lsl #1
		return 0;
	}

	/* new, add as ready in the queue */
	m->_req = ack + 1;
	memq_enqueue(m->_link, m, &mft[callee_id][caller_id].tail);
   3468e:	4431      	add	r1, r6
   34690:	44ac      	add	ip, r5
   34692:	0089      	lsls	r1, r1, #2
   34694:	eb01 110c 	add.w	r1, r1, ip, lsl #4
	m->_req = ack + 1;
   34698:	3301      	adds	r3, #1
	memq_enqueue(m->_link, m, &mft[callee_id][caller_id].tail);
   3469a:	3104      	adds	r1, #4
	m->_req = ack + 1;
   3469c:	b2db      	uxtb	r3, r3
	memq_enqueue(m->_link, m, &mft[callee_id][caller_id].tail);
   3469e:	187a      	adds	r2, r7, r1
   346a0:	6860      	ldr	r0, [r4, #4]
	m->_req = ack + 1;
   346a2:	7023      	strb	r3, [r4, #0]
	memq_enqueue(m->_link, m, &mft[callee_id][caller_id].tail);
   346a4:	4621      	mov	r1, r4
   346a6:	f7ff ff6d 	bl	34584 <memq_enqueue>

mayfly_enqueue_pend:
	/* set mayfly callee pending */
	mfp[callee_id] = 1U;
   346aa:	4b1f      	ldr	r3, [pc, #124]	; (34728 <mayfly_enqueue+0xb8>)
   346ac:	2201      	movs	r2, #1
   346ae:	555a      	strb	r2, [r3, r5]

	/* pend the callee for execution */
	mayfly_pend(caller_id, callee_id);
   346b0:	4629      	mov	r1, r5
   346b2:	4630      	mov	r0, r6
   346b4:	f00d fe84 	bl	423c0 <mayfly_pend>
		return 0;
   346b8:	2000      	movs	r0, #0

	return 0;
}
   346ba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	chain = chain || !mayfly_prio_is_equal(caller_id, callee_id) ||
   346bc:	f00d fe6a 	bl	42394 <mayfly_prio_is_equal>
   346c0:	2800      	cmp	r0, #0
   346c2:	d0da      	beq.n	3467a <mayfly_enqueue+0xa>
		!mayfly_is_enabled(caller_id, callee_id) ||
   346c4:	4629      	mov	r1, r5
   346c6:	4630      	mov	r0, r6
   346c8:	f00d fe44 	bl	42354 <mayfly_is_enabled>
	chain = chain || !mayfly_prio_is_equal(caller_id, callee_id) ||
   346cc:	2800      	cmp	r0, #0
   346ce:	d0d4      	beq.n	3467a <mayfly_enqueue+0xa>
		(mft[callee_id][caller_id].disable_req !=
   346d0:	eb05 0245 	add.w	r2, r5, r5, lsl #1
   346d4:	eb06 0146 	add.w	r1, r6, r6, lsl #1
   346d8:	4f12      	ldr	r7, [pc, #72]	; (34724 <mayfly_enqueue+0xb4>)
	ack = m->_ack;
   346da:	7863      	ldrb	r3, [r4, #1]
		(mft[callee_id][caller_id].disable_req !=
   346dc:	0112      	lsls	r2, r2, #4
   346de:	eb02 0281 	add.w	r2, r2, r1, lsl #2
   346e2:	443a      	add	r2, r7
   346e4:	0071      	lsls	r1, r6, #1
		!mayfly_is_enabled(caller_id, callee_id) ||
   346e6:	7a90      	ldrb	r0, [r2, #10]
   346e8:	7ad2      	ldrb	r2, [r2, #11]
   346ea:	4290      	cmp	r0, r2
		(mft[callee_id][caller_id].disable_req !=
   346ec:	ea4f 0c45 	mov.w	ip, r5, lsl #1
		!mayfly_is_enabled(caller_id, callee_id) ||
   346f0:	d00c      	beq.n	3470c <mayfly_enqueue+0x9c>
	state = (m->_req - ack) & 0x03;
   346f2:	7820      	ldrb	r0, [r4, #0]
   346f4:	1ac0      	subs	r0, r0, r3
	if (state != 0U) {
   346f6:	f010 0203 	ands.w	r2, r0, #3
   346fa:	d0c8      	beq.n	3468e <mayfly_enqueue+0x1e>
			if (state != 1U) {
   346fc:	2a01      	cmp	r2, #1
   346fe:	d003      	beq.n	34708 <mayfly_enqueue+0x98>
				m->_req = ack + 1;
   34700:	3301      	adds	r3, #1
   34702:	b2db      	uxtb	r3, r3
   34704:	7023      	strb	r3, [r4, #0]
				goto mayfly_enqueue_pend;
   34706:	e7d0      	b.n	346aa <mayfly_enqueue+0x3a>
			return 1;
   34708:	4610      	mov	r0, r2
}
   3470a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	state = (m->_req - ack) & 0x03;
   3470c:	7822      	ldrb	r2, [r4, #0]
   3470e:	1ad2      	subs	r2, r2, r3
	if (state != 0U) {
   34710:	0792      	lsls	r2, r2, #30
   34712:	d002      	beq.n	3471a <mayfly_enqueue+0xaa>
		m->_req = ack + 2;
   34714:	3302      	adds	r3, #2
   34716:	b2db      	uxtb	r3, r3
   34718:	7023      	strb	r3, [r4, #0]
		m->fp(m->param);
   3471a:	e9d4 0302 	ldrd	r0, r3, [r4, #8]
   3471e:	4798      	blx	r3
		return 0;
   34720:	e7ca      	b.n	346b8 <mayfly_enqueue+0x48>
   34722:	bf00      	nop
   34724:	200043dc 	.word	0x200043dc
   34728:	20004358 	.word	0x20004358

0003472c <mayfly_run>:
		}
	}
}

void mayfly_run(uint8_t callee_id)
{
   3472c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint8_t disable = 0U;
	uint8_t enable = 0U;
	uint8_t caller_id;

	if (!mfp[callee_id]) {
   34730:	f8df 9140 	ldr.w	r9, [pc, #320]	; 34874 <mayfly_run+0x148>
   34734:	f819 3000 	ldrb.w	r3, [r9, r0]
{
   34738:	b089      	sub	sp, #36	; 0x24
	if (!mfp[callee_id]) {
   3473a:	2b00      	cmp	r3, #0
   3473c:	d060      	beq.n	34800 <mayfly_run+0xd4>
		return;
	}
	mfp[callee_id] = 0U;
   3473e:	f8df a138 	ldr.w	sl, [pc, #312]	; 34878 <mayfly_run+0x14c>
   34742:	9003      	str	r0, [sp, #12]
			memq_enqueue(link, m, &mft[callee_id][callee_id].tail);
   34744:	223c      	movs	r2, #60	; 0x3c
   34746:	2304      	movs	r3, #4
	mfp[callee_id] = 0U;
   34748:	2500      	movs	r5, #0
   3474a:	eb00 0b40 	add.w	fp, r0, r0, lsl #1
			memq_enqueue(link, m, &mft[callee_id][callee_id].tail);
   3474e:	fb12 3300 	smlabb	r3, r2, r0, r3

	/* iterate through each caller queue to this callee_id */
	caller_id = MAYFLY_CALLER_COUNT;
	while (caller_id--) {
   34752:	2403      	movs	r4, #3
   34754:	e9cd 5504 	strd	r5, r5, [sp, #16]
	mfp[callee_id] = 0U;
   34758:	f809 5000 	strb.w	r5, [r9, r0]
	while (caller_id--) {
   3475c:	eb0a 1b0b 	add.w	fp, sl, fp, lsl #4
			memq_enqueue(link, m, &mft[callee_id][callee_id].tail);
   34760:	9302      	str	r3, [sp, #8]
   34762:	4625      	mov	r5, r4
		memq_link_t *link;
		struct mayfly *m = 0;

		/* fetch mayfly in callee queue, if any */
		link = memq_peek(mft[callee_id][caller_id].head,
   34764:	465c      	mov	r4, fp
		struct mayfly *m = 0;
   34766:	2300      	movs	r3, #0
		link = memq_peek(mft[callee_id][caller_id].head,
   34768:	f8db 1028 	ldr.w	r1, [fp, #40]	; 0x28
   3476c:	f854 0f24 	ldr.w	r0, [r4, #36]!
		struct mayfly *m = 0;
   34770:	9307      	str	r3, [sp, #28]
		link = memq_peek(mft[callee_id][caller_id].head,
   34772:	aa07      	add	r2, sp, #28
   34774:	f7ff ff10 	bl	34598 <memq_peek>
   34778:	9501      	str	r5, [sp, #4]
   3477a:	4607      	mov	r7, r0
				 mft[callee_id][caller_id].tail,
				 (void **)&m);
		while (link) {
   3477c:	2f00      	cmp	r7, #0
   3477e:	d04b      	beq.n	34818 <mayfly_run+0xec>
#if defined(MAYFLY_UT)
			_state = 0U;
#endif /* MAYFLY_UT */

			/* execute work if ready */
			state = (m->_req - m->_ack) & 0x03;
   34780:	9d07      	ldr	r5, [sp, #28]
   34782:	7868      	ldrb	r0, [r5, #1]
   34784:	782e      	ldrb	r6, [r5, #0]
   34786:	1a36      	subs	r6, r6, r0
   34788:	f006 0603 	and.w	r6, r6, #3
			if (state == 1U) {
   3478c:	2e01      	cmp	r6, #1
   3478e:	d107      	bne.n	347a0 <mayfly_run+0x74>
#if defined(MAYFLY_UT)
				_state = 1U;
#endif /* MAYFLY_UT */

				/* mark mayfly as ran */
				m->_ack--;
   34790:	3801      	subs	r0, #1
   34792:	7068      	strb	r0, [r5, #1]

				/* call the mayfly function */
				m->fp(m->param);
   34794:	9b07      	ldr	r3, [sp, #28]
   34796:	e9d3 0302 	ldrd	r0, r3, [r3, #8]
   3479a:	4798      	blx	r3
			}

			/* dequeue if not re-pended */
			dequeue(callee_id, caller_id, link, m);
   3479c:	9d07      	ldr	r5, [sp, #28]
	if (((req - m->_ack) & 0x03) != 1U) {
   3479e:	7868      	ldrb	r0, [r5, #1]
	req = m->_req;
   347a0:	782b      	ldrb	r3, [r5, #0]
		memq_dequeue(mft[callee_id][caller_id].tail,
   347a2:	f8db c028 	ldr.w	ip, [fp, #40]	; 0x28
	if (((req - m->_ack) & 0x03) != 1U) {
   347a6:	1a18      	subs	r0, r3, r0
   347a8:	f000 0003 	and.w	r0, r0, #3
   347ac:	2801      	cmp	r0, #1
		memq_dequeue(mft[callee_id][caller_id].tail,
   347ae:	f04f 0200 	mov.w	r2, #0
   347b2:	4621      	mov	r1, r4
	req = m->_req;
   347b4:	fa5f f883 	uxtb.w	r8, r3
		memq_dequeue(mft[callee_id][caller_id].tail,
   347b8:	4660      	mov	r0, ip
	if (((req - m->_ack) & 0x03) != 1U) {
   347ba:	d00d      	beq.n	347d8 <mayfly_run+0xac>
		memq_dequeue(mft[callee_id][caller_id].tail,
   347bc:	f7ff fef4 	bl	345a8 <memq_dequeue>
		ack = m->_ack;
   347c0:	7869      	ldrb	r1, [r5, #1]
		if (((m->_req - ack) & 0x03) == 1U) {
   347c2:	782a      	ldrb	r2, [r5, #0]
		m->_link = link;
   347c4:	606f      	str	r7, [r5, #4]
		if (((m->_req - ack) & 0x03) == 1U) {
   347c6:	1a52      	subs	r2, r2, r1
   347c8:	f002 0203 	and.w	r2, r2, #3
   347cc:	2a01      	cmp	r2, #1
		m->_ack = req;
   347ce:	f885 8001 	strb.w	r8, [r5, #1]
		if (((m->_req - ack) & 0x03) == 1U) {
   347d2:	d018      	beq.n	34806 <mayfly_run+0xda>
   347d4:	f8db c028 	ldr.w	ip, [fp, #40]	; 0x28

			/* fetch next mayfly in callee queue, if any */
			link = memq_peek(mft[callee_id][caller_id].head,
   347d8:	f8db 0024 	ldr.w	r0, [fp, #36]	; 0x24
   347dc:	aa07      	add	r2, sp, #28
   347de:	4661      	mov	r1, ip
   347e0:	f7ff feda 	bl	34598 <memq_peek>
 */
#if defined(CONFIG_BT_MAYFLY_YIELD_AFTER_CALL)
			/* yield out of mayfly_run if a mayfly function was
			 * called.
			 */
			if (state == 1U) {
   347e4:	2e01      	cmp	r6, #1
			link = memq_peek(mft[callee_id][caller_id].head,
   347e6:	4607      	mov	r7, r0
			if (state == 1U) {
   347e8:	d1c8      	bne.n	3477c <mayfly_run+0x50>
				/* pend callee (tailchain) if mayfly queue is
				 * not empty or all caller queues are not
				 * processed.
				 */
				if (caller_id || link) {
   347ea:	9d01      	ldr	r5, [sp, #4]
   347ec:	2d00      	cmp	r5, #0
   347ee:	d03d      	beq.n	3486c <mayfly_run+0x140>
					/* set mayfly callee pending */
					mfp[callee_id] = 1U;
   347f0:	9f03      	ldr	r7, [sp, #12]
   347f2:	2301      	movs	r3, #1
   347f4:	f809 3007 	strb.w	r3, [r9, r7]

					/* pend the callee for execution */
					mayfly_pend(callee_id, callee_id);
   347f8:	4639      	mov	r1, r7
   347fa:	4638      	mov	r0, r7
   347fc:	f00d fde0 	bl	423c0 <mayfly_pend>
	}

	if (disable && !enable) {
		mayfly_enable_cb(callee_id, callee_id, 0);
	}
}
   34800:	b009      	add	sp, #36	; 0x24
   34802:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			memq_enqueue(link, m, &mft[callee_id][callee_id].tail);
   34806:	9b02      	ldr	r3, [sp, #8]
			m->_ack = ack;
   34808:	7069      	strb	r1, [r5, #1]
			memq_enqueue(link, m, &mft[callee_id][callee_id].tail);
   3480a:	4638      	mov	r0, r7
   3480c:	4629      	mov	r1, r5
   3480e:	eb0a 0203 	add.w	r2, sl, r3
   34812:	f7ff feb7 	bl	34584 <memq_enqueue>
   34816:	e7dd      	b.n	347d4 <mayfly_run+0xa8>
   34818:	9d01      	ldr	r5, [sp, #4]
		if (mft[callee_id][caller_id].disable_req !=
   3481a:	f89b 302e 	ldrb.w	r3, [fp, #46]	; 0x2e
   3481e:	f89b 202f 	ldrb.w	r2, [fp, #47]	; 0x2f
   34822:	429a      	cmp	r2, r3
   34824:	d003      	beq.n	3482e <mayfly_run+0x102>
			mft[callee_id][caller_id].disable_ack =
   34826:	f88b 302f 	strb.w	r3, [fp, #47]	; 0x2f
			disable = 1U;
   3482a:	2301      	movs	r3, #1
   3482c:	9304      	str	r3, [sp, #16]
		if (mft[callee_id][caller_id].enable_req !=
   3482e:	f89b 302c 	ldrb.w	r3, [fp, #44]	; 0x2c
   34832:	f89b 202d 	ldrb.w	r2, [fp, #45]	; 0x2d
   34836:	429a      	cmp	r2, r3
   34838:	d003      	beq.n	34842 <mayfly_run+0x116>
			mft[callee_id][caller_id].enable_ack =
   3483a:	f88b 302d 	strb.w	r3, [fp, #45]	; 0x2d
			enable = 1U;
   3483e:	2301      	movs	r3, #1
   34840:	9305      	str	r3, [sp, #20]
	while (caller_id--) {
   34842:	3d01      	subs	r5, #1
   34844:	b2ed      	uxtb	r5, r5
   34846:	2dff      	cmp	r5, #255	; 0xff
   34848:	f1ab 0b0c 	sub.w	fp, fp, #12
   3484c:	d18a      	bne.n	34764 <mayfly_run+0x38>
	if (disable && !enable) {
   3484e:	e9dd 2504 	ldrd	r2, r5, [sp, #16]
   34852:	9f03      	ldr	r7, [sp, #12]
   34854:	2a00      	cmp	r2, #0
   34856:	d0d3      	beq.n	34800 <mayfly_run+0xd4>
   34858:	2d00      	cmp	r5, #0
   3485a:	d1d1      	bne.n	34800 <mayfly_run+0xd4>
		mayfly_enable_cb(callee_id, callee_id, 0);
   3485c:	462a      	mov	r2, r5
   3485e:	4639      	mov	r1, r7
   34860:	4638      	mov	r0, r7
}
   34862:	b009      	add	sp, #36	; 0x24
   34864:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		mayfly_enable_cb(callee_id, callee_id, 0);
   34868:	f00d bd54 	b.w	42314 <mayfly_enable_cb>
				if (caller_id || link) {
   3486c:	2800      	cmp	r0, #0
   3486e:	d0d4      	beq.n	3481a <mayfly_run+0xee>
   34870:	e7be      	b.n	347f0 <mayfly_run+0xc4>
   34872:	bf00      	nop
   34874:	20004358 	.word	0x20004358
   34878:	200043dc 	.word	0x200043dc

0003487c <util_ones_count_get>:
 */
uint8_t util_ones_count_get(const uint8_t *octets, uint8_t octets_len)
{
	uint8_t one_count = 0U;

	while (octets_len--) {
   3487c:	1e4b      	subs	r3, r1, #1
   3487e:	b2db      	uxtb	r3, r3
   34880:	b171      	cbz	r1, 348a0 <util_ones_count_get+0x24>
   34882:	1e41      	subs	r1, r0, #1
   34884:	eb00 0c03 	add.w	ip, r0, r3
	uint8_t one_count = 0U;
   34888:	2000      	movs	r0, #0
		uint8_t bite;

		bite = *octets;
   3488a:	f811 3f01 	ldrb.w	r3, [r1, #1]!
		while (bite) {
   3488e:	b123      	cbz	r3, 3489a <util_ones_count_get+0x1e>
			bite &= (bite - 1);
   34890:	1e5a      	subs	r2, r3, #1
			one_count++;
   34892:	3001      	adds	r0, #1
		while (bite) {
   34894:	4013      	ands	r3, r2
			one_count++;
   34896:	b2c0      	uxtb	r0, r0
		while (bite) {
   34898:	d1fa      	bne.n	34890 <util_ones_count_get+0x14>
	while (octets_len--) {
   3489a:	4561      	cmp	r1, ip
   3489c:	d1f5      	bne.n	3488a <util_ones_count_get+0xe>
   3489e:	4770      	bx	lr
	uint8_t one_count = 0U;
   348a0:	4608      	mov	r0, r1
		}
		octets++;
	}

	return one_count;
}
   348a2:	4770      	bx	lr

000348a4 <util_aa_le32>:
 * - It shall have at least three ones in the least significant 8 bits.
 * - It shall have no more than eleven transitions in the least significant 16
 *   bits.
 */
int util_aa_le32(uint8_t *dst)
{
   348a4:	b5f0      	push	{r4, r5, r6, r7, lr}

	/* It shall not be the advertising channel packets Access Address.
	 * It shall not be a sequence that differs from the advertising channel
	 * packets Access Address by only one bit.
	 */
	adv_aa_check = aa ^ PDU_AC_ACCESS_ADDR;
   348a6:	4d51      	ldr	r5, [pc, #324]	; (349ec <util_aa_le32+0x148>)
{
   348a8:	b083      	sub	sp, #12
   348aa:	4607      	mov	r7, r0
   348ac:	2603      	movs	r6, #3
	consecutive_cnt = 1U;
   348ae:	2401      	movs	r4, #1
	lll_csrand_get(dst, sizeof(uint32_t));
   348b0:	2104      	movs	r1, #4
   348b2:	4638      	mov	r0, r7
   348b4:	f00a fe90 	bl	3f5d8 <lll_csrand_get>
	return ((uint32_t)sys_get_le16(&src[2]) << 16) | sys_get_le16(&src[0]);
   348b8:	6838      	ldr	r0, [r7, #0]
	bit_idx = 31U;
   348ba:	231f      	movs	r3, #31
	consecutive_bit = (aa >> bit_idx) & 0x01;
   348bc:	fa20 f203 	lsr.w	r2, r0, r3
	while (bit_idx--) {
   348c0:	3b01      	subs	r3, #1
   348c2:	b2db      	uxtb	r3, r3
   348c4:	2bff      	cmp	r3, #255	; 0xff
	transitions = 0U;
   348c6:	f04f 0c00 	mov.w	ip, #0
	consecutive_cnt = 1U;
   348ca:	f04f 0e01 	mov.w	lr, #1
	while (bit_idx--) {
   348ce:	d014      	beq.n	348fa <util_aa_le32+0x56>
		bit = (aa >> bit_idx) & 0x01;
   348d0:	fa20 f103 	lsr.w	r1, r0, r3
   348d4:	f001 0101 	and.w	r1, r1, #1
		if (bit == consecutive_bit) {
   348d8:	428a      	cmp	r2, r1
   348da:	d032      	beq.n	34942 <util_aa_le32+0x9e>
			transitions++;
   348dc:	f10c 0201 	add.w	r2, ip, #1
		    ((consecutive_cnt < 6) &&
   348e0:	2b1c      	cmp	r3, #28
			transitions++;
   348e2:	b2d2      	uxtb	r2, r2
		    ((consecutive_cnt < 6) &&
   348e4:	d94e      	bls.n	34984 <util_aa_le32+0xe0>
		if ((transitions > 24) ||
   348e6:	2a19      	cmp	r2, #25
   348e8:	d03b      	beq.n	34962 <util_aa_le32+0xbe>
   348ea:	4694      	mov	ip, r2
   348ec:	f04f 0e01 	mov.w	lr, #1
	consecutive_cnt = 1U;
   348f0:	460a      	mov	r2, r1
	while (bit_idx--) {
   348f2:	3b01      	subs	r3, #1
   348f4:	b2db      	uxtb	r3, r3
   348f6:	2bff      	cmp	r3, #255	; 0xff
   348f8:	d1ea      	bne.n	348d0 <util_aa_le32+0x2c>
	adv_aa_check = aa ^ PDU_AC_ACCESS_ADDR;
   348fa:	ea80 0305 	eor.w	r3, r0, r5
   348fe:	9301      	str	r3, [sp, #4]
	while (octets_len--) {
   34900:	f10d 0c04 	add.w	ip, sp, #4
   34904:	f10d 0e08 	add.w	lr, sp, #8
	uint8_t one_count = 0U;
   34908:	2200      	movs	r2, #0
		bite = *octets;
   3490a:	f81c 3b01 	ldrb.w	r3, [ip], #1
		while (bite) {
   3490e:	b123      	cbz	r3, 3491a <util_aa_le32+0x76>
			bite &= (bite - 1);
   34910:	1e59      	subs	r1, r3, #1
			one_count++;
   34912:	3201      	adds	r2, #1
		while (bite) {
   34914:	400b      	ands	r3, r1
			one_count++;
   34916:	b2d2      	uxtb	r2, r2
		while (bite) {
   34918:	d1fa      	bne.n	34910 <util_aa_le32+0x6c>
	while (octets_len--) {
   3491a:	45e6      	cmp	lr, ip
   3491c:	d1f5      	bne.n	3490a <util_aa_le32+0x66>
	if (util_ones_count_get((uint8_t *)&adv_aa_check,
   3491e:	2a01      	cmp	r2, #1
   34920:	d907      	bls.n	34932 <util_aa_le32+0x8e>
				sizeof(adv_aa_check)) <= 1) {
		goto again;
	}

	/* It shall not have all four octets equal. */
	if (!((aa & 0xFFFF) ^ (aa >> 16)) &&
   34922:	b283      	uxth	r3, r0
   34924:	ebb3 4f10 	cmp.w	r3, r0, lsr #16
   34928:	d128      	bne.n	3497c <util_aa_le32+0xd8>
	    !((aa & 0xFF) ^ (aa >> 24))) {
   3492a:	b2c3      	uxtb	r3, r0
	if (!((aa & 0xFFFF) ^ (aa >> 16)) &&
   3492c:	ebb3 6f10 	cmp.w	r3, r0, lsr #24
   34930:	d124      	bne.n	3497c <util_aa_le32+0xd8>
	if (!retry) {
   34932:	3e01      	subs	r6, #1
   34934:	f016 06ff 	ands.w	r6, r6, #255	; 0xff
   34938:	d1ba      	bne.n	348b0 <util_aa_le32+0xc>
		return -EFAULT;
   3493a:	f06f 000d 	mvn.w	r0, #13
	}

	sys_put_le32(aa, dst);

	return 0;
}
   3493e:	b003      	add	sp, #12
   34940:	bdf0      	pop	{r4, r5, r6, r7, pc}
			consecutive_cnt++;
   34942:	f10e 0201 	add.w	r2, lr, #1
   34946:	b2d2      	uxtb	r2, r2
		if ((consecutive_cnt > 6) ||
   34948:	2a06      	cmp	r2, #6
   3494a:	d92c      	bls.n	349a6 <util_aa_le32+0x102>
				aa &= ~BIT(bit_idx);
   3494c:	fa04 f203 	lsl.w	r2, r4, r3
			if (consecutive_bit) {
   34950:	b171      	cbz	r1, 34970 <util_aa_le32+0xcc>
				aa &= ~BIT(bit_idx);
   34952:	ea20 0002 	bic.w	r0, r0, r2
				consecutive_bit = 0U;
   34956:	2100      	movs	r1, #0
				transitions++;
   34958:	f10c 0201 	add.w	r2, ip, #1
   3495c:	b2d2      	uxtb	r2, r2
		if ((transitions > 24) ||
   3495e:	2a19      	cmp	r2, #25
   34960:	d1c3      	bne.n	348ea <util_aa_le32+0x46>
				aa &= ~(BIT(bit_idx + 1) - 1);
   34962:	3301      	adds	r3, #1
   34964:	fa04 f303 	lsl.w	r3, r4, r3
			if (consecutive_bit) {
   34968:	b129      	cbz	r1, 34976 <util_aa_le32+0xd2>
				aa &= ~(BIT(bit_idx + 1) - 1);
   3496a:	425b      	negs	r3, r3
   3496c:	4018      	ands	r0, r3
   3496e:	e7c4      	b.n	348fa <util_aa_le32+0x56>
				aa |= BIT(bit_idx);
   34970:	4310      	orrs	r0, r2
				consecutive_bit = 1U;
   34972:	2101      	movs	r1, #1
   34974:	e7f0      	b.n	34958 <util_aa_le32+0xb4>
				aa |= (BIT(bit_idx + 1) - 1);
   34976:	3b01      	subs	r3, #1
   34978:	4318      	orrs	r0, r3
   3497a:	e7be      	b.n	348fa <util_aa_le32+0x56>
	dst[0] = val;
   3497c:	6038      	str	r0, [r7, #0]
	return 0;
   3497e:	2000      	movs	r0, #0
}
   34980:	b003      	add	sp, #12
   34982:	bdf0      	pop	{r4, r5, r6, r7, pc}
		     (((bit_idx < 29) && (transitions < 1)) ||
   34984:	d0af      	beq.n	348e6 <util_aa_le32+0x42>
		      ((bit_idx < 28) && (transitions < 2))))) {
   34986:	2a01      	cmp	r2, #1
   34988:	d1ad      	bne.n	348e6 <util_aa_le32+0x42>
				aa &= ~BIT(bit_idx);
   3498a:	fa04 f203 	lsl.w	r2, r4, r3
			if (consecutive_bit) {
   3498e:	b139      	cbz	r1, 349a0 <util_aa_le32+0xfc>
				aa &= ~BIT(bit_idx);
   34990:	ea20 0002 	bic.w	r0, r0, r2
				consecutive_bit = 0U;
   34994:	2100      	movs	r1, #0
			if (transitions != transitions_prev) {
   34996:	f1bc 0f01 	cmp.w	ip, #1
   3499a:	d0dd      	beq.n	34958 <util_aa_le32+0xb4>
	consecutive_cnt = 1U;
   3499c:	460a      	mov	r2, r1
   3499e:	e7a8      	b.n	348f2 <util_aa_le32+0x4e>
				aa |= BIT(bit_idx);
   349a0:	4310      	orrs	r0, r2
				consecutive_bit = 1U;
   349a2:	2101      	movs	r1, #1
   349a4:	e7f7      	b.n	34996 <util_aa_le32+0xf2>
		if ((consecutive_cnt > 6) ||
   349a6:	d001      	beq.n	349ac <util_aa_le32+0x108>
		    ((consecutive_cnt < 6) &&
   349a8:	2b1c      	cmp	r3, #28
   349aa:	d902      	bls.n	349b2 <util_aa_le32+0x10e>
		      ((bit_idx < 28) && (transitions < 2))))) {
   349ac:	4696      	mov	lr, r2
	consecutive_cnt = 1U;
   349ae:	460a      	mov	r2, r1
   349b0:	e79f      	b.n	348f2 <util_aa_le32+0x4e>
		     (((bit_idx < 29) && (transitions < 1)) ||
   349b2:	f1bc 0f00 	cmp.w	ip, #0
   349b6:	d10a      	bne.n	349ce <util_aa_le32+0x12a>
				aa &= ~BIT(bit_idx);
   349b8:	2201      	movs	r2, #1
   349ba:	fa02 fe03 	lsl.w	lr, r2, r3
			if (consecutive_bit) {
   349be:	b169      	cbz	r1, 349dc <util_aa_le32+0x138>
				aa &= ~BIT(bit_idx);
   349c0:	ea20 000e 	bic.w	r0, r0, lr
				consecutive_cnt = 1U;
   349c4:	468e      	mov	lr, r1
				consecutive_bit = 0U;
   349c6:	4661      	mov	r1, ip
	consecutive_cnt = 1U;
   349c8:	460a      	mov	r2, r1
				transitions++;
   349ca:	46f4      	mov	ip, lr
   349cc:	e791      	b.n	348f2 <util_aa_le32+0x4e>
		     (((bit_idx < 29) && (transitions < 1)) ||
   349ce:	2b1c      	cmp	r3, #28
   349d0:	d0ec      	beq.n	349ac <util_aa_le32+0x108>
		      ((bit_idx < 28) && (transitions < 2))))) {
   349d2:	f1bc 0f01 	cmp.w	ip, #1
   349d6:	d0d8      	beq.n	3498a <util_aa_le32+0xe6>
   349d8:	4696      	mov	lr, r2
   349da:	e7e8      	b.n	349ae <util_aa_le32+0x10a>
				consecutive_bit = 1U;
   349dc:	4611      	mov	r1, r2
				aa |= BIT(bit_idx);
   349de:	ea40 000e 	orr.w	r0, r0, lr
				transitions++;
   349e2:	4694      	mov	ip, r2
				consecutive_cnt = 1U;
   349e4:	4696      	mov	lr, r2
	consecutive_cnt = 1U;
   349e6:	460a      	mov	r2, r1
   349e8:	e783      	b.n	348f2 <util_aa_le32+0x4e>
   349ea:	bf00      	nop
   349ec:	8e89bed6 	.word	0x8e89bed6

000349f0 <ticker_dequeue>:
 * @return Total ticks until expiration for dequeued ticker node, or 0 if
 * node was not found
 * @internal
 */
static uint32_t ticker_dequeue(struct ticker_instance *instance, uint8_t id)
{
   349f0:	b530      	push	{r4, r5, lr}

	/* Find the ticker's position in ticker node list while accumulating
	 * ticks_to_expire
	 */
	node = &instance->nodes[0];
	previous = instance->ticker_id_head;
   349f2:	7e03      	ldrb	r3, [r0, #24]
	node = &instance->nodes[0];
   349f4:	6805      	ldr	r5, [r0, #0]
	current = previous;
	total = 0U;
	ticker_current = 0;
	while (current != TICKER_NULL) {
   349f6:	2bff      	cmp	r3, #255	; 0xff
   349f8:	d014      	beq.n	34a24 <ticker_dequeue+0x34>
		ticker_current = &node[current];
   349fa:	eb03 0243 	add.w	r2, r3, r3, lsl #1

		if (current == id) {
   349fe:	428b      	cmp	r3, r1
		ticker_current = &node[current];
   34a00:	eb05 1202 	add.w	r2, r5, r2, lsl #4
		if (current == id) {
   34a04:	d027      	beq.n	34a56 <ticker_dequeue+0x66>
	total = 0U;
   34a06:	f04f 0c00 	mov.w	ip, #0
   34a0a:	e001      	b.n	34a10 <ticker_dequeue+0x20>
		if (current == id) {
   34a0c:	4299      	cmp	r1, r3
   34a0e:	d00b      	beq.n	34a28 <ticker_dequeue+0x38>
			break;
		}

		total += ticker_current->ticks_to_expire;
   34a10:	469e      	mov	lr, r3
		previous = current;
		current = ticker_current->next;
   34a12:	7813      	ldrb	r3, [r2, #0]
		total += ticker_current->ticks_to_expire;
   34a14:	6894      	ldr	r4, [r2, #8]
	while (current != TICKER_NULL) {
   34a16:	2bff      	cmp	r3, #255	; 0xff
		ticker_current = &node[current];
   34a18:	eb03 0243 	add.w	r2, r3, r3, lsl #1
		total += ticker_current->ticks_to_expire;
   34a1c:	44a4      	add	ip, r4
		ticker_current = &node[current];
   34a1e:	eb05 1202 	add.w	r2, r5, r2, lsl #4
	while (current != TICKER_NULL) {
   34a22:	d1f3      	bne.n	34a0c <ticker_dequeue+0x1c>
	}

	if (current == TICKER_NULL) {
		/* Ticker not in active list */
		return 0;
   34a24:	2000      	movs	r0, #0
	if (ticker_current->next != TICKER_NULL) {
		node[ticker_current->next].ticks_to_expire += timeout;
	}

	return (total + timeout);
}
   34a26:	bd30      	pop	{r4, r5, pc}
	if (previous == current) {
   34a28:	4571      	cmp	r1, lr
   34a2a:	d017      	beq.n	34a5c <ticker_dequeue+0x6c>
	node[previous].next = ticker_current->next;
   34a2c:	fa0f fe8e 	sxth.w	lr, lr
   34a30:	7813      	ldrb	r3, [r2, #0]
	timeout = ticker_current->ticks_to_expire;
   34a32:	6890      	ldr	r0, [r2, #8]
	node[previous].next = ticker_current->next;
   34a34:	eb0e 0e4e 	add.w	lr, lr, lr, lsl #1
   34a38:	ea4f 1e0e 	mov.w	lr, lr, lsl #4
	if (ticker_current->next != TICKER_NULL) {
   34a3c:	2bff      	cmp	r3, #255	; 0xff
	node[previous].next = ticker_current->next;
   34a3e:	f805 300e 	strb.w	r3, [r5, lr]
	if (ticker_current->next != TICKER_NULL) {
   34a42:	d006      	beq.n	34a52 <ticker_dequeue+0x62>
		node[ticker_current->next].ticks_to_expire += timeout;
   34a44:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   34a48:	eb05 1303 	add.w	r3, r5, r3, lsl #4
   34a4c:	689a      	ldr	r2, [r3, #8]
   34a4e:	4402      	add	r2, r0
   34a50:	609a      	str	r2, [r3, #8]
	return (total + timeout);
   34a52:	4460      	add	r0, ip
}
   34a54:	bd30      	pop	{r4, r5, pc}
	previous = instance->ticker_id_head;
   34a56:	469e      	mov	lr, r3
	total = 0U;
   34a58:	f04f 0c00 	mov.w	ip, #0
		instance->ticker_id_head = ticker_current->next;
   34a5c:	7813      	ldrb	r3, [r2, #0]
   34a5e:	7603      	strb	r3, [r0, #24]
   34a60:	e7e4      	b.n	34a2c <ticker_dequeue+0x3c>
   34a62:	bf00      	nop

00034a64 <ticks_to_expire_prep>:
{
	uint32_t ticks_to_expire = ticker->ticks_to_expire;
	uint32_t ticks_to_expire_minus = ticker->ticks_to_expire_minus;

	/* Calculate ticks to expire for this new node */
	if (!((ticks_at_start - ticks_current) & BIT(HAL_TICKER_CNTR_MSBIT))) {
   34a64:	eba2 0c01 	sub.w	ip, r2, r1
   34a68:	f41c 0f00 	tst.w	ip, #8388608	; 0x800000
{
   34a6c:	b410      	push	{r4}
	uint32_t ticks_to_expire = ticker->ticks_to_expire;
   34a6e:	6883      	ldr	r3, [r0, #8]
	uint32_t ticks_to_expire_minus = ticker->ticks_to_expire_minus;
   34a70:	6944      	ldr	r4, [r0, #20]
	if (!((ticks_at_start - ticks_current) & BIT(HAL_TICKER_CNTR_MSBIT))) {
   34a72:	d10a      	bne.n	34a8a <ticks_to_expire_prep+0x26>
 * @param ticks_now Highest tick count (now)
 * @param ticks_old Tick count to subtract from ticks_now
 */
uint32_t ticker_ticks_diff_get(uint32_t ticks_now, uint32_t ticks_old)
{
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   34a74:	f02c 4c7f 	bic.w	ip, ip, #4278190080	; 0xff000000
		ticks_to_expire += ticker_ticks_diff_get(ticks_at_start,
   34a78:	4463      	add	r3, ip
	if (ticks_to_expire > ticks_to_expire_minus) {
   34a7a:	42a3      	cmp	r3, r4
   34a7c:	d80d      	bhi.n	34a9a <ticks_to_expire_prep+0x36>
		ticks_to_expire_minus -= ticks_to_expire;
   34a7e:	1ae4      	subs	r4, r4, r3
		ticks_to_expire = 0U;
   34a80:	2300      	movs	r3, #0
	ticker->ticks_to_expire_minus = ticks_to_expire_minus;
   34a82:	6144      	str	r4, [r0, #20]
	ticker->ticks_to_expire = ticks_to_expire;
   34a84:	6083      	str	r3, [r0, #8]
}
   34a86:	bc10      	pop	{r4}
   34a88:	4770      	bx	lr
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   34a8a:	1a89      	subs	r1, r1, r2
   34a8c:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
		if (ticks_to_expire > delta_current_start) {
   34a90:	428b      	cmp	r3, r1
   34a92:	d908      	bls.n	34aa6 <ticks_to_expire_prep+0x42>
			ticks_to_expire -= delta_current_start;
   34a94:	1a5b      	subs	r3, r3, r1
	if (ticks_to_expire > ticks_to_expire_minus) {
   34a96:	42a3      	cmp	r3, r4
   34a98:	d9f1      	bls.n	34a7e <ticks_to_expire_prep+0x1a>
		ticks_to_expire -= ticks_to_expire_minus;
   34a9a:	1b1b      	subs	r3, r3, r4
		ticks_to_expire_minus = 0U;
   34a9c:	2400      	movs	r4, #0
	ticker->ticks_to_expire_minus = ticks_to_expire_minus;
   34a9e:	6144      	str	r4, [r0, #20]
	ticker->ticks_to_expire = ticks_to_expire;
   34aa0:	6083      	str	r3, [r0, #8]
}
   34aa2:	bc10      	pop	{r4}
   34aa4:	4770      	bx	lr
			ticks_to_expire_minus +=
   34aa6:	440c      	add	r4, r1
   34aa8:	1ae4      	subs	r4, r4, r3
	if (ticks_to_expire > ticks_to_expire_minus) {
   34aaa:	e7e9      	b.n	34a80 <ticks_to_expire_prep+0x1c>

00034aac <ticker_job_list_insert>:
{
   34aac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   34ab0:	4607      	mov	r7, r0
   34ab2:	b087      	sub	sp, #28
	count_user = instance->count_user;
   34ab4:	7a40      	ldrb	r0, [r0, #9]
	node = &instance->nodes[0];
   34ab6:	683b      	ldr	r3, [r7, #0]
	users = &instance->users[0];
   34ab8:	687d      	ldr	r5, [r7, #4]
	node = &instance->nodes[0];
   34aba:	9301      	str	r3, [sp, #4]
	while (count_user--) {
   34abc:	2800      	cmp	r0, #0
   34abe:	f000 80ea 	beq.w	34c96 <ticker_job_list_insert+0x1ea>
   34ac2:	1e42      	subs	r2, r0, #1
   34ac4:	b2d2      	uxtb	r2, r2
   34ac6:	eb05 02c2 	add.w	r2, r5, r2, lsl #3
   34aca:	46bb      	mov	fp, r7
   34acc:	9202      	str	r2, [sp, #8]
   34ace:	9505      	str	r5, [sp, #20]
   34ad0:	460f      	mov	r7, r1
		user_ops = (void *)&user->user_op[0];
   34ad2:	9b02      	ldr	r3, [sp, #8]
   34ad4:	685a      	ldr	r2, [r3, #4]
		user_ops_first = user->first;
   34ad6:	f893 8001 	ldrb.w	r8, [r3, #1]
		user_ops = (void *)&user->user_op[0];
   34ada:	9204      	str	r2, [sp, #16]
		while ((insert_head != TICKER_NULL) ||
   34adc:	f8cd 800c 	str.w	r8, [sp, #12]
   34ae0:	2fff      	cmp	r7, #255	; 0xff
   34ae2:	d05e      	beq.n	34ba2 <ticker_job_list_insert+0xf6>
				ticker = &node[id_insert];
   34ae4:	eb07 0447 	add.w	r4, r7, r7, lsl #1
   34ae8:	9b01      	ldr	r3, [sp, #4]
   34aea:	0126      	lsls	r6, r4, #4
   34aec:	46ba      	mov	sl, r7
				insert_head = ticker->next;
   34aee:	5d9f      	ldrb	r7, [r3, r6]
				ticker = &node[id_insert];
   34af0:	eb03 1404 	add.w	r4, r3, r4, lsl #4
				user_op = NULL;
   34af4:	2500      	movs	r5, #0
	ticker->next = TICKER_NULL;
   34af6:	f04f 0eff 	mov.w	lr, #255	; 0xff
   34afa:	f884 e000 	strb.w	lr, [r4]
	node = &instance->nodes[0];
   34afe:	f8db c000 	ldr.w	ip, [fp]
	current = instance->ticker_id_head;
   34b02:	f89b 2018 	ldrb.w	r2, [fp, #24]
	ticker_new = &node[id];
   34b06:	eb0c 0906 	add.w	r9, ip, r6
	while ((current != TICKER_NULL) && (ticks_to_expire >=
   34b0a:	4572      	cmp	r2, lr
	ticks_to_expire = ticker_new->ticks_to_expire;
   34b0c:	f8d9 1008 	ldr.w	r1, [r9, #8]
	while ((current != TICKER_NULL) && (ticks_to_expire >=
   34b10:	d10d      	bne.n	34b2e <ticker_job_list_insert+0x82>
   34b12:	e0bb      	b.n	34c8c <ticker_job_list_insert+0x1e0>
		if (ticks_to_expire == 0 && (ticker_new->lazy_current >
   34b14:	1a09      	subs	r1, r1, r0
   34b16:	d104      	bne.n	34b22 <ticker_job_list_insert+0x76>
   34b18:	f8b9 801e 	ldrh.w	r8, [r9, #30]
   34b1c:	8bf6      	ldrh	r6, [r6, #30]
   34b1e:	45b0      	cmp	r8, r6
   34b20:	d876      	bhi.n	34c10 <ticker_job_list_insert+0x164>
		current = ticker_current->next;
   34b22:	f81c 3003 	ldrb.w	r3, [ip, r3]
	while ((current != TICKER_NULL) && (ticks_to_expire >=
   34b26:	2bff      	cmp	r3, #255	; 0xff
   34b28:	4696      	mov	lr, r2
		current = ticker_current->next;
   34b2a:	461a      	mov	r2, r3
	while ((current != TICKER_NULL) && (ticks_to_expire >=
   34b2c:	d007      	beq.n	34b3e <ticker_job_list_insert+0x92>
		(ticker_current = &node[current])->ticks_to_expire))) {
   34b2e:	eb02 0342 	add.w	r3, r2, r2, lsl #1
   34b32:	eb0c 1603 	add.w	r6, ip, r3, lsl #4
   34b36:	011b      	lsls	r3, r3, #4
		(ticks_to_expire_current =
   34b38:	68b0      	ldr	r0, [r6, #8]
	while ((current != TICKER_NULL) && (ticks_to_expire >=
   34b3a:	4288      	cmp	r0, r1
   34b3c:	d9ea      	bls.n	34b14 <ticker_job_list_insert+0x68>
	if (previous == TICKER_NULL) {
   34b3e:	f1be 0fff 	cmp.w	lr, #255	; 0xff
	ticker_new->ticks_to_expire = ticks_to_expire;
   34b42:	f8c9 1008 	str.w	r1, [r9, #8]
	ticker_new->next = current;
   34b46:	f889 2000 	strb.w	r2, [r9]
	if (previous == TICKER_NULL) {
   34b4a:	d05e      	beq.n	34c0a <ticker_job_list_insert+0x15e>
		node[previous].next = id;
   34b4c:	fa0f fe8e 	sxth.w	lr, lr
   34b50:	eb0e 0e4e 	add.w	lr, lr, lr, lsl #1
   34b54:	ea4f 1e0e 	mov.w	lr, lr, lsl #4
   34b58:	f80c a00e 	strb.w	sl, [ip, lr]
	if (current != TICKER_NULL) {
   34b5c:	2aff      	cmp	r2, #255	; 0xff
   34b5e:	d008      	beq.n	34b72 <ticker_job_list_insert+0xc6>
		node[current].ticks_to_expire -= ticks_to_expire;
   34b60:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   34b64:	eb0c 1c02 	add.w	ip, ip, r2, lsl #4
   34b68:	f8dc 3008 	ldr.w	r3, [ip, #8]
   34b6c:	1a5b      	subs	r3, r3, r1
   34b6e:	f8cc 3008 	str.w	r3, [ip, #8]
	ticker->req = ticker->ack + 1;
   34b72:	78a3      	ldrb	r3, [r4, #2]
   34b74:	3301      	adds	r3, #1
   34b76:	7063      	strb	r3, [r4, #1]
			if (user_op) {
   34b78:	2d00      	cmp	r5, #0
   34b7a:	d0b1      	beq.n	34ae0 <ticker_job_list_insert+0x34>
	user_op->op = TICKER_USER_OP_TYPE_NONE;
   34b7c:	f04f 0200 	mov.w	r2, #0
	if (user_op->fp_op_func) {
   34b80:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
	user_op->op = TICKER_USER_OP_TYPE_NONE;
   34b82:	702a      	strb	r2, [r5, #0]
	user_op->status = status;
   34b84:	2200      	movs	r2, #0
   34b86:	62aa      	str	r2, [r5, #40]	; 0x28
	if (user_op->fp_op_func) {
   34b88:	b113      	cbz	r3, 34b90 <ticker_job_list_insert+0xe4>
		user_op->fp_op_func(user_op->status, user_op->op_context);
   34b8a:	6b29      	ldr	r1, [r5, #48]	; 0x30
   34b8c:	4610      	mov	r0, r2
   34b8e:	4798      	blx	r3
				if (!IS_ENABLED(CONFIG_BT_TICKER_LOW_LAT) &&
   34b90:	6863      	ldr	r3, [r4, #4]
   34b92:	2b00      	cmp	r3, #0
   34b94:	d1a4      	bne.n	34ae0 <ticker_job_list_insert+0x34>
						user_op->fp_op_func;
   34b96:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
					ticker->fp_op_func =
   34b98:	6223      	str	r3, [r4, #32]
						user_op->op_context;
   34b9a:	6b2b      	ldr	r3, [r5, #48]	; 0x30
					ticker->op_context =
   34b9c:	6263      	str	r3, [r4, #36]	; 0x24
		while ((insert_head != TICKER_NULL) ||
   34b9e:	2fff      	cmp	r7, #255	; 0xff
   34ba0:	d1a0      	bne.n	34ae4 <ticker_job_list_insert+0x38>
   34ba2:	9b02      	ldr	r3, [sp, #8]
   34ba4:	e9dd 8903 	ldrd	r8, r9, [sp, #12]
   34ba8:	789a      	ldrb	r2, [r3, #2]
				user_op = &user_ops[user_ops_first];
   34baa:	eb08 0348 	add.w	r3, r8, r8, lsl #1
   34bae:	eb08 0383 	add.w	r3, r8, r3, lsl #2
				first = user_ops_first + 1;
   34bb2:	f108 0101 	add.w	r1, r8, #1
		while ((insert_head != TICKER_NULL) ||
   34bb6:	4542      	cmp	r2, r8
				user_op = &user_ops[user_ops_first];
   34bb8:	eb09 0583 	add.w	r5, r9, r3, lsl #2
				first = user_ops_first + 1;
   34bbc:	fa5f f881 	uxtb.w	r8, r1
		while ((insert_head != TICKER_NULL) ||
   34bc0:	d05c      	beq.n	34c7c <ticker_job_list_insert+0x1d0>
				if (first == user->count_user_op) {
   34bc2:	9902      	ldr	r1, [sp, #8]
   34bc4:	7808      	ldrb	r0, [r1, #0]
				if (user_op->op != TICKER_USER_OP_TYPE_START) {
   34bc6:	f819 1023 	ldrb.w	r1, [r9, r3, lsl #2]
					first = 0U;
   34bca:	4540      	cmp	r0, r8
   34bcc:	bf08      	it	eq
   34bce:	f04f 0800 	moveq.w	r8, #0
				if (user_op->op != TICKER_USER_OP_TYPE_START) {
   34bd2:	2904      	cmp	r1, #4
   34bd4:	d1e9      	bne.n	34baa <ticker_job_list_insert+0xfe>
				id_insert = user_op->id;
   34bd6:	f895 a001 	ldrb.w	sl, [r5, #1]
				ticker = &node[id_insert];
   34bda:	9901      	ldr	r1, [sp, #4]
   34bdc:	eb0a 024a 	add.w	r2, sl, sl, lsl #1
   34be0:	eb01 1402 	add.w	r4, r1, r2, lsl #4
   34be4:	0116      	lsls	r6, r2, #4
				if (((ticker->req -
   34be6:	7861      	ldrb	r1, [r4, #1]
   34be8:	78a2      	ldrb	r2, [r4, #2]
   34bea:	4291      	cmp	r1, r2
	user_op->status = status;
   34bec:	f04f 0001 	mov.w	r0, #1
				if (((ticker->req -
   34bf0:	d010      	beq.n	34c14 <ticker_job_list_insert+0x168>
	user_op->op = TICKER_USER_OP_TYPE_NONE;
   34bf2:	f04f 0200 	mov.w	r2, #0
   34bf6:	f809 2023 	strb.w	r2, [r9, r3, lsl #2]
	if (user_op->fp_op_func) {
   34bfa:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
	user_op->status = status;
   34bfc:	62a8      	str	r0, [r5, #40]	; 0x28
	if (user_op->fp_op_func) {
   34bfe:	b10b      	cbz	r3, 34c04 <ticker_job_list_insert+0x158>
		user_op->fp_op_func(user_op->status, user_op->op_context);
   34c00:	6b29      	ldr	r1, [r5, #48]	; 0x30
   34c02:	4798      	blx	r3
   34c04:	9b02      	ldr	r3, [sp, #8]
   34c06:	789a      	ldrb	r2, [r3, #2]
		while ((insert_head != TICKER_NULL) ||
   34c08:	e7cf      	b.n	34baa <ticker_job_list_insert+0xfe>
		instance->ticker_id_head = id;
   34c0a:	f88b a018 	strb.w	sl, [fp, #24]
   34c0e:	e7a5      	b.n	34b5c <ticker_job_list_insert+0xb0>
		(ticks_to_expire_current =
   34c10:	4601      	mov	r1, r0
   34c12:	e794      	b.n	34b3e <ticker_job_list_insert+0x92>
	if (start->lazy != TICKER_LAZY_MUST_EXPIRE_KEEP) {
   34c14:	8aab      	ldrh	r3, [r5, #20]
				ticker_job_op_start(ticker, user_op,
   34c16:	f8db 1014 	ldr.w	r1, [fp, #20]
	if (start->lazy != TICKER_LAZY_MUST_EXPIRE_KEEP) {
   34c1a:	f8cd 800c 	str.w	r8, [sp, #12]
   34c1e:	f64f 72fe 	movw	r2, #65534	; 0xfffe
   34c22:	4293      	cmp	r3, r2
   34c24:	d007      	beq.n	34c36 <ticker_job_list_insert+0x18a>
		ticker->must_expire =
   34c26:	f64f 72ff 	movw	r2, #65535	; 0xffff
   34c2a:	1a9b      	subs	r3, r3, r2
   34c2c:	fab3 f383 	clz	r3, r3
   34c30:	095b      	lsrs	r3, r3, #5
   34c32:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
	ticker->ext_data = start->ext_data;
   34c36:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   34c38:	62a3      	str	r3, [r4, #40]	; 0x28
	ticker->ticks_periodic = start->ticks_periodic;
   34c3a:	68eb      	ldr	r3, [r5, #12]
   34c3c:	6063      	str	r3, [r4, #4]
	ticker->remainder_periodic = start->remainder_periodic;
   34c3e:	692b      	ldr	r3, [r5, #16]
   34c40:	6223      	str	r3, [r4, #32]
		(start->lazy < TICKER_LAZY_MUST_EXPIRE_KEEP) ? start->lazy :
   34c42:	8aab      	ldrh	r3, [r5, #20]
	ticker->lazy_periodic =
   34c44:	f64f 72fd 	movw	r2, #65533	; 0xfffd
   34c48:	4293      	cmp	r3, r2
   34c4a:	bf88      	it	hi
   34c4c:	2300      	movhi	r3, #0
   34c4e:	83a3      	strh	r3, [r4, #28]
	ticker->ticks_slot = start->ticks_slot;
   34c50:	69ab      	ldr	r3, [r5, #24]
   34c52:	61a3      	str	r3, [r4, #24]
	ticker->timeout_func = start->fp_timeout_func;
   34c54:	69eb      	ldr	r3, [r5, #28]
   34c56:	60e3      	str	r3, [r4, #12]
	ticker->context = start->context;
   34c58:	6a2b      	ldr	r3, [r5, #32]
   34c5a:	6123      	str	r3, [r4, #16]
	ticker->ticks_to_expire = start->ticks_first;
   34c5c:	68ab      	ldr	r3, [r5, #8]
   34c5e:	60a3      	str	r3, [r4, #8]
	ticker->ticks_to_expire_minus = 0U;
   34c60:	2300      	movs	r3, #0
   34c62:	6163      	str	r3, [r4, #20]
	ticks_to_expire_prep(ticker, ticks_current, start->ticks_at_start);
   34c64:	686a      	ldr	r2, [r5, #4]
   34c66:	4620      	mov	r0, r4
	ticker->ticks_to_expire_minus = 0U;
   34c68:	4698      	mov	r8, r3
	ticks_to_expire_prep(ticker, ticks_current, start->ticks_at_start);
   34c6a:	f7ff fefb 	bl	34a64 <ticks_to_expire_prep>
	ticker->force = 1U;
   34c6e:	2301      	movs	r3, #1
	ticker->remainder_current = 0U;
   34c70:	f8c4 8024 	str.w	r8, [r4, #36]	; 0x24
	ticker->lazy_current = 0U;
   34c74:	f8a4 801e 	strh.w	r8, [r4, #30]
	ticker->force = 1U;
   34c78:	70e3      	strb	r3, [r4, #3]
}
   34c7a:	e73c      	b.n	34af6 <ticker_job_list_insert+0x4a>
	while (count_user--) {
   34c7c:	9a02      	ldr	r2, [sp, #8]
   34c7e:	9905      	ldr	r1, [sp, #20]
   34c80:	4291      	cmp	r1, r2
   34c82:	f1a2 0308 	sub.w	r3, r2, #8
   34c86:	d006      	beq.n	34c96 <ticker_job_list_insert+0x1ea>
   34c88:	9302      	str	r3, [sp, #8]
   34c8a:	e722      	b.n	34ad2 <ticker_job_list_insert+0x26>
	ticker_new->next = current;
   34c8c:	f80c 2006 	strb.w	r2, [ip, r6]
		instance->ticker_id_head = id;
   34c90:	f88b a018 	strb.w	sl, [fp, #24]
	if (current != TICKER_NULL) {
   34c94:	e76d      	b.n	34b72 <ticker_job_list_insert+0xc6>
}
   34c96:	b007      	add	sp, #28
   34c98:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00034c9c <ticker_worker>:
{
   34c9c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (instance->job_guard) {
   34ca0:	7e47      	ldrb	r7, [r0, #25]
	instance->worker_trigger = 1U;
   34ca2:	2301      	movs	r3, #1
{
   34ca4:	b089      	sub	sp, #36	; 0x24
	instance->worker_trigger = 1U;
   34ca6:	7683      	strb	r3, [r0, #26]
	if (instance->job_guard) {
   34ca8:	2f00      	cmp	r7, #0
   34caa:	d153      	bne.n	34d54 <ticker_worker+0xb8>
	if (instance->ticker_id_head == TICKER_NULL) {
   34cac:	7e03      	ldrb	r3, [r0, #24]
   34cae:	2bff      	cmp	r3, #255	; 0xff
   34cb0:	4682      	mov	sl, r0
   34cb2:	d04e      	beq.n	34d52 <ticker_worker+0xb6>
	ticks_elapsed = ticker_ticks_diff_get(cntr_cnt_get(),
   34cb4:	f00c feae 	bl	41a14 <cntr_cnt_get>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   34cb8:	f8da 2014 	ldr.w	r2, [sl, #20]
	if (instance->ticks_slot_previous > ticks_elapsed) {
   34cbc:	f8da 301c 	ldr.w	r3, [sl, #28]
	ticker_id_head = instance->ticker_id_head;
   34cc0:	f89a 4018 	ldrb.w	r4, [sl, #24]
	node = &instance->nodes[0];
   34cc4:	f8da b000 	ldr.w	fp, [sl]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   34cc8:	1a86      	subs	r6, r0, r2
   34cca:	f026 467f 	bic.w	r6, r6, #4278190080	; 0xff000000
	if (instance->ticks_slot_previous > ticks_elapsed) {
   34cce:	42b3      	cmp	r3, r6
   34cd0:	bf94      	ite	ls
   34cd2:	2300      	movls	r3, #0
   34cd4:	2301      	movhi	r3, #1
	while (ticker_id_head != TICKER_NULL) {
   34cd6:	2cff      	cmp	r4, #255	; 0xff
	if (instance->ticks_slot_previous > ticks_elapsed) {
   34cd8:	9303      	str	r3, [sp, #12]
	ticks_expired = 0U;
   34cda:	46b9      	mov	r9, r7
	while (ticker_id_head != TICKER_NULL) {
   34cdc:	d043      	beq.n	34d66 <ticker_worker+0xca>
			ticker->ext_data->ticks_drift = 0U;
   34cde:	9704      	str	r7, [sp, #16]
		ticker = &node[ticker_id_head];
   34ce0:	eb04 0444 	add.w	r4, r4, r4, lsl #1
   34ce4:	eb0b 1504 	add.w	r5, fp, r4, lsl #4
   34ce8:	0124      	lsls	r4, r4, #4
		ticks_to_expire = ticker->ticks_to_expire;
   34cea:	68ab      	ldr	r3, [r5, #8]
		if (ticks_elapsed < ticks_to_expire) {
   34cec:	42b3      	cmp	r3, r6
   34cee:	d839      	bhi.n	34d64 <ticker_worker+0xc8>
		if (((ticker->req - ticker->ack) & 0xff) != 1U) {
   34cf0:	78aa      	ldrb	r2, [r5, #2]
		ticker_id_head = ticker->next;
   34cf2:	f81b 4004 	ldrb.w	r4, [fp, r4]
		ticks_elapsed -= ticks_to_expire;
   34cf6:	1af6      	subs	r6, r6, r3
		ticks_expired += ticks_to_expire;
   34cf8:	4499      	add	r9, r3
		if (((ticker->req - ticker->ack) & 0xff) != 1U) {
   34cfa:	786b      	ldrb	r3, [r5, #1]
   34cfc:	1a9b      	subs	r3, r3, r2
   34cfe:	b2db      	uxtb	r3, r3
   34d00:	2b01      	cmp	r3, #1
   34d02:	d12d      	bne.n	34d60 <ticker_worker+0xc4>
		if (ticker->ticks_slot != 0U &&
   34d04:	f8d5 c018 	ldr.w	ip, [r5, #24]
   34d08:	f1bc 0f00 	cmp.w	ip, #0
   34d0c:	d04f      	beq.n	34dae <ticker_worker+0x112>
   34d0e:	9b03      	ldr	r3, [sp, #12]
   34d10:	2b00      	cmp	r3, #0
   34d12:	f000 8081 	beq.w	34e18 <ticker_worker+0x17c>
			struct ticker_ext *ext_data = ticker->ext_data;
   34d16:	6aab      	ldr	r3, [r5, #40]	; 0x28
			if (ext_data &&
   34d18:	b143      	cbz	r3, 34d2c <ticker_worker+0x90>
   34d1a:	681a      	ldr	r2, [r3, #0]
   34d1c:	b11a      	cbz	r2, 34d26 <ticker_worker+0x8a>
			    ext_data->ticks_slot_window != 0U &&
   34d1e:	7a1a      	ldrb	r2, [r3, #8]
   34d20:	2a00      	cmp	r2, #0
   34d22:	f000 80c1 	beq.w	34ea8 <ticker_worker+0x20c>
				ext_data->reschedule_state =
   34d26:	f04f 0200 	mov.w	r2, #0
   34d2a:	721a      	strb	r2, [r3, #8]
			ticker->lazy_current++;
   34d2c:	8beb      	ldrh	r3, [r5, #30]
			if ((ticker->must_expire == 0U) ||
   34d2e:	f895 202c 	ldrb.w	r2, [r5, #44]	; 0x2c
			ticker->lazy_current++;
   34d32:	3301      	adds	r3, #1
   34d34:	b29b      	uxth	r3, r3
   34d36:	83eb      	strh	r3, [r5, #30]
			if ((ticker->must_expire == 0U) ||
   34d38:	b17a      	cbz	r2, 34d5a <ticker_worker+0xbe>
   34d3a:	8baa      	ldrh	r2, [r5, #28]
   34d3c:	429a      	cmp	r2, r3
   34d3e:	d20c      	bcs.n	34d5a <ticker_worker+0xbe>
			    TICKER_RESCHEDULE_PENDING(ticker)) {
   34d40:	6aab      	ldr	r3, [r5, #40]	; 0x28
			    (ticker->lazy_periodic >= ticker->lazy_current) ||
   34d42:	2b00      	cmp	r3, #0
   34d44:	f000 80c3 	beq.w	34ece <ticker_worker+0x232>
			    TICKER_RESCHEDULE_PENDING(ticker)) {
   34d48:	7a1a      	ldrb	r2, [r3, #8]
   34d4a:	2a01      	cmp	r2, #1
   34d4c:	d005      	beq.n	34d5a <ticker_worker+0xbe>
			must_expire_skip = 1U;
   34d4e:	2701      	movs	r7, #1
   34d50:	e030      	b.n	34db4 <ticker_worker+0x118>
		instance->worker_trigger = 0U;
   34d52:	7687      	strb	r7, [r0, #26]
}
   34d54:	b009      	add	sp, #36	; 0x24
   34d56:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				ticker->ack--;
   34d5a:	78ab      	ldrb	r3, [r5, #2]
   34d5c:	3b01      	subs	r3, #1
   34d5e:	70ab      	strb	r3, [r5, #2]
	while (ticker_id_head != TICKER_NULL) {
   34d60:	2cff      	cmp	r4, #255	; 0xff
   34d62:	d1bd      	bne.n	34ce0 <ticker_worker+0x44>
   34d64:	9f04      	ldr	r7, [sp, #16]
	if (instance->ticks_elapsed_first == instance->ticks_elapsed_last) {
   34d66:	f89a 300b 	ldrb.w	r3, [sl, #11]
   34d6a:	f89a 200a 	ldrb.w	r2, [sl, #10]
   34d6e:	429a      	cmp	r2, r3
   34d70:	d108      	bne.n	34d84 <ticker_worker+0xe8>
	uint8_t idx = *ticks_elapsed_index + 1;
   34d72:	3201      	adds	r2, #1
   34d74:	b2d2      	uxtb	r2, r2
	if (idx == DOUBLE_BUFFER_SIZE) {
   34d76:	2a02      	cmp	r2, #2
	instance->ticks_elapsed[instance->ticks_elapsed_last] = ticks_expired;
   34d78:	bf1a      	itte	ne
   34d7a:	4617      	movne	r7, r2
   34d7c:	463b      	movne	r3, r7
   34d7e:	2300      	moveq	r3, #0
	*ticks_elapsed_index = idx;
   34d80:	f88a 700b 	strb.w	r7, [sl, #11]
	instance->ticks_elapsed[instance->ticks_elapsed_last] = ticks_expired;
   34d84:	eb0a 0383 	add.w	r3, sl, r3, lsl #2
	instance->worker_trigger = 0U;
   34d88:	2200      	movs	r2, #0
	instance->ticks_elapsed[instance->ticks_elapsed_last] = ticks_expired;
   34d8a:	f8c3 900c 	str.w	r9, [r3, #12]
	instance->sched_cb(TICKER_CALL_ID_WORKER, TICKER_CALL_ID_JOB, 1,
   34d8e:	f8da 4024 	ldr.w	r4, [sl, #36]	; 0x24
	instance->worker_trigger = 0U;
   34d92:	f88a 201a 	strb.w	r2, [sl, #26]
	instance->sched_cb(TICKER_CALL_ID_WORKER, TICKER_CALL_ID_JOB, 1,
   34d96:	4653      	mov	r3, sl
   34d98:	2201      	movs	r2, #1
   34d9a:	2104      	movs	r1, #4
   34d9c:	2003      	movs	r0, #3
   34d9e:	46a4      	mov	ip, r4
}
   34da0:	b009      	add	sp, #36	; 0x24
   34da2:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	instance->sched_cb(TICKER_CALL_ID_WORKER, TICKER_CALL_ID_JOB, 1,
   34da6:	4760      	bx	ip
   34da8:	9e05      	ldr	r6, [sp, #20]
   34daa:	9a06      	ldr	r2, [sp, #24]
   34dac:	4674      	mov	r4, lr
		if (ticker->ext_data) {
   34dae:	6aab      	ldr	r3, [r5, #40]	; 0x28
   34db0:	b37b      	cbz	r3, 34e12 <ticker_worker+0x176>
   34db2:	2700      	movs	r7, #0
			ticker->ext_data->ticks_drift = 0U;
   34db4:	2200      	movs	r2, #0
			ticks_drift = ticker->ext_data->ticks_drift;
   34db6:	6859      	ldr	r1, [r3, #4]
			ticker->ext_data->ticks_drift = 0U;
   34db8:	605a      	str	r2, [r3, #4]
			ticker->ext_data->reschedule_state =
   34dba:	6aab      	ldr	r3, [r5, #40]	; 0x28
   34dbc:	721a      	strb	r2, [r3, #8]
		ticker->ack--;
   34dbe:	78aa      	ldrb	r2, [r5, #2]
		if (ticker->timeout_func) {
   34dc0:	f8d5 800c 	ldr.w	r8, [r5, #12]
		ticker->ack--;
   34dc4:	3a01      	subs	r2, #1
   34dc6:	70aa      	strb	r2, [r5, #2]
		if (ticker->timeout_func) {
   34dc8:	f1b8 0f00 	cmp.w	r8, #0
   34dcc:	d0c8      	beq.n	34d60 <ticker_worker+0xc4>
					   ticks_expired -
   34dce:	696b      	ldr	r3, [r5, #20]
   34dd0:	f8da 2014 	ldr.w	r2, [sl, #20]
			ticker->timeout_func(ticks_at_expire,
   34dd4:	f895 c003 	ldrb.w	ip, [r5, #3]
					   ticks_expired -
   34dd8:	eba9 0303 	sub.w	r3, r9, r3
   34ddc:	4413      	add	r3, r2
			ticks_at_expire = (instance->ticks_current +
   34dde:	f023 407f 	bic.w	r0, r3, #4278190080	; 0xff000000
			ticker->timeout_func(ticks_at_expire,
   34de2:	6a6a      	ldr	r2, [r5, #36]	; 0x24
   34de4:	692b      	ldr	r3, [r5, #16]
   34de6:	b977      	cbnz	r7, 34e06 <ticker_worker+0x16a>
   34de8:	f8b5 e01e 	ldrh.w	lr, [r5, #30]
   34dec:	e9cd c300 	strd	ip, r3, [sp]
   34df0:	4673      	mov	r3, lr
   34df2:	47c0      	blx	r8
				if (ticker->ticks_slot != 0U) {
   34df4:	69ab      	ldr	r3, [r5, #24]
				ticker->lazy_current = 0U;
   34df6:	83ef      	strh	r7, [r5, #30]
					slot_reserved = 1U;
   34df8:	2b00      	cmp	r3, #0
   34dfa:	9b03      	ldr	r3, [sp, #12]
				ticker->force = 0U;
   34dfc:	70ef      	strb	r7, [r5, #3]
					slot_reserved = 1U;
   34dfe:	bf18      	it	ne
   34e00:	2301      	movne	r3, #1
   34e02:	9303      	str	r3, [sp, #12]
   34e04:	e7ac      	b.n	34d60 <ticker_worker+0xc4>
			ticker->timeout_func(ticks_at_expire,
   34e06:	e9cd c300 	strd	ip, r3, [sp]
   34e0a:	f64f 73ff 	movw	r3, #65535	; 0xffff
   34e0e:	47c0      	blx	r8
			if (!IS_ENABLED(CONFIG_BT_TICKER_LOW_LAT) &&
   34e10:	e7a6      	b.n	34d60 <ticker_worker+0xc4>
   34e12:	461f      	mov	r7, r3
			ticks_drift = 0U;
   34e14:	4619      	mov	r1, r3
   34e16:	e7d3      	b.n	34dc0 <ticker_worker+0x124>
	if (ticker->next != TICKER_NULL) {
   34e18:	2cff      	cmp	r4, #255	; 0xff
   34e1a:	d0c8      	beq.n	34dae <ticker_worker+0x112>
		uint16_t lazy_current = ticker->lazy_current;
   34e1c:	8be9      	ldrh	r1, [r5, #30]
		if (lazy_current >= ticker->lazy_periodic) {
   34e1e:	8bab      	ldrh	r3, [r5, #28]
		uint32_t current_age = ticker->ticks_periodic +
   34e20:	6868      	ldr	r0, [r5, #4]
		if (lazy_current >= ticker->lazy_periodic) {
   34e22:	4299      	cmp	r1, r3
			lazy_current -= ticker->lazy_periodic;
   34e24:	bf24      	itt	cs
   34e26:	1acb      	subcs	r3, r1, r3
   34e28:	b299      	uxthcs	r1, r3
			struct ticker_node *ticker_next = &nodes[id_head];
   34e2a:	eb04 0344 	add.w	r3, r4, r4, lsl #1
   34e2e:	eb0b 1303 	add.w	r3, fp, r3, lsl #4
		uint32_t current_age = ticker->ticks_periodic +
   34e32:	fb01 0100 	mla	r1, r1, r0, r0
			acc_ticks_to_expire += ticker_next->ticks_to_expire;
   34e36:	689f      	ldr	r7, [r3, #8]
		uint32_t current_age = ticker->ticks_periodic +
   34e38:	9107      	str	r1, [sp, #28]
			if (acc_ticks_to_expire > ticker->ticks_slot) {
   34e3a:	4567      	cmp	r7, ip
   34e3c:	d8b7      	bhi.n	34dae <ticker_worker+0x112>
   34e3e:	9605      	str	r6, [sp, #20]
			acc_ticks_to_expire += ticker_next->ticks_to_expire;
   34e40:	4639      	mov	r1, r7
   34e42:	46a6      	mov	lr, r4
   34e44:	4606      	mov	r6, r0
   34e46:	9206      	str	r2, [sp, #24]
   34e48:	e010      	b.n	34e6c <ticker_worker+0x1d0>
					  0U :
   34e4a:	2c00      	cmp	r4, #0
   34e4c:	d134      	bne.n	34eb8 <ticker_worker+0x21c>
			     (next_is_critical ||
   34e4e:	78d8      	ldrb	r0, [r3, #3]
   34e50:	78ea      	ldrb	r2, [r5, #3]
   34e52:	4290      	cmp	r0, r2
   34e54:	d825      	bhi.n	34ea2 <ticker_worker+0x206>
			id_head = ticker_next->next;
   34e56:	781b      	ldrb	r3, [r3, #0]
		while (id_head != TICKER_NULL) {
   34e58:	2bff      	cmp	r3, #255	; 0xff
   34e5a:	d0a5      	beq.n	34da8 <ticker_worker+0x10c>
			struct ticker_node *ticker_next = &nodes[id_head];
   34e5c:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   34e60:	eb0b 1303 	add.w	r3, fp, r3, lsl #4
			acc_ticks_to_expire += ticker_next->ticks_to_expire;
   34e64:	689f      	ldr	r7, [r3, #8]
   34e66:	4439      	add	r1, r7
			if (acc_ticks_to_expire > ticker->ticks_slot) {
   34e68:	458c      	cmp	ip, r1
   34e6a:	d39d      	bcc.n	34da8 <ticker_worker+0x10c>
			if (ticker_next->ticks_slot == 0U) {
   34e6c:	699a      	ldr	r2, [r3, #24]
   34e6e:	2a00      	cmp	r2, #0
   34e70:	d0f1      	beq.n	34e56 <ticker_worker+0x1ba>
			uint16_t lazy_next = ticker_next->lazy_current;
   34e72:	8bda      	ldrh	r2, [r3, #30]
				ticker_next->lazy_periodic > lazy_next;
   34e74:	8b98      	ldrh	r0, [r3, #28]
			uint32_t next_age = (ticker_next->ticks_periodic == 0U ?
   34e76:	685c      	ldr	r4, [r3, #4]
			if (!lazy_next_periodic_skip) {
   34e78:	4282      	cmp	r2, r0
   34e7a:	d2e6      	bcs.n	34e4a <ticker_worker+0x1ae>
					  0U :
   34e7c:	2c00      	cmp	r4, #0
   34e7e:	d0ea      	beq.n	34e56 <ticker_worker+0x1ba>
				(ticker->ticks_periodic != 0U) &&
   34e80:	2e00      	cmp	r6, #0
   34e82:	d0e8      	beq.n	34e56 <ticker_worker+0x1ba>
   34e84:	4690      	mov	r8, r2
			if (curr_has_ticks_slot_window ||
   34e86:	4282      	cmp	r2, r0
   34e88:	d3e5      	bcc.n	34e56 <ticker_worker+0x1ba>
				(ticker->force == ticker_next->force);
   34e8a:	78e8      	ldrb	r0, [r5, #3]
   34e8c:	78da      	ldrb	r2, [r3, #3]
			     (next_is_critical ||
   34e8e:	4290      	cmp	r0, r2
   34e90:	d307      	bcc.n	34ea2 <ticker_worker+0x206>
			      (equal_priority && equal_force && next_is_older &&
   34e92:	d1e0      	bne.n	34e56 <ticker_worker+0x1ba>
   34e94:	9a07      	ldr	r2, [sp, #28]
			uint32_t next_age = (ticker_next->ticks_periodic == 0U ?
   34e96:	fb08 4804 	mla	r8, r8, r4, r4
   34e9a:	eba8 0807 	sub.w	r8, r8, r7
			      (equal_priority && equal_force && next_is_older &&
   34e9e:	4542      	cmp	r2, r8
   34ea0:	d2d9      	bcs.n	34e56 <ticker_worker+0x1ba>
   34ea2:	9e05      	ldr	r6, [sp, #20]
   34ea4:	4674      	mov	r4, lr
   34ea6:	e736      	b.n	34d16 <ticker_worker+0x7a>
			    TICKER_RESCHEDULE_STATE_NONE &&
   34ea8:	8ba9      	ldrh	r1, [r5, #28]
   34eaa:	8bea      	ldrh	r2, [r5, #30]
   34eac:	4291      	cmp	r1, r2
   34eae:	f63f af3a 	bhi.w	34d26 <ticker_worker+0x8a>
				ext_data->reschedule_state =
   34eb2:	2201      	movs	r2, #1
   34eb4:	721a      	strb	r2, [r3, #8]
   34eb6:	e739      	b.n	34d2c <ticker_worker+0x90>
				(ticker->ticks_periodic != 0U) &&
   34eb8:	b126      	cbz	r6, 34ec4 <ticker_worker+0x228>
				lazy_next -= ticker_next->lazy_periodic;
   34eba:	eba2 0800 	sub.w	r8, r2, r0
   34ebe:	fa1f f888 	uxth.w	r8, r8
   34ec2:	e7e0      	b.n	34e86 <ticker_worker+0x1ea>
			     (next_is_critical ||
   34ec4:	78e8      	ldrb	r0, [r5, #3]
   34ec6:	78da      	ldrb	r2, [r3, #3]
   34ec8:	4290      	cmp	r0, r2
   34eca:	d2c4      	bcs.n	34e56 <ticker_worker+0x1ba>
   34ecc:	e7e9      	b.n	34ea2 <ticker_worker+0x206>
				ticker->ack--;
   34ece:	78aa      	ldrb	r2, [r5, #2]
			ticks_drift = 0U;
   34ed0:	4619      	mov	r1, r3
			must_expire_skip = 1U;
   34ed2:	2701      	movs	r7, #1
   34ed4:	e774      	b.n	34dc0 <ticker_worker+0x124>
   34ed6:	bf00      	nop

00034ed8 <ticker_job>:
	if (instance->worker_trigger) {
   34ed8:	7e83      	ldrb	r3, [r0, #26]
   34eda:	2b00      	cmp	r3, #0
   34edc:	f040 843a 	bne.w	35754 <ticker_job+0x87c>
{
   34ee0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (instance->job_guard) {
   34ee4:	7e42      	ldrb	r2, [r0, #25]
{
   34ee6:	b08f      	sub	sp, #60	; 0x3c
   34ee8:	4682      	mov	sl, r0
	if (instance->job_guard) {
   34eea:	2a00      	cmp	r2, #0
   34eec:	f040 8081 	bne.w	34ff2 <ticker_job+0x11a>
	if (instance->ticks_elapsed_first != instance->ticks_elapsed_last) {
   34ef0:	7a83      	ldrb	r3, [r0, #10]
   34ef2:	7ac1      	ldrb	r1, [r0, #11]
	instance->job_guard = 1U;
   34ef4:	2001      	movs	r0, #1
   34ef6:	f88a 0019 	strb.w	r0, [sl, #25]
	if (instance->ticks_elapsed_first != instance->ticks_elapsed_last) {
   34efa:	4299      	cmp	r1, r3
	ticks_previous = instance->ticks_current;
   34efc:	f8da 0014 	ldr.w	r0, [sl, #20]
   34f00:	9008      	str	r0, [sp, #32]
	if (instance->ticks_elapsed_first != instance->ticks_elapsed_last) {
   34f02:	f000 8452 	beq.w	357aa <ticker_job+0x8d2>
	uint8_t idx = *ticks_elapsed_index + 1;
   34f06:	3301      	adds	r3, #1
   34f08:	b2db      	uxtb	r3, r3
	if (idx == DOUBLE_BUFFER_SIZE) {
   34f0a:	2b02      	cmp	r3, #2
		idx = 0U;
   34f0c:	bf08      	it	eq
   34f0e:	4613      	moveq	r3, r2
		ticks_elapsed =
   34f10:	eb0a 0283 	add.w	r2, sl, r3, lsl #2
	*ticks_elapsed_index = idx;
   34f14:	f88a 300a 	strb.w	r3, [sl, #10]
		ticks_elapsed =
   34f18:	68d2      	ldr	r2, [r2, #12]
		instance->ticks_current += ticks_elapsed;
   34f1a:	9b08      	ldr	r3, [sp, #32]
		ticks_elapsed =
   34f1c:	9204      	str	r2, [sp, #16]
		instance->ticks_current += ticks_elapsed;
   34f1e:	4413      	add	r3, r2
		instance->ticks_current &= HAL_TICKER_CNTR_MASK;
   34f20:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
		flag_elapsed = 1U;
   34f24:	2401      	movs	r4, #1
		instance->ticks_current &= HAL_TICKER_CNTR_MASK;
   34f26:	f8ca 3014 	str.w	r3, [sl, #20]
	ticker_id_old_head = instance->ticker_id_head;
   34f2a:	f89a 3018 	ldrb.w	r3, [sl, #24]
   34f2e:	9309      	str	r3, [sp, #36]	; 0x24
	ticks_now = cntr_cnt_get();
   34f30:	f00c fd70 	bl	41a14 <cntr_cnt_get>
	count_user = instance->count_user;
   34f34:	f89a 6009 	ldrb.w	r6, [sl, #9]
	node = &instance->nodes[0];
   34f38:	f8da 3000 	ldr.w	r3, [sl]
   34f3c:	9301      	str	r3, [sp, #4]
	while (count_user--) {
   34f3e:	1e73      	subs	r3, r6, #1
	users = &instance->users[0];
   34f40:	f8da 5004 	ldr.w	r5, [sl, #4]
	ticks_now = cntr_cnt_get();
   34f44:	9006      	str	r0, [sp, #24]
	while (count_user--) {
   34f46:	b2db      	uxtb	r3, r3
   34f48:	2e00      	cmp	r6, #0
   34f4a:	f000 8454 	beq.w	357f6 <ticker_job+0x91e>
	pending = 0U;
   34f4e:	2600      	movs	r6, #0
   34f50:	eb05 09c3 	add.w	r9, r5, r3, lsl #3
	insert_head = TICKER_NULL;
   34f54:	23ff      	movs	r3, #255	; 0xff
   34f56:	960a      	str	r6, [sp, #40]	; 0x28
   34f58:	9305      	str	r3, [sp, #20]
   34f5a:	940d      	str	r4, [sp, #52]	; 0x34
   34f5c:	462e      	mov	r6, r5
   34f5e:	f8cd a00c 	str.w	sl, [sp, #12]
		user_ops = &user->user_op[0];
   34f62:	f8d9 b004 	ldr.w	fp, [r9, #4]
	user_op->op = TICKER_USER_OP_TYPE_NONE;
   34f66:	f04f 0a00 	mov.w	sl, #0
   34f6a:	4637      	mov	r7, r6
		while (user->middle != user->last) {
   34f6c:	f899 0003 	ldrb.w	r0, [r9, #3]
   34f70:	f899 8002 	ldrb.w	r8, [r9, #2]
			user_op = &user_ops[user->middle];
   34f74:	fa0f f288 	sxth.w	r2, r8
   34f78:	eb02 0142 	add.w	r1, r2, r2, lsl #1
			middle = user->middle + 1;
   34f7c:	f108 0301 	add.w	r3, r8, #1
			user_op = &user_ops[user->middle];
   34f80:	eb02 0481 	add.w	r4, r2, r1, lsl #2
		while (user->middle != user->last) {
   34f84:	4540      	cmp	r0, r8
			middle = user->middle + 1;
   34f86:	b2db      	uxtb	r3, r3
			user_op = &user_ops[user->middle];
   34f88:	eb0b 0584 	add.w	r5, fp, r4, lsl #2
		while (user->middle != user->last) {
   34f8c:	f000 8110 	beq.w	351b0 <ticker_job+0x2d8>
			if (middle == user->count_user_op) {
   34f90:	f899 2000 	ldrb.w	r2, [r9]
				middle = 0U;
   34f94:	429a      	cmp	r2, r3
   34f96:	bf08      	it	eq
   34f98:	2300      	moveq	r3, #0
			user->middle = middle;
   34f9a:	f889 3002 	strb.w	r3, [r9, #2]
			if (user_op->op < TICKER_USER_OP_TYPE_UPDATE) {
   34f9e:	f81b 2024 	ldrb.w	r2, [fp, r4, lsl #2]
			ticker = &node[user_op->id];
   34fa2:	7869      	ldrb	r1, [r5, #1]
			if (user_op->op < TICKER_USER_OP_TYPE_UPDATE) {
   34fa4:	2a04      	cmp	r2, #4
   34fa6:	d939      	bls.n	3501c <ticker_job+0x144>
			ticker = &node[user_op->id];
   34fa8:	9801      	ldr	r0, [sp, #4]
   34faa:	eb01 0341 	add.w	r3, r1, r1, lsl #1
   34fae:	eb00 1603 	add.w	r6, r0, r3, lsl #4
			if ((user_op->op > TICKER_USER_OP_TYPE_STOP_ABS) ||
   34fb2:	2a08      	cmp	r2, #8
			ticker = &node[user_op->id];
   34fb4:	ea4f 1303 	mov.w	r3, r3, lsl #4
   34fb8:	9302      	str	r3, [sp, #8]
			state = (ticker->req - ticker->ack) & 0xff;
   34fba:	78b0      	ldrb	r0, [r6, #2]
   34fbc:	7873      	ldrb	r3, [r6, #1]
			if ((user_op->op > TICKER_USER_OP_TYPE_STOP_ABS) ||
   34fbe:	d822      	bhi.n	35006 <ticker_job+0x12e>
			state = (ticker->req - ticker->ack) & 0xff;
   34fc0:	1a1b      	subs	r3, r3, r0
			if ((user_op->op > TICKER_USER_OP_TYPE_STOP_ABS) ||
   34fc2:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
   34fc6:	d12b      	bne.n	35020 <ticker_job+0x148>
			    ((state == 0U) &&
   34fc8:	2a06      	cmp	r2, #6
   34fca:	d11c      	bne.n	35006 <ticker_job+0x12e>
		if (instance->ticker_id_slot_previous == user_op->id) {
   34fcc:	9b03      	ldr	r3, [sp, #12]
   34fce:	7edb      	ldrb	r3, [r3, #27]
   34fd0:	428b      	cmp	r3, r1
   34fd2:	d050      	beq.n	35076 <ticker_job+0x19e>
	user_op->op = TICKER_USER_OP_TYPE_NONE;
   34fd4:	f80b a024 	strb.w	sl, [fp, r4, lsl #2]
	if (user_op->fp_op_func) {
   34fd8:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
	user_op->status = status;
   34fda:	f8c5 a028 	str.w	sl, [r5, #40]	; 0x28
	if (user_op->fp_op_func) {
   34fde:	2b00      	cmp	r3, #0
   34fe0:	d0c4      	beq.n	34f6c <ticker_job+0x94>
		user_op->fp_op_func(user_op->status, user_op->op_context);
   34fe2:	2000      	movs	r0, #0
   34fe4:	6b29      	ldr	r1, [r5, #48]	; 0x30
   34fe6:	4798      	blx	r3
		while (user->middle != user->last) {
   34fe8:	f899 0003 	ldrb.w	r0, [r9, #3]
   34fec:	f899 8002 	ldrb.w	r8, [r9, #2]
   34ff0:	e7c0      	b.n	34f74 <ticker_job+0x9c>
		instance->sched_cb(TICKER_CALL_ID_JOB, TICKER_CALL_ID_JOB, 1,
   34ff2:	6a44      	ldr	r4, [r0, #36]	; 0x24
   34ff4:	2104      	movs	r1, #4
   34ff6:	4603      	mov	r3, r0
   34ff8:	2201      	movs	r2, #1
		instance->sched_cb(TICKER_CALL_ID_JOB, TICKER_CALL_ID_WORKER, 1,
   34ffa:	2004      	movs	r0, #4
   34ffc:	46a4      	mov	ip, r4
}
   34ffe:	b00f      	add	sp, #60	; 0x3c
   35000:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		instance->sched_cb(TICKER_CALL_ID_JOB, TICKER_CALL_ID_WORKER, 1,
   35004:	4760      	bx	ip
	user_op->op = TICKER_USER_OP_TYPE_NONE;
   35006:	f80b a024 	strb.w	sl, [fp, r4, lsl #2]
	user_op->status = status;
   3500a:	2301      	movs	r3, #1
   3500c:	62ab      	str	r3, [r5, #40]	; 0x28
	if (user_op->fp_op_func) {
   3500e:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
   35010:	2b00      	cmp	r3, #0
   35012:	d0ab      	beq.n	34f6c <ticker_job+0x94>
		user_op->fp_op_func(user_op->status, user_op->op_context);
   35014:	6b29      	ldr	r1, [r5, #48]	; 0x30
   35016:	2001      	movs	r0, #1
   35018:	4798      	blx	r3
   3501a:	e7a7      	b.n	34f6c <ticker_job+0x94>
   3501c:	4698      	mov	r8, r3
   3501e:	e7a9      	b.n	34f74 <ticker_job+0x9c>
			     (user_op->op != TICKER_USER_OP_TYPE_YIELD_ABS)) ||
   35020:	2a05      	cmp	r2, #5
   35022:	d11f      	bne.n	35064 <ticker_job+0x18c>
			    ((user_op->op == TICKER_USER_OP_TYPE_UPDATE) &&
   35024:	686a      	ldr	r2, [r5, #4]
   35026:	b94a      	cbnz	r2, 3503c <ticker_job+0x164>
			     (user_op->params.update.ticks_drift_plus == 0U) &&
   35028:	68aa      	ldr	r2, [r5, #8]
   3502a:	b93a      	cbnz	r2, 3503c <ticker_job+0x164>
			     (user_op->params.update.ticks_drift_minus == 0U) &&
   3502c:	68ea      	ldr	r2, [r5, #12]
   3502e:	b92a      	cbnz	r2, 3503c <ticker_job+0x164>
			     (user_op->params.update.ticks_slot_plus == 0U) &&
   35030:	692a      	ldr	r2, [r5, #16]
   35032:	b91a      	cbnz	r2, 3503c <ticker_job+0x164>
			     (user_op->params.update.lazy == 0U) &&
   35034:	696a      	ldr	r2, [r5, #20]
   35036:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
   3503a:	d0e4      	beq.n	35006 <ticker_job+0x12e>
			if ((state == 1U) ||
   3503c:	2b01      	cmp	r3, #1
   3503e:	d01c      	beq.n	3507a <ticker_job+0x1a2>
				instance->sched_cb(TICKER_CALL_ID_JOB,
   35040:	9b03      	ldr	r3, [sp, #12]
   35042:	2104      	movs	r1, #4
   35044:	6a5c      	ldr	r4, [r3, #36]	; 0x24
   35046:	463e      	mov	r6, r7
   35048:	2201      	movs	r2, #1
   3504a:	4608      	mov	r0, r1
   3504c:	47a0      	blx	r4
				pending = 1U;
   3504e:	2301      	movs	r3, #1
	while (count_user--) {
   35050:	45b1      	cmp	r9, r6
				pending = 1U;
   35052:	930a      	str	r3, [sp, #40]	; 0x28
				user->middle = prev;
   35054:	f889 8002 	strb.w	r8, [r9, #2]
	while (count_user--) {
   35058:	f1a9 0308 	sub.w	r3, r9, #8
   3505c:	f000 80ae 	beq.w	351bc <ticker_job+0x2e4>
   35060:	4699      	mov	r9, r3
   35062:	e77e      	b.n	34f62 <ticker_job+0x8a>
			if ((state == 1U) ||
   35064:	2b01      	cmp	r3, #1
   35066:	f000 818d 	beq.w	35384 <ticker_job+0x4ac>
   3506a:	2a06      	cmp	r2, #6
   3506c:	d1e8      	bne.n	35040 <ticker_job+0x168>
		if (instance->ticker_id_slot_previous == user_op->id) {
   3506e:	9b03      	ldr	r3, [sp, #12]
   35070:	7edb      	ldrb	r3, [r3, #27]
   35072:	428b      	cmp	r3, r1
   35074:	d1ae      	bne.n	34fd4 <ticker_job+0xfc>
				ticks_at_yield =
   35076:	6869      	ldr	r1, [r5, #4]
   35078:	e1a6      	b.n	353c8 <ticker_job+0x4f0>
		ticker->ticks_to_expire = ticker_dequeue(instance, user_op->id);
   3507a:	f8dd 800c 	ldr.w	r8, [sp, #12]
   3507e:	4640      	mov	r0, r8
   35080:	f7ff fcb6 	bl	349f0 <ticker_dequeue>
   35084:	60b0      	str	r0, [r6, #8]
		ticker_job_node_update(ticker, user_op, ticks_now,
   35086:	f8d8 c014 	ldr.w	ip, [r8, #20]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   3508a:	9b06      	ldr	r3, [sp, #24]
	ticks_elapsed += ticker_ticks_diff_get(ticks_now, ticks_current);
   3508c:	9a04      	ldr	r2, [sp, #16]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   3508e:	eba3 030c 	sub.w	r3, r3, ip
   35092:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
	ticks_elapsed += ticker_ticks_diff_get(ticks_now, ticks_current);
   35096:	4413      	add	r3, r2
	if (ticks_to_expire > ticks_elapsed) {
   35098:	4298      	cmp	r0, r3
   3509a:	f240 81ad 	bls.w	353f8 <ticker_job+0x520>
		ticks_to_expire -= ticks_elapsed;
   3509e:	1ac0      	subs	r0, r0, r3
	if ((ticker->ticks_periodic != 0U) &&
   350a0:	6873      	ldr	r3, [r6, #4]
   350a2:	2b00      	cmp	r3, #0
   350a4:	d050      	beq.n	35148 <ticker_job+0x270>
	    (user_op->params.update.lazy != 0U)) {
   350a6:	8aab      	ldrh	r3, [r5, #20]
	if ((ticker->ticks_periodic != 0U) &&
   350a8:	2b00      	cmp	r3, #0
   350aa:	d04d      	beq.n	35148 <ticker_job+0x270>
		user_op->params.update.lazy--;
   350ac:	3b01      	subs	r3, #1
   350ae:	b29a      	uxth	r2, r3
   350b0:	82aa      	strh	r2, [r5, #20]
		while ((ticks_to_expire > ticker->ticks_periodic) &&
   350b2:	6871      	ldr	r1, [r6, #4]
		while (ticker->lazy_current < user_op->params.update.lazy) {
   350b4:	8bf3      	ldrh	r3, [r6, #30]
		while ((ticks_to_expire > ticker->ticks_periodic) &&
   350b6:	4288      	cmp	r0, r1
   350b8:	d923      	bls.n	35102 <ticker_job+0x22a>
			ticks_to_expire += ticker->ticks_periodic +
   350ba:	f101 0801 	add.w	r8, r1, #1
   350be:	9707      	str	r7, [sp, #28]
   350c0:	940b      	str	r4, [sp, #44]	; 0x2c
   350c2:	e01a      	b.n	350fa <ticker_job+0x222>
	if ((ticker->remainder_current >= BIT(31)) ||
   350c4:	6a72      	ldr	r2, [r6, #36]	; 0x24
   350c6:	f8df e0e0 	ldr.w	lr, [pc, #224]	; 351a8 <ticker_job+0x2d0>
   350ca:	4c38      	ldr	r4, [pc, #224]	; (351ac <ticker_job+0x2d4>)
   350cc:	4496      	add	lr, r2
   350ce:	45a6      	cmp	lr, r4
		ticker->remainder_current += HAL_TICKER_REMAINDER_RANGE;
   350d0:	bf84      	itt	hi
   350d2:	f102 72e8 	addhi.w	r2, r2, #30408704	; 0x1d00000
   350d6:	f502 32d4 	addhi.w	r2, r2, #108544	; 0x1a800
			ticks_to_expire += ticker->ticks_periodic +
   350da:	4647      	mov	r7, r8
	ticker->remainder_current -= ticker->remainder_periodic;
   350dc:	6a34      	ldr	r4, [r6, #32]
   350de:	bf94      	ite	ls
   350e0:	460f      	movls	r7, r1
		ticker->remainder_current += HAL_TICKER_REMAINDER_RANGE;
   350e2:	f502 72a5 	addhi.w	r2, r2, #330	; 0x14a
			ticker->lazy_current--;
   350e6:	3b01      	subs	r3, #1
			ticks_to_expire -= ticker->ticks_periodic +
   350e8:	1bc0      	subs	r0, r0, r7
	ticker->remainder_current -= ticker->remainder_periodic;
   350ea:	1b12      	subs	r2, r2, r4
			ticker->lazy_current--;
   350ec:	b29b      	uxth	r3, r3
		while ((ticks_to_expire > ticker->ticks_periodic) &&
   350ee:	4288      	cmp	r0, r1
	ticker->remainder_current -= ticker->remainder_periodic;
   350f0:	6272      	str	r2, [r6, #36]	; 0x24
			ticker->lazy_current--;
   350f2:	83f3      	strh	r3, [r6, #30]
		while ((ticks_to_expire > ticker->ticks_periodic) &&
   350f4:	f240 81d9 	bls.w	354aa <ticker_job+0x5d2>
		while (ticker->lazy_current < user_op->params.update.lazy) {
   350f8:	8aaa      	ldrh	r2, [r5, #20]
		while ((ticks_to_expire > ticker->ticks_periodic) &&
   350fa:	4293      	cmp	r3, r2
   350fc:	d8e2      	bhi.n	350c4 <ticker_job+0x1ec>
   350fe:	9f07      	ldr	r7, [sp, #28]
   35100:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
		while (ticker->lazy_current < user_op->params.update.lazy) {
   35102:	429a      	cmp	r2, r3
   35104:	d91f      	bls.n	35146 <ticker_job+0x26e>
			ticks_to_expire += ticker->ticks_periodic +
   35106:	e9cd 740b 	strd	r7, r4, [sp, #44]	; 0x2c
   3510a:	1c4a      	adds	r2, r1, #1
	ticker->remainder_current += ticker->remainder_periodic;
   3510c:	f8d6 e020 	ldr.w	lr, [r6, #32]
			ticks_to_expire += ticker->ticks_periodic +
   35110:	9207      	str	r2, [sp, #28]
	ticker->remainder_current += ticker->remainder_periodic;
   35112:	6a72      	ldr	r2, [r6, #36]	; 0x24
	if ((ticker->remainder_current < BIT(31)) &&
   35114:	f8df 8090 	ldr.w	r8, [pc, #144]	; 351a8 <ticker_job+0x2d0>
   35118:	4c24      	ldr	r4, [pc, #144]	; (351ac <ticker_job+0x2d4>)
	ticker->remainder_current += ticker->remainder_periodic;
   3511a:	4472      	add	r2, lr
	if ((ticker->remainder_current < BIT(31)) &&
   3511c:	4490      	add	r8, r2
   3511e:	45a0      	cmp	r8, r4
   35120:	460f      	mov	r7, r1
   35122:	d806      	bhi.n	35132 <ticker_job+0x25a>
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
   35124:	f1a2 72e8 	sub.w	r2, r2, #30408704	; 0x1d00000
   35128:	f5a2 32d4 	sub.w	r2, r2, #108544	; 0x1a800
			ticks_to_expire += ticker->ticks_periodic +
   3512c:	9f07      	ldr	r7, [sp, #28]
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
   3512e:	f5a2 72a5 	sub.w	r2, r2, #330	; 0x14a
			ticker->lazy_current++;
   35132:	3301      	adds	r3, #1
   35134:	b29b      	uxth	r3, r3
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
   35136:	6272      	str	r2, [r6, #36]	; 0x24
			ticker->lazy_current++;
   35138:	83f3      	strh	r3, [r6, #30]
		while (ticker->lazy_current < user_op->params.update.lazy) {
   3513a:	8aaa      	ldrh	r2, [r5, #20]
   3513c:	429a      	cmp	r2, r3
			ticks_to_expire += ticker->ticks_periodic +
   3513e:	4438      	add	r0, r7
		while (ticker->lazy_current < user_op->params.update.lazy) {
   35140:	d8e7      	bhi.n	35112 <ticker_job+0x23a>
   35142:	e9dd 740b 	ldrd	r7, r4, [sp, #44]	; 0x2c
		ticker->lazy_periodic = user_op->params.update.lazy;
   35146:	83b2      	strh	r2, [r6, #28]
	ticker->ticks_to_expire = ticks_to_expire +
   35148:	686b      	ldr	r3, [r5, #4]
	struct ticker_ext *ext_data = ticker->ext_data;
   3514a:	6ab1      	ldr	r1, [r6, #40]	; 0x28
	ticker->ticks_to_expire = ticks_to_expire +
   3514c:	4403      	add	r3, r0
   3514e:	60b3      	str	r3, [r6, #8]
	ticker->ticks_to_expire_minus +=
   35150:	68aa      	ldr	r2, [r5, #8]
   35152:	6973      	ldr	r3, [r6, #20]
   35154:	4413      	add	r3, r2
   35156:	6173      	str	r3, [r6, #20]
	if (ext_data && ext_data->ticks_slot_window != 0U) {
   35158:	b129      	cbz	r1, 35166 <ticker_job+0x28e>
   3515a:	680b      	ldr	r3, [r1, #0]
   3515c:	b11b      	cbz	r3, 35166 <ticker_job+0x28e>
			user_op->params.update.ticks_drift_plus -
   3515e:	e9d5 3201 	ldrd	r3, r2, [r5, #4]
   35162:	1a9b      	subs	r3, r3, r2
		ext_data->ticks_drift =
   35164:	604b      	str	r3, [r1, #4]
	ticks_to_expire_prep(ticker, ticks_current, ticks_now);
   35166:	9a06      	ldr	r2, [sp, #24]
   35168:	4661      	mov	r1, ip
   3516a:	4630      	mov	r0, r6
   3516c:	f7ff fc7a 	bl	34a64 <ticks_to_expire_prep>
	ticker->ticks_slot += user_op->params.update.ticks_slot_plus;
   35170:	68ea      	ldr	r2, [r5, #12]
   35172:	69b3      	ldr	r3, [r6, #24]
   35174:	4413      	add	r3, r2
   35176:	61b3      	str	r3, [r6, #24]
	if (ticker->ticks_slot > user_op->params.update.ticks_slot_minus) {
   35178:	692a      	ldr	r2, [r5, #16]
   3517a:	4293      	cmp	r3, r2
		ticker->ticks_slot -= user_op->params.update.ticks_slot_minus;
   3517c:	bf8c      	ite	hi
   3517e:	1a9b      	subhi	r3, r3, r2
		ticker->ticks_slot = 0U;
   35180:	2300      	movls	r3, #0
   35182:	61b3      	str	r3, [r6, #24]
	if (user_op->params.update.force != 0U) {
   35184:	7dab      	ldrb	r3, [r5, #22]
   35186:	b103      	cbz	r3, 3518a <ticker_job+0x2b2>
		ticker->force = user_op->params.update.force;
   35188:	70f3      	strb	r3, [r6, #3]
	if (user_op->params.update.must_expire) {
   3518a:	7deb      	ldrb	r3, [r5, #23]
   3518c:	b113      	cbz	r3, 35194 <ticker_job+0x2bc>
		ticker->must_expire = (user_op->params.update.must_expire - 1);
   3518e:	3b01      	subs	r3, #1
   35190:	f886 302c 	strb.w	r3, [r6, #44]	; 0x2c
	ticker->next = *insert_head;
   35194:	e9dd 2101 	ldrd	r2, r1, [sp, #4]
   35198:	9b05      	ldr	r3, [sp, #20]
   3519a:	5453      	strb	r3, [r2, r1]
		ticker->req++;
   3519c:	7873      	ldrb	r3, [r6, #1]
	*insert_head = user_op->id;
   3519e:	786a      	ldrb	r2, [r5, #1]
   351a0:	9205      	str	r2, [sp, #20]
		ticker->req++;
   351a2:	3301      	adds	r3, #1
   351a4:	7073      	strb	r3, [r6, #1]
   351a6:	e715      	b.n	34fd4 <ticker_job+0xfc>
   351a8:	ff172b5a 	.word	0xff172b5a
   351ac:	7f172b59 	.word	0x7f172b59
   351b0:	463e      	mov	r6, r7
	while (count_user--) {
   351b2:	45b1      	cmp	r9, r6
   351b4:	f1a9 0308 	sub.w	r3, r9, #8
   351b8:	f47f af52 	bne.w	35060 <ticker_job+0x188>
   351bc:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   351be:	9e0a      	ldr	r6, [sp, #40]	; 0x28
   351c0:	f8dd a00c 	ldr.w	sl, [sp, #12]
	if (instance->ticker_id_head != ticker_id_old_head) {
   351c4:	f89a b018 	ldrb.w	fp, [sl, #24]
   351c8:	9b09      	ldr	r3, [sp, #36]	; 0x24
   351ca:	ebbb 0303 	subs.w	r3, fp, r3
   351ce:	bf18      	it	ne
   351d0:	2301      	movne	r3, #1
   351d2:	9307      	str	r3, [sp, #28]
	if (flag_elapsed) {
   351d4:	2c00      	cmp	r4, #0
   351d6:	f000 822c 	beq.w	35632 <ticker_job+0x75a>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   351da:	9b06      	ldr	r3, [sp, #24]
   351dc:	9a08      	ldr	r2, [sp, #32]
   351de:	1a9b      	subs	r3, r3, r2
   351e0:	f023 477f 	bic.w	r7, r3, #4278190080	; 0xff000000
	while (instance->ticker_id_head != TICKER_NULL) {
   351e4:	f1bb 0fff 	cmp.w	fp, #255	; 0xff
	node = &instance->nodes[0];
   351e8:	f8da 3000 	ldr.w	r3, [sl]
   351ec:	9301      	str	r3, [sp, #4]
	while (instance->ticker_id_head != TICKER_NULL) {
   351ee:	d050      	beq.n	35292 <ticker_job+0x3ba>
   351f0:	f8dd 8010 	ldr.w	r8, [sp, #16]
			instance->ticks_slot_previous = 0U;
   351f4:	9406      	str	r4, [sp, #24]
	ticks_expired = 0U;
   351f6:	f04f 0900 	mov.w	r9, #0
			instance->ticks_slot_previous = 0U;
   351fa:	4645      	mov	r5, r8
   351fc:	960a      	str	r6, [sp, #40]	; 0x28
   351fe:	46c8      	mov	r8, r9
		ticker = &node[id_expired];
   35200:	9a01      	ldr	r2, [sp, #4]
   35202:	eb0b 034b 	add.w	r3, fp, fp, lsl #1
   35206:	eb02 1403 	add.w	r4, r2, r3, lsl #4
   3520a:	ea4f 1903 	mov.w	r9, r3, lsl #4
		ticks_to_expire = ticker->ticks_to_expire;
   3520e:	68a3      	ldr	r3, [r4, #8]
		if (ticks_elapsed < ticks_to_expire) {
   35210:	42ab      	cmp	r3, r5
   35212:	f200 82ce 	bhi.w	357b2 <ticker_job+0x8da>
		state = (ticker->req - ticker->ack) & 0xff;
   35216:	78a1      	ldrb	r1, [r4, #2]
   35218:	7862      	ldrb	r2, [r4, #1]
		skip_collision = (ticker->lazy_current != 0U);
   3521a:	8be0      	ldrh	r0, [r4, #30]
		state = (ticker->req - ticker->ack) & 0xff;
   3521c:	1a52      	subs	r2, r2, r1
		if (instance->ticks_slot_previous > ticks_to_expire) {
   3521e:	f8da 101c 	ldr.w	r1, [sl, #28]
   35222:	428b      	cmp	r3, r1
		ticks_elapsed -= ticks_to_expire;
   35224:	eba5 0503 	sub.w	r5, r5, r3
		ticks_expired += ticks_to_expire;
   35228:	4498      	add	r8, r3
		ticks_latency -= ticks_to_expire;
   3522a:	eba7 0703 	sub.w	r7, r7, r3
			instance->ticks_slot_previous -= ticks_to_expire;
   3522e:	bf31      	iteee	cc
   35230:	1ac9      	subcc	r1, r1, r3
			instance->ticker_id_slot_previous = TICKER_NULL;
   35232:	f04f 33ff 	movcs.w	r3, #4294967295	; 0xffffffff
			instance->ticks_slot_previous = 0U;
   35236:	2100      	movcs	r1, #0
			instance->ticker_id_slot_previous = TICKER_NULL;
   35238:	f88a 301b 	strbcs.w	r3, [sl, #27]
   3523c:	f8ca 101c 	str.w	r1, [sl, #28]
		if (ticker->ticks_slot && (state == 2U) && !skip_collision &&
   35240:	69a3      	ldr	r3, [r4, #24]
		state = (ticker->req - ticker->ack) & 0xff;
   35242:	b2d2      	uxtb	r2, r2
		if (ticker->ticks_slot && (state == 2U) && !skip_collision &&
   35244:	b113      	cbz	r3, 3524c <ticker_job+0x374>
   35246:	2a02      	cmp	r2, #2
   35248:	f000 8133 	beq.w	354b2 <ticker_job+0x5da>
		ticker->ticks_to_expire = 0U;
   3524c:	2300      	movs	r3, #0
   3524e:	60a3      	str	r3, [r4, #8]
		instance->ticker_id_head = ticker->next;
   35250:	9b01      	ldr	r3, [sp, #4]
   35252:	f813 3009 	ldrb.w	r3, [r3, r9]
   35256:	f88a 3018 	strb.w	r3, [sl, #24]
		if ((ticker->ticks_periodic != 0U) ||
   3525a:	6861      	ldr	r1, [r4, #4]
			if (TICKER_RESCHEDULE_PENDING(ticker)) {
   3525c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
		if ((ticker->ticks_periodic != 0U) ||
   3525e:	2900      	cmp	r1, #0
   35260:	f040 80ec 	bne.w	3543c <ticker_job+0x564>
   35264:	b11b      	cbz	r3, 3526e <ticker_job+0x396>
		    TICKER_RESCHEDULE_PENDING(ticker)) {
   35266:	7a1b      	ldrb	r3, [r3, #8]
   35268:	2b01      	cmp	r3, #1
   3526a:	f000 80cb 	beq.w	35404 <ticker_job+0x52c>
			if (state && ((state == 1U) || skip_collision) &&
   3526e:	b13a      	cbz	r2, 35280 <ticker_job+0x3a8>
   35270:	2a01      	cmp	r2, #1
   35272:	d000      	beq.n	35276 <ticker_job+0x39e>
   35274:	b120      	cbz	r0, 35280 <ticker_job+0x3a8>
			    ticker->fp_op_func) {
   35276:	6a23      	ldr	r3, [r4, #32]
			if (state && ((state == 1U) || skip_collision) &&
   35278:	b113      	cbz	r3, 35280 <ticker_job+0x3a8>
				ticker->fp_op_func(TICKER_STATUS_FAILURE,
   3527a:	6a61      	ldr	r1, [r4, #36]	; 0x24
   3527c:	2001      	movs	r0, #1
   3527e:	4798      	blx	r3
			ticker->req = ticker->ack;
   35280:	78a3      	ldrb	r3, [r4, #2]
   35282:	7063      	strb	r3, [r4, #1]
	while (instance->ticker_id_head != TICKER_NULL) {
   35284:	f89a b018 	ldrb.w	fp, [sl, #24]
   35288:	f1bb 0fff 	cmp.w	fp, #255	; 0xff
   3528c:	d1b8      	bne.n	35200 <ticker_job+0x328>
   3528e:	9c06      	ldr	r4, [sp, #24]
   35290:	9e0a      	ldr	r6, [sp, #40]	; 0x28
			flag_compare_update = 1U;
   35292:	9b07      	ldr	r3, [sp, #28]
   35294:	9a09      	ldr	r2, [sp, #36]	; 0x24
		ticker_job_list_insert(instance, insert_head);
   35296:	9905      	ldr	r1, [sp, #20]
			flag_compare_update = 1U;
   35298:	4593      	cmp	fp, r2
   3529a:	bf18      	it	ne
   3529c:	4623      	movne	r3, r4
		ticker_job_list_insert(instance, insert_head);
   3529e:	4650      	mov	r0, sl
			flag_compare_update = 1U;
   352a0:	9307      	str	r3, [sp, #28]
		ticker_job_list_insert(instance, insert_head);
   352a2:	f7ff fc03 	bl	34aac <ticker_job_list_insert>
		ticker_id_head = instance->ticker_id_head;
   352a6:	f89a 3018 	ldrb.w	r3, [sl, #24]
	nodes = &instance->nodes[0];
   352aa:	f8da b000 	ldr.w	fp, [sl]
	while (rescheduling) {
   352ae:	9603      	str	r6, [sp, #12]
		while (ticker_id_head != TICKER_NULL) {
   352b0:	2bff      	cmp	r3, #255	; 0xff
	uint8_t  rescheduled = 0U;
   352b2:	f04f 0500 	mov.w	r5, #0
		ticker_id_head = instance->ticker_id_head;
   352b6:	461a      	mov	r2, r3
		while (ticker_id_head != TICKER_NULL) {
   352b8:	f000 81aa 	beq.w	35610 <ticker_job+0x738>
		ticker_id_head = instance->ticker_id_head;
   352bc:	461c      	mov	r4, r3
			ticker = &nodes[ticker_id_head];
   352be:	b221      	sxth	r1, r4
   352c0:	eb01 0141 	add.w	r1, r1, r1, lsl #1
   352c4:	eb0b 1001 	add.w	r0, fp, r1, lsl #4
   352c8:	0109      	lsls	r1, r1, #4
			ext_data = ticker->ext_data;
   352ca:	6a87      	ldr	r7, [r0, #40]	; 0x28
			if (ext_data && ext_data->reschedule_state ==
   352cc:	b11f      	cbz	r7, 352d6 <ticker_job+0x3fe>
   352ce:	7a3e      	ldrb	r6, [r7, #8]
   352d0:	2e01      	cmp	r6, #1
   352d2:	f000 8102 	beq.w	354da <ticker_job+0x602>
			ticker_id_head = ticker->next;
   352d6:	f81b 4001 	ldrb.w	r4, [fp, r1]
		while (ticker_id_head != TICKER_NULL) {
   352da:	2cff      	cmp	r4, #255	; 0xff
   352dc:	d1ef      	bne.n	352be <ticker_job+0x3e6>
	return rescheduled;
   352de:	9e03      	ldr	r6, [sp, #12]
		if (ticker_job_reschedule_in_window(instance, ticks_elapsed)) {
   352e0:	2d00      	cmp	r5, #0
   352e2:	f000 81ac 	beq.w	3563e <ticker_job+0x766>
	if (instance->ticker_id_head != ticker_id_old_head) {
   352e6:	9909      	ldr	r1, [sp, #36]	; 0x24
   352e8:	4299      	cmp	r1, r3
   352ea:	f000 826a 	beq.w	357c2 <ticker_job+0x8ea>
	if (!pending) {
   352ee:	2e00      	cmp	r6, #0
   352f0:	f000 81bd 	beq.w	3566e <ticker_job+0x796>
	if (instance->ticker_id_head == TICKER_NULL) {
   352f4:	461a      	mov	r2, r3
   352f6:	2aff      	cmp	r2, #255	; 0xff
   352f8:	f000 8191 	beq.w	3561e <ticker_job+0x746>
	if (ticker_id_old_head == TICKER_NULL) {
   352fc:	9b09      	ldr	r3, [sp, #36]	; 0x24
   352fe:	2bff      	cmp	r3, #255	; 0xff
   35300:	f000 8286 	beq.w	35810 <ticker_job+0x938>
	ticks_to_expire = ticker->ticks_to_expire;
   35304:	f8da 3000 	ldr.w	r3, [sl]
		LL_ASSERT(i);
   35308:	f8df 92c8 	ldr.w	r9, [pc, #712]	; 355d4 <ticker_job+0x6fc>
   3530c:	f8df 82c8 	ldr.w	r8, [pc, #712]	; 355d8 <ticker_job+0x700>
   35310:	4fb2      	ldr	r7, [pc, #712]	; (355dc <ticker_job+0x704>)
	ticker = &instance->nodes[instance->ticker_id_head];
   35312:	eb02 0242 	add.w	r2, r2, r2, lsl #1
	ticks_to_expire = ticker->ticks_to_expire;
   35316:	eb03 1302 	add.w	r3, r3, r2, lsl #4
	i = 10U;
   3531a:	250a      	movs	r5, #10
	ticks_to_expire = ticker->ticks_to_expire;
   3531c:	689e      	ldr	r6, [r3, #8]
		ctr = cntr_cnt_get();
   3531e:	f00c fb79 	bl	41a14 <cntr_cnt_get>
		cc = instance->ticks_current;
   35322:	f8da 4014 	ldr.w	r4, [sl, #20]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   35326:	1b03      	subs	r3, r0, r4
   35328:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
		ticks_elapsed = ticker_ticks_diff_get(ctr, cc) +
   3532c:	3303      	adds	r3, #3
		cc += MAX(ticks_elapsed, ticks_to_expire);
   3532e:	42b3      	cmp	r3, r6
   35330:	bf2c      	ite	cs
   35332:	18e4      	addcs	r4, r4, r3
   35334:	19a4      	addcc	r4, r4, r6
		cc &= HAL_TICKER_CNTR_MASK;
   35336:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
		instance->trigger_set_cb(cc);
   3533a:	f8da 3028 	ldr.w	r3, [sl, #40]	; 0x28
		ctr = cntr_cnt_get();
   3533e:	4683      	mov	fp, r0
		instance->trigger_set_cb(cc);
   35340:	4620      	mov	r0, r4
   35342:	4798      	blx	r3
		ctr_post = cntr_cnt_get();
   35344:	f00c fb66 	bl	41a14 <cntr_cnt_get>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   35348:	eba0 030b 	sub.w	r3, r0, fp
   3534c:	eba4 040b 	sub.w	r4, r4, fp
   35350:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
	} while ((ticker_ticks_diff_get(ctr_post, ctr) +
   35354:	3303      	adds	r3, #3
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   35356:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
		  HAL_TICKER_CNTR_CMP_OFFSET_MIN) >
   3535a:	42a3      	cmp	r3, r4
		i--;
   3535c:	f105 35ff 	add.w	r5, r5, #4294967295	; 0xffffffff
		  HAL_TICKER_CNTR_CMP_OFFSET_MIN) >
   35360:	f240 8178 	bls.w	35654 <ticker_job+0x77c>
		LL_ASSERT(i);
   35364:	2d00      	cmp	r5, #0
   35366:	d1da      	bne.n	3531e <ticker_job+0x446>
   35368:	f640 13a8 	movw	r3, #2472	; 0x9a8
   3536c:	464a      	mov	r2, r9
   3536e:	4641      	mov	r1, r8
   35370:	4638      	mov	r0, r7
   35372:	f013 fe87 	bl	49084 <assert_print>
   35376:	4040      	eors	r0, r0
   35378:	f380 8811 	msr	BASEPRI, r0
   3537c:	f04f 0003 	mov.w	r0, #3
   35380:	df02      	svc	2
   35382:	e7cc      	b.n	3531e <ticker_job+0x446>
		if (user_op->op != TICKER_USER_OP_TYPE_YIELD_ABS) {
   35384:	2a06      	cmp	r2, #6
   35386:	f43f ae21 	beq.w	34fcc <ticker_job+0xf4>
			ticker->ticks_to_expire = ticker_dequeue(instance,
   3538a:	f8dd 800c 	ldr.w	r8, [sp, #12]
   3538e:	4640      	mov	r0, r8
   35390:	f7ff fb2e 	bl	349f0 <ticker_dequeue>
			ticker->req = ticker->ack;
   35394:	78b3      	ldrb	r3, [r6, #2]
			ticker->ticks_to_expire = ticker_dequeue(instance,
   35396:	60b0      	str	r0, [r6, #8]
			ticker->req = ticker->ack;
   35398:	7073      	strb	r3, [r6, #1]
		if (instance->ticker_id_slot_previous == user_op->id) {
   3539a:	f898 201b 	ldrb.w	r2, [r8, #27]
   3539e:	786b      	ldrb	r3, [r5, #1]
   353a0:	429a      	cmp	r2, r3
   353a2:	f47f ae17 	bne.w	34fd4 <ticker_job+0xfc>
			if (user_op->op != TICKER_USER_OP_TYPE_YIELD_ABS) {
   353a6:	f81b 3024 	ldrb.w	r3, [fp, r4, lsl #2]
   353aa:	2b06      	cmp	r3, #6
   353ac:	f43f ae63 	beq.w	35076 <ticker_job+0x19e>
				instance->ticker_id_slot_previous = TICKER_NULL;
   353b0:	9a03      	ldr	r2, [sp, #12]
   353b2:	23ff      	movs	r3, #255	; 0xff
   353b4:	76d3      	strb	r3, [r2, #27]
			if ((user_op->op == TICKER_USER_OP_TYPE_YIELD_ABS) ||
   353b6:	f81b 3024 	ldrb.w	r3, [fp, r4, lsl #2]
   353ba:	2b06      	cmp	r3, #6
   353bc:	f43f ae5b 	beq.w	35076 <ticker_job+0x19e>
   353c0:	2b08      	cmp	r3, #8
   353c2:	f43f ae58 	beq.w	35076 <ticker_job+0x19e>
				ticks_at_yield = ticks_now;
   353c6:	9906      	ldr	r1, [sp, #24]
			ticks_current = instance->ticks_current;
   353c8:	9b03      	ldr	r3, [sp, #12]
   353ca:	695a      	ldr	r2, [r3, #20]
			if (!((ticks_at_yield - ticks_current) &
   353cc:	1a8b      	subs	r3, r1, r2
   353ce:	021e      	lsls	r6, r3, #8
   353d0:	d409      	bmi.n	353e6 <ticker_job+0x50e>
				ticks_used = ticks_elapsed +
   353d2:	9a04      	ldr	r2, [sp, #16]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   353d4:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
				ticks_used = ticks_elapsed +
   353d8:	4413      	add	r3, r2
			if (instance->ticks_slot_previous > ticks_used) {
   353da:	9903      	ldr	r1, [sp, #12]
   353dc:	69ca      	ldr	r2, [r1, #28]
   353de:	429a      	cmp	r2, r3
				instance->ticks_slot_previous = ticks_used;
   353e0:	bf88      	it	hi
   353e2:	61cb      	strhi	r3, [r1, #28]
   353e4:	e5f6      	b.n	34fd4 <ticker_job+0xfc>
				if (ticks_elapsed > ticks_used) {
   353e6:	9b04      	ldr	r3, [sp, #16]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   353e8:	1a52      	subs	r2, r2, r1
   353ea:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
				if (ticks_elapsed > ticks_used) {
   353ee:	4293      	cmp	r3, r2
					ticks_used = ticks_elapsed -
   353f0:	bf8c      	ite	hi
   353f2:	1a9b      	subhi	r3, r3, r2
					ticks_used = 0;
   353f4:	2300      	movls	r3, #0
   353f6:	e7f0      	b.n	353da <ticker_job+0x502>
		ticker->ticks_to_expire_minus += ticks_elapsed -
   353f8:	6972      	ldr	r2, [r6, #20]
   353fa:	4413      	add	r3, r2
   353fc:	1a1b      	subs	r3, r3, r0
   353fe:	6173      	str	r3, [r6, #20]
		ticks_to_expire = 0U;
   35400:	2000      	movs	r0, #0
   35402:	e64d      	b.n	350a0 <ticker_job+0x1c8>
				ticker->req = ticker->ack;
   35404:	78a3      	ldrb	r3, [r4, #2]
				ticker->ticks_to_expire = ticks_elapsed;
   35406:	60a5      	str	r5, [r4, #8]
				ticker->req = ticker->ack;
   35408:	7063      	strb	r3, [r4, #1]
			ticks_to_expire_prep(ticker, instance->ticks_current,
   3540a:	9b08      	ldr	r3, [sp, #32]
   3540c:	f8da 1014 	ldr.w	r1, [sl, #20]
   35410:	eb03 0208 	add.w	r2, r3, r8
   35414:	4620      	mov	r0, r4
   35416:	f7ff fb25 	bl	34a64 <ticks_to_expire_prep>
			ticker->next = *insert_head;
   3541a:	9a01      	ldr	r2, [sp, #4]
   3541c:	9b05      	ldr	r3, [sp, #20]
   3541e:	f802 3009 	strb.w	r3, [r2, r9]
			ticker->req++;
   35422:	7863      	ldrb	r3, [r4, #1]
   35424:	f8cd b014 	str.w	fp, [sp, #20]
   35428:	3301      	adds	r3, #1
   3542a:	b2db      	uxtb	r3, r3
			ticker->req = ticker->ack;
   3542c:	7063      	strb	r3, [r4, #1]
	while (instance->ticker_id_head != TICKER_NULL) {
   3542e:	f89a b018 	ldrb.w	fp, [sl, #24]
   35432:	f1bb 0fff 	cmp.w	fp, #255	; 0xff
   35436:	f47f aee3 	bne.w	35200 <ticker_job+0x328>
   3543a:	e728      	b.n	3528e <ticker_job+0x3b6>
			if (TICKER_RESCHEDULE_PENDING(ticker)) {
   3543c:	b113      	cbz	r3, 35444 <ticker_job+0x56c>
   3543e:	7a1b      	ldrb	r3, [r3, #8]
   35440:	2b01      	cmp	r3, #1
   35442:	d0df      	beq.n	35404 <ticker_job+0x52c>
				if (!ticker->lazy_current) {
   35444:	f8b4 c01e 	ldrh.w	ip, [r4, #30]
   35448:	f1bc 0f00 	cmp.w	ip, #0
   3544c:	d140      	bne.n	354d0 <ticker_job+0x5f8>
					lazy_periodic = ticker->lazy_periodic;
   3544e:	f8b4 c01c 	ldrh.w	ip, [r4, #28]
				while (count--) {
   35452:	46e6      	mov	lr, ip
   35454:	1c48      	adds	r0, r1, #1
   35456:	e9cd 0402 	strd	r0, r4, [sp, #8]
	ticker->remainder_current += ticker->remainder_periodic;
   3545a:	e9d4 6308 	ldrd	r6, r3, [r4, #32]
				ticks_to_expire = 0U;
   3545e:	2200      	movs	r2, #0
   35460:	4670      	mov	r0, lr
   35462:	e004      	b.n	3546e <ticker_job+0x596>
				while (count--) {
   35464:	3801      	subs	r0, #1
	if ((ticker->remainder_current < BIT(31)) &&
   35466:	468e      	mov	lr, r1
				while (count--) {
   35468:	1c44      	adds	r4, r0, #1
					ticks_to_expire +=
   3546a:	4472      	add	r2, lr
				while (count--) {
   3546c:	d012      	beq.n	35494 <ticker_job+0x5bc>
	if ((ticker->remainder_current < BIT(31)) &&
   3546e:	f8df e170 	ldr.w	lr, [pc, #368]	; 355e0 <ticker_job+0x708>
   35472:	4c5c      	ldr	r4, [pc, #368]	; (355e4 <ticker_job+0x70c>)
	ticker->remainder_current += ticker->remainder_periodic;
   35474:	4433      	add	r3, r6
	if ((ticker->remainder_current < BIT(31)) &&
   35476:	449e      	add	lr, r3
   35478:	45a6      	cmp	lr, r4
   3547a:	d8f3      	bhi.n	35464 <ticker_job+0x58c>
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
   3547c:	f8dd e008 	ldr.w	lr, [sp, #8]
   35480:	f1a3 73e8 	sub.w	r3, r3, #30408704	; 0x1d00000
				while (count--) {
   35484:	3801      	subs	r0, #1
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
   35486:	f5a3 33d4 	sub.w	r3, r3, #108544	; 0x1a800
				while (count--) {
   3548a:	1c44      	adds	r4, r0, #1
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
   3548c:	f5a3 73a5 	sub.w	r3, r3, #330	; 0x14a
					ticks_to_expire +=
   35490:	4472      	add	r2, lr
				while (count--) {
   35492:	d1ec      	bne.n	3546e <ticker_job+0x596>
   35494:	9c03      	ldr	r4, [sp, #12]
				} else if (!ticker->must_expire) {
   35496:	f894 002c 	ldrb.w	r0, [r4, #44]	; 0x2c
   3549a:	6263      	str	r3, [r4, #36]	; 0x24
   3549c:	2800      	cmp	r0, #0
   3549e:	f000 815a 	beq.w	35756 <ticker_job+0x87e>
				ticker->ticks_to_expire = ticks_to_expire;
   354a2:	60a2      	str	r2, [r4, #8]
				ticker->lazy_current += (lazy_periodic + lazy);
   354a4:	f8a4 c01e 	strh.w	ip, [r4, #30]
   354a8:	e7af      	b.n	3540a <ticker_job+0x532>
		while (ticker->lazy_current < user_op->params.update.lazy) {
   354aa:	9f07      	ldr	r7, [sp, #28]
   354ac:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
   354ae:	8aaa      	ldrh	r2, [r5, #20]
   354b0:	e627      	b.n	35102 <ticker_job+0x22a>
		if (ticker->ticks_slot && (state == 2U) && !skip_collision &&
   354b2:	2800      	cmp	r0, #0
   354b4:	f47f aeca 	bne.w	3524c <ticker_job+0x374>
		    !TICKER_RESCHEDULE_PENDING(ticker)) {
   354b8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
		if (ticker->ticks_slot && (state == 2U) && !skip_collision &&
   354ba:	b11b      	cbz	r3, 354c4 <ticker_job+0x5ec>
		    !TICKER_RESCHEDULE_PENDING(ticker)) {
   354bc:	7a1b      	ldrb	r3, [r3, #8]
   354be:	2b01      	cmp	r3, #1
   354c0:	f43f aec4 	beq.w	3524c <ticker_job+0x374>
			instance->ticker_id_slot_previous = id_expired;
   354c4:	f88a b01b 	strb.w	fp, [sl, #27]
			instance->ticks_slot_previous = ticker->ticks_slot;
   354c8:	69a3      	ldr	r3, [r4, #24]
   354ca:	f8ca 301c 	str.w	r3, [sl, #28]
   354ce:	e6bd      	b.n	3524c <ticker_job+0x374>
					ticker->req = ticker->ack;
   354d0:	78a3      	ldrb	r3, [r4, #2]
   354d2:	7063      	strb	r3, [r4, #1]
				while (count--) {
   354d4:	f04f 0e00 	mov.w	lr, #0
   354d8:	e7bc      	b.n	35454 <ticker_job+0x57c>
		if (instance->ticks_slot_previous > ticks_elapsed) {
   354da:	f8da 601c 	ldr.w	r6, [sl, #28]
   354de:	9b04      	ldr	r3, [sp, #16]
		ticker_id_iter = nodes[ticker_id_head].next;
   354e0:	f81b 2001 	ldrb.w	r2, [fp, r1]
		if (instance->ticks_slot_previous > ticks_elapsed) {
   354e4:	42b3      	cmp	r3, r6
			window_start_ticks = instance->ticks_slot_previous -
   354e6:	bf38      	it	cc
   354e8:	1af6      	subcc	r6, r6, r3
		if (ext_data->ticks_drift < ext_data->ticks_slot_window) {
   354ea:	e9d7 3900 	ldrd	r3, r9, [r7]
		window_start_ticks = 0U;
   354ee:	bf28      	it	cs
   354f0:	2600      	movcs	r6, #0
		if (ext_data->ticks_drift < ext_data->ticks_slot_window) {
   354f2:	4599      	cmp	r9, r3
   354f4:	d278      	bcs.n	355e8 <ticker_job+0x710>
		while (ticker_id_iter != TICKER_NULL &&
   354f6:	2aff      	cmp	r2, #255	; 0xff
			ticks_slot_window = ext_data->ticks_slot_window -
   354f8:	eba3 0e09 	sub.w	lr, r3, r9
		while (ticker_id_iter != TICKER_NULL &&
   354fc:	d074      	beq.n	355e8 <ticker_job+0x710>
		       ticks_start_offset + ticker->ticks_slot <=
   354fe:	f8d0 c018 	ldr.w	ip, [r0, #24]
		while (ticker_id_iter != TICKER_NULL &&
   35502:	45f4      	cmp	ip, lr
   35504:	d870      	bhi.n	355e8 <ticker_job+0x710>
   35506:	2300      	movs	r3, #0
   35508:	e9cd 0701 	strd	r0, r7, [sp, #4]
		       ticks_start_offset + ticker->ticks_slot <=
   3550c:	46e0      	mov	r8, ip
		while (ticker_id_iter != TICKER_NULL &&
   3550e:	461d      	mov	r5, r3
   35510:	e01b      	b.n	3554a <ticker_job+0x672>
			if (node->ticks_to_expire >
   35512:	68b8      	ldr	r0, [r7, #8]
					MIN(ticks_slot_window,
   35514:	1f03      	subs	r3, r0, #4
			if (node->ticks_to_expire >
   35516:	2804      	cmp	r0, #4
					MIN(ticks_slot_window,
   35518:	442b      	add	r3, r5
			if (node->ticks_to_expire >
   3551a:	d909      	bls.n	35530 <ticker_job+0x658>
				window_end_ticks =
   3551c:	4573      	cmp	r3, lr
   3551e:	bf28      	it	cs
   35520:	4673      	movcs	r3, lr
			if (window_end_ticks > ticks_start_offset +
   35522:	4543      	cmp	r3, r8
   35524:	d904      	bls.n	35530 <ticker_job+0x658>
			if (ticks_to_expire != 0U &&
   35526:	ebb3 030c 	subs.w	r3, r3, ip
   3552a:	d001      	beq.n	35530 <ticker_job+0x658>
   3552c:	42b3      	cmp	r3, r6
   3552e:	d21d      	bcs.n	3556c <ticker_job+0x694>
			ticker_id_iter = node->next;
   35530:	f81b 2002 	ldrb.w	r2, [fp, r2]
			window_start_ticks  = node->ticks_to_expire +
   35534:	69be      	ldr	r6, [r7, #24]
			ticks_start_offset += node->ticks_to_expire;
   35536:	4405      	add	r5, r0
		while (ticker_id_iter != TICKER_NULL &&
   35538:	2aff      	cmp	r2, #255	; 0xff
			window_start_ticks  = node->ticks_to_expire +
   3553a:	4406      	add	r6, r0
			ticks_to_expire     = ticks_slot_window -
   3553c:	ebae 030c 	sub.w	r3, lr, ip
		       ticks_start_offset + ticker->ticks_slot <=
   35540:	eb0c 0805 	add.w	r8, ip, r5
		while (ticker_id_iter != TICKER_NULL &&
   35544:	d012      	beq.n	3556c <ticker_job+0x694>
   35546:	45c6      	cmp	lr, r8
   35548:	d310      	bcc.n	3556c <ticker_job+0x694>
			node = &nodes[ticker_id_iter];
   3554a:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   3554e:	eb0b 1702 	add.w	r7, fp, r2, lsl #4
   35552:	0112      	lsls	r2, r2, #4
			if (node->ext_data &&
   35554:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   35556:	2800      	cmp	r0, #0
   35558:	d0db      	beq.n	35512 <ticker_job+0x63a>
   3555a:	7a00      	ldrb	r0, [r0, #8]
   3555c:	2801      	cmp	r0, #1
   3555e:	d1d8      	bne.n	35512 <ticker_job+0x63a>
				ticker_id_iter = node->next;
   35560:	f81b 2002 	ldrb.w	r2, [fp, r2]
		while (ticker_id_iter != TICKER_NULL &&
   35564:	2aff      	cmp	r2, #255	; 0xff
		       ticks_start_offset + ticker->ticks_slot <=
   35566:	eb0c 0805 	add.w	r8, ip, r5
		while (ticker_id_iter != TICKER_NULL &&
   3556a:	d1ec      	bne.n	35546 <ticker_job+0x66e>
		ticker->ext_data->ticks_drift += ticks_to_expire -
   3556c:	e9dd 0701 	ldrd	r0, r7, [sp, #4]
   35570:	6882      	ldr	r2, [r0, #8]
   35572:	eba9 0202 	sub.w	r2, r9, r2
   35576:	441a      	add	r2, r3
   35578:	607a      	str	r2, [r7, #4]
		ticker->ticks_to_expire = ticks_to_expire;
   3557a:	6083      	str	r3, [r0, #8]
		ticker_id_iter = nodes[ticker_id_head].next;
   3557c:	f81b 5001 	ldrb.w	r5, [fp, r1]
		while (ticker_id_iter != TICKER_NULL) {
   35580:	2dff      	cmp	r5, #255	; 0xff
   35582:	d037      	beq.n	355f4 <ticker_job+0x71c>
		ticker_id_prev = TICKER_NULL;
   35584:	26ff      	movs	r6, #255	; 0xff
   35586:	46b6      	mov	lr, r6
   35588:	e000      	b.n	3558c <ticker_job+0x6b4>
			ticker_id_iter = node->next;
   3558a:	4615      	mov	r5, r2
			node = &nodes[ticker_id_iter];
   3558c:	b22a      	sxth	r2, r5
   3558e:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   35592:	eb0b 1c02 	add.w	ip, fp, r2, lsl #4
   35596:	0112      	lsls	r2, r2, #4
			if (ticker->ticks_to_expire > node->ticks_to_expire) {
   35598:	f8dc 6008 	ldr.w	r6, [ip, #8]
   3559c:	429e      	cmp	r6, r3
   3559e:	f080 8147 	bcs.w	35830 <ticker_job+0x958>
				ticker->ticks_to_expire -=
   355a2:	1b9b      	subs	r3, r3, r6
   355a4:	6083      	str	r3, [r0, #8]
			ticker_id_iter = node->next;
   355a6:	f81b 2002 	ldrb.w	r2, [fp, r2]
		while (ticker_id_iter != TICKER_NULL) {
   355aa:	2aff      	cmp	r2, #255	; 0xff
   355ac:	46ae      	mov	lr, r5
   355ae:	d1ec      	bne.n	3558a <ticker_job+0x6b2>
		if (ticker_id_prev != TICKER_NULL) {
   355b0:	2dff      	cmp	r5, #255	; 0xff
   355b2:	d01f      	beq.n	355f4 <ticker_job+0x71c>
			nodes[ticker_id_head].next = nodes[ticker_id_prev].next;
   355b4:	b22d      	sxth	r5, r5
   355b6:	eb05 0545 	add.w	r5, r5, r5, lsl #1
			instance->ticker_id_head = nodes[ticker_id_head].next;
   355ba:	f81b 2001 	ldrb.w	r2, [fp, r1]
   355be:	f88a 2018 	strb.w	r2, [sl, #24]
			nodes[ticker_id_head].next = nodes[ticker_id_prev].next;
   355c2:	012b      	lsls	r3, r5, #4
   355c4:	f81b 2003 	ldrb.w	r2, [fp, r3]
   355c8:	f80b 2001 	strb.w	r2, [fp, r1]
			nodes[ticker_id_prev].next = ticker_id_head;
   355cc:	f80b 4003 	strb.w	r4, [fp, r3]
   355d0:	e010      	b.n	355f4 <ticker_job+0x71c>
   355d2:	bf00      	nop
   355d4:	0005210c 	.word	0x0005210c
   355d8:	000521b8 	.word	0x000521b8
   355dc:	0005214c 	.word	0x0005214c
   355e0:	ff172b5a 	.word	0xff172b5a
   355e4:	7f172b59 	.word	0x7f172b59
		ticker->ext_data->ticks_drift += ticks_to_expire -
   355e8:	6883      	ldr	r3, [r0, #8]
   355ea:	eba9 0303 	sub.w	r3, r9, r3
   355ee:	607b      	str	r3, [r7, #4]
		ticker->ticks_to_expire = ticks_to_expire;
   355f0:	2300      	movs	r3, #0
   355f2:	6083      	str	r3, [r0, #8]
		ticker->lazy_current--;
   355f4:	8bc3      	ldrh	r3, [r0, #30]
   355f6:	3b01      	subs	r3, #1
   355f8:	83c3      	strh	r3, [r0, #30]
		ext_data->reschedule_state =
   355fa:	f04f 0302 	mov.w	r3, #2
   355fe:	723b      	strb	r3, [r7, #8]
		ticker_id_head = instance->ticker_id_head;
   35600:	f89a 3018 	ldrb.w	r3, [sl, #24]
		while (ticker_id_head != TICKER_NULL) {
   35604:	2bff      	cmp	r3, #255	; 0xff
		rescheduled  = 1U;
   35606:	f04f 0501 	mov.w	r5, #1
		ticker_id_head = instance->ticker_id_head;
   3560a:	461a      	mov	r2, r3
		while (ticker_id_head != TICKER_NULL) {
   3560c:	f47f ae56 	bne.w	352bc <ticker_job+0x3e4>
		if (ticker_job_reschedule_in_window(instance, ticks_elapsed)) {
   35610:	9e03      	ldr	r6, [sp, #12]
   35612:	b1a5      	cbz	r5, 3563e <ticker_job+0x766>
	if (instance->ticker_id_head != ticker_id_old_head) {
   35614:	9a09      	ldr	r2, [sp, #36]	; 0x24
   35616:	2aff      	cmp	r2, #255	; 0xff
   35618:	f000 80e1 	beq.w	357de <ticker_job+0x906>
	if (!pending) {
   3561c:	b33e      	cbz	r6, 3566e <ticker_job+0x796>
		if (cntr_stop() == 0) {
   3561e:	f00c f9d3 	bl	419c8 <cntr_stop>
   35622:	b9b8      	cbnz	r0, 35654 <ticker_job+0x77c>
			instance->ticks_slot_previous = 0U;
   35624:	f8ca 001c 	str.w	r0, [sl, #28]
			instance->ticks_current = cntr_cnt_get();
   35628:	f00c f9f4 	bl	41a14 <cntr_cnt_get>
   3562c:	f8ca 0014 	str.w	r0, [sl, #20]
   35630:	e010      	b.n	35654 <ticker_job+0x77c>
		ticker_job_list_insert(instance, insert_head);
   35632:	9905      	ldr	r1, [sp, #20]
   35634:	4650      	mov	r0, sl
   35636:	f7ff fa39 	bl	34aac <ticker_job_list_insert>
	if (instance->ticker_id_head != ticker_id_old_head) {
   3563a:	f89a 3018 	ldrb.w	r3, [sl, #24]
   3563e:	9a09      	ldr	r2, [sp, #36]	; 0x24
   35640:	429a      	cmp	r2, r3
   35642:	f47f ae54 	bne.w	352ee <ticker_job+0x416>
	if (!pending) {
   35646:	2e00      	cmp	r6, #0
   35648:	f000 80d8 	beq.w	357fc <ticker_job+0x924>
	if (flag_compare_update) {
   3564c:	9b07      	ldr	r3, [sp, #28]
   3564e:	2b00      	cmp	r3, #0
   35650:	f040 80eb 	bne.w	3582a <ticker_job+0x952>
	if (instance->worker_trigger) {
   35654:	f89a 301a 	ldrb.w	r3, [sl, #26]
	instance->job_guard = 0U;
   35658:	2200      	movs	r2, #0
   3565a:	f88a 2019 	strb.w	r2, [sl, #25]
	if (instance->worker_trigger) {
   3565e:	2b00      	cmp	r3, #0
   35660:	d075      	beq.n	3574e <ticker_job+0x876>
		instance->sched_cb(TICKER_CALL_ID_JOB, TICKER_CALL_ID_WORKER, 1,
   35662:	f8da 4024 	ldr.w	r4, [sl, #36]	; 0x24
   35666:	4653      	mov	r3, sl
   35668:	2201      	movs	r2, #1
   3566a:	2103      	movs	r1, #3
   3566c:	e4c5      	b.n	34ffa <ticker_job+0x122>
	count_user = instance->count_user;
   3566e:	f89a 2009 	ldrb.w	r2, [sl, #9]
	users = &instance->users[0];
   35672:	f8da 4004 	ldr.w	r4, [sl, #4]
	while (count_user--) {
   35676:	1e51      	subs	r1, r2, #1
   35678:	b2c9      	uxtb	r1, r1
   3567a:	2a00      	cmp	r2, #0
   3567c:	f43f ae3a 	beq.w	352f4 <ticker_job+0x41c>
		flag_compare_update = 1U;
   35680:	2301      	movs	r3, #1
   35682:	9307      	str	r3, [sp, #28]
   35684:	eb04 05c1 	add.w	r5, r4, r1, lsl #3
		uop->status = TICKER_STATUS_SUCCESS;
   35688:	2600      	movs	r6, #0
		while (user->first != user->last) {
   3568a:	786b      	ldrb	r3, [r5, #1]
   3568c:	78e9      	ldrb	r1, [r5, #3]
		user_op = &user->user_op[0];
   3568e:	686f      	ldr	r7, [r5, #4]
		while (user->first != user->last) {
   35690:	4299      	cmp	r1, r3
   35692:	d050      	beq.n	35736 <ticker_job+0x85e>
			ticker_job_op_inquire(instance, &user_op[user->first]);
   35694:	b21b      	sxth	r3, r3
   35696:	eb03 0243 	add.w	r2, r3, r3, lsl #1
   3569a:	eb03 0382 	add.w	r3, r3, r2, lsl #2
   3569e:	eb07 0e83 	add.w	lr, r7, r3, lsl #2
	switch (uop->op) {
   356a2:	f817 3023 	ldrb.w	r3, [r7, r3, lsl #2]
   356a6:	2b01      	cmp	r3, #1
   356a8:	d031      	beq.n	3570e <ticker_job+0x836>
   356aa:	2b02      	cmp	r3, #2
   356ac:	d139      	bne.n	35722 <ticker_job+0x84a>
		ticker_by_next_slot_get(instance,
   356ae:	f8de 9004 	ldr.w	r9, [lr, #4]
	node = instance->nodes;
   356b2:	f8da c000 	ldr.w	ip, [sl]
	_ticker_id_head = *ticker_id_head;
   356b6:	f899 2000 	ldrb.w	r2, [r9]
	    (*ticks_current != instance->ticks_current)) {
   356ba:	f8da 3014 	ldr.w	r3, [sl, #20]
		ticker_by_next_slot_get(instance,
   356be:	e9de 0802 	ldrd	r0, r8, [lr, #8]
	if ((_ticker_id_head == TICKER_NULL) ||
   356c2:	2aff      	cmp	r2, #255	; 0xff
	_ticks_to_expire = *ticks_to_expire;
   356c4:	f8d8 1000 	ldr.w	r1, [r8]
	if ((_ticker_id_head == TICKER_NULL) ||
   356c8:	d003      	beq.n	356d2 <ticker_job+0x7fa>
   356ca:	f8d0 b000 	ldr.w	fp, [r0]
   356ce:	459b      	cmp	fp, r3
   356d0:	d037      	beq.n	35742 <ticker_job+0x86a>
		_ticker_id_head = instance->ticker_id_head;
   356d2:	f89a 2018 	ldrb.w	r2, [sl, #24]
		*ticks_current = instance->ticks_current;
   356d6:	6003      	str	r3, [r0, #0]
		_ticks_to_expire = 0U;
   356d8:	2100      	movs	r1, #0
	while (_ticker_id_head != TICKER_NULL) {
   356da:	2aff      	cmp	r2, #255	; 0xff
   356dc:	d107      	bne.n	356ee <ticker_job+0x816>
   356de:	e012      	b.n	35706 <ticker_job+0x82e>
		_ticker_id_head = ticker->next;
   356e0:	f81c 2003 	ldrb.w	r2, [ip, r3]
		_ticks_to_expire += ticker->ticks_to_expire;
   356e4:	f8db 0008 	ldr.w	r0, [fp, #8]
	while (_ticker_id_head != TICKER_NULL) {
   356e8:	2aff      	cmp	r2, #255	; 0xff
		_ticks_to_expire += ticker->ticks_to_expire;
   356ea:	4401      	add	r1, r0
	while (_ticker_id_head != TICKER_NULL) {
   356ec:	d00b      	beq.n	35706 <ticker_job+0x82e>
		ticker = &node[_ticker_id_head];
   356ee:	eb02 0342 	add.w	r3, r2, r2, lsl #1
   356f2:	eb0c 1b03 	add.w	fp, ip, r3, lsl #4
   356f6:	011b      	lsls	r3, r3, #4
			if (ticker->ticks_slot) {
   356f8:	f8db 0018 	ldr.w	r0, [fp, #24]
   356fc:	2800      	cmp	r0, #0
   356fe:	d0ef      	beq.n	356e0 <ticker_job+0x808>
		_ticks_to_expire += ticker->ticks_to_expire;
   35700:	f8db 3008 	ldr.w	r3, [fp, #8]
   35704:	4419      	add	r1, r3
	*ticker_id_head = _ticker_id_head;
   35706:	f889 2000 	strb.w	r2, [r9]
	*ticks_to_expire = _ticks_to_expire;
   3570a:	f8c8 1000 	str.w	r1, [r8]
		fp_op_func = uop->fp_op_func;
   3570e:	f8de 302c 	ldr.w	r3, [lr, #44]	; 0x2c
		uop->status = TICKER_STATUS_SUCCESS;
   35712:	f8ce 6028 	str.w	r6, [lr, #40]	; 0x28
	if (fp_op_func) {
   35716:	b11b      	cbz	r3, 35720 <ticker_job+0x848>
		fp_op_func(uop->status, uop->op_context);
   35718:	f8de 1030 	ldr.w	r1, [lr, #48]	; 0x30
   3571c:	2000      	movs	r0, #0
   3571e:	4798      	blx	r3
   35720:	78e9      	ldrb	r1, [r5, #3]
			first = user->first + 1;
   35722:	786b      	ldrb	r3, [r5, #1]
			if (first == user->count_user_op) {
   35724:	782a      	ldrb	r2, [r5, #0]
			first = user->first + 1;
   35726:	3301      	adds	r3, #1
   35728:	b2db      	uxtb	r3, r3
				first = 0U;
   3572a:	429a      	cmp	r2, r3
   3572c:	bf08      	it	eq
   3572e:	2300      	moveq	r3, #0
		while (user->first != user->last) {
   35730:	4299      	cmp	r1, r3
			user->first = first;
   35732:	706b      	strb	r3, [r5, #1]
		while (user->first != user->last) {
   35734:	d1ae      	bne.n	35694 <ticker_job+0x7bc>
	while (count_user--) {
   35736:	42a5      	cmp	r5, r4
   35738:	f1a5 0308 	sub.w	r3, r5, #8
   3573c:	d086      	beq.n	3564c <ticker_job+0x774>
   3573e:	461d      	mov	r5, r3
   35740:	e7a3      	b.n	3568a <ticker_job+0x7b2>
		ticker = &node[_ticker_id_head];
   35742:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   35746:	0113      	lsls	r3, r2, #4
		_ticker_id_head = ticker->next;
   35748:	f81c 2003 	ldrb.w	r2, [ip, r3]
   3574c:	e7c5      	b.n	356da <ticker_job+0x802>
}
   3574e:	b00f      	add	sp, #60	; 0x3c
   35750:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   35754:	4770      	bx	lr
					while (ticks_to_expire <
   35756:	4297      	cmp	r7, r2
   35758:	f67f aea3 	bls.w	354a2 <ticker_job+0x5ca>
				lazy = 0U;
   3575c:	4686      	mov	lr, r0
   3575e:	1c48      	adds	r0, r1, #1
   35760:	9002      	str	r0, [sp, #8]
   35762:	9c02      	ldr	r4, [sp, #8]
   35764:	950b      	str	r5, [sp, #44]	; 0x2c
   35766:	4670      	mov	r0, lr
   35768:	e005      	b.n	35776 <ticker_job+0x89e>
	if ((ticker->remainder_current < BIT(31)) &&
   3576a:	468e      	mov	lr, r1
						ticks_to_expire +=
   3576c:	4472      	add	r2, lr
						lazy++;
   3576e:	3001      	adds	r0, #1
					while (ticks_to_expire <
   35770:	4297      	cmp	r7, r2
						lazy++;
   35772:	b280      	uxth	r0, r0
					while (ticks_to_expire <
   35774:	d912      	bls.n	3579c <ticker_job+0x8c4>
	if ((ticker->remainder_current < BIT(31)) &&
   35776:	f8df e0c8 	ldr.w	lr, [pc, #200]	; 35840 <ticker_job+0x968>
   3577a:	4d32      	ldr	r5, [pc, #200]	; (35844 <ticker_job+0x96c>)
	ticker->remainder_current += ticker->remainder_periodic;
   3577c:	4433      	add	r3, r6
	if ((ticker->remainder_current < BIT(31)) &&
   3577e:	449e      	add	lr, r3
   35780:	45ae      	cmp	lr, r5
   35782:	d8f2      	bhi.n	3576a <ticker_job+0x892>
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
   35784:	46a6      	mov	lr, r4
   35786:	f1a3 73e8 	sub.w	r3, r3, #30408704	; 0x1d00000
						ticks_to_expire +=
   3578a:	4472      	add	r2, lr
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
   3578c:	f5a3 33d4 	sub.w	r3, r3, #108544	; 0x1a800
						lazy++;
   35790:	3001      	adds	r0, #1
					while (ticks_to_expire <
   35792:	4297      	cmp	r7, r2
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
   35794:	f5a3 73a5 	sub.w	r3, r3, #330	; 0x14a
						lazy++;
   35798:	b280      	uxth	r0, r0
					while (ticks_to_expire <
   3579a:	d8ec      	bhi.n	35776 <ticker_job+0x89e>
				ticker->lazy_current += (lazy_periodic + lazy);
   3579c:	9c03      	ldr	r4, [sp, #12]
   3579e:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
   357a0:	6263      	str	r3, [r4, #36]	; 0x24
   357a2:	4460      	add	r0, ip
   357a4:	fa1f fc80 	uxth.w	ip, r0
   357a8:	e67b      	b.n	354a2 <ticker_job+0x5ca>
		flag_elapsed = 0U;
   357aa:	4614      	mov	r4, r2
		ticks_elapsed = 0U;
   357ac:	9204      	str	r2, [sp, #16]
   357ae:	f7ff bbbc 	b.w	34f2a <ticker_job+0x52>
			ticker->ticks_to_expire -= ticks_elapsed;
   357b2:	4622      	mov	r2, r4
   357b4:	1b5b      	subs	r3, r3, r5
   357b6:	6093      	str	r3, [r2, #8]
   357b8:	9c06      	ldr	r4, [sp, #24]
   357ba:	9e0a      	ldr	r6, [sp, #40]	; 0x28
		if (instance->ticker_id_head != ticker_id_old_head) {
   357bc:	f89a b018 	ldrb.w	fp, [sl, #24]
			break;
   357c0:	e567      	b.n	35292 <ticker_job+0x3ba>
	if (!pending) {
   357c2:	2e00      	cmp	r6, #0
   357c4:	f47f ad9e 	bne.w	35304 <ticker_job+0x42c>
	count_user = instance->count_user;
   357c8:	f89a 3009 	ldrb.w	r3, [sl, #9]
	users = &instance->users[0];
   357cc:	f8da 4004 	ldr.w	r4, [sl, #4]
	while (count_user--) {
   357d0:	1e59      	subs	r1, r3, #1
   357d2:	b2c9      	uxtb	r1, r1
   357d4:	2b00      	cmp	r3, #0
   357d6:	f43f ad95 	beq.w	35304 <ticker_job+0x42c>
			flag_compare_update = 1U;
   357da:	9507      	str	r5, [sp, #28]
   357dc:	e752      	b.n	35684 <ticker_job+0x7ac>
	if (!pending) {
   357de:	2e00      	cmp	r6, #0
   357e0:	f47f af1d 	bne.w	3561e <ticker_job+0x746>
	count_user = instance->count_user;
   357e4:	f89a 3009 	ldrb.w	r3, [sl, #9]
	users = &instance->users[0];
   357e8:	f8da 4004 	ldr.w	r4, [sl, #4]
	while (count_user--) {
   357ec:	1e59      	subs	r1, r3, #1
   357ee:	b2c9      	uxtb	r1, r1
   357f0:	2b00      	cmp	r3, #0
   357f2:	d1f2      	bne.n	357da <ticker_job+0x902>
   357f4:	e713      	b.n	3561e <ticker_job+0x746>
	insert_head = TICKER_NULL;
   357f6:	23ff      	movs	r3, #255	; 0xff
   357f8:	9305      	str	r3, [sp, #20]
   357fa:	e4e3      	b.n	351c4 <ticker_job+0x2ec>
	count_user = instance->count_user;
   357fc:	f89a 3009 	ldrb.w	r3, [sl, #9]
	users = &instance->users[0];
   35800:	f8da 4004 	ldr.w	r4, [sl, #4]
	while (count_user--) {
   35804:	1e59      	subs	r1, r3, #1
   35806:	b2c9      	uxtb	r1, r1
   35808:	2b00      	cmp	r3, #0
   3580a:	f47f af3b 	bne.w	35684 <ticker_job+0x7ac>
   3580e:	e71d      	b.n	3564c <ticker_job+0x774>
		ticks_current = cntr_cnt_get();
   35810:	f00c f900 	bl	41a14 <cntr_cnt_get>
   35814:	4604      	mov	r4, r0
		if (cntr_start() == 0) {
   35816:	f00c f8c7 	bl	419a8 <cntr_start>
	ticker = &instance->nodes[instance->ticker_id_head];
   3581a:	f89a 2018 	ldrb.w	r2, [sl, #24]
		if (cntr_start() == 0) {
   3581e:	2800      	cmp	r0, #0
   35820:	f47f ad70 	bne.w	35304 <ticker_job+0x42c>
			instance->ticks_current = ticks_current;
   35824:	f8ca 4014 	str.w	r4, [sl, #20]
   35828:	e56c      	b.n	35304 <ticker_job+0x42c>
	if (instance->ticker_id_head == TICKER_NULL) {
   3582a:	f89a 2018 	ldrb.w	r2, [sl, #24]
   3582e:	e562      	b.n	352f6 <ticker_job+0x41e>
				node->ticks_to_expire -=
   35830:	4672      	mov	r2, lr
   35832:	1af3      	subs	r3, r6, r3
   35834:	46b6      	mov	lr, r6
   35836:	f8cc 3008 	str.w	r3, [ip, #8]
				break;
   3583a:	4615      	mov	r5, r2
   3583c:	e6b8      	b.n	355b0 <ticker_job+0x6d8>
   3583e:	bf00      	nop
   35840:	ff172b5a 	.word	0xff172b5a
   35844:	7f172b59 	.word	0x7f172b59

00035848 <ticker_init>:
{
   35848:	b4f0      	push	{r4, r5, r6, r7}
   3584a:	9e04      	ldr	r6, [sp, #16]
   3584c:	f89d 5014 	ldrb.w	r5, [sp, #20]
   35850:	9c06      	ldr	r4, [sp, #24]
	if (instance_index >= TICKER_INSTANCE_MAX) {
   35852:	bb40      	cbnz	r0, 358a6 <ticker_init+0x5e>
	instance->count_node = count_node;
   35854:	4f15      	ldr	r7, [pc, #84]	; (358ac <ticker_init+0x64>)
	instance->nodes = node;
   35856:	603a      	str	r2, [r7, #0]
	while (count_user--) {
   35858:	1e5a      	subs	r2, r3, #1
	instance->count_node = count_node;
   3585a:	7239      	strb	r1, [r7, #8]
	instance->count_user = count_user;
   3585c:	727b      	strb	r3, [r7, #9]
	instance->users = user;
   3585e:	607e      	str	r6, [r7, #4]
	while (count_user--) {
   35860:	b2d2      	uxtb	r2, r2
   35862:	b183      	cbz	r3, 35886 <ticker_init+0x3e>
   35864:	eb06 02c2 	add.w	r2, r6, r2, lsl #3
		users[count_user].user_op = user_op_;
   35868:	6054      	str	r4, [r2, #4]
		user_op_ += users[count_user].count_user_op;
   3586a:	4610      	mov	r0, r2
   3586c:	f812 3908 	ldrb.w	r3, [r2], #-8
   35870:	eb03 0143 	add.w	r1, r3, r3, lsl #1
   35874:	eb03 0181 	add.w	r1, r3, r1, lsl #2
	while (count_user--) {
   35878:	4286      	cmp	r6, r0
		count_op -= users[count_user].count_user_op;
   3587a:	eba5 0303 	sub.w	r3, r5, r3
		user_op_ += users[count_user].count_user_op;
   3587e:	eb04 0481 	add.w	r4, r4, r1, lsl #2
		count_op -= users[count_user].count_user_op;
   35882:	b2dd      	uxtb	r5, r3
	while (count_user--) {
   35884:	d1f0      	bne.n	35868 <ticker_init+0x20>
	if (count_op) {
   35886:	b975      	cbnz	r5, 358a6 <ticker_init+0x5e>
	instance->caller_id_get_cb = caller_id_get_cb;
   35888:	9a07      	ldr	r2, [sp, #28]
   3588a:	623a      	str	r2, [r7, #32]
	instance->sched_cb = sched_cb;
   3588c:	9a08      	ldr	r2, [sp, #32]
   3588e:	627a      	str	r2, [r7, #36]	; 0x24
	instance->ticker_id_head = TICKER_NULL;
   35890:	23ff      	movs	r3, #255	; 0xff
	instance->trigger_set_cb = trigger_set_cb;
   35892:	9a09      	ldr	r2, [sp, #36]	; 0x24
   35894:	62ba      	str	r2, [r7, #40]	; 0x28
	instance->ticker_id_head = TICKER_NULL;
   35896:	763b      	strb	r3, [r7, #24]
	instance->ticks_current = 0U;
   35898:	617d      	str	r5, [r7, #20]
	instance->ticks_elapsed_first = 0U;
   3589a:	817d      	strh	r5, [r7, #10]
	instance->ticker_id_slot_previous = TICKER_NULL;
   3589c:	76fb      	strb	r3, [r7, #27]
	instance->ticks_slot_previous = 0U;
   3589e:	61fd      	str	r5, [r7, #28]
	return TICKER_STATUS_SUCCESS;
   358a0:	4628      	mov	r0, r5
}
   358a2:	bcf0      	pop	{r4, r5, r6, r7}
   358a4:	4770      	bx	lr
		return TICKER_STATUS_FAILURE;
   358a6:	2001      	movs	r0, #1
}
   358a8:	bcf0      	pop	{r4, r5, r6, r7}
   358aa:	4770      	bx	lr
   358ac:	2000449c 	.word	0x2000449c

000358b0 <ticker_is_initialized>:
	return !!(_instance[instance_index].count_node);
   358b0:	4b04      	ldr	r3, [pc, #16]	; (358c4 <ticker_is_initialized+0x14>)
   358b2:	222c      	movs	r2, #44	; 0x2c
   358b4:	fb02 3300 	mla	r3, r2, r0, r3
   358b8:	7a18      	ldrb	r0, [r3, #8]
}
   358ba:	3800      	subs	r0, #0
   358bc:	bf18      	it	ne
   358be:	2001      	movne	r0, #1
   358c0:	4770      	bx	lr
   358c2:	bf00      	nop
   358c4:	2000449c 	.word	0x2000449c

000358c8 <ticker_trigger>:
{
   358c8:	b410      	push	{r4}
	if (instance->sched_cb) {
   358ca:	4b0a      	ldr	r3, [pc, #40]	; (358f4 <ticker_trigger+0x2c>)
   358cc:	222c      	movs	r2, #44	; 0x2c
   358ce:	fb02 3200 	mla	r2, r2, r0, r3
   358d2:	6a54      	ldr	r4, [r2, #36]	; 0x24
   358d4:	b15c      	cbz	r4, 358ee <ticker_trigger+0x26>
	instance = &_instance[instance_index];
   358d6:	eb00 0280 	add.w	r2, r0, r0, lsl #2
   358da:	eb00 0042 	add.w	r0, r0, r2, lsl #1
		instance->sched_cb(TICKER_CALL_ID_TRIGGER,
   358de:	eb03 0380 	add.w	r3, r3, r0, lsl #2
   358e2:	46a4      	mov	ip, r4
   358e4:	2201      	movs	r2, #1
}
   358e6:	bc10      	pop	{r4}
		instance->sched_cb(TICKER_CALL_ID_TRIGGER,
   358e8:	2103      	movs	r1, #3
   358ea:	2002      	movs	r0, #2
   358ec:	4760      	bx	ip
}
   358ee:	bc10      	pop	{r4}
   358f0:	4770      	bx	lr
   358f2:	bf00      	nop
   358f4:	2000449c 	.word	0x2000449c

000358f8 <ticker_start_ext>:
{
   358f8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	struct ticker_instance *instance = &_instance[instance_index];
   358fc:	4e28      	ldr	r6, [pc, #160]	; (359a0 <ticker_start_ext+0xa8>)
{
   358fe:	f8bd 802c 	ldrh.w	r8, [sp, #44]	; 0x2c
   35902:	4604      	mov	r4, r0
	user = &instance->users[user_id];
   35904:	252c      	movs	r5, #44	; 0x2c
   35906:	fb05 6504 	mla	r5, r5, r4, r6
{
   3590a:	4608      	mov	r0, r1
	struct ticker_instance *instance = &_instance[instance_index];
   3590c:	eb04 0184 	add.w	r1, r4, r4, lsl #2
   35910:	eb04 0441 	add.w	r4, r4, r1, lsl #1
	user = &instance->users[user_id];
   35914:	6869      	ldr	r1, [r5, #4]
   35916:	eb01 07c0 	add.w	r7, r1, r0, lsl #3
	struct ticker_instance *instance = &_instance[instance_index];
   3591a:	eb06 0684 	add.w	r6, r6, r4, lsl #2
	last = user->last + 1;
   3591e:	78fc      	ldrb	r4, [r7, #3]
	if (last >= user->count_user_op) {
   35920:	f811 e030 	ldrb.w	lr, [r1, r0, lsl #3]
	if (last == user->first) {
   35924:	7879      	ldrb	r1, [r7, #1]
	last = user->last + 1;
   35926:	f104 0c01 	add.w	ip, r4, #1
   3592a:	fa5f fc8c 	uxtb.w	ip, ip
		last = 0U;
   3592e:	45e6      	cmp	lr, ip
   35930:	bf98      	it	ls
   35932:	f04f 0c00 	movls.w	ip, #0
	if (last == user->first) {
   35936:	4561      	cmp	r1, ip
   35938:	d02e      	beq.n	35998 <ticker_start_ext+0xa0>
	user_op = &user->user_op[user->last];
   3593a:	6879      	ldr	r1, [r7, #4]
   3593c:	eb04 0e44 	add.w	lr, r4, r4, lsl #1
   35940:	eb04 0e8e 	add.w	lr, r4, lr, lsl #2
   35944:	eb01 048e 	add.w	r4, r1, lr, lsl #2
	user_op->op = TICKER_USER_OP_TYPE_START;
   35948:	f04f 0904 	mov.w	r9, #4
   3594c:	f801 902e 	strb.w	r9, [r1, lr, lsl #2]
	user_op->params.start.ticks_at_start = ticks_anchor;
   35950:	6063      	str	r3, [r4, #4]
	user_op->params.start.ticks_first = ticks_first;
   35952:	9b08      	ldr	r3, [sp, #32]
   35954:	60a3      	str	r3, [r4, #8]
	user_op->params.start.ticks_periodic = ticks_periodic;
   35956:	9b09      	ldr	r3, [sp, #36]	; 0x24
   35958:	60e3      	str	r3, [r4, #12]
	user_op->params.start.remainder_periodic = remainder_periodic;
   3595a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   3595c:	6123      	str	r3, [r4, #16]
	user_op->params.start.ticks_slot = ticks_slot;
   3595e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   35960:	61a3      	str	r3, [r4, #24]
	user_op->params.start.ext_data = ext_data;
   35962:	9b11      	ldr	r3, [sp, #68]	; 0x44
   35964:	6263      	str	r3, [r4, #36]	; 0x24
	user_op->params.start.fp_timeout_func = fp_timeout_func;
   35966:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   35968:	61e3      	str	r3, [r4, #28]
	user_op->params.start.context = context;
   3596a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   3596c:	6223      	str	r3, [r4, #32]
	user_op->fp_op_func = fp_op_func;
   3596e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   35970:	62e3      	str	r3, [r4, #44]	; 0x2c
	user_op->op_context = op_context;
   35972:	9b10      	ldr	r3, [sp, #64]	; 0x40
   35974:	6323      	str	r3, [r4, #48]	; 0x30
	user_op->status = TICKER_STATUS_BUSY;
   35976:	2302      	movs	r3, #2
	user_op->id = ticker_id;
   35978:	7062      	strb	r2, [r4, #1]
	user_op->params.start.lazy = lazy;
   3597a:	f8a4 8014 	strh.w	r8, [r4, #20]
	user_op->status = TICKER_STATUS_BUSY;
   3597e:	62a3      	str	r3, [r4, #40]	; 0x28
	user->last = last;
   35980:	f887 c003 	strb.w	ip, [r7, #3]
	instance->sched_cb(instance->caller_id_get_cb(user_id),
   35984:	e9d5 3508 	ldrd	r3, r5, [r5, #32]
   35988:	4798      	blx	r3
   3598a:	4633      	mov	r3, r6
   3598c:	4649      	mov	r1, r9
   3598e:	2200      	movs	r2, #0
   35990:	47a8      	blx	r5
	return user_op->status;
   35992:	6aa0      	ldr	r0, [r4, #40]	; 0x28
}
   35994:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return TICKER_STATUS_FAILURE;
   35998:	2001      	movs	r0, #1
}
   3599a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   3599e:	bf00      	nop
   359a0:	2000449c 	.word	0x2000449c

000359a4 <ticker_start>:
{
   359a4:	b510      	push	{r4, lr}
   359a6:	b08a      	sub	sp, #40	; 0x28
   359a8:	9c0c      	ldr	r4, [sp, #48]	; 0x30
	return ticker_start_ext(instance_index, user_id, ticker_id,
   359aa:	9400      	str	r4, [sp, #0]
{
   359ac:	9c0d      	ldr	r4, [sp, #52]	; 0x34
	return ticker_start_ext(instance_index, user_id, ticker_id,
   359ae:	9401      	str	r4, [sp, #4]
{
   359b0:	9c0e      	ldr	r4, [sp, #56]	; 0x38
	return ticker_start_ext(instance_index, user_id, ticker_id,
   359b2:	9402      	str	r4, [sp, #8]
{
   359b4:	f8bd 403c 	ldrh.w	r4, [sp, #60]	; 0x3c
	return ticker_start_ext(instance_index, user_id, ticker_id,
   359b8:	9403      	str	r4, [sp, #12]
{
   359ba:	9c10      	ldr	r4, [sp, #64]	; 0x40
	return ticker_start_ext(instance_index, user_id, ticker_id,
   359bc:	9404      	str	r4, [sp, #16]
{
   359be:	9c11      	ldr	r4, [sp, #68]	; 0x44
	return ticker_start_ext(instance_index, user_id, ticker_id,
   359c0:	9405      	str	r4, [sp, #20]
{
   359c2:	9c12      	ldr	r4, [sp, #72]	; 0x48
	return ticker_start_ext(instance_index, user_id, ticker_id,
   359c4:	9406      	str	r4, [sp, #24]
{
   359c6:	9c13      	ldr	r4, [sp, #76]	; 0x4c
	return ticker_start_ext(instance_index, user_id, ticker_id,
   359c8:	9407      	str	r4, [sp, #28]
{
   359ca:	9c14      	ldr	r4, [sp, #80]	; 0x50
	return ticker_start_ext(instance_index, user_id, ticker_id,
   359cc:	9408      	str	r4, [sp, #32]
   359ce:	2400      	movs	r4, #0
   359d0:	9409      	str	r4, [sp, #36]	; 0x24
   359d2:	f7ff ff91 	bl	358f8 <ticker_start_ext>
}
   359d6:	b00a      	add	sp, #40	; 0x28
   359d8:	bd10      	pop	{r4, pc}
   359da:	bf00      	nop

000359dc <ticker_update_ext>:
{
   359dc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	struct ticker_instance *instance = &_instance[instance_index];
   359e0:	4d29      	ldr	r5, [pc, #164]	; (35a88 <ticker_update_ext+0xac>)
{
   359e2:	f8bd 7034 	ldrh.w	r7, [sp, #52]	; 0x34
   359e6:	f89d 8038 	ldrb.w	r8, [sp, #56]	; 0x38
   359ea:	4604      	mov	r4, r0
	user = &instance->users[user_id];
   359ec:	f04f 0e2c 	mov.w	lr, #44	; 0x2c
   359f0:	fb0e 5e04 	mla	lr, lr, r4, r5
{
   359f4:	4608      	mov	r0, r1
	struct ticker_instance *instance = &_instance[instance_index];
   359f6:	eb04 0184 	add.w	r1, r4, r4, lsl #2
   359fa:	eb04 0441 	add.w	r4, r4, r1, lsl #1
	user = &instance->users[user_id];
   359fe:	f8de 1004 	ldr.w	r1, [lr, #4]
   35a02:	eb01 06c0 	add.w	r6, r1, r0, lsl #3
	struct ticker_instance *instance = &_instance[instance_index];
   35a06:	eb05 0584 	add.w	r5, r5, r4, lsl #2
	last = user->last + 1;
   35a0a:	78f4      	ldrb	r4, [r6, #3]
	if (last >= user->count_user_op) {
   35a0c:	f811 9030 	ldrb.w	r9, [r1, r0, lsl #3]
	if (last == user->first) {
   35a10:	7871      	ldrb	r1, [r6, #1]
	last = user->last + 1;
   35a12:	f104 0c01 	add.w	ip, r4, #1
   35a16:	fa5f fc8c 	uxtb.w	ip, ip
		last = 0U;
   35a1a:	45e1      	cmp	r9, ip
   35a1c:	bf98      	it	ls
   35a1e:	f04f 0c00 	movls.w	ip, #0
	if (last == user->first) {
   35a22:	4561      	cmp	r1, ip
{
   35a24:	f89d 9044 	ldrb.w	r9, [sp, #68]	; 0x44
	if (last == user->first) {
   35a28:	d02a      	beq.n	35a80 <ticker_update_ext+0xa4>
	user_op = &user->user_op[user->last];
   35a2a:	f8d6 a004 	ldr.w	sl, [r6, #4]
   35a2e:	eb04 0144 	add.w	r1, r4, r4, lsl #1
   35a32:	eb04 0181 	add.w	r1, r4, r1, lsl #2
   35a36:	eb0a 0481 	add.w	r4, sl, r1, lsl #2
	user_op->op = TICKER_USER_OP_TYPE_UPDATE;
   35a3a:	f04f 0b05 	mov.w	fp, #5
   35a3e:	f80a b021 	strb.w	fp, [sl, r1, lsl #2]
	user_op->params.update.ticks_drift_plus = ticks_drift_plus;
   35a42:	6063      	str	r3, [r4, #4]
	user_op->params.update.ticks_drift_minus = ticks_drift_minus;
   35a44:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   35a46:	60a3      	str	r3, [r4, #8]
	user_op->params.update.ticks_slot_plus = ticks_slot_plus;
   35a48:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   35a4a:	60e3      	str	r3, [r4, #12]
	user_op->params.update.ticks_slot_minus = ticks_slot_minus;
   35a4c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   35a4e:	6123      	str	r3, [r4, #16]
	user_op->fp_op_func = fp_op_func;
   35a50:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   35a52:	62e3      	str	r3, [r4, #44]	; 0x2c
	user_op->op_context = op_context;
   35a54:	9b10      	ldr	r3, [sp, #64]	; 0x40
   35a56:	6323      	str	r3, [r4, #48]	; 0x30
	user_op->status = TICKER_STATUS_BUSY;
   35a58:	2302      	movs	r3, #2
	user_op->id = ticker_id;
   35a5a:	7062      	strb	r2, [r4, #1]
	user_op->params.update.lazy = lazy;
   35a5c:	82a7      	strh	r7, [r4, #20]
	user_op->params.update.force = force;
   35a5e:	f884 8016 	strb.w	r8, [r4, #22]
	user_op->params.update.must_expire = must_expire;
   35a62:	f884 9017 	strb.w	r9, [r4, #23]
	user_op->status = TICKER_STATUS_BUSY;
   35a66:	62a3      	str	r3, [r4, #40]	; 0x28
	user->last = last;
   35a68:	f886 c003 	strb.w	ip, [r6, #3]
	instance->sched_cb(instance->caller_id_get_cb(user_id),
   35a6c:	e9de 3608 	ldrd	r3, r6, [lr, #32]
   35a70:	4798      	blx	r3
   35a72:	462b      	mov	r3, r5
   35a74:	2200      	movs	r2, #0
   35a76:	2104      	movs	r1, #4
   35a78:	47b0      	blx	r6
	return user_op->status;
   35a7a:	6aa0      	ldr	r0, [r4, #40]	; 0x28
}
   35a7c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return TICKER_STATUS_FAILURE;
   35a80:	2001      	movs	r0, #1
}
   35a82:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   35a86:	bf00      	nop
   35a88:	2000449c 	.word	0x2000449c

00035a8c <ticker_update>:
{
   35a8c:	b510      	push	{r4, lr}
   35a8e:	b088      	sub	sp, #32
   35a90:	9c0a      	ldr	r4, [sp, #40]	; 0x28
	return ticker_update_ext(instance_index, user_id, ticker_id,
   35a92:	9400      	str	r4, [sp, #0]
{
   35a94:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
	return ticker_update_ext(instance_index, user_id, ticker_id,
   35a96:	9401      	str	r4, [sp, #4]
{
   35a98:	9c0c      	ldr	r4, [sp, #48]	; 0x30
	return ticker_update_ext(instance_index, user_id, ticker_id,
   35a9a:	9402      	str	r4, [sp, #8]
{
   35a9c:	f8bd 4034 	ldrh.w	r4, [sp, #52]	; 0x34
	return ticker_update_ext(instance_index, user_id, ticker_id,
   35aa0:	9403      	str	r4, [sp, #12]
{
   35aa2:	f89d 4038 	ldrb.w	r4, [sp, #56]	; 0x38
	return ticker_update_ext(instance_index, user_id, ticker_id,
   35aa6:	9404      	str	r4, [sp, #16]
{
   35aa8:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
	return ticker_update_ext(instance_index, user_id, ticker_id,
   35aaa:	9405      	str	r4, [sp, #20]
{
   35aac:	9c10      	ldr	r4, [sp, #64]	; 0x40
	return ticker_update_ext(instance_index, user_id, ticker_id,
   35aae:	9406      	str	r4, [sp, #24]
   35ab0:	2400      	movs	r4, #0
   35ab2:	9407      	str	r4, [sp, #28]
   35ab4:	f7ff ff92 	bl	359dc <ticker_update_ext>
}
   35ab8:	b008      	add	sp, #32
   35aba:	bd10      	pop	{r4, pc}

00035abc <ticker_stop>:
{
   35abc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   35ac0:	4607      	mov	r7, r0
	struct ticker_instance *instance = &_instance[instance_index];
   35ac2:	4d1e      	ldr	r5, [pc, #120]	; (35b3c <ticker_stop+0x80>)
   35ac4:	eb07 0487 	add.w	r4, r7, r7, lsl #2
{
   35ac8:	4608      	mov	r0, r1
	struct ticker_instance *instance = &_instance[instance_index];
   35aca:	eb07 0444 	add.w	r4, r7, r4, lsl #1
	user = &instance->users[user_id];
   35ace:	212c      	movs	r1, #44	; 0x2c
	struct ticker_instance *instance = &_instance[instance_index];
   35ad0:	eb05 0684 	add.w	r6, r5, r4, lsl #2
	user = &instance->users[user_id];
   35ad4:	fb01 5407 	mla	r4, r1, r7, r5
   35ad8:	6865      	ldr	r5, [r4, #4]
   35ada:	eb05 01c0 	add.w	r1, r5, r0, lsl #3
	if (last >= user->count_user_op) {
   35ade:	f815 7030 	ldrb.w	r7, [r5, r0, lsl #3]
	last = user->last + 1;
   35ae2:	f891 e003 	ldrb.w	lr, [r1, #3]
	if (last == user->first) {
   35ae6:	784d      	ldrb	r5, [r1, #1]
	last = user->last + 1;
   35ae8:	f10e 0c01 	add.w	ip, lr, #1
   35aec:	fa5f fc8c 	uxtb.w	ip, ip
		last = 0U;
   35af0:	4567      	cmp	r7, ip
   35af2:	bf98      	it	ls
   35af4:	f04f 0c00 	movls.w	ip, #0
	if (last == user->first) {
   35af8:	4565      	cmp	r5, ip
   35afa:	d01c      	beq.n	35b36 <ticker_stop+0x7a>
	user_op = &user->user_op[user->last];
   35afc:	684f      	ldr	r7, [r1, #4]
   35afe:	eb0e 054e 	add.w	r5, lr, lr, lsl #1
   35b02:	eb0e 0e85 	add.w	lr, lr, r5, lsl #2
   35b06:	eb07 058e 	add.w	r5, r7, lr, lsl #2
	user_op->op = TICKER_USER_OP_TYPE_STOP;
   35b0a:	f04f 0807 	mov.w	r8, #7
   35b0e:	f807 802e 	strb.w	r8, [r7, lr, lsl #2]
	user_op->fp_op_func = fp_op_func;
   35b12:	62eb      	str	r3, [r5, #44]	; 0x2c
	user_op->op_context = op_context;
   35b14:	9b06      	ldr	r3, [sp, #24]
   35b16:	632b      	str	r3, [r5, #48]	; 0x30
	user_op->status = TICKER_STATUS_BUSY;
   35b18:	2302      	movs	r3, #2
	user_op->id = ticker_id;
   35b1a:	706a      	strb	r2, [r5, #1]
	user_op->status = TICKER_STATUS_BUSY;
   35b1c:	62ab      	str	r3, [r5, #40]	; 0x28
	user->last = last;
   35b1e:	f881 c003 	strb.w	ip, [r1, #3]
	instance->sched_cb(instance->caller_id_get_cb(user_id),
   35b22:	e9d4 3708 	ldrd	r3, r7, [r4, #32]
   35b26:	4798      	blx	r3
   35b28:	4633      	mov	r3, r6
   35b2a:	2200      	movs	r2, #0
   35b2c:	2104      	movs	r1, #4
   35b2e:	47b8      	blx	r7
	return user_op->status;
   35b30:	6aa8      	ldr	r0, [r5, #40]	; 0x28
}
   35b32:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return TICKER_STATUS_FAILURE;
   35b36:	2001      	movs	r0, #1
}
   35b38:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   35b3c:	2000449c 	.word	0x2000449c

00035b40 <ticker_next_slot_get>:
{
   35b40:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   35b44:	4607      	mov	r7, r0
	struct ticker_instance *instance = &_instance[instance_index];
   35b46:	4d20      	ldr	r5, [pc, #128]	; (35bc8 <ticker_next_slot_get+0x88>)
   35b48:	eb07 0487 	add.w	r4, r7, r7, lsl #2
{
   35b4c:	4608      	mov	r0, r1
	struct ticker_instance *instance = &_instance[instance_index];
   35b4e:	eb07 0444 	add.w	r4, r7, r4, lsl #1
	user = &instance->users[user_id];
   35b52:	212c      	movs	r1, #44	; 0x2c
	struct ticker_instance *instance = &_instance[instance_index];
   35b54:	eb05 0684 	add.w	r6, r5, r4, lsl #2
	user = &instance->users[user_id];
   35b58:	fb01 5407 	mla	r4, r1, r7, r5
   35b5c:	6865      	ldr	r5, [r4, #4]
   35b5e:	eb05 01c0 	add.w	r1, r5, r0, lsl #3
	if (last >= user->count_user_op) {
   35b62:	f815 7030 	ldrb.w	r7, [r5, r0, lsl #3]
	last = user->last + 1;
   35b66:	f891 e003 	ldrb.w	lr, [r1, #3]
	if (last == user->first) {
   35b6a:	784d      	ldrb	r5, [r1, #1]
	last = user->last + 1;
   35b6c:	f10e 0c01 	add.w	ip, lr, #1
   35b70:	fa5f fc8c 	uxtb.w	ip, ip
		last = 0U;
   35b74:	4567      	cmp	r7, ip
   35b76:	bf98      	it	ls
   35b78:	f04f 0c00 	movls.w	ip, #0
	if (last == user->first) {
   35b7c:	4565      	cmp	r5, ip
   35b7e:	d020      	beq.n	35bc2 <ticker_next_slot_get+0x82>
	user_op = &user->user_op[user->last];
   35b80:	684f      	ldr	r7, [r1, #4]
   35b82:	eb0e 054e 	add.w	r5, lr, lr, lsl #1
   35b86:	eb0e 0e85 	add.w	lr, lr, r5, lsl #2
   35b8a:	eb07 058e 	add.w	r5, r7, lr, lsl #2
	user_op->op = TICKER_USER_OP_TYPE_SLOT_GET;
   35b8e:	f64f 7802 	movw	r8, #65282	; 0xff02
   35b92:	f827 802e 	strh.w	r8, [r7, lr, lsl #2]
	user_op->params.slot_get.ticks_current = ticks_current;
   35b96:	e9c5 2301 	strd	r2, r3, [r5, #4]
	user_op->params.slot_get.ticks_to_expire = ticks_to_expire;
   35b9a:	9b06      	ldr	r3, [sp, #24]
   35b9c:	60eb      	str	r3, [r5, #12]
	user_op->fp_op_func = fp_op_func;
   35b9e:	9b07      	ldr	r3, [sp, #28]
   35ba0:	62eb      	str	r3, [r5, #44]	; 0x2c
	user_op->op_context = op_context;
   35ba2:	9b08      	ldr	r3, [sp, #32]
   35ba4:	632b      	str	r3, [r5, #48]	; 0x30
	user_op->status = TICKER_STATUS_BUSY;
   35ba6:	2302      	movs	r3, #2
   35ba8:	62ab      	str	r3, [r5, #40]	; 0x28
	user->last = last;
   35baa:	f881 c003 	strb.w	ip, [r1, #3]
	instance->sched_cb(instance->caller_id_get_cb(user_id),
   35bae:	e9d4 3708 	ldrd	r3, r7, [r4, #32]
   35bb2:	4798      	blx	r3
   35bb4:	4633      	mov	r3, r6
   35bb6:	2200      	movs	r2, #0
   35bb8:	2104      	movs	r1, #4
   35bba:	47b8      	blx	r7
	return user_op->status;
   35bbc:	6aa8      	ldr	r0, [r5, #40]	; 0x28
}
   35bbe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return TICKER_STATUS_FAILURE;
   35bc2:	2001      	movs	r0, #1
}
   35bc4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   35bc8:	2000449c 	.word	0x2000449c

00035bcc <ticker_job_sched>:
{
   35bcc:	b570      	push	{r4, r5, r6, lr}
	instance->sched_cb(instance->caller_id_get_cb(user_id),
   35bce:	4d0a      	ldr	r5, [pc, #40]	; (35bf8 <ticker_job_sched+0x2c>)
   35bd0:	222c      	movs	r2, #44	; 0x2c
   35bd2:	fb02 5200 	mla	r2, r2, r0, r5
   35bd6:	e9d2 3608 	ldrd	r3, r6, [r2, #32]
{
   35bda:	4604      	mov	r4, r0
	instance->sched_cb(instance->caller_id_get_cb(user_id),
   35bdc:	4608      	mov	r0, r1
   35bde:	4798      	blx	r3
	struct ticker_instance *instance = &_instance[instance_index];
   35be0:	eb04 0384 	add.w	r3, r4, r4, lsl #2
   35be4:	eb04 0343 	add.w	r3, r4, r3, lsl #1
	instance->sched_cb(instance->caller_id_get_cb(user_id),
   35be8:	eb05 0383 	add.w	r3, r5, r3, lsl #2
   35bec:	46b4      	mov	ip, r6
   35bee:	2200      	movs	r2, #0
}
   35bf0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	instance->sched_cb(instance->caller_id_get_cb(user_id),
   35bf4:	2104      	movs	r1, #4
   35bf6:	4760      	bx	ip
   35bf8:	2000449c 	.word	0x2000449c

00035bfc <ticker_ticks_now_get>:
	return cntr_cnt_get();
   35bfc:	f00b bf0a 	b.w	41a14 <cntr_cnt_get>

00035c00 <ticker_ticks_diff_get>:
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   35c00:	1a40      	subs	r0, r0, r1
}
   35c02:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
   35c06:	4770      	bx	lr

00035c08 <ll_addr_set>:

static uint8_t pub_addr[BDADDR_SIZE];
static uint8_t rnd_addr[BDADDR_SIZE];

uint8_t ll_addr_set(uint8_t addr_type, uint8_t const *const bdaddr)
{
   35c08:	b538      	push	{r3, r4, r5, lr}
   35c0a:	4605      	mov	r5, r0
	if (IS_ENABLED(CONFIG_BT_BROADCASTER)) {
#if defined(CONFIG_BT_CTLR_ADV_EXT)
		if (ull_adv_is_enabled(0) && !ll_adv_cmds_is_ext()) {
#else /* !CONFIG_BT_CTLR_ADV_EXT */
		if (ull_adv_is_enabled(0)) {
   35c0c:	2000      	movs	r0, #0
{
   35c0e:	460c      	mov	r4, r1
		if (ull_adv_is_enabled(0)) {
   35c10:	f003 f9e2 	bl	38fd8 <ull_adv_is_enabled>
   35c14:	b9a8      	cbnz	r0, 35c42 <ll_addr_set+0x3a>
			return BT_HCI_ERR_CMD_DISALLOWED;
		}
	}

	if (IS_ENABLED(CONFIG_BT_OBSERVER) &&
	    (ull_scan_is_enabled(0) & (BIT(1) | BIT(2)))) {
   35c16:	f003 fb9b 	bl	39350 <ull_scan_is_enabled>
	if (IS_ENABLED(CONFIG_BT_OBSERVER) &&
   35c1a:	f010 0f06 	tst.w	r0, #6
   35c1e:	d110      	bne.n	35c42 <ll_addr_set+0x3a>
		return BT_HCI_ERR_CMD_DISALLOWED;
	}

	if (addr_type) {
   35c20:	b13d      	cbz	r5, 35c32 <ll_addr_set+0x2a>
		if (bdaddr) {
   35c22:	b184      	cbz	r4, 35c46 <ll_addr_set+0x3e>
			(void)memcpy(rnd_addr, bdaddr, BDADDR_SIZE);
   35c24:	480b      	ldr	r0, [pc, #44]	; (35c54 <ll_addr_set+0x4c>)
   35c26:	2206      	movs	r2, #6
   35c28:	4621      	mov	r1, r4
   35c2a:	f015 f926 	bl	4ae7a <memcpy>
		} else {
			(void)memset(pub_addr, 0, BDADDR_SIZE);
		}
	}

	return 0;
   35c2e:	2000      	movs	r0, #0
}
   35c30:	bd38      	pop	{r3, r4, r5, pc}
			(void)memcpy(pub_addr, bdaddr, BDADDR_SIZE);
   35c32:	4809      	ldr	r0, [pc, #36]	; (35c58 <ll_addr_set+0x50>)
   35c34:	2206      	movs	r2, #6
   35c36:	4621      	mov	r1, r4
		if (bdaddr) {
   35c38:	2c00      	cmp	r4, #0
   35c3a:	d1f6      	bne.n	35c2a <ll_addr_set+0x22>
			(void)memset(pub_addr, 0, BDADDR_SIZE);
   35c3c:	f015 f928 	bl	4ae90 <memset>
   35c40:	e7f5      	b.n	35c2e <ll_addr_set+0x26>
			return BT_HCI_ERR_CMD_DISALLOWED;
   35c42:	200c      	movs	r0, #12
}
   35c44:	bd38      	pop	{r3, r4, r5, pc}
			(void)memset(rnd_addr, 0, BDADDR_SIZE);
   35c46:	2206      	movs	r2, #6
   35c48:	4621      	mov	r1, r4
   35c4a:	4802      	ldr	r0, [pc, #8]	; (35c54 <ll_addr_set+0x4c>)
   35c4c:	f015 f920 	bl	4ae90 <memset>
   35c50:	e7ed      	b.n	35c2e <ll_addr_set+0x26>
   35c52:	bf00      	nop
   35c54:	200044c8 	.word	0x200044c8
   35c58:	200044d0 	.word	0x200044d0

00035c5c <ll_addr_get>:

uint8_t *ll_addr_get(uint8_t addr_type)
{
	if (addr_type > BT_ADDR_LE_RANDOM) {
   35c5c:	2801      	cmp	r0, #1
{
   35c5e:	4603      	mov	r3, r0
	if (addr_type > BT_ADDR_LE_RANDOM) {
   35c60:	d805      	bhi.n	35c6e <ll_addr_get+0x12>

	if (addr_type) {
		return rnd_addr;
	}

	return pub_addr;
   35c62:	4a04      	ldr	r2, [pc, #16]	; (35c74 <ll_addr_get+0x18>)
   35c64:	4804      	ldr	r0, [pc, #16]	; (35c78 <ll_addr_get+0x1c>)
   35c66:	2b00      	cmp	r3, #0
   35c68:	bf08      	it	eq
   35c6a:	4610      	moveq	r0, r2
   35c6c:	4770      	bx	lr
		return NULL;
   35c6e:	2000      	movs	r0, #0
}
   35c70:	4770      	bx	lr
   35c72:	bf00      	nop
   35c74:	200044d0 	.word	0x200044d0
   35c78:	200044c8 	.word	0x200044c8

00035c7c <ll_addr_read>:
	if (addr_type > BT_ADDR_LE_RANDOM) {
   35c7c:	2801      	cmp	r0, #1

uint8_t *ll_addr_read(uint8_t addr_type, uint8_t *const bdaddr)
{
   35c7e:	b510      	push	{r4, lr}
   35c80:	4603      	mov	r3, r0
	if (addr_type > BT_ADDR_LE_RANDOM) {
   35c82:	d80b      	bhi.n	35c9c <ll_addr_read+0x20>
	if (addr_type) {
   35c84:	4608      	mov	r0, r1
		return rnd_addr;
   35c86:	4c07      	ldr	r4, [pc, #28]	; (35ca4 <ll_addr_read+0x28>)
   35c88:	4907      	ldr	r1, [pc, #28]	; (35ca8 <ll_addr_read+0x2c>)
   35c8a:	2b00      	cmp	r3, #0
   35c8c:	bf18      	it	ne
   35c8e:	460c      	movne	r4, r1
	uint8_t *addr;

	addr = ll_addr_get(addr_type);
	if (addr) {
		memcpy(bdaddr, addr, BDADDR_SIZE);
   35c90:	2206      	movs	r2, #6
   35c92:	4621      	mov	r1, r4
   35c94:	f015 f8f1 	bl	4ae7a <memcpy>
	}

	return addr;
}
   35c98:	4620      	mov	r0, r4
   35c9a:	bd10      	pop	{r4, pc}
		return NULL;
   35c9c:	2400      	movs	r4, #0
}
   35c9e:	4620      	mov	r0, r4
   35ca0:	bd10      	pop	{r4, pc}
   35ca2:	bf00      	nop
   35ca4:	200044d0 	.word	0x200044d0
   35ca8:	200044c8 	.word	0x200044c8

00035cac <ll_tx_pwr_lvl_get>:
#include "ll.h"

uint8_t ll_tx_pwr_lvl_get(uint8_t handle_type,
		       uint16_t handle, uint8_t type, int8_t *tx_pwr_lvl)
{
	switch (handle_type) {
   35cac:	2802      	cmp	r0, #2
   35cae:	d001      	beq.n	35cb4 <ll_tx_pwr_lvl_get+0x8>
			}
			break;
		}
#endif /* CONFIG_BT_CONN */
		default: {
			return BT_HCI_ERR_UNKNOWN_CMD;
   35cb0:	2001      	movs	r0, #1
		}
	}

	return BT_HCI_ERR_SUCCESS;
}
   35cb2:	4770      	bx	lr
{
   35cb4:	b538      	push	{r3, r4, r5, lr}
   35cb6:	4604      	mov	r4, r0
			conn = ll_connected_get(handle);
   35cb8:	4608      	mov	r0, r1
   35cba:	461d      	mov	r5, r3
   35cbc:	f004 fa16 	bl	3a0ec <ll_connected_get>
			if (!conn) {
   35cc0:	b110      	cbz	r0, 35cc8 <ll_tx_pwr_lvl_get+0x1c>
				*tx_pwr_lvl = RADIO_TXP_DEFAULT;
   35cc2:	2000      	movs	r0, #0
   35cc4:	7028      	strb	r0, [r5, #0]
}
   35cc6:	bd38      	pop	{r3, r4, r5, pc}
				return BT_HCI_ERR_UNKNOWN_CONN_ID;
   35cc8:	4620      	mov	r0, r4
}
   35cca:	bd38      	pop	{r3, r4, r5, pc}

00035ccc <ll_tx_pwr_get>:
{
#if defined(CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL)
	*min = lll_radio_tx_pwr_min_get();
	*max = lll_radio_tx_pwr_max_get();
#else
	*min = RADIO_TXP_DEFAULT;
   35ccc:	2300      	movs	r3, #0
   35cce:	7003      	strb	r3, [r0, #0]
	*max = RADIO_TXP_DEFAULT;
   35cd0:	700b      	strb	r3, [r1, #0]
#endif /* CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL */
}
   35cd2:	4770      	bx	lr

00035cd4 <hci_driver_init>:
	.close	= hci_driver_close,
	.send	= hci_driver_send,
};

static int hci_driver_init(const struct device *unused)
{
   35cd4:	b508      	push	{r3, lr}
	ARG_UNUSED(unused);

	bt_hci_driver_register(&drv);
   35cd6:	4802      	ldr	r0, [pc, #8]	; (35ce0 <hci_driver_init+0xc>)
   35cd8:	f7f8 fcd4 	bl	2e684 <bt_hci_driver_register>

	return 0;
}
   35cdc:	2000      	movs	r0, #0
   35cde:	bd08      	pop	{r3, pc}
   35ce0:	000521d0 	.word	0x000521d0

00035ce4 <hci_driver_send>:
{
   35ce4:	b530      	push	{r4, r5, lr}
	if (!buf->len) {
   35ce6:	8983      	ldrh	r3, [r0, #12]
{
   35ce8:	b083      	sub	sp, #12
	if (!buf->len) {
   35cea:	b123      	cbz	r3, 35cf6 <hci_driver_send+0x12>
	return (enum bt_buf_type)((struct bt_buf_data *)net_buf_user_data(buf))
   35cec:	7d03      	ldrb	r3, [r0, #20]
	switch (type) {
   35cee:	4604      	mov	r4, r0
   35cf0:	b1c3      	cbz	r3, 35d24 <hci_driver_send+0x40>
   35cf2:	2b02      	cmp	r3, #2
   35cf4:	d004      	beq.n	35d00 <hci_driver_send+0x1c>
   35cf6:	f06f 0515 	mvn.w	r5, #21
}
   35cfa:	4628      	mov	r0, r5
   35cfc:	b003      	add	sp, #12
   35cfe:	bd30      	pop	{r4, r5, pc}
	err = hci_acl_handle(buf, &evt);
   35d00:	a901      	add	r1, sp, #4
   35d02:	f000 ff05 	bl	36b10 <hci_acl_handle>
	if (evt) {
   35d06:	9b01      	ldr	r3, [sp, #4]
	err = hci_acl_handle(buf, &evt);
   35d08:	4605      	mov	r5, r0
	if (evt) {
   35d0a:	b113      	cbz	r3, 35d12 <hci_driver_send+0x2e>
		bt_recv_prio(evt);
   35d0c:	4618      	mov	r0, r3
   35d0e:	f7f8 fc9b 	bl	2e648 <bt_recv_prio>
	if (!err) {
   35d12:	2d00      	cmp	r5, #0
   35d14:	d1f1      	bne.n	35cfa <hci_driver_send+0x16>
		net_buf_unref(buf);
   35d16:	4620      	mov	r0, r4
   35d18:	f00c fd96 	bl	42848 <net_buf_unref>
   35d1c:	2500      	movs	r5, #0
}
   35d1e:	4628      	mov	r0, r5
   35d20:	b003      	add	sp, #12
   35d22:	bd30      	pop	{r4, r5, pc}
	evt = hci_cmd_handle(buf, (void **) &node_rx);
   35d24:	a901      	add	r1, sp, #4
	struct node_rx_pdu *node_rx = NULL;
   35d26:	9301      	str	r3, [sp, #4]
	evt = hci_cmd_handle(buf, (void **) &node_rx);
   35d28:	f000 fabc 	bl	362a4 <hci_cmd_handle>
	if (evt) {
   35d2c:	2800      	cmp	r0, #0
   35d2e:	d0f2      	beq.n	35d16 <hci_driver_send+0x32>
		bt_recv_prio(evt);
   35d30:	f7f8 fc8a 	bl	2e648 <bt_recv_prio>
		if (node_rx) {
   35d34:	9d01      	ldr	r5, [sp, #4]
   35d36:	2d00      	cmp	r5, #0
   35d38:	d0ed      	beq.n	35d16 <hci_driver_send+0x32>
			node_rx->hdr.user_meta = hci_get_class(node_rx);
   35d3a:	4628      	mov	r0, r5
   35d3c:	f001 fb06 	bl	3734c <hci_get_class>
   35d40:	7168      	strb	r0, [r5, #5]
			k_fifo_put(&recv_fifo, node_rx);
   35d42:	9901      	ldr	r1, [sp, #4]
   35d44:	4801      	ldr	r0, [pc, #4]	; (35d4c <hci_driver_send+0x68>)
   35d46:	f01a f843 	bl	4fdd0 <k_queue_append>
	if (!err) {
   35d4a:	e7e4      	b.n	35d16 <hci_driver_send+0x32>
   35d4c:	200044d8 	.word	0x200044d8

00035d50 <hci_driver_close>:
{
   35d50:	b508      	push	{r3, lr}
	ll_deinit();
   35d52:	f002 fce7 	bl	38724 <ll_deinit>
	z_impl_k_thread_abort(thread);
   35d56:	4804      	ldr	r0, [pc, #16]	; (35d68 <hci_driver_close+0x18>)
   35d58:	f7f7 fa64 	bl	2d224 <z_impl_k_thread_abort>
   35d5c:	4803      	ldr	r0, [pc, #12]	; (35d6c <hci_driver_close+0x1c>)
   35d5e:	f7f7 fa61 	bl	2d224 <z_impl_k_thread_abort>
}
   35d62:	2000      	movs	r0, #0
   35d64:	bd08      	pop	{r3, pc}
   35d66:	bf00      	nop
   35d68:	20002860 	.word	0x20002860
   35d6c:	200027e0 	.word	0x200027e0

00035d70 <recv_thread>:
{
   35d70:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	return z_impl_k_queue_get(queue, timeout);
   35d74:	4e42      	ldr	r6, [pc, #264]	; (35e80 <recv_thread+0x110>)
		LL_ASSERT(0);
   35d76:	f8df 810c 	ldr.w	r8, [pc, #268]	; 35e84 <recv_thread+0x114>
   35d7a:	4f43      	ldr	r7, [pc, #268]	; (35e88 <recv_thread+0x118>)
{
   35d7c:	b082      	sub	sp, #8
   35d7e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   35d82:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   35d86:	4630      	mov	r0, r6
   35d88:	f011 f9c2 	bl	47110 <z_impl_k_queue_get>
		if (node_rx && !buf) {
   35d8c:	2800      	cmp	r0, #0
   35d8e:	d0f6      	beq.n	35d7e <recv_thread+0xe>
	uint8_t class = node_rx->hdr.user_meta;
   35d90:	7943      	ldrb	r3, [r0, #5]
	buf = encode_node(node_rx, class);
   35d92:	9001      	str	r0, [sp, #4]
	switch (class) {
   35d94:	2b04      	cmp	r3, #4
   35d96:	d821      	bhi.n	35ddc <recv_thread+0x6c>
   35d98:	2b00      	cmp	r3, #0
   35d9a:	d14b      	bne.n	35e34 <recv_thread+0xc4>
		LL_ASSERT(0);
   35d9c:	483b      	ldr	r0, [pc, #236]	; (35e8c <recv_thread+0x11c>)
   35d9e:	f44f 73dd 	mov.w	r3, #442	; 0x1ba
   35da2:	4642      	mov	r2, r8
   35da4:	4639      	mov	r1, r7
   35da6:	f013 f96d 	bl	49084 <assert_print>
   35daa:	4040      	eors	r0, r0
   35dac:	f380 8811 	msr	BASEPRI, r0
   35db0:	f04f 0003 	mov.w	r0, #3
   35db4:	df02      	svc	2
	node_rx->hdr.next = NULL;
   35db6:	9b01      	ldr	r3, [sp, #4]
   35db8:	2200      	movs	r2, #0
   35dba:	601a      	str	r2, [r3, #0]
	ll_rx_mem_release((void **)&node_rx);
   35dbc:	a801      	add	r0, sp, #4
   35dbe:	f001 ff01 	bl	37bc4 <ll_rx_mem_release>
   35dc2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   35dc6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   35dca:	4630      	mov	r0, r6
   35dcc:	f011 f9a0 	bl	47110 <z_impl_k_queue_get>
		if (node_rx && !buf) {
   35dd0:	2800      	cmp	r0, #0
   35dd2:	d0d4      	beq.n	35d7e <recv_thread+0xe>
	uint8_t class = node_rx->hdr.user_meta;
   35dd4:	7943      	ldrb	r3, [r0, #5]
	buf = encode_node(node_rx, class);
   35dd6:	9001      	str	r0, [sp, #4]
	switch (class) {
   35dd8:	2b04      	cmp	r3, #4
   35dda:	d9dd      	bls.n	35d98 <recv_thread+0x28>
   35ddc:	2b05      	cmp	r3, #5
   35dde:	d1dd      	bne.n	35d9c <recv_thread+0x2c>
		buf = bt_buf_get_rx(BT_BUF_ACL_IN, K_FOREVER);
   35de0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   35de4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   35de8:	2003      	movs	r0, #3
   35dea:	f7f7 fe2d 	bl	2da48 <bt_buf_get_rx>
   35dee:	4604      	mov	r4, r0
		hci_acl_encode(node_rx, buf);
   35df0:	4621      	mov	r1, r4
   35df2:	9801      	ldr	r0, [sp, #4]
   35df4:	f000 ff12 	bl	36c1c <hci_acl_encode>
	node_rx->hdr.next = NULL;
   35df8:	9b01      	ldr	r3, [sp, #4]
   35dfa:	2200      	movs	r2, #0
   35dfc:	601a      	str	r2, [r3, #0]
	ll_rx_mem_release((void **)&node_rx);
   35dfe:	a801      	add	r0, sp, #4
   35e00:	f001 fee0 	bl	37bc4 <ll_rx_mem_release>
		while (buf) {
   35e04:	2c00      	cmp	r4, #0
   35e06:	d0ba      	beq.n	35d7e <recv_thread+0xe>
			frag = net_buf_ref(buf);
   35e08:	4620      	mov	r0, r4
   35e0a:	f018 ffa1 	bl	4ed50 <net_buf_ref>
			buf = net_buf_frag_del(NULL, buf);
   35e0e:	4621      	mov	r1, r4
			frag = net_buf_ref(buf);
   35e10:	4605      	mov	r5, r0
			buf = net_buf_frag_del(NULL, buf);
   35e12:	2000      	movs	r0, #0
   35e14:	f018 ffc2 	bl	4ed9c <net_buf_frag_del>
			if (frag->len) {
   35e18:	89ab      	ldrh	r3, [r5, #12]
			buf = net_buf_frag_del(NULL, buf);
   35e1a:	4604      	mov	r4, r0
				bt_recv(frag);
   35e1c:	4628      	mov	r0, r5
			if (frag->len) {
   35e1e:	b133      	cbz	r3, 35e2e <recv_thread+0xbe>
				bt_recv(frag);
   35e20:	f7f8 fb98 	bl	2e554 <bt_recv>
	z_impl_k_yield();
   35e24:	f011 fe32 	bl	47a8c <z_impl_k_yield>
		while (buf) {
   35e28:	2c00      	cmp	r4, #0
   35e2a:	d1ed      	bne.n	35e08 <recv_thread+0x98>
   35e2c:	e7a7      	b.n	35d7e <recv_thread+0xe>
				net_buf_unref(frag);
   35e2e:	f00c fd0b 	bl	42848 <net_buf_unref>
   35e32:	e7f7      	b.n	35e24 <recv_thread+0xb4>
		if (class == HCI_CLASS_EVT_DISCARDABLE) {
   35e34:	2b02      	cmp	r3, #2
   35e36:	d013      	beq.n	35e60 <recv_thread+0xf0>
			buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
   35e38:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   35e3c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   35e40:	2001      	movs	r0, #1
   35e42:	f7f7 fe01 	bl	2da48 <bt_buf_get_rx>
   35e46:	4604      	mov	r4, r0
			hci_evt_encode(node_rx, buf);
   35e48:	9801      	ldr	r0, [sp, #4]
		if (buf) {
   35e4a:	b19c      	cbz	r4, 35e74 <recv_thread+0x104>
			hci_evt_encode(node_rx, buf);
   35e4c:	4621      	mov	r1, r4
   35e4e:	f000 ff1f 	bl	36c90 <hci_evt_encode>
	node_rx->hdr.next = NULL;
   35e52:	9b01      	ldr	r3, [sp, #4]
   35e54:	2200      	movs	r2, #0
   35e56:	601a      	str	r2, [r3, #0]
	ll_rx_mem_release((void **)&node_rx);
   35e58:	a801      	add	r0, sp, #4
   35e5a:	f001 feb3 	bl	37bc4 <ll_rx_mem_release>
		while (buf) {
   35e5e:	e7d3      	b.n	35e08 <recv_thread+0x98>
			buf = bt_buf_get_evt(BT_HCI_EVT_UNKNOWN, true,
   35e60:	2200      	movs	r2, #0
   35e62:	2300      	movs	r3, #0
   35e64:	2101      	movs	r1, #1
   35e66:	2000      	movs	r0, #0
   35e68:	f7f7 fe18 	bl	2da9c <bt_buf_get_evt>
   35e6c:	4604      	mov	r4, r0
			hci_evt_encode(node_rx, buf);
   35e6e:	9801      	ldr	r0, [sp, #4]
		if (buf) {
   35e70:	2c00      	cmp	r4, #0
   35e72:	d1eb      	bne.n	35e4c <recv_thread+0xdc>
	node_rx->hdr.next = NULL;
   35e74:	6004      	str	r4, [r0, #0]
	ll_rx_mem_release((void **)&node_rx);
   35e76:	a801      	add	r0, sp, #4
   35e78:	f001 fea4 	bl	37bc4 <ll_rx_mem_release>
		while (buf) {
   35e7c:	e77f      	b.n	35d7e <recv_thread+0xe>
   35e7e:	bf00      	nop
   35e80:	200044d8 	.word	0x200044d8
   35e84:	0005216c 	.word	0x0005216c
   35e88:	000521ac 	.word	0x000521ac
   35e8c:	0005214c 	.word	0x0005214c

00035e90 <prio_recv_thread>:
{
   35e90:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	return z_impl_k_sem_take(sem, timeout);
   35e94:	4f2e      	ldr	r7, [pc, #184]	; (35f50 <prio_recv_thread+0xc0>)
				k_fifo_put(&recv_fifo, node_rx);
   35e96:	4e2f      	ldr	r6, [pc, #188]	; (35f54 <prio_recv_thread+0xc4>)
{
   35e98:	b082      	sub	sp, #8
   35e9a:	e00c      	b.n	35eb6 <prio_recv_thread+0x26>
			buf = bt_buf_get_evt(BT_HCI_EVT_NUM_COMPLETED_PACKETS,
   35e9c:	f7f7 fdfe 	bl	2da9c <bt_buf_get_evt>
			hci_num_cmplt_encode(buf, handle, num_cmplt);
   35ea0:	4622      	mov	r2, r4
   35ea2:	f8bd 1002 	ldrh.w	r1, [sp, #2]
			buf = bt_buf_get_evt(BT_HCI_EVT_NUM_COMPLETED_PACKETS,
   35ea6:	4604      	mov	r4, r0
			hci_num_cmplt_encode(buf, handle, num_cmplt);
   35ea8:	f001 fa38 	bl	3731c <hci_num_cmplt_encode>
			bt_recv_prio(buf);
   35eac:	4620      	mov	r0, r4
   35eae:	f7f8 fbcb 	bl	2e648 <bt_recv_prio>
	z_impl_k_yield();
   35eb2:	f011 fdeb 	bl	47a8c <z_impl_k_yield>
		while ((num_cmplt = ll_rx_get((void *)&node_rx, &handle))) {
   35eb6:	f10d 0102 	add.w	r1, sp, #2
   35eba:	a801      	add	r0, sp, #4
   35ebc:	f001 fd4e 	bl	3795c <ll_rx_get>
   35ec0:	4604      	mov	r4, r0
			buf = bt_buf_get_evt(BT_HCI_EVT_NUM_COMPLETED_PACKETS,
   35ec2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   35ec6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   35eca:	2100      	movs	r1, #0
   35ecc:	2013      	movs	r0, #19
		while ((num_cmplt = ll_rx_get((void *)&node_rx, &handle))) {
   35ece:	2c00      	cmp	r4, #0
   35ed0:	d1e4      	bne.n	35e9c <prio_recv_thread+0xc>
		if (node_rx) {
   35ed2:	9b01      	ldr	r3, [sp, #4]
   35ed4:	b1b3      	cbz	r3, 35f04 <prio_recv_thread+0x74>
			ll_rx_dequeue();
   35ed6:	f001 fdbb 	bl	37a50 <ll_rx_dequeue>
			node_rx->hdr.user_meta = hci_get_class(node_rx);
   35eda:	f8dd 8004 	ldr.w	r8, [sp, #4]
   35ede:	4640      	mov	r0, r8
   35ee0:	f001 fa34 	bl	3734c <hci_get_class>
			buf = process_prio_evt(node_rx, &evt_flags);
   35ee4:	9d01      	ldr	r5, [sp, #4]
			node_rx->hdr.user_meta = hci_get_class(node_rx);
   35ee6:	f888 0005 	strb.w	r0, [r8, #5]
	if (node_rx->hdr.user_meta == HCI_CLASS_EVT_CONNECTION) {
   35eea:	796b      	ldrb	r3, [r5, #5]
   35eec:	2b03      	cmp	r3, #3
   35eee:	d102      	bne.n	35ef6 <prio_recv_thread+0x66>
		if (node_rx->hdr.type == NODE_RX_TYPE_TERMINATE) {
   35ef0:	792b      	ldrb	r3, [r5, #4]
   35ef2:	2b18      	cmp	r3, #24
   35ef4:	d00e      	beq.n	35f14 <prio_recv_thread+0x84>
				k_fifo_put(&recv_fifo, node_rx);
   35ef6:	4629      	mov	r1, r5
   35ef8:	4630      	mov	r0, r6
   35efa:	f019 ff69 	bl	4fdd0 <k_queue_append>
		if (iso_received || node_rx) {
   35efe:	9b01      	ldr	r3, [sp, #4]
   35f00:	2b00      	cmp	r3, #0
   35f02:	d1d8      	bne.n	35eb6 <prio_recv_thread+0x26>
	return z_impl_k_sem_take(sem, timeout);
   35f04:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   35f08:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   35f0c:	4638      	mov	r0, r7
   35f0e:	f011 f959 	bl	471c4 <z_impl_k_sem_take>
		while ((num_cmplt = ll_rx_get((void *)&node_rx, &handle))) {
   35f12:	e7d0      	b.n	35eb6 <prio_recv_thread+0x26>
			buf = bt_buf_get_evt(BT_HCI_EVT_DISCONN_COMPLETE, false,
   35f14:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   35f18:	4621      	mov	r1, r4
   35f1a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   35f1e:	2005      	movs	r0, #5
		handle = node_rx->hdr.handle;
   35f20:	f8b5 8006 	ldrh.w	r8, [r5, #6]
			buf = bt_buf_get_evt(BT_HCI_EVT_DISCONN_COMPLETE, false,
   35f24:	f7f7 fdba 	bl	2da9c <bt_buf_get_evt>
			hci_disconn_complete_encode(pdu_data, handle, buf);
   35f28:	4641      	mov	r1, r8
   35f2a:	4602      	mov	r2, r0
			buf = bt_buf_get_evt(BT_HCI_EVT_DISCONN_COMPLETE, false,
   35f2c:	4604      	mov	r4, r0
			hci_disconn_complete_encode(pdu_data, handle, buf);
   35f2e:	f105 001c 	add.w	r0, r5, #28
   35f32:	f000 fe4b 	bl	36bcc <hci_disconn_complete_encode>
			hci_disconn_complete_process(handle);
   35f36:	4640      	mov	r0, r8
   35f38:	f000 fe68 	bl	36c0c <hci_disconn_complete_process>
				bt_recv_prio(buf);
   35f3c:	4620      	mov	r0, r4
			if (buf) {
   35f3e:	b124      	cbz	r4, 35f4a <prio_recv_thread+0xba>
				bt_recv_prio(buf);
   35f40:	f7f8 fb82 	bl	2e648 <bt_recv_prio>
					net_buf_unref(buf);
   35f44:	4620      	mov	r0, r4
   35f46:	f00c fc7f 	bl	42848 <net_buf_unref>
				k_fifo_put(&recv_fifo, node_rx);
   35f4a:	9d01      	ldr	r5, [sp, #4]
   35f4c:	e7d3      	b.n	35ef6 <prio_recv_thread+0x66>
   35f4e:	bf00      	nop
   35f50:	200044f0 	.word	0x200044f0
   35f54:	200044d8 	.word	0x200044d8

00035f58 <hci_driver_open>:
{
   35f58:	b5d0      	push	{r4, r6, r7, lr}
   35f5a:	b088      	sub	sp, #32
	z_impl_k_queue_init(queue);
   35f5c:	481e      	ldr	r0, [pc, #120]	; (35fd8 <hci_driver_open+0x80>)
   35f5e:	f019 ff0b 	bl	4fd78 <z_impl_k_queue_init>
	return z_impl_k_sem_init(sem, initial_count, limit);
   35f62:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   35f66:	2100      	movs	r1, #0
   35f68:	481c      	ldr	r0, [pc, #112]	; (35fdc <hci_driver_open+0x84>)
   35f6a:	f019 ff85 	bl	4fe78 <z_impl_k_sem_init>
	err = ll_init(&sem_prio_recv);
   35f6e:	481b      	ldr	r0, [pc, #108]	; (35fdc <hci_driver_open+0x84>)
   35f70:	f002 faba 	bl	384e8 <ll_init>
	if (err) {
   35f74:	4604      	mov	r4, r0
   35f76:	bb58      	cbnz	r0, 35fd0 <hci_driver_open+0x78>
	hci_init(NULL);
   35f78:	f001 f9fe 	bl	37378 <hci_init>
	k_thread_create(&prio_recv_thread_data, prio_recv_thread_stack,
   35f7c:	2600      	movs	r6, #0
   35f7e:	2700      	movs	r7, #0
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   35f80:	f06f 0209 	mvn.w	r2, #9
   35f84:	e9cd 2403 	strd	r2, r4, [sp, #12]
   35f88:	e9cd 6706 	strd	r6, r7, [sp, #24]
   35f8c:	e9cd 4401 	strd	r4, r4, [sp, #4]
   35f90:	4b13      	ldr	r3, [pc, #76]	; (35fe0 <hci_driver_open+0x88>)
   35f92:	4914      	ldr	r1, [pc, #80]	; (35fe4 <hci_driver_open+0x8c>)
   35f94:	9400      	str	r4, [sp, #0]
   35f96:	f44f 72e0 	mov.w	r2, #448	; 0x1c0
   35f9a:	4813      	ldr	r0, [pc, #76]	; (35fe8 <hci_driver_open+0x90>)
   35f9c:	f010 feae 	bl	46cfc <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread, str);
   35fa0:	4912      	ldr	r1, [pc, #72]	; (35fec <hci_driver_open+0x94>)
   35fa2:	4811      	ldr	r0, [pc, #68]	; (35fe8 <hci_driver_open+0x90>)
   35fa4:	f019 fe5b 	bl	4fc5e <z_impl_k_thread_name_set>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   35fa8:	f06f 0207 	mvn.w	r2, #7
   35fac:	e9cd 2403 	strd	r2, r4, [sp, #12]
   35fb0:	e9cd 6706 	strd	r6, r7, [sp, #24]
   35fb4:	e9cd 4401 	strd	r4, r4, [sp, #4]
   35fb8:	4b0d      	ldr	r3, [pc, #52]	; (35ff0 <hci_driver_open+0x98>)
   35fba:	490e      	ldr	r1, [pc, #56]	; (35ff4 <hci_driver_open+0x9c>)
   35fbc:	9400      	str	r4, [sp, #0]
   35fbe:	f640 0298 	movw	r2, #2200	; 0x898
   35fc2:	480d      	ldr	r0, [pc, #52]	; (35ff8 <hci_driver_open+0xa0>)
   35fc4:	f010 fe9a 	bl	46cfc <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread, str);
   35fc8:	490c      	ldr	r1, [pc, #48]	; (35ffc <hci_driver_open+0xa4>)
   35fca:	480b      	ldr	r0, [pc, #44]	; (35ff8 <hci_driver_open+0xa0>)
   35fcc:	f019 fe47 	bl	4fc5e <z_impl_k_thread_name_set>
}
   35fd0:	4620      	mov	r0, r4
   35fd2:	b008      	add	sp, #32
   35fd4:	bdd0      	pop	{r4, r6, r7, pc}
   35fd6:	bf00      	nop
   35fd8:	200044d8 	.word	0x200044d8
   35fdc:	200044f0 	.word	0x200044f0
   35fe0:	00035e91 	.word	0x00035e91
   35fe4:	20008ae8 	.word	0x20008ae8
   35fe8:	20002860 	.word	0x20002860
   35fec:	000521b0 	.word	0x000521b0
   35ff0:	00035d71 	.word	0x00035d71
   35ff4:	20008250 	.word	0x20008250
   35ff8:	200027e0 	.word	0x200027e0
   35ffc:	000521bc 	.word	0x000521bc

00036000 <hci_recv_fifo_reset>:
{
   36000:	b510      	push	{r4, lr}
	k_sched_lock();
   36002:	f011 fd07 	bl	47a14 <k_sched_lock>
	z_impl_k_queue_cancel_wait(queue);
   36006:	4c05      	ldr	r4, [pc, #20]	; (3601c <hci_recv_fifo_reset+0x1c>)
   36008:	4620      	mov	r0, r4
   3600a:	f019 fec1 	bl	4fd90 <z_impl_k_queue_cancel_wait>
	z_impl_k_queue_init(queue);
   3600e:	4620      	mov	r0, r4
   36010:	f019 feb2 	bl	4fd78 <z_impl_k_queue_init>
}
   36014:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	k_sched_unlock();
   36018:	f011 bd10 	b.w	47a3c <k_sched_unlock>
   3601c:	200044d8 	.word	0x200044d8

00036020 <dup_found.constprop.0>:
	}

	return true;
}

static bool dup_found(uint8_t adv_type, uint8_t addr_type, const uint8_t *addr,
   36020:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		      uint8_t adv_mode, const struct pdu_adv_adi *adi,
		      uint8_t data_status)
{
	/* check for duplicate filtering */
	if (dup_count >= 0) {
   36024:	f8df 90a0 	ldr.w	r9, [pc, #160]	; 360c8 <dup_found.constprop.0+0xa8>
   36028:	f8d9 3000 	ldr.w	r3, [r9]
   3602c:	2b00      	cmp	r3, #0
   3602e:	db34      	blt.n	3609a <dup_found.constprop.0+0x7a>
   36030:	4680      	mov	r8, r0
   36032:	460f      	mov	r7, r1
   36034:	4616      	mov	r6, r2
		__ASSERT((adv_mode < ARRAY_SIZE(dup_filter[0].adv_mode)),
			 "adv_mode index out-of-bound");
#endif /* CONFIG_BT_CTLR_ADV_EXT */

		/* find for existing entry and update if changed */
		for (int32_t i = 0; i < dup_count; i++) {
   36036:	d012      	beq.n	3605e <dup_found.constprop.0+0x3e>
   36038:	4c24      	ldr	r4, [pc, #144]	; (360cc <dup_found.constprop.0+0xac>)
   3603a:	2500      	movs	r5, #0
			dup = &dup_filter[i];
			if (memcmp(addr, &dup->addr.a.val[0],
   3603c:	4621      	mov	r1, r4
   3603e:	2206      	movs	r2, #6
   36040:	4630      	mov	r0, r6
   36042:	f014 ff0a 	bl	4ae5a <memcmp>
   36046:	b918      	cbnz	r0, 36050 <dup_found.constprop.0+0x30>
				   sizeof(bt_addr_t)) ||
   36048:	f814 3c01 	ldrb.w	r3, [r4, #-1]
   3604c:	42bb      	cmp	r3, r7
   3604e:	d027      	beq.n	360a0 <dup_found.constprop.0+0x80>
		for (int32_t i = 0; i < dup_count; i++) {
   36050:	f8d9 3000 	ldr.w	r3, [r9]
   36054:	3501      	adds	r5, #1
   36056:	429d      	cmp	r5, r3
   36058:	f104 0408 	add.w	r4, r4, #8
   3605c:	dbee      	blt.n	3603c <dup_found.constprop.0+0x1c>
			return is_dup_or_update(dup, adv_type, adv_mode, adi,
						data_status);
		}

		/* insert into the duplicate filter */
		dup = &dup_filter[dup_curr];
   3605e:	4c1c      	ldr	r4, [pc, #112]	; (360d0 <dup_found.constprop.0+0xb0>)
		(void)memcpy(&dup->addr.a.val[0], addr, sizeof(bt_addr_t));
   36060:	4d1c      	ldr	r5, [pc, #112]	; (360d4 <dup_found.constprop.0+0xb4>)
		dup = &dup_filter[dup_curr];
   36062:	f8d4 a000 	ldr.w	sl, [r4]
		(void)memcpy(&dup->addr.a.val[0], addr, sizeof(bt_addr_t));
   36066:	4631      	mov	r1, r6
   36068:	ea4f 06ca 	mov.w	r6, sl, lsl #3
   3606c:	1c70      	adds	r0, r6, #1
   3606e:	4428      	add	r0, r5
   36070:	2206      	movs	r2, #6
   36072:	f014 ff02 	bl	4ae7a <memcpy>
		dup_ext_adv_mode_reset(dup->adv_mode);
		dup_ext_adv_adi_store(&dup->adv_mode[adv_mode], adi,
				      data_status);
#endif /* CONFIG_BT_CTLR_ADV_EXT */

		if (dup_count < CONFIG_BT_CTLR_DUP_FILTER_LEN) {
   36076:	f8d9 3000 	ldr.w	r3, [r9]
		dup->addr.type = addr_type;
   3607a:	f805 703a 	strb.w	r7, [r5, sl, lsl #3]
		dup->mask = BIT(adv_type);
   3607e:	2201      	movs	r2, #1
   36080:	4435      	add	r5, r6
   36082:	fa02 f208 	lsl.w	r2, r2, r8
		if (dup_count < CONFIG_BT_CTLR_DUP_FILTER_LEN) {
   36086:	2b0f      	cmp	r3, #15
		dup->mask = BIT(adv_type);
   36088:	71ea      	strb	r2, [r5, #7]
		if (dup_count < CONFIG_BT_CTLR_DUP_FILTER_LEN) {
   3608a:	dc1a      	bgt.n	360c2 <dup_found.constprop.0+0xa2>
			dup_count++;
   3608c:	3301      	adds	r3, #1
   3608e:	f8c9 3000 	str.w	r3, [r9]
			dup_curr = dup_count;
		} else {
			dup_curr++;
		}

		if (dup_curr == CONFIG_BT_CTLR_DUP_FILTER_LEN) {
   36092:	2b10      	cmp	r3, #16
			dup_curr = 0U;
   36094:	bf08      	it	eq
   36096:	2300      	moveq	r3, #0
   36098:	6023      	str	r3, [r4, #0]
		return false;
   3609a:	2000      	movs	r0, #0
		}
	}

	return false;
}
   3609c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (!(dup->mask & BIT(adv_type))) {
   360a0:	4b0c      	ldr	r3, [pc, #48]	; (360d4 <dup_found.constprop.0+0xb4>)
   360a2:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
   360a6:	79da      	ldrb	r2, [r3, #7]
   360a8:	fa22 f108 	lsr.w	r1, r2, r8
   360ac:	07c9      	lsls	r1, r1, #31
   360ae:	d502      	bpl.n	360b6 <dup_found.constprop.0+0x96>
	return true;
   360b0:	2001      	movs	r0, #1
}
   360b2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		dup->mask |= BIT(adv_type);
   360b6:	2101      	movs	r1, #1
   360b8:	fa01 f108 	lsl.w	r1, r1, r8
   360bc:	430a      	orrs	r2, r1
   360be:	71da      	strb	r2, [r3, #7]
		return false;
   360c0:	e7eb      	b.n	3609a <dup_found.constprop.0+0x7a>
			dup_curr++;
   360c2:	6823      	ldr	r3, [r4, #0]
   360c4:	3301      	adds	r3, #1
   360c6:	e7e4      	b.n	36092 <dup_found.constprop.0+0x72>
   360c8:	20004510 	.word	0x20004510
   360cc:	20004515 	.word	0x20004515
   360d0:	2000450c 	.word	0x2000450c
   360d4:	20004514 	.word	0x20004514

000360d8 <le_remote_feat_complete>:
}
#endif /* CONFIG_BT_CTLR_LE_ENC */

static void le_remote_feat_complete(uint8_t status, struct pdu_data *pdu_data,
				    uint16_t handle, struct net_buf *buf)
{
   360d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct bt_hci_evt_le_remote_feat_complete *sep;

	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   360da:	4c18      	ldr	r4, [pc, #96]	; (3613c <le_remote_feat_complete+0x64>)
   360dc:	6864      	ldr	r4, [r4, #4]
   360de:	00a4      	lsls	r4, r4, #2
   360e0:	d504      	bpl.n	360ec <le_remote_feat_complete+0x14>
   360e2:	4615      	mov	r5, r2
	    !(le_event_mask & BT_EVT_MASK_LE_REMOTE_FEAT_COMPLETE)) {
   360e4:	4a16      	ldr	r2, [pc, #88]	; (36140 <le_remote_feat_complete+0x68>)
   360e6:	6812      	ldr	r2, [r2, #0]
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   360e8:	0712      	lsls	r2, r2, #28
   360ea:	d400      	bmi.n	360ee <le_remote_feat_complete+0x16>
		       &pdu_data->llctrl.feature_rsp.features[0],
		       sizeof(sep->features));
	} else {
		(void)memset(&sep->features[0], 0x00, sizeof(sep->features));
	}
}
   360ec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return net_buf_simple_add(&buf->b, len);
   360ee:	f103 0408 	add.w	r4, r3, #8
   360f2:	4607      	mov	r7, r0
   360f4:	460e      	mov	r6, r1
   360f6:	4620      	mov	r0, r4
   360f8:	2102      	movs	r1, #2
   360fa:	f018 fe5b 	bl	4edb4 <net_buf_simple_add>
	hdr->evt = evt;
   360fe:	f640 433e 	movw	r3, #3134	; 0xc3e
   36102:	8003      	strh	r3, [r0, #0]
   36104:	2101      	movs	r1, #1
   36106:	4620      	mov	r0, r4
   36108:	f018 fe54 	bl	4edb4 <net_buf_simple_add>
   3610c:	4603      	mov	r3, r0
	me->subevent = subevt;
   3610e:	2204      	movs	r2, #4
   36110:	701a      	strb	r2, [r3, #0]
   36112:	4620      	mov	r0, r4
   36114:	210b      	movs	r1, #11
   36116:	f018 fe4d 	bl	4edb4 <net_buf_simple_add>
		memcpy(&sep->features[0],
   3611a:	2208      	movs	r2, #8
	sep->status = status;
   3611c:	7007      	strb	r7, [r0, #0]
	sep->handle = sys_cpu_to_le16(handle);
   3611e:	f8a0 5001 	strh.w	r5, [r0, #1]
	if (!status) {
   36122:	b92f      	cbnz	r7, 36130 <le_remote_feat_complete+0x58>
		memcpy(&sep->features[0],
   36124:	1d31      	adds	r1, r6, #4
   36126:	3003      	adds	r0, #3
}
   36128:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		memcpy(&sep->features[0],
   3612c:	f014 bea5 	b.w	4ae7a <memcpy>
}
   36130:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		(void)memset(&sep->features[0], 0x00, sizeof(sep->features));
   36134:	2100      	movs	r1, #0
   36136:	3003      	adds	r0, #3
   36138:	f014 beaa 	b.w	4ae90 <memset>
   3613c:	20000190 	.word	0x20000190
   36140:	20000188 	.word	0x20000188

00036144 <hci_vendor_cmd_handle_common>:
{
   36144:	b570      	push	{r4, r5, r6, lr}
	switch (ocf) {
   36146:	3801      	subs	r0, #1
{
   36148:	b086      	sub	sp, #24
   3614a:	4614      	mov	r4, r2
	switch (ocf) {
   3614c:	2809      	cmp	r0, #9
   3614e:	d806      	bhi.n	3615e <hci_vendor_cmd_handle_common+0x1a>
   36150:	e8df f000 	tbb	[pc, r0]
   36154:	05412709 	.word	0x05412709
   36158:	64055205 	.word	0x64055205
   3615c:	927f      	.short	0x927f
   3615e:	f06f 0015 	mvn.w	r0, #21
}
   36162:	b006      	add	sp, #24
   36164:	bd70      	pop	{r4, r5, r6, pc}
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
   36166:	4b4d      	ldr	r3, [pc, #308]	; (3629c <hci_vendor_cmd_handle_common+0x158>)
   36168:	210d      	movs	r1, #13
   3616a:	8818      	ldrh	r0, [r3, #0]
   3616c:	f015 fb10 	bl	4b790 <bt_hci_cmd_complete_create>
   36170:	210d      	movs	r1, #13
   36172:	6020      	str	r0, [r4, #0]
   36174:	3008      	adds	r0, #8
   36176:	f018 fe1d 	bl	4edb4 <net_buf_simple_add>
	rp->hw_platform = sys_cpu_to_le16(BT_HCI_VS_HW_PLAT);
   3617a:	f04f 1402 	mov.w	r4, #131074	; 0x20002
	rp->status = 0x00;
   3617e:	2300      	movs	r3, #0
	rp->fw_variant = 0U;
   36180:	f44f 7140 	mov.w	r1, #768	; 0x300
	rp->fw_revision = sys_cpu_to_le16(KERNEL_VERSION_MINOR);
   36184:	2202      	movs	r2, #2
	rp->status = 0x00;
   36186:	7003      	strb	r3, [r0, #0]
	rp->hw_platform = sys_cpu_to_le16(BT_HCI_VS_HW_PLAT);
   36188:	f8c0 4001 	str.w	r4, [r0, #1]
	rp->fw_variant = 0U;
   3618c:	f8a0 1005 	strh.w	r1, [r0, #5]
	rp->fw_revision = sys_cpu_to_le16(KERNEL_VERSION_MINOR);
   36190:	71c2      	strb	r2, [r0, #7]
   36192:	7203      	strb	r3, [r0, #8]
	rp->fw_build = sys_cpu_to_le32(KERNEL_PATCHLEVEL & 0xffff);
   36194:	7243      	strb	r3, [r0, #9]
   36196:	7283      	strb	r3, [r0, #10]
   36198:	72c3      	strb	r3, [r0, #11]
   3619a:	7303      	strb	r3, [r0, #12]
	return 0;
   3619c:	2000      	movs	r0, #0
}
   3619e:	b006      	add	sp, #24
   361a0:	bd70      	pop	{r4, r5, r6, pc}
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
   361a2:	4b3e      	ldr	r3, [pc, #248]	; (3629c <hci_vendor_cmd_handle_common+0x158>)
   361a4:	2141      	movs	r1, #65	; 0x41
   361a6:	8818      	ldrh	r0, [r3, #0]
   361a8:	f015 faf2 	bl	4b790 <bt_hci_cmd_complete_create>
   361ac:	2141      	movs	r1, #65	; 0x41
   361ae:	6020      	str	r0, [r4, #0]
   361b0:	3008      	adds	r0, #8
   361b2:	f018 fdff 	bl	4edb4 <net_buf_simple_add>
	rp->status = 0x00;
   361b6:	2100      	movs	r1, #0
   361b8:	4604      	mov	r4, r0
	(void)memset(&rp->commands[0], 0, sizeof(rp->commands));
   361ba:	2240      	movs	r2, #64	; 0x40
	rp->status = 0x00;
   361bc:	f800 1b01 	strb.w	r1, [r0], #1
	(void)memset(&rp->commands[0], 0, sizeof(rp->commands));
   361c0:	f014 fe66 	bl	4ae90 <memset>
	rp->commands[0] |= BIT(5) | BIT(7);
   361c4:	7862      	ldrb	r2, [r4, #1]
	rp->commands[1] |= BIT(0) | BIT(1);
   361c6:	78a3      	ldrb	r3, [r4, #2]
	rp->commands[0] |= BIT(5) | BIT(7);
   361c8:	f062 0258 	orn	r2, r2, #88	; 0x58
	rp->commands[1] |= BIT(0) | BIT(1);
   361cc:	f043 0303 	orr.w	r3, r3, #3
	rp->commands[0] |= BIT(5) | BIT(7);
   361d0:	7062      	strb	r2, [r4, #1]
	rp->commands[1] |= BIT(0) | BIT(1);
   361d2:	70a3      	strb	r3, [r4, #2]
}
   361d4:	e7e2      	b.n	3619c <hci_vendor_cmd_handle_common+0x58>
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
   361d6:	4b31      	ldr	r3, [pc, #196]	; (3629c <hci_vendor_cmd_handle_common+0x158>)
   361d8:	2109      	movs	r1, #9
   361da:	8818      	ldrh	r0, [r3, #0]
   361dc:	f015 fad8 	bl	4b790 <bt_hci_cmd_complete_create>
   361e0:	2109      	movs	r1, #9
   361e2:	6020      	str	r0, [r4, #0]
   361e4:	3008      	adds	r0, #8
   361e6:	f018 fde5 	bl	4edb4 <net_buf_simple_add>
	rp->status = 0x00;
   361ea:	2100      	movs	r1, #0
   361ec:	f800 1b01 	strb.w	r1, [r0], #1
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
   361f0:	2208      	movs	r2, #8
   361f2:	f014 fe4d 	bl	4ae90 <memset>
}
   361f6:	e7d1      	b.n	3619c <hci_vendor_cmd_handle_common+0x58>
	ll_addr_set(0, &cmd->bdaddr.val[0]);
   361f8:	6889      	ldr	r1, [r1, #8]
   361fa:	2000      	movs	r0, #0
   361fc:	f7ff fd04 	bl	35c08 <ll_addr_set>
	buf = bt_hci_cmd_complete_create(_opcode, sizeof(*ccst));
   36200:	4b26      	ldr	r3, [pc, #152]	; (3629c <hci_vendor_cmd_handle_common+0x158>)
   36202:	2101      	movs	r1, #1
   36204:	8818      	ldrh	r0, [r3, #0]
   36206:	f015 fac3 	bl	4b790 <bt_hci_cmd_complete_create>
   3620a:	2101      	movs	r1, #1
   3620c:	4605      	mov	r5, r0
   3620e:	3008      	adds	r0, #8
   36210:	f018 fdd0 	bl	4edb4 <net_buf_simple_add>
	ccst->status = status;
   36214:	2300      	movs	r3, #0
   36216:	7003      	strb	r3, [r0, #0]
	*evt = cmd_complete_status(0x00);
   36218:	6025      	str	r5, [r4, #0]
}
   3621a:	e7bf      	b.n	3619c <hci_vendor_cmd_handle_common+0x58>
	const char build_info[] = HCI_VS_BUILD_INFO;
   3621c:	4d20      	ldr	r5, [pc, #128]	; (362a0 <hci_vendor_cmd_handle_common+0x15c>)
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
   3621e:	4e1f      	ldr	r6, [pc, #124]	; (3629c <hci_vendor_cmd_handle_common+0x158>)
	const char build_info[] = HCI_VS_BUILD_INFO;
   36220:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   36222:	f10d 0c04 	add.w	ip, sp, #4
   36226:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
   3622a:	682b      	ldr	r3, [r5, #0]
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
   3622c:	8830      	ldrh	r0, [r6, #0]
	const char build_info[] = HCI_VS_BUILD_INFO;
   3622e:	f88c 3000 	strb.w	r3, [ip]
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
   36232:	2112      	movs	r1, #18
   36234:	f015 faac 	bl	4b790 <bt_hci_cmd_complete_create>
   36238:	2112      	movs	r1, #18
   3623a:	6020      	str	r0, [r4, #0]
   3623c:	3008      	adds	r0, #8
   3623e:	f018 fdb9 	bl	4edb4 <net_buf_simple_add>
	rp->status = 0x00;
   36242:	2300      	movs	r3, #0
   36244:	f800 3b01 	strb.w	r3, [r0], #1
	memcpy(rp->info, build_info, sizeof(build_info));
   36248:	2211      	movs	r2, #17
   3624a:	a901      	add	r1, sp, #4
   3624c:	f014 fe15 	bl	4ae7a <memcpy>
}
   36250:	e7a4      	b.n	3619c <hci_vendor_cmd_handle_common+0x58>
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
   36252:	4b12      	ldr	r3, [pc, #72]	; (3629c <hci_vendor_cmd_handle_common+0x158>)
   36254:	2118      	movs	r1, #24
   36256:	8818      	ldrh	r0, [r3, #0]
   36258:	f015 fa9a 	bl	4b790 <bt_hci_cmd_complete_create>
   3625c:	2118      	movs	r1, #24
   3625e:	6020      	str	r0, [r4, #0]
   36260:	3008      	adds	r0, #8
   36262:	f018 fda7 	bl	4edb4 <net_buf_simple_add>
	rp->status = 0x00;
   36266:	2300      	movs	r3, #0
   36268:	4604      	mov	r4, r0
	rp->num_addrs = hci_vendor_read_static_addr(rp->a, 1);
   3626a:	2101      	movs	r1, #1
	rp->status = 0x00;
   3626c:	f800 3b02 	strb.w	r3, [r0], #2
	rp->num_addrs = hci_vendor_read_static_addr(rp->a, 1);
   36270:	f00c f9ac 	bl	425cc <hci_vendor_read_static_addr>
   36274:	7060      	strb	r0, [r4, #1]
}
   36276:	e791      	b.n	3619c <hci_vendor_cmd_handle_common+0x58>
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
   36278:	4b08      	ldr	r3, [pc, #32]	; (3629c <hci_vendor_cmd_handle_common+0x158>)
   3627a:	2121      	movs	r1, #33	; 0x21
   3627c:	8818      	ldrh	r0, [r3, #0]
   3627e:	f015 fa87 	bl	4b790 <bt_hci_cmd_complete_create>
   36282:	2121      	movs	r1, #33	; 0x21
   36284:	6020      	str	r0, [r4, #0]
   36286:	3008      	adds	r0, #8
   36288:	f018 fd94 	bl	4edb4 <net_buf_simple_add>
	rp->status = 0x00;
   3628c:	4601      	mov	r1, r0
   3628e:	2300      	movs	r3, #0
   36290:	f801 3b11 	strb.w	r3, [r1], #17
	hci_vendor_read_key_hierarchy_roots(rp->ir, rp->er);
   36294:	3001      	adds	r0, #1
   36296:	f00c f9e9 	bl	4266c <hci_vendor_read_key_hierarchy_roots>
}
   3629a:	e77f      	b.n	3619c <hci_vendor_cmd_handle_common+0x58>
   3629c:	20006a2e 	.word	0x20006a2e
   362a0:	000521e8 	.word	0x000521e8

000362a4 <hci_cmd_handle>:
{
   362a4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (cmd->len < sizeof(*chdr)) {
   362a8:	8983      	ldrh	r3, [r0, #12]
{
   362aa:	b08e      	sub	sp, #56	; 0x38
	struct net_buf *evt = NULL;
   362ac:	2200      	movs	r2, #0
	if (cmd->len < sizeof(*chdr)) {
   362ae:	2b02      	cmp	r3, #2
	struct net_buf *evt = NULL;
   362b0:	9209      	str	r2, [sp, #36]	; 0x24
	if (cmd->len < sizeof(*chdr)) {
   362b2:	d92e      	bls.n	36312 <hci_cmd_handle+0x6e>
	return net_buf_simple_pull_mem(&buf->b, len);
   362b4:	4604      	mov	r4, r0
   362b6:	460e      	mov	r6, r1
   362b8:	3008      	adds	r0, #8
   362ba:	2103      	movs	r1, #3
   362bc:	f018 fdab 	bl	4ee16 <net_buf_simple_pull_mem>
	if (cmd->len < chdr->param_len) {
   362c0:	89a2      	ldrh	r2, [r4, #12]
   362c2:	7883      	ldrb	r3, [r0, #2]
   362c4:	429a      	cmp	r2, r3
   362c6:	d324      	bcc.n	36312 <hci_cmd_handle+0x6e>
	_opcode = sys_le16_to_cpu(chdr->opcode);
   362c8:	8802      	ldrh	r2, [r0, #0]
   362ca:	4fd5      	ldr	r7, [pc, #852]	; (36620 <hci_cmd_handle+0x37c>)
	switch (BT_OGF(_opcode)) {
   362cc:	f3c2 2385 	ubfx	r3, r2, #10, #6
   362d0:	2b08      	cmp	r3, #8
	_opcode = sys_le16_to_cpu(chdr->opcode);
   362d2:	b290      	uxth	r0, r2
   362d4:	803a      	strh	r2, [r7, #0]
	ocf = BT_OCF(_opcode);
   362d6:	f3c2 0509 	ubfx	r5, r2, #0, #10
	switch (BT_OGF(_opcode)) {
   362da:	d809      	bhi.n	362f0 <hci_cmd_handle+0x4c>
   362dc:	b19b      	cbz	r3, 36306 <hci_cmd_handle+0x62>
   362de:	3b01      	subs	r3, #1
   362e0:	2b07      	cmp	r3, #7
   362e2:	d810      	bhi.n	36306 <hci_cmd_handle+0x62>
   362e4:	e8df f003 	tbb	[pc, r3]
   362e8:	49260f1a 	.word	0x49260f1a
   362ec:	620f0f0f 	.word	0x620f0f0f
   362f0:	2b3f      	cmp	r3, #63	; 0x3f
   362f2:	d108      	bne.n	36306 <hci_cmd_handle+0x62>

/* Map vendor command handler directly to common implementation */
inline int hci_vendor_cmd_handle(uint16_t ocf, struct net_buf *cmd,
				 struct net_buf **evt)
{
	return hci_vendor_cmd_handle_common(ocf, cmd, evt);
   362f4:	aa09      	add	r2, sp, #36	; 0x24
   362f6:	4621      	mov	r1, r4
   362f8:	4628      	mov	r0, r5
   362fa:	f7ff ff23 	bl	36144 <hci_vendor_cmd_handle_common>
	if (err == -EINVAL) {
   362fe:	3016      	adds	r0, #22
   36300:	f040 83f1 	bne.w	36ae6 <hci_cmd_handle+0x842>
	return bt_hci_cmd_status_create(_opcode, status);
   36304:	8838      	ldrh	r0, [r7, #0]
   36306:	2101      	movs	r1, #1
}
   36308:	b00e      	add	sp, #56	; 0x38
   3630a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	return bt_hci_cmd_status_create(_opcode, status);
   3630e:	f015 ba51 	b.w	4b7b4 <bt_hci_cmd_status_create>
		return NULL;
   36312:	2400      	movs	r4, #0
}
   36314:	4620      	mov	r0, r4
   36316:	b00e      	add	sp, #56	; 0x38
   36318:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	switch (ocf) {
   3631c:	2d06      	cmp	r5, #6
   3631e:	f000 8398 	beq.w	36a52 <hci_cmd_handle+0x7ae>
   36322:	2d1d      	cmp	r5, #29
   36324:	d1ef      	bne.n	36306 <hci_cmd_handle+0x62>
	handle = sys_le16_to_cpu(cmd->handle);
   36326:	68a3      	ldr	r3, [r4, #8]
	status = ll_version_ind_send(handle);
   36328:	8818      	ldrh	r0, [r3, #0]
   3632a:	f004 f875 	bl	3a418 <ll_version_ind_send>
   3632e:	4601      	mov	r1, r0
	return bt_hci_cmd_status_create(_opcode, status);
   36330:	8838      	ldrh	r0, [r7, #0]
   36332:	e7e9      	b.n	36308 <hci_cmd_handle+0x64>
	switch (ocf) {
   36334:	2d63      	cmp	r5, #99	; 0x63
   36336:	f000 83bb 	beq.w	36ab0 <hci_cmd_handle+0x80c>
   3633a:	f200 80e7 	bhi.w	3650c <hci_cmd_handle+0x268>
   3633e:	2d03      	cmp	r5, #3
   36340:	f000 838f 	beq.w	36a62 <hci_cmd_handle+0x7be>
   36344:	2d2d      	cmp	r5, #45	; 0x2d
   36346:	f040 80cd 	bne.w	364e4 <hci_cmd_handle+0x240>
	struct bt_hci_cp_read_tx_power_level *cmd = (void *)buf->data;
   3634a:	68a3      	ldr	r3, [r4, #8]
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
   3634c:	2104      	movs	r1, #4
	handle = sys_le16_to_cpu(cmd->handle);
   3634e:	881e      	ldrh	r6, [r3, #0]
	type = cmd->type;
   36350:	f893 8002 	ldrb.w	r8, [r3, #2]
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
   36354:	f015 fa1c 	bl	4b790 <bt_hci_cmd_complete_create>
	return net_buf_simple_add(&buf->b, len);
   36358:	2104      	movs	r1, #4
   3635a:	4604      	mov	r4, r0
   3635c:	3008      	adds	r0, #8
   3635e:	f018 fd29 	bl	4edb4 <net_buf_simple_add>
	handle = sys_le16_to_cpu(cmd->handle);
   36362:	b2b7      	uxth	r7, r6
   36364:	4605      	mov	r5, r0
	status = ll_tx_pwr_lvl_get(BT_HCI_VS_LL_HANDLE_TYPE_CONN,
   36366:	1cc3      	adds	r3, r0, #3
   36368:	4642      	mov	r2, r8
   3636a:	4639      	mov	r1, r7
   3636c:	2002      	movs	r0, #2
   3636e:	f7ff fc9d 	bl	35cac <ll_tx_pwr_lvl_get>
	rp->handle = sys_cpu_to_le16(handle);
   36372:	f8a5 6001 	strh.w	r6, [r5, #1]
	rp->status = status;
   36376:	7028      	strb	r0, [r5, #0]
	if (err == -EINVAL) {
   36378:	e7cc      	b.n	36314 <hci_cmd_handle+0x70>
	switch (ocf) {
   3637a:	1e6a      	subs	r2, r5, #1
   3637c:	2a08      	cmp	r2, #8
   3637e:	d8c2      	bhi.n	36306 <hci_cmd_handle+0x62>
   36380:	a301      	add	r3, pc, #4	; (adr r3, 36388 <hci_cmd_handle+0xe4>)
   36382:	f853 f022 	ldr.w	pc, [r3, r2, lsl #2]
   36386:	bf00      	nop
   36388:	000365f7 	.word	0x000365f7
   3638c:	00036583 	.word	0x00036583
   36390:	0003655f 	.word	0x0003655f
   36394:	00036307 	.word	0x00036307
   36398:	00036307 	.word	0x00036307
   3639c:	00036307 	.word	0x00036307
   363a0:	00036307 	.word	0x00036307
   363a4:	00036307 	.word	0x00036307
   363a8:	00036541 	.word	0x00036541
	switch (ocf) {
   363ac:	1e6a      	subs	r2, r5, #1
   363ae:	2a4a      	cmp	r2, #74	; 0x4a
   363b0:	d8a9      	bhi.n	36306 <hci_cmd_handle+0x62>
   363b2:	a301      	add	r3, pc, #4	; (adr r3, 363b8 <hci_cmd_handle+0x114>)
   363b4:	f853 f022 	ldr.w	pc, [r3, r2, lsl #2]
   363b8:	00036655 	.word	0x00036655
   363bc:	00036635 	.word	0x00036635
   363c0:	0003685d 	.word	0x0003685d
   363c4:	00036307 	.word	0x00036307
   363c8:	00036853 	.word	0x00036853
   363cc:	00036837 	.word	0x00036837
   363d0:	0003681f 	.word	0x0003681f
   363d4:	00036813 	.word	0x00036813
   363d8:	00036807 	.word	0x00036807
   363dc:	000367fd 	.word	0x000367fd
   363e0:	000367e5 	.word	0x000367e5
   363e4:	00036a27 	.word	0x00036a27
   363e8:	000369f9 	.word	0x000369f9
   363ec:	000369f1 	.word	0x000369f1
   363f0:	00036307 	.word	0x00036307
   363f4:	00036307 	.word	0x00036307
   363f8:	00036307 	.word	0x00036307
   363fc:	00036307 	.word	0x00036307
   36400:	000369d1 	.word	0x000369d1
   36404:	000369c9 	.word	0x000369c9
   36408:	000369a3 	.word	0x000369a3
   3640c:	00036995 	.word	0x00036995
   36410:	00036965 	.word	0x00036965
   36414:	0003693b 	.word	0x0003693b
   36418:	00036923 	.word	0x00036923
   3641c:	00036919 	.word	0x00036919
   36420:	00036909 	.word	0x00036909
   36424:	000368eb 	.word	0x000368eb
   36428:	00036307 	.word	0x00036307
   3642c:	00036307 	.word	0x00036307
   36430:	00036307 	.word	0x00036307
   36434:	000368cd 	.word	0x000368cd
   36438:	000368b5 	.word	0x000368b5
   3643c:	000368a5 	.word	0x000368a5
   36440:	000367b3 	.word	0x000367b3
   36444:	000367a7 	.word	0x000367a7
   36448:	00036307 	.word	0x00036307
   3644c:	00036307 	.word	0x00036307
   36450:	00036307 	.word	0x00036307
   36454:	00036307 	.word	0x00036307
   36458:	00036307 	.word	0x00036307
   3645c:	00036307 	.word	0x00036307
   36460:	00036307 	.word	0x00036307
   36464:	00036307 	.word	0x00036307
   36468:	00036307 	.word	0x00036307
   3646c:	00036307 	.word	0x00036307
   36470:	0003675f 	.word	0x0003675f
   36474:	0003670b 	.word	0x0003670b
   36478:	000366d5 	.word	0x000366d5
   3647c:	00036681 	.word	0x00036681
   36480:	00036307 	.word	0x00036307
   36484:	00036307 	.word	0x00036307
   36488:	00036307 	.word	0x00036307
   3648c:	00036307 	.word	0x00036307
   36490:	00036307 	.word	0x00036307
   36494:	00036307 	.word	0x00036307
   36498:	00036307 	.word	0x00036307
   3649c:	00036307 	.word	0x00036307
   364a0:	00036307 	.word	0x00036307
   364a4:	00036307 	.word	0x00036307
   364a8:	00036307 	.word	0x00036307
   364ac:	00036307 	.word	0x00036307
   364b0:	00036307 	.word	0x00036307
   364b4:	00036307 	.word	0x00036307
   364b8:	00036307 	.word	0x00036307
   364bc:	00036307 	.word	0x00036307
   364c0:	00036307 	.word	0x00036307
   364c4:	00036307 	.word	0x00036307
   364c8:	00036307 	.word	0x00036307
   364cc:	00036307 	.word	0x00036307
   364d0:	00036307 	.word	0x00036307
   364d4:	00036307 	.word	0x00036307
   364d8:	00036307 	.word	0x00036307
   364dc:	00036307 	.word	0x00036307
   364e0:	00036661 	.word	0x00036661
	switch (ocf) {
   364e4:	2d01      	cmp	r5, #1
   364e6:	f47f af0e 	bne.w	36306 <hci_cmd_handle+0x62>
	return ((uint64_t)sys_get_le32(&src[4]) << 32) | sys_get_le32(&src[0]);
   364ea:	68a2      	ldr	r2, [r4, #8]
	event_mask = sys_get_le64(cmd->events);
   364ec:	4b4d      	ldr	r3, [pc, #308]	; (36624 <hci_cmd_handle+0x380>)
   364ee:	6811      	ldr	r1, [r2, #0]
   364f0:	6852      	ldr	r2, [r2, #4]
   364f2:	6019      	str	r1, [r3, #0]
	event_mask_page_2 = sys_get_le64(cmd->events_page_2);
   364f4:	605a      	str	r2, [r3, #4]
	buf = bt_hci_cmd_complete_create(_opcode, sizeof(*ccst));
   364f6:	2101      	movs	r1, #1
   364f8:	f015 f94a 	bl	4b790 <bt_hci_cmd_complete_create>
   364fc:	2101      	movs	r1, #1
   364fe:	4604      	mov	r4, r0
   36500:	3008      	adds	r0, #8
   36502:	f018 fc57 	bl	4edb4 <net_buf_simple_add>
	ccst->status = status;
   36506:	2300      	movs	r3, #0
   36508:	7003      	strb	r3, [r0, #0]
	if (err == -EINVAL) {
   3650a:	e703      	b.n	36314 <hci_cmd_handle+0x70>
	switch (ocf) {
   3650c:	2d7b      	cmp	r5, #123	; 0x7b
   3650e:	f000 82d2 	beq.w	36ab6 <hci_cmd_handle+0x812>
   36512:	2d7c      	cmp	r5, #124	; 0x7c
   36514:	f47f aef7 	bne.w	36306 <hci_cmd_handle+0x62>
	struct bt_hci_cp_write_auth_payload_timeout *cmd = (void *)buf->data;
   36518:	68a3      	ldr	r3, [r4, #8]
	handle = sys_le16_to_cpu(cmd->handle);
   3651a:	881e      	ldrh	r6, [r3, #0]
	status = ll_apto_set(handle, auth_payload_timeout);
   3651c:	8859      	ldrh	r1, [r3, #2]
   3651e:	b2b0      	uxth	r0, r6
   36520:	f004 f8c4 	bl	3a6ac <ll_apto_set>
	status = ll_start_enc_req_send(handle, 0x00, &cmd->ltk[0]);
   36524:	4605      	mov	r5, r0
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
   36526:	2103      	movs	r1, #3
   36528:	8838      	ldrh	r0, [r7, #0]
   3652a:	f015 f931 	bl	4b790 <bt_hci_cmd_complete_create>
   3652e:	2103      	movs	r1, #3
   36530:	4604      	mov	r4, r0
   36532:	3008      	adds	r0, #8
   36534:	f018 fc3e 	bl	4edb4 <net_buf_simple_add>
	rp->status = status;
   36538:	7005      	strb	r5, [r0, #0]
	rp->handle = sys_cpu_to_le16(handle);
   3653a:	f8a0 6001 	strh.w	r6, [r0, #1]
	if (err == -EINVAL) {
   3653e:	e6e9      	b.n	36314 <hci_cmd_handle+0x70>
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
   36540:	2107      	movs	r1, #7
   36542:	f015 f925 	bl	4b790 <bt_hci_cmd_complete_create>
   36546:	2107      	movs	r1, #7
   36548:	4604      	mov	r4, r0
   3654a:	3008      	adds	r0, #8
   3654c:	f018 fc32 	bl	4edb4 <net_buf_simple_add>
	rp->status = 0x00;
   36550:	4601      	mov	r1, r0
   36552:	2000      	movs	r0, #0
   36554:	f801 0b01 	strb.w	r0, [r1], #1
	(void)ll_addr_read(0, &rp->bdaddr.val[0]);
   36558:	f7ff fb90 	bl	35c7c <ll_addr_read>
	if (err == -EINVAL) {
   3655c:	e6da      	b.n	36314 <hci_cmd_handle+0x70>
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
   3655e:	2109      	movs	r1, #9
   36560:	f015 f916 	bl	4b790 <bt_hci_cmd_complete_create>
   36564:	2109      	movs	r1, #9
   36566:	4604      	mov	r4, r0
   36568:	3008      	adds	r0, #8
   3656a:	f018 fc23 	bl	4edb4 <net_buf_simple_add>
	rp->status = 0x00;
   3656e:	2100      	movs	r1, #0
   36570:	4605      	mov	r5, r0
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
   36572:	2208      	movs	r2, #8
	rp->status = 0x00;
   36574:	f800 1b01 	strb.w	r1, [r0], #1
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
   36578:	f014 fc8a 	bl	4ae90 <memset>
	rp->features[4] = (1 << 5) | (1 << 6);
   3657c:	2360      	movs	r3, #96	; 0x60
   3657e:	716b      	strb	r3, [r5, #5]
	if (err == -EINVAL) {
   36580:	e6c8      	b.n	36314 <hci_cmd_handle+0x70>
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
   36582:	2141      	movs	r1, #65	; 0x41
   36584:	f015 f904 	bl	4b790 <bt_hci_cmd_complete_create>
   36588:	2141      	movs	r1, #65	; 0x41
   3658a:	4604      	mov	r4, r0
   3658c:	3008      	adds	r0, #8
   3658e:	f018 fc11 	bl	4edb4 <net_buf_simple_add>
	rp->status = 0x00;
   36592:	2100      	movs	r1, #0
   36594:	4605      	mov	r5, r0
	(void)memset(&rp->commands[0], 0, sizeof(rp->commands));
   36596:	2240      	movs	r2, #64	; 0x40
	rp->status = 0x00;
   36598:	f800 1b01 	strb.w	r1, [r0], #1
	(void)memset(&rp->commands[0], 0, sizeof(rp->commands));
   3659c:	f014 fc78 	bl	4ae90 <memset>
	rp->commands[10] |= BIT(2);
   365a0:	7aeb      	ldrb	r3, [r5, #11]
	rp->commands[5] |= BIT(6) | BIT(7);
   365a2:	79a9      	ldrb	r1, [r5, #6]
	rp->commands[14] |= BIT(3) | BIT(5);
   365a4:	7bea      	ldrb	r2, [r5, #15]
	rp->commands[25] |= BIT(0) | BIT(1) | BIT(2) | BIT(4);
   365a6:	f8d5 001a 	ldr.w	r0, [r5, #26]
	rp->commands[10] |= BIT(2);
   365aa:	f043 0304 	orr.w	r3, r3, #4
   365ae:	72eb      	strb	r3, [r5, #11]
	rp->commands[15] |= BIT(1);
   365b0:	7c2b      	ldrb	r3, [r5, #16]
	rp->commands[5] |= BIT(6) | BIT(7);
   365b2:	f061 013f 	orn	r1, r1, #63	; 0x3f
	rp->commands[14] |= BIT(3) | BIT(5);
   365b6:	f042 0228 	orr.w	r2, r2, #40	; 0x28
	rp->commands[15] |= BIT(1);
   365ba:	f043 0302 	orr.w	r3, r3, #2
	rp->commands[5] |= BIT(6) | BIT(7);
   365be:	71a9      	strb	r1, [r5, #6]
	rp->commands[14] |= BIT(3) | BIT(5);
   365c0:	73ea      	strb	r2, [r5, #15]
	rp->commands[22] |= BIT(2);
   365c2:	7de9      	ldrb	r1, [r5, #23]
	rp->commands[0] |= BIT(5);
   365c4:	786a      	ldrb	r2, [r5, #1]
	rp->commands[15] |= BIT(1);
   365c6:	742b      	strb	r3, [r5, #16]
	rp->commands[25] |= BIT(5) | BIT(6) | BIT(7);
   365c8:	4b17      	ldr	r3, [pc, #92]	; (36628 <hci_cmd_handle+0x384>)
	rp->commands[22] |= BIT(2);
   365ca:	f041 0104 	orr.w	r1, r1, #4
	rp->commands[25] |= BIT(5) | BIT(6) | BIT(7);
   365ce:	4303      	orrs	r3, r0
	rp->commands[0] |= BIT(5);
   365d0:	f042 0220 	orr.w	r2, r2, #32
	rp->commands[22] |= BIT(2);
   365d4:	75e9      	strb	r1, [r5, #23]
	rp->commands[0] |= BIT(5);
   365d6:	706a      	strb	r2, [r5, #1]
	rp->commands[32] |= BIT(4) | BIT(5);
   365d8:	f8d5 1021 	ldr.w	r1, [r5, #33]	; 0x21
   365dc:	4a13      	ldr	r2, [pc, #76]	; (3662c <hci_cmd_handle+0x388>)
	rp->commands[25] |= BIT(5) | BIT(6) | BIT(7);
   365de:	f8c5 301a 	str.w	r3, [r5, #26]
	rp->commands[38] |= BIT(7);
   365e2:	f895 3027 	ldrb.w	r3, [r5, #39]	; 0x27
	rp->commands[32] |= BIT(4) | BIT(5);
   365e6:	430a      	orrs	r2, r1
	rp->commands[38] |= BIT(7);
   365e8:	f063 037f 	orn	r3, r3, #127	; 0x7f
	rp->commands[32] |= BIT(4) | BIT(5);
   365ec:	f8c5 2021 	str.w	r2, [r5, #33]	; 0x21
	rp->commands[38] |= BIT(7);
   365f0:	f885 3027 	strb.w	r3, [r5, #39]	; 0x27
	if (err == -EINVAL) {
   365f4:	e68e      	b.n	36314 <hci_cmd_handle+0x70>
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
   365f6:	2109      	movs	r1, #9
   365f8:	f015 f8ca 	bl	4b790 <bt_hci_cmd_complete_create>
   365fc:	2109      	movs	r1, #9
   365fe:	4604      	mov	r4, r0
   36600:	3008      	adds	r0, #8
   36602:	f018 fbd7 	bl	4edb4 <net_buf_simple_add>
	rp->status = 0x00;
   36606:	f44f 6140 	mov.w	r1, #3072	; 0xc00
	rp->hci_revision = sys_cpu_to_le16(0);
   3660a:	2300      	movs	r3, #0
	rp->manufacturer = sys_cpu_to_le16(ll_settings_company_id());
   3660c:	4a08      	ldr	r2, [pc, #32]	; (36630 <hci_cmd_handle+0x38c>)
	rp->status = 0x00;
   3660e:	8001      	strh	r1, [r0, #0]
	rp->lmp_version = LL_VERSION_NUMBER;
   36610:	210c      	movs	r1, #12
	rp->hci_revision = sys_cpu_to_le16(0);
   36612:	7083      	strb	r3, [r0, #2]
   36614:	70c3      	strb	r3, [r0, #3]
	rp->lmp_version = LL_VERSION_NUMBER;
   36616:	7101      	strb	r1, [r0, #4]
	rp->manufacturer = sys_cpu_to_le16(ll_settings_company_id());
   36618:	f8c0 2005 	str.w	r2, [r0, #5]
	if (err == -EINVAL) {
   3661c:	e67a      	b.n	36314 <hci_cmd_handle+0x70>
   3661e:	bf00      	nop
   36620:	20006a2e 	.word	0x20006a2e
   36624:	20000190 	.word	0x20000190
   36628:	0ffc3ff7 	.word	0x0ffc3ff7
   3662c:	7801f030 	.word	0x7801f030
   36630:	ffff05f1 	.word	0xffff05f1
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
   36634:	2104      	movs	r1, #4
   36636:	f015 f8ab 	bl	4b790 <bt_hci_cmd_complete_create>
   3663a:	2104      	movs	r1, #4
   3663c:	4604      	mov	r4, r0
   3663e:	3008      	adds	r0, #8
   36640:	f018 fbb8 	bl	4edb4 <net_buf_simple_add>
	rp->status = 0x00;
   36644:	2300      	movs	r3, #0
	rp->le_max_len = sys_cpu_to_le16(LL_LENGTH_OCTETS_TX_MAX);
   36646:	211b      	movs	r1, #27
	rp->le_max_num = CONFIG_BT_BUF_ACL_TX_COUNT;
   36648:	2203      	movs	r2, #3
	rp->status = 0x00;
   3664a:	7003      	strb	r3, [r0, #0]
	rp->le_max_len = sys_cpu_to_le16(LL_LENGTH_OCTETS_TX_MAX);
   3664c:	7041      	strb	r1, [r0, #1]
   3664e:	7083      	strb	r3, [r0, #2]
	rp->le_max_num = CONFIG_BT_BUF_ACL_TX_COUNT;
   36650:	70c2      	strb	r2, [r0, #3]
	if (err == -EINVAL) {
   36652:	e65f      	b.n	36314 <hci_cmd_handle+0x70>
   36654:	68a2      	ldr	r2, [r4, #8]
	le_event_mask = sys_get_le64(cmd->events);
   36656:	4bc0      	ldr	r3, [pc, #768]	; (36958 <hci_cmd_handle+0x6b4>)
   36658:	6811      	ldr	r1, [r2, #0]
   3665a:	6852      	ldr	r2, [r2, #4]
	event_mask_page_2 = sys_get_le64(cmd->events_page_2);
   3665c:	6019      	str	r1, [r3, #0]
   3665e:	e749      	b.n	364f4 <hci_cmd_handle+0x250>
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
   36660:	2103      	movs	r1, #3
   36662:	f015 f895 	bl	4b790 <bt_hci_cmd_complete_create>
   36666:	2103      	movs	r1, #3
   36668:	4604      	mov	r4, r0
   3666a:	3008      	adds	r0, #8
   3666c:	f018 fba2 	bl	4edb4 <net_buf_simple_add>
	rp->status = 0x00;
   36670:	4601      	mov	r1, r0
   36672:	2300      	movs	r3, #0
   36674:	f801 3b02 	strb.w	r3, [r1], #2
	ll_tx_pwr_get(&rp->min_tx_power, &rp->max_tx_power);
   36678:	3001      	adds	r0, #1
   3667a:	f7ff fb27 	bl	35ccc <ll_tx_pwr_get>
	if (err == -EINVAL) {
   3667e:	e649      	b.n	36314 <hci_cmd_handle+0x70>
	struct bt_hci_cp_le_set_phy *cmd = (void *)buf->data;
   36680:	68a2      	ldr	r2, [r4, #8]
	if (cmd->all_phys & BT_HCI_LE_PHY_TX_ANY) {
   36682:	7895      	ldrb	r5, [r2, #2]
	return ((uint16_t)src[1] << 8) | src[0];
   36684:	78d1      	ldrb	r1, [r2, #3]
	handle = sys_le16_to_cpu(cmd->handle);
   36686:	8816      	ldrh	r6, [r2, #0]
	phy_opts = sys_le16_to_cpu(cmd->phy_opts);
   36688:	f8b2 4005 	ldrh.w	r4, [r2, #5]
	if (cmd->all_phys & BT_HCI_LE_PHY_TX_ANY) {
   3668c:	07eb      	lsls	r3, r5, #31
		cmd->tx_phys |= mask_phys;
   3668e:	bf48      	it	mi
   36690:	f041 0103 	orrmi.w	r1, r1, #3
		cmd->rx_phys |= mask_phys;
   36694:	7913      	ldrb	r3, [r2, #4]
		cmd->tx_phys |= mask_phys;
   36696:	bf48      	it	mi
   36698:	70d1      	strbmi	r1, [r2, #3]
	if (cmd->all_phys & BT_HCI_LE_PHY_RX_ANY) {
   3669a:	07ad      	lsls	r5, r5, #30
		cmd->rx_phys |= mask_phys;
   3669c:	bf44      	itt	mi
   3669e:	f043 0303 	orrmi.w	r3, r3, #3
   366a2:	7113      	strbmi	r3, [r2, #4]
	if ((cmd->tx_phys | cmd->rx_phys) & ~mask_phys) {
   366a4:	ea43 0201 	orr.w	r2, r3, r1
   366a8:	2a03      	cmp	r2, #3
   366aa:	f200 8223 	bhi.w	36af4 <hci_cmd_handle+0x850>
	if (!(cmd->tx_phys & 0x07) ||
   366ae:	074d      	lsls	r5, r1, #29
   366b0:	f000 821e 	beq.w	36af0 <hci_cmd_handle+0x84c>
   366b4:	075a      	lsls	r2, r3, #29
   366b6:	f000 821b 	beq.w	36af0 <hci_cmd_handle+0x84c>
	if (phy_opts & 0x03) {
   366ba:	f014 0203 	ands.w	r2, r4, #3
		phy_opts -= 1U;
   366be:	bf1c      	itt	ne
   366c0:	f104 34ff 	addne.w	r4, r4, #4294967295	; 0xffffffff
		phy_opts &= 1;
   366c4:	f004 0201 	andne.w	r2, r4, #1
	status = ll_phy_req_send(handle, cmd->tx_phys, phy_opts,
   366c8:	4630      	mov	r0, r6
   366ca:	f003 ff73 	bl	3a5b4 <ll_phy_req_send>
   366ce:	4601      	mov	r1, r0
	return bt_hci_cmd_status_create(_opcode, status);
   366d0:	8838      	ldrh	r0, [r7, #0]
   366d2:	e619      	b.n	36308 <hci_cmd_handle+0x64>
	struct bt_hci_cp_le_set_default_phy *cmd = (void *)buf->data;
   366d4:	68a3      	ldr	r3, [r4, #8]
	if (cmd->all_phys & BT_HCI_LE_PHY_TX_ANY) {
   366d6:	781a      	ldrb	r2, [r3, #0]
   366d8:	07d1      	lsls	r1, r2, #31
		cmd->tx_phys = 0x07;
   366da:	bf44      	itt	mi
   366dc:	2107      	movmi	r1, #7
   366de:	7059      	strbmi	r1, [r3, #1]
	if (cmd->all_phys & BT_HCI_LE_PHY_RX_ANY) {
   366e0:	0792      	lsls	r2, r2, #30
		cmd->rx_phys = 0x07;
   366e2:	bf4c      	ite	mi
   366e4:	2107      	movmi	r1, #7
	status = ll_phy_default_set(cmd->tx_phys, cmd->rx_phys);
   366e6:	7899      	ldrbpl	r1, [r3, #2]
   366e8:	7858      	ldrb	r0, [r3, #1]
		cmd->rx_phys = 0x07;
   366ea:	bf48      	it	mi
   366ec:	7099      	strbmi	r1, [r3, #2]
	status = ll_phy_default_set(cmd->tx_phys, cmd->rx_phys);
   366ee:	f003 ff57 	bl	3a5a0 <ll_phy_default_set>
   366f2:	4605      	mov	r5, r0
	buf = bt_hci_cmd_complete_create(_opcode, sizeof(*ccst));
   366f4:	8838      	ldrh	r0, [r7, #0]
   366f6:	2101      	movs	r1, #1
   366f8:	f015 f84a 	bl	4b790 <bt_hci_cmd_complete_create>
   366fc:	2101      	movs	r1, #1
   366fe:	4604      	mov	r4, r0
   36700:	3008      	adds	r0, #8
   36702:	f018 fb57 	bl	4edb4 <net_buf_simple_add>
	ccst->status = status;
   36706:	7005      	strb	r5, [r0, #0]
	if (err == -EINVAL) {
   36708:	e604      	b.n	36314 <hci_cmd_handle+0x70>
	handle = sys_le16_to_cpu(cmd->handle);
   3670a:	68a3      	ldr	r3, [r4, #8]
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
   3670c:	2105      	movs	r1, #5
	handle = sys_le16_to_cpu(cmd->handle);
   3670e:	881e      	ldrh	r6, [r3, #0]
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
   36710:	f015 f83e 	bl	4b790 <bt_hci_cmd_complete_create>
   36714:	2105      	movs	r1, #5
   36716:	4604      	mov	r4, r0
   36718:	3008      	adds	r0, #8
   3671a:	f018 fb4b 	bl	4edb4 <net_buf_simple_add>
   3671e:	4605      	mov	r5, r0
	status = ll_phy_get(handle, &rp->tx_phy, &rp->rx_phy);
   36720:	1d2a      	adds	r2, r5, #4
	handle = sys_le16_to_cpu(cmd->handle);
   36722:	b2b0      	uxth	r0, r6
	status = ll_phy_get(handle, &rp->tx_phy, &rp->rx_phy);
   36724:	1ce9      	adds	r1, r5, #3
   36726:	f003 ff19 	bl	3a55c <ll_phy_get>
 */

static ALWAYS_INLINE unsigned int find_lsb_set(uint32_t op)
{
#ifdef CONFIG_TOOLCHAIN_HAS_BUILTIN_FFS
	return __builtin_ffs(op);
   3672a:	78eb      	ldrb	r3, [r5, #3]
   3672c:	792a      	ldrb	r2, [r5, #4]
	rp->status = status;
   3672e:	7028      	strb	r0, [r5, #0]
   36730:	2b00      	cmp	r3, #0
   36732:	fa93 f3a3 	rbit	r3, r3
   36736:	fab3 f383 	clz	r3, r3
   3673a:	bf08      	it	eq
   3673c:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff
   36740:	3301      	adds	r3, #1
	rp->tx_phy = find_lsb_set(rp->tx_phy);
   36742:	70eb      	strb	r3, [r5, #3]
   36744:	2a00      	cmp	r2, #0
   36746:	fa92 f3a2 	rbit	r3, r2
   3674a:	fab3 f383 	clz	r3, r3
   3674e:	bf08      	it	eq
   36750:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff
   36754:	3301      	adds	r3, #1
	rp->handle = sys_cpu_to_le16(handle);
   36756:	f8a5 6001 	strh.w	r6, [r5, #1]
	rp->rx_phy = find_lsb_set(rp->rx_phy);
   3675a:	712b      	strb	r3, [r5, #4]
	if (err == -EINVAL) {
   3675c:	e5da      	b.n	36314 <hci_cmd_handle+0x70>
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
   3675e:	2109      	movs	r1, #9
   36760:	f015 f816 	bl	4b790 <bt_hci_cmd_complete_create>
   36764:	2109      	movs	r1, #9
   36766:	4604      	mov	r4, r0
   36768:	3008      	adds	r0, #8
   3676a:	f018 fb23 	bl	4edb4 <net_buf_simple_add>
	ll_length_max_get(&max_tx_octets, &max_tx_time,
   3676e:	ab0a      	add	r3, sp, #40	; 0x28
   36770:	4605      	mov	r5, r0
   36772:	f10d 0222 	add.w	r2, sp, #34	; 0x22
   36776:	a908      	add	r1, sp, #32
   36778:	f10d 001e 	add.w	r0, sp, #30
   3677c:	f003 fee2 	bl	3a544 <ll_length_max_get>
	rp->max_tx_octets = sys_cpu_to_le16(max_tx_octets);
   36780:	f8bd 301e 	ldrh.w	r3, [sp, #30]
   36784:	f8a5 3001 	strh.w	r3, [r5, #1]
	rp->max_tx_time = sys_cpu_to_le16(max_tx_time);
   36788:	f8bd 3020 	ldrh.w	r3, [sp, #32]
   3678c:	f8a5 3003 	strh.w	r3, [r5, #3]
	rp->max_rx_octets = sys_cpu_to_le16(max_rx_octets);
   36790:	f8bd 3022 	ldrh.w	r3, [sp, #34]	; 0x22
   36794:	f8a5 3005 	strh.w	r3, [r5, #5]
	rp->max_rx_time = sys_cpu_to_le16(max_rx_time);
   36798:	f8bd 2028 	ldrh.w	r2, [sp, #40]	; 0x28
   3679c:	f8a5 2007 	strh.w	r2, [r5, #7]
	rp->status = 0x00;
   367a0:	2300      	movs	r3, #0
   367a2:	702b      	strb	r3, [r5, #0]
	if (err == -EINVAL) {
   367a4:	e5b6      	b.n	36314 <hci_cmd_handle+0x70>
	struct bt_hci_cp_le_write_default_data_len *cmd = (void *)buf->data;
   367a6:	68a3      	ldr	r3, [r4, #8]
	status = ll_length_default_set(max_tx_octets, max_tx_time);
   367a8:	8859      	ldrh	r1, [r3, #2]
   367aa:	8818      	ldrh	r0, [r3, #0]
   367ac:	f003 fec0 	bl	3a530 <ll_length_default_set>
   367b0:	e79f      	b.n	366f2 <hci_cmd_handle+0x44e>
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
   367b2:	2105      	movs	r1, #5
   367b4:	f014 ffec 	bl	4b790 <bt_hci_cmd_complete_create>
   367b8:	2105      	movs	r1, #5
   367ba:	4604      	mov	r4, r0
   367bc:	3008      	adds	r0, #8
   367be:	f018 faf9 	bl	4edb4 <net_buf_simple_add>
	ll_length_default_get(&max_tx_octets, &max_tx_time);
   367c2:	a90a      	add	r1, sp, #40	; 0x28
   367c4:	4605      	mov	r5, r0
   367c6:	f10d 0022 	add.w	r0, sp, #34	; 0x22
   367ca:	f003 fea5 	bl	3a518 <ll_length_default_get>
	rp->max_tx_octets = sys_cpu_to_le16(max_tx_octets);
   367ce:	f8bd 3022 	ldrh.w	r3, [sp, #34]	; 0x22
   367d2:	f8a5 3001 	strh.w	r3, [r5, #1]
	rp->max_tx_time = sys_cpu_to_le16(max_tx_time);
   367d6:	f8bd 2028 	ldrh.w	r2, [sp, #40]	; 0x28
   367da:	f8a5 2003 	strh.w	r2, [r5, #3]
	rp->status = 0x00;
   367de:	2300      	movs	r3, #0
   367e0:	702b      	strb	r3, [r5, #0]
	if (err == -EINVAL) {
   367e2:	e597      	b.n	36314 <hci_cmd_handle+0x70>
	struct bt_hci_cp_le_set_scan_param *cmd = (void *)buf->data;
   367e4:	68a4      	ldr	r4, [r4, #8]
	status = ll_scan_params_set(cmd->scan_type, interval, window,
   367e6:	7963      	ldrb	r3, [r4, #5]
   367e8:	f8b4 2003 	ldrh.w	r2, [r4, #3]
   367ec:	f8b4 1001 	ldrh.w	r1, [r4, #1]
   367f0:	7820      	ldrb	r0, [r4, #0]
   367f2:	79a4      	ldrb	r4, [r4, #6]
   367f4:	9400      	str	r4, [sp, #0]
   367f6:	f7f0 fac3 	bl	26d80 <ll_scan_params_set>
   367fa:	e77a      	b.n	366f2 <hci_cmd_handle+0x44e>
	status = ll_adv_enable(cmd->enable);
   367fc:	68a3      	ldr	r3, [r4, #8]
   367fe:	7818      	ldrb	r0, [r3, #0]
   36800:	f7f0 f83a 	bl	26878 <ll_adv_enable>
   36804:	e775      	b.n	366f2 <hci_cmd_handle+0x44e>
	status = ll_adv_scan_rsp_set(cmd->len, &cmd->data[0]);
   36806:	68a1      	ldr	r1, [r4, #8]
   36808:	f811 0b01 	ldrb.w	r0, [r1], #1
   3680c:	f002 fcaa 	bl	39164 <ll_adv_scan_rsp_set>
   36810:	e76f      	b.n	366f2 <hci_cmd_handle+0x44e>
	status = ll_adv_data_set(cmd->len, &cmd->data[0]);
   36812:	68a1      	ldr	r1, [r4, #8]
   36814:	f811 0b01 	ldrb.w	r0, [r1], #1
   36818:	f002 fc4e 	bl	390b8 <ll_adv_data_set>
   3681c:	e769      	b.n	366f2 <hci_cmd_handle+0x44e>
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
   3681e:	2102      	movs	r1, #2
   36820:	f014 ffb6 	bl	4b790 <bt_hci_cmd_complete_create>
   36824:	2102      	movs	r1, #2
   36826:	4604      	mov	r4, r0
   36828:	3008      	adds	r0, #8
   3682a:	f018 fac3 	bl	4edb4 <net_buf_simple_add>
	rp->status = 0x00;
   3682e:	2300      	movs	r3, #0
   36830:	7003      	strb	r3, [r0, #0]
	rp->tx_power_level = 0;
   36832:	7043      	strb	r3, [r0, #1]
	if (err == -EINVAL) {
   36834:	e56e      	b.n	36314 <hci_cmd_handle+0x70>
	struct bt_hci_cp_le_set_adv_param *cmd = (void *)buf->data;
   36836:	68a4      	ldr	r4, [r4, #8]
	status = ll_adv_params_set(min_interval, cmd->type,
   36838:	7ba5      	ldrb	r5, [r4, #14]
   3683a:	79a3      	ldrb	r3, [r4, #6]
   3683c:	7962      	ldrb	r2, [r4, #5]
   3683e:	7921      	ldrb	r1, [r4, #4]
   36840:	8820      	ldrh	r0, [r4, #0]
   36842:	9502      	str	r5, [sp, #8]
   36844:	7b65      	ldrb	r5, [r4, #13]
   36846:	9501      	str	r5, [sp, #4]
				   &cmd->direct_addr.a.val[0], cmd->channel_map,
   36848:	3407      	adds	r4, #7
	status = ll_adv_params_set(min_interval, cmd->type,
   3684a:	9400      	str	r4, [sp, #0]
   3684c:	f002 fa96 	bl	38d7c <ll_adv_params_set>
   36850:	e74f      	b.n	366f2 <hci_cmd_handle+0x44e>
	status = ll_addr_set(1, &cmd->bdaddr.val[0]);
   36852:	68a1      	ldr	r1, [r4, #8]
   36854:	2001      	movs	r0, #1
   36856:	f7ff f9d7 	bl	35c08 <ll_addr_set>
   3685a:	e74a      	b.n	366f2 <hci_cmd_handle+0x44e>
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
   3685c:	2109      	movs	r1, #9
   3685e:	f014 ff97 	bl	4b790 <bt_hci_cmd_complete_create>
   36862:	2109      	movs	r1, #9
   36864:	4604      	mov	r4, r0
   36866:	3008      	adds	r0, #8
   36868:	f018 faa4 	bl	4edb4 <net_buf_simple_add>
	rp->status = 0x00;
   3686c:	2500      	movs	r5, #0
   3686e:	4606      	mov	r6, r0
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
   36870:	2208      	movs	r2, #8
   36872:	4629      	mov	r1, r5
	rp->status = 0x00;
   36874:	f800 5b01 	strb.w	r5, [r0], #1
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
   36878:	f014 fb0a 	bl	4ae90 <memset>
	sys_put_le64(ll_feat_get(), rp->features);
   3687c:	f000 fdaa 	bl	373d4 <ll_feat_get>
	dst[0] = val;
   36880:	462b      	mov	r3, r5
   36882:	f361 0307 	bfi	r3, r1, #0, #8
	dst[1] = val >> 8;
   36886:	f3c1 2207 	ubfx	r2, r1, #8, #8
	dst[0] = val;
   3688a:	f362 230f 	bfi	r3, r2, #8, #8
	sys_put_le16(val >> 16, &dst[2]);
   3688e:	0c09      	lsrs	r1, r1, #16
	dst[0] = val;
   36890:	f361 4317 	bfi	r3, r1, #16, #8
	dst[1] = val >> 8;
   36894:	0a09      	lsrs	r1, r1, #8
	dst[0] = val;
   36896:	f361 631f 	bfi	r3, r1, #24, #8
   3689a:	f8c6 0001 	str.w	r0, [r6, #1]
   3689e:	f8c6 3005 	str.w	r3, [r6, #5]
	if (err == -EINVAL) {
   368a2:	e537      	b.n	36314 <hci_cmd_handle+0x70>
	struct bt_hci_cp_le_set_data_len *cmd = (void *)buf->data;
   368a4:	68a3      	ldr	r3, [r4, #8]
	handle = sys_le16_to_cpu(cmd->handle);
   368a6:	881e      	ldrh	r6, [r3, #0]
	status = ll_length_req_send(handle, tx_octets, tx_time);
   368a8:	889a      	ldrh	r2, [r3, #4]
   368aa:	8859      	ldrh	r1, [r3, #2]
   368ac:	b2b0      	uxth	r0, r6
   368ae:	f003 fddb 	bl	3a468 <ll_length_req_send>
   368b2:	e637      	b.n	36524 <hci_cmd_handle+0x280>
	struct bt_hci_cp_le_conn_param_req_neg_reply *cmd = (void *)buf->data;
   368b4:	68a2      	ldr	r2, [r4, #8]
	handle = sys_le16_to_cpu(cmd->handle);
   368b6:	8816      	ldrh	r6, [r2, #0]
	status = ll_conn_update(handle, 2, cmd->reason, 0, 0, 0, 0);
   368b8:	7892      	ldrb	r2, [r2, #2]
   368ba:	2300      	movs	r3, #0
   368bc:	e9cd 3301 	strd	r3, r3, [sp, #4]
   368c0:	9300      	str	r3, [sp, #0]
   368c2:	2102      	movs	r1, #2
   368c4:	b2b0      	uxth	r0, r6
   368c6:	f003 fc7f 	bl	3a1c8 <ll_conn_update>
   368ca:	e62b      	b.n	36524 <hci_cmd_handle+0x280>
	struct bt_hci_cp_le_conn_param_req_reply *cmd = (void *)buf->data;
   368cc:	68a2      	ldr	r2, [r4, #8]
	status = ll_conn_update(handle, 2, 0, interval_min, interval_max,
   368ce:	8911      	ldrh	r1, [r2, #8]
	handle = sys_le16_to_cpu(cmd->handle);
   368d0:	8816      	ldrh	r6, [r2, #0]
	status = ll_conn_update(handle, 2, 0, interval_min, interval_max,
   368d2:	8853      	ldrh	r3, [r2, #2]
   368d4:	9102      	str	r1, [sp, #8]
   368d6:	88d1      	ldrh	r1, [r2, #6]
   368d8:	9101      	str	r1, [sp, #4]
   368da:	8891      	ldrh	r1, [r2, #4]
   368dc:	9100      	str	r1, [sp, #0]
   368de:	2200      	movs	r2, #0
   368e0:	2102      	movs	r1, #2
   368e2:	b2b0      	uxth	r0, r6
   368e4:	f003 fc70 	bl	3a1c8 <ll_conn_update>
   368e8:	e61c      	b.n	36524 <hci_cmd_handle+0x280>
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
   368ea:	2109      	movs	r1, #9
   368ec:	f014 ff50 	bl	4b790 <bt_hci_cmd_complete_create>
   368f0:	2109      	movs	r1, #9
   368f2:	4604      	mov	r4, r0
   368f4:	3008      	adds	r0, #8
   368f6:	f018 fa5d 	bl	4edb4 <net_buf_simple_add>
	rp->status = 0x00;
   368fa:	4918      	ldr	r1, [pc, #96]	; (3695c <hci_cmd_handle+0x6b8>)
   368fc:	4a18      	ldr	r2, [pc, #96]	; (36960 <hci_cmd_handle+0x6bc>)
   368fe:	6001      	str	r1, [r0, #0]
	dst[1] = val >> 8;
   36900:	2300      	movs	r3, #0
   36902:	6042      	str	r2, [r0, #4]
   36904:	7203      	strb	r3, [r0, #8]
	if (err == -EINVAL) {
   36906:	e505      	b.n	36314 <hci_cmd_handle+0x70>
	handle = sys_le16_to_cpu(cmd->handle);
   36908:	68a3      	ldr	r3, [r4, #8]
   3690a:	881e      	ldrh	r6, [r3, #0]
	status = ll_start_enc_req_send(handle, BT_HCI_ERR_PIN_OR_KEY_MISSING,
   3690c:	2200      	movs	r2, #0
   3690e:	2106      	movs	r1, #6
	status = ll_start_enc_req_send(handle, 0x00, &cmd->ltk[0]);
   36910:	b2b0      	uxth	r0, r6
   36912:	f007 fe7f 	bl	3e614 <ll_start_enc_req_send>
   36916:	e605      	b.n	36524 <hci_cmd_handle+0x280>
	handle = sys_le16_to_cpu(cmd->handle);
   36918:	68a2      	ldr	r2, [r4, #8]
	status = ll_start_enc_req_send(handle, 0x00, &cmd->ltk[0]);
   3691a:	2100      	movs	r1, #0
	handle = sys_le16_to_cpu(cmd->handle);
   3691c:	f832 6b02 	ldrh.w	r6, [r2], #2
   36920:	e7f6      	b.n	36910 <hci_cmd_handle+0x66c>
	struct bt_hci_cp_le_start_encryption *cmd = (void *)buf->data;
   36922:	68a2      	ldr	r2, [r4, #8]
				 (uint8_t *)&cmd->rand,
   36924:	4611      	mov	r1, r2
	status = ll_enc_req_send(handle,
   36926:	f102 030c 	add.w	r3, r2, #12
   3692a:	f831 0b02 	ldrh.w	r0, [r1], #2
   3692e:	320a      	adds	r2, #10
   36930:	f007 ff84 	bl	3e83c <ll_enc_req_send>
   36934:	4601      	mov	r1, r0
	return bt_hci_cmd_status_create(_opcode, status);
   36936:	8838      	ldrh	r0, [r7, #0]
   36938:	e4e6      	b.n	36308 <hci_cmd_handle+0x64>
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
   3693a:	2109      	movs	r1, #9
   3693c:	f014 ff28 	bl	4b790 <bt_hci_cmd_complete_create>
   36940:	2109      	movs	r1, #9
   36942:	4604      	mov	r4, r0
   36944:	3008      	adds	r0, #8
   36946:	f018 fa35 	bl	4edb4 <net_buf_simple_add>
	rp->status = 0x00;
   3694a:	2300      	movs	r3, #0
   3694c:	f800 3b01 	strb.w	r3, [r0], #1
	lll_csrand_get(rp->rand, count);
   36950:	2108      	movs	r1, #8
   36952:	f008 fe41 	bl	3f5d8 <lll_csrand_get>
	if (err == -EINVAL) {
   36956:	e4dd      	b.n	36314 <hci_cmd_handle+0x70>
   36958:	20000188 	.word	0x20000188
   3695c:	3fffff00 	.word	0x3fffff00
   36960:	0003ffff 	.word	0x0003ffff
	struct bt_hci_cp_le_encrypt *cmd = (void *)buf->data;
   36964:	68a0      	ldr	r0, [r4, #8]
	ecb_encrypt(cmd->key, cmd->plaintext, enc_data, NULL);
   36966:	aa0a      	add	r2, sp, #40	; 0x28
   36968:	2300      	movs	r3, #0
   3696a:	f100 0110 	add.w	r1, r0, #16
   3696e:	f00b f887 	bl	41a80 <ecb_encrypt>
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
   36972:	8838      	ldrh	r0, [r7, #0]
   36974:	2111      	movs	r1, #17
   36976:	f014 ff0b 	bl	4b790 <bt_hci_cmd_complete_create>
   3697a:	2111      	movs	r1, #17
   3697c:	4604      	mov	r4, r0
   3697e:	3008      	adds	r0, #8
   36980:	f018 fa18 	bl	4edb4 <net_buf_simple_add>
	rp->status = 0x00;
   36984:	2300      	movs	r3, #0
   36986:	f800 3b01 	strb.w	r3, [r0], #1
	memcpy(rp->enc_data, enc_data, 16);
   3698a:	2210      	movs	r2, #16
   3698c:	a90a      	add	r1, sp, #40	; 0x28
   3698e:	f014 fa74 	bl	4ae7a <memcpy>
	if (err == -EINVAL) {
   36992:	e4bf      	b.n	36314 <hci_cmd_handle+0x70>
	handle = sys_le16_to_cpu(cmd->handle);
   36994:	68a3      	ldr	r3, [r4, #8]
	status = ll_feature_req_send(handle);
   36996:	8818      	ldrh	r0, [r3, #0]
   36998:	f003 fd16 	bl	3a3c8 <ll_feature_req_send>
   3699c:	4601      	mov	r1, r0
	return bt_hci_cmd_status_create(_opcode, status);
   3699e:	8838      	ldrh	r0, [r7, #0]
   369a0:	e4b2      	b.n	36308 <hci_cmd_handle+0x64>
	handle = sys_le16_to_cpu(cmd->handle);
   369a2:	68a3      	ldr	r3, [r4, #8]
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
   369a4:	2108      	movs	r1, #8
	handle = sys_le16_to_cpu(cmd->handle);
   369a6:	881e      	ldrh	r6, [r3, #0]
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
   369a8:	f014 fef2 	bl	4b790 <bt_hci_cmd_complete_create>
   369ac:	2108      	movs	r1, #8
   369ae:	4604      	mov	r4, r0
   369b0:	4408      	add	r0, r1
   369b2:	f018 f9ff 	bl	4edb4 <net_buf_simple_add>
   369b6:	4605      	mov	r5, r0
	status = ll_chm_get(handle, rp->ch_map);
   369b8:	1ce9      	adds	r1, r5, #3
	handle = sys_le16_to_cpu(cmd->handle);
   369ba:	b2b0      	uxth	r0, r6
	status = ll_chm_get(handle, rp->ch_map);
   369bc:	f003 fca4 	bl	3a308 <ll_chm_get>
	rp->handle = sys_le16_to_cpu(handle);
   369c0:	f8a5 6001 	strh.w	r6, [r5, #1]
	rp->status = status;
   369c4:	7028      	strb	r0, [r5, #0]
	if (err == -EINVAL) {
   369c6:	e4a5      	b.n	36314 <hci_cmd_handle+0x70>
	status = ll_chm_update(&cmd->ch_map[0]);
   369c8:	68a0      	ldr	r0, [r4, #8]
   369ca:	f008 fa99 	bl	3ef00 <ll_chm_update>
   369ce:	e690      	b.n	366f2 <hci_cmd_handle+0x44e>
	struct hci_cp_le_conn_update *cmd = (void *)buf->data;
   369d0:	68a2      	ldr	r2, [r4, #8]
	status = ll_conn_update(handle, 0, 0, conn_interval_min,
   369d2:	8911      	ldrh	r1, [r2, #8]
   369d4:	8853      	ldrh	r3, [r2, #2]
   369d6:	8810      	ldrh	r0, [r2, #0]
   369d8:	9102      	str	r1, [sp, #8]
   369da:	88d1      	ldrh	r1, [r2, #6]
   369dc:	9101      	str	r1, [sp, #4]
   369de:	8891      	ldrh	r1, [r2, #4]
   369e0:	9100      	str	r1, [sp, #0]
   369e2:	2200      	movs	r2, #0
   369e4:	4611      	mov	r1, r2
   369e6:	f003 fbef 	bl	3a1c8 <ll_conn_update>
   369ea:	4601      	mov	r1, r0
	return bt_hci_cmd_status_create(_opcode, status);
   369ec:	8838      	ldrh	r0, [r7, #0]
   369ee:	e48b      	b.n	36308 <hci_cmd_handle+0x64>
	status = ll_connect_disable(node_rx);
   369f0:	4630      	mov	r0, r6
   369f2:	f007 fed5 	bl	3e7a0 <ll_connect_disable>
   369f6:	e67c      	b.n	366f2 <hci_cmd_handle+0x44e>
	struct bt_hci_cp_le_create_conn *cmd = (void *)buf->data;
   369f8:	68a4      	ldr	r4, [r4, #8]
	status = ll_create_connection(scan_interval, scan_window,
   369fa:	f8b4 5013 	ldrh.w	r5, [r4, #19]
   369fe:	8861      	ldrh	r1, [r4, #2]
   36a00:	7963      	ldrb	r3, [r4, #5]
   36a02:	7922      	ldrb	r2, [r4, #4]
   36a04:	8820      	ldrh	r0, [r4, #0]
   36a06:	9504      	str	r5, [sp, #16]
   36a08:	f8b4 5011 	ldrh.w	r5, [r4, #17]
   36a0c:	9503      	str	r5, [sp, #12]
   36a0e:	f8b4 500f 	ldrh.w	r5, [r4, #15]
   36a12:	9502      	str	r5, [sp, #8]
   36a14:	7b25      	ldrb	r5, [r4, #12]
   36a16:	9501      	str	r5, [sp, #4]
				      &cmd->peer_addr.a.val[0],
   36a18:	3406      	adds	r4, #6
	status = ll_create_connection(scan_interval, scan_window,
   36a1a:	9400      	str	r4, [sp, #0]
   36a1c:	f7f1 f8a0 	bl	27b60 <ll_create_connection>
   36a20:	4601      	mov	r1, r0
	return bt_hci_cmd_status_create(_opcode, status);
   36a22:	8838      	ldrh	r0, [r7, #0]
   36a24:	e470      	b.n	36308 <hci_cmd_handle+0x64>
	struct bt_hci_cp_le_set_scan_enable *cmd = (void *)buf->data;
   36a26:	68a3      	ldr	r3, [r4, #8]
	if (cmd->enable && cmd->filter_dup) {
   36a28:	7818      	ldrb	r0, [r3, #0]
   36a2a:	2800      	cmp	r0, #0
   36a2c:	d05d      	beq.n	36aea <hci_cmd_handle+0x846>
   36a2e:	785b      	ldrb	r3, [r3, #1]
   36a30:	2b00      	cmp	r3, #0
   36a32:	d05a      	beq.n	36aea <hci_cmd_handle+0x846>
			dup_curr = 0U;
   36a34:	4a30      	ldr	r2, [pc, #192]	; (36af8 <hci_cmd_handle+0x854>)
   36a36:	2300      	movs	r3, #0
   36a38:	6013      	str	r3, [r2, #0]
   36a3a:	4a30      	ldr	r2, [pc, #192]	; (36afc <hci_cmd_handle+0x858>)
   36a3c:	6013      	str	r3, [r2, #0]
	status = ll_scan_enable(cmd->enable);
   36a3e:	f002 fc0b 	bl	39258 <ll_scan_enable>
		status = BT_HCI_ERR_SUCCESS;
   36a42:	280c      	cmp	r0, #12
	status = ll_scan_enable(cmd->enable);
   36a44:	4605      	mov	r5, r0
	buf = bt_hci_cmd_complete_create(_opcode, sizeof(*ccst));
   36a46:	f04f 0101 	mov.w	r1, #1
   36a4a:	8838      	ldrh	r0, [r7, #0]
		status = BT_HCI_ERR_SUCCESS;
   36a4c:	bf08      	it	eq
   36a4e:	2500      	moveq	r5, #0
	buf = bt_hci_cmd_complete_create(_opcode, sizeof(*ccst));
   36a50:	e652      	b.n	366f8 <hci_cmd_handle+0x454>
	struct bt_hci_cp_disconnect *cmd = (void *)buf->data;
   36a52:	68a3      	ldr	r3, [r4, #8]
	status = ll_terminate_ind_send(handle, cmd->reason);
   36a54:	7899      	ldrb	r1, [r3, #2]
   36a56:	8818      	ldrh	r0, [r3, #0]
   36a58:	f003 fc7a 	bl	3a350 <ll_terminate_ind_send>
   36a5c:	4601      	mov	r1, r0
	return bt_hci_cmd_status_create(_opcode, status);
   36a5e:	8838      	ldrh	r0, [r7, #0]
   36a60:	e452      	b.n	36308 <hci_cmd_handle+0x64>
	dup_count = DUP_FILTER_DISABLED;
   36a62:	4826      	ldr	r0, [pc, #152]	; (36afc <hci_cmd_handle+0x858>)
	event_mask = DEFAULT_EVENT_MASK;
   36a64:	4926      	ldr	r1, [pc, #152]	; (36b00 <hci_cmd_handle+0x85c>)
	event_mask_page_2 = DEFAULT_EVENT_MASK_PAGE_2;
   36a66:	4a27      	ldr	r2, [pc, #156]	; (36b04 <hci_cmd_handle+0x860>)
	le_event_mask = DEFAULT_LE_EVENT_MASK;
   36a68:	4b27      	ldr	r3, [pc, #156]	; (36b08 <hci_cmd_handle+0x864>)
	dup_count = DUP_FILTER_DISABLED;
   36a6a:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   36a6e:	6004      	str	r4, [r0, #0]
	event_mask = DEFAULT_EVENT_MASK;
   36a70:	f641 75ff 	movw	r5, #8191	; 0x1fff
   36a74:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   36a78:	e9c1 4500 	strd	r4, r5, [r1]
	event_mask_page_2 = DEFAULT_EVENT_MASK_PAGE_2;
   36a7c:	2000      	movs	r0, #0
   36a7e:	2100      	movs	r1, #0
   36a80:	e9c2 0100 	strd	r0, r1, [r2]
	le_event_mask = DEFAULT_LE_EVENT_MASK;
   36a84:	201f      	movs	r0, #31
   36a86:	2100      	movs	r1, #0
   36a88:	e9c3 0100 	strd	r0, r1, [r3]
		ll_reset();
   36a8c:	f001 fda2 	bl	385d4 <ll_reset>
	buf = bt_hci_cmd_complete_create(_opcode, sizeof(*ccst));
   36a90:	8838      	ldrh	r0, [r7, #0]
   36a92:	2101      	movs	r1, #1
   36a94:	f014 fe7c 	bl	4b790 <bt_hci_cmd_complete_create>
   36a98:	2101      	movs	r1, #1
   36a9a:	4604      	mov	r4, r0
   36a9c:	3008      	adds	r0, #8
   36a9e:	f018 f989 	bl	4edb4 <net_buf_simple_add>
	ccst->status = status;
   36aa2:	2300      	movs	r3, #0
	conn_count = 0U;
   36aa4:	4a19      	ldr	r2, [pc, #100]	; (36b0c <hci_cmd_handle+0x868>)
	ccst->status = status;
   36aa6:	7003      	strb	r3, [r0, #0]
	conn_count = 0U;
   36aa8:	6013      	str	r3, [r2, #0]
	hci_recv_fifo_reset();
   36aaa:	f7ff faa9 	bl	36000 <hci_recv_fifo_reset>
	if (err == -EINVAL) {
   36aae:	e431      	b.n	36314 <hci_cmd_handle+0x70>
	return ((uint64_t)sys_get_le32(&src[4]) << 32) | sys_get_le32(&src[0]);
   36ab0:	68a2      	ldr	r2, [r4, #8]
	event_mask_page_2 = sys_get_le64(cmd->events_page_2);
   36ab2:	4b14      	ldr	r3, [pc, #80]	; (36b04 <hci_cmd_handle+0x860>)
   36ab4:	e5d0      	b.n	36658 <hci_cmd_handle+0x3b4>
	handle = sys_le16_to_cpu(cmd->handle);
   36ab6:	68a3      	ldr	r3, [r4, #8]
   36ab8:	881e      	ldrh	r6, [r3, #0]
	status = ll_apto_get(handle, &auth_payload_timeout);
   36aba:	a90a      	add	r1, sp, #40	; 0x28
   36abc:	b2b0      	uxth	r0, r6
   36abe:	f003 fdcf 	bl	3a660 <ll_apto_get>
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
   36ac2:	2105      	movs	r1, #5
	status = ll_apto_get(handle, &auth_payload_timeout);
   36ac4:	4605      	mov	r5, r0
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
   36ac6:	8838      	ldrh	r0, [r7, #0]
   36ac8:	f014 fe62 	bl	4b790 <bt_hci_cmd_complete_create>
   36acc:	2105      	movs	r1, #5
   36ace:	4604      	mov	r4, r0
   36ad0:	3008      	adds	r0, #8
   36ad2:	f018 f96f 	bl	4edb4 <net_buf_simple_add>
	rp->status = status;
   36ad6:	7005      	strb	r5, [r0, #0]
	rp->handle = sys_cpu_to_le16(handle);
   36ad8:	f8a0 6001 	strh.w	r6, [r0, #1]
	rp->auth_payload_timeout = sys_cpu_to_le16(auth_payload_timeout);
   36adc:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
   36ae0:	f8a0 3003 	strh.w	r3, [r0, #3]
	if (err == -EINVAL) {
   36ae4:	e416      	b.n	36314 <hci_cmd_handle+0x70>
	return evt;
   36ae6:	9c09      	ldr	r4, [sp, #36]	; 0x24
   36ae8:	e414      	b.n	36314 <hci_cmd_handle+0x70>
		dup_count = DUP_FILTER_DISABLED;
   36aea:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   36aee:	e7a4      	b.n	36a3a <hci_cmd_handle+0x796>
	return bt_hci_cmd_status_create(_opcode, status);
   36af0:	2112      	movs	r1, #18
   36af2:	e409      	b.n	36308 <hci_cmd_handle+0x64>
   36af4:	2111      	movs	r1, #17
   36af6:	e407      	b.n	36308 <hci_cmd_handle+0x64>
   36af8:	2000450c 	.word	0x2000450c
   36afc:	20004510 	.word	0x20004510
   36b00:	20000190 	.word	0x20000190
   36b04:	200028e0 	.word	0x200028e0
   36b08:	20000188 	.word	0x20000188
   36b0c:	20004508 	.word	0x20004508

00036b10 <hci_acl_handle>:
{
   36b10:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	*evt = NULL;
   36b14:	2300      	movs	r3, #0
   36b16:	600b      	str	r3, [r1, #0]
	if (buf->len < sizeof(*acl)) {
   36b18:	8983      	ldrh	r3, [r0, #12]
   36b1a:	2b03      	cmp	r3, #3
   36b1c:	d92e      	bls.n	36b7c <hci_acl_handle+0x6c>
	return net_buf_simple_pull_mem(&buf->b, len);
   36b1e:	4605      	mov	r5, r0
   36b20:	4688      	mov	r8, r1
   36b22:	3008      	adds	r0, #8
   36b24:	2104      	movs	r1, #4
   36b26:	f018 f976 	bl	4ee16 <net_buf_simple_pull_mem>
	if (buf->len < len) {
   36b2a:	89ab      	ldrh	r3, [r5, #12]
	len = sys_le16_to_cpu(acl->len);
   36b2c:	8847      	ldrh	r7, [r0, #2]
	handle = sys_le16_to_cpu(acl->handle);
   36b2e:	f8b0 9000 	ldrh.w	r9, [r0]
	if (buf->len < len) {
   36b32:	42bb      	cmp	r3, r7
   36b34:	d322      	bcc.n	36b7c <hci_acl_handle+0x6c>
	if (len > LL_LENGTH_OCTETS_TX_MAX) {
   36b36:	2f1b      	cmp	r7, #27
   36b38:	d820      	bhi.n	36b7c <hci_acl_handle+0x6c>
	node_tx = ll_tx_mem_acquire();
   36b3a:	f003 faeb 	bl	3a114 <ll_tx_mem_acquire>
	flags = bt_acl_flags(handle);
   36b3e:	ea4f 3619 	mov.w	r6, r9, lsr #12
   36b42:	4633      	mov	r3, r6
	if (!node_tx) {
   36b44:	4604      	mov	r4, r0
   36b46:	b1f8      	cbz	r0, 36b88 <hci_acl_handle+0x78>
	if (bt_acl_flags_bc(flags) != BT_ACL_POINT_TO_POINT) {
   36b48:	089b      	lsrs	r3, r3, #2
   36b4a:	d117      	bne.n	36b7c <hci_acl_handle+0x6c>
	switch (bt_acl_flags_pb(flags)) {
   36b4c:	b1d6      	cbz	r6, 36b84 <hci_acl_handle+0x74>
   36b4e:	2e01      	cmp	r6, #1
   36b50:	d114      	bne.n	36b7c <hci_acl_handle+0x6c>
		pdu_data->ll_id = PDU_DATA_LLID_DATA_START;
   36b52:	7923      	ldrb	r3, [r4, #4]
	pdu_data->len = len;
   36b54:	7167      	strb	r7, [r4, #5]
		pdu_data->ll_id = PDU_DATA_LLID_DATA_START;
   36b56:	f366 0301 	bfi	r3, r6, #0, #2
   36b5a:	7123      	strb	r3, [r4, #4]
	memcpy(&pdu_data->lldata[0], buf->data, len);
   36b5c:	68a9      	ldr	r1, [r5, #8]
   36b5e:	463a      	mov	r2, r7
   36b60:	1de0      	adds	r0, r4, #7
   36b62:	f014 f98a 	bl	4ae7a <memcpy>
	if (ll_tx_mem_enqueue(handle, node_tx)) {
   36b66:	4621      	mov	r1, r4
   36b68:	f3c9 000b 	ubfx	r0, r9, #0, #12
   36b6c:	f003 fade 	bl	3a12c <ll_tx_mem_enqueue>
   36b70:	b908      	cbnz	r0, 36b76 <hci_acl_handle+0x66>
}
   36b72:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		ll_tx_mem_release(node_tx);
   36b76:	4620      	mov	r0, r4
   36b78:	f003 fad2 	bl	3a120 <ll_tx_mem_release>
	switch (bt_acl_flags_pb(flags)) {
   36b7c:	f06f 0015 	mvn.w	r0, #21
}
   36b80:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	switch (bt_acl_flags_pb(flags)) {
   36b84:	2602      	movs	r6, #2
   36b86:	e7e4      	b.n	36b52 <hci_acl_handle+0x42>
	if (!(event_mask & BT_EVT_MASK_DATA_BUFFER_OVERFLOW)) {
   36b88:	4b0f      	ldr	r3, [pc, #60]	; (36bc8 <hci_acl_handle+0xb8>)
   36b8a:	681b      	ldr	r3, [r3, #0]
   36b8c:	019b      	lsls	r3, r3, #6
   36b8e:	d517      	bpl.n	36bc0 <hci_acl_handle+0xb0>
	*buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
   36b90:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   36b94:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   36b98:	2001      	movs	r0, #1
   36b9a:	f7f6 ff55 	bl	2da48 <bt_buf_get_rx>
	return net_buf_simple_add(&buf->b, len);
   36b9e:	2102      	movs	r1, #2
   36ba0:	f8c8 0000 	str.w	r0, [r8]
   36ba4:	3008      	adds	r0, #8
   36ba6:	f018 f905 	bl	4edb4 <net_buf_simple_add>
	hdr->evt = evt;
   36baa:	f44f 738d 	mov.w	r3, #282	; 0x11a
   36bae:	8003      	strh	r3, [r0, #0]
   36bb0:	f8d8 0000 	ldr.w	r0, [r8]
   36bb4:	2101      	movs	r1, #1
   36bb6:	3008      	adds	r0, #8
   36bb8:	f018 f8fc 	bl	4edb4 <net_buf_simple_add>
	ep->link_type = link_type;
   36bbc:	2301      	movs	r3, #1
   36bbe:	7003      	strb	r3, [r0, #0]
		return -ENOBUFS;
   36bc0:	f06f 0068 	mvn.w	r0, #104	; 0x68
   36bc4:	e7d5      	b.n	36b72 <hci_acl_handle+0x62>
   36bc6:	bf00      	nop
   36bc8:	20000190 	.word	0x20000190

00036bcc <hci_disconn_complete_encode>:
{
   36bcc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (!(event_mask & BT_EVT_MASK_DISCONN_COMPLETE)) {
   36bce:	4b0e      	ldr	r3, [pc, #56]	; (36c08 <hci_disconn_complete_encode+0x3c>)
   36bd0:	681b      	ldr	r3, [r3, #0]
   36bd2:	06db      	lsls	r3, r3, #27
   36bd4:	d400      	bmi.n	36bd8 <hci_disconn_complete_encode+0xc>
}
   36bd6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   36bd8:	f102 0408 	add.w	r4, r2, #8
   36bdc:	4606      	mov	r6, r0
   36bde:	460d      	mov	r5, r1
   36be0:	4620      	mov	r0, r4
   36be2:	2102      	movs	r1, #2
   36be4:	f018 f8e6 	bl	4edb4 <net_buf_simple_add>
   36be8:	4603      	mov	r3, r0
	hdr->evt = evt;
   36bea:	f240 4205 	movw	r2, #1029	; 0x405
   36bee:	801a      	strh	r2, [r3, #0]
   36bf0:	4620      	mov	r0, r4
   36bf2:	2104      	movs	r1, #4
   36bf4:	f018 f8de 	bl	4edb4 <net_buf_simple_add>
	ep->status = 0x00;
   36bf8:	2700      	movs	r7, #0
   36bfa:	7007      	strb	r7, [r0, #0]
	ep->handle = sys_cpu_to_le16(handle);
   36bfc:	f8a0 5001 	strh.w	r5, [r0, #1]
	ep->reason = *((uint8_t *)pdu_data);
   36c00:	7832      	ldrb	r2, [r6, #0]
   36c02:	70c2      	strb	r2, [r0, #3]
}
   36c04:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   36c06:	bf00      	nop
   36c08:	20000190 	.word	0x20000190

00036c0c <hci_disconn_complete_process>:
	conn_count--;
   36c0c:	4a02      	ldr	r2, [pc, #8]	; (36c18 <hci_disconn_complete_process+0xc>)
   36c0e:	6813      	ldr	r3, [r2, #0]
   36c10:	3b01      	subs	r3, #1
   36c12:	6013      	str	r3, [r2, #0]
}
   36c14:	4770      	bx	lr
   36c16:	bf00      	nop
   36c18:	20004508 	.word	0x20004508

00036c1c <hci_acl_encode>:
	}
}

#if defined(CONFIG_BT_CONN)
void hci_acl_encode(struct node_rx_pdu *node_rx, struct net_buf *buf)
{
   36c1c:	b570      	push	{r4, r5, r6, lr}
	uint16_t handle;
	uint8_t *data;

	handle = node_rx->hdr.handle;

	switch (pdu_data->ll_id) {
   36c1e:	7f03      	ldrb	r3, [r0, #28]
	handle = node_rx->hdr.handle;
   36c20:	88c6      	ldrh	r6, [r0, #6]
	switch (pdu_data->ll_id) {
   36c22:	f003 0303 	and.w	r3, r3, #3
   36c26:	3b01      	subs	r3, #1
   36c28:	2b01      	cmp	r3, #1
   36c2a:	d90d      	bls.n	36c48 <hci_acl_encode+0x2c>
		}
#endif
		break;

	default:
		LL_ASSERT(0);
   36c2c:	4a15      	ldr	r2, [pc, #84]	; (36c84 <hci_acl_encode+0x68>)
   36c2e:	4916      	ldr	r1, [pc, #88]	; (36c88 <hci_acl_encode+0x6c>)
   36c30:	4816      	ldr	r0, [pc, #88]	; (36c8c <hci_acl_encode+0x70>)
   36c32:	f242 1344 	movw	r3, #8516	; 0x2144
   36c36:	f012 fa25 	bl	49084 <assert_print>
   36c3a:	4040      	eors	r0, r0
   36c3c:	f380 8811 	msr	BASEPRI, r0
   36c40:	f04f 0003 	mov.w	r0, #3
   36c44:	df02      	svc	2
		break;
	}
}
   36c46:	bd70      	pop	{r4, r5, r6, pc}
   36c48:	4604      	mov	r4, r0
   36c4a:	f101 0508 	add.w	r5, r1, #8
   36c4e:	4628      	mov	r0, r5
   36c50:	2104      	movs	r1, #4
   36c52:	f018 f8af 	bl	4edb4 <net_buf_simple_add>
		if (pdu_data->ll_id == PDU_DATA_LLID_DATA_START) {
   36c56:	7f23      	ldrb	r3, [r4, #28]
   36c58:	f003 0303 	and.w	r3, r3, #3
   36c5c:	2b02      	cmp	r3, #2
			handle_flags = bt_acl_handle_pack(handle, BT_ACL_START);
   36c5e:	bf0c      	ite	eq
   36c60:	f446 5600 	orreq.w	r6, r6, #8192	; 0x2000
			handle_flags = bt_acl_handle_pack(handle, BT_ACL_CONT);
   36c64:	f446 5680 	orrne.w	r6, r6, #4096	; 0x1000
		acl->handle = sys_cpu_to_le16(handle_flags);
   36c68:	8006      	strh	r6, [r0, #0]
		acl->len = sys_cpu_to_le16(pdu_data->len);
   36c6a:	7f63      	ldrb	r3, [r4, #29]
   36c6c:	8043      	strh	r3, [r0, #2]
   36c6e:	7f61      	ldrb	r1, [r4, #29]
   36c70:	4628      	mov	r0, r5
   36c72:	f018 f89f 	bl	4edb4 <net_buf_simple_add>
		memcpy(data, pdu_data->lldata, pdu_data->len);
   36c76:	7f62      	ldrb	r2, [r4, #29]
   36c78:	f104 011f 	add.w	r1, r4, #31
}
   36c7c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		memcpy(data, pdu_data->lldata, pdu_data->len);
   36c80:	f014 b8fb 	b.w	4ae7a <memcpy>
   36c84:	000521fc 	.word	0x000521fc
   36c88:	000521ac 	.word	0x000521ac
   36c8c:	0005214c 	.word	0x0005214c

00036c90 <hci_evt_encode>:
#endif /* CONFIG_BT_CONN */

void hci_evt_encode(struct node_rx_pdu *node_rx, struct net_buf *buf)
{
   36c90:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	struct pdu_data *pdu_data = (void *)node_rx->pdu;

	if (node_rx->hdr.type != NODE_RX_TYPE_DC_PDU) {
   36c94:	f890 c004 	ldrb.w	ip, [r0, #4]
	handle = node_rx->hdr.handle;
   36c98:	88c6      	ldrh	r6, [r0, #6]
	if (node_rx->hdr.type != NODE_RX_TYPE_DC_PDU) {
   36c9a:	f1bc 0f03 	cmp.w	ip, #3
{
   36c9e:	b087      	sub	sp, #28
   36ca0:	4604      	mov	r4, r0
   36ca2:	460d      	mov	r5, r1
	struct pdu_data *pdu_data = (void *)node_rx->pdu;
   36ca4:	f100 071c 	add.w	r7, r0, #28
	if (node_rx->hdr.type != NODE_RX_TYPE_DC_PDU) {
   36ca8:	d01f      	beq.n	36cea <hci_evt_encode+0x5a>
	switch (node_rx->hdr.type) {
   36caa:	f1ac 0c05 	sub.w	ip, ip, #5
   36cae:	f1bc 0f18 	cmp.w	ip, #24
   36cb2:	d834      	bhi.n	36d1e <hci_evt_encode+0x8e>
   36cb4:	e8df f01c 	tbh	[pc, ip, lsl #1]
   36cb8:	00330043 	.word	0x00330043
   36cbc:	00330033 	.word	0x00330033
   36cc0:	00330033 	.word	0x00330033
   36cc4:	00330033 	.word	0x00330033
   36cc8:	00330033 	.word	0x00330033
   36ccc:	00330033 	.word	0x00330033
   36cd0:	00330033 	.word	0x00330033
   36cd4:	00330033 	.word	0x00330033
   36cd8:	00330033 	.word	0x00330033
   36cdc:	00d900b1 	.word	0x00d900b1
   36ce0:	011000e1 	.word	0x011000e1
   36ce4:	013a0127 	.word	0x013a0127
   36ce8:	015a      	.short	0x015a
	switch (pdu_data->llctrl.opcode) {
   36cea:	7fc3      	ldrb	r3, [r0, #31]
   36cec:	3b03      	subs	r3, #3
   36cee:	2b12      	cmp	r3, #18
   36cf0:	f200 8173 	bhi.w	36fda <hci_evt_encode+0x34a>
   36cf4:	e8df f013 	tbh	[pc, r3, lsl #1]
   36cf8:	0171021f 	.word	0x0171021f
   36cfc:	01b40171 	.word	0x01b40171
   36d00:	017101cd 	.word	0x017101cd
   36d04:	017101db 	.word	0x017101db
   36d08:	01710171 	.word	0x01710171
   36d0c:	017101e0 	.word	0x017101e0
   36d10:	017101fb 	.word	0x017101fb
   36d14:	01710020 	.word	0x01710020
   36d18:	018e0171 	.word	0x018e0171
   36d1c:	018e      	.short	0x018e
		LL_ASSERT(0);
   36d1e:	4ab6      	ldr	r2, [pc, #728]	; (36ff8 <hci_evt_encode+0x368>)
   36d20:	49b6      	ldr	r1, [pc, #728]	; (36ffc <hci_evt_encode+0x36c>)
   36d22:	48b7      	ldr	r0, [pc, #732]	; (37000 <hci_evt_encode+0x370>)
   36d24:	f242 0334 	movw	r3, #8244	; 0x2034
   36d28:	f012 f9ac 	bl	49084 <assert_print>
   36d2c:	4040      	eors	r0, r0
   36d2e:	f380 8811 	msr	BASEPRI, r0
   36d32:	f04f 0003 	mov.w	r0, #3
   36d36:	df02      	svc	2
		encode_control(node_rx, pdu_data, buf);
	} else if (IS_ENABLED(CONFIG_BT_CONN)) {
		encode_data_ctrl(node_rx, pdu_data, buf);
	}
}
   36d38:	b007      	add	sp, #28
   36d3a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	const uint8_t c_adv_type[] = { 0x00, 0x01, 0x03, 0xff, 0x04,
   36d3e:	4bb1      	ldr	r3, [pc, #708]	; (37004 <hci_evt_encode+0x374>)
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   36d40:	4ab1      	ldr	r2, [pc, #708]	; (37008 <hci_evt_encode+0x378>)
	const uint8_t c_adv_type[] = { 0x00, 0x01, 0x03, 0xff, 0x04,
   36d42:	e893 0003 	ldmia.w	r3, {r0, r1}
   36d46:	0c0b      	lsrs	r3, r1, #16
   36d48:	f88d 3016 	strb.w	r3, [sp, #22]
	rssi = -(node_rx->hdr.rx_ftr.rssi);
   36d4c:	7e23      	ldrb	r3, [r4, #24]
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   36d4e:	6852      	ldr	r2, [r2, #4]
	const uint8_t c_adv_type[] = { 0x00, 0x01, 0x03, 0xff, 0x04,
   36d50:	f8ad 1014 	strh.w	r1, [sp, #20]
	rssi = -(node_rx->hdr.rx_ftr.rssi);
   36d54:	425b      	negs	r3, r3
   36d56:	b25e      	sxtb	r6, r3
	direct_report = node_rx->hdr.rx_ftr.direct;
   36d58:	7e63      	ldrb	r3, [r4, #25]
	const uint8_t c_adv_type[] = { 0x00, 0x01, 0x03, 0xff, 0x04,
   36d5a:	9004      	str	r0, [sp, #16]
	if (direct_report) {
   36d5c:	07d9      	lsls	r1, r3, #31
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   36d5e:	f002 5200 	and.w	r2, r2, #536870912	; 0x20000000
	if (direct_report) {
   36d62:	f100 8261 	bmi.w	37228 <hci_evt_encode+0x598>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   36d66:	2a00      	cmp	r2, #0
   36d68:	d0e6      	beq.n	36d38 <hci_evt_encode+0xa8>
	    !(le_event_mask & BT_EVT_MASK_LE_ADVERTISING_REPORT)) {
   36d6a:	4ba8      	ldr	r3, [pc, #672]	; (3700c <hci_evt_encode+0x37c>)
   36d6c:	681b      	ldr	r3, [r3, #0]
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   36d6e:	079b      	lsls	r3, r3, #30
   36d70:	d5e2      	bpl.n	36d38 <hci_evt_encode+0xa8>
	    dup_found(adv->type, adv->tx_addr, adv->adv_ind.addr, 0, NULL, 0)) {
   36d72:	7f20      	ldrb	r0, [r4, #28]
   36d74:	f104 081e 	add.w	r8, r4, #30
   36d78:	f3c0 1180 	ubfx	r1, r0, #6, #1
   36d7c:	4642      	mov	r2, r8
   36d7e:	f000 000f 	and.w	r0, r0, #15
   36d82:	f7ff f94d 	bl	36020 <dup_found.constprop.0>
	if (dup_scan &&
   36d86:	2800      	cmp	r0, #0
   36d88:	d1d6      	bne.n	36d38 <hci_evt_encode+0xa8>
	if (adv->type != PDU_ADV_TYPE_DIRECT_IND) {
   36d8a:	7f23      	ldrb	r3, [r4, #28]
   36d8c:	f003 030f 	and.w	r3, r3, #15
   36d90:	2b01      	cmp	r3, #1
   36d92:	f000 82ab 	beq.w	372ec <hci_evt_encode+0x65c>
		data_len = (adv->len - BDADDR_SIZE);
   36d96:	7f63      	ldrb	r3, [r4, #29]
   36d98:	f1a3 0906 	sub.w	r9, r3, #6
	hci_evt_create(buf, BT_HCI_EVT_LE_META_EVENT, sizeof(*me) + melen);
   36d9c:	f103 0b06 	add.w	fp, r3, #6
		data_len = (adv->len - BDADDR_SIZE);
   36da0:	fa5f f989 	uxtb.w	r9, r9
	sep = meta_evt(buf, BT_HCI_EVT_LE_ADVERTISING_REPORT,
   36da4:	3305      	adds	r3, #5
	hci_evt_create(buf, BT_HCI_EVT_LE_META_EVENT, sizeof(*me) + melen);
   36da6:	fa5f fb8b 	uxtb.w	fp, fp
	return net_buf_add(buf, melen);
   36daa:	fa5f fa83 	uxtb.w	sl, r3
	memcpy(&adv_info->data[0], &adv->adv_ind.data[0], data_len);
   36dae:	464f      	mov	r7, r9
   36db0:	3508      	adds	r5, #8
   36db2:	2102      	movs	r1, #2
   36db4:	4628      	mov	r0, r5
   36db6:	f017 fffd 	bl	4edb4 <net_buf_simple_add>
	hdr->evt = evt;
   36dba:	233e      	movs	r3, #62	; 0x3e
   36dbc:	7003      	strb	r3, [r0, #0]
	hdr->len = len;
   36dbe:	f880 b001 	strb.w	fp, [r0, #1]
   36dc2:	2101      	movs	r1, #1
   36dc4:	4628      	mov	r0, r5
   36dc6:	f017 fff5 	bl	4edb4 <net_buf_simple_add>
   36dca:	4603      	mov	r3, r0
	me->subevent = subevt;
   36dcc:	2202      	movs	r2, #2
   36dce:	701a      	strb	r2, [r3, #0]
   36dd0:	4651      	mov	r1, sl
   36dd2:	4628      	mov	r0, r5
   36dd4:	f017 ffee 	bl	4edb4 <net_buf_simple_add>
	sep->num_reports = 1U;
   36dd8:	2301      	movs	r3, #1
   36dda:	7003      	strb	r3, [r0, #0]
	adv_info->evt_type = c_adv_type[adv->type];
   36ddc:	7f23      	ldrb	r3, [r4, #28]
   36dde:	f003 030f 	and.w	r3, r3, #15
   36de2:	3318      	adds	r3, #24
   36de4:	446b      	add	r3, sp
   36de6:	4605      	mov	r5, r0
   36de8:	f813 3c08 	ldrb.w	r3, [r3, #-8]
   36dec:	7043      	strb	r3, [r0, #1]
		adv_info->addr.type = adv->tx_addr;
   36dee:	7f23      	ldrb	r3, [r4, #28]
   36df0:	f3c3 1380 	ubfx	r3, r3, #6, #1
		memcpy(&adv_info->addr.a.val[0], &adv->adv_ind.addr[0],
   36df4:	4641      	mov	r1, r8
		adv_info->addr.type = adv->tx_addr;
   36df6:	7083      	strb	r3, [r0, #2]
	memcpy(&adv_info->data[0], &adv->adv_ind.data[0], data_len);
   36df8:	f100 080a 	add.w	r8, r0, #10
		memcpy(&adv_info->addr.a.val[0], &adv->adv_ind.addr[0],
   36dfc:	2206      	movs	r2, #6
   36dfe:	3003      	adds	r0, #3
   36e00:	f014 f83b 	bl	4ae7a <memcpy>
	adv_info->length = data_len;
   36e04:	f885 9009 	strb.w	r9, [r5, #9]
	memcpy(&adv_info->data[0], &adv->adv_ind.data[0], data_len);
   36e08:	463a      	mov	r2, r7
   36e0a:	f104 0124 	add.w	r1, r4, #36	; 0x24
   36e0e:	4640      	mov	r0, r8
   36e10:	f014 f833 	bl	4ae7a <memcpy>
	*prssi = rssi;
   36e14:	f808 6007 	strb.w	r6, [r8, r7]
   36e18:	e78e      	b.n	36d38 <hci_evt_encode+0xa8>
	LL_ASSERT(IS_PTR_ALIGNED(node, struct node_rx_cc));
   36e1a:	07ff      	lsls	r7, r7, #31
   36e1c:	f100 81b9 	bmi.w	37192 <hci_evt_encode+0x502>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   36e20:	4b79      	ldr	r3, [pc, #484]	; (37008 <hci_evt_encode+0x378>)
	status = cc->status;
   36e22:	7f27      	ldrb	r7, [r4, #28]
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   36e24:	685b      	ldr	r3, [r3, #4]
   36e26:	0098      	lsls	r0, r3, #2
   36e28:	d586      	bpl.n	36d38 <hci_evt_encode+0xa8>
	    (!(le_event_mask & BT_EVT_MASK_LE_CONN_COMPLETE) &&
   36e2a:	4b78      	ldr	r3, [pc, #480]	; (3700c <hci_evt_encode+0x37c>)
   36e2c:	681b      	ldr	r3, [r3, #0]
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   36e2e:	07d9      	lsls	r1, r3, #31
   36e30:	d582      	bpl.n	36d38 <hci_evt_encode+0xa8>
   36e32:	3508      	adds	r5, #8
	if (!status) {
   36e34:	2f00      	cmp	r7, #0
   36e36:	f000 81c4 	beq.w	371c2 <hci_evt_encode+0x532>
   36e3a:	2102      	movs	r1, #2
   36e3c:	4628      	mov	r0, r5
   36e3e:	f017 ffb9 	bl	4edb4 <net_buf_simple_add>
	hdr->evt = evt;
   36e42:	f241 333e 	movw	r3, #4926	; 0x133e
   36e46:	8003      	strh	r3, [r0, #0]
   36e48:	2101      	movs	r1, #1
   36e4a:	4628      	mov	r0, r5
   36e4c:	f017 ffb2 	bl	4edb4 <net_buf_simple_add>
	me->subevent = subevt;
   36e50:	2301      	movs	r3, #1
   36e52:	7003      	strb	r3, [r0, #0]
   36e54:	2112      	movs	r1, #18
   36e56:	4628      	mov	r0, r5
   36e58:	f017 ffac 	bl	4edb4 <net_buf_simple_add>
   36e5c:	4604      	mov	r4, r0
		(void)memset(lecc, 0x00, sizeof(*lecc));
   36e5e:	2212      	movs	r2, #18
   36e60:	2100      	movs	r1, #0
   36e62:	f014 f815 	bl	4ae90 <memset>
		lecc->status = status;
   36e66:	7027      	strb	r7, [r4, #0]
		return;
   36e68:	e766      	b.n	36d38 <hci_evt_encode+0xa8>
		hci_disconn_complete_encode(pdu_data, handle, buf);
   36e6a:	460a      	mov	r2, r1
   36e6c:	4638      	mov	r0, r7
   36e6e:	4631      	mov	r1, r6
}
   36e70:	b007      	add	sp, #28
   36e72:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		hci_disconn_complete_encode(pdu_data, handle, buf);
   36e76:	f7ff bea9 	b.w	36bcc <hci_disconn_complete_encode>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   36e7a:	4b63      	ldr	r3, [pc, #396]	; (37008 <hci_evt_encode+0x378>)
   36e7c:	685b      	ldr	r3, [r3, #4]
   36e7e:	009a      	lsls	r2, r3, #2
   36e80:	f57f af5a 	bpl.w	36d38 <hci_evt_encode+0xa8>
	    !(le_event_mask & BT_EVT_MASK_LE_CONN_UPDATE_COMPLETE)) {
   36e84:	4b61      	ldr	r3, [pc, #388]	; (3700c <hci_evt_encode+0x37c>)
   36e86:	681b      	ldr	r3, [r3, #0]
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   36e88:	075b      	lsls	r3, r3, #29
   36e8a:	f57f af55 	bpl.w	36d38 <hci_evt_encode+0xa8>
   36e8e:	3508      	adds	r5, #8
   36e90:	2102      	movs	r1, #2
   36e92:	4628      	mov	r0, r5
   36e94:	f017 ff8e 	bl	4edb4 <net_buf_simple_add>
	hdr->evt = evt;
   36e98:	f640 233e 	movw	r3, #2622	; 0xa3e
   36e9c:	8003      	strh	r3, [r0, #0]
   36e9e:	2101      	movs	r1, #1
   36ea0:	4628      	mov	r0, r5
   36ea2:	f017 ff87 	bl	4edb4 <net_buf_simple_add>
   36ea6:	4603      	mov	r3, r0
	me->subevent = subevt;
   36ea8:	2203      	movs	r2, #3
   36eaa:	4628      	mov	r0, r5
   36eac:	701a      	strb	r2, [r3, #0]
   36eae:	2109      	movs	r1, #9
   36eb0:	f017 ff80 	bl	4edb4 <net_buf_simple_add>
	LL_ASSERT(IS_PTR_ALIGNED(node, struct node_rx_cu));
   36eb4:	07ff      	lsls	r7, r7, #31
   36eb6:	4605      	mov	r5, r0
   36eb8:	f100 820a 	bmi.w	372d0 <hci_evt_encode+0x640>
	sep->status = cu->status;
   36ebc:	7f23      	ldrb	r3, [r4, #28]
   36ebe:	702b      	strb	r3, [r5, #0]
	sep->handle = sys_cpu_to_le16(handle);
   36ec0:	f8a5 6001 	strh.w	r6, [r5, #1]
	sep->interval = sys_cpu_to_le16(cu->interval);
   36ec4:	8be3      	ldrh	r3, [r4, #30]
   36ec6:	f8a5 3003 	strh.w	r3, [r5, #3]
	sep->latency = sys_cpu_to_le16(cu->latency);
   36eca:	8c23      	ldrh	r3, [r4, #32]
   36ecc:	f8a5 3005 	strh.w	r3, [r5, #5]
	sep->supv_timeout = sys_cpu_to_le16(cu->timeout);
   36ed0:	8c63      	ldrh	r3, [r4, #34]	; 0x22
   36ed2:	f8a5 3007 	strh.w	r3, [r5, #7]
   36ed6:	e72f      	b.n	36d38 <hci_evt_encode+0xa8>
	if (!(event_mask & BT_EVT_MASK_ENCRYPT_KEY_REFRESH_COMPLETE)) {
   36ed8:	4b4b      	ldr	r3, [pc, #300]	; (37008 <hci_evt_encode+0x378>)
   36eda:	685b      	ldr	r3, [r3, #4]
   36edc:	0418      	lsls	r0, r3, #16
   36ede:	f04f 0400 	mov.w	r4, #0
   36ee2:	f57f af29 	bpl.w	36d38 <hci_evt_encode+0xa8>
   36ee6:	3508      	adds	r5, #8
   36ee8:	2102      	movs	r1, #2
   36eea:	4628      	mov	r0, r5
   36eec:	f017 ff62 	bl	4edb4 <net_buf_simple_add>
	hdr->evt = evt;
   36ef0:	f44f 734c 	mov.w	r3, #816	; 0x330
   36ef4:	8003      	strh	r3, [r0, #0]
   36ef6:	2103      	movs	r1, #3
   36ef8:	4628      	mov	r0, r5
   36efa:	f017 ff5b 	bl	4edb4 <net_buf_simple_add>
	ep->status = 0x00;
   36efe:	7004      	strb	r4, [r0, #0]
	ep->handle = sys_cpu_to_le16(handle);
   36f00:	f8a0 6001 	strh.w	r6, [r0, #1]
   36f04:	e718      	b.n	36d38 <hci_evt_encode+0xa8>
	if (!(event_mask_page_2 & BT_EVT_MASK_AUTH_PAYLOAD_TIMEOUT_EXP)) {
   36f06:	4b42      	ldr	r3, [pc, #264]	; (37010 <hci_evt_encode+0x380>)
   36f08:	681b      	ldr	r3, [r3, #0]
   36f0a:	0219      	lsls	r1, r3, #8
   36f0c:	f57f af14 	bpl.w	36d38 <hci_evt_encode+0xa8>
   36f10:	3508      	adds	r5, #8
   36f12:	2102      	movs	r1, #2
   36f14:	4628      	mov	r0, r5
   36f16:	f017 ff4d 	bl	4edb4 <net_buf_simple_add>
	hdr->evt = evt;
   36f1a:	f240 2357 	movw	r3, #599	; 0x257
   36f1e:	8003      	strh	r3, [r0, #0]
   36f20:	2102      	movs	r1, #2
   36f22:	4628      	mov	r0, r5
   36f24:	f017 ff46 	bl	4edb4 <net_buf_simple_add>
	ep->handle = sys_cpu_to_le16(handle);
   36f28:	8006      	strh	r6, [r0, #0]
   36f2a:	e705      	b.n	36d38 <hci_evt_encode+0xa8>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   36f2c:	4b36      	ldr	r3, [pc, #216]	; (37008 <hci_evt_encode+0x378>)
   36f2e:	685b      	ldr	r3, [r3, #4]
   36f30:	009a      	lsls	r2, r3, #2
   36f32:	f57f af01 	bpl.w	36d38 <hci_evt_encode+0xa8>
	    !(le_event_mask & BT_EVT_MASK_LE_CHAN_SEL_ALGO)) {
   36f36:	4b35      	ldr	r3, [pc, #212]	; (3700c <hci_evt_encode+0x37c>)
   36f38:	681b      	ldr	r3, [r3, #0]
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   36f3a:	031b      	lsls	r3, r3, #12
   36f3c:	f57f aefc 	bpl.w	36d38 <hci_evt_encode+0xa8>
   36f40:	3508      	adds	r5, #8
   36f42:	2102      	movs	r1, #2
   36f44:	4628      	mov	r0, r5
   36f46:	f017 ff35 	bl	4edb4 <net_buf_simple_add>
	hdr->evt = evt;
   36f4a:	f240 433e 	movw	r3, #1086	; 0x43e
   36f4e:	8003      	strh	r3, [r0, #0]
   36f50:	2101      	movs	r1, #1
   36f52:	4628      	mov	r0, r5
   36f54:	f017 ff2e 	bl	4edb4 <net_buf_simple_add>
	me->subevent = subevt;
   36f58:	2314      	movs	r3, #20
   36f5a:	7003      	strb	r3, [r0, #0]
   36f5c:	2103      	movs	r1, #3
   36f5e:	4628      	mov	r0, r5
   36f60:	f017 ff28 	bl	4edb4 <net_buf_simple_add>
	sep->handle = sys_cpu_to_le16(handle);
   36f64:	8006      	strh	r6, [r0, #0]
	sep->chan_sel_algo = cs->csa;
   36f66:	7f23      	ldrb	r3, [r4, #28]
   36f68:	7083      	strb	r3, [r0, #2]
   36f6a:	e6e5      	b.n	36d38 <hci_evt_encode+0xa8>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   36f6c:	4b26      	ldr	r3, [pc, #152]	; (37008 <hci_evt_encode+0x378>)
   36f6e:	685b      	ldr	r3, [r3, #4]
   36f70:	009f      	lsls	r7, r3, #2
   36f72:	f57f aee1 	bpl.w	36d38 <hci_evt_encode+0xa8>
	    !(le_event_mask & BT_EVT_MASK_LE_PHY_UPDATE_COMPLETE)) {
   36f76:	4b25      	ldr	r3, [pc, #148]	; (3700c <hci_evt_encode+0x37c>)
   36f78:	681b      	ldr	r3, [r3, #0]
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   36f7a:	0518      	lsls	r0, r3, #20
   36f7c:	f57f aedc 	bpl.w	36d38 <hci_evt_encode+0xa8>
   36f80:	3508      	adds	r5, #8
   36f82:	2102      	movs	r1, #2
   36f84:	4628      	mov	r0, r5
   36f86:	f017 ff15 	bl	4edb4 <net_buf_simple_add>
	hdr->evt = evt;
   36f8a:	f240 633e 	movw	r3, #1598	; 0x63e
   36f8e:	8003      	strh	r3, [r0, #0]
   36f90:	2101      	movs	r1, #1
   36f92:	4628      	mov	r0, r5
   36f94:	f017 ff0e 	bl	4edb4 <net_buf_simple_add>
	me->subevent = subevt;
   36f98:	230c      	movs	r3, #12
   36f9a:	7003      	strb	r3, [r0, #0]
   36f9c:	2105      	movs	r1, #5
   36f9e:	4628      	mov	r0, r5
   36fa0:	f017 ff08 	bl	4edb4 <net_buf_simple_add>
	sep->status = pu->status;
   36fa4:	7f23      	ldrb	r3, [r4, #28]
   36fa6:	7003      	strb	r3, [r0, #0]
	sep->handle = sys_cpu_to_le16(handle);
   36fa8:	f8a0 6001 	strh.w	r6, [r0, #1]
   36fac:	7f62      	ldrb	r2, [r4, #29]
   36fae:	2a00      	cmp	r2, #0
   36fb0:	fa92 f3a2 	rbit	r3, r2
   36fb4:	fab3 f383 	clz	r3, r3
   36fb8:	bf08      	it	eq
   36fba:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff
   36fbe:	3301      	adds	r3, #1
	sep->tx_phy = find_lsb_set(pu->tx);
   36fc0:	70c3      	strb	r3, [r0, #3]
   36fc2:	7fa2      	ldrb	r2, [r4, #30]
   36fc4:	fa92 f3a2 	rbit	r3, r2
   36fc8:	2a00      	cmp	r2, #0
   36fca:	fab3 f383 	clz	r3, r3
   36fce:	bf08      	it	eq
   36fd0:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff
   36fd4:	3301      	adds	r3, #1
	sep->rx_phy = find_lsb_set(pu->rx);
   36fd6:	7103      	strb	r3, [r0, #4]
   36fd8:	e6ae      	b.n	36d38 <hci_evt_encode+0xa8>
		LL_ASSERT(0);
   36fda:	4a07      	ldr	r2, [pc, #28]	; (36ff8 <hci_evt_encode+0x368>)
   36fdc:	4907      	ldr	r1, [pc, #28]	; (36ffc <hci_evt_encode+0x36c>)
   36fde:	4808      	ldr	r0, [pc, #32]	; (37000 <hci_evt_encode+0x370>)
   36fe0:	f242 1318 	movw	r3, #8472	; 0x2118
   36fe4:	f012 f84e 	bl	49084 <assert_print>
   36fe8:	4040      	eors	r0, r0
   36fea:	f380 8811 	msr	BASEPRI, r0
   36fee:	f04f 0003 	mov.w	r0, #3
   36ff2:	df02      	svc	2
}
   36ff4:	e6a0      	b.n	36d38 <hci_evt_encode+0xa8>
   36ff6:	bf00      	nop
   36ff8:	000521fc 	.word	0x000521fc
   36ffc:	000521ac 	.word	0x000521ac
   37000:	0005214c 	.word	0x0005214c
   37004:	00050dd0 	.word	0x00050dd0
   37008:	20000190 	.word	0x20000190
   3700c:	20000188 	.word	0x20000188
   37010:	200028e0 	.word	0x200028e0
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   37014:	4bb9      	ldr	r3, [pc, #740]	; (372fc <hci_evt_encode+0x66c>)
   37016:	685b      	ldr	r3, [r3, #4]
   37018:	009a      	lsls	r2, r3, #2
   3701a:	f57f ae8d 	bpl.w	36d38 <hci_evt_encode+0xa8>
	    !(le_event_mask & BT_EVT_MASK_LE_DATA_LEN_CHANGE)) {
   3701e:	4bb8      	ldr	r3, [pc, #736]	; (37300 <hci_evt_encode+0x670>)
   37020:	681b      	ldr	r3, [r3, #0]
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   37022:	065b      	lsls	r3, r3, #25
   37024:	f57f ae88 	bpl.w	36d38 <hci_evt_encode+0xa8>
   37028:	3508      	adds	r5, #8
   3702a:	2102      	movs	r1, #2
   3702c:	4628      	mov	r0, r5
   3702e:	f017 fec1 	bl	4edb4 <net_buf_simple_add>
	hdr->evt = evt;
   37032:	f640 333e 	movw	r3, #2878	; 0xb3e
   37036:	8003      	strh	r3, [r0, #0]
   37038:	2101      	movs	r1, #1
   3703a:	4628      	mov	r0, r5
   3703c:	f017 feba 	bl	4edb4 <net_buf_simple_add>
	me->subevent = subevt;
   37040:	2307      	movs	r3, #7
   37042:	7003      	strb	r3, [r0, #0]
   37044:	210a      	movs	r1, #10
   37046:	4628      	mov	r0, r5
   37048:	f017 feb4 	bl	4edb4 <net_buf_simple_add>
	sep->handle = sys_cpu_to_le16(handle);
   3704c:	8006      	strh	r6, [r0, #0]
	sep->max_tx_octets = pdu_data->llctrl.length_rsp.max_tx_octets;
   3704e:	8ca3      	ldrh	r3, [r4, #36]	; 0x24
   37050:	8043      	strh	r3, [r0, #2]
	sep->max_tx_time = pdu_data->llctrl.length_rsp.max_tx_time;
   37052:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
   37054:	8083      	strh	r3, [r0, #4]
	sep->max_rx_octets = pdu_data->llctrl.length_rsp.max_rx_octets;
   37056:	8c23      	ldrh	r3, [r4, #32]
   37058:	80c3      	strh	r3, [r0, #6]
	sep->max_rx_time = pdu_data->llctrl.length_rsp.max_rx_time;
   3705a:	8c63      	ldrh	r3, [r4, #34]	; 0x22
   3705c:	8103      	strh	r3, [r0, #8]
   3705e:	e66b      	b.n	36d38 <hci_evt_encode+0xa8>
	if (!(event_mask & BT_EVT_MASK_ENCRYPT_CHANGE)) {
   37060:	4ba6      	ldr	r3, [pc, #664]	; (372fc <hci_evt_encode+0x66c>)
   37062:	681b      	ldr	r3, [r3, #0]
   37064:	061b      	lsls	r3, r3, #24
   37066:	f04f 0400 	mov.w	r4, #0
   3706a:	f57f ae65 	bpl.w	36d38 <hci_evt_encode+0xa8>
   3706e:	3508      	adds	r5, #8
   37070:	2102      	movs	r1, #2
   37072:	4628      	mov	r0, r5
   37074:	f017 fe9e 	bl	4edb4 <net_buf_simple_add>
	hdr->evt = evt;
   37078:	f44f 6381 	mov.w	r3, #1032	; 0x408
   3707c:	8003      	strh	r3, [r0, #0]
   3707e:	2104      	movs	r1, #4
   37080:	4628      	mov	r0, r5
   37082:	f017 fe97 	bl	4edb4 <net_buf_simple_add>
	ep->encrypt = !err ? 1 : 0;
   37086:	2301      	movs	r3, #1
	ep->status = err;
   37088:	7004      	strb	r4, [r0, #0]
	ep->handle = sys_cpu_to_le16(handle);
   3708a:	f8a0 6001 	strh.w	r6, [r0, #1]
	ep->encrypt = !err ? 1 : 0;
   3708e:	70c3      	strb	r3, [r0, #3]
   37090:	e652      	b.n	36d38 <hci_evt_encode+0xa8>
	switch (pdu_data->llctrl.unknown_rsp.type) {
   37092:	f890 3020 	ldrb.w	r3, [r0, #32]
   37096:	2b0e      	cmp	r3, #14
   37098:	f47f ae4e 	bne.w	36d38 <hci_evt_encode+0xa8>
		le_remote_feat_complete(BT_HCI_ERR_UNSUPP_REMOTE_FEATURE,
   3709c:	460b      	mov	r3, r1
   3709e:	4632      	mov	r2, r6
   370a0:	2100      	movs	r1, #0
   370a2:	201a      	movs	r0, #26
}
   370a4:	b007      	add	sp, #28
   370a6:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		le_remote_feat_complete(BT_HCI_ERR_UNSUPP_REMOTE_FEATURE,
   370aa:	f7ff b815 	b.w	360d8 <le_remote_feat_complete>
		le_remote_feat_complete(0x00, pdu_data, handle, buf);
   370ae:	460b      	mov	r3, r1
   370b0:	4632      	mov	r2, r6
   370b2:	4639      	mov	r1, r7
   370b4:	2000      	movs	r0, #0
   370b6:	e7f5      	b.n	370a4 <hci_evt_encode+0x414>
	if (!(event_mask & BT_EVT_MASK_ENCRYPT_CHANGE)) {
   370b8:	4b90      	ldr	r3, [pc, #576]	; (372fc <hci_evt_encode+0x66c>)
		encrypt_change(pdu_data->llctrl.reject_ind.error_code, handle,
   370ba:	f890 4020 	ldrb.w	r4, [r0, #32]
	if (!(event_mask & BT_EVT_MASK_ENCRYPT_CHANGE)) {
   370be:	681b      	ldr	r3, [r3, #0]
   370c0:	061f      	lsls	r7, r3, #24
   370c2:	f57f ae39 	bpl.w	36d38 <hci_evt_encode+0xa8>
   370c6:	3508      	adds	r5, #8
   370c8:	2102      	movs	r1, #2
   370ca:	4628      	mov	r0, r5
   370cc:	f017 fe72 	bl	4edb4 <net_buf_simple_add>
	hdr->evt = evt;
   370d0:	f44f 6381 	mov.w	r3, #1032	; 0x408
   370d4:	8003      	strh	r3, [r0, #0]
   370d6:	2104      	movs	r1, #4
   370d8:	4628      	mov	r0, r5
   370da:	f017 fe6b 	bl	4edb4 <net_buf_simple_add>
	ep->encrypt = !err ? 1 : 0;
   370de:	fab4 f384 	clz	r3, r4
   370e2:	095b      	lsrs	r3, r3, #5
	ep->status = err;
   370e4:	7004      	strb	r4, [r0, #0]
	ep->handle = sys_cpu_to_le16(handle);
   370e6:	f8a0 6001 	strh.w	r6, [r0, #1]
	ep->encrypt = !err ? 1 : 0;
   370ea:	70c3      	strb	r3, [r0, #3]
   370ec:	e624      	b.n	36d38 <hci_evt_encode+0xa8>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   370ee:	4b83      	ldr	r3, [pc, #524]	; (372fc <hci_evt_encode+0x66c>)
   370f0:	685b      	ldr	r3, [r3, #4]
   370f2:	0098      	lsls	r0, r3, #2
   370f4:	d55b      	bpl.n	371ae <hci_evt_encode+0x51e>
	    !(le_event_mask & BT_EVT_MASK_LE_CONN_PARAM_REQ)) {
   370f6:	4b82      	ldr	r3, [pc, #520]	; (37300 <hci_evt_encode+0x670>)
   370f8:	681b      	ldr	r3, [r3, #0]
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   370fa:	0699      	lsls	r1, r3, #26
   370fc:	d557      	bpl.n	371ae <hci_evt_encode+0x51e>
   370fe:	3508      	adds	r5, #8
   37100:	2102      	movs	r1, #2
   37102:	4628      	mov	r0, r5
   37104:	f017 fe56 	bl	4edb4 <net_buf_simple_add>
	hdr->evt = evt;
   37108:	f640 333e 	movw	r3, #2878	; 0xb3e
   3710c:	8003      	strh	r3, [r0, #0]
   3710e:	2101      	movs	r1, #1
   37110:	4628      	mov	r0, r5
   37112:	f017 fe4f 	bl	4edb4 <net_buf_simple_add>
	me->subevent = subevt;
   37116:	2306      	movs	r3, #6
   37118:	7003      	strb	r3, [r0, #0]
   3711a:	210a      	movs	r1, #10
   3711c:	4628      	mov	r0, r5
   3711e:	f017 fe49 	bl	4edb4 <net_buf_simple_add>
	sep->handle = sys_cpu_to_le16(handle);
   37122:	8006      	strh	r6, [r0, #0]
	sep->interval_min = pdu_data->llctrl.conn_param_req.interval_min;
   37124:	8c23      	ldrh	r3, [r4, #32]
   37126:	8043      	strh	r3, [r0, #2]
	sep->interval_max = pdu_data->llctrl.conn_param_req.interval_max;
   37128:	8c63      	ldrh	r3, [r4, #34]	; 0x22
   3712a:	8083      	strh	r3, [r0, #4]
	sep->latency = pdu_data->llctrl.conn_param_req.latency;
   3712c:	8ca3      	ldrh	r3, [r4, #36]	; 0x24
   3712e:	80c3      	strh	r3, [r0, #6]
	sep->timeout = pdu_data->llctrl.conn_param_req.timeout;
   37130:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
   37132:	8103      	strh	r3, [r0, #8]
   37134:	e600      	b.n	36d38 <hci_evt_encode+0xa8>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   37136:	4b71      	ldr	r3, [pc, #452]	; (372fc <hci_evt_encode+0x66c>)
   37138:	685b      	ldr	r3, [r3, #4]
   3713a:	0099      	lsls	r1, r3, #2
   3713c:	f57f adfc 	bpl.w	36d38 <hci_evt_encode+0xa8>
	    !(le_event_mask & BT_EVT_MASK_LE_LTK_REQUEST)) {
   37140:	4b6f      	ldr	r3, [pc, #444]	; (37300 <hci_evt_encode+0x670>)
   37142:	681b      	ldr	r3, [r3, #0]
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   37144:	06da      	lsls	r2, r3, #27
   37146:	f57f adf7 	bpl.w	36d38 <hci_evt_encode+0xa8>
   3714a:	3508      	adds	r5, #8
   3714c:	2102      	movs	r1, #2
   3714e:	4628      	mov	r0, r5
   37150:	f017 fe30 	bl	4edb4 <net_buf_simple_add>
	hdr->evt = evt;
   37154:	f640 533e 	movw	r3, #3390	; 0xd3e
   37158:	8003      	strh	r3, [r0, #0]
   3715a:	2101      	movs	r1, #1
   3715c:	4628      	mov	r0, r5
   3715e:	f017 fe29 	bl	4edb4 <net_buf_simple_add>
	me->subevent = subevt;
   37162:	2305      	movs	r3, #5
   37164:	7003      	strb	r3, [r0, #0]
   37166:	210c      	movs	r1, #12
   37168:	4628      	mov	r0, r5
   3716a:	f017 fe23 	bl	4edb4 <net_buf_simple_add>
	memcpy(&sep->rand, pdu_data->llctrl.enc_req.rand, sizeof(uint64_t));
   3716e:	f104 0120 	add.w	r1, r4, #32
   37172:	4605      	mov	r5, r0
   37174:	2208      	movs	r2, #8
	sep->handle = sys_cpu_to_le16(handle);
   37176:	f820 6b02 	strh.w	r6, [r0], #2
	memcpy(&sep->rand, pdu_data->llctrl.enc_req.rand, sizeof(uint64_t));
   3717a:	f013 fe7e 	bl	4ae7a <memcpy>
	memcpy(&sep->ediv, pdu_data->llctrl.enc_req.ediv, sizeof(uint16_t));
   3717e:	2202      	movs	r2, #2
   37180:	f104 0128 	add.w	r1, r4, #40	; 0x28
   37184:	f105 000a 	add.w	r0, r5, #10
}
   37188:	b007      	add	sp, #28
   3718a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	memcpy(&sep->ediv, pdu_data->llctrl.enc_req.ediv, sizeof(uint16_t));
   3718e:	f013 be74 	b.w	4ae7a <memcpy>
	LL_ASSERT(IS_PTR_ALIGNED(node, struct node_rx_cc));
   37192:	4a5c      	ldr	r2, [pc, #368]	; (37304 <hci_evt_encode+0x674>)
   37194:	495c      	ldr	r1, [pc, #368]	; (37308 <hci_evt_encode+0x678>)
   37196:	485d      	ldr	r0, [pc, #372]	; (3730c <hci_evt_encode+0x67c>)
   37198:	f641 636c 	movw	r3, #7788	; 0x1e6c
   3719c:	f011 ff72 	bl	49084 <assert_print>
   371a0:	4040      	eors	r0, r0
   371a2:	f380 8811 	msr	BASEPRI, r0
   371a6:	f04f 0003 	mov.w	r0, #3
   371aa:	df02      	svc	2
   371ac:	e638      	b.n	36e20 <hci_evt_encode+0x190>
		ll_conn_update(handle, 2, BT_HCI_ERR_UNSUPP_REMOTE_FEATURE, 0,
   371ae:	2300      	movs	r3, #0
   371b0:	e9cd 3301 	strd	r3, r3, [sp, #4]
   371b4:	9300      	str	r3, [sp, #0]
   371b6:	221a      	movs	r2, #26
   371b8:	2102      	movs	r1, #2
   371ba:	4630      	mov	r0, r6
   371bc:	f003 f804 	bl	3a1c8 <ll_conn_update>
		return;
   371c0:	e5ba      	b.n	36d38 <hci_evt_encode+0xa8>
		conn_count++;
   371c2:	4a53      	ldr	r2, [pc, #332]	; (37310 <hci_evt_encode+0x680>)
   371c4:	6813      	ldr	r3, [r2, #0]
   371c6:	2102      	movs	r1, #2
   371c8:	3301      	adds	r3, #1
   371ca:	4628      	mov	r0, r5
   371cc:	6013      	str	r3, [r2, #0]
   371ce:	f017 fdf1 	bl	4edb4 <net_buf_simple_add>
	hdr->evt = evt;
   371d2:	f241 333e 	movw	r3, #4926	; 0x133e
   371d6:	8003      	strh	r3, [r0, #0]
   371d8:	2101      	movs	r1, #1
   371da:	4628      	mov	r0, r5
   371dc:	f017 fdea 	bl	4edb4 <net_buf_simple_add>
   371e0:	4603      	mov	r3, r0
	me->subevent = subevt;
   371e2:	2201      	movs	r2, #1
   371e4:	701a      	strb	r2, [r3, #0]
   371e6:	4628      	mov	r0, r5
   371e8:	2112      	movs	r1, #18
   371ea:	f017 fde3 	bl	4edb4 <net_buf_simple_add>
	lecc->status = 0x00;
   371ee:	7007      	strb	r7, [r0, #0]
	lecc->handle = sys_cpu_to_le16(handle);
   371f0:	f8a0 6001 	strh.w	r6, [r0, #1]
	lecc->role = cc->role;
   371f4:	7f63      	ldrb	r3, [r4, #29]
   371f6:	70c3      	strb	r3, [r0, #3]
	lecc->peer_addr.type = cc->peer_addr_type & 0x1;
   371f8:	7fa3      	ldrb	r3, [r4, #30]
   371fa:	f003 0301 	and.w	r3, r3, #1
   371fe:	4605      	mov	r5, r0
   37200:	7103      	strb	r3, [r0, #4]
	memcpy(&lecc->peer_addr.a.val[0], &cc->peer_addr[0], BDADDR_SIZE);
   37202:	2206      	movs	r2, #6
   37204:	f104 011f 	add.w	r1, r4, #31
   37208:	3005      	adds	r0, #5
   3720a:	f013 fe36 	bl	4ae7a <memcpy>
	lecc->interval = sys_cpu_to_le16(cc->interval);
   3720e:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
   37210:	f8a5 300b 	strh.w	r3, [r5, #11]
	lecc->latency = sys_cpu_to_le16(cc->latency);
   37214:	8d23      	ldrh	r3, [r4, #40]	; 0x28
   37216:	f8a5 300d 	strh.w	r3, [r5, #13]
	lecc->supv_timeout = sys_cpu_to_le16(cc->timeout);
   3721a:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
   3721c:	f8a5 300f 	strh.w	r3, [r5, #15]
	lecc->clock_accuracy = cc->sca;
   37220:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
   37224:	746b      	strb	r3, [r5, #17]
   37226:	e587      	b.n	36d38 <hci_evt_encode+0xa8>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   37228:	2a00      	cmp	r2, #0
   3722a:	f43f ad85 	beq.w	36d38 <hci_evt_encode+0xa8>
	    !(le_event_mask & BT_EVT_MASK_LE_DIRECT_ADV_REPORT)) {
   3722e:	4b34      	ldr	r3, [pc, #208]	; (37300 <hci_evt_encode+0x670>)
   37230:	681b      	ldr	r3, [r3, #0]
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   37232:	055a      	lsls	r2, r3, #21
   37234:	f57f ad80 	bpl.w	36d38 <hci_evt_encode+0xa8>
	LL_ASSERT(adv->type == PDU_ADV_TYPE_DIRECT_IND);
   37238:	7f20      	ldrb	r0, [r4, #28]
   3723a:	f000 030f 	and.w	r3, r0, #15
   3723e:	2b01      	cmp	r3, #1
   37240:	d00d      	beq.n	3725e <hci_evt_encode+0x5ce>
   37242:	4a30      	ldr	r2, [pc, #192]	; (37304 <hci_evt_encode+0x674>)
   37244:	4933      	ldr	r1, [pc, #204]	; (37314 <hci_evt_encode+0x684>)
   37246:	4831      	ldr	r0, [pc, #196]	; (3730c <hci_evt_encode+0x67c>)
   37248:	f241 7389 	movw	r3, #6025	; 0x1789
   3724c:	f011 ff1a 	bl	49084 <assert_print>
   37250:	4040      	eors	r0, r0
   37252:	f380 8811 	msr	BASEPRI, r0
   37256:	f04f 0003 	mov.w	r0, #3
   3725a:	df02      	svc	2
   3725c:	7f20      	ldrb	r0, [r4, #28]
	    dup_found(adv->type, adv->tx_addr, adv->adv_ind.addr, 0, NULL, 0)) {
   3725e:	f104 071e 	add.w	r7, r4, #30
   37262:	f3c0 1180 	ubfx	r1, r0, #6, #1
   37266:	463a      	mov	r2, r7
   37268:	f000 000f 	and.w	r0, r0, #15
   3726c:	f7fe fed8 	bl	36020 <dup_found.constprop.0>
	if (dup_scan &&
   37270:	2800      	cmp	r0, #0
   37272:	f47f ad61 	bne.w	36d38 <hci_evt_encode+0xa8>
   37276:	3508      	adds	r5, #8
   37278:	2102      	movs	r1, #2
   3727a:	4628      	mov	r0, r5
   3727c:	f017 fd9a 	bl	4edb4 <net_buf_simple_add>
	hdr->evt = evt;
   37280:	f241 233e 	movw	r3, #4670	; 0x123e
   37284:	8003      	strh	r3, [r0, #0]
   37286:	2101      	movs	r1, #1
   37288:	4628      	mov	r0, r5
   3728a:	f017 fd93 	bl	4edb4 <net_buf_simple_add>
   3728e:	4603      	mov	r3, r0
	me->subevent = subevt;
   37290:	220b      	movs	r2, #11
   37292:	701a      	strb	r2, [r3, #0]
   37294:	4628      	mov	r0, r5
   37296:	2111      	movs	r1, #17
   37298:	f017 fd8c 	bl	4edb4 <net_buf_simple_add>
	drp->num_reports = 1U;
   3729c:	f240 1301 	movw	r3, #257	; 0x101
   372a0:	8003      	strh	r3, [r0, #0]
		dir_info->addr.type = adv->tx_addr;
   372a2:	7f23      	ldrb	r3, [r4, #28]
   372a4:	f3c3 1380 	ubfx	r3, r3, #6, #1
   372a8:	4605      	mov	r5, r0
   372aa:	7083      	strb	r3, [r0, #2]
		memcpy(&dir_info->addr.a.val[0], &adv->direct_ind.adv_addr[0],
   372ac:	4639      	mov	r1, r7
   372ae:	2206      	movs	r2, #6
   372b0:	3003      	adds	r0, #3
   372b2:	f013 fde2 	bl	4ae7a <memcpy>
	dir_info->dir_addr.type = adv->rx_addr;
   372b6:	7f23      	ldrb	r3, [r4, #28]
   372b8:	f3c3 13c0 	ubfx	r3, r3, #7, #1
	memcpy(&dir_info->dir_addr.a.val[0],
   372bc:	2206      	movs	r2, #6
	dir_info->dir_addr.type = adv->rx_addr;
   372be:	726b      	strb	r3, [r5, #9]
	memcpy(&dir_info->dir_addr.a.val[0],
   372c0:	f104 0124 	add.w	r1, r4, #36	; 0x24
   372c4:	f105 000a 	add.w	r0, r5, #10
   372c8:	f013 fdd7 	bl	4ae7a <memcpy>
	dir_info->rssi = rssi;
   372cc:	742e      	strb	r6, [r5, #16]
   372ce:	e533      	b.n	36d38 <hci_evt_encode+0xa8>
	LL_ASSERT(IS_PTR_ALIGNED(node, struct node_rx_cu));
   372d0:	4a0c      	ldr	r2, [pc, #48]	; (37304 <hci_evt_encode+0x674>)
   372d2:	4911      	ldr	r1, [pc, #68]	; (37318 <hci_evt_encode+0x688>)
   372d4:	480d      	ldr	r0, [pc, #52]	; (3730c <hci_evt_encode+0x67c>)
   372d6:	f641 63f1 	movw	r3, #7921	; 0x1ef1
   372da:	f011 fed3 	bl	49084 <assert_print>
   372de:	4040      	eors	r0, r0
   372e0:	f380 8811 	msr	BASEPRI, r0
   372e4:	f04f 0003 	mov.w	r0, #3
   372e8:	df02      	svc	2
   372ea:	e5e7      	b.n	36ebc <hci_evt_encode+0x22c>
   372ec:	4607      	mov	r7, r0
   372ee:	f04f 0a0b 	mov.w	sl, #11
   372f2:	f04f 0b0c 	mov.w	fp, #12
		data_len = 0U;
   372f6:	4681      	mov	r9, r0
   372f8:	e55a      	b.n	36db0 <hci_evt_encode+0x120>
   372fa:	bf00      	nop
   372fc:	20000190 	.word	0x20000190
   37300:	20000188 	.word	0x20000188
   37304:	000521fc 	.word	0x000521fc
   37308:	00052260 	.word	0x00052260
   3730c:	0005214c 	.word	0x0005214c
   37310:	20004508 	.word	0x20004508
   37314:	00052238 	.word	0x00052238
   37318:	0005229c 	.word	0x0005229c

0003731c <hci_num_cmplt_encode>:

#if defined(CONFIG_BT_CONN) || defined(CONFIG_BT_CTLR_ADV_ISO) || \
	defined(CONFIG_BT_CTLR_CONN_ISO)
void hci_num_cmplt_encode(struct net_buf *buf, uint16_t handle, uint8_t num)
{
   3731c:	b570      	push	{r4, r5, r6, lr}
   3731e:	f100 0408 	add.w	r4, r0, #8
   37322:	460e      	mov	r6, r1
   37324:	4620      	mov	r0, r4
   37326:	2102      	movs	r1, #2
   37328:	4615      	mov	r5, r2
   3732a:	f017 fd43 	bl	4edb4 <net_buf_simple_add>
	hdr->evt = evt;
   3732e:	f240 5313 	movw	r3, #1299	; 0x513
   37332:	8003      	strh	r3, [r0, #0]
   37334:	2105      	movs	r1, #5
   37336:	4620      	mov	r0, r4
   37338:	f017 fd3c 	bl	4edb4 <net_buf_simple_add>

	len = (sizeof(*ep) + (sizeof(*hc) * num_handles));
	hci_evt_create(buf, BT_HCI_EVT_NUM_COMPLETED_PACKETS, len);

	ep = net_buf_add(buf, len);
	ep->num_handles = num_handles;
   3733c:	2301      	movs	r3, #1
   3733e:	7003      	strb	r3, [r0, #0]
	hc = &ep->h[0];
	hc->handle = sys_cpu_to_le16(handle);
   37340:	f8a0 6001 	strh.w	r6, [r0, #1]
	hc->count = sys_cpu_to_le16(num);
   37344:	f8a0 5003 	strh.w	r5, [r0, #3]
}
   37348:	bd70      	pop	{r4, r5, r6, pc}
   3734a:	bf00      	nop

0003734c <hci_get_class>:
{
#if defined(CONFIG_BT_CONN)
	struct pdu_data *pdu_data = (void *)node_rx->pdu;
#endif

	if (node_rx->hdr.type != NODE_RX_TYPE_DC_PDU) {
   3734c:	7903      	ldrb	r3, [r0, #4]
   3734e:	2b03      	cmp	r3, #3
   37350:	d008      	beq.n	37364 <hci_get_class+0x18>

		switch (node_rx->hdr.type) {
   37352:	3b05      	subs	r3, #5
   37354:	b2db      	uxtb	r3, r3
   37356:	2b18      	cmp	r3, #24
   37358:	d901      	bls.n	3735e <hci_get_class+0x12>
	if (node_rx->hdr.type != NODE_RX_TYPE_DC_PDU) {
   3735a:	2000      	movs	r0, #0
#else
	} else {
		return HCI_CLASS_NONE;
	}
#endif
}
   3735c:	4770      	bx	lr
   3735e:	4a05      	ldr	r2, [pc, #20]	; (37374 <hci_get_class+0x28>)
   37360:	5cd0      	ldrb	r0, [r2, r3]
   37362:	4770      	bx	lr
	} else if (pdu_data->ll_id == PDU_DATA_LLID_CTRL) {
   37364:	7f03      	ldrb	r3, [r0, #28]
   37366:	f003 0303 	and.w	r3, r3, #3
		return HCI_CLASS_EVT_LLCP;
   3736a:	2b03      	cmp	r3, #3
   3736c:	bf14      	ite	ne
   3736e:	2005      	movne	r0, #5
   37370:	2004      	moveq	r0, #4
   37372:	4770      	bx	lr
   37374:	000522d8 	.word	0x000522d8

00037378 <hci_init>:
	dup_count = DUP_FILTER_DISABLED;
   37378:	480d      	ldr	r0, [pc, #52]	; (373b0 <hci_init+0x38>)
	event_mask = DEFAULT_EVENT_MASK;
   3737a:	4b0e      	ldr	r3, [pc, #56]	; (373b4 <hci_init+0x3c>)
	event_mask_page_2 = DEFAULT_EVENT_MASK_PAGE_2;
   3737c:	4a0e      	ldr	r2, [pc, #56]	; (373b8 <hci_init+0x40>)
	le_event_mask = DEFAULT_LE_EVENT_MASK;
   3737e:	490f      	ldr	r1, [pc, #60]	; (373bc <hci_init+0x44>)

void hci_init(struct k_poll_signal *signal_host_buf)
{
   37380:	b430      	push	{r4, r5}
	dup_count = DUP_FILTER_DISABLED;
   37382:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   37386:	6004      	str	r4, [r0, #0]
	event_mask = DEFAULT_EVENT_MASK;
   37388:	f641 75ff 	movw	r5, #8191	; 0x1fff
   3738c:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   37390:	e9c3 4500 	strd	r4, r5, [r3]
	event_mask_page_2 = DEFAULT_EVENT_MASK_PAGE_2;
   37394:	2400      	movs	r4, #0
   37396:	2500      	movs	r5, #0
   37398:	e9c2 4500 	strd	r4, r5, [r2]
	le_event_mask = DEFAULT_LE_EVENT_MASK;
   3739c:	241f      	movs	r4, #31
   3739e:	2500      	movs	r5, #0
   373a0:	e9c1 4500 	strd	r4, r5, [r1]
	conn_count = 0U;
   373a4:	4b06      	ldr	r3, [pc, #24]	; (373c0 <hci_init+0x48>)
   373a6:	2200      	movs	r2, #0
   373a8:	601a      	str	r2, [r3, #0]
#if defined(CONFIG_BT_HCI_ACL_FLOW_CONTROL)
	hbuf_signal = signal_host_buf;
#endif
	reset(NULL, NULL);
}
   373aa:	bc30      	pop	{r4, r5}
	hci_recv_fifo_reset();
   373ac:	f7fe be28 	b.w	36000 <hci_recv_fifo_reset>
   373b0:	20004510 	.word	0x20004510
   373b4:	20000190 	.word	0x20000190
   373b8:	200028e0 	.word	0x200028e0
   373bc:	20000188 	.word	0x20000188
   373c0:	20004508 	.word	0x20004508

000373c4 <bt_rand>:
#include "hal/ecb.h"
#include "lll.h"

int bt_rand(void *buf, size_t len)
{
	return lll_csrand_get(buf, len);
   373c4:	f008 b908 	b.w	3f5d8 <lll_csrand_get>

000373c8 <bt_encrypt_le>:
}

int bt_encrypt_le(const uint8_t key[16], const uint8_t plaintext[16],
		  uint8_t enc_data[16])
{
   373c8:	b508      	push	{r3, lr}
	BT_DBG("key %s", bt_hex(key, 16));
	BT_DBG("plaintext %s", bt_hex(plaintext, 16));

	ecb_encrypt(key, plaintext, enc_data, NULL);
   373ca:	2300      	movs	r3, #0
   373cc:	f00a fb58 	bl	41a80 <ecb_encrypt>

	BT_DBG("enc_data %s", bt_hex(enc_data, 16));

	return 0;
}
   373d0:	2000      	movs	r0, #0
   373d2:	bd08      	pop	{r3, pc}

000373d4 <ll_feat_get>:

#else /* !CONFIG_BT_CTLR_SET_HOST_FEATURE */
uint64_t ll_feat_get(void)
{
	return LL_FEAT;
}
   373d4:	4801      	ldr	r0, [pc, #4]	; (373dc <ll_feat_get+0x8>)
   373d6:	2100      	movs	r1, #0
   373d8:	4770      	bx	lr
   373da:	bf00      	nop
   373dc:	000141bf 	.word	0x000141bf

000373e0 <perform_lll_reset>:

	return 0;
}

static void perform_lll_reset(void *param)
{
   373e0:	b510      	push	{r4, lr}
   373e2:	4604      	mov	r4, r0
	int err;

	/* Reset LLL */
	err = lll_reset();
   373e4:	f008 f926 	bl	3f634 <lll_reset>
	LL_ASSERT(!err);
   373e8:	b970      	cbnz	r0, 37408 <perform_lll_reset+0x28>

#if defined(CONFIG_BT_BROADCASTER)
	/* Reset adv state */
	err = lll_adv_reset();
   373ea:	f008 fd3f 	bl	3fe6c <lll_adv_reset>
	LL_ASSERT(!err);
   373ee:	b9e0      	cbnz	r0, 3742a <perform_lll_reset+0x4a>
#endif /* CONFIG_BT_BROADCASTER */

#if defined(CONFIG_BT_OBSERVER)
	/* Reset scan state */
	err = lll_scan_reset();
   373f0:	f009 fb86 	bl	40b00 <lll_scan_reset>
	LL_ASSERT(!err);
   373f4:	bb50      	cbnz	r0, 3744c <perform_lll_reset+0x6c>
#endif /* CONFIG_BT_OBSERVER */

#if defined(CONFIG_BT_CONN)
	/* Reset conn role */
	err = lll_conn_reset();
   373f6:	f009 fca7 	bl	40d48 <lll_conn_reset>
	LL_ASSERT(!err);
   373fa:	2800      	cmp	r0, #0
   373fc:	d137      	bne.n	3746e <perform_lll_reset+0x8e>
	z_impl_k_sem_give(sem);
   373fe:	4620      	mov	r0, r4
#endif /* CONFIG_BT_CTLR_DF */

#if !defined(CONFIG_BT_CTLR_ZLI)
	k_sem_give(param);
#endif /* !CONFIG_BT_CTLR_ZLI */
}
   37400:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   37404:	f00f beb8 	b.w	47178 <z_impl_k_sem_give>
	LL_ASSERT(!err);
   37408:	4a22      	ldr	r2, [pc, #136]	; (37494 <perform_lll_reset+0xb4>)
   3740a:	4923      	ldr	r1, [pc, #140]	; (37498 <perform_lll_reset+0xb8>)
   3740c:	4823      	ldr	r0, [pc, #140]	; (3749c <perform_lll_reset+0xbc>)
   3740e:	f640 03c9 	movw	r3, #2249	; 0x8c9
   37412:	f011 fe37 	bl	49084 <assert_print>
   37416:	4040      	eors	r0, r0
   37418:	f380 8811 	msr	BASEPRI, r0
   3741c:	f04f 0003 	mov.w	r0, #3
   37420:	df02      	svc	2
	err = lll_adv_reset();
   37422:	f008 fd23 	bl	3fe6c <lll_adv_reset>
	LL_ASSERT(!err);
   37426:	2800      	cmp	r0, #0
   37428:	d0e2      	beq.n	373f0 <perform_lll_reset+0x10>
   3742a:	4a1a      	ldr	r2, [pc, #104]	; (37494 <perform_lll_reset+0xb4>)
   3742c:	491a      	ldr	r1, [pc, #104]	; (37498 <perform_lll_reset+0xb8>)
   3742e:	481b      	ldr	r0, [pc, #108]	; (3749c <perform_lll_reset+0xbc>)
   37430:	f640 03ce 	movw	r3, #2254	; 0x8ce
   37434:	f011 fe26 	bl	49084 <assert_print>
   37438:	4040      	eors	r0, r0
   3743a:	f380 8811 	msr	BASEPRI, r0
   3743e:	f04f 0003 	mov.w	r0, #3
   37442:	df02      	svc	2
	err = lll_scan_reset();
   37444:	f009 fb5c 	bl	40b00 <lll_scan_reset>
	LL_ASSERT(!err);
   37448:	2800      	cmp	r0, #0
   3744a:	d0d4      	beq.n	373f6 <perform_lll_reset+0x16>
   3744c:	4a11      	ldr	r2, [pc, #68]	; (37494 <perform_lll_reset+0xb4>)
   3744e:	4912      	ldr	r1, [pc, #72]	; (37498 <perform_lll_reset+0xb8>)
   37450:	4812      	ldr	r0, [pc, #72]	; (3749c <perform_lll_reset+0xbc>)
   37452:	f640 03d4 	movw	r3, #2260	; 0x8d4
   37456:	f011 fe15 	bl	49084 <assert_print>
   3745a:	4040      	eors	r0, r0
   3745c:	f380 8811 	msr	BASEPRI, r0
   37460:	f04f 0003 	mov.w	r0, #3
   37464:	df02      	svc	2
	err = lll_conn_reset();
   37466:	f009 fc6f 	bl	40d48 <lll_conn_reset>
	LL_ASSERT(!err);
   3746a:	2800      	cmp	r0, #0
   3746c:	d0c7      	beq.n	373fe <perform_lll_reset+0x1e>
   3746e:	4a09      	ldr	r2, [pc, #36]	; (37494 <perform_lll_reset+0xb4>)
   37470:	4909      	ldr	r1, [pc, #36]	; (37498 <perform_lll_reset+0xb8>)
   37472:	480a      	ldr	r0, [pc, #40]	; (3749c <perform_lll_reset+0xbc>)
   37474:	f640 03da 	movw	r3, #2266	; 0x8da
   37478:	f011 fe04 	bl	49084 <assert_print>
   3747c:	4040      	eors	r0, r0
   3747e:	f380 8811 	msr	BASEPRI, r0
   37482:	f04f 0003 	mov.w	r0, #3
   37486:	df02      	svc	2
   37488:	4620      	mov	r0, r4
}
   3748a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   3748e:	f00f be73 	b.w	47178 <z_impl_k_sem_give>
   37492:	bf00      	nop
   37494:	000522f4 	.word	0x000522f4
   37498:	00052330 	.word	0x00052330
   3749c:	0005214c 	.word	0x0005214c

000374a0 <ull_ticker_status_give>:
	*((uint32_t volatile *)param) = status;
   374a0:	6008      	str	r0, [r1, #0]
   374a2:	4801      	ldr	r0, [pc, #4]	; (374a8 <ull_ticker_status_give+0x8>)
   374a4:	f00f be68 	b.w	47178 <z_impl_k_sem_give>
   374a8:	20004bf4 	.word	0x20004bf4

000374ac <disabled_cb>:
   374ac:	f00f be64 	b.w	47178 <z_impl_k_sem_give>

000374b0 <tx_cmplt_get>:
}
#endif /* CONFIG_BT_CTLR_LOW_LAT_ULL */

#if defined(CONFIG_BT_CONN) || defined(CONFIG_BT_CTLR_ADV_ISO)
static uint8_t tx_cmplt_get(uint16_t *handle, uint8_t *first, uint8_t last)
{
   374b0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	struct lll_tx *tx;
	uint8_t cmplt;
	uint8_t next;

	next = *first;
	tx = mfifo_dequeue_iter_get(mfifo_tx_ack.m, mfifo_tx_ack.s,
   374b4:	4d2a      	ldr	r5, [pc, #168]	; (37560 <tx_cmplt_get+0xb0>)
	next = *first;
   374b6:	780c      	ldrb	r4, [r1, #0]
	tx = mfifo_dequeue_iter_get(mfifo_tx_ack.m, mfifo_tx_ack.s,
   374b8:	78ab      	ldrb	r3, [r5, #2]
{
   374ba:	468a      	mov	sl, r1
	tx = mfifo_dequeue_iter_get(mfifo_tx_ack.m, mfifo_tx_ack.s,
   374bc:	7929      	ldrb	r1, [r5, #4]
{
	void *p;
	uint8_t i;

	if (*idx >= count) {
		*idx = first;
   374be:	429c      	cmp	r4, r3
   374c0:	bf28      	it	cs
   374c2:	460c      	movcs	r4, r1
	}

	if (*idx == last) {
   374c4:	42a2      	cmp	r2, r4
   374c6:	7829      	ldrb	r1, [r5, #0]
   374c8:	d042      	beq.n	37550 <tx_cmplt_get+0xa0>
	i = *idx + 1;
	if (i == count) {
		i = 0U;
	}

	p = (void *)(fifo + (*idx) * size);
   374ca:	fb14 f101 	smulbb	r1, r4, r1
   374ce:	f105 0708 	add.w	r7, r5, #8
	i = *idx + 1;
   374d2:	3401      	adds	r4, #1
   374d4:	b2e4      	uxtb	r4, r4
		i = 0U;
   374d6:	42a3      	cmp	r3, r4
   374d8:	bf08      	it	eq
   374da:	2400      	moveq	r4, #0
	p = (void *)(fifo + (*idx) * size);
   374dc:	187b      	adds	r3, r7, r1
				    &next);
	if (!tx) {
		return 0;
	}

	*handle = tx->handle;
   374de:	5a79      	ldrh	r1, [r7, r1]
   374e0:	8001      	strh	r1, [r0, #0]
	cmplt = 0U;
   374e2:	4693      	mov	fp, r2
   374e4:	4681      	mov	r9, r0
   374e6:	2600      	movs	r6, #0
			     (p->ll_id == PDU_DATA_LLID_DATA_START ||
			      p->ll_id == PDU_DATA_LLID_DATA_CONTINUE)) ||
			    (!IS_NODE_TX_PTR(tx_node) &&
			     IS_NODE_TX_DATA(tx_node))) {
				/* data packet, hence count num cmplt */
				NODE_TX_DATA_SET(tx->node);
   374e8:	f04f 0801 	mov.w	r8, #1
   374ec:	e01c      	b.n	37528 <tx_cmplt_get+0x78>
			    (!IS_NODE_TX_PTR(tx_node) &&
   374ee:	2801      	cmp	r0, #1
   374f0:	d02b      	beq.n	3754a <tx_cmplt_get+0x9a>
   374f2:	2212      	movs	r2, #18
   374f4:	605a      	str	r2, [r3, #4]
#if defined(CONFIG_BT_CTLR_ADV_ISO) || \
	defined(CONFIG_BT_CTLR_CONN_ISO)
next_ack:
#endif /* CONFIG_BT_CTLR_ADV_ISO || CONFIG_BT_CTLR_CONN_ISO */

		*first = next;
   374f6:	f88a 4000 	strb.w	r4, [sl]
		tx = mfifo_dequeue_iter_get(mfifo_tx_ack.m, mfifo_tx_ack.s,
   374fa:	78a8      	ldrb	r0, [r5, #2]
   374fc:	792b      	ldrb	r3, [r5, #4]
   374fe:	7829      	ldrb	r1, [r5, #0]
	if (*idx >= count) {
   37500:	42a0      	cmp	r0, r4
   37502:	bf88      	it	hi
   37504:	4623      	movhi	r3, r4
	if (*idx == last) {
   37506:	459b      	cmp	fp, r3
   37508:	d023      	beq.n	37552 <tx_cmplt_get+0xa2>
	p = (void *)(fifo + (*idx) * size);
   3750a:	fb13 f101 	smulbb	r1, r3, r1
	i = *idx + 1;
   3750e:	3301      	adds	r3, #1
   37510:	b2dc      	uxtb	r4, r3
		i = 0U;
   37512:	42a0      	cmp	r0, r4
   37514:	bf08      	it	eq
   37516:	2400      	moveq	r4, #0
					    mfifo_tx_ack.n, mfifo_tx_ack.f,
					    last, &next);
	} while (tx && tx->handle == *handle);
   37518:	f837 c001 	ldrh.w	ip, [r7, r1]
   3751c:	f8b9 0000 	ldrh.w	r0, [r9]
   37520:	4584      	cmp	ip, r0
	p = (void *)(fifo + (*idx) * size);
   37522:	eb07 0301 	add.w	r3, r7, r1
   37526:	d114      	bne.n	37552 <tx_cmplt_get+0xa2>
			tx_node = tx->node;
   37528:	6858      	ldr	r0, [r3, #4]
			if (!tx_node ||
   3752a:	b160      	cbz	r0, 37546 <tx_cmplt_get+0x96>
   3752c:	28ff      	cmp	r0, #255	; 0xff
   3752e:	d9de      	bls.n	374ee <tx_cmplt_get+0x3e>
			     (p->ll_id == PDU_DATA_LLID_DATA_START ||
   37530:	7901      	ldrb	r1, [r0, #4]
   37532:	f001 0103 	and.w	r1, r1, #3
			    (IS_NODE_TX_PTR(tx_node) &&
   37536:	3901      	subs	r1, #1
   37538:	2901      	cmp	r1, #1
   3753a:	d90d      	bls.n	37558 <tx_cmplt_get+0xa8>
				NODE_TX_CTRL_SET(tx->node);
   3753c:	2112      	movs	r1, #18
   3753e:	6059      	str	r1, [r3, #4]
				ll_tx_mem_release(tx_node);
   37540:	f002 fdee 	bl	3a120 <ll_tx_mem_release>
   37544:	e7d7      	b.n	374f6 <tx_cmplt_get+0x46>
				NODE_TX_DATA_SET(tx->node);
   37546:	f8c3 8004 	str.w	r8, [r3, #4]
				cmplt++;
   3754a:	3601      	adds	r6, #1
   3754c:	b2f6      	uxtb	r6, r6
			if (IS_NODE_TX_PTR(tx_node)) {
   3754e:	e7d2      	b.n	374f6 <tx_cmplt_get+0x46>
		return 0;
   37550:	2600      	movs	r6, #0

	return cmplt;
}
   37552:	4630      	mov	r0, r6
   37554:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				cmplt++;
   37558:	3601      	adds	r6, #1
   3755a:	b2f6      	uxtb	r6, r6
				NODE_TX_DATA_SET(tx->node);
   3755c:	2101      	movs	r1, #1
				cmplt++;
   3755e:	e7ee      	b.n	3753e <tx_cmplt_get+0x8e>
   37560:	200007d0 	.word	0x200007d0

00037564 <rx_replenish>:
{
   37564:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (max > mem_link_rx.quota_pdu) {
   37568:	4f3d      	ldr	r7, [pc, #244]	; (37660 <rx_replenish+0xfc>)
   3756a:	883b      	ldrh	r3, [r7, #0]
   3756c:	4298      	cmp	r0, r3
   3756e:	d968      	bls.n	37642 <rx_replenish+0xde>
	while (max && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
   37570:	f013 06ff 	ands.w	r6, r3, #255	; 0xff
   37574:	d02c      	beq.n	375d0 <rx_replenish+0x6c>
   37576:	4d3b      	ldr	r5, [pc, #236]	; (37664 <rx_replenish+0x100>)
		link = mem_acquire(&mem_link_rx.free);
   37578:	f8df 80ec 	ldr.w	r8, [pc, #236]	; 37668 <rx_replenish+0x104>
	while (max && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
   3757c:	796c      	ldrb	r4, [r5, #5]
		rx = mem_acquire(&mem_pdu_rx.free);
   3757e:	f8df 90ec 	ldr.w	r9, [pc, #236]	; 3766c <rx_replenish+0x108>
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
   37582:	f105 0a08 	add.w	sl, r5, #8
	if (last == count) {
   37586:	78aa      	ldrb	r2, [r5, #2]
	while (max && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
   37588:	792b      	ldrb	r3, [r5, #4]
	last = last + 1;
   3758a:	3401      	adds	r4, #1
   3758c:	b2e4      	uxtb	r4, r4
		last = 0U;
   3758e:	42a2      	cmp	r2, r4
   37590:	bf08      	it	eq
   37592:	2400      	moveq	r4, #0
	if (last == first) {
   37594:	42a3      	cmp	r3, r4
		link = mem_acquire(&mem_link_rx.free);
   37596:	4640      	mov	r0, r8
   37598:	d01c      	beq.n	375d4 <rx_replenish+0x70>
   3759a:	f7fc ff8d 	bl	344b8 <mem_acquire>
   3759e:	4683      	mov	fp, r0
		rx = mem_acquire(&mem_pdu_rx.free);
   375a0:	4648      	mov	r0, r9
		if (!link) {
   375a2:	f1bb 0f00 	cmp.w	fp, #0
   375a6:	d013      	beq.n	375d0 <rx_replenish+0x6c>
		rx = mem_acquire(&mem_pdu_rx.free);
   375a8:	f7fc ff86 	bl	344b8 <mem_acquire>
		if (!rx) {
   375ac:	2800      	cmp	r0, #0
   375ae:	d04a      	beq.n	37646 <rx_replenish+0xe2>
		rx->link = link;
   375b0:	f8c0 b000 	str.w	fp, [r0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
   375b4:	796b      	ldrb	r3, [r5, #5]
   375b6:	782a      	ldrb	r2, [r5, #0]
   375b8:	fb13 f302 	smulbb	r3, r3, r2
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
   375bc:	f84a 0003 	str.w	r0, [sl, r3]
	mem_link_rx.quota_pdu += delta;
   375c0:	883b      	ldrh	r3, [r7, #0]
	*last = idx; /* Commit: Update write index */
   375c2:	716c      	strb	r4, [r5, #5]
		max--;
   375c4:	3e01      	subs	r6, #1
	mem_link_rx.quota_pdu += delta;
   375c6:	3b01      	subs	r3, #1
	while (max && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
   375c8:	f016 06ff 	ands.w	r6, r6, #255	; 0xff
	mem_link_rx.quota_pdu += delta;
   375cc:	803b      	strh	r3, [r7, #0]
	while (max && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
   375ce:	d1da      	bne.n	37586 <rx_replenish+0x22>
}
   375d0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	while (mem_link_rx.quota_pdu &&
   375d4:	883b      	ldrh	r3, [r7, #0]
   375d6:	2b00      	cmp	r3, #0
   375d8:	d0fa      	beq.n	375d0 <rx_replenish+0x6c>
	       MFIFO_ENQUEUE_IDX_GET(ll_pdu_rx_free, &idx)) {
   375da:	f8df 9094 	ldr.w	r9, [pc, #148]	; 37670 <rx_replenish+0x10c>
		link = mem_acquire(&mem_link_rx.free);
   375de:	4d22      	ldr	r5, [pc, #136]	; (37668 <rx_replenish+0x104>)
	       MFIFO_ENQUEUE_IDX_GET(ll_pdu_rx_free, &idx)) {
   375e0:	f899 4005 	ldrb.w	r4, [r9, #5]
		rx = mem_acquire(&mem_pdu_rx.free);
   375e4:	4e21      	ldr	r6, [pc, #132]	; (3766c <rx_replenish+0x108>)
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
   375e6:	f109 0808 	add.w	r8, r9, #8
	if (last == count) {
   375ea:	f899 2002 	ldrb.w	r2, [r9, #2]
	       MFIFO_ENQUEUE_IDX_GET(ll_pdu_rx_free, &idx)) {
   375ee:	f899 3004 	ldrb.w	r3, [r9, #4]
	last = last + 1;
   375f2:	3401      	adds	r4, #1
   375f4:	b2e4      	uxtb	r4, r4
		last = 0U;
   375f6:	42a2      	cmp	r2, r4
   375f8:	bf08      	it	eq
   375fa:	2400      	moveq	r4, #0
	if (last == first) {
   375fc:	42a3      	cmp	r3, r4
		link = mem_acquire(&mem_link_rx.free);
   375fe:	4628      	mov	r0, r5
   37600:	d0e6      	beq.n	375d0 <rx_replenish+0x6c>
   37602:	f7fc ff59 	bl	344b8 <mem_acquire>
   37606:	4682      	mov	sl, r0
		rx = mem_acquire(&mem_pdu_rx.free);
   37608:	4630      	mov	r0, r6
		if (!link) {
   3760a:	f1ba 0f00 	cmp.w	sl, #0
   3760e:	d0df      	beq.n	375d0 <rx_replenish+0x6c>
		rx = mem_acquire(&mem_pdu_rx.free);
   37610:	f7fc ff52 	bl	344b8 <mem_acquire>
		link->mem = NULL;
   37614:	2300      	movs	r3, #0
		if (!rx) {
   37616:	b1e0      	cbz	r0, 37652 <rx_replenish+0xee>
		link->mem = NULL;
   37618:	f8ca 3004 	str.w	r3, [sl, #4]
		rx->link = link;
   3761c:	f8c0 a000 	str.w	sl, [r0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
   37620:	f899 3005 	ldrb.w	r3, [r9, #5]
   37624:	f899 2000 	ldrb.w	r2, [r9]
   37628:	fb13 f302 	smulbb	r3, r3, r2
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
   3762c:	f848 0003 	str.w	r0, [r8, r3]
	mem_link_rx.quota_pdu += delta;
   37630:	883b      	ldrh	r3, [r7, #0]
	*last = idx; /* Commit: Update write index */
   37632:	f889 4005 	strb.w	r4, [r9, #5]
   37636:	3b01      	subs	r3, #1
   37638:	b29b      	uxth	r3, r3
   3763a:	803b      	strh	r3, [r7, #0]
	while (mem_link_rx.quota_pdu &&
   3763c:	2b00      	cmp	r3, #0
   3763e:	d1d4      	bne.n	375ea <rx_replenish+0x86>
   37640:	e7c6      	b.n	375d0 <rx_replenish+0x6c>
   37642:	4606      	mov	r6, r0
   37644:	e797      	b.n	37576 <rx_replenish+0x12>
	mem_release(link, &mem_link_rx.free);
   37646:	4658      	mov	r0, fp
   37648:	4907      	ldr	r1, [pc, #28]	; (37668 <rx_replenish+0x104>)
}
   3764a:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	mem_release(link, &mem_link_rx.free);
   3764e:	f7fc bf4f 	b.w	344f0 <mem_release>
   37652:	4650      	mov	r0, sl
   37654:	4904      	ldr	r1, [pc, #16]	; (37668 <rx_replenish+0x104>)
}
   37656:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	mem_release(link, &mem_link_rx.free);
   3765a:	f7fc bf49 	b.w	344f0 <mem_release>
   3765e:	bf00      	nop
   37660:	200045e4 	.word	0x200045e4
   37664:	20000834 	.word	0x20000834
   37668:	200045e8 	.word	0x200045e8
   3766c:	200046b4 	.word	0x200046b4
   37670:	200007f8 	.word	0x200007f8

00037674 <ull_done>:
}
#endif /* CONFIG_BT_CONN || CONFIG_BT_CTLR_ADV_ISO */

#if !defined(CONFIG_BT_CTLR_LOW_LAT_ULL)
static void ull_done(void *param)
{
   37674:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   37678:	4e3c      	ldr	r6, [pc, #240]	; (3776c <ull_done+0xf8>)
	void *release;

	/* Decrement prepare reference if ULL will not resume */
	ull_hdr = done->param;
	if (ull_hdr) {
		LL_ASSERT(ull_ref_get(ull_hdr));
   3767a:	f8df 80f4 	ldr.w	r8, [pc, #244]	; 37770 <ull_done+0xfc>
   3767e:	f8df 90f4 	ldr.w	r9, [pc, #244]	; 37774 <ull_done+0x100>
{
   37682:	b083      	sub	sp, #12
		link = memq_peek(memq_ull_done.head, memq_ull_done.tail,
   37684:	e9d6 0100 	ldrd	r0, r1, [r6]
   37688:	aa01      	add	r2, sp, #4
   3768a:	f7fc ff85 	bl	34598 <memq_peek>
		if (link) {
   3768e:	4604      	mov	r4, r0
   37690:	2800      	cmp	r0, #0
   37692:	d03e      	beq.n	37712 <ull_done+0x9e>
			(void)memq_dequeue(memq_ull_done.tail,
   37694:	6870      	ldr	r0, [r6, #4]
   37696:	2200      	movs	r2, #0
   37698:	4631      	mov	r1, r6
   3769a:	f7fc ff85 	bl	345a8 <memq_dequeue>
			rx_demux_event_done(link, done);
   3769e:	9f01      	ldr	r7, [sp, #4]
	ull_hdr = done->param;
   376a0:	69fd      	ldr	r5, [r7, #28]
	if (ull_hdr) {
   376a2:	b135      	cbz	r5, 376b2 <ull_done+0x3e>
	return hdr->ref;
   376a4:	782b      	ldrb	r3, [r5, #0]
		LL_ASSERT(ull_ref_get(ull_hdr));
   376a6:	2b00      	cmp	r3, #0
   376a8:	d052      	beq.n	37750 <ull_done+0xdc>
	return hdr->ref--;
   376aa:	782b      	ldrb	r3, [r5, #0]
   376ac:	3b01      	subs	r3, #1
   376ae:	b2db      	uxtb	r3, r3
   376b0:	702b      	strb	r3, [r5, #0]
		ull_ref_dec(ull_hdr);
	}

	/* Process role dependent event done */
	switch (done->extra.type) {
   376b2:	f897 3020 	ldrb.w	r3, [r7, #32]
   376b6:	b123      	cbz	r3, 376c2 <ull_done+0x4e>
   376b8:	2b01      	cmp	r3, #1
   376ba:	d13b      	bne.n	37734 <ull_done+0xc0>
#if defined(CONFIG_BT_CONN)
	case EVENT_DONE_EXTRA_TYPE_CONN:
		ull_conn_done(done);
   376bc:	4638      	mov	r0, r7
   376be:	f006 f905 	bl	3d8cc <ull_conn_done>
		break;
	}

	/* Release done */
	done->extra.type = 0U;
	release = RXFIFO_RELEASE(done, link, done);
   376c2:	4a2d      	ldr	r2, [pc, #180]	; (37778 <ull_done+0x104>)
	last = last + 1;
   376c4:	7953      	ldrb	r3, [r2, #5]
	if (last == count) {
   376c6:	f892 c002 	ldrb.w	ip, [r2, #2]
   376ca:	7910      	ldrb	r0, [r2, #4]
	last = last + 1;
   376cc:	3301      	adds	r3, #1
	done->extra.type = 0U;
   376ce:	2100      	movs	r1, #0
   376d0:	b2db      	uxtb	r3, r3
		last = 0U;
   376d2:	459c      	cmp	ip, r3
   376d4:	bf08      	it	eq
   376d6:	460b      	moveq	r3, r1
	if (last == first) {
   376d8:	4298      	cmp	r0, r3
   376da:	f887 1020 	strb.w	r1, [r7, #32]
	release = RXFIFO_RELEASE(done, link, done);
   376de:	7811      	ldrb	r1, [r2, #0]
   376e0:	d01a      	beq.n	37718 <ull_done+0xa4>

	if (!mfifo_enqueue_idx_get(n, f, *l, &idx)) {
		return NULL;
	}

	rx->link = link;
   376e2:	603c      	str	r4, [r7, #0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
   376e4:	7950      	ldrb	r0, [r2, #5]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
   376e6:	fb00 2101 	mla	r1, r0, r1, r2
   376ea:	608f      	str	r7, [r1, #8]
	*last = idx; /* Commit: Update write index */
   376ec:	7153      	strb	r3, [r2, #5]
	if (ull_hdr && !ull_ref_get(ull_hdr) && ull_hdr->disabled_cb) {
   376ee:	2d00      	cmp	r5, #0
   376f0:	d0c8      	beq.n	37684 <ull_done+0x10>
	return hdr->ref;
   376f2:	782b      	ldrb	r3, [r5, #0]
   376f4:	2b00      	cmp	r3, #0
   376f6:	d1c5      	bne.n	37684 <ull_done+0x10>
   376f8:	696b      	ldr	r3, [r5, #20]
   376fa:	2b00      	cmp	r3, #0
   376fc:	d0c2      	beq.n	37684 <ull_done+0x10>
		ull_hdr->disabled_cb(ull_hdr->disabled_param);
   376fe:	69a8      	ldr	r0, [r5, #24]
   37700:	4798      	blx	r3
		link = memq_peek(memq_ull_done.head, memq_ull_done.tail,
   37702:	e9d6 0100 	ldrd	r0, r1, [r6]
   37706:	aa01      	add	r2, sp, #4
   37708:	f7fc ff46 	bl	34598 <memq_peek>
		if (link) {
   3770c:	4604      	mov	r4, r0
   3770e:	2800      	cmp	r0, #0
   37710:	d1c0      	bne.n	37694 <ull_done+0x20>
}
   37712:	b003      	add	sp, #12
   37714:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	LL_ASSERT(release == done);
   37718:	4918      	ldr	r1, [pc, #96]	; (3777c <ull_done+0x108>)
   3771a:	4819      	ldr	r0, [pc, #100]	; (37780 <ull_done+0x10c>)
   3771c:	f640 339a 	movw	r3, #2970	; 0xb9a
   37720:	4642      	mov	r2, r8
   37722:	f011 fcaf 	bl	49084 <assert_print>
   37726:	4040      	eors	r0, r0
   37728:	f380 8811 	msr	BASEPRI, r0
   3772c:	f04f 0003 	mov.w	r0, #3
   37730:	df02      	svc	2
   37732:	e7dc      	b.n	376ee <ull_done+0x7a>
		LL_ASSERT(0);
   37734:	4913      	ldr	r1, [pc, #76]	; (37784 <ull_done+0x110>)
   37736:	4812      	ldr	r0, [pc, #72]	; (37780 <ull_done+0x10c>)
   37738:	f640 3393 	movw	r3, #2963	; 0xb93
   3773c:	4642      	mov	r2, r8
   3773e:	f011 fca1 	bl	49084 <assert_print>
   37742:	4040      	eors	r0, r0
   37744:	f380 8811 	msr	BASEPRI, r0
   37748:	f04f 0003 	mov.w	r0, #3
   3774c:	df02      	svc	2
		break;
   3774e:	e7b8      	b.n	376c2 <ull_done+0x4e>
		LL_ASSERT(ull_ref_get(ull_hdr));
   37750:	480b      	ldr	r0, [pc, #44]	; (37780 <ull_done+0x10c>)
   37752:	f640 333c 	movw	r3, #2876	; 0xb3c
   37756:	4642      	mov	r2, r8
   37758:	4649      	mov	r1, r9
   3775a:	f011 fc93 	bl	49084 <assert_print>
   3775e:	4040      	eors	r0, r0
   37760:	f380 8811 	msr	BASEPRI, r0
   37764:	f04f 0003 	mov.w	r0, #3
   37768:	df02      	svc	2
   3776a:	e79e      	b.n	376aa <ull_done+0x36>
   3776c:	200045cc 	.word	0x200045cc
   37770:	000522f4 	.word	0x000522f4
   37774:	00052338 	.word	0x00052338
   37778:	20000928 	.word	0x20000928
   3777c:	00052350 	.word	0x00052350
   37780:	0005214c 	.word	0x0005214c
   37784:	000521ac 	.word	0x000521ac

00037788 <rx_demux>:
{
   37788:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   3778c:	f8df 81ac 	ldr.w	r8, [pc, #428]	; 3793c <rx_demux+0x1b4>
	k_sem_give(sem_recv);
   37790:	f8df 91ac 	ldr.w	r9, [pc, #428]	; 37940 <rx_demux+0x1b8>
			LL_ASSERT(rx);
   37794:	f8df b1ac 	ldr.w	fp, [pc, #428]	; 37944 <rx_demux+0x1bc>
   37798:	f8df a1ac 	ldr.w	sl, [pc, #428]	; 37948 <rx_demux+0x1c0>
{
   3779c:	b087      	sub	sp, #28
		link = memq_peek(memq_ull_rx.head, memq_ull_rx.tail,
   3779e:	e9d8 0100 	ldrd	r0, r1, [r8]
   377a2:	aa03      	add	r2, sp, #12
   377a4:	f7fc fef8 	bl	34598 <memq_peek>
		if (link) {
   377a8:	4605      	mov	r5, r0
   377aa:	2800      	cmp	r0, #0
   377ac:	d035      	beq.n	3781a <rx_demux+0x92>
			LL_ASSERT(rx);
   377ae:	9b03      	ldr	r3, [sp, #12]
   377b0:	2b00      	cmp	r3, #0
   377b2:	f000 80a6 	beq.w	37902 <rx_demux+0x17a>
			link_tx = ull_conn_ack_by_last_peek(rx->ack_last,
   377b6:	7818      	ldrb	r0, [r3, #0]
   377b8:	aa04      	add	r2, sp, #16
   377ba:	a902      	add	r1, sp, #8
   377bc:	f006 fb5c 	bl	3de78 <ull_conn_ack_by_last_peek>
			if (link_tx) {
   377c0:	4604      	mov	r4, r0
   377c2:	2800      	cmp	r0, #0
   377c4:	d055      	beq.n	37872 <rx_demux+0xea>
				rx_demux_conn_tx_ack(rx->ack_last, handle,
   377c6:	e9dd 1303 	ldrd	r1, r3, [sp, #12]
   377ca:	f8bd 2008 	ldrh.w	r2, [sp, #8]
   377ce:	780f      	ldrb	r7, [r1, #0]
   377d0:	f8ad 200a 	strh.w	r2, [sp, #10]
   377d4:	ae05      	add	r6, sp, #20
   377d6:	9305      	str	r3, [sp, #20]
static inline void rx_demux_conn_tx_ack(uint8_t ack_last, uint16_t handle,
   377d8:	f10d 050a 	add.w	r5, sp, #10
		ull_conn_ack_dequeue();
   377dc:	f006 fb66 	bl	3deac <ull_conn_ack_dequeue>
		ull_conn_tx_ack(handle, link, node_tx);
   377e0:	4621      	mov	r1, r4
   377e2:	9a05      	ldr	r2, [sp, #20]
   377e4:	f8bd 000a 	ldrh.w	r0, [sp, #10]
   377e8:	f006 fba8 	bl	3df3c <ull_conn_tx_ack>
		ull_conn_link_tx_release(link);
   377ec:	4620      	mov	r0, r4
   377ee:	f006 fb1b 	bl	3de28 <ull_conn_link_tx_release>
		link = ull_conn_ack_by_last_peek(ack_last, &handle, &node_tx);
   377f2:	4632      	mov	r2, r6
   377f4:	4629      	mov	r1, r5
   377f6:	4638      	mov	r0, r7
   377f8:	f006 fb3e 	bl	3de78 <ull_conn_ack_by_last_peek>
	} while (link);
   377fc:	4604      	mov	r4, r0
   377fe:	2800      	cmp	r0, #0
   37800:	d1ec      	bne.n	377dc <rx_demux+0x54>
	k_sem_give(sem_recv);
   37802:	f8d9 0000 	ldr.w	r0, [r9]
   37806:	f00f fcb7 	bl	47178 <z_impl_k_sem_give>
		link = memq_peek(memq_ull_rx.head, memq_ull_rx.tail,
   3780a:	e9d8 0100 	ldrd	r0, r1, [r8]
   3780e:	aa03      	add	r2, sp, #12
   37810:	f7fc fec2 	bl	34598 <memq_peek>
		if (link) {
   37814:	4605      	mov	r5, r0
   37816:	2800      	cmp	r0, #0
   37818:	d1c9      	bne.n	377ae <rx_demux+0x26>
			link = ull_conn_ack_peek(&ack_last, &handle, &node_tx);
   3781a:	aa04      	add	r2, sp, #16
   3781c:	a902      	add	r1, sp, #8
   3781e:	f10d 0007 	add.w	r0, sp, #7
   37822:	f006 fb0d 	bl	3de40 <ull_conn_ack_peek>
			if (link) {
   37826:	4604      	mov	r4, r0
   37828:	2800      	cmp	r0, #0
   3782a:	d067      	beq.n	378fc <rx_demux+0x174>
				rx_demux_conn_tx_ack(ack_last, handle,
   3782c:	9b04      	ldr	r3, [sp, #16]
   3782e:	9305      	str	r3, [sp, #20]
   37830:	f89d 7007 	ldrb.w	r7, [sp, #7]
static inline void rx_demux_conn_tx_ack(uint8_t ack_last, uint16_t handle,
   37834:	f8bd 3008 	ldrh.w	r3, [sp, #8]
   37838:	f8ad 300a 	strh.w	r3, [sp, #10]
   3783c:	ae05      	add	r6, sp, #20
   3783e:	f10d 050a 	add.w	r5, sp, #10
		ull_conn_ack_dequeue();
   37842:	f006 fb33 	bl	3deac <ull_conn_ack_dequeue>
		ull_conn_tx_ack(handle, link, node_tx);
   37846:	4621      	mov	r1, r4
   37848:	9a05      	ldr	r2, [sp, #20]
   3784a:	f8bd 000a 	ldrh.w	r0, [sp, #10]
   3784e:	f006 fb75 	bl	3df3c <ull_conn_tx_ack>
		ull_conn_link_tx_release(link);
   37852:	4620      	mov	r0, r4
   37854:	f006 fae8 	bl	3de28 <ull_conn_link_tx_release>
		link = ull_conn_ack_by_last_peek(ack_last, &handle, &node_tx);
   37858:	4632      	mov	r2, r6
   3785a:	4629      	mov	r1, r5
   3785c:	4638      	mov	r0, r7
   3785e:	f006 fb0b 	bl	3de78 <ull_conn_ack_by_last_peek>
	} while (link);
   37862:	4604      	mov	r4, r0
   37864:	2800      	cmp	r0, #0
   37866:	d1ec      	bne.n	37842 <rx_demux+0xba>
	k_sem_give(sem_recv);
   37868:	f8d9 0000 	ldr.w	r0, [r9]
   3786c:	f00f fc84 	bl	47178 <z_impl_k_sem_give>
	} while (link);
   37870:	e7cb      	b.n	3780a <rx_demux+0x82>
				nack = rx_demux_rx(link, rx);
   37872:	9b03      	ldr	r3, [sp, #12]
   37874:	9305      	str	r3, [sp, #20]
	switch (rx->type) {
   37876:	791b      	ldrb	r3, [r3, #4]
   37878:	3b01      	subs	r3, #1
   3787a:	2b17      	cmp	r3, #23
   3787c:	d80d      	bhi.n	3789a <rx_demux+0x112>
   3787e:	e8df f003 	tbb	[pc, r3]
   37882:	0c1a      	.short	0x0c1a
   37884:	0c1a0c38 	.word	0x0c1a0c38
   37888:	0c0c0c0c 	.word	0x0c0c0c0c
   3788c:	0c0c0c0c 	.word	0x0c0c0c0c
   37890:	0c0c0c0c 	.word	0x0c0c0c0c
   37894:	0c0c0c0c 	.word	0x0c0c0c0c
   37898:	1a2d      	.short	0x1a2d
		LL_ASSERT(0);
   3789a:	4a2a      	ldr	r2, [pc, #168]	; (37944 <rx_demux+0x1bc>)
   3789c:	492b      	ldr	r1, [pc, #172]	; (3794c <rx_demux+0x1c4>)
   3789e:	482c      	ldr	r0, [pc, #176]	; (37950 <rx_demux+0x1c8>)
   378a0:	f640 3329 	movw	r3, #2857	; 0xb29
   378a4:	f011 fbee 	bl	49084 <assert_print>
   378a8:	4040      	eors	r0, r0
   378aa:	f380 8811 	msr	BASEPRI, r0
   378ae:	f04f 0003 	mov.w	r0, #3
   378b2:	df02      	svc	2
			if (nack) {
   378b4:	e773      	b.n	3779e <rx_demux+0x16>
		(void)memq_dequeue(memq_ull_rx.tail, &memq_ull_rx.head, NULL);
   378b6:	4921      	ldr	r1, [pc, #132]	; (3793c <rx_demux+0x1b4>)
   378b8:	f8d8 0004 	ldr.w	r0, [r8, #4]
   378bc:	2200      	movs	r2, #0
   378be:	f7fc fe73 	bl	345a8 <memq_dequeue>
	rx_hdr->ack_last = mfifo_tx_ack.l;
   378c2:	4b24      	ldr	r3, [pc, #144]	; (37954 <rx_demux+0x1cc>)
		ll_rx_put(link, rx);
   378c4:	9905      	ldr	r1, [sp, #20]
	rx_hdr->ack_last = mfifo_tx_ack.l;
   378c6:	795b      	ldrb	r3, [r3, #5]
	memq_enqueue(link, rx, &memq_ll_rx.tail);
   378c8:	4628      	mov	r0, r5
	rx_hdr->ack_last = mfifo_tx_ack.l;
   378ca:	700b      	strb	r3, [r1, #0]
	memq_enqueue(link, rx, &memq_ll_rx.tail);
   378cc:	4a22      	ldr	r2, [pc, #136]	; (37958 <rx_demux+0x1d0>)
   378ce:	f7fc fe59 	bl	34584 <memq_enqueue>
	k_sem_give(sem_recv);
   378d2:	4b1b      	ldr	r3, [pc, #108]	; (37940 <rx_demux+0x1b8>)
   378d4:	6818      	ldr	r0, [r3, #0]
   378d6:	f00f fc4f 	bl	47178 <z_impl_k_sem_give>
			if (nack) {
   378da:	e760      	b.n	3779e <rx_demux+0x16>
		(void)memq_dequeue(memq_ull_rx.tail, &memq_ull_rx.head, NULL);
   378dc:	4917      	ldr	r1, [pc, #92]	; (3793c <rx_demux+0x1b4>)
   378de:	f8d8 0004 	ldr.w	r0, [r8, #4]
   378e2:	2200      	movs	r2, #0
   378e4:	f7fc fe60 	bl	345a8 <memq_dequeue>
		ull_conn_setup(link, rx);
   378e8:	9905      	ldr	r1, [sp, #20]
   378ea:	4628      	mov	r0, r5
   378ec:	f002 ff9c 	bl	3a828 <ull_conn_setup>
			if (nack) {
   378f0:	e755      	b.n	3779e <rx_demux+0x16>
		nack = ull_conn_rx(link, (void *)&rx);
   378f2:	a905      	add	r1, sp, #20
   378f4:	4628      	mov	r0, r5
   378f6:	f002 ffbf 	bl	3a878 <ull_conn_rx>
		if (nack) {
   378fa:	b188      	cbz	r0, 37920 <rx_demux+0x198>
}
   378fc:	b007      	add	sp, #28
   378fe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			LL_ASSERT(rx);
   37902:	4813      	ldr	r0, [pc, #76]	; (37950 <rx_demux+0x1c8>)
   37904:	f640 1377 	movw	r3, #2423	; 0x977
   37908:	465a      	mov	r2, fp
   3790a:	4651      	mov	r1, sl
   3790c:	f011 fbba 	bl	49084 <assert_print>
   37910:	4040      	eors	r0, r0
   37912:	f380 8811 	msr	BASEPRI, r0
   37916:	f04f 0003 	mov.w	r0, #3
   3791a:	df02      	svc	2
			link_tx = ull_conn_ack_by_last_peek(rx->ack_last,
   3791c:	9b03      	ldr	r3, [sp, #12]
   3791e:	e74a      	b.n	377b6 <rx_demux+0x2e>
		(void)memq_dequeue(memq_ull_rx.tail, &memq_ull_rx.head, NULL);
   37920:	4906      	ldr	r1, [pc, #24]	; (3793c <rx_demux+0x1b4>)
   37922:	4602      	mov	r2, r0
   37924:	f8d8 0004 	ldr.w	r0, [r8, #4]
   37928:	f7fc fe3e 	bl	345a8 <memq_dequeue>
		if (rx) {
   3792c:	9905      	ldr	r1, [sp, #20]
   3792e:	2900      	cmp	r1, #0
   37930:	f43f af35 	beq.w	3779e <rx_demux+0x16>
	rx_hdr->ack_last = mfifo_tx_ack.l;
   37934:	4b07      	ldr	r3, [pc, #28]	; (37954 <rx_demux+0x1cc>)
	memq_enqueue(link, rx, &memq_ll_rx.tail);
   37936:	4628      	mov	r0, r5
	rx_hdr->ack_last = mfifo_tx_ack.l;
   37938:	795b      	ldrb	r3, [r3, #5]
   3793a:	e7c6      	b.n	378ca <rx_demux+0x142>
   3793c:	200045dc 	.word	0x200045dc
   37940:	20004bf0 	.word	0x20004bf0
   37944:	000522f4 	.word	0x000522f4
   37948:	00052360 	.word	0x00052360
   3794c:	000521ac 	.word	0x000521ac
   37950:	0005214c 	.word	0x0005214c
   37954:	200007d0 	.word	0x200007d0
   37958:	200045d8 	.word	0x200045d8

0003795c <ll_rx_get>:
{
   3795c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		cmplt = tx_cmplt_get(handle, &mfifo_tx_ack.f, rx->ack_last);
   37960:	f8df a0cc 	ldr.w	sl, [pc, #204]	; 37a30 <ll_rx_get+0xd4>
   37964:	4f33      	ldr	r7, [pc, #204]	; (37a34 <ll_rx_get+0xd8>)
{
   37966:	b082      	sub	sp, #8
   37968:	4680      	mov	r8, r0
   3796a:	4689      	mov	r9, r1
			f = mfifo_tx_ack.f;
   3796c:	f1aa 0504 	sub.w	r5, sl, #4
	*node_rx = NULL;
   37970:	2300      	movs	r3, #0
   37972:	f8c8 3000 	str.w	r3, [r8]
	link = memq_peek(memq_ll_rx.head, memq_ll_rx.tail, (void **)&rx);
   37976:	e9d7 0100 	ldrd	r0, r1, [r7]
   3797a:	aa01      	add	r2, sp, #4
   3797c:	f7fc fe0c 	bl	34598 <memq_peek>
	if (link) {
   37980:	4606      	mov	r6, r0
   37982:	2800      	cmp	r0, #0
   37984:	d042      	beq.n	37a0c <ll_rx_get+0xb0>
		cmplt = tx_cmplt_get(handle, &mfifo_tx_ack.f, rx->ack_last);
   37986:	9b01      	ldr	r3, [sp, #4]
   37988:	4651      	mov	r1, sl
   3798a:	781a      	ldrb	r2, [r3, #0]
   3798c:	4648      	mov	r0, r9
   3798e:	f7ff fd8f 	bl	374b0 <tx_cmplt_get>
		if (!cmplt) {
   37992:	4603      	mov	r3, r0
   37994:	2800      	cmp	r0, #0
   37996:	d140      	bne.n	37a1a <ll_rx_get+0xbe>
			f = mfifo_tx_ack.f;
   37998:	792a      	ldrb	r2, [r5, #4]
   3799a:	f88d 2001 	strb.w	r2, [sp, #1]
				cmplt_curr = tx_cmplt_get(&h, &f,
   3799e:	796a      	ldrb	r2, [r5, #5]
   379a0:	f10d 0101 	add.w	r1, sp, #1
   379a4:	f10d 0002 	add.w	r0, sp, #2
   379a8:	461c      	mov	r4, r3
   379aa:	f7ff fd81 	bl	374b0 <tx_cmplt_get>
   379ae:	ea44 0200 	orr.w	r2, r4, r0
			} while ((cmplt_prev != 0U) ||
   379b2:	f012 02ff 	ands.w	r2, r2, #255	; 0xff
				cmplt_curr = tx_cmplt_get(&h, &f,
   379b6:	4603      	mov	r3, r0
			} while ((cmplt_prev != 0U) ||
   379b8:	d1f1      	bne.n	3799e <ll_rx_get+0x42>
			} else if (rx->type == NODE_RX_TYPE_RELEASE) {
   379ba:	9b01      	ldr	r3, [sp, #4]
   379bc:	7919      	ldrb	r1, [r3, #4]
   379be:	2901      	cmp	r1, #1
   379c0:	d12f      	bne.n	37a22 <ll_rx_get+0xc6>
	LL_ASSERT(delta <= 0 || mem_link_rx.quota_pdu < RX_CNT);
   379c2:	4c1d      	ldr	r4, [pc, #116]	; (37a38 <ll_rx_get+0xdc>)
	(void)memq_dequeue(memq_ll_rx.tail,
   379c4:	6878      	ldr	r0, [r7, #4]
   379c6:	4639      	mov	r1, r7
   379c8:	f7fc fdee 	bl	345a8 <memq_dequeue>
	mem_release(link, &mem_link_rx.free);
   379cc:	1d21      	adds	r1, r4, #4
   379ce:	4630      	mov	r0, r6
   379d0:	f7fc fd8e 	bl	344f0 <mem_release>
	LL_ASSERT(delta <= 0 || mem_link_rx.quota_pdu < RX_CNT);
   379d4:	8823      	ldrh	r3, [r4, #0]
   379d6:	2b0f      	cmp	r3, #15
   379d8:	d809      	bhi.n	379ee <ll_rx_get+0x92>
	mem_release(node_rx, &mem_pdu_rx.free);
   379da:	9801      	ldr	r0, [sp, #4]
   379dc:	4917      	ldr	r1, [pc, #92]	; (37a3c <ll_rx_get+0xe0>)
	mem_link_rx.quota_pdu += delta;
   379de:	3301      	adds	r3, #1
   379e0:	8023      	strh	r3, [r4, #0]
	mem_release(node_rx, &mem_pdu_rx.free);
   379e2:	f7fc fd85 	bl	344f0 <mem_release>
	rx_replenish(1U);
   379e6:	2001      	movs	r0, #1
   379e8:	f7ff fdbc 	bl	37564 <rx_replenish>
				goto ll_rx_get_again;
   379ec:	e7c0      	b.n	37970 <ll_rx_get+0x14>
	LL_ASSERT(delta <= 0 || mem_link_rx.quota_pdu < RX_CNT);
   379ee:	4a14      	ldr	r2, [pc, #80]	; (37a40 <ll_rx_get+0xe4>)
   379f0:	4914      	ldr	r1, [pc, #80]	; (37a44 <ll_rx_get+0xe8>)
   379f2:	4815      	ldr	r0, [pc, #84]	; (37a48 <ll_rx_get+0xec>)
   379f4:	f240 6375 	movw	r3, #1653	; 0x675
   379f8:	f011 fb44 	bl	49084 <assert_print>
   379fc:	4040      	eors	r0, r0
   379fe:	f380 8811 	msr	BASEPRI, r0
   37a02:	f04f 0003 	mov.w	r0, #3
   37a06:	df02      	svc	2
	mem_link_rx.quota_pdu += delta;
   37a08:	8823      	ldrh	r3, [r4, #0]
   37a0a:	e7e6      	b.n	379da <ll_rx_get+0x7e>
		cmplt = tx_cmplt_get(handle, &mfifo_tx_ack.f, mfifo_tx_ack.l);
   37a0c:	490f      	ldr	r1, [pc, #60]	; (37a4c <ll_rx_get+0xf0>)
   37a0e:	4648      	mov	r0, r9
   37a10:	794a      	ldrb	r2, [r1, #5]
   37a12:	3104      	adds	r1, #4
   37a14:	f7ff fd4c 	bl	374b0 <tx_cmplt_get>
   37a18:	4603      	mov	r3, r0
}
   37a1a:	4618      	mov	r0, r3
   37a1c:	b002      	add	sp, #8
   37a1e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			*node_rx = rx;
   37a22:	f8c8 3000 	str.w	r3, [r8]
		cmplt = tx_cmplt_get(handle, &mfifo_tx_ack.f, rx->ack_last);
   37a26:	4613      	mov	r3, r2
}
   37a28:	4618      	mov	r0, r3
   37a2a:	b002      	add	sp, #8
   37a2c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   37a30:	200007d4 	.word	0x200007d4
   37a34:	200045d4 	.word	0x200045d4
   37a38:	200045e4 	.word	0x200045e4
   37a3c:	200046b4 	.word	0x200046b4
   37a40:	000522f4 	.word	0x000522f4
   37a44:	00052364 	.word	0x00052364
   37a48:	0005214c 	.word	0x0005214c
   37a4c:	200007d0 	.word	0x200007d0

00037a50 <ll_rx_dequeue>:
{
   37a50:	b570      	push	{r4, r5, r6, lr}
	link = memq_dequeue(memq_ll_rx.tail, &memq_ll_rx.head,
   37a52:	4951      	ldr	r1, [pc, #324]	; (37b98 <ll_rx_dequeue+0x148>)
{
   37a54:	b082      	sub	sp, #8
	struct node_rx_hdr *rx = NULL;
   37a56:	2300      	movs	r3, #0
	link = memq_dequeue(memq_ll_rx.tail, &memq_ll_rx.head,
   37a58:	6848      	ldr	r0, [r1, #4]
	struct node_rx_hdr *rx = NULL;
   37a5a:	9301      	str	r3, [sp, #4]
	link = memq_dequeue(memq_ll_rx.tail, &memq_ll_rx.head,
   37a5c:	aa01      	add	r2, sp, #4
   37a5e:	f7fc fda3 	bl	345a8 <memq_dequeue>
	LL_ASSERT(link);
   37a62:	4604      	mov	r4, r0
   37a64:	2800      	cmp	r0, #0
   37a66:	d04c      	beq.n	37b02 <ll_rx_dequeue+0xb2>
	mem_release(link, &mem_link_rx.free);
   37a68:	494c      	ldr	r1, [pc, #304]	; (37b9c <ll_rx_dequeue+0x14c>)
   37a6a:	4620      	mov	r0, r4
   37a6c:	f7fc fd40 	bl	344f0 <mem_release>
	switch (rx->type) {
   37a70:	9901      	ldr	r1, [sp, #4]
   37a72:	790a      	ldrb	r2, [r1, #4]
   37a74:	2a1d      	cmp	r2, #29
   37a76:	d806      	bhi.n	37a86 <ll_rx_dequeue+0x36>
   37a78:	4849      	ldr	r0, [pc, #292]	; (37ba0 <ll_rx_dequeue+0x150>)
   37a7a:	2301      	movs	r3, #1
   37a7c:	4093      	lsls	r3, r2
   37a7e:	4003      	ands	r3, r0
   37a80:	d125      	bne.n	37ace <ll_rx_dequeue+0x7e>
   37a82:	2a17      	cmp	r2, #23
   37a84:	d00e      	beq.n	37aa4 <ll_rx_dequeue+0x54>
		LL_ASSERT(0);
   37a86:	4a47      	ldr	r2, [pc, #284]	; (37ba4 <ll_rx_dequeue+0x154>)
   37a88:	4947      	ldr	r1, [pc, #284]	; (37ba8 <ll_rx_dequeue+0x158>)
   37a8a:	4848      	ldr	r0, [pc, #288]	; (37bac <ll_rx_dequeue+0x15c>)
   37a8c:	f240 5334 	movw	r3, #1332	; 0x534
   37a90:	f011 faf8 	bl	49084 <assert_print>
   37a94:	4040      	eors	r0, r0
   37a96:	f380 8811 	msr	BASEPRI, r0
   37a9a:	f04f 0003 	mov.w	r0, #3
   37a9e:	df02      	svc	2
}
   37aa0:	b002      	add	sp, #8
   37aa2:	bd70      	pop	{r4, r5, r6, pc}
		} else if ((cc->status == BT_HCI_ERR_ADV_TIMEOUT) || cc->role) {
   37aa4:	7f0a      	ldrb	r2, [r1, #28]
			lll = ftr->param;
   37aa6:	688d      	ldr	r5, [r1, #8]
		} else if ((cc->status == BT_HCI_ERR_ADV_TIMEOUT) || cc->role) {
   37aa8:	2a3c      	cmp	r2, #60	; 0x3c
			adv = HDR_LLL2ULL(lll);
   37aaa:	682c      	ldr	r4, [r5, #0]
		} else if ((cc->status == BT_HCI_ERR_ADV_TIMEOUT) || cc->role) {
   37aac:	d037      	beq.n	37b1e <ll_rx_dequeue+0xce>
   37aae:	7f4a      	ldrb	r2, [r1, #29]
   37ab0:	b1f2      	cbz	r2, 37af0 <ll_rx_dequeue+0xa0>
				if (adv->node_rx_cc_free) {
   37ab2:	6e60      	ldr	r0, [r4, #100]	; 0x64
   37ab4:	b118      	cbz	r0, 37abe <ll_rx_dequeue+0x6e>
	mem_release(node_rx, &mem_pdu_rx.free);
   37ab6:	493e      	ldr	r1, [pc, #248]	; (37bb0 <ll_rx_dequeue+0x160>)
					adv->node_rx_cc_free = NULL;
   37ab8:	6663      	str	r3, [r4, #100]	; 0x64
	mem_release(node_rx, &mem_pdu_rx.free);
   37aba:	f7fc fd19 	bl	344f0 <mem_release>
			adv->is_enabled = 0U;
   37abe:	f894 306a 	ldrb.w	r3, [r4, #106]	; 0x6a
   37ac2:	f36f 0300 	bfc	r3, #0, #1
   37ac6:	f884 306a 	strb.w	r3, [r4, #106]	; 0x6a
}
   37aca:	b002      	add	sp, #8
   37acc:	bd70      	pop	{r4, r5, r6, pc}
		LL_ASSERT(rx->type != NODE_RX_TYPE_NONE);
   37ace:	2a00      	cmp	r2, #0
   37ad0:	d1e6      	bne.n	37aa0 <ll_rx_dequeue+0x50>
   37ad2:	4a34      	ldr	r2, [pc, #208]	; (37ba4 <ll_rx_dequeue+0x154>)
   37ad4:	4937      	ldr	r1, [pc, #220]	; (37bb4 <ll_rx_dequeue+0x164>)
   37ad6:	4835      	ldr	r0, [pc, #212]	; (37bac <ll_rx_dequeue+0x15c>)
   37ad8:	f44f 63a6 	mov.w	r3, #1328	; 0x530
   37adc:	f011 fad2 	bl	49084 <assert_print>
   37ae0:	4040      	eors	r0, r0
   37ae2:	f380 8811 	msr	BASEPRI, r0
   37ae6:	f04f 0003 	mov.w	r0, #3
   37aea:	df02      	svc	2
}
   37aec:	b002      	add	sp, #8
   37aee:	bd70      	pop	{r4, r5, r6, pc}
			scan->is_enabled = 0U;
   37af0:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
			scan->lll.conn = NULL;
   37af4:	6222      	str	r2, [r4, #32]
			scan->is_enabled = 0U;
   37af6:	f362 0300 	bfi	r3, r2, #0, #1
   37afa:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
}
   37afe:	b002      	add	sp, #8
   37b00:	bd70      	pop	{r4, r5, r6, pc}
	LL_ASSERT(link);
   37b02:	4a28      	ldr	r2, [pc, #160]	; (37ba4 <ll_rx_dequeue+0x154>)
   37b04:	492c      	ldr	r1, [pc, #176]	; (37bb8 <ll_rx_dequeue+0x168>)
   37b06:	4829      	ldr	r0, [pc, #164]	; (37bac <ll_rx_dequeue+0x15c>)
   37b08:	f240 430a 	movw	r3, #1034	; 0x40a
   37b0c:	f011 faba 	bl	49084 <assert_print>
   37b10:	4040      	eors	r0, r0
   37b12:	f380 8811 	msr	BASEPRI, r0
   37b16:	f04f 0003 	mov.w	r0, #3
   37b1a:	df02      	svc	2
   37b1c:	e7a4      	b.n	37a68 <ll_rx_dequeue+0x18>
				conn_lll = lll->conn;
   37b1e:	686e      	ldr	r6, [r5, #4]
				LL_ASSERT(conn_lll);
   37b20:	b1ee      	cbz	r6, 37b5e <ll_rx_dequeue+0x10e>
				lll->conn = NULL;
   37b22:	2300      	movs	r3, #0
   37b24:	606b      	str	r3, [r5, #4]
				LL_ASSERT(!conn_lll->link_tx_free);
   37b26:	6db3      	ldr	r3, [r6, #88]	; 0x58
   37b28:	b163      	cbz	r3, 37b44 <ll_rx_dequeue+0xf4>
   37b2a:	4a1e      	ldr	r2, [pc, #120]	; (37ba4 <ll_rx_dequeue+0x154>)
   37b2c:	4923      	ldr	r1, [pc, #140]	; (37bbc <ll_rx_dequeue+0x16c>)
   37b2e:	481f      	ldr	r0, [pc, #124]	; (37bac <ll_rx_dequeue+0x15c>)
   37b30:	f240 4383 	movw	r3, #1155	; 0x483
   37b34:	f011 faa6 	bl	49084 <assert_print>
   37b38:	4040      	eors	r0, r0
   37b3a:	f380 8811 	msr	BASEPRI, r0
   37b3e:	f04f 0003 	mov.w	r0, #3
   37b42:	df02      	svc	2
				link = memq_deinit(&conn_lll->memq_tx.head,
   37b44:	f106 014c 	add.w	r1, r6, #76	; 0x4c
   37b48:	f106 0048 	add.w	r0, r6, #72	; 0x48
   37b4c:	f7fc fd10 	bl	34570 <memq_deinit>
				LL_ASSERT(link);
   37b50:	4605      	mov	r5, r0
   37b52:	b190      	cbz	r0, 37b7a <ll_rx_dequeue+0x12a>
				ll_conn_release(conn);
   37b54:	6830      	ldr	r0, [r6, #0]
				conn_lll->link_tx_free = link;
   37b56:	65b5      	str	r5, [r6, #88]	; 0x58
				ll_conn_release(conn);
   37b58:	f002 fab2 	bl	3a0c0 <ll_conn_release>
   37b5c:	e7af      	b.n	37abe <ll_rx_dequeue+0x6e>
				LL_ASSERT(conn_lll);
   37b5e:	4a11      	ldr	r2, [pc, #68]	; (37ba4 <ll_rx_dequeue+0x154>)
   37b60:	4917      	ldr	r1, [pc, #92]	; (37bc0 <ll_rx_dequeue+0x170>)
   37b62:	4812      	ldr	r0, [pc, #72]	; (37bac <ll_rx_dequeue+0x15c>)
   37b64:	f44f 6390 	mov.w	r3, #1152	; 0x480
   37b68:	f011 fa8c 	bl	49084 <assert_print>
   37b6c:	4040      	eors	r0, r0
   37b6e:	f380 8811 	msr	BASEPRI, r0
   37b72:	f04f 0003 	mov.w	r0, #3
   37b76:	df02      	svc	2
   37b78:	e7d3      	b.n	37b22 <ll_rx_dequeue+0xd2>
				LL_ASSERT(link);
   37b7a:	4a0a      	ldr	r2, [pc, #40]	; (37ba4 <ll_rx_dequeue+0x154>)
   37b7c:	490e      	ldr	r1, [pc, #56]	; (37bb8 <ll_rx_dequeue+0x168>)
   37b7e:	480b      	ldr	r0, [pc, #44]	; (37bac <ll_rx_dequeue+0x15c>)
   37b80:	f240 4386 	movw	r3, #1158	; 0x486
   37b84:	f011 fa7e 	bl	49084 <assert_print>
   37b88:	4040      	eors	r0, r0
   37b8a:	f380 8811 	msr	BASEPRI, r0
   37b8e:	f04f 0003 	mov.w	r0, #3
   37b92:	df02      	svc	2
   37b94:	e7de      	b.n	37b54 <ll_rx_dequeue+0x104>
   37b96:	bf00      	nop
   37b98:	200045d4 	.word	0x200045d4
   37b9c:	200045e8 	.word	0x200045e8
   37ba0:	3f000029 	.word	0x3f000029
   37ba4:	000522f4 	.word	0x000522f4
   37ba8:	000521ac 	.word	0x000521ac
   37bac:	0005214c 	.word	0x0005214c
   37bb0:	200046b4 	.word	0x200046b4
   37bb4:	000523c8 	.word	0x000523c8
   37bb8:	000526f4 	.word	0x000526f4
   37bbc:	000523b0 	.word	0x000523b0
   37bc0:	000523a4 	.word	0x000523a4

00037bc4 <ll_rx_mem_release>:
{
   37bc4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	rx = *node_rx;
   37bc8:	6804      	ldr	r4, [r0, #0]
{
   37bca:	4680      	mov	r8, r0
	while (rx) {
   37bcc:	b304      	cbz	r4, 37c10 <ll_rx_mem_release+0x4c>
			LL_ASSERT(0);
   37bce:	4f56      	ldr	r7, [pc, #344]	; (37d28 <ll_rx_mem_release+0x164>)
   37bd0:	f8df 9158 	ldr.w	r9, [pc, #344]	; 37d2c <ll_rx_mem_release+0x168>
   37bd4:	4e56      	ldr	r6, [pc, #344]	; (37d30 <ll_rx_mem_release+0x16c>)
		rx = rx->next;
   37bd6:	4625      	mov	r5, r4
   37bd8:	6824      	ldr	r4, [r4, #0]
		switch (rx_free->type) {
   37bda:	792b      	ldrb	r3, [r5, #4]
   37bdc:	2b1d      	cmp	r3, #29
   37bde:	d808      	bhi.n	37bf2 <ll_rx_mem_release+0x2e>
   37be0:	4954      	ldr	r1, [pc, #336]	; (37d34 <ll_rx_mem_release+0x170>)
   37be2:	2201      	movs	r2, #1
   37be4:	409a      	lsls	r2, r3
   37be6:	420a      	tst	r2, r1
   37be8:	d12e      	bne.n	37c48 <ll_rx_mem_release+0x84>
   37bea:	2b18      	cmp	r3, #24
   37bec:	d04a      	beq.n	37c84 <ll_rx_mem_release+0xc0>
   37bee:	2b17      	cmp	r3, #23
   37bf0:	d016      	beq.n	37c20 <ll_rx_mem_release+0x5c>
			LL_ASSERT(0);
   37bf2:	f240 6369 	movw	r3, #1641	; 0x669
   37bf6:	463a      	mov	r2, r7
   37bf8:	4649      	mov	r1, r9
   37bfa:	4630      	mov	r0, r6
   37bfc:	f011 fa42 	bl	49084 <assert_print>
   37c00:	4040      	eors	r0, r0
   37c02:	f380 8811 	msr	BASEPRI, r0
   37c06:	f04f 0003 	mov.w	r0, #3
   37c0a:	df02      	svc	2
	while (rx) {
   37c0c:	2c00      	cmp	r4, #0
   37c0e:	d1e2      	bne.n	37bd6 <ll_rx_mem_release+0x12>
	*node_rx = rx;
   37c10:	2300      	movs	r3, #0
   37c12:	f8c8 3000 	str.w	r3, [r8]
}
   37c16:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	rx_replenish(UINT8_MAX);
   37c1a:	20ff      	movs	r0, #255	; 0xff
   37c1c:	f7ff bca2 	b.w	37564 <rx_replenish>
			} else if (cc->status == BT_HCI_ERR_ADV_TIMEOUT) {
   37c20:	7f2b      	ldrb	r3, [r5, #28]
   37c22:	2b3c      	cmp	r3, #60	; 0x3c
   37c24:	d063      	beq.n	37cee <ll_rx_mem_release+0x12a>
			} else if (cc->status == BT_HCI_ERR_UNKNOWN_CONN_ID) {
   37c26:	2b02      	cmp	r3, #2
   37c28:	d069      	beq.n	37cfe <ll_rx_mem_release+0x13a>
				LL_ASSERT(!cc->status);
   37c2a:	b1db      	cbz	r3, 37c64 <ll_rx_mem_release+0xa0>
   37c2c:	4a3e      	ldr	r2, [pc, #248]	; (37d28 <ll_rx_mem_release+0x164>)
   37c2e:	4942      	ldr	r1, [pc, #264]	; (37d38 <ll_rx_mem_release+0x174>)
   37c30:	483f      	ldr	r0, [pc, #252]	; (37d30 <ll_rx_mem_release+0x16c>)
   37c32:	f44f 63b3 	mov.w	r3, #1432	; 0x598
   37c36:	f011 fa25 	bl	49084 <assert_print>
   37c3a:	4040      	eors	r0, r0
   37c3c:	f380 8811 	msr	BASEPRI, r0
   37c40:	f04f 0003 	mov.w	r0, #3
   37c44:	df02      	svc	2
			LL_ASSERT(rx_free->type != NODE_RX_TYPE_NONE);
   37c46:	792b      	ldrb	r3, [r5, #4]
   37c48:	b963      	cbnz	r3, 37c64 <ll_rx_mem_release+0xa0>
   37c4a:	493c      	ldr	r1, [pc, #240]	; (37d3c <ll_rx_mem_release+0x178>)
   37c4c:	f240 53ea 	movw	r3, #1514	; 0x5ea
   37c50:	463a      	mov	r2, r7
   37c52:	4630      	mov	r0, r6
   37c54:	f011 fa16 	bl	49084 <assert_print>
   37c58:	4040      	eors	r0, r0
   37c5a:	f380 8811 	msr	BASEPRI, r0
   37c5e:	f04f 0003 	mov.w	r0, #3
   37c62:	df02      	svc	2
	LL_ASSERT(delta <= 0 || mem_link_rx.quota_pdu < RX_CNT);
   37c64:	f8df a0d8 	ldr.w	sl, [pc, #216]	; 37d40 <ll_rx_mem_release+0x17c>
   37c68:	f8ba 3000 	ldrh.w	r3, [sl]
   37c6c:	2b0f      	cmp	r3, #15
   37c6e:	d82e      	bhi.n	37cce <ll_rx_mem_release+0x10a>
	mem_link_rx.quota_pdu += delta;
   37c70:	3301      	adds	r3, #1
	mem_release(node_rx, &mem_pdu_rx.free);
   37c72:	4934      	ldr	r1, [pc, #208]	; (37d44 <ll_rx_mem_release+0x180>)
	mem_link_rx.quota_pdu += delta;
   37c74:	f8aa 3000 	strh.w	r3, [sl]
	mem_release(node_rx, &mem_pdu_rx.free);
   37c78:	4628      	mov	r0, r5
   37c7a:	f7fc fc39 	bl	344f0 <mem_release>
	while (rx) {
   37c7e:	2c00      	cmp	r4, #0
   37c80:	d1a9      	bne.n	37bd6 <ll_rx_mem_release+0x12>
   37c82:	e7c5      	b.n	37c10 <ll_rx_mem_release+0x4c>
			if (IS_ACL_HANDLE(rx_free->handle)) {
   37c84:	88e8      	ldrh	r0, [r5, #6]
   37c86:	2805      	cmp	r0, #5
   37c88:	d8c0      	bhi.n	37c0c <ll_rx_mem_release+0x48>
				conn = ll_conn_get(rx_free->handle);
   37c8a:	f002 fa27 	bl	3a0dc <ll_conn_get>
				LL_ASSERT(!conn->lll.link_tx_free);
   37c8e:	6f43      	ldr	r3, [r0, #116]	; 0x74
				conn = ll_conn_get(rx_free->handle);
   37c90:	4605      	mov	r5, r0
				LL_ASSERT(!conn->lll.link_tx_free);
   37c92:	b163      	cbz	r3, 37cae <ll_rx_mem_release+0xea>
   37c94:	4a24      	ldr	r2, [pc, #144]	; (37d28 <ll_rx_mem_release+0x164>)
   37c96:	492c      	ldr	r1, [pc, #176]	; (37d48 <ll_rx_mem_release+0x184>)
   37c98:	4825      	ldr	r0, [pc, #148]	; (37d30 <ll_rx_mem_release+0x16c>)
   37c9a:	f240 635b 	movw	r3, #1627	; 0x65b
   37c9e:	f011 f9f1 	bl	49084 <assert_print>
   37ca2:	4040      	eors	r0, r0
   37ca4:	f380 8811 	msr	BASEPRI, r0
   37ca8:	f04f 0003 	mov.w	r0, #3
   37cac:	df02      	svc	2
				link = memq_deinit(&conn->lll.memq_tx.head,
   37cae:	f105 0168 	add.w	r1, r5, #104	; 0x68
   37cb2:	f105 0064 	add.w	r0, r5, #100	; 0x64
   37cb6:	f7fc fc5b 	bl	34570 <memq_deinit>
				LL_ASSERT(link);
   37cba:	4682      	mov	sl, r0
   37cbc:	b330      	cbz	r0, 37d0c <ll_rx_mem_release+0x148>
				conn->lll.link_tx_free = link;
   37cbe:	f8c5 a074 	str.w	sl, [r5, #116]	; 0x74
				ll_conn_release(conn);
   37cc2:	4628      	mov	r0, r5
   37cc4:	f002 f9fc 	bl	3a0c0 <ll_conn_release>
	while (rx) {
   37cc8:	2c00      	cmp	r4, #0
   37cca:	d184      	bne.n	37bd6 <ll_rx_mem_release+0x12>
   37ccc:	e7a0      	b.n	37c10 <ll_rx_mem_release+0x4c>
	LL_ASSERT(delta <= 0 || mem_link_rx.quota_pdu < RX_CNT);
   37cce:	491f      	ldr	r1, [pc, #124]	; (37d4c <ll_rx_mem_release+0x188>)
   37cd0:	f240 6375 	movw	r3, #1653	; 0x675
   37cd4:	463a      	mov	r2, r7
   37cd6:	4630      	mov	r0, r6
   37cd8:	f011 f9d4 	bl	49084 <assert_print>
   37cdc:	4040      	eors	r0, r0
   37cde:	f380 8811 	msr	BASEPRI, r0
   37ce2:	f04f 0003 	mov.w	r0, #3
   37ce6:	df02      	svc	2
	mem_link_rx.quota_pdu += delta;
   37ce8:	f8ba 3000 	ldrh.w	r3, [sl]
   37cec:	e7c0      	b.n	37c70 <ll_rx_mem_release+0xac>
	mem_release(node_rx, &mem_pdu_rx.free);
   37cee:	4915      	ldr	r1, [pc, #84]	; (37d44 <ll_rx_mem_release+0x180>)
   37cf0:	4628      	mov	r0, r5
   37cf2:	f7fc fbfd 	bl	344f0 <mem_release>
	while (rx) {
   37cf6:	2c00      	cmp	r4, #0
   37cf8:	f47f af6d 	bne.w	37bd6 <ll_rx_mem_release+0x12>
   37cfc:	e788      	b.n	37c10 <ll_rx_mem_release+0x4c>
				ull_central_cleanup(rx_free);
   37cfe:	4628      	mov	r0, r5
   37d00:	f006 fe42 	bl	3e988 <ull_central_cleanup>
	while (rx) {
   37d04:	2c00      	cmp	r4, #0
   37d06:	f47f af66 	bne.w	37bd6 <ll_rx_mem_release+0x12>
   37d0a:	e781      	b.n	37c10 <ll_rx_mem_release+0x4c>
				LL_ASSERT(link);
   37d0c:	4a06      	ldr	r2, [pc, #24]	; (37d28 <ll_rx_mem_release+0x164>)
   37d0e:	4910      	ldr	r1, [pc, #64]	; (37d50 <ll_rx_mem_release+0x18c>)
   37d10:	4807      	ldr	r0, [pc, #28]	; (37d30 <ll_rx_mem_release+0x16c>)
   37d12:	f240 635e 	movw	r3, #1630	; 0x65e
   37d16:	f011 f9b5 	bl	49084 <assert_print>
   37d1a:	4040      	eors	r0, r0
   37d1c:	f380 8811 	msr	BASEPRI, r0
   37d20:	f04f 0003 	mov.w	r0, #3
   37d24:	df02      	svc	2
   37d26:	e7ca      	b.n	37cbe <ll_rx_mem_release+0xfa>
   37d28:	000522f4 	.word	0x000522f4
   37d2c:	000521ac 	.word	0x000521ac
   37d30:	0005214c 	.word	0x0005214c
   37d34:	3e000029 	.word	0x3e000029
   37d38:	000523e8 	.word	0x000523e8
   37d3c:	000523f4 	.word	0x000523f4
   37d40:	200045e4 	.word	0x200045e4
   37d44:	200046b4 	.word	0x200046b4
   37d48:	00052418 	.word	0x00052418
   37d4c:	00052364 	.word	0x00052364
   37d50:	000526f4 	.word	0x000526f4

00037d54 <ll_rx_link_alloc>:
	return mem_acquire(&mem_link_rx.free);
   37d54:	4801      	ldr	r0, [pc, #4]	; (37d5c <ll_rx_link_alloc+0x8>)
   37d56:	f7fc bbaf 	b.w	344b8 <mem_acquire>
   37d5a:	bf00      	nop
   37d5c:	200045e8 	.word	0x200045e8

00037d60 <ll_rx_link_release>:
	mem_release(link, &mem_link_rx.free);
   37d60:	4901      	ldr	r1, [pc, #4]	; (37d68 <ll_rx_link_release+0x8>)
   37d62:	f7fc bbc5 	b.w	344f0 <mem_release>
   37d66:	bf00      	nop
   37d68:	200045e8 	.word	0x200045e8

00037d6c <ll_rx_alloc>:
	return mem_acquire(&mem_pdu_rx.free);
   37d6c:	4801      	ldr	r0, [pc, #4]	; (37d74 <ll_rx_alloc+0x8>)
   37d6e:	f7fc bba3 	b.w	344b8 <mem_acquire>
   37d72:	bf00      	nop
   37d74:	200046b4 	.word	0x200046b4

00037d78 <ll_rx_release>:
	mem_release(node_rx, &mem_pdu_rx.free);
   37d78:	4901      	ldr	r1, [pc, #4]	; (37d80 <ll_rx_release+0x8>)
   37d7a:	f7fc bbb9 	b.w	344f0 <mem_release>
   37d7e:	bf00      	nop
   37d80:	200046b4 	.word	0x200046b4

00037d84 <ll_rx_put>:
	rx_hdr->ack_last = mfifo_tx_ack.l;
   37d84:	4b02      	ldr	r3, [pc, #8]	; (37d90 <ll_rx_put+0xc>)
	memq_enqueue(link, rx, &memq_ll_rx.tail);
   37d86:	4a03      	ldr	r2, [pc, #12]	; (37d94 <ll_rx_put+0x10>)
	rx_hdr->ack_last = mfifo_tx_ack.l;
   37d88:	795b      	ldrb	r3, [r3, #5]
   37d8a:	700b      	strb	r3, [r1, #0]
	memq_enqueue(link, rx, &memq_ll_rx.tail);
   37d8c:	f7fc bbfa 	b.w	34584 <memq_enqueue>
   37d90:	200007d0 	.word	0x200007d0
   37d94:	200045d8 	.word	0x200045d8

00037d98 <ll_rx_sched>:
	k_sem_give(sem_recv);
   37d98:	4b01      	ldr	r3, [pc, #4]	; (37da0 <ll_rx_sched+0x8>)
   37d9a:	6818      	ldr	r0, [r3, #0]
   37d9c:	f00f b9ec 	b.w	47178 <z_impl_k_sem_give>
   37da0:	20004bf0 	.word	0x20004bf0

00037da4 <ll_pdu_rx_alloc_peek>:
	if (count > MFIFO_AVAIL_COUNT_GET(ll_pdu_rx_free)) {
   37da4:	490e      	ldr	r1, [pc, #56]	; (37de0 <ll_pdu_rx_alloc_peek+0x3c>)
   37da6:	790b      	ldrb	r3, [r1, #4]
   37da8:	794a      	ldrb	r2, [r1, #5]
	if (last >= first) {
   37daa:	4293      	cmp	r3, r2
   37dac:	d80d      	bhi.n	37dca <ll_pdu_rx_alloc_peek+0x26>
		return last - first;
   37dae:	eba2 0c03 	sub.w	ip, r2, r3
   37db2:	fa5f fc8c 	uxtb.w	ip, ip
   37db6:	4560      	cmp	r0, ip
   37db8:	d80f      	bhi.n	37dda <ll_pdu_rx_alloc_peek+0x36>
	if (first == last) {
   37dba:	4293      	cmp	r3, r2
   37dbc:	d00d      	beq.n	37dda <ll_pdu_rx_alloc_peek+0x36>
	return MFIFO_DEQUEUE_PEEK(ll_pdu_rx_free);
   37dbe:	7809      	ldrb	r1, [r1, #0]
	return *((void **)(fifo + first * size));
   37dc0:	4a08      	ldr	r2, [pc, #32]	; (37de4 <ll_pdu_rx_alloc_peek+0x40>)
   37dc2:	fb13 f301 	smulbb	r3, r3, r1
   37dc6:	58d0      	ldr	r0, [r2, r3]
   37dc8:	4770      	bx	lr
	if (count > MFIFO_AVAIL_COUNT_GET(ll_pdu_rx_free)) {
   37dca:	f8b1 c002 	ldrh.w	ip, [r1, #2]
		return count - first + last;
   37dce:	ebac 0c03 	sub.w	ip, ip, r3
   37dd2:	4462      	add	r2, ip
   37dd4:	b2d2      	uxtb	r2, r2
   37dd6:	4290      	cmp	r0, r2
   37dd8:	d9f1      	bls.n	37dbe <ll_pdu_rx_alloc_peek+0x1a>
		return NULL;
   37dda:	2000      	movs	r0, #0
}
   37ddc:	4770      	bx	lr
   37dde:	bf00      	nop
   37de0:	200007f8 	.word	0x200007f8
   37de4:	20000800 	.word	0x20000800

00037de8 <ll_pdu_rx_alloc>:
	return MFIFO_DEQUEUE(ll_pdu_rx_free);
   37de8:	4b09      	ldr	r3, [pc, #36]	; (37e10 <ll_pdu_rx_alloc+0x28>)
 * @return              Head buffer; or NULL if queue was empty
 */
static inline void *mfifo_dequeue(uint8_t *fifo, uint8_t size, uint8_t count,
				  uint8_t last, uint8_t *first)
{
	uint8_t _first = *first; /* Copy read-index */
   37dea:	7919      	ldrb	r1, [r3, #4]
	void *mem;

	/* Queue is empty if first == last */
	if (_first == last) {
   37dec:	795a      	ldrb	r2, [r3, #5]
   37dee:	7818      	ldrb	r0, [r3, #0]
   37df0:	f893 c002 	ldrb.w	ip, [r3, #2]
   37df4:	428a      	cmp	r2, r1
   37df6:	d009      	beq.n	37e0c <ll_pdu_rx_alloc+0x24>
	 * API 2: fifo is array of void-ptrs
	 */
	mem = *((void **)(fifo + _first * size));

	/* Circular buffer increment read-index modulo 'count' */
	_first += 1U;
   37df8:	1c4a      	adds	r2, r1, #1
	mem = *((void **)(fifo + _first * size));
   37dfa:	fb01 3000 	mla	r0, r1, r0, r3
	_first += 1U;
   37dfe:	b2d2      	uxtb	r2, r2
	if (_first == count) {
		_first = 0U;
   37e00:	4594      	cmp	ip, r2
   37e02:	bf08      	it	eq
   37e04:	2200      	moveq	r2, #0
	mem = *((void **)(fifo + _first * size));
   37e06:	6880      	ldr	r0, [r0, #8]
	}

	*first = _first; /* Write back read-index */
   37e08:	711a      	strb	r2, [r3, #4]

	return mem;
   37e0a:	4770      	bx	lr
		return NULL;
   37e0c:	2000      	movs	r0, #0
}
   37e0e:	4770      	bx	lr
   37e10:	200007f8 	.word	0x200007f8

00037e14 <ll_tx_ack_put>:
{
   37e14:	b538      	push	{r3, r4, r5, lr}
	idx = MFIFO_ENQUEUE_GET(tx_ack, (void **)&tx);
   37e16:	4c14      	ldr	r4, [pc, #80]	; (37e68 <ll_tx_ack_put+0x54>)
   37e18:	7962      	ldrb	r2, [r4, #5]
	if (last == count) {
   37e1a:	f894 e002 	ldrb.w	lr, [r4, #2]
   37e1e:	f894 c004 	ldrb.w	ip, [r4, #4]
   37e22:	7825      	ldrb	r5, [r4, #0]
	last = last + 1;
   37e24:	1c53      	adds	r3, r2, #1
   37e26:	b2db      	uxtb	r3, r3
		last = 0U;
   37e28:	459e      	cmp	lr, r3
   37e2a:	bf08      	it	eq
   37e2c:	2300      	moveq	r3, #0
	if (last == first) {
   37e2e:	459c      	cmp	ip, r3
   37e30:	d009      	beq.n	37e46 <ll_tx_ack_put+0x32>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
   37e32:	fb12 f205 	smulbb	r2, r2, r5
   37e36:	f104 0c08 	add.w	ip, r4, #8
	tx->handle = handle;
   37e3a:	f82c 0002 	strh.w	r0, [ip, r2]
   37e3e:	4462      	add	r2, ip
	tx->node = node_tx;
   37e40:	6051      	str	r1, [r2, #4]
	*last = idx; /* Commit: Update write index */
   37e42:	7163      	strb	r3, [r4, #5]
}
   37e44:	bd38      	pop	{r3, r4, r5, pc}
	LL_ASSERT(tx);
   37e46:	4a09      	ldr	r2, [pc, #36]	; (37e6c <ll_tx_ack_put+0x58>)
   37e48:	4909      	ldr	r1, [pc, #36]	; (37e70 <ll_tx_ack_put+0x5c>)
   37e4a:	480a      	ldr	r0, [pc, #40]	; (37e74 <ll_tx_ack_put+0x60>)
   37e4c:	f240 63c9 	movw	r3, #1737	; 0x6c9
   37e50:	f011 f918 	bl	49084 <assert_print>
   37e54:	4040      	eors	r0, r0
   37e56:	f380 8811 	msr	BASEPRI, r0
   37e5a:	f04f 0003 	mov.w	r0, #3
   37e5e:	df02      	svc	2
	tx->handle = handle;
   37e60:	2300      	movs	r3, #0
   37e62:	801b      	strh	r3, [r3, #0]
   37e64:	deff      	udf	#255	; 0xff
   37e66:	bf00      	nop
   37e68:	200007d0 	.word	0x200007d0
   37e6c:	000522f4 	.word	0x000522f4
   37e70:	000526e8 	.word	0x000526e8
   37e74:	0005214c 	.word	0x0005214c

00037e78 <ll_timeslice_ticker_id_get>:
	*instance_index = TICKER_INSTANCE_ID_CTLR;
   37e78:	2200      	movs	r2, #0
	*ticker_id = (TICKER_NODES - FLASH_TICKER_NODES);
   37e7a:	230b      	movs	r3, #11
	*instance_index = TICKER_INSTANCE_ID_CTLR;
   37e7c:	7002      	strb	r2, [r0, #0]
	*ticker_id = (TICKER_NODES - FLASH_TICKER_NODES);
   37e7e:	700b      	strb	r3, [r1, #0]
}
   37e80:	4770      	bx	lr
   37e82:	bf00      	nop

00037e84 <ll_radio_state_abort>:
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL, 0,
   37e84:	2200      	movs	r2, #0
{
   37e86:	b508      	push	{r3, lr}
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL, 0,
   37e88:	4611      	mov	r1, r2
   37e8a:	4b0a      	ldr	r3, [pc, #40]	; (37eb4 <ll_radio_state_abort+0x30>)
   37e8c:	2001      	movs	r0, #1
   37e8e:	f7fc fbef 	bl	34670 <mayfly_enqueue>
	LL_ASSERT(!ret);
   37e92:	b900      	cbnz	r0, 37e96 <ll_radio_state_abort+0x12>
}
   37e94:	bd08      	pop	{r3, pc}
	LL_ASSERT(!ret);
   37e96:	4a08      	ldr	r2, [pc, #32]	; (37eb8 <ll_radio_state_abort+0x34>)
   37e98:	4908      	ldr	r1, [pc, #32]	; (37ebc <ll_radio_state_abort+0x38>)
   37e9a:	4809      	ldr	r0, [pc, #36]	; (37ec0 <ll_radio_state_abort+0x3c>)
   37e9c:	f240 63e1 	movw	r3, #1761	; 0x6e1
   37ea0:	f011 f8f0 	bl	49084 <assert_print>
   37ea4:	4040      	eors	r0, r0
   37ea6:	f380 8811 	msr	BASEPRI, r0
   37eaa:	f04f 0003 	mov.w	r0, #3
   37eae:	df02      	svc	2
}
   37eb0:	bd08      	pop	{r3, pc}
   37eb2:	bf00      	nop
   37eb4:	200007b0 	.word	0x200007b0
   37eb8:	000522f4 	.word	0x000522f4
   37ebc:	00052430 	.word	0x00052430
   37ec0:	0005214c 	.word	0x0005214c

00037ec4 <ull_ticker_status_take>:
	if (ret == TICKER_STATUS_BUSY) {
   37ec4:	f030 0302 	bics.w	r3, r0, #2
{
   37ec8:	b510      	push	{r4, lr}
   37eca:	460c      	mov	r4, r1
	if (ret == TICKER_STATUS_BUSY) {
   37ecc:	d002      	beq.n	37ed4 <ull_ticker_status_take+0x10>
		LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
   37ece:	680b      	ldr	r3, [r1, #0]
   37ed0:	2b02      	cmp	r3, #2
   37ed2:	d008      	beq.n	37ee6 <ull_ticker_status_take+0x22>
	return z_impl_k_sem_take(sem, timeout);
   37ed4:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   37ed8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   37edc:	4809      	ldr	r0, [pc, #36]	; (37f04 <ull_ticker_status_take+0x40>)
   37ede:	f00f f971 	bl	471c4 <z_impl_k_sem_take>
	return *ret_cb;
   37ee2:	6820      	ldr	r0, [r4, #0]
}
   37ee4:	bd10      	pop	{r4, pc}
		LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
   37ee6:	4a08      	ldr	r2, [pc, #32]	; (37f08 <ull_ticker_status_take+0x44>)
   37ee8:	4908      	ldr	r1, [pc, #32]	; (37f0c <ull_ticker_status_take+0x48>)
   37eea:	4809      	ldr	r0, [pc, #36]	; (37f10 <ull_ticker_status_take+0x4c>)
   37eec:	f240 63fd 	movw	r3, #1789	; 0x6fd
   37ef0:	f011 f8c8 	bl	49084 <assert_print>
   37ef4:	4040      	eors	r0, r0
   37ef6:	f380 8811 	msr	BASEPRI, r0
   37efa:	f04f 0003 	mov.w	r0, #3
   37efe:	df02      	svc	2
   37f00:	e7e8      	b.n	37ed4 <ull_ticker_status_take+0x10>
   37f02:	bf00      	nop
   37f04:	20004bf4 	.word	0x20004bf4
   37f08:	000522f4 	.word	0x000522f4
   37f0c:	00052438 	.word	0x00052438
   37f10:	0005214c 	.word	0x0005214c

00037f14 <ull_disable_mark>:
	if (!*m) {
   37f14:	4904      	ldr	r1, [pc, #16]	; (37f28 <ull_disable_mark+0x14>)
   37f16:	680a      	ldr	r2, [r1, #0]
   37f18:	b10a      	cbz	r2, 37f1e <ull_disable_mark+0xa>
}
   37f1a:	4610      	mov	r0, r2
   37f1c:	4770      	bx	lr
		*m = param;
   37f1e:	4602      	mov	r2, r0
   37f20:	6008      	str	r0, [r1, #0]
}
   37f22:	4610      	mov	r0, r2
   37f24:	4770      	bx	lr
   37f26:	bf00      	nop
   37f28:	200045c4 	.word	0x200045c4

00037f2c <ull_disable_unmark>:
	if (*m && *m == param) {
   37f2c:	4a04      	ldr	r2, [pc, #16]	; (37f40 <ull_disable_unmark+0x14>)
   37f2e:	6813      	ldr	r3, [r2, #0]
   37f30:	b123      	cbz	r3, 37f3c <ull_disable_unmark+0x10>
   37f32:	4298      	cmp	r0, r3
		*m = NULL;
   37f34:	bf06      	itte	eq
   37f36:	2100      	moveq	r1, #0
   37f38:	6011      	streq	r1, [r2, #0]
	return NULL;
   37f3a:	2300      	movne	r3, #0
}
   37f3c:	4618      	mov	r0, r3
   37f3e:	4770      	bx	lr
   37f40:	200045c4 	.word	0x200045c4

00037f44 <ull_disable_mark_get>:
	return mark_get(mark_disable);
   37f44:	4b01      	ldr	r3, [pc, #4]	; (37f4c <ull_disable_mark_get+0x8>)
}
   37f46:	6818      	ldr	r0, [r3, #0]
   37f48:	4770      	bx	lr
   37f4a:	bf00      	nop
   37f4c:	200045c4 	.word	0x200045c4

00037f50 <ull_update_mark>:
	if (!*m) {
   37f50:	4904      	ldr	r1, [pc, #16]	; (37f64 <ull_update_mark+0x14>)
   37f52:	680a      	ldr	r2, [r1, #0]
   37f54:	b10a      	cbz	r2, 37f5a <ull_update_mark+0xa>
}
   37f56:	4610      	mov	r0, r2
   37f58:	4770      	bx	lr
		*m = param;
   37f5a:	4602      	mov	r2, r0
   37f5c:	6008      	str	r0, [r1, #0]
}
   37f5e:	4610      	mov	r0, r2
   37f60:	4770      	bx	lr
   37f62:	bf00      	nop
   37f64:	200045c8 	.word	0x200045c8

00037f68 <ull_update_unmark>:
	if (*m && *m == param) {
   37f68:	4a04      	ldr	r2, [pc, #16]	; (37f7c <ull_update_unmark+0x14>)
   37f6a:	6813      	ldr	r3, [r2, #0]
   37f6c:	b123      	cbz	r3, 37f78 <ull_update_unmark+0x10>
   37f6e:	4298      	cmp	r0, r3
		*m = NULL;
   37f70:	bf06      	itte	eq
   37f72:	2100      	moveq	r1, #0
   37f74:	6011      	streq	r1, [r2, #0]
	return NULL;
   37f76:	2300      	movne	r3, #0
}
   37f78:	4618      	mov	r0, r3
   37f7a:	4770      	bx	lr
   37f7c:	200045c8 	.word	0x200045c8

00037f80 <ull_update_mark_get>:
	return mark_get(mark_update);
   37f80:	4b01      	ldr	r3, [pc, #4]	; (37f88 <ull_update_mark_get+0x8>)
}
   37f82:	6818      	ldr	r0, [r3, #0]
   37f84:	4770      	bx	lr
   37f86:	bf00      	nop
   37f88:	200045c8 	.word	0x200045c8

00037f8c <ull_disable>:
{
   37f8c:	b530      	push	{r4, r5, lr}
	hdr = HDR_LLL2ULL(lll);
   37f8e:	6805      	ldr	r5, [r0, #0]
   37f90:	782b      	ldrb	r3, [r5, #0]
{
   37f92:	b087      	sub	sp, #28
	if (!ull_ref_get(hdr)) {
   37f94:	b353      	cbz	r3, 37fec <ull_disable+0x60>
	compiler_barrier();
   37f96:	4604      	mov	r4, r0
	return z_impl_k_sem_init(sem, initial_count, limit);
   37f98:	2201      	movs	r2, #1
   37f9a:	2100      	movs	r1, #0
   37f9c:	4668      	mov	r0, sp
   37f9e:	f017 ff6b 	bl	4fe78 <z_impl_k_sem_init>
   37fa2:	782b      	ldrb	r3, [r5, #0]
	hdr->disabled_cb = disabled_cb;
   37fa4:	4a13      	ldr	r2, [pc, #76]	; (37ff4 <ull_disable+0x68>)
	hdr->disabled_param = &sem;
   37fa6:	f8c5 d018 	str.w	sp, [r5, #24]
	hdr->disabled_cb = disabled_cb;
   37faa:	616a      	str	r2, [r5, #20]
	if (!ull_ref_get(hdr)) {
   37fac:	b1f3      	cbz	r3, 37fec <ull_disable+0x60>
	mfy.param = lll;
   37fae:	4b12      	ldr	r3, [pc, #72]	; (37ff8 <ull_disable+0x6c>)
	ret = mayfly_enqueue(TICKER_USER_ID_THREAD, TICKER_USER_ID_LLL, 0,
   37fb0:	2200      	movs	r2, #0
   37fb2:	4611      	mov	r1, r2
   37fb4:	2003      	movs	r0, #3
	mfy.param = lll;
   37fb6:	609c      	str	r4, [r3, #8]
	ret = mayfly_enqueue(TICKER_USER_ID_THREAD, TICKER_USER_ID_LLL, 0,
   37fb8:	f7fc fb5a 	bl	34670 <mayfly_enqueue>
	LL_ASSERT(!ret);
   37fbc:	b940      	cbnz	r0, 37fd0 <ull_disable+0x44>
	return z_impl_k_sem_take(sem, timeout);
   37fbe:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   37fc2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   37fc6:	4668      	mov	r0, sp
   37fc8:	f00f f8fc 	bl	471c4 <z_impl_k_sem_take>
}
   37fcc:	b007      	add	sp, #28
   37fce:	bd30      	pop	{r4, r5, pc}
	LL_ASSERT(!ret);
   37fd0:	4a0a      	ldr	r2, [pc, #40]	; (37ffc <ull_disable+0x70>)
   37fd2:	490b      	ldr	r1, [pc, #44]	; (38000 <ull_disable+0x74>)
   37fd4:	480b      	ldr	r0, [pc, #44]	; (38004 <ull_disable+0x78>)
   37fd6:	f240 737a 	movw	r3, #1914	; 0x77a
   37fda:	f011 f853 	bl	49084 <assert_print>
   37fde:	4040      	eors	r0, r0
   37fe0:	f380 8811 	msr	BASEPRI, r0
   37fe4:	f04f 0003 	mov.w	r0, #3
   37fe8:	df02      	svc	2
   37fea:	e7e8      	b.n	37fbe <ull_disable+0x32>
		return -EALREADY;
   37fec:	f06f 0077 	mvn.w	r0, #119	; 0x77
   37ff0:	e7ec      	b.n	37fcc <ull_disable+0x40>
   37ff2:	bf00      	nop
   37ff4:	000374ad 	.word	0x000374ad
   37ff8:	200007a0 	.word	0x200007a0
   37ffc:	000522f4 	.word	0x000522f4
   38000:	00052430 	.word	0x00052430
   38004:	0005214c 	.word	0x0005214c

00038008 <ull_ticker_stop_with_mark>:
{
   38008:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (!*m) {
   3800a:	4e1e      	ldr	r6, [pc, #120]	; (38084 <ull_ticker_stop_with_mark+0x7c>)
   3800c:	6833      	ldr	r3, [r6, #0]
{
   3800e:	b085      	sub	sp, #20
   38010:	460c      	mov	r4, r1
   38012:	4617      	mov	r7, r2
	if (!*m) {
   38014:	b353      	cbz	r3, 3806c <ull_ticker_stop_with_mark+0x64>
	if (mark != param) {
   38016:	4299      	cmp	r1, r3
   38018:	d113      	bne.n	38042 <ull_ticker_stop_with_mark+0x3a>
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_THREAD,
   3801a:	ad03      	add	r5, sp, #12
	ret_cb = TICKER_STATUS_BUSY;
   3801c:	2302      	movs	r3, #2
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_THREAD,
   3801e:	4602      	mov	r2, r0
	ret_cb = TICKER_STATUS_BUSY;
   38020:	9303      	str	r3, [sp, #12]
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_THREAD,
   38022:	9500      	str	r5, [sp, #0]
   38024:	4b18      	ldr	r3, [pc, #96]	; (38088 <ull_ticker_stop_with_mark+0x80>)
   38026:	2103      	movs	r1, #3
   38028:	2000      	movs	r0, #0
   3802a:	f7fd fd47 	bl	35abc <ticker_stop>
	ret = ull_ticker_status_take(ret, &ret_cb);
   3802e:	4629      	mov	r1, r5
   38030:	f7ff ff48 	bl	37ec4 <ull_ticker_status_take>
	if (ret) {
   38034:	4605      	mov	r5, r0
   38036:	b140      	cbz	r0, 3804a <ull_ticker_stop_with_mark+0x42>
	if (*m && *m == param) {
   38038:	6833      	ldr	r3, [r6, #0]
   3803a:	b10b      	cbz	r3, 38040 <ull_ticker_stop_with_mark+0x38>
   3803c:	429c      	cmp	r4, r3
   3803e:	d017      	beq.n	38070 <ull_ticker_stop_with_mark+0x68>
		if (mark != param) {
   38040:	b1c4      	cbz	r4, 38074 <ull_ticker_stop_with_mark+0x6c>
		return -ENOLCK;
   38042:	f06f 002d 	mvn.w	r0, #45	; 0x2d
}
   38046:	b005      	add	sp, #20
   38048:	bdf0      	pop	{r4, r5, r6, r7, pc}
	err = ull_disable(lll_disable);
   3804a:	4638      	mov	r0, r7
   3804c:	f7ff ff9e 	bl	37f8c <ull_disable>
	if (*m && *m == param) {
   38050:	6833      	ldr	r3, [r6, #0]
   38052:	b10b      	cbz	r3, 38058 <ull_ticker_stop_with_mark+0x50>
   38054:	429c      	cmp	r4, r3
   38056:	d011      	beq.n	3807c <ull_ticker_stop_with_mark+0x74>
	if (mark != param) {
   38058:	2c00      	cmp	r4, #0
   3805a:	d1f2      	bne.n	38042 <ull_ticker_stop_with_mark+0x3a>
	if (err && (err != -EALREADY)) {
   3805c:	2800      	cmp	r0, #0
   3805e:	d0f2      	beq.n	38046 <ull_ticker_stop_with_mark+0x3e>
	return 0;
   38060:	f110 0f78 	cmn.w	r0, #120	; 0x78
   38064:	bf08      	it	eq
   38066:	2000      	moveq	r0, #0
}
   38068:	b005      	add	sp, #20
   3806a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		*m = param;
   3806c:	6031      	str	r1, [r6, #0]
	if (mark != param) {
   3806e:	e7d4      	b.n	3801a <ull_ticker_stop_with_mark+0x12>
		*m = NULL;
   38070:	2300      	movs	r3, #0
   38072:	6033      	str	r3, [r6, #0]
		return -EALREADY;
   38074:	f06f 0077 	mvn.w	r0, #119	; 0x77
}
   38078:	b005      	add	sp, #20
   3807a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		*m = NULL;
   3807c:	6035      	str	r5, [r6, #0]
	if (err && (err != -EALREADY)) {
   3807e:	2800      	cmp	r0, #0
   38080:	d0e1      	beq.n	38046 <ull_ticker_stop_with_mark+0x3e>
   38082:	e7ed      	b.n	38060 <ull_ticker_stop_with_mark+0x58>
   38084:	200045c4 	.word	0x200045c4
   38088:	000374a1 	.word	0x000374a1

0003808c <ull_pdu_rx_alloc_peek>:
	if (count > MFIFO_AVAIL_COUNT_GET(pdu_rx_free)) {
   3808c:	490e      	ldr	r1, [pc, #56]	; (380c8 <ull_pdu_rx_alloc_peek+0x3c>)
   3808e:	790b      	ldrb	r3, [r1, #4]
   38090:	794a      	ldrb	r2, [r1, #5]
	if (last >= first) {
   38092:	4293      	cmp	r3, r2
   38094:	d80d      	bhi.n	380b2 <ull_pdu_rx_alloc_peek+0x26>
		return last - first;
   38096:	eba2 0c03 	sub.w	ip, r2, r3
   3809a:	fa5f fc8c 	uxtb.w	ip, ip
   3809e:	4560      	cmp	r0, ip
   380a0:	d80f      	bhi.n	380c2 <ull_pdu_rx_alloc_peek+0x36>
	if (first == last) {
   380a2:	4293      	cmp	r3, r2
   380a4:	d00d      	beq.n	380c2 <ull_pdu_rx_alloc_peek+0x36>
	return MFIFO_DEQUEUE_PEEK(pdu_rx_free);
   380a6:	7809      	ldrb	r1, [r1, #0]
	return *((void **)(fifo + first * size));
   380a8:	4a08      	ldr	r2, [pc, #32]	; (380cc <ull_pdu_rx_alloc_peek+0x40>)
   380aa:	fb13 f301 	smulbb	r3, r3, r1
   380ae:	58d0      	ldr	r0, [r2, r3]
   380b0:	4770      	bx	lr
	if (count > MFIFO_AVAIL_COUNT_GET(pdu_rx_free)) {
   380b2:	f8b1 c002 	ldrh.w	ip, [r1, #2]
		return count - first + last;
   380b6:	ebac 0c03 	sub.w	ip, ip, r3
   380ba:	4462      	add	r2, ip
   380bc:	b2d2      	uxtb	r2, r2
   380be:	4290      	cmp	r0, r2
   380c0:	d9f1      	bls.n	380a6 <ull_pdu_rx_alloc_peek+0x1a>
		return NULL;
   380c2:	2000      	movs	r0, #0
}
   380c4:	4770      	bx	lr
   380c6:	bf00      	nop
   380c8:	20000834 	.word	0x20000834
   380cc:	2000083c 	.word	0x2000083c

000380d0 <ull_pdu_rx_alloc>:
	return MFIFO_DEQUEUE(pdu_rx_free);
   380d0:	4b09      	ldr	r3, [pc, #36]	; (380f8 <ull_pdu_rx_alloc+0x28>)
	uint8_t _first = *first; /* Copy read-index */
   380d2:	7919      	ldrb	r1, [r3, #4]
	if (_first == last) {
   380d4:	795a      	ldrb	r2, [r3, #5]
   380d6:	7818      	ldrb	r0, [r3, #0]
   380d8:	f893 c002 	ldrb.w	ip, [r3, #2]
   380dc:	428a      	cmp	r2, r1
   380de:	d009      	beq.n	380f4 <ull_pdu_rx_alloc+0x24>
	_first += 1U;
   380e0:	1c4a      	adds	r2, r1, #1
	mem = *((void **)(fifo + _first * size));
   380e2:	fb01 3000 	mla	r0, r1, r0, r3
	_first += 1U;
   380e6:	b2d2      	uxtb	r2, r2
		_first = 0U;
   380e8:	4594      	cmp	ip, r2
   380ea:	bf08      	it	eq
   380ec:	2200      	moveq	r2, #0
	mem = *((void **)(fifo + _first * size));
   380ee:	6880      	ldr	r0, [r0, #8]
	*first = _first; /* Write back read-index */
   380f0:	711a      	strb	r2, [r3, #4]
	return mem;
   380f2:	4770      	bx	lr
		return NULL;
   380f4:	2000      	movs	r0, #0
}
   380f6:	4770      	bx	lr
   380f8:	20000834 	.word	0x20000834

000380fc <ull_rx_put>:
{
   380fc:	b538      	push	{r3, r4, r5, lr}
   380fe:	460c      	mov	r4, r1
   38100:	4605      	mov	r5, r0
	rx_hdr->ack_last = ull_conn_ack_last_idx_get();
   38102:	f005 fe97 	bl	3de34 <ull_conn_ack_last_idx_get>
   38106:	7020      	strb	r0, [r4, #0]
	memq_enqueue(link, rx, &memq_ull_rx.tail);
   38108:	4621      	mov	r1, r4
   3810a:	4628      	mov	r0, r5
   3810c:	4a02      	ldr	r2, [pc, #8]	; (38118 <ull_rx_put+0x1c>)
}
   3810e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	memq_enqueue(link, rx, &memq_ull_rx.tail);
   38112:	f7fc ba37 	b.w	34584 <memq_enqueue>
   38116:	bf00      	nop
   38118:	200045e0 	.word	0x200045e0

0003811c <ull_rx_sched>:
	mayfly_enqueue(TICKER_USER_ID_LLL, TICKER_USER_ID_ULL_HIGH, 1, &mfy);
   3811c:	2201      	movs	r2, #1
   3811e:	4b02      	ldr	r3, [pc, #8]	; (38128 <ull_rx_sched+0xc>)
   38120:	4611      	mov	r1, r2
   38122:	2000      	movs	r0, #0
   38124:	f7fc baa4 	b.w	34670 <mayfly_enqueue>
   38128:	20000790 	.word	0x20000790

0003812c <ull_prepare_enqueue>:
{
   3812c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	idx = MFIFO_ENQUEUE_GET(prep, (void **)&e);
   38130:	4e16      	ldr	r6, [pc, #88]	; (3818c <ull_prepare_enqueue+0x60>)
{
   38132:	f89d a020 	ldrb.w	sl, [sp, #32]
   38136:	4699      	mov	r9, r3
	idx = MFIFO_ENQUEUE_GET(prep, (void **)&e);
   38138:	7973      	ldrb	r3, [r6, #5]
{
   3813a:	460f      	mov	r7, r1
	last = last + 1;
   3813c:	1c5d      	adds	r5, r3, #1
   3813e:	4611      	mov	r1, r2
	if (last == count) {
   38140:	78b2      	ldrb	r2, [r6, #2]
	last = last + 1;
   38142:	b2ed      	uxtb	r5, r5
		last = 0U;
   38144:	42aa      	cmp	r2, r5
   38146:	bf08      	it	eq
   38148:	2500      	moveq	r5, #0
	idx = MFIFO_ENQUEUE_GET(prep, (void **)&e);
   3814a:	7932      	ldrb	r2, [r6, #4]
	if (last == first) {
   3814c:	42aa      	cmp	r2, r5
{
   3814e:	4680      	mov	r8, r0
	idx = MFIFO_ENQUEUE_GET(prep, (void **)&e);
   38150:	7830      	ldrb	r0, [r6, #0]
   38152:	d016      	beq.n	38182 <ull_prepare_enqueue+0x56>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
   38154:	f106 0408 	add.w	r4, r6, #8
   38158:	fb03 4400 	mla	r4, r3, r0, r4
	memcpy(&e->prepare_param, prepare_param, sizeof(e->prepare_param));
   3815c:	2210      	movs	r2, #16
   3815e:	4620      	mov	r0, r4
   38160:	f012 fe8b 	bl	4ae7a <memcpy>
	e->is_resume = is_resume;
   38164:	7f23      	ldrb	r3, [r4, #28]
	e->abort_cb = abort_cb;
   38166:	61a7      	str	r7, [r4, #24]
	e->is_resume = is_resume;
   38168:	f00a 0a01 	and.w	sl, sl, #1
   3816c:	f023 0303 	bic.w	r3, r3, #3
   38170:	ea43 030a 	orr.w	r3, r3, sl
	e->is_abort_cb = is_abort_cb;
   38174:	e9c4 9804 	strd	r9, r8, [r4, #16]
	e->is_resume = is_resume;
   38178:	7723      	strb	r3, [r4, #28]
	*last = idx; /* Commit: Update write index */
   3817a:	7175      	strb	r5, [r6, #5]
}
   3817c:	4620      	mov	r0, r4
   3817e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		return NULL;
   38182:	2400      	movs	r4, #0
}
   38184:	4620      	mov	r0, r4
   38186:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   3818a:	bf00      	nop
   3818c:	20000944 	.word	0x20000944

00038190 <ull_prepare_dequeue_get>:
	return MFIFO_DEQUEUE_GET(prep);
   38190:	4805      	ldr	r0, [pc, #20]	; (381a8 <ull_prepare_dequeue_get+0x18>)
   38192:	7902      	ldrb	r2, [r0, #4]
	if (first == last) {
   38194:	7941      	ldrb	r1, [r0, #5]
   38196:	f890 c000 	ldrb.w	ip, [r0]
   3819a:	4291      	cmp	r1, r2
	return (void *)(fifo + first * size);
   3819c:	bf1a      	itte	ne
   3819e:	3008      	addne	r0, #8
   381a0:	fb02 000c 	mlane	r0, r2, ip, r0
		return NULL;
   381a4:	2000      	moveq	r0, #0
}
   381a6:	4770      	bx	lr
   381a8:	20000944 	.word	0x20000944

000381ac <ull_prepare_dequeue_iter>:
{
   381ac:	b500      	push	{lr}
	return MFIFO_DEQUEUE_ITER_GET(prep, idx);
   381ae:	4b0d      	ldr	r3, [pc, #52]	; (381e4 <ull_prepare_dequeue_iter+0x38>)
	if (*idx >= count) {
   381b0:	7802      	ldrb	r2, [r0, #0]
   381b2:	7899      	ldrb	r1, [r3, #2]
   381b4:	f893 c005 	ldrb.w	ip, [r3, #5]
   381b8:	f893 e000 	ldrb.w	lr, [r3]
   381bc:	4291      	cmp	r1, r2
   381be:	bf9c      	itt	ls
   381c0:	791a      	ldrbls	r2, [r3, #4]
		*idx = first;
   381c2:	7002      	strbls	r2, [r0, #0]
	if (*idx == last) {
   381c4:	4594      	cmp	ip, r2
   381c6:	d00a      	beq.n	381de <ull_prepare_dequeue_iter+0x32>
	i = *idx + 1;
   381c8:	1c53      	adds	r3, r2, #1
   381ca:	b2db      	uxtb	r3, r3
		i = 0U;
   381cc:	4299      	cmp	r1, r3
   381ce:	bf08      	it	eq
   381d0:	2300      	moveq	r3, #0
	p = (void *)(fifo + (*idx) * size);
   381d2:	4905      	ldr	r1, [pc, #20]	; (381e8 <ull_prepare_dequeue_iter+0x3c>)
	*idx = i;
   381d4:	7003      	strb	r3, [r0, #0]
	p = (void *)(fifo + (*idx) * size);
   381d6:	fb02 100e 	mla	r0, r2, lr, r1
}
   381da:	f85d fb04 	ldr.w	pc, [sp], #4
		return NULL;
   381de:	2000      	movs	r0, #0
	return MFIFO_DEQUEUE_ITER_GET(prep, idx);
   381e0:	e7fb      	b.n	381da <ull_prepare_dequeue_iter+0x2e>
   381e2:	bf00      	nop
   381e4:	20000944 	.word	0x20000944
   381e8:	2000094c 	.word	0x2000094c

000381ec <ull_prepare_dequeue>:
{
   381ec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	return MFIFO_DEQUEUE_GET(prep);
   381f0:	4c2b      	ldr	r4, [pc, #172]	; (382a0 <ull_prepare_dequeue+0xb4>)
   381f2:	7922      	ldrb	r2, [r4, #4]
	if (first == last) {
   381f4:	7961      	ldrb	r1, [r4, #5]
   381f6:	7823      	ldrb	r3, [r4, #0]
{
   381f8:	b083      	sub	sp, #12
   381fa:	4291      	cmp	r1, r2
   381fc:	9001      	str	r0, [sp, #4]
   381fe:	d032      	beq.n	38266 <ull_prepare_dequeue+0x7a>
	return (void *)(fifo + first * size);
   38200:	f104 0908 	add.w	r9, r4, #8
   38204:	f04f 0800 	mov.w	r8, #0
			mfy.param = next;
   38208:	f8df b098 	ldr.w	fp, [pc, #152]	; 382a4 <ull_prepare_dequeue+0xb8>
   3820c:	fb02 9303 	mla	r3, r2, r3, r9
   38210:	46c2      	mov	sl, r8
		uint8_t is_aborted = next->is_aborted;
   38212:	7f1a      	ldrb	r2, [r3, #28]
		void *param = next->prepare_param.param;
   38214:	68df      	ldr	r7, [r3, #12]
		if (!is_aborted) {
   38216:	0791      	lsls	r1, r2, #30
		uint8_t is_aborted = next->is_aborted;
   38218:	f3c2 0540 	ubfx	r5, r2, #1, #1
		uint8_t is_resume = next->is_resume;
   3821c:	f002 0601 	and.w	r6, r2, #1
		if (!is_aborted) {
   38220:	d524      	bpl.n	3826c <ull_prepare_dequeue+0x80>
		MFIFO_DEQUEUE(prep);
   38222:	7961      	ldrb	r1, [r4, #5]
	uint8_t _first = *first; /* Copy read-index */
   38224:	7923      	ldrb	r3, [r4, #4]
   38226:	7822      	ldrb	r2, [r4, #0]
   38228:	78a0      	ldrb	r0, [r4, #2]
	if (_first == last) {
   3822a:	4299      	cmp	r1, r3
   3822c:	d01b      	beq.n	38266 <ull_prepare_dequeue+0x7a>
	_first += 1U;
   3822e:	3301      	adds	r3, #1
   38230:	b2db      	uxtb	r3, r3
		_first = 0U;
   38232:	4298      	cmp	r0, r3
   38234:	bf08      	it	eq
   38236:	2300      	moveq	r3, #0
	if (first == last) {
   38238:	4299      	cmp	r1, r3
	*first = _first; /* Write back read-index */
   3823a:	7123      	strb	r3, [r4, #4]
	if (first == last) {
   3823c:	d013      	beq.n	38266 <ull_prepare_dequeue+0x7a>
	return (void *)(fifo + first * size);
   3823e:	fb03 9302 	mla	r3, r3, r2, r9
		if (!is_aborted) {
   38242:	2d00      	cmp	r5, #0
   38244:	d1e5      	bne.n	38212 <ull_prepare_dequeue+0x26>
			if (!is_resume) {
   38246:	b176      	cbz	r6, 38266 <ull_prepare_dequeue+0x7a>
			if (!param_resume_head) {
   38248:	f1ba 0f00 	cmp.w	sl, #0
   3824c:	d026      	beq.n	3829c <ull_prepare_dequeue+0xb0>
				param_resume_next = param;
   3824e:	f1b8 0f00 	cmp.w	r8, #0
   38252:	bf08      	it	eq
   38254:	46b8      	moveq	r8, r7
			if (next->is_resume &&
   38256:	7f1a      	ldrb	r2, [r3, #28]
   38258:	07d2      	lsls	r2, r2, #31
   3825a:	d5da      	bpl.n	38212 <ull_prepare_dequeue+0x26>
			    ((next->prepare_param.param ==
   3825c:	68da      	ldr	r2, [r3, #12]
			if (next->is_resume &&
   3825e:	4592      	cmp	sl, r2
   38260:	d001      	beq.n	38266 <ull_prepare_dequeue+0x7a>
			      param_resume_head) ||
   38262:	4590      	cmp	r8, r2
   38264:	d1d5      	bne.n	38212 <ull_prepare_dequeue+0x26>
}
   38266:	b003      	add	sp, #12
   38268:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			mfy.param = next;
   3826c:	f8cb 3008 	str.w	r3, [fp, #8]
			ret = mayfly_enqueue(caller_id, TICKER_USER_ID_LLL, 0,
   38270:	9801      	ldr	r0, [sp, #4]
   38272:	4b0c      	ldr	r3, [pc, #48]	; (382a4 <ull_prepare_dequeue+0xb8>)
   38274:	462a      	mov	r2, r5
   38276:	4629      	mov	r1, r5
   38278:	f7fc f9fa 	bl	34670 <mayfly_enqueue>
			LL_ASSERT(!ret);
   3827c:	2800      	cmp	r0, #0
   3827e:	d0d0      	beq.n	38222 <ull_prepare_dequeue+0x36>
   38280:	4a09      	ldr	r2, [pc, #36]	; (382a8 <ull_prepare_dequeue+0xbc>)
   38282:	490a      	ldr	r1, [pc, #40]	; (382ac <ull_prepare_dequeue+0xc0>)
   38284:	480a      	ldr	r0, [pc, #40]	; (382b0 <ull_prepare_dequeue+0xc4>)
   38286:	f240 73f7 	movw	r3, #2039	; 0x7f7
   3828a:	f010 fefb 	bl	49084 <assert_print>
   3828e:	4040      	eors	r0, r0
   38290:	f380 8811 	msr	BASEPRI, r0
   38294:	f04f 0003 	mov.w	r0, #3
   38298:	df02      	svc	2
   3829a:	e7c2      	b.n	38222 <ull_prepare_dequeue+0x36>
				param_resume_head = param;
   3829c:	46ba      	mov	sl, r7
   3829e:	e7da      	b.n	38256 <ull_prepare_dequeue+0x6a>
   382a0:	20000944 	.word	0x20000944
   382a4:	20000770 	.word	0x20000770
   382a8:	000522f4 	.word	0x000522f4
   382ac:	00052430 	.word	0x00052430
   382b0:	0005214c 	.word	0x0005214c

000382b4 <ull_event_done_extra_get>:
	evdone = MFIFO_DEQUEUE_PEEK(done);
   382b4:	4b06      	ldr	r3, [pc, #24]	; (382d0 <ull_event_done_extra_get+0x1c>)
   382b6:	791a      	ldrb	r2, [r3, #4]
	if (first == last) {
   382b8:	7959      	ldrb	r1, [r3, #5]
   382ba:	7818      	ldrb	r0, [r3, #0]
   382bc:	4291      	cmp	r1, r2
   382be:	d005      	beq.n	382cc <ull_event_done_extra_get+0x18>
	return *((void **)(fifo + first * size));
   382c0:	fb02 3300 	mla	r3, r2, r0, r3
   382c4:	6898      	ldr	r0, [r3, #8]
	if (!evdone) {
   382c6:	b110      	cbz	r0, 382ce <ull_event_done_extra_get+0x1a>
	return &evdone->extra;
   382c8:	3020      	adds	r0, #32
   382ca:	4770      	bx	lr
		return NULL;
   382cc:	2000      	movs	r0, #0
}
   382ce:	4770      	bx	lr
   382d0:	20000928 	.word	0x20000928

000382d4 <ull_event_done>:
{
   382d4:	b538      	push	{r3, r4, r5, lr}
	evdone = MFIFO_DEQUEUE(done);
   382d6:	4a13      	ldr	r2, [pc, #76]	; (38324 <ull_event_done+0x50>)
	uint8_t _first = *first; /* Copy read-index */
   382d8:	7913      	ldrb	r3, [r2, #4]
	if (_first == last) {
   382da:	7955      	ldrb	r5, [r2, #5]
   382dc:	7814      	ldrb	r4, [r2, #0]
   382de:	429d      	cmp	r5, r3
{
   382e0:	4601      	mov	r1, r0
	evdone = MFIFO_DEQUEUE(done);
   382e2:	7890      	ldrb	r0, [r2, #2]
   382e4:	d01b      	beq.n	3831e <ull_event_done+0x4a>
	mem = *((void **)(fifo + _first * size));
   382e6:	fb03 2404 	mla	r4, r3, r4, r2
	_first += 1U;
   382ea:	3301      	adds	r3, #1
	mem = *((void **)(fifo + _first * size));
   382ec:	68a4      	ldr	r4, [r4, #8]
	_first += 1U;
   382ee:	b2db      	uxtb	r3, r3
		_first = 0U;
   382f0:	4298      	cmp	r0, r3
   382f2:	bf08      	it	eq
   382f4:	2300      	moveq	r3, #0
	*first = _first; /* Write back read-index */
   382f6:	7113      	strb	r3, [r2, #4]
	if (!evdone) {
   382f8:	b18c      	cbz	r4, 3831e <ull_event_done+0x4a>
	evdone->hdr.type = NODE_RX_TYPE_EVENT_DONE;
   382fa:	2302      	movs	r3, #2
	evdone->hdr.link = NULL;
   382fc:	2500      	movs	r5, #0
	link = evdone->hdr.link;
   382fe:	6820      	ldr	r0, [r4, #0]
	memq_enqueue(link, done, &memq_ull_done.tail);
   38300:	4a09      	ldr	r2, [pc, #36]	; (38328 <ull_event_done+0x54>)
	evdone->hdr.type = NODE_RX_TYPE_EVENT_DONE;
   38302:	7123      	strb	r3, [r4, #4]
	evdone->param = param;
   38304:	61e1      	str	r1, [r4, #28]
	evdone->hdr.link = NULL;
   38306:	6025      	str	r5, [r4, #0]
	memq_enqueue(link, done, &memq_ull_done.tail);
   38308:	4621      	mov	r1, r4
   3830a:	f7fc f93b 	bl	34584 <memq_enqueue>
	mayfly_enqueue(TICKER_USER_ID_LLL, TICKER_USER_ID_ULL_HIGH, 1, &mfy);
   3830e:	2201      	movs	r2, #1
   38310:	4b06      	ldr	r3, [pc, #24]	; (3832c <ull_event_done+0x58>)
   38312:	4611      	mov	r1, r2
   38314:	4628      	mov	r0, r5
   38316:	f7fc f9ab 	bl	34670 <mayfly_enqueue>
}
   3831a:	4620      	mov	r0, r4
   3831c:	bd38      	pop	{r3, r4, r5, pc}
		return NULL;
   3831e:	2400      	movs	r4, #0
   38320:	e7fb      	b.n	3831a <ull_event_done+0x46>
   38322:	bf00      	nop
   38324:	20000928 	.word	0x20000928
   38328:	200045d0 	.word	0x200045d0
   3832c:	20000780 	.word	0x20000780

00038330 <ull_rxfifo_alloc>:
{
   38330:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   38334:	b083      	sub	sp, #12
   38336:	461d      	mov	r5, r3
   38338:	f89d 303c 	ldrb.w	r3, [sp, #60]	; 0x3c
   3833c:	9c0c      	ldr	r4, [sp, #48]	; 0x30
   3833e:	f8dd 9038 	ldr.w	r9, [sp, #56]	; 0x38
   38342:	9401      	str	r4, [sp, #4]
   38344:	4617      	mov	r7, r2
   38346:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   38348:	9200      	str	r2, [sp, #0]
	while ((max--) && mfifo_enqueue_idx_get(n, f, *l, &idx)) {
   3834a:	b353      	cbz	r3, 383a2 <ull_rxfifo_alloc+0x72>
   3834c:	1e5c      	subs	r4, r3, #1
   3834e:	f895 a000 	ldrb.w	sl, [r5]
   38352:	4680      	mov	r8, r0
   38354:	460e      	mov	r6, r1
   38356:	b2e4      	uxtb	r4, r4
	last = last + 1;
   38358:	f10a 0301 	add.w	r3, sl, #1
   3835c:	fa5f fa83 	uxtb.w	sl, r3
		last = 0U;
   38360:	4556      	cmp	r6, sl
   38362:	bf08      	it	eq
   38364:	f04f 0a00 	moveq.w	sl, #0
	if (last == first) {
   38368:	4557      	cmp	r7, sl
		link = mem_acquire(link_free);
   3836a:	4648      	mov	r0, r9
   3836c:	d019      	beq.n	383a2 <ull_rxfifo_alloc+0x72>
   3836e:	f7fc f8a3 	bl	344b8 <mem_acquire>
   38372:	4683      	mov	fp, r0
		rx = mem_acquire(mem_free);
   38374:	9800      	ldr	r0, [sp, #0]
		if (!link) {
   38376:	f1bb 0f00 	cmp.w	fp, #0
   3837a:	d012      	beq.n	383a2 <ull_rxfifo_alloc+0x72>
		rx = mem_acquire(mem_free);
   3837c:	f7fc f89c 	bl	344b8 <mem_acquire>
		if (!rx) {
   38380:	b190      	cbz	r0, 383a8 <ull_rxfifo_alloc+0x78>
		link->mem = NULL;
   38382:	2300      	movs	r3, #0
   38384:	f8cb 3004 	str.w	r3, [fp, #4]
		rx->link = link;
   38388:	f8c0 b000 	str.w	fp, [r0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
   3838c:	782a      	ldrb	r2, [r5, #0]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
   3838e:	9b01      	ldr	r3, [sp, #4]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
   38390:	fb12 f208 	smulbb	r2, r2, r8
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
   38394:	5098      	str	r0, [r3, r2]
	while ((max--) && mfifo_enqueue_idx_get(n, f, *l, &idx)) {
   38396:	3c01      	subs	r4, #1
   38398:	b2e4      	uxtb	r4, r4
   3839a:	2cff      	cmp	r4, #255	; 0xff
	*last = idx; /* Commit: Update write index */
   3839c:	f885 a000 	strb.w	sl, [r5]
   383a0:	d1da      	bne.n	38358 <ull_rxfifo_alloc+0x28>
}
   383a2:	b003      	add	sp, #12
   383a4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			mem_release(link, link_free);
   383a8:	4649      	mov	r1, r9
   383aa:	4658      	mov	r0, fp
}
   383ac:	b003      	add	sp, #12
   383ae:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
			mem_release(link, link_free);
   383b2:	f7fc b89d 	b.w	344f0 <mem_release>
   383b6:	bf00      	nop

000383b8 <init_reset>:
{
   383b8:	b570      	push	{r4, r5, r6, lr}
	RXFIFO_INIT_ALLOC(done);
   383ba:	4c3f      	ldr	r4, [pc, #252]	; (384b8 <init_reset+0x100>)
   383bc:	4d3f      	ldr	r5, [pc, #252]	; (384bc <init_reset+0x104>)
   383be:	79a2      	ldrb	r2, [r4, #6]
   383c0:	88a1      	ldrh	r1, [r4, #4]
   383c2:	4e3f      	ldr	r6, [pc, #252]	; (384c0 <init_reset+0x108>)
   383c4:	2000      	movs	r0, #0
{
   383c6:	b084      	sub	sp, #16
	RXFIFO_INIT_ALLOC(done);
   383c8:	4623      	mov	r3, r4
   383ca:	80a8      	strh	r0, [r5, #4]
   383cc:	f104 0008 	add.w	r0, r4, #8
   383d0:	f7fc f842 	bl	34458 <mem_init>
   383d4:	79e3      	ldrb	r3, [r4, #7]
   383d6:	79a2      	ldrb	r2, [r4, #6]
   383d8:	1d30      	adds	r0, r6, #4
   383da:	441a      	add	r2, r3
   383dc:	2108      	movs	r1, #8
   383de:	4633      	mov	r3, r6
   383e0:	f7fc f83a 	bl	34458 <mem_init>
   383e4:	9602      	str	r6, [sp, #8]
   383e6:	462e      	mov	r6, r5
   383e8:	79a3      	ldrb	r3, [r4, #6]
   383ea:	f816 0b08 	ldrb.w	r0, [r6], #8
   383ee:	9303      	str	r3, [sp, #12]
   383f0:	792a      	ldrb	r2, [r5, #4]
   383f2:	78a9      	ldrb	r1, [r5, #2]
   383f4:	1d6b      	adds	r3, r5, #5
   383f6:	e9cd 6400 	strd	r6, r4, [sp]
   383fa:	f7ff ff99 	bl	38330 <ull_rxfifo_alloc>
	mem_init(mem_pdu_rx.pool, (PDU_RX_NODE_POOL_ELEMENT_SIZE),
   383fe:	4b31      	ldr	r3, [pc, #196]	; (384c4 <init_reset+0x10c>)
   38400:	2213      	movs	r2, #19
   38402:	1d18      	adds	r0, r3, #4
   38404:	2144      	movs	r1, #68	; 0x44
   38406:	f7fc f827 	bl	34458 <mem_init>
	mem_init(mem_link_rx.pool, sizeof(memq_link_t),
   3840a:	4b2f      	ldr	r3, [pc, #188]	; (384c8 <init_reset+0x110>)
   3840c:	2219      	movs	r2, #25
   3840e:	1d18      	adds	r0, r3, #4
   38410:	2108      	movs	r1, #8
   38412:	f7fc f821 	bl	34458 <mem_init>
	link = mem_acquire(&mem_link_rx.free);
   38416:	482c      	ldr	r0, [pc, #176]	; (384c8 <init_reset+0x110>)
   38418:	f7fc f84e 	bl	344b8 <mem_acquire>
	LL_ASSERT(link);
   3841c:	4604      	mov	r4, r0
   3841e:	b308      	cbz	r0, 38464 <init_reset+0xac>
	MEMQ_INIT(ull_rx, link);
   38420:	4a2a      	ldr	r2, [pc, #168]	; (384cc <init_reset+0x114>)
   38422:	4620      	mov	r0, r4
   38424:	1f11      	subs	r1, r2, #4
   38426:	f7fc f89f 	bl	34568 <memq_init>
	link = mem_acquire(&mem_link_done.free);
   3842a:	4825      	ldr	r0, [pc, #148]	; (384c0 <init_reset+0x108>)
   3842c:	f7fc f844 	bl	344b8 <mem_acquire>
	LL_ASSERT(link);
   38430:	4604      	mov	r4, r0
   38432:	b328      	cbz	r0, 38480 <init_reset+0xc8>
	MEMQ_INIT(ull_done, link);
   38434:	4a26      	ldr	r2, [pc, #152]	; (384d0 <init_reset+0x118>)
   38436:	4620      	mov	r0, r4
   38438:	1f11      	subs	r1, r2, #4
   3843a:	f7fc f895 	bl	34568 <memq_init>
	link = mem_acquire(&mem_link_rx.free);
   3843e:	4822      	ldr	r0, [pc, #136]	; (384c8 <init_reset+0x110>)
   38440:	f7fc f83a 	bl	344b8 <mem_acquire>
	LL_ASSERT(link);
   38444:	4604      	mov	r4, r0
   38446:	b348      	cbz	r0, 3849c <init_reset+0xe4>
	MEMQ_INIT(ll_rx, link);
   38448:	4a22      	ldr	r2, [pc, #136]	; (384d4 <init_reset+0x11c>)
   3844a:	4620      	mov	r0, r4
   3844c:	1f11      	subs	r1, r2, #4
   3844e:	f7fc f88b 	bl	34568 <memq_init>
	mem_link_rx.quota_pdu = RX_CNT;
   38452:	4b21      	ldr	r3, [pc, #132]	; (384d8 <init_reset+0x120>)
   38454:	2210      	movs	r2, #16
	rx_replenish(UINT8_MAX);
   38456:	20ff      	movs	r0, #255	; 0xff
	mem_link_rx.quota_pdu = RX_CNT;
   38458:	801a      	strh	r2, [r3, #0]
	rx_replenish(UINT8_MAX);
   3845a:	f7ff f883 	bl	37564 <rx_replenish>
}
   3845e:	2000      	movs	r0, #0
   38460:	b004      	add	sp, #16
   38462:	bd70      	pop	{r4, r5, r6, pc}
	LL_ASSERT(link);
   38464:	4a1d      	ldr	r2, [pc, #116]	; (384dc <init_reset+0x124>)
   38466:	491e      	ldr	r1, [pc, #120]	; (384e0 <init_reset+0x128>)
   38468:	481e      	ldr	r0, [pc, #120]	; (384e4 <init_reset+0x12c>)
   3846a:	f640 03a7 	movw	r3, #2215	; 0x8a7
   3846e:	f010 fe09 	bl	49084 <assert_print>
   38472:	4040      	eors	r0, r0
   38474:	f380 8811 	msr	BASEPRI, r0
   38478:	f04f 0003 	mov.w	r0, #3
   3847c:	df02      	svc	2
   3847e:	e7cf      	b.n	38420 <init_reset+0x68>
	LL_ASSERT(link);
   38480:	4a16      	ldr	r2, [pc, #88]	; (384dc <init_reset+0x124>)
   38482:	4917      	ldr	r1, [pc, #92]	; (384e0 <init_reset+0x128>)
   38484:	4817      	ldr	r0, [pc, #92]	; (384e4 <init_reset+0x12c>)
   38486:	f640 03af 	movw	r3, #2223	; 0x8af
   3848a:	f010 fdfb 	bl	49084 <assert_print>
   3848e:	4040      	eors	r0, r0
   38490:	f380 8811 	msr	BASEPRI, r0
   38494:	f04f 0003 	mov.w	r0, #3
   38498:	df02      	svc	2
   3849a:	e7cb      	b.n	38434 <init_reset+0x7c>
	LL_ASSERT(link);
   3849c:	4a0f      	ldr	r2, [pc, #60]	; (384dc <init_reset+0x124>)
   3849e:	4910      	ldr	r1, [pc, #64]	; (384e0 <init_reset+0x128>)
   384a0:	4810      	ldr	r0, [pc, #64]	; (384e4 <init_reset+0x12c>)
   384a2:	f640 03b7 	movw	r3, #2231	; 0x8b7
   384a6:	f010 fded 	bl	49084 <assert_print>
   384aa:	4040      	eors	r0, r0
   384ac:	f380 8811 	msr	BASEPRI, r0
   384b0:	f04f 0003 	mov.w	r0, #3
   384b4:	df02      	svc	2
   384b6:	e7c7      	b.n	38448 <init_reset+0x90>
   384b8:	20000850 	.word	0x20000850
   384bc:	20000928 	.word	0x20000928
   384c0:	20004bc4 	.word	0x20004bc4
   384c4:	200046b4 	.word	0x200046b4
   384c8:	200045e8 	.word	0x200045e8
   384cc:	200045e0 	.word	0x200045e0
   384d0:	200045d0 	.word	0x200045d0
   384d4:	200045d8 	.word	0x200045d8
   384d8:	200045e4 	.word	0x200045e4
   384dc:	000522f4 	.word	0x000522f4
   384e0:	000526f4 	.word	0x000526f4
   384e4:	0005214c 	.word	0x0005214c

000384e8 <ll_init>:
{
   384e8:	b530      	push	{r4, r5, lr}
	sem_recv = sem_rx;
   384ea:	4b2e      	ldr	r3, [pc, #184]	; (385a4 <ll_init+0xbc>)
	if (!mayfly_initialized) {
   384ec:	4c2e      	ldr	r4, [pc, #184]	; (385a8 <ll_init+0xc0>)
	sem_recv = sem_rx;
   384ee:	6018      	str	r0, [r3, #0]
{
   384f0:	b087      	sub	sp, #28
	cntr_init();
   384f2:	f009 fa4b 	bl	4198c <cntr_init>
	if (!mayfly_initialized) {
   384f6:	7823      	ldrb	r3, [r4, #0]
   384f8:	2b00      	cmp	r3, #0
   384fa:	d04e      	beq.n	3859a <ll_init+0xb2>
	ticker_users[MAYFLY_CALL_ID_0][0] = TICKER_USER_LLL_OPS;
   384fc:	4a2b      	ldr	r2, [pc, #172]	; (385ac <ll_init+0xc4>)
	err = ticker_init(TICKER_INSTANCE_ID_CTLR,
   384fe:	4c2c      	ldr	r4, [pc, #176]	; (385b0 <ll_init+0xc8>)
   38500:	4d2c      	ldr	r5, [pc, #176]	; (385b4 <ll_init+0xcc>)
   38502:	9505      	str	r5, [sp, #20]
	ticker_users[MAYFLY_CALL_ID_1][0] = TICKER_USER_ULL_HIGH_OPS;
   38504:	f04f 0c05 	mov.w	ip, #5
   38508:	f882 c008 	strb.w	ip, [r2, #8]
	err = ticker_init(TICKER_INSTANCE_ID_CTLR,
   3850c:	9404      	str	r4, [sp, #16]
   3850e:	4c2a      	ldr	r4, [pc, #168]	; (385b8 <ll_init+0xd0>)
   38510:	9403      	str	r4, [sp, #12]
   38512:	4c2a      	ldr	r4, [pc, #168]	; (385bc <ll_init+0xd4>)
   38514:	9200      	str	r2, [sp, #0]
	ticker_users[MAYFLY_CALL_ID_2][0] = TICKER_USER_ULL_LOW_OPS;
   38516:	2002      	movs	r0, #2
	ticker_users[MAYFLY_CALL_ID_0][0] = TICKER_USER_LLL_OPS;
   38518:	2304      	movs	r3, #4
	err = ticker_init(TICKER_INSTANCE_ID_CTLR,
   3851a:	210d      	movs	r1, #13
   3851c:	e9cd 1401 	strd	r1, r4, [sp, #4]
	ticker_users[MAYFLY_CALL_ID_2][0] = TICKER_USER_ULL_LOW_OPS;
   38520:	7410      	strb	r0, [r2, #16]
	ticker_users[MAYFLY_CALL_ID_PROGRAM][0] = TICKER_USER_THREAD_OPS;
   38522:	7610      	strb	r0, [r2, #24]
	ticker_users[MAYFLY_CALL_ID_0][0] = TICKER_USER_LLL_OPS;
   38524:	7013      	strb	r3, [r2, #0]
	err = ticker_init(TICKER_INSTANCE_ID_CTLR,
   38526:	2000      	movs	r0, #0
   38528:	4a25      	ldr	r2, [pc, #148]	; (385c0 <ll_init+0xd8>)
   3852a:	f7fd f98d 	bl	35848 <ticker_init>
	LL_ASSERT(!err);
   3852e:	bb30      	cbnz	r0, 3857e <ll_init+0x96>
	return z_impl_k_sem_init(sem, initial_count, limit);
   38530:	2201      	movs	r2, #1
   38532:	2100      	movs	r1, #0
   38534:	4823      	ldr	r0, [pc, #140]	; (385c4 <ll_init+0xdc>)
   38536:	f017 fc9f 	bl	4fe78 <z_impl_k_sem_init>
	err = lll_init();
   3853a:	f007 f80d 	bl	3f558 <lll_init>
	if (err) {
   3853e:	b108      	cbz	r0, 38544 <ll_init+0x5c>
}
   38540:	b007      	add	sp, #28
   38542:	bd30      	pop	{r4, r5, pc}
	err = init_reset();
   38544:	f7ff ff38 	bl	383b8 <init_reset>
	if (err) {
   38548:	2800      	cmp	r0, #0
   3854a:	d1f9      	bne.n	38540 <ll_init+0x58>
	err = lll_adv_init();
   3854c:	f007 fc76 	bl	3fe3c <lll_adv_init>
	if (err) {
   38550:	2800      	cmp	r0, #0
   38552:	d1f5      	bne.n	38540 <ll_init+0x58>
	err = ull_adv_init();
   38554:	f000 fcfa 	bl	38f4c <ull_adv_init>
	if (err) {
   38558:	2800      	cmp	r0, #0
   3855a:	d1f1      	bne.n	38540 <ll_init+0x58>
	err = lll_scan_init();
   3855c:	f008 face 	bl	40afc <lll_scan_init>
	if (err) {
   38560:	2800      	cmp	r0, #0
   38562:	d1ed      	bne.n	38540 <ll_init+0x58>
	err = ull_scan_init();
   38564:	f000 fe54 	bl	39210 <ull_scan_init>
	if (err) {
   38568:	2800      	cmp	r0, #0
   3856a:	d1e9      	bne.n	38540 <ll_init+0x58>
	err = lll_conn_init();
   3856c:	f008 fbe0 	bl	40d30 <lll_conn_init>
	if (err) {
   38570:	2800      	cmp	r0, #0
   38572:	d1e5      	bne.n	38540 <ll_init+0x58>
}
   38574:	b007      	add	sp, #28
   38576:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	err = ull_conn_init();
   3857a:	f002 b8bd 	b.w	3a6f8 <ull_conn_init>
	LL_ASSERT(!err);
   3857e:	4a12      	ldr	r2, [pc, #72]	; (385c8 <ll_init+0xe0>)
   38580:	4912      	ldr	r1, [pc, #72]	; (385cc <ll_init+0xe4>)
   38582:	4813      	ldr	r0, [pc, #76]	; (385d0 <ll_init+0xe8>)
   38584:	f44f 7317 	mov.w	r3, #604	; 0x25c
   38588:	f010 fd7c 	bl	49084 <assert_print>
   3858c:	4040      	eors	r0, r0
   3858e:	f380 8811 	msr	BASEPRI, r0
   38592:	f04f 0003 	mov.w	r0, #3
   38596:	df02      	svc	2
   38598:	e7ca      	b.n	38530 <ll_init+0x48>
		mayfly_init();
   3859a:	f7fc f815 	bl	345c8 <mayfly_init>
		mayfly_initialized = true;
   3859e:	2301      	movs	r3, #1
   385a0:	7023      	strb	r3, [r4, #0]
   385a2:	e7ab      	b.n	384fc <ll_init+0x14>
   385a4:	20004bf0 	.word	0x20004bf0
   385a8:	20006baa 	.word	0x20006baa
   385ac:	20004eb0 	.word	0x20004eb0
   385b0:	00042475 	.word	0x00042475
   385b4:	000425c5 	.word	0x000425c5
   385b8:	00042411 	.word	0x00042411
   385bc:	20004c0c 	.word	0x20004c0c
   385c0:	20004ed0 	.word	0x20004ed0
   385c4:	20004bf4 	.word	0x20004bf4
   385c8:	000522f4 	.word	0x000522f4
   385cc:	00052330 	.word	0x00052330
   385d0:	0005214c 	.word	0x0005214c

000385d4 <ll_reset>:
{
   385d4:	b510      	push	{r4, lr}
   385d6:	b086      	sub	sp, #24
	err = ull_adv_reset();
   385d8:	f000 fcc8 	bl	38f6c <ull_adv_reset>
	LL_ASSERT(!err);
   385dc:	2800      	cmp	r0, #0
   385de:	d135      	bne.n	3864c <ll_reset+0x78>
	err = ull_scan_reset();
   385e0:	f000 fe66 	bl	392b0 <ull_scan_reset>
	LL_ASSERT(!err);
   385e4:	2800      	cmp	r0, #0
   385e6:	d142      	bne.n	3866e <ll_reset+0x9a>
	err = ull_conn_reset();
   385e8:	f002 f888 	bl	3a6fc <ull_conn_reset>
	LL_ASSERT(!err);
   385ec:	2800      	cmp	r0, #0
   385ee:	d14f      	bne.n	38690 <ll_reset+0xbc>
	MFIFO_INIT(tx_ack);
   385f0:	4843      	ldr	r0, [pc, #268]	; (38700 <ll_reset+0x12c>)
	MFIFO_INIT(prep);
   385f2:	4944      	ldr	r1, [pc, #272]	; (38704 <ll_reset+0x130>)
	MFIFO_INIT(pdu_rx_free);
   385f4:	4a44      	ldr	r2, [pc, #272]	; (38708 <ll_reset+0x134>)
	MFIFO_INIT(ll_pdu_rx_free);
   385f6:	4b45      	ldr	r3, [pc, #276]	; (3870c <ll_reset+0x138>)
	MFIFO_INIT(tx_ack);
   385f8:	2400      	movs	r4, #0
   385fa:	8084      	strh	r4, [r0, #4]
	MFIFO_INIT(prep);
   385fc:	808c      	strh	r4, [r1, #4]
	MFIFO_INIT(pdu_rx_free);
   385fe:	8094      	strh	r4, [r2, #4]
	MFIFO_INIT(ll_pdu_rx_free);
   38600:	809c      	strh	r4, [r3, #4]
   38602:	2201      	movs	r2, #1
   38604:	4621      	mov	r1, r4
   38606:	4668      	mov	r0, sp
   38608:	f017 fc36 	bl	4fe78 <z_impl_k_sem_init>
		mfy.param = &sem;
   3860c:	4b40      	ldr	r3, [pc, #256]	; (38710 <ll_reset+0x13c>)
		retval = mayfly_enqueue(TICKER_USER_ID_THREAD,
   3860e:	4622      	mov	r2, r4
   38610:	4621      	mov	r1, r4
   38612:	2003      	movs	r0, #3
		mfy.param = &sem;
   38614:	f8c3 d008 	str.w	sp, [r3, #8]
		retval = mayfly_enqueue(TICKER_USER_ID_THREAD,
   38618:	f7fc f82a 	bl	34670 <mayfly_enqueue>
		LL_ASSERT(!retval);
   3861c:	2800      	cmp	r0, #0
   3861e:	d161      	bne.n	386e4 <ll_reset+0x110>
	return z_impl_k_sem_take(sem, timeout);
   38620:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   38624:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   38628:	4668      	mov	r0, sp
   3862a:	f00e fdcb 	bl	471c4 <z_impl_k_sem_take>
	err = ull_adv_reset_finalize();
   3862e:	f000 fca3 	bl	38f78 <ull_adv_reset_finalize>
	LL_ASSERT(!err);
   38632:	2800      	cmp	r0, #0
   38634:	d148      	bne.n	386c8 <ll_reset+0xf4>
	err = init_reset();
   38636:	f7ff febf 	bl	383b8 <init_reset>
	LL_ASSERT(!err);
   3863a:	2800      	cmp	r0, #0
   3863c:	d136      	bne.n	386ac <ll_reset+0xd8>
	(void)ll_addr_set(1U, NULL);
   3863e:	2100      	movs	r1, #0
   38640:	2001      	movs	r0, #1
}
   38642:	b006      	add	sp, #24
   38644:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	(void)ll_addr_set(1U, NULL);
   38648:	f7fd bade 	b.w	35c08 <ll_addr_set>
	LL_ASSERT(!err);
   3864c:	4a31      	ldr	r2, [pc, #196]	; (38714 <ll_reset+0x140>)
   3864e:	4932      	ldr	r1, [pc, #200]	; (38718 <ll_reset+0x144>)
   38650:	4832      	ldr	r0, [pc, #200]	; (3871c <ll_reset+0x148>)
   38652:	f240 3302 	movw	r3, #770	; 0x302
   38656:	f010 fd15 	bl	49084 <assert_print>
   3865a:	4040      	eors	r0, r0
   3865c:	f380 8811 	msr	BASEPRI, r0
   38660:	f04f 0003 	mov.w	r0, #3
   38664:	df02      	svc	2
	err = ull_scan_reset();
   38666:	f000 fe23 	bl	392b0 <ull_scan_reset>
	LL_ASSERT(!err);
   3866a:	2800      	cmp	r0, #0
   3866c:	d0bc      	beq.n	385e8 <ll_reset+0x14>
   3866e:	4a29      	ldr	r2, [pc, #164]	; (38714 <ll_reset+0x140>)
   38670:	4929      	ldr	r1, [pc, #164]	; (38718 <ll_reset+0x144>)
   38672:	482a      	ldr	r0, [pc, #168]	; (3871c <ll_reset+0x148>)
   38674:	f44f 7345 	mov.w	r3, #788	; 0x314
   38678:	f010 fd04 	bl	49084 <assert_print>
   3867c:	4040      	eors	r0, r0
   3867e:	f380 8811 	msr	BASEPRI, r0
   38682:	f04f 0003 	mov.w	r0, #3
   38686:	df02      	svc	2
	err = ull_conn_reset();
   38688:	f002 f838 	bl	3a6fc <ull_conn_reset>
	LL_ASSERT(!err);
   3868c:	2800      	cmp	r0, #0
   3868e:	d0af      	beq.n	385f0 <ll_reset+0x1c>
   38690:	4a20      	ldr	r2, [pc, #128]	; (38714 <ll_reset+0x140>)
   38692:	4921      	ldr	r1, [pc, #132]	; (38718 <ll_reset+0x144>)
   38694:	4821      	ldr	r0, [pc, #132]	; (3871c <ll_reset+0x148>)
   38696:	f44f 734d 	mov.w	r3, #820	; 0x334
   3869a:	f010 fcf3 	bl	49084 <assert_print>
   3869e:	4040      	eors	r0, r0
   386a0:	f380 8811 	msr	BASEPRI, r0
   386a4:	f04f 0003 	mov.w	r0, #3
   386a8:	df02      	svc	2
   386aa:	e7a1      	b.n	385f0 <ll_reset+0x1c>
	LL_ASSERT(!err);
   386ac:	4a19      	ldr	r2, [pc, #100]	; (38714 <ll_reset+0x140>)
   386ae:	491a      	ldr	r1, [pc, #104]	; (38718 <ll_reset+0x144>)
   386b0:	481a      	ldr	r0, [pc, #104]	; (3871c <ll_reset+0x148>)
   386b2:	f240 337d 	movw	r3, #893	; 0x37d
   386b6:	f010 fce5 	bl	49084 <assert_print>
   386ba:	4040      	eors	r0, r0
   386bc:	f380 8811 	msr	BASEPRI, r0
   386c0:	f04f 0003 	mov.w	r0, #3
   386c4:	df02      	svc	2
   386c6:	e7ba      	b.n	3863e <ll_reset+0x6a>
	LL_ASSERT(!err);
   386c8:	4a12      	ldr	r2, [pc, #72]	; (38714 <ll_reset+0x140>)
   386ca:	4913      	ldr	r1, [pc, #76]	; (38718 <ll_reset+0x144>)
   386cc:	4813      	ldr	r0, [pc, #76]	; (3871c <ll_reset+0x148>)
   386ce:	f44f 735c 	mov.w	r3, #880	; 0x370
   386d2:	f010 fcd7 	bl	49084 <assert_print>
   386d6:	4040      	eors	r0, r0
   386d8:	f380 8811 	msr	BASEPRI, r0
   386dc:	f04f 0003 	mov.w	r0, #3
   386e0:	df02      	svc	2
   386e2:	e7a8      	b.n	38636 <ll_reset+0x62>
		LL_ASSERT(!retval);
   386e4:	4a0b      	ldr	r2, [pc, #44]	; (38714 <ll_reset+0x140>)
   386e6:	490e      	ldr	r1, [pc, #56]	; (38720 <ll_reset+0x14c>)
   386e8:	480c      	ldr	r0, [pc, #48]	; (3871c <ll_reset+0x148>)
   386ea:	f240 3363 	movw	r3, #867	; 0x363
   386ee:	f010 fcc9 	bl	49084 <assert_print>
   386f2:	4040      	eors	r0, r0
   386f4:	f380 8811 	msr	BASEPRI, r0
   386f8:	f04f 0003 	mov.w	r0, #3
   386fc:	df02      	svc	2
   386fe:	e78f      	b.n	38620 <ll_reset+0x4c>
   38700:	200007d0 	.word	0x200007d0
   38704:	20000944 	.word	0x20000944
   38708:	20000834 	.word	0x20000834
   3870c:	200007f8 	.word	0x200007f8
   38710:	200007c0 	.word	0x200007c0
   38714:	000522f4 	.word	0x000522f4
   38718:	00052330 	.word	0x00052330
   3871c:	0005214c 	.word	0x0005214c
   38720:	00052458 	.word	0x00052458

00038724 <ll_deinit>:
{
   38724:	b508      	push	{r3, lr}
	ll_reset();
   38726:	f7ff ff55 	bl	385d4 <ll_reset>
}
   3872a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	return lll_deinit();
   3872e:	f006 bf43 	b.w	3f5b8 <lll_deinit>
   38732:	bf00      	nop

00038734 <lll_prepare>:
 *	   -EINPROGRESS: Event already in progress and prepare was queued
 */
int lll_prepare(lll_is_abort_cb_t is_abort_cb, lll_abort_cb_t abort_cb,
		lll_prepare_cb_t prepare_cb, int8_t event_prio,
		struct lll_prepare_param *prepare_param)
{
   38734:	b510      	push	{r4, lr}
   38736:	b082      	sub	sp, #8
	}

	prepare_param->prio = prio;
#endif /* CONFIG_BT_CTLR_JIT_SCHEDULING */

	return lll_prepare_resolve(is_abort_cb, abort_cb, prepare_cb,
   38738:	2400      	movs	r4, #0
   3873a:	e9cd 4400 	strd	r4, r4, [sp]
   3873e:	9b04      	ldr	r3, [sp, #16]
   38740:	f007 f932 	bl	3f9a8 <lll_prepare_resolve>
				   prepare_param, 0, 0);
}
   38744:	b002      	add	sp, #8
   38746:	bd10      	pop	{r4, pc}

00038748 <lll_resume>:

void lll_resume(void *param)
{
   38748:	b510      	push	{r4, lr}
   3874a:	4603      	mov	r3, r0
	int ret;

	next = param;
	ret = lll_prepare_resolve(next->is_abort_cb, next->abort_cb,
				  next->prepare_cb, &next->prepare_param,
				  next->is_resume, 1);
   3874c:	7f00      	ldrb	r0, [r0, #28]
	ret = lll_prepare_resolve(next->is_abort_cb, next->abort_cb,
   3874e:	691a      	ldr	r2, [r3, #16]
   38750:	6999      	ldr	r1, [r3, #24]
   38752:	2401      	movs	r4, #1
{
   38754:	b082      	sub	sp, #8
	ret = lll_prepare_resolve(next->is_abort_cb, next->abort_cb,
   38756:	4020      	ands	r0, r4
   38758:	e9cd 0400 	strd	r0, r4, [sp]
   3875c:	6958      	ldr	r0, [r3, #20]
   3875e:	f007 f923 	bl	3f9a8 <lll_prepare_resolve>
	LL_ASSERT(!ret || ret == -EINPROGRESS);
   38762:	b108      	cbz	r0, 38768 <lll_resume+0x20>
   38764:	3077      	adds	r0, #119	; 0x77
   38766:	d101      	bne.n	3876c <lll_resume+0x24>
}
   38768:	b002      	add	sp, #8
   3876a:	bd10      	pop	{r4, pc}
	LL_ASSERT(!ret || ret == -EINPROGRESS);
   3876c:	4a06      	ldr	r2, [pc, #24]	; (38788 <lll_resume+0x40>)
   3876e:	4907      	ldr	r1, [pc, #28]	; (3878c <lll_resume+0x44>)
   38770:	4807      	ldr	r0, [pc, #28]	; (38790 <lll_resume+0x48>)
   38772:	234f      	movs	r3, #79	; 0x4f
   38774:	f010 fc86 	bl	49084 <assert_print>
   38778:	4040      	eors	r0, r0
   3877a:	f380 8811 	msr	BASEPRI, r0
   3877e:	f04f 0003 	mov.w	r0, #3
   38782:	df02      	svc	2
}
   38784:	b002      	add	sp, #8
   38786:	bd10      	pop	{r4, pc}
   38788:	00052460 	.word	0x00052460
   3878c:	000524a4 	.word	0x000524a4
   38790:	0005214c 	.word	0x0005214c

00038794 <ticker_stop_cb>:
{
   38794:	b530      	push	{r4, r5, lr}
   38796:	b083      	sub	sp, #12
	return ((uint8_t *)adv - (uint8_t *)ll_adv) / sizeof(*adv);
   38798:	4b19      	ldr	r3, [pc, #100]	; (38800 <ticker_stop_cb+0x6c>)
{
   3879a:	9d07      	ldr	r5, [sp, #28]
	return ((uint8_t *)adv - (uint8_t *)ll_adv) / sizeof(*adv);
   3879c:	4a19      	ldr	r2, [pc, #100]	; (38804 <ticker_stop_cb+0x70>)
   3879e:	1aeb      	subs	r3, r5, r3
   387a0:	fba2 2303 	umull	r2, r3, r2, r3
	LL_ASSERT(handle < BT_CTLR_ADV_SET);
   387a4:	f413 5f7f 	tst.w	r3, #16320	; 0x3fc0
	handle = ull_adv_handle_get(adv);
   387a8:	f3c3 1487 	ubfx	r4, r3, #6, #8
	LL_ASSERT(handle < BT_CTLR_ADV_SET);
   387ac:	d119      	bne.n	387e2 <ticker_stop_cb+0x4e>
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_ULL_HIGH,
   387ae:	1ca2      	adds	r2, r4, #2
   387b0:	4b15      	ldr	r3, [pc, #84]	; (38808 <ticker_stop_cb+0x74>)
   387b2:	9500      	str	r5, [sp, #0]
   387b4:	b2d2      	uxtb	r2, r2
   387b6:	2101      	movs	r1, #1
   387b8:	2000      	movs	r0, #0
   387ba:	f7fd f97f 	bl	35abc <ticker_stop>
	LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
   387be:	f030 0302 	bics.w	r3, r0, #2
   387c2:	d00c      	beq.n	387de <ticker_stop_cb+0x4a>
   387c4:	4a11      	ldr	r2, [pc, #68]	; (3880c <ticker_stop_cb+0x78>)
   387c6:	4912      	ldr	r1, [pc, #72]	; (38810 <ticker_stop_cb+0x7c>)
   387c8:	4812      	ldr	r0, [pc, #72]	; (38814 <ticker_stop_cb+0x80>)
   387ca:	f640 131f 	movw	r3, #2335	; 0x91f
   387ce:	f010 fc59 	bl	49084 <assert_print>
   387d2:	4040      	eors	r0, r0
   387d4:	f380 8811 	msr	BASEPRI, r0
   387d8:	f04f 0003 	mov.w	r0, #3
   387dc:	df02      	svc	2
}
   387de:	b003      	add	sp, #12
   387e0:	bd30      	pop	{r4, r5, pc}
	LL_ASSERT(handle < BT_CTLR_ADV_SET);
   387e2:	4a0a      	ldr	r2, [pc, #40]	; (3880c <ticker_stop_cb+0x78>)
   387e4:	490c      	ldr	r1, [pc, #48]	; (38818 <ticker_stop_cb+0x84>)
   387e6:	480b      	ldr	r0, [pc, #44]	; (38814 <ticker_stop_cb+0x80>)
   387e8:	f640 131a 	movw	r3, #2330	; 0x91a
   387ec:	f010 fc4a 	bl	49084 <assert_print>
   387f0:	4040      	eors	r0, r0
   387f2:	f380 8811 	msr	BASEPRI, r0
   387f6:	f04f 0003 	mov.w	r0, #3
   387fa:	df02      	svc	2
   387fc:	e7d7      	b.n	387ae <ticker_stop_cb+0x1a>
   387fe:	bf00      	nop
   38800:	20005174 	.word	0x20005174
   38804:	8d3dcb09 	.word	0x8d3dcb09
   38808:	000388b1 	.word	0x000388b1
   3880c:	000524b8 	.word	0x000524b8
   38810:	00052504 	.word	0x00052504
   38814:	0005214c 	.word	0x0005214c
   38818:	000524f8 	.word	0x000524f8

0003881c <disabled_cb>:
{
   3881c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	adv = ((struct lll_hdr *)param)->parent;
   3881e:	6805      	ldr	r5, [r0, #0]
	LL_ASSERT(adv->link_cc_free);
   38820:	6e2f      	ldr	r7, [r5, #96]	; 0x60
{
   38822:	4606      	mov	r6, r0
	LL_ASSERT(adv->link_cc_free);
   38824:	b1d7      	cbz	r7, 3885c <disabled_cb+0x40>
	LL_ASSERT(adv->node_rx_cc_free);
   38826:	6e6c      	ldr	r4, [r5, #100]	; 0x64
	adv->link_cc_free = NULL;
   38828:	2300      	movs	r3, #0
   3882a:	662b      	str	r3, [r5, #96]	; 0x60
	LL_ASSERT(adv->node_rx_cc_free);
   3882c:	b34c      	cbz	r4, 38882 <disabled_cb+0x66>
	adv->node_rx_cc_free = NULL;
   3882e:	2100      	movs	r1, #0
	rx->hdr.type = NODE_RX_TYPE_CONNECTION;
   38830:	2317      	movs	r3, #23
	adv->node_rx_cc_free = NULL;
   38832:	6669      	str	r1, [r5, #100]	; 0x64
	rx->hdr.type = NODE_RX_TYPE_CONNECTION;
   38834:	7123      	strb	r3, [r4, #4]
	rx->hdr.handle = 0xffff;
   38836:	f64f 73ff 	movw	r3, #65535	; 0xffff
   3883a:	80e3      	strh	r3, [r4, #6]
	memset(cc, 0x00, sizeof(struct node_rx_cc));
   3883c:	2212      	movs	r2, #18
   3883e:	f104 001c 	add.w	r0, r4, #28
   38842:	f012 fb25 	bl	4ae90 <memset>
	cc->status = BT_HCI_ERR_ADV_TIMEOUT;
   38846:	233c      	movs	r3, #60	; 0x3c
   38848:	7723      	strb	r3, [r4, #28]
	rx->hdr.rx_ftr.param = param;
   3884a:	60a6      	str	r6, [r4, #8]
	ll_rx_put(link, rx);
   3884c:	4621      	mov	r1, r4
   3884e:	4638      	mov	r0, r7
   38850:	f7ff fa98 	bl	37d84 <ll_rx_put>
}
   38854:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	ll_rx_sched();
   38858:	f7ff ba9e 	b.w	37d98 <ll_rx_sched>
	LL_ASSERT(adv->link_cc_free);
   3885c:	4a10      	ldr	r2, [pc, #64]	; (388a0 <disabled_cb+0x84>)
   3885e:	4911      	ldr	r1, [pc, #68]	; (388a4 <disabled_cb+0x88>)
   38860:	4811      	ldr	r0, [pc, #68]	; (388a8 <disabled_cb+0x8c>)
   38862:	f640 1367 	movw	r3, #2407	; 0x967
   38866:	f010 fc0d 	bl	49084 <assert_print>
   3886a:	4040      	eors	r0, r0
   3886c:	f380 8811 	msr	BASEPRI, r0
   38870:	f04f 0003 	mov.w	r0, #3
   38874:	df02      	svc	2
	LL_ASSERT(adv->node_rx_cc_free);
   38876:	6e6c      	ldr	r4, [r5, #100]	; 0x64
	link = adv->link_cc_free;
   38878:	6e2f      	ldr	r7, [r5, #96]	; 0x60
	adv->link_cc_free = NULL;
   3887a:	2300      	movs	r3, #0
   3887c:	662b      	str	r3, [r5, #96]	; 0x60
	LL_ASSERT(adv->node_rx_cc_free);
   3887e:	2c00      	cmp	r4, #0
   38880:	d1d5      	bne.n	3882e <disabled_cb+0x12>
   38882:	4a07      	ldr	r2, [pc, #28]	; (388a0 <disabled_cb+0x84>)
   38884:	4909      	ldr	r1, [pc, #36]	; (388ac <disabled_cb+0x90>)
   38886:	4808      	ldr	r0, [pc, #32]	; (388a8 <disabled_cb+0x8c>)
   38888:	f640 136b 	movw	r3, #2411	; 0x96b
   3888c:	f010 fbfa 	bl	49084 <assert_print>
   38890:	4040      	eors	r0, r0
   38892:	f380 8811 	msr	BASEPRI, r0
   38896:	f04f 0003 	mov.w	r0, #3
   3889a:	df02      	svc	2
	rx = adv->node_rx_cc_free;
   3889c:	6e6c      	ldr	r4, [r5, #100]	; 0x64
   3889e:	e7c6      	b.n	3882e <disabled_cb+0x12>
   388a0:	000524b8 	.word	0x000524b8
   388a4:	00052520 	.word	0x00052520
   388a8:	0005214c 	.word	0x0005214c
   388ac:	00052534 	.word	0x00052534

000388b0 <ticker_stop_op_cb>:
	if (status != TICKER_STATUS_SUCCESS) {
   388b0:	b100      	cbz	r0, 388b4 <ticker_stop_op_cb+0x4>
   388b2:	4770      	bx	lr
	mfy.param = param;
   388b4:	4b0c      	ldr	r3, [pc, #48]	; (388e8 <ticker_stop_op_cb+0x38>)
{
   388b6:	b510      	push	{r4, lr}
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_LOW,
   388b8:	4602      	mov	r2, r0
   388ba:	460c      	mov	r4, r1
   388bc:	2002      	movs	r0, #2
   388be:	2101      	movs	r1, #1
	mfy.param = param;
   388c0:	609c      	str	r4, [r3, #8]
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_LOW,
   388c2:	f7fb fed5 	bl	34670 <mayfly_enqueue>
	LL_ASSERT(!ret);
   388c6:	b900      	cbnz	r0, 388ca <ticker_stop_op_cb+0x1a>
}
   388c8:	bd10      	pop	{r4, pc}
	LL_ASSERT(!ret);
   388ca:	4a08      	ldr	r2, [pc, #32]	; (388ec <ticker_stop_op_cb+0x3c>)
   388cc:	4908      	ldr	r1, [pc, #32]	; (388f0 <ticker_stop_op_cb+0x40>)
   388ce:	4809      	ldr	r0, [pc, #36]	; (388f4 <ticker_stop_op_cb+0x44>)
   388d0:	f640 133b 	movw	r3, #2363	; 0x93b
   388d4:	f010 fbd6 	bl	49084 <assert_print>
   388d8:	4040      	eors	r0, r0
   388da:	f380 8811 	msr	BASEPRI, r0
   388de:	f04f 0003 	mov.w	r0, #3
   388e2:	df02      	svc	2
}
   388e4:	bd10      	pop	{r4, pc}
   388e6:	bf00      	nop
   388e8:	20000a6c 	.word	0x20000a6c
   388ec:	000524b8 	.word	0x000524b8
   388f0:	00052430 	.word	0x00052430
   388f4:	0005214c 	.word	0x0005214c

000388f8 <adv_disable>:
{
   388f8:	b538      	push	{r3, r4, r5, lr}
   388fa:	4604      	mov	r4, r0
   388fc:	f810 3b1c 	ldrb.w	r3, [r0], #28
	if (ull_ref_get(hdr)) {
   38900:	b353      	cbz	r3, 38958 <adv_disable+0x60>
		mfy.param = &adv->lll;
   38902:	4d17      	ldr	r5, [pc, #92]	; (38960 <adv_disable+0x68>)
		LL_ASSERT(!hdr->disabled_cb);
   38904:	6963      	ldr	r3, [r4, #20]
		mfy.param = &adv->lll;
   38906:	60a8      	str	r0, [r5, #8]
		LL_ASSERT(!hdr->disabled_cb);
   38908:	b16b      	cbz	r3, 38926 <adv_disable+0x2e>
   3890a:	4a16      	ldr	r2, [pc, #88]	; (38964 <adv_disable+0x6c>)
   3890c:	4916      	ldr	r1, [pc, #88]	; (38968 <adv_disable+0x70>)
   3890e:	4817      	ldr	r0, [pc, #92]	; (3896c <adv_disable+0x74>)
   38910:	f44f 6315 	mov.w	r3, #2384	; 0x950
   38914:	f010 fbb6 	bl	49084 <assert_print>
   38918:	4040      	eors	r0, r0
   3891a:	f380 8811 	msr	BASEPRI, r0
   3891e:	f04f 0003 	mov.w	r0, #3
   38922:	df02      	svc	2
		hdr->disabled_param = mfy.param;
   38924:	68a8      	ldr	r0, [r5, #8]
		hdr->disabled_cb = disabled_cb;
   38926:	4912      	ldr	r1, [pc, #72]	; (38970 <adv_disable+0x78>)
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
   38928:	4b0d      	ldr	r3, [pc, #52]	; (38960 <adv_disable+0x68>)
   3892a:	2200      	movs	r2, #0
		hdr->disabled_cb = disabled_cb;
   3892c:	e9c4 1005 	strd	r1, r0, [r4, #20]
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
   38930:	4611      	mov	r1, r2
   38932:	2001      	movs	r0, #1
   38934:	f7fb fe9c 	bl	34670 <mayfly_enqueue>
		LL_ASSERT(!ret);
   38938:	b900      	cbnz	r0, 3893c <adv_disable+0x44>
}
   3893a:	bd38      	pop	{r3, r4, r5, pc}
		LL_ASSERT(!ret);
   3893c:	4a09      	ldr	r2, [pc, #36]	; (38964 <adv_disable+0x6c>)
   3893e:	490d      	ldr	r1, [pc, #52]	; (38974 <adv_disable+0x7c>)
   38940:	480a      	ldr	r0, [pc, #40]	; (3896c <adv_disable+0x74>)
   38942:	f640 1357 	movw	r3, #2391	; 0x957
   38946:	f010 fb9d 	bl	49084 <assert_print>
   3894a:	4040      	eors	r0, r0
   3894c:	f380 8811 	msr	BASEPRI, r0
   38950:	f04f 0003 	mov.w	r0, #3
   38954:	df02      	svc	2
}
   38956:	bd38      	pop	{r3, r4, r5, pc}
   38958:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		disabled_cb(&adv->lll);
   3895c:	f7ff bf5e 	b.w	3881c <disabled_cb>
   38960:	20000a5c 	.word	0x20000a5c
   38964:	000524b8 	.word	0x000524b8
   38968:	0005254c 	.word	0x0005254c
   3896c:	0005214c 	.word	0x0005214c
   38970:	0003881d 	.word	0x0003881d
   38974:	00052430 	.word	0x00052430

00038978 <ticker_update_op_cb>:
	LL_ASSERT(status == TICKER_STATUS_SUCCESS ||
   38978:	b900      	cbnz	r0, 3897c <ticker_update_op_cb+0x4>
   3897a:	4770      	bx	lr
{
   3897c:	b510      	push	{r4, lr}
   3897e:	460c      	mov	r4, r1
	LL_ASSERT(status == TICKER_STATUS_SUCCESS ||
   38980:	f7ff fae0 	bl	37f44 <ull_disable_mark_get>
   38984:	4284      	cmp	r4, r0
   38986:	d00c      	beq.n	389a2 <ticker_update_op_cb+0x2a>
   38988:	4a06      	ldr	r2, [pc, #24]	; (389a4 <ticker_update_op_cb+0x2c>)
   3898a:	4907      	ldr	r1, [pc, #28]	; (389a8 <ticker_update_op_cb+0x30>)
   3898c:	4807      	ldr	r0, [pc, #28]	; (389ac <ticker_update_op_cb+0x34>)
   3898e:	f640 130c 	movw	r3, #2316	; 0x90c
   38992:	f010 fb77 	bl	49084 <assert_print>
   38996:	4040      	eors	r0, r0
   38998:	f380 8811 	msr	BASEPRI, r0
   3899c:	f04f 0003 	mov.w	r0, #3
   389a0:	df02      	svc	2
}
   389a2:	bd10      	pop	{r4, pc}
   389a4:	000524b8 	.word	0x000524b8
   389a8:	00052560 	.word	0x00052560
   389ac:	0005214c 	.word	0x0005214c

000389b0 <init_set.constprop.0>:
	pdu->len = BDADDR_SIZE;
}

static void init_set(struct ll_adv_set *adv)
{
	adv->interval = BT_LE_ADV_INTERVAL_DEFAULT;
   389b0:	4b0f      	ldr	r3, [pc, #60]	; (389f0 <init_set.constprop.0+0x40>)
#if defined(CONFIG_BT_CTLR_PRIVACY)
	adv->own_addr_type = BT_ADDR_LE_PUBLIC;
#endif /* CONFIG_BT_CTLR_PRIVACY */
	adv->lll.chan_map = BT_LE_ADV_CHAN_MAP_ALL;
   389b2:	8c9a      	ldrh	r2, [r3, #36]	; 0x24
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
   389b4:	f893 1029 	ldrb.w	r1, [r3, #41]	; 0x29
   389b8:	f422 7243 	bic.w	r2, r2, #780	; 0x30c
   389bc:	eb03 0181 	add.w	r1, r3, r1, lsl #2
   389c0:	f022 0202 	bic.w	r2, r2, #2
   389c4:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
   389c6:	f042 020e 	orr.w	r2, r2, #14
   389ca:	849a      	strh	r2, [r3, #36]	; 0x24
	pdu->len = BDADDR_SIZE;
   389cc:	2006      	movs	r0, #6
	pdu->type = pdu_type;
   389ce:	2200      	movs	r2, #0
	adv->interval = BT_LE_ADV_INTERVAL_DEFAULT;
   389d0:	f44f 6c00 	mov.w	ip, #2048	; 0x800
   389d4:	f8a3 c068 	strh.w	ip, [r3, #104]	; 0x68
	pdu->type = pdu_type;
   389d8:	700a      	strb	r2, [r1, #0]
	pdu->len = BDADDR_SIZE;
   389da:	7048      	strb	r0, [r1, #1]
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
   389dc:	f893 1035 	ldrb.w	r1, [r3, #53]	; 0x35
   389e0:	eb03 0381 	add.w	r3, r3, r1, lsl #2
	pdu->type = pdu_type;
   389e4:	2204      	movs	r2, #4
   389e6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   389e8:	701a      	strb	r2, [r3, #0]
	pdu->len = BDADDR_SIZE;
   389ea:	7058      	strb	r0, [r3, #1]
	adv->delay_remain = ULL_ADV_RANDOM_DELAY;
#endif /* ONFIG_BT_CTLR_JIT_SCHEDULING */

	init_pdu(lll_adv_data_peek(&ll_adv[0].lll), PDU_ADV_TYPE_ADV_IND);
	init_pdu(lll_adv_scan_rsp_peek(&ll_adv[0].lll), PDU_ADV_TYPE_SCAN_RSP);
}
   389ec:	4770      	bx	lr
   389ee:	bf00      	nop
   389f0:	20005174 	.word	0x20005174

000389f4 <conn_release.constprop.0>:
static void conn_release(struct ll_adv_set *adv)
   389f4:	b570      	push	{r4, r5, r6, lr}
	struct lll_conn *lll = adv->lll.conn;
   389f6:	4c1b      	ldr	r4, [pc, #108]	; (38a64 <conn_release.constprop.0+0x70>)
   389f8:	6a25      	ldr	r5, [r4, #32]
	LL_ASSERT(!lll->link_tx_free);
   389fa:	6dab      	ldr	r3, [r5, #88]	; 0x58
   389fc:	b163      	cbz	r3, 38a18 <conn_release.constprop.0+0x24>
   389fe:	4a1a      	ldr	r2, [pc, #104]	; (38a68 <conn_release.constprop.0+0x74>)
   38a00:	491a      	ldr	r1, [pc, #104]	; (38a6c <conn_release.constprop.0+0x78>)
   38a02:	481b      	ldr	r0, [pc, #108]	; (38a70 <conn_release.constprop.0+0x7c>)
   38a04:	f640 1395 	movw	r3, #2453	; 0x995
   38a08:	f010 fb3c 	bl	49084 <assert_print>
   38a0c:	4040      	eors	r0, r0
   38a0e:	f380 8811 	msr	BASEPRI, r0
   38a12:	f04f 0003 	mov.w	r0, #3
   38a16:	df02      	svc	2
	link = memq_deinit(&lll->memq_tx.head, &lll->memq_tx.tail);
   38a18:	f105 014c 	add.w	r1, r5, #76	; 0x4c
   38a1c:	f105 0048 	add.w	r0, r5, #72	; 0x48
   38a20:	f7fb fda6 	bl	34570 <memq_deinit>
	LL_ASSERT(link);
   38a24:	4606      	mov	r6, r0
   38a26:	b170      	cbz	r0, 38a46 <conn_release.constprop.0+0x52>
	ll_conn_release(lll->hdr.parent);
   38a28:	6828      	ldr	r0, [r5, #0]
	lll->link_tx_free = link;
   38a2a:	65ae      	str	r6, [r5, #88]	; 0x58
	adv->lll.conn = NULL;
   38a2c:	2500      	movs	r5, #0
	ll_conn_release(lll->hdr.parent);
   38a2e:	f001 fb47 	bl	3a0c0 <ll_conn_release>
	ll_rx_release(adv->node_rx_cc_free);
   38a32:	6e60      	ldr	r0, [r4, #100]	; 0x64
	adv->lll.conn = NULL;
   38a34:	6225      	str	r5, [r4, #32]
	ll_rx_release(adv->node_rx_cc_free);
   38a36:	f7ff f99f 	bl	37d78 <ll_rx_release>
	ll_rx_link_release(adv->link_cc_free);
   38a3a:	6e20      	ldr	r0, [r4, #96]	; 0x60
	adv->node_rx_cc_free = NULL;
   38a3c:	6665      	str	r5, [r4, #100]	; 0x64
	ll_rx_link_release(adv->link_cc_free);
   38a3e:	f7ff f98f 	bl	37d60 <ll_rx_link_release>
	adv->link_cc_free = NULL;
   38a42:	6625      	str	r5, [r4, #96]	; 0x60
}
   38a44:	bd70      	pop	{r4, r5, r6, pc}
	LL_ASSERT(link);
   38a46:	4a08      	ldr	r2, [pc, #32]	; (38a68 <conn_release.constprop.0+0x74>)
   38a48:	490a      	ldr	r1, [pc, #40]	; (38a74 <conn_release.constprop.0+0x80>)
   38a4a:	4809      	ldr	r0, [pc, #36]	; (38a70 <conn_release.constprop.0+0x7c>)
   38a4c:	f640 1397 	movw	r3, #2455	; 0x997
   38a50:	f010 fb18 	bl	49084 <assert_print>
   38a54:	4040      	eors	r0, r0
   38a56:	f380 8811 	msr	BASEPRI, r0
   38a5a:	f04f 0003 	mov.w	r0, #3
   38a5e:	df02      	svc	2
   38a60:	e7e2      	b.n	38a28 <conn_release.constprop.0+0x34>
   38a62:	bf00      	nop
   38a64:	20005174 	.word	0x20005174
   38a68:	000524b8 	.word	0x000524b8
   38a6c:	00052590 	.word	0x00052590
   38a70:	0005214c 	.word	0x0005214c
   38a74:	000526f4 	.word	0x000526f4

00038a78 <disable.constprop.0>:
static inline uint8_t disable(uint8_t handle)
   38a78:	b530      	push	{r4, r5, lr}
	if (!adv || !adv->is_enabled) {
   38a7a:	4c4f      	ldr	r4, [pc, #316]	; (38bb8 <disable.constprop.0+0x140>)
   38a7c:	f894 306a 	ldrb.w	r3, [r4, #106]	; 0x6a
   38a80:	07d9      	lsls	r1, r3, #31
static inline uint8_t disable(uint8_t handle)
   38a82:	b085      	sub	sp, #20
	if (!adv || !adv->is_enabled) {
   38a84:	d55f      	bpl.n	38b46 <disable.constprop.0+0xce>
	if (adv->lll.conn) {
   38a86:	6a23      	ldr	r3, [r4, #32]
   38a88:	b153      	cbz	r3, 38aa0 <disable.constprop.0+0x28>
		adv->lll.conn->periph.cancelled = 1U;
   38a8a:	f893 2020 	ldrb.w	r2, [r3, #32]
   38a8e:	f042 0202 	orr.w	r2, r2, #2
   38a92:	f883 2020 	strb.w	r2, [r3, #32]
		if (unlikely(adv->lll.conn->periph.initiated)) {
   38a96:	6a23      	ldr	r3, [r4, #32]
   38a98:	f893 3020 	ldrb.w	r3, [r3, #32]
   38a9c:	07da      	lsls	r2, r3, #31
   38a9e:	d467      	bmi.n	38b70 <disable.constprop.0+0xf8>
	mark = ull_disable_mark(adv);
   38aa0:	4845      	ldr	r0, [pc, #276]	; (38bb8 <disable.constprop.0+0x140>)
   38aa2:	f7ff fa37 	bl	37f14 <ull_disable_mark>
	LL_ASSERT(mark == adv);
   38aa6:	4284      	cmp	r4, r0
   38aa8:	d00c      	beq.n	38ac4 <disable.constprop.0+0x4c>
   38aaa:	4a44      	ldr	r2, [pc, #272]	; (38bbc <disable.constprop.0+0x144>)
   38aac:	4944      	ldr	r1, [pc, #272]	; (38bc0 <disable.constprop.0+0x148>)
   38aae:	4845      	ldr	r0, [pc, #276]	; (38bc4 <disable.constprop.0+0x14c>)
   38ab0:	f640 2362 	movw	r3, #2658	; 0xa62
   38ab4:	f010 fae6 	bl	49084 <assert_print>
   38ab8:	4040      	eors	r0, r0
   38aba:	f380 8811 	msr	BASEPRI, r0
   38abe:	f04f 0003 	mov.w	r0, #3
   38ac2:	df02      	svc	2
	if (adv->lll.is_hdcd) {
   38ac4:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
   38ac8:	07db      	lsls	r3, r3, #31
		ret = ticker_stop(TICKER_INSTANCE_ID_CTLR,
   38aca:	ad03      	add	r5, sp, #12
	if (adv->lll.is_hdcd) {
   38acc:	d50d      	bpl.n	38aea <disable.constprop.0+0x72>
		ret_cb = TICKER_STATUS_BUSY;
   38ace:	2102      	movs	r1, #2
   38ad0:	9103      	str	r1, [sp, #12]
		ret = ticker_stop(TICKER_INSTANCE_ID_CTLR,
   38ad2:	4b3d      	ldr	r3, [pc, #244]	; (38bc8 <disable.constprop.0+0x150>)
   38ad4:	9500      	str	r5, [sp, #0]
   38ad6:	2103      	movs	r1, #3
   38ad8:	2201      	movs	r2, #1
   38ada:	2000      	movs	r0, #0
   38adc:	f7fc ffee 	bl	35abc <ticker_stop>
		ret = ull_ticker_status_take(ret, &ret_cb);
   38ae0:	4629      	mov	r1, r5
   38ae2:	f7ff f9ef 	bl	37ec4 <ull_ticker_status_take>
		if (ret) {
   38ae6:	2800      	cmp	r0, #0
   38ae8:	d152      	bne.n	38b90 <disable.constprop.0+0x118>
	ret_cb = TICKER_STATUS_BUSY;
   38aea:	2202      	movs	r2, #2
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_THREAD,
   38aec:	2103      	movs	r1, #3
   38aee:	4b36      	ldr	r3, [pc, #216]	; (38bc8 <disable.constprop.0+0x150>)
   38af0:	9500      	str	r5, [sp, #0]
   38af2:	2000      	movs	r0, #0
	ret_cb = TICKER_STATUS_BUSY;
   38af4:	9203      	str	r2, [sp, #12]
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_THREAD,
   38af6:	f7fc ffe1 	bl	35abc <ticker_stop>
	ret = ull_ticker_status_take(ret, &ret_cb);
   38afa:	4629      	mov	r1, r5
   38afc:	f7ff f9e2 	bl	37ec4 <ull_ticker_status_take>
	if (ret) {
   38b00:	bb20      	cbnz	r0, 38b4c <disable.constprop.0+0xd4>
	err = ull_disable(&adv->lll);
   38b02:	4832      	ldr	r0, [pc, #200]	; (38bcc <disable.constprop.0+0x154>)
   38b04:	f7ff fa42 	bl	37f8c <ull_disable>
	LL_ASSERT(!err || (err == -EALREADY));
   38b08:	b108      	cbz	r0, 38b0e <disable.constprop.0+0x96>
   38b0a:	3078      	adds	r0, #120	; 0x78
   38b0c:	d132      	bne.n	38b74 <disable.constprop.0+0xfc>
	mark = ull_disable_unmark(adv);
   38b0e:	482a      	ldr	r0, [pc, #168]	; (38bb8 <disable.constprop.0+0x140>)
   38b10:	f7ff fa0c 	bl	37f2c <ull_disable_unmark>
	LL_ASSERT(mark == adv);
   38b14:	4284      	cmp	r4, r0
   38b16:	d00c      	beq.n	38b32 <disable.constprop.0+0xba>
   38b18:	4a28      	ldr	r2, [pc, #160]	; (38bbc <disable.constprop.0+0x144>)
   38b1a:	4929      	ldr	r1, [pc, #164]	; (38bc0 <disable.constprop.0+0x148>)
   38b1c:	4829      	ldr	r0, [pc, #164]	; (38bc4 <disable.constprop.0+0x14c>)
   38b1e:	f640 2384 	movw	r3, #2692	; 0xa84
   38b22:	f010 faaf 	bl	49084 <assert_print>
   38b26:	4040      	eors	r0, r0
   38b28:	f380 8811 	msr	BASEPRI, r0
   38b2c:	f04f 0003 	mov.w	r0, #3
   38b30:	df02      	svc	2
	if (adv->lll.conn) {
   38b32:	6a23      	ldr	r3, [r4, #32]
   38b34:	b10b      	cbz	r3, 38b3a <disable.constprop.0+0xc2>
		conn_release(adv);
   38b36:	f7ff ff5d 	bl	389f4 <conn_release.constprop.0>
	adv->is_enabled = 0U;
   38b3a:	f894 306a 	ldrb.w	r3, [r4, #106]	; 0x6a
   38b3e:	f36f 0300 	bfc	r3, #0, #1
   38b42:	f884 306a 	strb.w	r3, [r4, #106]	; 0x6a
			return 0;
   38b46:	2000      	movs	r0, #0
}
   38b48:	b005      	add	sp, #20
   38b4a:	bd30      	pop	{r4, r5, pc}
		mark = ull_disable_unmark(adv);
   38b4c:	481a      	ldr	r0, [pc, #104]	; (38bb8 <disable.constprop.0+0x140>)
   38b4e:	f7ff f9ed 	bl	37f2c <ull_disable_unmark>
		LL_ASSERT(mark == adv);
   38b52:	4284      	cmp	r4, r0
   38b54:	d00c      	beq.n	38b70 <disable.constprop.0+0xf8>
   38b56:	4a19      	ldr	r2, [pc, #100]	; (38bbc <disable.constprop.0+0x144>)
   38b58:	4919      	ldr	r1, [pc, #100]	; (38bc0 <disable.constprop.0+0x148>)
   38b5a:	481a      	ldr	r0, [pc, #104]	; (38bc4 <disable.constprop.0+0x14c>)
   38b5c:	f640 237b 	movw	r3, #2683	; 0xa7b
   38b60:	f010 fa90 	bl	49084 <assert_print>
   38b64:	4040      	eors	r0, r0
   38b66:	f380 8811 	msr	BASEPRI, r0
   38b6a:	f04f 0003 	mov.w	r0, #3
   38b6e:	df02      	svc	2
			return BT_HCI_ERR_CMD_DISALLOWED;
   38b70:	200c      	movs	r0, #12
   38b72:	e7e9      	b.n	38b48 <disable.constprop.0+0xd0>
	LL_ASSERT(!err || (err == -EALREADY));
   38b74:	4a11      	ldr	r2, [pc, #68]	; (38bbc <disable.constprop.0+0x144>)
   38b76:	4916      	ldr	r1, [pc, #88]	; (38bd0 <disable.constprop.0+0x158>)
   38b78:	4812      	ldr	r0, [pc, #72]	; (38bc4 <disable.constprop.0+0x14c>)
   38b7a:	f640 2381 	movw	r3, #2689	; 0xa81
   38b7e:	f010 fa81 	bl	49084 <assert_print>
   38b82:	4040      	eors	r0, r0
   38b84:	f380 8811 	msr	BASEPRI, r0
   38b88:	f04f 0003 	mov.w	r0, #3
   38b8c:	df02      	svc	2
   38b8e:	e7be      	b.n	38b0e <disable.constprop.0+0x96>
			mark = ull_disable_unmark(adv);
   38b90:	4809      	ldr	r0, [pc, #36]	; (38bb8 <disable.constprop.0+0x140>)
   38b92:	f7ff f9cb 	bl	37f2c <ull_disable_unmark>
			LL_ASSERT(mark == adv);
   38b96:	4284      	cmp	r4, r0
   38b98:	d0ea      	beq.n	38b70 <disable.constprop.0+0xf8>
   38b9a:	4a08      	ldr	r2, [pc, #32]	; (38bbc <disable.constprop.0+0x144>)
   38b9c:	4908      	ldr	r1, [pc, #32]	; (38bc0 <disable.constprop.0+0x148>)
   38b9e:	4809      	ldr	r0, [pc, #36]	; (38bc4 <disable.constprop.0+0x14c>)
   38ba0:	f640 236d 	movw	r3, #2669	; 0xa6d
   38ba4:	f010 fa6e 	bl	49084 <assert_print>
   38ba8:	4040      	eors	r0, r0
   38baa:	f380 8811 	msr	BASEPRI, r0
   38bae:	f04f 0003 	mov.w	r0, #3
   38bb2:	df02      	svc	2
   38bb4:	e7dc      	b.n	38b70 <disable.constprop.0+0xf8>
   38bb6:	bf00      	nop
   38bb8:	20005174 	.word	0x20005174
   38bbc:	000524b8 	.word	0x000524b8
   38bc0:	000525a4 	.word	0x000525a4
   38bc4:	0005214c 	.word	0x0005214c
   38bc8:	000374a1 	.word	0x000374a1
   38bcc:	20005190 	.word	0x20005190
   38bd0:	000525b0 	.word	0x000525b0

00038bd4 <adv_time_get.constprop.0.isra.0>:
static uint16_t adv_time_get(struct pdu_adv *pdu, struct pdu_adv *pdu_scan,
   38bd4:	b410      	push	{r4}
		if (pdu->type == PDU_ADV_TYPE_NONCONN_IND) {
   38bd6:	7804      	ldrb	r4, [r0, #0]
   38bd8:	f004 040f 	and.w	r4, r4, #15
				   rxtx_turn_us * (adv_chn_cnt - 1);
   38bdc:	1e53      	subs	r3, r2, #1
		if (pdu->type == PDU_ADV_TYPE_NONCONN_IND) {
   38bde:	2c02      	cmp	r4, #2
			time_us += BYTES2US(adv_size, PHY_1M) * adv_chn_cnt +
   38be0:	b29b      	uxth	r3, r3
		if (pdu->type == PDU_ADV_TYPE_NONCONN_IND) {
   38be2:	d01f      	beq.n	38c24 <adv_time_get.constprop.0.isra.0+0x50>
			if (pdu->type == PDU_ADV_TYPE_DIRECT_IND) {
   38be4:	2c01      	cmp	r4, #1
   38be6:	d009      	beq.n	38bfc <adv_time_get.constprop.0.isra.0+0x28>
			BYTES2US((PDU_OVERHEAD_SIZE(PHY_1M) +
   38be8:	3110      	adds	r1, #16
		const uint16_t scan_rsp_us =
   38bea:	00c9      	lsls	r1, r1, #3
			} else if (pdu->type == PDU_ADV_TYPE_ADV_IND) {
   38bec:	b18c      	cbz	r4, 38c12 <adv_time_get.constprop.0.isra.0+0x3e>
			} else if (pdu->type == PDU_ADV_TYPE_SCAN_IND) {
   38bee:	2c06      	cmp	r4, #6
   38bf0:	d00f      	beq.n	38c12 <adv_time_get.constprop.0.isra.0+0x3e>
   38bf2:	f240 426a 	movw	r2, #1130	; 0x46a
   38bf6:	f44f 70f3 	mov.w	r0, #486	; 0x1e6
   38bfa:	e003      	b.n	38c04 <adv_time_get.constprop.0.isra.0+0x30>
   38bfc:	f240 52fa 	movw	r2, #1530	; 0x5fa
   38c00:	f240 2016 	movw	r0, #534	; 0x216
			time_us += (BYTES2US(adv_size, PHY_1M) +
   38c04:	fb03 2300 	mla	r3, r3, r0, r2
   38c08:	f64f 70fe 	movw	r0, #65534	; 0xfffe
   38c0c:	4018      	ands	r0, r3
}
   38c0e:	bc10      	pop	{r4}
   38c10:	4770      	bx	lr
				adv_size += pdu->len;
   38c12:	7842      	ldrb	r2, [r0, #1]
   38c14:	3210      	adds	r2, #16
			time_us += (BYTES2US(adv_size, PHY_1M) +
   38c16:	00d2      	lsls	r2, r2, #3
   38c18:	f201 5132 	addw	r1, r1, #1330	; 0x532
				    rxtx_turn_us) * (adv_chn_cnt - 1) +
   38c1c:	f502 70b3 	add.w	r0, r2, #358	; 0x166
   38c20:	440a      	add	r2, r1
   38c22:	e7ef      	b.n	38c04 <adv_time_get.constprop.0.isra.0+0x30>
			adv_size += pdu->len;
   38c24:	7841      	ldrb	r1, [r0, #1]
}
   38c26:	bc10      	pop	{r4}
			time_us += BYTES2US(adv_size, PHY_1M) * adv_chn_cnt +
   38c28:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   38c2c:	ebc3 1303 	rsb	r3, r3, r3, lsl #4
   38c30:	0058      	lsls	r0, r3, #1
   38c32:	3110      	adds	r1, #16
   38c34:	f200 3052 	addw	r0, r0, #850	; 0x352
   38c38:	00cb      	lsls	r3, r1, #3
   38c3a:	fb03 0202 	mla	r2, r3, r2, r0
   38c3e:	b290      	uxth	r0, r2
}
   38c40:	4770      	bx	lr
   38c42:	bf00      	nop

00038c44 <ticker_cb>:
{
   38c44:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   38c48:	461d      	mov	r5, r3
   38c4a:	b08a      	sub	sp, #40	; 0x28
	if (IS_ENABLED(CONFIG_BT_TICKER_LOW_LAT) ||
   38c4c:	f64f 73ff 	movw	r3, #65535	; 0xffff
   38c50:	429d      	cmp	r5, r3
{
   38c52:	f89d 8040 	ldrb.w	r8, [sp, #64]	; 0x40
   38c56:	9c11      	ldr	r4, [sp, #68]	; 0x44
	if (IS_ENABLED(CONFIG_BT_TICKER_LOW_LAT) ||
   38c58:	d018      	beq.n	38c8c <ticker_cb+0x48>
	return ++hdr->ref;
   38c5a:	7823      	ldrb	r3, [r4, #0]
   38c5c:	3301      	adds	r3, #1
   38c5e:	b2db      	uxtb	r3, r3
   38c60:	4607      	mov	r7, r0
   38c62:	4616      	mov	r6, r2
   38c64:	7023      	strb	r3, [r4, #0]
		LL_ASSERT(ref);
   38c66:	2b00      	cmp	r3, #0
   38c68:	d063      	beq.n	38d32 <ticker_cb+0xee>
		p.ticks_at_expire = ticks_at_expire;
   38c6a:	4939      	ldr	r1, [pc, #228]	; (38d50 <ticker_cb+0x10c>)
		mfy.param = &p;
   38c6c:	4b39      	ldr	r3, [pc, #228]	; (38d54 <ticker_cb+0x110>)
		p.lazy = lazy;
   38c6e:	810d      	strh	r5, [r1, #8]
	lll = &adv->lll;
   38c70:	f104 001c 	add.w	r0, r4, #28
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
   38c74:	2200      	movs	r2, #0
		p.param = lll;
   38c76:	60c8      	str	r0, [r1, #12]
		p.remainder = remainder;
   38c78:	e9c1 7600 	strd	r7, r6, [r1]
		p.force = force;
   38c7c:	f881 800a 	strb.w	r8, [r1, #10]
		mfy.param = &p;
   38c80:	6099      	str	r1, [r3, #8]
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
   38c82:	2001      	movs	r0, #1
   38c84:	4611      	mov	r1, r2
   38c86:	f7fb fcf3 	bl	34670 <mayfly_enqueue>
		LL_ASSERT(!ret);
   38c8a:	b938      	cbnz	r0, 38c9c <ticker_cb+0x58>
	if (!lll->is_hdcd)
   38c8c:	f894 0024 	ldrb.w	r0, [r4, #36]	; 0x24
   38c90:	f010 0501 	ands.w	r5, r0, #1
   38c94:	d014      	beq.n	38cc0 <ticker_cb+0x7c>
}
   38c96:	b00a      	add	sp, #40	; 0x28
   38c98:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		LL_ASSERT(!ret);
   38c9c:	4a2e      	ldr	r2, [pc, #184]	; (38d58 <ticker_cb+0x114>)
   38c9e:	492f      	ldr	r1, [pc, #188]	; (38d5c <ticker_cb+0x118>)
   38ca0:	482f      	ldr	r0, [pc, #188]	; (38d60 <ticker_cb+0x11c>)
   38ca2:	f640 03de 	movw	r3, #2270	; 0x8de
   38ca6:	f010 f9ed 	bl	49084 <assert_print>
   38caa:	4040      	eors	r0, r0
   38cac:	f380 8811 	msr	BASEPRI, r0
   38cb0:	f04f 0003 	mov.w	r0, #3
   38cb4:	df02      	svc	2
	if (!lll->is_hdcd)
   38cb6:	f894 0024 	ldrb.w	r0, [r4, #36]	; 0x24
   38cba:	f010 0501 	ands.w	r5, r0, #1
   38cbe:	d1ea      	bne.n	38c96 <ticker_cb+0x52>
	lll_rand_isr_get(&random_delay, sizeof(random_delay));
   38cc0:	2104      	movs	r1, #4
   38cc2:	a809      	add	r0, sp, #36	; 0x24
   38cc4:	f006 fca4 	bl	3f610 <lll_rand_isr_get>
	random_delay %= ticks_delay_window;
   38cc8:	9b09      	ldr	r3, [sp, #36]	; 0x24
   38cca:	4a26      	ldr	r2, [pc, #152]	; (38d64 <ticker_cb+0x120>)
	ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
   38ccc:	9406      	str	r4, [sp, #24]
	random_delay %= ticks_delay_window;
   38cce:	fba2 1203 	umull	r1, r2, r2, r3
   38cd2:	1a99      	subs	r1, r3, r2
   38cd4:	eb02 0251 	add.w	r2, r2, r1, lsr #1
   38cd8:	0a12      	lsrs	r2, r2, #8
   38cda:	f240 1147 	movw	r1, #327	; 0x147
   38cde:	fb01 3312 	mls	r3, r1, r2, r3
	return ((uint8_t *)adv - (uint8_t *)ll_adv) / sizeof(*adv);
   38ce2:	4a21      	ldr	r2, [pc, #132]	; (38d68 <ticker_cb+0x124>)
   38ce4:	4921      	ldr	r1, [pc, #132]	; (38d6c <ticker_cb+0x128>)
   38ce6:	1aa2      	subs	r2, r4, r2
   38ce8:	fba1 1202 	umull	r1, r2, r1, r2
   38cec:	0992      	lsrs	r2, r2, #6
	ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
   38cee:	4920      	ldr	r1, [pc, #128]	; (38d70 <ticker_cb+0x12c>)
   38cf0:	3202      	adds	r2, #2
	random_delay += (ticks_delay_window_offset + 1);
   38cf2:	3301      	adds	r3, #1
	ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
   38cf4:	e9cd 5104 	strd	r5, r1, [sp, #16]
   38cf8:	e9cd 5502 	strd	r5, r5, [sp, #8]
   38cfc:	e9cd 5500 	strd	r5, r5, [sp]
   38d00:	b2d2      	uxtb	r2, r2
   38d02:	2101      	movs	r1, #1
   38d04:	4628      	mov	r0, r5
	random_delay += (ticks_delay_window_offset + 1);
   38d06:	9309      	str	r3, [sp, #36]	; 0x24
	ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
   38d08:	f7fc fec0 	bl	35a8c <ticker_update>
	LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
   38d0c:	f030 0302 	bics.w	r3, r0, #2
   38d10:	d0c1      	beq.n	38c96 <ticker_cb+0x52>
   38d12:	4a11      	ldr	r2, [pc, #68]	; (38d58 <ticker_cb+0x114>)
   38d14:	4917      	ldr	r1, [pc, #92]	; (38d74 <ticker_cb+0x130>)
   38d16:	4812      	ldr	r0, [pc, #72]	; (38d60 <ticker_cb+0x11c>)
   38d18:	f240 7373 	movw	r3, #1907	; 0x773
   38d1c:	f010 f9b2 	bl	49084 <assert_print>
   38d20:	4040      	eors	r0, r0
   38d22:	f380 8811 	msr	BASEPRI, r0
   38d26:	f04f 0003 	mov.w	r0, #3
   38d2a:	df02      	svc	2
}
   38d2c:	b00a      	add	sp, #40	; 0x28
   38d2e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		LL_ASSERT(ref);
   38d32:	4a09      	ldr	r2, [pc, #36]	; (38d58 <ticker_cb+0x114>)
   38d34:	4910      	ldr	r1, [pc, #64]	; (38d78 <ticker_cb+0x134>)
   38d36:	480a      	ldr	r0, [pc, #40]	; (38d60 <ticker_cb+0x11c>)
   38d38:	f640 03d1 	movw	r3, #2257	; 0x8d1
   38d3c:	f010 f9a2 	bl	49084 <assert_print>
   38d40:	4040      	eors	r0, r0
   38d42:	f380 8811 	msr	BASEPRI, r0
   38d46:	f04f 0003 	mov.w	r0, #3
   38d4a:	df02      	svc	2
   38d4c:	e78d      	b.n	38c6a <ticker_cb+0x26>
   38d4e:	bf00      	nop
   38d50:	20005148 	.word	0x20005148
   38d54:	20000a4c 	.word	0x20000a4c
   38d58:	000524b8 	.word	0x000524b8
   38d5c:	00052430 	.word	0x00052430
   38d60:	0005214c 	.word	0x0005214c
   38d64:	90d4f121 	.word	0x90d4f121
   38d68:	20005174 	.word	0x20005174
   38d6c:	8d3dcb09 	.word	0x8d3dcb09
   38d70:	00038979 	.word	0x00038979
   38d74:	000525cc 	.word	0x000525cc
   38d78:	000525c8 	.word	0x000525c8

00038d7c <ll_adv_params_set>:
{
   38d7c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	if (!adv || adv->is_enabled) {
   38d80:	4c6c      	ldr	r4, [pc, #432]	; (38f34 <ll_adv_params_set+0x1b8>)
{
   38d82:	461f      	mov	r7, r3
	uint8_t const pdu_adv_type[] = {PDU_ADV_TYPE_ADV_IND,
   38d84:	4b6c      	ldr	r3, [pc, #432]	; (38f38 <ll_adv_params_set+0x1bc>)
	if (!adv || adv->is_enabled) {
   38d86:	f894 606a 	ldrb.w	r6, [r4, #106]	; 0x6a
{
   38d8a:	4686      	mov	lr, r0
   38d8c:	468c      	mov	ip, r1
	uint8_t const pdu_adv_type[] = {PDU_ADV_TYPE_ADV_IND,
   38d8e:	e893 0003 	ldmia.w	r3, {r0, r1}
{
   38d92:	b083      	sub	sp, #12
	if (!adv || adv->is_enabled) {
   38d94:	f016 0601 	ands.w	r6, r6, #1
{
   38d98:	f89d 802c 	ldrb.w	r8, [sp, #44]	; 0x2c
   38d9c:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
	uint8_t const pdu_adv_type[] = {PDU_ADV_TYPE_ADV_IND,
   38da0:	9000      	str	r0, [sp, #0]
   38da2:	f88d 1004 	strb.w	r1, [sp, #4]
	if (!adv || adv->is_enabled) {
   38da6:	f040 809c 	bne.w	38ee2 <ll_adv_params_set+0x166>
	adv->lll.chan_map = chan_map;
   38daa:	8ca1      	ldrh	r1, [r4, #36]	; 0x24
   38dac:	4615      	mov	r5, r2
   38dae:	f008 0207 	and.w	r2, r8, #7
   38db2:	f003 0303 	and.w	r3, r3, #3
   38db6:	0052      	lsls	r2, r2, #1
   38db8:	f421 7143 	bic.w	r1, r1, #780	; 0x30c
   38dbc:	f021 0102 	bic.w	r1, r1, #2
   38dc0:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
   38dc4:	430a      	orrs	r2, r1
   38dc6:	84a2      	strh	r2, [r4, #36]	; 0x24
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
   38dc8:	f894 2029 	ldrb.w	r2, [r4, #41]	; 0x29
   38dcc:	eb04 0282 	add.w	r2, r4, r2, lsl #2
		adv->interval = 0;
   38dd0:	f1bc 0f01 	cmp.w	ip, #1
	pdu->type = pdu_adv_type[adv_type];
   38dd4:	f10c 0308 	add.w	r3, ip, #8
   38dd8:	f8d2 802c 	ldr.w	r8, [r2, #44]	; 0x2c
		adv->interval = 0;
   38ddc:	bf08      	it	eq
   38dde:	f04f 0e00 	moveq.w	lr, #0
	pdu->type = pdu_adv_type[adv_type];
   38de2:	eb0d 0c03 	add.w	ip, sp, r3
   38de6:	f8a4 e068 	strh.w	lr, [r4, #104]	; 0x68
	pdu_type_prev = pdu->type;
   38dea:	f898 2000 	ldrb.w	r2, [r8]
	pdu->type = pdu_adv_type[adv_type];
   38dee:	f81c 3c08 	ldrb.w	r3, [ip, #-8]
   38df2:	f022 001f 	bic.w	r0, r2, #31
	if (IS_ENABLED(CONFIG_BT_CTLR_CHAN_SEL_2) &&
   38df6:	f013 0f0e 	tst.w	r3, #14
	pdu->type = pdu_adv_type[adv_type];
   38dfa:	f003 030f 	and.w	r3, r3, #15
	if (IS_ENABLED(CONFIG_BT_CTLR_CHAN_SEL_2) &&
   38dfe:	bf0c      	ite	eq
   38e00:	2101      	moveq	r1, #1
   38e02:	2100      	movne	r1, #0
   38e04:	4303      	orrs	r3, r0
   38e06:	f361 1345 	bfi	r3, r1, #5, #1
   38e0a:	f888 3000 	strb.w	r3, [r8]
	if (((pdu->type == PDU_ADV_TYPE_DIRECT_IND) ||
   38e0e:	f003 030f 	and.w	r3, r3, #15
   38e12:	2b01      	cmp	r3, #1
	pdu_type_prev = pdu->type;
   38e14:	f002 020f 	and.w	r2, r2, #15
	if (((pdu->type == PDU_ADV_TYPE_DIRECT_IND) ||
   38e18:	d02e      	beq.n	38e78 <ll_adv_params_set+0xfc>
	} else if (pdu->len == 0) {
   38e1a:	f898 3001 	ldrb.w	r3, [r8, #1]
   38e1e:	b9f3      	cbnz	r3, 38e5e <ll_adv_params_set+0xe2>
		pdu->tx_addr = own_addr_type & 0x1;
   38e20:	f898 3000 	ldrb.w	r3, [r8]
   38e24:	f005 0501 	and.w	r5, r5, #1
   38e28:	f365 1386 	bfi	r3, r5, #6, #1
		pdu->rx_addr = 0;
   38e2c:	f36f 13c7 	bfc	r3, #7, #1
   38e30:	f888 3000 	strb.w	r3, [r8]
		pdu->len = BDADDR_SIZE;
   38e34:	2306      	movs	r3, #6
   38e36:	f888 3001 	strb.w	r3, [r8, #1]
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
   38e3a:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
	hdr->parent = parent;
   38e3e:	61e4      	str	r4, [r4, #28]
   38e40:	eb04 0483 	add.w	r4, r4, r3, lsl #2
		pdu->type = PDU_ADV_TYPE_SCAN_RSP;
   38e44:	01ad      	lsls	r5, r5, #6
   38e46:	6ba3      	ldr	r3, [r4, #56]	; 0x38
		if (pdu->len == 0) {
   38e48:	785a      	ldrb	r2, [r3, #1]
		pdu->type = PDU_ADV_TYPE_SCAN_RSP;
   38e4a:	f045 0504 	orr.w	r5, r5, #4
   38e4e:	701d      	strb	r5, [r3, #0]
		if (pdu->len == 0) {
   38e50:	b90a      	cbnz	r2, 38e56 <ll_adv_params_set+0xda>
			pdu->len = BDADDR_SIZE;
   38e52:	2206      	movs	r2, #6
   38e54:	705a      	strb	r2, [r3, #1]
}
   38e56:	4630      	mov	r0, r6
   38e58:	b003      	add	sp, #12
   38e5a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		if (((pdu_type_prev == PDU_ADV_TYPE_DIRECT_IND) ||
   38e5e:	2a01      	cmp	r2, #1
   38e60:	d031      	beq.n	38ec6 <ll_adv_params_set+0x14a>
		pdu->tx_addr = own_addr_type & 0x1;
   38e62:	f898 3000 	ldrb.w	r3, [r8]
   38e66:	f005 0501 	and.w	r5, r5, #1
   38e6a:	f365 1386 	bfi	r3, r5, #6, #1
		pdu->rx_addr = 0;
   38e6e:	f36f 13c7 	bfc	r3, #7, #1
   38e72:	f888 3000 	strb.w	r3, [r8]
   38e76:	e7e0      	b.n	38e3a <ll_adv_params_set+0xbe>
	    (pdu_type_prev != PDU_ADV_TYPE_DIRECT_IND) &&
   38e78:	2a01      	cmp	r2, #1
   38e7a:	d00f      	beq.n	38e9c <ll_adv_params_set+0x120>
		if (pdu->len == 0U) {
   38e7c:	f898 2001 	ldrb.w	r2, [r8, #1]
   38e80:	bba2      	cbnz	r2, 38eec <ll_adv_params_set+0x170>
			adv->ad_data_backup.len = 0U;
   38e82:	f884 6040 	strb.w	r6, [r4, #64]	; 0x40
	if (pdu->type == PDU_ADV_TYPE_DIRECT_IND) {
   38e86:	f898 3000 	ldrb.w	r3, [r8]
   38e8a:	f003 030f 	and.w	r3, r3, #15
   38e8e:	2b01      	cmp	r3, #1
   38e90:	d004      	beq.n	38e9c <ll_adv_params_set+0x120>
	} else if (pdu->len == 0) {
   38e92:	f898 3001 	ldrb.w	r3, [r8, #1]
   38e96:	2b00      	cmp	r3, #0
   38e98:	d0c2      	beq.n	38e20 <ll_adv_params_set+0xa4>
   38e9a:	e7e2      	b.n	38e62 <ll_adv_params_set+0xe6>
			memcpy(adv->ad_data_backup.data, pdu->adv_ind.data,
   38e9c:	f108 0908 	add.w	r9, r8, #8
		pdu->tx_addr = own_addr_type & 0x1;
   38ea0:	f898 3000 	ldrb.w	r3, [r8]
		memcpy(&pdu->direct_ind.tgt_addr[0], direct_addr, BDADDR_SIZE);
   38ea4:	990a      	ldr	r1, [sp, #40]	; 0x28
		pdu->tx_addr = own_addr_type & 0x1;
   38ea6:	f005 0501 	and.w	r5, r5, #1
   38eaa:	f365 1386 	bfi	r3, r5, #6, #1
		pdu->rx_addr = direct_addr_type;
   38eae:	f367 13c7 	bfi	r3, r7, #7, #1
   38eb2:	f888 3000 	strb.w	r3, [r8]
		memcpy(&pdu->direct_ind.tgt_addr[0], direct_addr, BDADDR_SIZE);
   38eb6:	4648      	mov	r0, r9
   38eb8:	2206      	movs	r2, #6
   38eba:	f011 ffde 	bl	4ae7a <memcpy>
		pdu->len = sizeof(struct pdu_adv_direct_ind);
   38ebe:	230c      	movs	r3, #12
   38ec0:	f888 3001 	strb.w	r3, [r8, #1]
   38ec4:	e7b9      	b.n	38e3a <ll_adv_params_set+0xbe>
			memcpy(pdu->adv_ind.data, adv->ad_data_backup.data,
   38ec6:	f894 2040 	ldrb.w	r2, [r4, #64]	; 0x40
   38eca:	f104 0141 	add.w	r1, r4, #65	; 0x41
   38ece:	f108 0008 	add.w	r0, r8, #8
   38ed2:	f011 ffd2 	bl	4ae7a <memcpy>
			pdu->len = offsetof(struct pdu_adv_adv_ind, data) +
   38ed6:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
   38eda:	3306      	adds	r3, #6
   38edc:	f888 3001 	strb.w	r3, [r8, #1]
   38ee0:	e7bf      	b.n	38e62 <ll_adv_params_set+0xe6>
		return BT_HCI_ERR_CMD_DISALLOWED;
   38ee2:	260c      	movs	r6, #12
}
   38ee4:	4630      	mov	r0, r6
   38ee6:	b003      	add	sp, #12
   38ee8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			LL_ASSERT(pdu->len >=
   38eec:	2a05      	cmp	r2, #5
   38eee:	d910      	bls.n	38f12 <ll_adv_params_set+0x196>
			adv->ad_data_backup.len = pdu->len -
   38ef0:	3a06      	subs	r2, #6
   38ef2:	b2d2      	uxtb	r2, r2
			memcpy(adv->ad_data_backup.data, pdu->adv_ind.data,
   38ef4:	f108 0908 	add.w	r9, r8, #8
   38ef8:	4810      	ldr	r0, [pc, #64]	; (38f3c <ll_adv_params_set+0x1c0>)
			adv->ad_data_backup.len = pdu->len -
   38efa:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
			memcpy(adv->ad_data_backup.data, pdu->adv_ind.data,
   38efe:	4649      	mov	r1, r9
   38f00:	f011 ffbb 	bl	4ae7a <memcpy>
	if (pdu->type == PDU_ADV_TYPE_DIRECT_IND) {
   38f04:	f898 3000 	ldrb.w	r3, [r8]
   38f08:	f003 030f 	and.w	r3, r3, #15
   38f0c:	2b01      	cmp	r3, #1
   38f0e:	d1c0      	bne.n	38e92 <ll_adv_params_set+0x116>
   38f10:	e7c6      	b.n	38ea0 <ll_adv_params_set+0x124>
			LL_ASSERT(pdu->len >=
   38f12:	4a0b      	ldr	r2, [pc, #44]	; (38f40 <ll_adv_params_set+0x1c4>)
   38f14:	490b      	ldr	r1, [pc, #44]	; (38f44 <ll_adv_params_set+0x1c8>)
   38f16:	480c      	ldr	r0, [pc, #48]	; (38f48 <ll_adv_params_set+0x1cc>)
   38f18:	f44f 73d9 	mov.w	r3, #434	; 0x1b2
   38f1c:	f010 f8b2 	bl	49084 <assert_print>
   38f20:	4040      	eors	r0, r0
   38f22:	f380 8811 	msr	BASEPRI, r0
   38f26:	f04f 0003 	mov.w	r0, #3
   38f2a:	df02      	svc	2
			adv->ad_data_backup.len = pdu->len -
   38f2c:	f898 2001 	ldrb.w	r2, [r8, #1]
   38f30:	e7de      	b.n	38ef0 <ll_adv_params_set+0x174>
   38f32:	bf00      	nop
   38f34:	20005174 	.word	0x20005174
   38f38:	00050dd8 	.word	0x00050dd8
   38f3c:	200051b5 	.word	0x200051b5
   38f40:	000524b8 	.word	0x000524b8
   38f44:	00052604 	.word	0x00052604
   38f48:	0005214c 	.word	0x0005214c

00038f4c <ull_adv_init>:
{
   38f4c:	b510      	push	{r4, lr}
		lll_adv_data_init(&ll_adv[handle].lll.adv_data);
   38f4e:	4c06      	ldr	r4, [pc, #24]	; (38f68 <ull_adv_init+0x1c>)
   38f50:	4620      	mov	r0, r4
   38f52:	f006 ffa3 	bl	3fe9c <lll_adv_data_init>
		lll_adv_data_init(&ll_adv[handle].lll.scan_rsp);
   38f56:	f104 000c 	add.w	r0, r4, #12
   38f5a:	f006 ff9f 	bl	3fe9c <lll_adv_data_init>
	init_set(&ll_adv[0]);
   38f5e:	f7ff fd27 	bl	389b0 <init_set.constprop.0>
}
   38f62:	2000      	movs	r0, #0
   38f64:	bd10      	pop	{r4, pc}
   38f66:	bf00      	nop
   38f68:	2000519c 	.word	0x2000519c

00038f6c <ull_adv_reset>:
{
   38f6c:	b508      	push	{r3, lr}
		(void)disable(handle);
   38f6e:	f7ff fd83 	bl	38a78 <disable.constprop.0>
}
   38f72:	2000      	movs	r0, #0
   38f74:	bd08      	pop	{r3, pc}
   38f76:	bf00      	nop

00038f78 <ull_adv_reset_finalize>:
{
   38f78:	b538      	push	{r3, r4, r5, lr}
		lll_adv_data_reset(&lll->adv_data);
   38f7a:	4c09      	ldr	r4, [pc, #36]	; (38fa0 <ull_adv_reset_finalize+0x28>)
		lll_adv_data_reset(&lll->scan_rsp);
   38f7c:	f104 050c 	add.w	r5, r4, #12
		lll_adv_data_reset(&lll->adv_data);
   38f80:	4620      	mov	r0, r4
   38f82:	f006 ff9b 	bl	3febc <lll_adv_data_reset>
		lll_adv_data_reset(&lll->scan_rsp);
   38f86:	4628      	mov	r0, r5
   38f88:	f006 ff98 	bl	3febc <lll_adv_data_reset>
		lll_adv_data_init(&ll_adv[handle].lll.adv_data);
   38f8c:	4620      	mov	r0, r4
   38f8e:	f006 ff85 	bl	3fe9c <lll_adv_data_init>
		lll_adv_data_init(&ll_adv[handle].lll.scan_rsp);
   38f92:	4628      	mov	r0, r5
   38f94:	f006 ff82 	bl	3fe9c <lll_adv_data_init>
	init_set(&ll_adv[0]);
   38f98:	f7ff fd0a 	bl	389b0 <init_set.constprop.0>
}
   38f9c:	2000      	movs	r0, #0
   38f9e:	bd38      	pop	{r3, r4, r5, pc}
   38fa0:	2000519c 	.word	0x2000519c

00038fa4 <ull_adv_handle_get>:
	return ((uint8_t *)adv - (uint8_t *)ll_adv) / sizeof(*adv);
   38fa4:	4a03      	ldr	r2, [pc, #12]	; (38fb4 <ull_adv_handle_get+0x10>)
   38fa6:	4b04      	ldr	r3, [pc, #16]	; (38fb8 <ull_adv_handle_get+0x14>)
   38fa8:	1a80      	subs	r0, r0, r2
   38faa:	fba3 3000 	umull	r3, r0, r3, r0
}
   38fae:	f3c0 108f 	ubfx	r0, r0, #6, #16
   38fb2:	4770      	bx	lr
   38fb4:	20005174 	.word	0x20005174
   38fb8:	8d3dcb09 	.word	0x8d3dcb09

00038fbc <ull_adv_lll_handle_get>:
	return ((uint8_t *)adv - (uint8_t *)ll_adv) / sizeof(*adv);
   38fbc:	4a04      	ldr	r2, [pc, #16]	; (38fd0 <ull_adv_lll_handle_get+0x14>)
   38fbe:	6800      	ldr	r0, [r0, #0]
   38fc0:	4b04      	ldr	r3, [pc, #16]	; (38fd4 <ull_adv_lll_handle_get+0x18>)
   38fc2:	1a80      	subs	r0, r0, r2
   38fc4:	fba3 3000 	umull	r3, r0, r3, r0
}
   38fc8:	f3c0 108f 	ubfx	r0, r0, #6, #16
   38fcc:	4770      	bx	lr
   38fce:	bf00      	nop
   38fd0:	20005174 	.word	0x20005174
   38fd4:	8d3dcb09 	.word	0x8d3dcb09

00038fd8 <ull_adv_is_enabled>:
	if (handle >= BT_CTLR_ADV_SET) {
   38fd8:	b928      	cbnz	r0, 38fe6 <ull_adv_is_enabled+0xe>
	if (!adv || !adv->is_enabled) {
   38fda:	4b04      	ldr	r3, [pc, #16]	; (38fec <ull_adv_is_enabled+0x14>)
   38fdc:	f893 006a 	ldrb.w	r0, [r3, #106]	; 0x6a
   38fe0:	f000 0001 	and.w	r0, r0, #1
   38fe4:	4770      	bx	lr
   38fe6:	2000      	movs	r0, #0
}
   38fe8:	4770      	bx	lr
   38fea:	bf00      	nop
   38fec:	20005174 	.word	0x20005174

00038ff0 <ull_adv_data_set>:
	if (len > PDU_AC_LEG_DATA_SIZE_MAX) {
   38ff0:	291f      	cmp	r1, #31
   38ff2:	d857      	bhi.n	390a4 <ull_adv_data_set+0xb4>
{
   38ff4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
   38ff8:	f890 3029 	ldrb.w	r3, [r0, #41]	; 0x29
   38ffc:	eb00 0383 	add.w	r3, r0, r3, lsl #2
   39000:	b082      	sub	sp, #8
   39002:	6adf      	ldr	r7, [r3, #44]	; 0x2c
	if ((prev->type == PDU_ADV_TYPE_DIRECT_IND) ||
   39004:	783b      	ldrb	r3, [r7, #0]
   39006:	f003 030f 	and.w	r3, r3, #15
   3900a:	2b01      	cmp	r3, #1
   3900c:	460e      	mov	r6, r1
   3900e:	4605      	mov	r5, r0
   39010:	4690      	mov	r8, r2
   39012:	d049      	beq.n	390a8 <ull_adv_data_set+0xb8>
	return lll_adv_pdu_alloc(&lll->adv_data, idx);
   39014:	f10d 0107 	add.w	r1, sp, #7
   39018:	3028      	adds	r0, #40	; 0x28
   3901a:	f006 ffc1 	bl	3ffa0 <lll_adv_pdu_alloc>
	pdu->type = prev->type;
   3901e:	783a      	ldrb	r2, [r7, #0]
   39020:	7803      	ldrb	r3, [r0, #0]
   39022:	f002 020f 	and.w	r2, r2, #15
   39026:	f023 031f 	bic.w	r3, r3, #31
   3902a:	4313      	orrs	r3, r2
   3902c:	7003      	strb	r3, [r0, #0]
		pdu->chan_sel = prev->chan_sel;
   3902e:	783b      	ldrb	r3, [r7, #0]
   39030:	7802      	ldrb	r2, [r0, #0]
   39032:	f3c3 1340 	ubfx	r3, r3, #5, #1
   39036:	f363 1245 	bfi	r2, r3, #5, #1
   3903a:	7002      	strb	r2, [r0, #0]
	pdu->tx_addr = prev->tx_addr;
   3903c:	783b      	ldrb	r3, [r7, #0]
   3903e:	b2d2      	uxtb	r2, r2
   39040:	f3c3 1380 	ubfx	r3, r3, #6, #1
	pdu->rx_addr = prev->rx_addr;
   39044:	4639      	mov	r1, r7
	pdu->tx_addr = prev->tx_addr;
   39046:	f363 1286 	bfi	r2, r3, #6, #1
   3904a:	7002      	strb	r2, [r0, #0]
	pdu->rx_addr = prev->rx_addr;
   3904c:	f811 3b02 	ldrb.w	r3, [r1], #2
   39050:	b2d2      	uxtb	r2, r2
   39052:	09db      	lsrs	r3, r3, #7
   39054:	f363 12c7 	bfi	r2, r3, #7, #1
   39058:	4604      	mov	r4, r0
   3905a:	f800 2b02 	strb.w	r2, [r0], #2
	memcpy(&pdu->adv_ind.addr[0], &prev->adv_ind.addr[0], BDADDR_SIZE);
   3905e:	2206      	movs	r2, #6
   39060:	f011 ff0b 	bl	4ae7a <memcpy>
	memcpy(&pdu->adv_ind.data[0], data, len);
   39064:	4632      	mov	r2, r6
   39066:	4641      	mov	r1, r8
   39068:	f104 0008 	add.w	r0, r4, #8
	pdu->len = BDADDR_SIZE + len;
   3906c:	3606      	adds	r6, #6
	memcpy(&pdu->adv_ind.data[0], data, len);
   3906e:	f011 ff04 	bl	4ae7a <memcpy>
	pdu->len = BDADDR_SIZE + len;
   39072:	7066      	strb	r6, [r4, #1]
	if (adv->is_enabled) {
   39074:	f895 306a 	ldrb.w	r3, [r5, #106]	; 0x6a
   39078:	07db      	lsls	r3, r3, #31
   3907a:	d407      	bmi.n	3908c <ull_adv_data_set+0x9c>
	pdu->last = idx;
   3907c:	f89d 3007 	ldrb.w	r3, [sp, #7]
   39080:	f885 3029 	strb.w	r3, [r5, #41]	; 0x29
		return 0;
   39084:	2000      	movs	r0, #0
}
   39086:	b002      	add	sp, #8
   39088:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
   3908c:	f895 3035 	ldrb.w	r3, [r5, #53]	; 0x35
   39090:	eb05 0383 	add.w	r3, r5, r3, lsl #2
		err = ull_adv_time_update(adv, pdu, pdu_scan);
   39094:	4621      	mov	r1, r4
   39096:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   39098:	4628      	mov	r0, r5
   3909a:	f7ed fe19 	bl	26cd0 <ull_adv_time_update>
		if (err) {
   3909e:	2800      	cmp	r0, #0
   390a0:	d0ec      	beq.n	3907c <ull_adv_data_set+0x8c>
   390a2:	e7f0      	b.n	39086 <ull_adv_data_set+0x96>
		return BT_HCI_ERR_INVALID_PARAM;
   390a4:	2012      	movs	r0, #18
}
   390a6:	4770      	bx	lr
		adv->ad_data_backup.len = len;
   390a8:	f880 1040 	strb.w	r1, [r0, #64]	; 0x40
		memcpy(adv->ad_data_backup.data, data, adv->ad_data_backup.len);
   390ac:	460a      	mov	r2, r1
   390ae:	3041      	adds	r0, #65	; 0x41
   390b0:	4641      	mov	r1, r8
   390b2:	f011 fee2 	bl	4ae7a <memcpy>
		return 0;
   390b6:	e7e5      	b.n	39084 <ull_adv_data_set+0x94>

000390b8 <ll_adv_data_set>:
{
   390b8:	4603      	mov	r3, r0
   390ba:	460a      	mov	r2, r1
	return ull_adv_data_set(adv, len, data);
   390bc:	4801      	ldr	r0, [pc, #4]	; (390c4 <ll_adv_data_set+0xc>)
   390be:	4619      	mov	r1, r3
   390c0:	f7ff bf96 	b.w	38ff0 <ull_adv_data_set>
   390c4:	20005174 	.word	0x20005174

000390c8 <ull_scan_rsp_set.part.0>:
uint8_t ull_scan_rsp_set(struct ll_adv_set *adv, uint8_t len,
   390c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   390cc:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
   390d0:	b082      	sub	sp, #8
   390d2:	eb00 0383 	add.w	r3, r0, r3, lsl #2
   390d6:	460e      	mov	r6, r1
   390d8:	4605      	mov	r5, r0
	return lll_adv_pdu_alloc(&lll->scan_rsp, idx);
   390da:	f10d 0107 	add.w	r1, sp, #7
   390de:	3034      	adds	r0, #52	; 0x34
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
   390e0:	f8d3 8038 	ldr.w	r8, [r3, #56]	; 0x38
   390e4:	4617      	mov	r7, r2
	return lll_adv_pdu_alloc(&lll->scan_rsp, idx);
   390e6:	f006 ff5b 	bl	3ffa0 <lll_adv_pdu_alloc>
	pdu->type = PDU_ADV_TYPE_SCAN_RSP;
   390ea:	7803      	ldrb	r3, [r0, #0]
   390ec:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
	pdu->tx_addr = prev->tx_addr;
   390f0:	4641      	mov	r1, r8
	pdu->type = PDU_ADV_TYPE_SCAN_RSP;
   390f2:	f043 0304 	orr.w	r3, r3, #4
   390f6:	7003      	strb	r3, [r0, #0]
	pdu->tx_addr = prev->tx_addr;
   390f8:	f811 2b02 	ldrb.w	r2, [r1], #2
   390fc:	b2db      	uxtb	r3, r3
   390fe:	f3c2 1280 	ubfx	r2, r2, #6, #1
   39102:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   39106:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
   3910a:	7003      	strb	r3, [r0, #0]
	pdu->len = BDADDR_SIZE + len;
   3910c:	1db3      	adds	r3, r6, #6
   3910e:	7043      	strb	r3, [r0, #1]
   39110:	4604      	mov	r4, r0
	memcpy(&pdu->scan_rsp.addr[0], &prev->scan_rsp.addr[0], BDADDR_SIZE);
   39112:	2206      	movs	r2, #6
   39114:	3002      	adds	r0, #2
   39116:	f011 feb0 	bl	4ae7a <memcpy>
	memcpy(&pdu->scan_rsp.data[0], data, len);
   3911a:	4632      	mov	r2, r6
   3911c:	4639      	mov	r1, r7
   3911e:	f104 0008 	add.w	r0, r4, #8
   39122:	f011 feaa 	bl	4ae7a <memcpy>
	if (adv->is_enabled) {
   39126:	f895 306a 	ldrb.w	r3, [r5, #106]	; 0x6a
   3912a:	07da      	lsls	r2, r3, #31
   3912c:	d50b      	bpl.n	39146 <ull_scan_rsp_set.part.0+0x7e>
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
   3912e:	f895 2029 	ldrb.w	r2, [r5, #41]	; 0x29
   39132:	eb05 0282 	add.w	r2, r5, r2, lsl #2
		if ((pdu_adv_scan->type == PDU_ADV_TYPE_ADV_IND) ||
   39136:	2341      	movs	r3, #65	; 0x41
   39138:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
   3913a:	780a      	ldrb	r2, [r1, #0]
   3913c:	f002 020f 	and.w	r2, r2, #15
   39140:	40d3      	lsrs	r3, r2
   39142:	07db      	lsls	r3, r3, #31
   39144:	d407      	bmi.n	39156 <ull_scan_rsp_set.part.0+0x8e>
	pdu->last = idx;
   39146:	f89d 3007 	ldrb.w	r3, [sp, #7]
   3914a:	f885 3035 	strb.w	r3, [r5, #53]	; 0x35
	return 0;
   3914e:	2000      	movs	r0, #0
}
   39150:	b002      	add	sp, #8
   39152:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			err = ull_adv_time_update(adv, pdu_adv_scan, pdu);
   39156:	4622      	mov	r2, r4
   39158:	4628      	mov	r0, r5
   3915a:	f7ed fdb9 	bl	26cd0 <ull_adv_time_update>
			if (err) {
   3915e:	2800      	cmp	r0, #0
   39160:	d0f1      	beq.n	39146 <ull_scan_rsp_set.part.0+0x7e>
   39162:	e7f5      	b.n	39150 <ull_scan_rsp_set.part.0+0x88>

00039164 <ll_adv_scan_rsp_set>:
	if (len > PDU_AC_LEG_DATA_SIZE_MAX) {
   39164:	281f      	cmp	r0, #31
{
   39166:	4603      	mov	r3, r0
   39168:	460a      	mov	r2, r1
	if (len > PDU_AC_LEG_DATA_SIZE_MAX) {
   3916a:	d803      	bhi.n	39174 <ll_adv_scan_rsp_set+0x10>
   3916c:	4802      	ldr	r0, [pc, #8]	; (39178 <ll_adv_scan_rsp_set+0x14>)
   3916e:	4619      	mov	r1, r3
   39170:	f7ff bfaa 	b.w	390c8 <ull_scan_rsp_set.part.0>
}
   39174:	2012      	movs	r0, #18
   39176:	4770      	bx	lr
   39178:	20005174 	.word	0x20005174

0003917c <ticker_cb>:
}

static void ticker_cb(uint32_t ticks_at_expire, uint32_t ticks_drift,
		      uint32_t remainder, uint16_t lazy, uint8_t force,
		      void *param)
{
   3917c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   39180:	9c09      	ldr	r4, [sp, #36]	; 0x24
   39182:	f89d 9020 	ldrb.w	r9, [sp, #32]
	uint8_t ref;

	DEBUG_RADIO_PREPARE_O(1);

	scan = param;
	lll = &scan->lll;
   39186:	4625      	mov	r5, r4
{
   39188:	4680      	mov	r8, r0
   3918a:	f815 1b1c 	ldrb.w	r1, [r5], #28
   3918e:	3101      	adds	r1, #1
   39190:	b2c9      	uxtb	r1, r1
   39192:	4617      	mov	r7, r2
   39194:	461e      	mov	r6, r3
   39196:	7021      	strb	r1, [r4, #0]

	/* Increment prepare reference count */
	ref = ull_ref_inc(&scan->ull);
	LL_ASSERT(ref);
   39198:	b181      	cbz	r1, 391bc <ticker_cb+0x40>

	/* Append timing parameters */
	p.ticks_at_expire = ticks_at_expire;
   3919a:	4c17      	ldr	r4, [pc, #92]	; (391f8 <ticker_cb+0x7c>)
	p.remainder = remainder;
	p.lazy = lazy;
	p.param = lll;
	p.force = force;
	mfy.param = &p;
   3919c:	4b17      	ldr	r3, [pc, #92]	; (391fc <ticker_cb+0x80>)
	p.lazy = lazy;
   3919e:	8126      	strh	r6, [r4, #8]

	/* Kick LLL prepare */
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
   391a0:	2200      	movs	r2, #0
   391a2:	4611      	mov	r1, r2
   391a4:	2001      	movs	r0, #1
	p.remainder = remainder;
   391a6:	e9c4 8700 	strd	r8, r7, [r4]
	p.param = lll;
   391aa:	60e5      	str	r5, [r4, #12]
	p.force = force;
   391ac:	f884 900a 	strb.w	r9, [r4, #10]
	mfy.param = &p;
   391b0:	609c      	str	r4, [r3, #8]
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
   391b2:	f7fb fa5d 	bl	34670 <mayfly_enqueue>
			     0, &mfy);
	LL_ASSERT(!ret);
   391b6:	b978      	cbnz	r0, 391d8 <ticker_cb+0x5c>
			  (ret == TICKER_STATUS_BUSY));
	}
#endif /* CONFIG_BT_CTLR_ADV_EXT */

	DEBUG_RADIO_PREPARE_O(1);
}
   391b8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	LL_ASSERT(ref);
   391bc:	4a10      	ldr	r2, [pc, #64]	; (39200 <ticker_cb+0x84>)
   391be:	4911      	ldr	r1, [pc, #68]	; (39204 <ticker_cb+0x88>)
   391c0:	4811      	ldr	r0, [pc, #68]	; (39208 <ticker_cb+0x8c>)
   391c2:	f240 3373 	movw	r3, #883	; 0x373
   391c6:	f00f ff5d 	bl	49084 <assert_print>
   391ca:	4040      	eors	r0, r0
   391cc:	f380 8811 	msr	BASEPRI, r0
   391d0:	f04f 0003 	mov.w	r0, #3
   391d4:	df02      	svc	2
   391d6:	e7e0      	b.n	3919a <ticker_cb+0x1e>
	LL_ASSERT(!ret);
   391d8:	4a09      	ldr	r2, [pc, #36]	; (39200 <ticker_cb+0x84>)
   391da:	490c      	ldr	r1, [pc, #48]	; (3920c <ticker_cb+0x90>)
   391dc:	480a      	ldr	r0, [pc, #40]	; (39208 <ticker_cb+0x8c>)
   391de:	f44f 7360 	mov.w	r3, #896	; 0x380
   391e2:	f00f ff4f 	bl	49084 <assert_print>
   391e6:	4040      	eors	r0, r0
   391e8:	f380 8811 	msr	BASEPRI, r0
   391ec:	f04f 0003 	mov.w	r0, #3
   391f0:	df02      	svc	2
}
   391f2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   391f6:	bf00      	nop
   391f8:	200051f0 	.word	0x200051f0
   391fc:	20000a7c 	.word	0x20000a7c
   39200:	00052644 	.word	0x00052644
   39204:	000525c8 	.word	0x000525c8
   39208:	0005214c 	.word	0x0005214c
   3920c:	00052430 	.word	0x00052430

00039210 <ull_scan_init>:
}
   39210:	2000      	movs	r0, #0
   39212:	4770      	bx	lr

00039214 <ull_scan_disable>:
	err = ull_ticker_stop_with_mark(TICKER_ID_SCAN_BASE + handle,
   39214:	3004      	adds	r0, #4
{
   39216:	b508      	push	{r3, lr}
	err = ull_ticker_stop_with_mark(TICKER_ID_SCAN_BASE + handle,
   39218:	f101 021c 	add.w	r2, r1, #28
   3921c:	b2c0      	uxtb	r0, r0
   3921e:	f7fe fef3 	bl	38008 <ull_ticker_stop_with_mark>
	LL_ASSERT(err == 0 || err == -EALREADY);
   39222:	b900      	cbnz	r0, 39226 <ull_scan_disable+0x12>
}
   39224:	bd08      	pop	{r3, pc}
	LL_ASSERT(err == 0 || err == -EALREADY);
   39226:	3078      	adds	r0, #120	; 0x78
   39228:	d101      	bne.n	3922e <ull_scan_disable+0x1a>
		return BT_HCI_ERR_CMD_DISALLOWED;
   3922a:	200c      	movs	r0, #12
}
   3922c:	bd08      	pop	{r3, pc}
	LL_ASSERT(err == 0 || err == -EALREADY);
   3922e:	4a07      	ldr	r2, [pc, #28]	; (3924c <ull_scan_disable+0x38>)
   39230:	4907      	ldr	r1, [pc, #28]	; (39250 <ull_scan_disable+0x3c>)
   39232:	4808      	ldr	r0, [pc, #32]	; (39254 <ull_scan_disable+0x40>)
   39234:	f240 236d 	movw	r3, #621	; 0x26d
   39238:	f00f ff24 	bl	49084 <assert_print>
   3923c:	4040      	eors	r0, r0
   3923e:	f380 8811 	msr	BASEPRI, r0
   39242:	f04f 0003 	mov.w	r0, #3
   39246:	df02      	svc	2
		return BT_HCI_ERR_CMD_DISALLOWED;
   39248:	200c      	movs	r0, #12
   3924a:	e7ef      	b.n	3922c <ull_scan_disable+0x18>
   3924c:	00052644 	.word	0x00052644
   39250:	00052684 	.word	0x00052684
   39254:	0005214c 	.word	0x0005214c

00039258 <ll_scan_enable>:
{
   39258:	b510      	push	{r4, lr}
	if (!scan || !scan->is_enabled) {
   3925a:	4c14      	ldr	r4, [pc, #80]	; (392ac <ll_scan_enable+0x54>)
   3925c:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
   39260:	f003 0201 	and.w	r2, r3, #1
	if (!enable) {
   39264:	b170      	cbz	r0, 39284 <ll_scan_enable+0x2c>
	if (!scan || scan->is_enabled) {
   39266:	b972      	cbnz	r2, 39286 <ll_scan_enable+0x2e>
	    (!is_coded_phy && (scan->own_addr_type & 0x1))) {
   39268:	079b      	lsls	r3, r3, #30
   3926a:	d506      	bpl.n	3927a <ll_scan_enable+0x22>
		if (!mem_nz(ll_addr_get(BT_ADDR_LE_RANDOM), BDADDR_SIZE)) {
   3926c:	2001      	movs	r0, #1
   3926e:	f7fc fcf5 	bl	35c5c <ll_addr_get>
   39272:	2106      	movs	r1, #6
   39274:	f7fb f96c 	bl	34550 <mem_nz>
   39278:	b1b0      	cbz	r0, 392a8 <ll_scan_enable+0x50>
}
   3927a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		err = ull_scan_enable(scan);
   3927e:	480b      	ldr	r0, [pc, #44]	; (392ac <ll_scan_enable+0x54>)
   39280:	f7ed bde2 	b.w	26e48 <ull_scan_enable>
	if (!scan || !scan->is_enabled) {
   39284:	b90a      	cbnz	r2, 3928a <ll_scan_enable+0x32>
	struct ll_scan_set *scan;
	uint8_t ret;

	scan = ull_scan_is_enabled_get(handle);
	if (!scan) {
		return BT_HCI_ERR_CMD_DISALLOWED;
   39286:	200c      	movs	r0, #12
}
   39288:	bd10      	pop	{r4, pc}
	}

#if defined(CONFIG_BT_CENTRAL)
	if (scan->lll.conn) {
   3928a:	6a23      	ldr	r3, [r4, #32]
   3928c:	2b00      	cmp	r3, #0
   3928e:	d1fa      	bne.n	39286 <ll_scan_enable+0x2e>
		return BT_HCI_ERR_CMD_DISALLOWED;
	}
#endif

	ret = ull_scan_disable(handle, scan);
   39290:	4621      	mov	r1, r4
   39292:	f7ff ffbf 	bl	39214 <ull_scan_disable>
	if (ret) {
   39296:	2800      	cmp	r0, #0
   39298:	d1f6      	bne.n	39288 <ll_scan_enable+0x30>
		return ret;
	}

	scan->is_enabled = 0U;
   3929a:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
   3929e:	f360 0300 	bfi	r3, r0, #0, #1
   392a2:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
}
   392a6:	bd10      	pop	{r4, pc}
			return BT_HCI_ERR_INVALID_PARAM;
   392a8:	2012      	movs	r0, #18
}
   392aa:	bd10      	pop	{r4, pc}
   392ac:	20005200 	.word	0x20005200

000392b0 <ull_scan_reset>:
{
   392b0:	b538      	push	{r3, r4, r5, lr}
	if (!scan || !scan->is_enabled) {
   392b2:	4d0c      	ldr	r5, [pc, #48]	; (392e4 <ull_scan_reset+0x34>)
	for (handle = 0U; handle < BT_CTLR_SCAN_SET; handle++) {
   392b4:	2400      	movs	r4, #0
   392b6:	b93c      	cbnz	r4, 392c8 <ull_scan_reset+0x18>
	if (!scan || !scan->is_enabled) {
   392b8:	f895 4040 	ldrb.w	r4, [r5, #64]	; 0x40
   392bc:	f014 0401 	ands.w	r4, r4, #1
   392c0:	d002      	beq.n	392c8 <ull_scan_reset+0x18>
	if (scan->lll.conn) {
   392c2:	6a28      	ldr	r0, [r5, #32]
	ret = ull_scan_disable(handle, scan);
   392c4:	4907      	ldr	r1, [pc, #28]	; (392e4 <ull_scan_reset+0x34>)
	if (scan->lll.conn) {
   392c6:	b108      	cbz	r0, 392cc <ull_scan_reset+0x1c>
}
   392c8:	2000      	movs	r0, #0
   392ca:	bd38      	pop	{r3, r4, r5, pc}
	ret = ull_scan_disable(handle, scan);
   392cc:	f7ff ffa2 	bl	39214 <ull_scan_disable>
	if (ret) {
   392d0:	2800      	cmp	r0, #0
   392d2:	d1f0      	bne.n	392b6 <ull_scan_reset+0x6>
	scan->is_enabled = 0U;
   392d4:	f895 3040 	ldrb.w	r3, [r5, #64]	; 0x40
   392d8:	f360 0300 	bfi	r3, r0, #0, #1
   392dc:	f885 3040 	strb.w	r3, [r5, #64]	; 0x40
	{
		ull_filter_adv_scan_state_cb(0);
	}
#endif

	return 0;
   392e0:	e7e9      	b.n	392b6 <ull_scan_reset+0x6>
   392e2:	bf00      	nop
   392e4:	20005200 	.word	0x20005200

000392e8 <ull_scan_handle_get>:
	return ((uint8_t *)scan - (uint8_t *)ll_scan) / sizeof(*scan);
   392e8:	4a03      	ldr	r2, [pc, #12]	; (392f8 <ull_scan_handle_get+0x10>)
   392ea:	4b04      	ldr	r3, [pc, #16]	; (392fc <ull_scan_handle_get+0x14>)
   392ec:	1a80      	subs	r0, r0, r2
   392ee:	fba3 3000 	umull	r3, r0, r3, r0
}
   392f2:	f3c0 1087 	ubfx	r0, r0, #6, #8
   392f6:	4770      	bx	lr
   392f8:	20005200 	.word	0x20005200
   392fc:	f0f0f0f1 	.word	0xf0f0f0f1

00039300 <ull_scan_lll_handle_get>:
	return ((uint8_t *)scan - (uint8_t *)ll_scan) / sizeof(*scan);
   39300:	4a04      	ldr	r2, [pc, #16]	; (39314 <ull_scan_lll_handle_get+0x14>)
   39302:	6800      	ldr	r0, [r0, #0]
   39304:	4b04      	ldr	r3, [pc, #16]	; (39318 <ull_scan_lll_handle_get+0x18>)
   39306:	1a80      	subs	r0, r0, r2
   39308:	fba3 3000 	umull	r3, r0, r3, r0
}
   3930c:	f3c0 1087 	ubfx	r0, r0, #6, #8
   39310:	4770      	bx	lr
   39312:	bf00      	nop
   39314:	20005200 	.word	0x20005200
   39318:	f0f0f0f1 	.word	0xf0f0f0f1

0003931c <ull_scan_is_enabled_get>:
	if (handle >= BT_CTLR_SCAN_SET) {
   3931c:	b938      	cbnz	r0, 3932e <ull_scan_is_enabled_get+0x12>
	if (!scan || !scan->is_enabled) {
   3931e:	4805      	ldr	r0, [pc, #20]	; (39334 <ull_scan_is_enabled_get+0x18>)
   39320:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
		return NULL;
   39324:	f013 0f01 	tst.w	r3, #1
   39328:	bf08      	it	eq
   3932a:	2000      	moveq	r0, #0
   3932c:	4770      	bx	lr
   3932e:	2000      	movs	r0, #0
}
   39330:	4770      	bx	lr
   39332:	bf00      	nop
   39334:	20005200 	.word	0x20005200

00039338 <ull_scan_is_disabled_get>:
	if (!scan || scan->is_enabled) {
   39338:	4a04      	ldr	r2, [pc, #16]	; (3934c <ull_scan_is_disabled_get+0x14>)
   3933a:	f892 3040 	ldrb.w	r3, [r2, #64]	; 0x40
   3933e:	f003 0301 	and.w	r3, r3, #1
	return &ll_scan[handle];
   39342:	4318      	orrs	r0, r3
}
   39344:	bf0c      	ite	eq
   39346:	4610      	moveq	r0, r2
   39348:	2000      	movne	r0, #0
   3934a:	4770      	bx	lr
   3934c:	20005200 	.word	0x20005200

00039350 <ull_scan_is_enabled>:
	if (handle >= BT_CTLR_SCAN_SET) {
   39350:	b9a0      	cbnz	r0, 3937c <ull_scan_is_enabled+0x2c>
	if (!scan || !scan->is_enabled) {
   39352:	4a0b      	ldr	r2, [pc, #44]	; (39380 <ull_scan_is_enabled+0x30>)
   39354:	f892 3040 	ldrb.w	r3, [r2, #64]	; 0x40
   39358:	f013 0001 	ands.w	r0, r3, #1
   3935c:	d00f      	beq.n	3937e <ull_scan_is_enabled+0x2e>
		(scan->lll.conn ? ULL_SCAN_IS_INITIATOR : 0U) |
   3935e:	6a10      	ldr	r0, [r2, #32]
	return (((uint32_t)scan->is_enabled << scan->lll.type) |
   39360:	f892 1032 	ldrb.w	r1, [r2, #50]	; 0x32
		(scan->lll.conn ? ULL_SCAN_IS_INITIATOR : 0U) |
   39364:	3800      	subs	r0, #0
	return (((uint32_t)scan->is_enabled << scan->lll.type) |
   39366:	f3c1 1240 	ubfx	r2, r1, #5, #1
   3936a:	f003 0301 	and.w	r3, r3, #1
   3936e:	fa03 f302 	lsl.w	r3, r3, r2
		(scan->lll.conn ? ULL_SCAN_IS_INITIATOR : 0U) |
   39372:	bf18      	it	ne
   39374:	2001      	movne	r0, #1
   39376:	ea43 0080 	orr.w	r0, r3, r0, lsl #2
   3937a:	4770      	bx	lr
		return 0U;
   3937c:	2000      	movs	r0, #0
}
   3937e:	4770      	bx	lr
   39380:	20005200 	.word	0x20005200

00039384 <init_reset>:
{
   39384:	b510      	push	{r4, lr}
	mem_init(conn_pool, sizeof(struct ll_conn),
   39386:	4b15      	ldr	r3, [pc, #84]	; (393dc <init_reset+0x58>)
   39388:	4815      	ldr	r0, [pc, #84]	; (393e0 <init_reset+0x5c>)
	default_tx_time = PDU_DC_MAX_US(PDU_DC_PAYLOAD_SIZE_MIN, PHY_1M);
   3938a:	4c16      	ldr	r4, [pc, #88]	; (393e4 <init_reset+0x60>)
	mem_init(conn_pool, sizeof(struct ll_conn),
   3938c:	2206      	movs	r2, #6
   3938e:	f44f 71fc 	mov.w	r1, #504	; 0x1f8
   39392:	f7fb f861 	bl	34458 <mem_init>
	mem_init(mem_conn_tx.pool, CONN_TX_BUF_SIZE, CONN_DATA_BUFFERS,
   39396:	4b14      	ldr	r3, [pc, #80]	; (393e8 <init_reset+0x64>)
   39398:	2209      	movs	r2, #9
   3939a:	1d18      	adds	r0, r3, #4
   3939c:	2124      	movs	r1, #36	; 0x24
   3939e:	f7fb f85b 	bl	34458 <mem_init>
	mem_init(mem_conn_tx_ctrl.pool, CONN_TX_CTRL_BUF_SIZE,
   393a2:	4b12      	ldr	r3, [pc, #72]	; (393ec <init_reset+0x68>)
   393a4:	2218      	movs	r2, #24
   393a6:	1d18      	adds	r0, r3, #4
   393a8:	212c      	movs	r1, #44	; 0x2c
   393aa:	f7fb f855 	bl	34458 <mem_init>
	mem_init(mem_link_tx.pool, sizeof(memq_link_t),
   393ae:	4b10      	ldr	r3, [pc, #64]	; (393f0 <init_reset+0x6c>)
   393b0:	2221      	movs	r2, #33	; 0x21
   393b2:	1d18      	adds	r0, r3, #4
   393b4:	2108      	movs	r1, #8
   393b6:	f7fb f84f 	bl	34458 <mem_init>
	conn_upd_curr = NULL;
   393ba:	4a0e      	ldr	r2, [pc, #56]	; (393f4 <init_reset+0x70>)
	default_tx_octets = PDU_DC_PAYLOAD_SIZE_MIN;
   393bc:	4b0e      	ldr	r3, [pc, #56]	; (393f8 <init_reset+0x74>)
	default_phy_tx |= PHY_2M;
   393be:	490f      	ldr	r1, [pc, #60]	; (393fc <init_reset+0x78>)
   393c0:	2000      	movs	r0, #0
   393c2:	6010      	str	r0, [r2, #0]
	default_tx_octets = PDU_DC_PAYLOAD_SIZE_MIN;
   393c4:	221b      	movs	r2, #27
   393c6:	801a      	strh	r2, [r3, #0]
	default_phy_rx |= PHY_2M;
   393c8:	4a0d      	ldr	r2, [pc, #52]	; (39400 <init_reset+0x7c>)
	default_phy_tx |= PHY_2M;
   393ca:	2303      	movs	r3, #3
	default_tx_time = PDU_DC_MAX_US(PDU_DC_PAYLOAD_SIZE_MIN, PHY_1M);
   393cc:	f44f 7ca4 	mov.w	ip, #328	; 0x148
   393d0:	f8a4 c000 	strh.w	ip, [r4]
	default_phy_tx |= PHY_2M;
   393d4:	700b      	strb	r3, [r1, #0]
	default_phy_rx |= PHY_2M;
   393d6:	7013      	strb	r3, [r2, #0]
}
   393d8:	bd10      	pop	{r4, pc}
   393da:	bf00      	nop
   393dc:	20005274 	.word	0x20005274
   393e0:	200028e8 	.word	0x200028e8
   393e4:	20006a30 	.word	0x20006a30
   393e8:	200057a8 	.word	0x200057a8
   393ec:	20005384 	.word	0x20005384
   393f0:	20005278 	.word	0x20005278
   393f4:	200058f0 	.word	0x200058f0
   393f8:	20006a32 	.word	0x20006a32
   393fc:	20006bac 	.word	0x20006bac
   39400:	20006bab 	.word	0x20006bab

00039404 <ctrl_tx_pause_enqueue>:
{
   39404:	b538      	push	{r3, r4, r5, lr}
   39406:	4604      	mov	r4, r0
		if (!conn->tx_ctrl) {
   39408:	e9d0 3077 	ldrd	r3, r0, [r0, #476]	; 0x1dc
{
   3940c:	460d      	mov	r5, r1
	if (
   3940e:	b11b      	cbz	r3, 39418 <ctrl_tx_pause_enqueue+0x14>
	    !conn->llcp_cu.pause_tx &&
   39410:	f894 111a 	ldrb.w	r1, [r4, #282]	; 0x11a
	    conn->tx_head &&
   39414:	06c9      	lsls	r1, r1, #27
   39416:	d50e      	bpl.n	39436 <ctrl_tx_pause_enqueue+0x32>
		if (!conn->tx_ctrl) {
   39418:	2800      	cmp	r0, #0
   3941a:	d03a      	beq.n	39492 <ctrl_tx_pause_enqueue+0x8e>
			LL_ASSERT(!pause);
   3941c:	bb5a      	cbnz	r2, 39476 <ctrl_tx_pause_enqueue+0x72>
	tx->next = conn->tx_ctrl_last->next;
   3941e:	f8d4 31e4 	ldr.w	r3, [r4, #484]	; 0x1e4
   39422:	681b      	ldr	r3, [r3, #0]
   39424:	602b      	str	r3, [r5, #0]
	conn->tx_ctrl_last->next = tx;
   39426:	f8d4 31e4 	ldr.w	r3, [r4, #484]	; 0x1e4
   3942a:	601d      	str	r5, [r3, #0]
	conn->tx_ctrl_last = tx;
   3942c:	f8c4 51e4 	str.w	r5, [r4, #484]	; 0x1e4
	if (!tx->next) {
   39430:	682b      	ldr	r3, [r5, #0]
   39432:	b1eb      	cbz	r3, 39470 <ctrl_tx_pause_enqueue+0x6c>
}
   39434:	bd38      	pop	{r3, r4, r5, pc}
	    !conn->llcp_enc.pause_tx &&
   39436:	f894 1176 	ldrb.w	r1, [r4, #374]	; 0x176
	    !conn->llcp_cu.pause_tx &&
   3943a:	0789      	lsls	r1, r1, #30
   3943c:	d4ec      	bmi.n	39418 <ctrl_tx_pause_enqueue+0x14>
	    !conn->llcp_phy.pause_tx &&
   3943e:	f894 11d7 	ldrb.w	r1, [r4, #471]	; 0x1d7
   39442:	07c9      	lsls	r1, r1, #31
   39444:	d4e8      	bmi.n	39418 <ctrl_tx_pause_enqueue+0x14>
		if (conn->tx_head == conn->tx_data) {
   39446:	f8d4 11e8 	ldr.w	r1, [r4, #488]	; 0x1e8
   3944a:	428b      	cmp	r3, r1
   3944c:	d033      	beq.n	394b6 <ctrl_tx_pause_enqueue+0xb2>
		} else if (!conn->tx_ctrl) {
   3944e:	b340      	cbz	r0, 394a2 <ctrl_tx_pause_enqueue+0x9e>
			LL_ASSERT(!pause);
   39450:	2a00      	cmp	r2, #0
   39452:	d0e4      	beq.n	3941e <ctrl_tx_pause_enqueue+0x1a>
   39454:	4a21      	ldr	r2, [pc, #132]	; (394dc <ctrl_tx_pause_enqueue+0xd8>)
   39456:	4922      	ldr	r1, [pc, #136]	; (394e0 <ctrl_tx_pause_enqueue+0xdc>)
   39458:	4822      	ldr	r0, [pc, #136]	; (394e4 <ctrl_tx_pause_enqueue+0xe0>)
   3945a:	f640 335c 	movw	r3, #2908	; 0xb5c
   3945e:	f00f fe11 	bl	49084 <assert_print>
   39462:	4040      	eors	r0, r0
   39464:	f380 8811 	msr	BASEPRI, r0
   39468:	f04f 0003 	mov.w	r0, #3
   3946c:	df02      	svc	2
	tx->next = conn->tx_ctrl_last->next;
   3946e:	e7d6      	b.n	3941e <ctrl_tx_pause_enqueue+0x1a>
		conn->tx_data_last = tx;
   39470:	f8c4 51ec 	str.w	r5, [r4, #492]	; 0x1ec
}
   39474:	bd38      	pop	{r3, r4, r5, pc}
			LL_ASSERT(!pause);
   39476:	4a19      	ldr	r2, [pc, #100]	; (394dc <ctrl_tx_pause_enqueue+0xd8>)
   39478:	4919      	ldr	r1, [pc, #100]	; (394e0 <ctrl_tx_pause_enqueue+0xdc>)
   3947a:	481a      	ldr	r0, [pc, #104]	; (394e4 <ctrl_tx_pause_enqueue+0xe0>)
   3947c:	f640 336e 	movw	r3, #2926	; 0xb6e
   39480:	f00f fe00 	bl	49084 <assert_print>
   39484:	4040      	eors	r0, r0
   39486:	f380 8811 	msr	BASEPRI, r0
   3948a:	f04f 0003 	mov.w	r0, #3
   3948e:	df02      	svc	2
   39490:	e7c5      	b.n	3941e <ctrl_tx_pause_enqueue+0x1a>
			tx->next = conn->tx_head;
   39492:	602b      	str	r3, [r5, #0]
			conn->tx_head = tx;
   39494:	f8c4 51dc 	str.w	r5, [r4, #476]	; 0x1dc
			if (!pause) {
   39498:	2a00      	cmp	r2, #0
   3949a:	d1c9      	bne.n	39430 <ctrl_tx_pause_enqueue+0x2c>
				conn->tx_ctrl = tx;
   3949c:	e9c4 5578 	strd	r5, r5, [r4, #480]	; 0x1e0
   394a0:	e7c6      	b.n	39430 <ctrl_tx_pause_enqueue+0x2c>
	if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   394a2:	7919      	ldrb	r1, [r3, #4]
   394a4:	f001 0103 	and.w	r1, r1, #3
   394a8:	2903      	cmp	r1, #3
   394aa:	d011      	beq.n	394d0 <ctrl_tx_pause_enqueue+0xcc>
		conn->tx_ctrl = conn->tx_ctrl_last = conn->tx_head;
   394ac:	e9c4 3378 	strd	r3, r3, [r4, #480]	; 0x1e0
			LL_ASSERT(!pause);
   394b0:	2a00      	cmp	r2, #0
   394b2:	d0b4      	beq.n	3941e <ctrl_tx_pause_enqueue+0x1a>
   394b4:	e7ce      	b.n	39454 <ctrl_tx_pause_enqueue+0x50>
			conn->tx_data = conn->tx_data->next;
   394b6:	6819      	ldr	r1, [r3, #0]
   394b8:	f8c4 11e8 	str.w	r1, [r4, #488]	; 0x1e8
		if (!conn->tx_ctrl) {
   394bc:	2800      	cmp	r0, #0
   394be:	d1c7      	bne.n	39450 <ctrl_tx_pause_enqueue+0x4c>
			tx->next = conn->tx_head->next;
   394c0:	681b      	ldr	r3, [r3, #0]
   394c2:	602b      	str	r3, [r5, #0]
			conn->tx_head->next = tx;
   394c4:	f8d4 31dc 	ldr.w	r3, [r4, #476]	; 0x1dc
   394c8:	601d      	str	r5, [r3, #0]
			if (!pause) {
   394ca:	2a00      	cmp	r2, #0
   394cc:	d1b0      	bne.n	39430 <ctrl_tx_pause_enqueue+0x2c>
   394ce:	e7e5      	b.n	3949c <ctrl_tx_pause_enqueue+0x98>
	    ((pdu_data_tx->llctrl.opcode !=
   394d0:	79d9      	ldrb	r1, [r3, #7]
	if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   394d2:	2903      	cmp	r1, #3
   394d4:	d0f4      	beq.n	394c0 <ctrl_tx_pause_enqueue+0xbc>
	      PDU_DATA_LLCTRL_TYPE_ENC_REQ) &&
   394d6:	290a      	cmp	r1, #10
   394d8:	d1e8      	bne.n	394ac <ctrl_tx_pause_enqueue+0xa8>
   394da:	e7f1      	b.n	394c0 <ctrl_tx_pause_enqueue+0xbc>
   394dc:	0005269c 	.word	0x0005269c
   394e0:	000526dc 	.word	0x000526dc
   394e4:	0005214c 	.word	0x0005214c

000394e8 <tx_lll_flush>:
{
   394e8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	conn = HDR_LLL2ULL(lll);
   394ec:	f8d0 8000 	ldr.w	r8, [r0]
	return mem_index_get(conn, conn_pool, sizeof(struct ll_conn));
   394f0:	4934      	ldr	r1, [pc, #208]	; (395c4 <tx_lll_flush+0xdc>)
{
   394f2:	b083      	sub	sp, #12
   394f4:	4605      	mov	r5, r0
	return mem_index_get(conn, conn_pool, sizeof(struct ll_conn));
   394f6:	f44f 72fc 	mov.w	r2, #504	; 0x1f8
   394fa:	4640      	mov	r0, r8
   394fc:	f7fb f814 	bl	34528 <mem_index_get>
	link = memq_dequeue(lll->memq_tx.tail, &lll->memq_tx.head,
   39500:	f105 0648 	add.w	r6, r5, #72	; 0x48
	lll_conn_flush(handle, lll);
   39504:	4629      	mov	r1, r5
   39506:	f007 fc21 	bl	40d4c <lll_conn_flush>
	link = memq_dequeue(lll->memq_tx.tail, &lll->memq_tx.head,
   3950a:	6ce8      	ldr	r0, [r5, #76]	; 0x4c
   3950c:	aa01      	add	r2, sp, #4
   3950e:	4631      	mov	r1, r6
   39510:	f7fb f84a 	bl	345a8 <memq_dequeue>
	while (link) {
   39514:	b328      	cbz	r0, 39562 <tx_lll_flush+0x7a>
   39516:	4c2c      	ldr	r4, [pc, #176]	; (395c8 <tx_lll_flush+0xe0>)
		lll_tx->handle = LLL_HANDLE_INVALID;
   39518:	f64f 77ff 	movw	r7, #65535	; 0xffff
	*mem = (void *)(fifo + last * size); /* preceding buffer */
   3951c:	f104 0908 	add.w	r9, r4, #8
		idx = MFIFO_ENQUEUE_GET(conn_ack, (void **)&lll_tx);
   39520:	7962      	ldrb	r2, [r4, #5]
	if (last == count) {
   39522:	f894 c002 	ldrb.w	ip, [r4, #2]
   39526:	7921      	ldrb	r1, [r4, #4]
	last = last + 1;
   39528:	1c53      	adds	r3, r2, #1
   3952a:	b2db      	uxtb	r3, r3
		last = 0U;
   3952c:	459c      	cmp	ip, r3
   3952e:	bf08      	it	eq
   39530:	2300      	moveq	r3, #0
	if (last == first) {
   39532:	4299      	cmp	r1, r3
   39534:	f894 c000 	ldrb.w	ip, [r4]
   39538:	d033      	beq.n	395a2 <tx_lll_flush+0xba>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
   3953a:	fb12 f20c 	smulbb	r2, r2, ip
   3953e:	eb02 0109 	add.w	r1, r2, r9
		lll_tx->handle = LLL_HANDLE_INVALID;
   39542:	f829 7002 	strh.w	r7, [r9, r2]
		lll_tx->node = tx;
   39546:	9a01      	ldr	r2, [sp, #4]
   39548:	604a      	str	r2, [r1, #4]
		link->next = tx->next; /* Indicates ctrl pool or data pool */
   3954a:	6812      	ldr	r2, [r2, #0]
   3954c:	6002      	str	r2, [r0, #0]
		tx->next = link;
   3954e:	9a01      	ldr	r2, [sp, #4]
   39550:	6010      	str	r0, [r2, #0]
		link = memq_dequeue(lll->memq_tx.tail, &lll->memq_tx.head,
   39552:	6ce8      	ldr	r0, [r5, #76]	; 0x4c
	*last = idx; /* Commit: Update write index */
   39554:	7163      	strb	r3, [r4, #5]
   39556:	aa01      	add	r2, sp, #4
   39558:	4631      	mov	r1, r6
   3955a:	f7fb f825 	bl	345a8 <memq_dequeue>
	while (link) {
   3955e:	2800      	cmp	r0, #0
   39560:	d1de      	bne.n	39520 <tx_lll_flush+0x38>
	LL_ASSERT(rx->hdr.link);
   39562:	f8d8 0154 	ldr.w	r0, [r8, #340]	; 0x154
	rx = (void *)&conn->llcp_terminate.node_rx;
   39566:	f508 74aa 	add.w	r4, r8, #340	; 0x154
	LL_ASSERT(rx->hdr.link);
   3956a:	b150      	cbz	r0, 39582 <tx_lll_flush+0x9a>
	rx->hdr.link = NULL;
   3956c:	2300      	movs	r3, #0
	ull_rx_put(link, rx);
   3956e:	4621      	mov	r1, r4
	rx->hdr.link = NULL;
   39570:	f8c8 3154 	str.w	r3, [r8, #340]	; 0x154
	ull_rx_put(link, rx);
   39574:	f7fe fdc2 	bl	380fc <ull_rx_put>
	ull_rx_sched();
   39578:	f7fe fdd0 	bl	3811c <ull_rx_sched>
}
   3957c:	b003      	add	sp, #12
   3957e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	LL_ASSERT(rx->hdr.link);
   39582:	4a12      	ldr	r2, [pc, #72]	; (395cc <tx_lll_flush+0xe4>)
   39584:	4912      	ldr	r1, [pc, #72]	; (395d0 <tx_lll_flush+0xe8>)
   39586:	4813      	ldr	r0, [pc, #76]	; (395d4 <tx_lll_flush+0xec>)
   39588:	f640 23c7 	movw	r3, #2759	; 0xac7
   3958c:	f00f fd7a 	bl	49084 <assert_print>
   39590:	4040      	eors	r0, r0
   39592:	f380 8811 	msr	BASEPRI, r0
   39596:	f04f 0003 	mov.w	r0, #3
   3959a:	df02      	svc	2
	link = rx->hdr.link;
   3959c:	f8d8 0154 	ldr.w	r0, [r8, #340]	; 0x154
   395a0:	e7e4      	b.n	3956c <tx_lll_flush+0x84>
		LL_ASSERT(lll_tx);
   395a2:	4a0a      	ldr	r2, [pc, #40]	; (395cc <tx_lll_flush+0xe4>)
   395a4:	490c      	ldr	r1, [pc, #48]	; (395d8 <tx_lll_flush+0xf0>)
   395a6:	480b      	ldr	r0, [pc, #44]	; (395d4 <tx_lll_flush+0xec>)
   395a8:	f640 23b3 	movw	r3, #2739	; 0xab3
   395ac:	f00f fd6a 	bl	49084 <assert_print>
   395b0:	4040      	eors	r0, r0
   395b2:	f380 8811 	msr	BASEPRI, r0
   395b6:	f04f 0003 	mov.w	r0, #3
   395ba:	df02      	svc	2
		lll_tx->handle = LLL_HANDLE_INVALID;
   395bc:	2300      	movs	r3, #0
   395be:	801b      	strh	r3, [r3, #0]
   395c0:	deff      	udf	#255	; 0xff
   395c2:	bf00      	nop
   395c4:	200028e8 	.word	0x200028e8
   395c8:	20000aec 	.word	0x20000aec
   395cc:	0005269c 	.word	0x0005269c
   395d0:	000526ec 	.word	0x000526ec
   395d4:	0005214c 	.word	0x0005214c
   395d8:	000526e4 	.word	0x000526e4

000395dc <ctrl_tx_sec_enqueue>:
	if (conn->llcp_enc.pause_tx) {
   395dc:	f890 2176 	ldrb.w	r2, [r0, #374]	; 0x176
   395e0:	f012 0202 	ands.w	r2, r2, #2
   395e4:	d00c      	beq.n	39600 <ctrl_tx_sec_enqueue+0x24>
		if (!conn->tx_ctrl) {
   395e6:	f8d0 31e0 	ldr.w	r3, [r0, #480]	; 0x1e0
   395ea:	b1e3      	cbz	r3, 39626 <ctrl_tx_sec_enqueue+0x4a>
			tx->next = conn->tx_ctrl_last->next;
   395ec:	f8d0 31e4 	ldr.w	r3, [r0, #484]	; 0x1e4
   395f0:	681b      	ldr	r3, [r3, #0]
   395f2:	600b      	str	r3, [r1, #0]
			conn->tx_ctrl_last->next = tx;
   395f4:	f8d0 31e4 	ldr.w	r3, [r0, #484]	; 0x1e4
   395f8:	6019      	str	r1, [r3, #0]
		if (!tx->next) {
   395fa:	680b      	ldr	r3, [r1, #0]
   395fc:	b1db      	cbz	r3, 39636 <ctrl_tx_sec_enqueue+0x5a>
   395fe:	4770      	bx	lr
		if (conn->tx_head) {
   39600:	f8d0 31dc 	ldr.w	r3, [r0, #476]	; 0x1dc
   39604:	b1d3      	cbz	r3, 3963c <ctrl_tx_sec_enqueue+0x60>
{
   39606:	b500      	push	{lr}
			if ((conn->llcp_req != conn->llcp_ack) &&
   39608:	f890 c0f1 	ldrb.w	ip, [r0, #241]	; 0xf1
   3960c:	f890 e0f0 	ldrb.w	lr, [r0, #240]	; 0xf0
   39610:	45e6      	cmp	lr, ip
   39612:	d004      	beq.n	3961e <ctrl_tx_sec_enqueue+0x42>
   39614:	f890 c0f2 	ldrb.w	ip, [r0, #242]	; 0xf2
   39618:	f1bc 0f03 	cmp.w	ip, #3
   3961c:	d011      	beq.n	39642 <ctrl_tx_sec_enqueue+0x66>
}
   3961e:	f85d eb04 	ldr.w	lr, [sp], #4
		ctrl_tx_pause_enqueue(conn, tx, pause);
   39622:	f7ff beef 	b.w	39404 <ctrl_tx_pause_enqueue>
			tx->next = conn->tx_head;
   39626:	f8d0 31dc 	ldr.w	r3, [r0, #476]	; 0x1dc
   3962a:	600b      	str	r3, [r1, #0]
			conn->tx_head = tx;
   3962c:	f8c0 11dc 	str.w	r1, [r0, #476]	; 0x1dc
		if (!tx->next) {
   39630:	680b      	ldr	r3, [r1, #0]
   39632:	2b00      	cmp	r3, #0
   39634:	d1e3      	bne.n	395fe <ctrl_tx_sec_enqueue+0x22>
			conn->tx_data_last = tx;
   39636:	f8c0 11ec 	str.w	r1, [r0, #492]	; 0x1ec
   3963a:	4770      	bx	lr
	bool pause = false;
   3963c:	461a      	mov	r2, r3
		ctrl_tx_pause_enqueue(conn, tx, pause);
   3963e:	f7ff bee1 	b.w	39404 <ctrl_tx_pause_enqueue>
			    (pdu_data_tx->ll_id == PDU_DATA_LLID_CTRL) &&
   39642:	f893 c004 	ldrb.w	ip, [r3, #4]
			    (conn->llcp_type == LLCP_ENCRYPTION) &&
   39646:	f00c 0c03 	and.w	ip, ip, #3
   3964a:	f1bc 0f03 	cmp.w	ip, #3
   3964e:	d1e6      	bne.n	3961e <ctrl_tx_sec_enqueue+0x42>
			    ((pdu_data_tx->llctrl.opcode ==
   39650:	79da      	ldrb	r2, [r3, #7]
			    (pdu_data_tx->ll_id == PDU_DATA_LLID_CTRL) &&
   39652:	2a03      	cmp	r2, #3
   39654:	d005      	beq.n	39662 <ctrl_tx_sec_enqueue+0x86>
			      PDU_DATA_LLCTRL_TYPE_ENC_REQ) ||
   39656:	f1a2 020a 	sub.w	r2, r2, #10
   3965a:	fab2 f282 	clz	r2, r2
   3965e:	0952      	lsrs	r2, r2, #5
   39660:	e7dd      	b.n	3961e <ctrl_tx_sec_enqueue+0x42>
				pause = true;
   39662:	2201      	movs	r2, #1
   39664:	e7db      	b.n	3961e <ctrl_tx_sec_enqueue+0x42>
   39666:	bf00      	nop

00039668 <ticker_stop_op_cb>:
{
   39668:	b510      	push	{r4, lr}
   3966a:	460c      	mov	r4, r1
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
   3966c:	b9b0      	cbnz	r0, 3969c <ticker_stop_op_cb+0x34>
	mfy.param = param;
   3966e:	4b12      	ldr	r3, [pc, #72]	; (396b8 <ticker_stop_op_cb+0x50>)
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_LOW,
   39670:	2200      	movs	r2, #0
   39672:	2101      	movs	r1, #1
   39674:	2002      	movs	r0, #2
	mfy.param = param;
   39676:	609c      	str	r4, [r3, #8]
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_LOW,
   39678:	f7fa fffa 	bl	34670 <mayfly_enqueue>
	LL_ASSERT(!ret);
   3967c:	b900      	cbnz	r0, 39680 <ticker_stop_op_cb+0x18>
}
   3967e:	bd10      	pop	{r4, pc}
	LL_ASSERT(!ret);
   39680:	4a0e      	ldr	r2, [pc, #56]	; (396bc <ticker_stop_op_cb+0x54>)
   39682:	490f      	ldr	r1, [pc, #60]	; (396c0 <ticker_stop_op_cb+0x58>)
   39684:	480f      	ldr	r0, [pc, #60]	; (396c4 <ticker_stop_op_cb+0x5c>)
   39686:	f640 236d 	movw	r3, #2669	; 0xa6d
   3968a:	f00f fcfb 	bl	49084 <assert_print>
   3968e:	4040      	eors	r0, r0
   39690:	f380 8811 	msr	BASEPRI, r0
   39694:	f04f 0003 	mov.w	r0, #3
   39698:	df02      	svc	2
}
   3969a:	bd10      	pop	{r4, pc}
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
   3969c:	4a07      	ldr	r2, [pc, #28]	; (396bc <ticker_stop_op_cb+0x54>)
   3969e:	490a      	ldr	r1, [pc, #40]	; (396c8 <ticker_stop_op_cb+0x60>)
   396a0:	4808      	ldr	r0, [pc, #32]	; (396c4 <ticker_stop_op_cb+0x5c>)
   396a2:	f640 2367 	movw	r3, #2663	; 0xa67
   396a6:	f00f fced 	bl	49084 <assert_print>
   396aa:	4040      	eors	r0, r0
   396ac:	f380 8811 	msr	BASEPRI, r0
   396b0:	f04f 0003 	mov.w	r0, #3
   396b4:	df02      	svc	2
   396b6:	e7da      	b.n	3966e <ticker_stop_op_cb+0x6>
   396b8:	20000aac 	.word	0x20000aac
   396bc:	0005269c 	.word	0x0005269c
   396c0:	00052430 	.word	0x00052430
   396c4:	0005214c 	.word	0x0005214c
   396c8:	000526fc 	.word	0x000526fc

000396cc <disabled_cb>:
{
   396cc:	b508      	push	{r3, lr}
	mfy.param = param;
   396ce:	4b0b      	ldr	r3, [pc, #44]	; (396fc <disabled_cb+0x30>)
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
   396d0:	2200      	movs	r2, #0
	mfy.param = param;
   396d2:	6098      	str	r0, [r3, #8]
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
   396d4:	4611      	mov	r1, r2
   396d6:	2001      	movs	r0, #1
   396d8:	f7fa ffca 	bl	34670 <mayfly_enqueue>
	LL_ASSERT(!ret);
   396dc:	b900      	cbnz	r0, 396e0 <disabled_cb+0x14>
}
   396de:	bd08      	pop	{r3, pc}
	LL_ASSERT(!ret);
   396e0:	4a07      	ldr	r2, [pc, #28]	; (39700 <disabled_cb+0x34>)
   396e2:	4908      	ldr	r1, [pc, #32]	; (39704 <disabled_cb+0x38>)
   396e4:	4808      	ldr	r0, [pc, #32]	; (39708 <disabled_cb+0x3c>)
   396e6:	f640 2399 	movw	r3, #2713	; 0xa99
   396ea:	f00f fccb 	bl	49084 <assert_print>
   396ee:	4040      	eors	r0, r0
   396f0:	f380 8811 	msr	BASEPRI, r0
   396f4:	f04f 0003 	mov.w	r0, #3
   396f8:	df02      	svc	2
}
   396fa:	bd08      	pop	{r3, pc}
   396fc:	20000a8c 	.word	0x20000a8c
   39700:	0005269c 	.word	0x0005269c
   39704:	00052430 	.word	0x00052430
   39708:	0005214c 	.word	0x0005214c

0003970c <conn_disable>:
{
   3970c:	b538      	push	{r3, r4, r5, lr}
   3970e:	4604      	mov	r4, r0
	return hdr->ref;
   39710:	f810 3b1c 	ldrb.w	r3, [r0], #28
	if (ull_ref_get(hdr)) {
   39714:	b353      	cbz	r3, 3976c <conn_disable+0x60>
		mfy.param = &conn->lll;
   39716:	4d17      	ldr	r5, [pc, #92]	; (39774 <conn_disable+0x68>)
		LL_ASSERT(!hdr->disabled_cb);
   39718:	6963      	ldr	r3, [r4, #20]
		mfy.param = &conn->lll;
   3971a:	60a8      	str	r0, [r5, #8]
		LL_ASSERT(!hdr->disabled_cb);
   3971c:	b16b      	cbz	r3, 3973a <conn_disable+0x2e>
   3971e:	4a16      	ldr	r2, [pc, #88]	; (39778 <conn_disable+0x6c>)
   39720:	4916      	ldr	r1, [pc, #88]	; (3977c <conn_disable+0x70>)
   39722:	4817      	ldr	r0, [pc, #92]	; (39780 <conn_disable+0x74>)
   39724:	f640 2382 	movw	r3, #2690	; 0xa82
   39728:	f00f fcac 	bl	49084 <assert_print>
   3972c:	4040      	eors	r0, r0
   3972e:	f380 8811 	msr	BASEPRI, r0
   39732:	f04f 0003 	mov.w	r0, #3
   39736:	df02      	svc	2
		hdr->disabled_param = mfy.param;
   39738:	68a8      	ldr	r0, [r5, #8]
		hdr->disabled_cb = disabled_cb;
   3973a:	4912      	ldr	r1, [pc, #72]	; (39784 <conn_disable+0x78>)
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
   3973c:	4b0d      	ldr	r3, [pc, #52]	; (39774 <conn_disable+0x68>)
   3973e:	2200      	movs	r2, #0
		hdr->disabled_cb = disabled_cb;
   39740:	e9c4 1005 	strd	r1, r0, [r4, #20]
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
   39744:	4611      	mov	r1, r2
   39746:	2001      	movs	r0, #1
   39748:	f7fa ff92 	bl	34670 <mayfly_enqueue>
		LL_ASSERT(!ret);
   3974c:	b900      	cbnz	r0, 39750 <conn_disable+0x44>
}
   3974e:	bd38      	pop	{r3, r4, r5, pc}
		LL_ASSERT(!ret);
   39750:	4a09      	ldr	r2, [pc, #36]	; (39778 <conn_disable+0x6c>)
   39752:	490d      	ldr	r1, [pc, #52]	; (39788 <conn_disable+0x7c>)
   39754:	480a      	ldr	r0, [pc, #40]	; (39780 <conn_disable+0x74>)
   39756:	f640 2389 	movw	r3, #2697	; 0xa89
   3975a:	f00f fc93 	bl	49084 <assert_print>
   3975e:	4040      	eors	r0, r0
   39760:	f380 8811 	msr	BASEPRI, r0
   39764:	f04f 0003 	mov.w	r0, #3
   39768:	df02      	svc	2
}
   3976a:	bd38      	pop	{r3, r4, r5, pc}
   3976c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		disabled_cb(&conn->lll);
   39770:	f7ff bfac 	b.w	396cc <disabled_cb>
   39774:	20000a9c 	.word	0x20000a9c
   39778:	0005269c 	.word	0x0005269c
   3977c:	0005254c 	.word	0x0005254c
   39780:	0005214c 	.word	0x0005214c
   39784:	000396cd 	.word	0x000396cd
   39788:	00052430 	.word	0x00052430

0003978c <conn_setup_adv_scan_disabled_cb>:
	lll = *((struct lll_conn **)((uint8_t *)ftr->param +
   3978c:	6883      	ldr	r3, [r0, #8]
   3978e:	685a      	ldr	r2, [r3, #4]
	switch (lll->role) {
   39790:	7f53      	ldrb	r3, [r2, #29]
   39792:	09db      	lsrs	r3, r3, #7
	ftr = &(rx->rx_ftr);
   39794:	f100 0108 	add.w	r1, r0, #8
	switch (lll->role) {
   39798:	d001      	beq.n	3979e <conn_setup_adv_scan_disabled_cb+0x12>
		ull_periph_setup(rx, ftr, lll);
   3979a:	f7ed bfb1 	b.w	27700 <ull_periph_setup>
		ull_central_setup(rx, ftr, lll);
   3979e:	f7ee bc1f 	b.w	27fe0 <ull_central_setup>
   397a2:	bf00      	nop

000397a4 <ticker_start_conn_op_cb>:
{
   397a4:	b510      	push	{r4, lr}
   397a6:	460c      	mov	r4, r1
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
   397a8:	b990      	cbnz	r0, 397d0 <ticker_start_conn_op_cb+0x2c>
	p = ull_update_unmark(param);
   397aa:	4620      	mov	r0, r4
   397ac:	f7fe fbdc 	bl	37f68 <ull_update_unmark>
	LL_ASSERT(p == param);
   397b0:	4284      	cmp	r4, r0
   397b2:	d00c      	beq.n	397ce <ticker_start_conn_op_cb+0x2a>
   397b4:	4a0d      	ldr	r2, [pc, #52]	; (397ec <ticker_start_conn_op_cb+0x48>)
   397b6:	490e      	ldr	r1, [pc, #56]	; (397f0 <ticker_start_conn_op_cb+0x4c>)
   397b8:	480e      	ldr	r0, [pc, #56]	; (397f4 <ticker_start_conn_op_cb+0x50>)
   397ba:	f640 1394 	movw	r3, #2452	; 0x994
   397be:	f00f fc61 	bl	49084 <assert_print>
   397c2:	4040      	eors	r0, r0
   397c4:	f380 8811 	msr	BASEPRI, r0
   397c8:	f04f 0003 	mov.w	r0, #3
   397cc:	df02      	svc	2
}
   397ce:	bd10      	pop	{r4, pc}
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
   397d0:	4a06      	ldr	r2, [pc, #24]	; (397ec <ticker_start_conn_op_cb+0x48>)
   397d2:	4909      	ldr	r1, [pc, #36]	; (397f8 <ticker_start_conn_op_cb+0x54>)
   397d4:	4807      	ldr	r0, [pc, #28]	; (397f4 <ticker_start_conn_op_cb+0x50>)
   397d6:	f640 1391 	movw	r3, #2449	; 0x991
   397da:	f00f fc53 	bl	49084 <assert_print>
   397de:	4040      	eors	r0, r0
   397e0:	f380 8811 	msr	BASEPRI, r0
   397e4:	f04f 0003 	mov.w	r0, #3
   397e8:	df02      	svc	2
   397ea:	e7de      	b.n	397aa <ticker_start_conn_op_cb+0x6>
   397ec:	0005269c 	.word	0x0005269c
   397f0:	00052708 	.word	0x00052708
   397f4:	0005214c 	.word	0x0005214c
   397f8:	000526fc 	.word	0x000526fc

000397fc <ticker_stop_conn_op_cb>:
{
   397fc:	b510      	push	{r4, lr}
   397fe:	460c      	mov	r4, r1
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
   39800:	b990      	cbnz	r0, 39828 <ticker_stop_conn_op_cb+0x2c>
	p = ull_update_mark(param);
   39802:	4620      	mov	r0, r4
   39804:	f7fe fba4 	bl	37f50 <ull_update_mark>
	LL_ASSERT(p == param);
   39808:	4284      	cmp	r4, r0
   3980a:	d00c      	beq.n	39826 <ticker_stop_conn_op_cb+0x2a>
   3980c:	4a0d      	ldr	r2, [pc, #52]	; (39844 <ticker_stop_conn_op_cb+0x48>)
   3980e:	490e      	ldr	r1, [pc, #56]	; (39848 <ticker_stop_conn_op_cb+0x4c>)
   39810:	480e      	ldr	r0, [pc, #56]	; (3984c <ticker_stop_conn_op_cb+0x50>)
   39812:	f640 138a 	movw	r3, #2442	; 0x98a
   39816:	f00f fc35 	bl	49084 <assert_print>
   3981a:	4040      	eors	r0, r0
   3981c:	f380 8811 	msr	BASEPRI, r0
   39820:	f04f 0003 	mov.w	r0, #3
   39824:	df02      	svc	2
}
   39826:	bd10      	pop	{r4, pc}
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
   39828:	4a06      	ldr	r2, [pc, #24]	; (39844 <ticker_stop_conn_op_cb+0x48>)
   3982a:	4909      	ldr	r1, [pc, #36]	; (39850 <ticker_stop_conn_op_cb+0x54>)
   3982c:	4807      	ldr	r0, [pc, #28]	; (3984c <ticker_stop_conn_op_cb+0x50>)
   3982e:	f640 1387 	movw	r3, #2439	; 0x987
   39832:	f00f fc27 	bl	49084 <assert_print>
   39836:	4040      	eors	r0, r0
   39838:	f380 8811 	msr	BASEPRI, r0
   3983c:	f04f 0003 	mov.w	r0, #3
   39840:	df02      	svc	2
   39842:	e7de      	b.n	39802 <ticker_stop_conn_op_cb+0x6>
   39844:	0005269c 	.word	0x0005269c
   39848:	00052708 	.word	0x00052708
   3984c:	0005214c 	.word	0x0005214c
   39850:	000526fc 	.word	0x000526fc

00039854 <ticker_update_conn_op_cb>:
	LL_ASSERT(status == TICKER_STATUS_SUCCESS ||
   39854:	b900      	cbnz	r0, 39858 <ticker_update_conn_op_cb+0x4>
   39856:	4770      	bx	lr
{
   39858:	b510      	push	{r4, lr}
   3985a:	460c      	mov	r4, r1
	LL_ASSERT(status == TICKER_STATUS_SUCCESS ||
   3985c:	f7fe fb90 	bl	37f80 <ull_update_mark_get>
   39860:	4284      	cmp	r4, r0
   39862:	d010      	beq.n	39886 <ticker_update_conn_op_cb+0x32>
   39864:	f7fe fb6e 	bl	37f44 <ull_disable_mark_get>
   39868:	4284      	cmp	r4, r0
   3986a:	d00c      	beq.n	39886 <ticker_update_conn_op_cb+0x32>
   3986c:	4a06      	ldr	r2, [pc, #24]	; (39888 <ticker_update_conn_op_cb+0x34>)
   3986e:	4907      	ldr	r1, [pc, #28]	; (3988c <ticker_update_conn_op_cb+0x38>)
   39870:	4807      	ldr	r0, [pc, #28]	; (39890 <ticker_update_conn_op_cb+0x3c>)
   39872:	f640 137e 	movw	r3, #2430	; 0x97e
   39876:	f00f fc05 	bl	49084 <assert_print>
   3987a:	4040      	eors	r0, r0
   3987c:	f380 8811 	msr	BASEPRI, r0
   39880:	f04f 0003 	mov.w	r0, #3
   39884:	df02      	svc	2
}
   39886:	bd10      	pop	{r4, pc}
   39888:	0005269c 	.word	0x0005269c
   3988c:	00052714 	.word	0x00052714
   39890:	0005214c 	.word	0x0005214c

00039894 <tx_ull_dequeue>:
{
   39894:	b410      	push	{r4}
	if (!conn->tx_ctrl && (conn->tx_head != conn->tx_data)) {
   39896:	e9d0 2477 	ldrd	r2, r4, [r0, #476]	; 0x1dc
{
   3989a:	4603      	mov	r3, r0
   3989c:	4608      	mov	r0, r1
	if (!conn->tx_ctrl && (conn->tx_head != conn->tx_data)) {
   3989e:	b164      	cbz	r4, 398ba <tx_ull_dequeue+0x26>
	if (conn->tx_head == conn->tx_ctrl) {
   398a0:	4294      	cmp	r4, r2
   398a2:	d026      	beq.n	398f2 <tx_ull_dequeue+0x5e>
	if (!conn->tx_ctrl && (conn->tx_head != conn->tx_data)) {
   398a4:	f8d3 11e8 	ldr.w	r1, [r3, #488]	; 0x1e8
		if (conn->tx_head == conn->tx_data) {
   398a8:	428a      	cmp	r2, r1
   398aa:	d00b      	beq.n	398c4 <tx_ull_dequeue+0x30>
		conn->tx_head = conn->tx_head->next;
   398ac:	6812      	ldr	r2, [r2, #0]
   398ae:	f8c3 21dc 	str.w	r2, [r3, #476]	; 0x1dc
   398b2:	2300      	movs	r3, #0
		tx->next = tx;
   398b4:	6003      	str	r3, [r0, #0]
}
   398b6:	bc10      	pop	{r4}
   398b8:	4770      	bx	lr
	if (!conn->tx_ctrl && (conn->tx_head != conn->tx_data)) {
   398ba:	f8d3 11e8 	ldr.w	r1, [r3, #488]	; 0x1e8
   398be:	4291      	cmp	r1, r2
   398c0:	d104      	bne.n	398cc <tx_ull_dequeue+0x38>
	if (conn->tx_head == conn->tx_ctrl) {
   398c2:	b1b2      	cbz	r2, 398f2 <tx_ull_dequeue+0x5e>
			conn->tx_data = conn->tx_data->next;
   398c4:	6809      	ldr	r1, [r1, #0]
   398c6:	f8c3 11e8 	str.w	r1, [r3, #488]	; 0x1e8
   398ca:	e7ef      	b.n	398ac <tx_ull_dequeue+0x18>
	if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   398cc:	7911      	ldrb	r1, [r2, #4]
   398ce:	f001 0103 	and.w	r1, r1, #3
   398d2:	2903      	cmp	r1, #3
   398d4:	d015      	beq.n	39902 <tx_ull_dequeue+0x6e>
		conn->tx_ctrl = conn->tx_ctrl_last = conn->tx_head;
   398d6:	e9c3 2278 	strd	r2, r2, [r3, #480]	; 0x1e0
		conn->tx_head = conn->tx_head->next;
   398da:	6812      	ldr	r2, [r2, #0]
   398dc:	f8c3 21dc 	str.w	r2, [r3, #476]	; 0x1dc
			conn->tx_ctrl_last = NULL;
   398e0:	2200      	movs	r2, #0
   398e2:	f8c3 21e4 	str.w	r2, [r3, #484]	; 0x1e4
   398e6:	f8c3 21e0 	str.w	r2, [r3, #480]	; 0x1e0
		tx->next = tx;
   398ea:	4603      	mov	r3, r0
   398ec:	6003      	str	r3, [r0, #0]
}
   398ee:	bc10      	pop	{r4}
   398f0:	4770      	bx	lr
		if (conn->tx_ctrl == conn->tx_ctrl_last) {
   398f2:	f8d3 11e4 	ldr.w	r1, [r3, #484]	; 0x1e4
		conn->tx_head = conn->tx_head->next;
   398f6:	6812      	ldr	r2, [r2, #0]
   398f8:	f8c3 21dc 	str.w	r2, [r3, #476]	; 0x1dc
		if (conn->tx_ctrl == conn->tx_ctrl_last) {
   398fc:	42a1      	cmp	r1, r4
   398fe:	d1f2      	bne.n	398e6 <tx_ull_dequeue+0x52>
   39900:	e7ee      	b.n	398e0 <tx_ull_dequeue+0x4c>
	    ((pdu_data_tx->llctrl.opcode !=
   39902:	79d1      	ldrb	r1, [r2, #7]
	if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   39904:	2903      	cmp	r1, #3
   39906:	d0d1      	beq.n	398ac <tx_ull_dequeue+0x18>
	      PDU_DATA_LLCTRL_TYPE_ENC_REQ) &&
   39908:	290a      	cmp	r1, #10
   3990a:	d1e4      	bne.n	398d6 <tx_ull_dequeue+0x42>
   3990c:	e7ce      	b.n	398ac <tx_ull_dequeue+0x18>
   3990e:	bf00      	nop

00039910 <feature_rsp_send>:
{
   39910:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	if (conn->common.txn_lock) {
   39914:	f890 70e4 	ldrb.w	r7, [r0, #228]	; 0xe4
   39918:	f017 0702 	ands.w	r7, r7, #2
{
   3991c:	4688      	mov	r8, r1
	if (conn->common.txn_lock) {
   3991e:	d15d      	bne.n	399dc <feature_rsp_send+0xcc>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
   39920:	4604      	mov	r4, r0
   39922:	4833      	ldr	r0, [pc, #204]	; (399f0 <feature_rsp_send+0xe0>)
   39924:	4691      	mov	r9, r2
   39926:	f7fa fdc7 	bl	344b8 <mem_acquire>
	if (!tx) {
   3992a:	4605      	mov	r5, r0
   3992c:	2800      	cmp	r0, #0
   3992e:	d05b      	beq.n	399e8 <feature_rsp_send+0xd8>
	conn->common.txn_lock = 1U;
   39930:	f894 30e4 	ldrb.w	r3, [r4, #228]	; 0xe4
	feat &= LL_FEAT_BIT_MASK;
   39934:	492f      	ldr	r1, [pc, #188]	; (399f4 <feature_rsp_send+0xe4>)
	conn->common.txn_lock = 1U;
   39936:	f043 0302 	orr.w	r3, r3, #2
   3993a:	f884 30e4 	strb.w	r3, [r4, #228]	; 0xe4
   3993e:	f8d9 2004 	ldr.w	r2, [r9, #4]
   39942:	f8d9 3008 	ldr.w	r3, [r9, #8]
	feat &= LL_FEAT_BIT_MASK;
   39946:	4311      	orrs	r1, r2
	conn->llcp_feature.features_conn &= feat_get(&req->features[0]);
   39948:	f8d4 2138 	ldr.w	r2, [r4, #312]	; 0x138
   3994c:	400a      	ands	r2, r1
   3994e:	f8c4 2138 	str.w	r2, [r4, #312]	; 0x138
	feat &= LL_FEAT_BIT_MASK;
   39952:	f003 03ff 	and.w	r3, r3, #255	; 0xff
	conn->llcp_feature.features_conn &= feat_get(&req->features[0]);
   39956:	f8d4 213c 	ldr.w	r2, [r4, #316]	; 0x13c
	feat &= LL_FEAT_BIT_MASK;
   3995a:	f043 0310 	orr.w	r3, r3, #16
	conn->llcp_feature.features_conn &= feat_get(&req->features[0]);
   3995e:	401a      	ands	r2, r3
   39960:	f8c4 213c 	str.w	r2, [r4, #316]	; 0x13c
   39964:	f8d9 6004 	ldr.w	r6, [r9, #4]
   39968:	f8d9 9008 	ldr.w	r9, [r9, #8]
	return feat;
   3996c:	f009 09ff 	and.w	r9, r9, #255	; 0xff
		feat_land_octet0(feat_get(&req->features[0]), ll_feat_get());
   39970:	f7fd fd30 	bl	373d4 <ll_feat_get>
	feat_result |= feat_to_keep & LL_FEAT_FILTER_OCTET0;
   39974:	f049 0310 	orr.w	r3, r9, #16
	conn->llcp_feature.features_peer =
   39978:	f8c4 3144 	str.w	r3, [r4, #324]	; 0x144
	feat &= LL_FEAT_BIT_MASK;
   3997c:	4b1d      	ldr	r3, [pc, #116]	; (399f4 <feature_rsp_send+0xe4>)
   3997e:	4333      	orrs	r3, r6
	feat_result = feat_to_keep & feat_octet0;
   39980:	4003      	ands	r3, r0
	feat_result &= 0xFF;
   39982:	f003 00ff 	and.w	r0, r3, #255	; 0xff
   39986:	f026 03ff 	bic.w	r3, r6, #255	; 0xff
   3998a:	4303      	orrs	r3, r0
	feat_result |= feat_to_keep & LL_FEAT_FILTER_OCTET0;
   3998c:	f043 6307 	orr.w	r3, r3, #141557760	; 0x8700000
   39990:	f443 2303 	orr.w	r3, r3, #536576	; 0x83000
	conn->llcp_feature.features_peer =
   39994:	f8c4 3140 	str.w	r3, [r4, #320]	; 0x140
	conn->common.fex_valid = 1U;
   39998:	f894 30e4 	ldrb.w	r3, [r4, #228]	; 0xe4
   3999c:	f043 0301 	orr.w	r3, r3, #1
   399a0:	f884 30e4 	strb.w	r3, [r4, #228]	; 0xe4
	pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
   399a4:	792b      	ldrb	r3, [r5, #4]
   399a6:	f043 0303 	orr.w	r3, r3, #3
	(void)memset(&pdu_tx->llctrl.feature_rsp.features[0], 0x00,
   399aa:	2208      	movs	r2, #8
	pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
   399ac:	712b      	strb	r3, [r5, #4]
	pdu_tx->len = offsetof(struct pdu_data_llctrl, feature_rsp) +
   399ae:	2309      	movs	r3, #9
   399b0:	716b      	strb	r3, [r5, #5]
	pdu_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_FEATURE_RSP;
   399b2:	71eb      	strb	r3, [r5, #7]
	(void)memset(&pdu_tx->llctrl.feature_rsp.features[0], 0x00,
   399b4:	4639      	mov	r1, r7
   399b6:	18a8      	adds	r0, r5, r2
   399b8:	f011 fa6a 	bl	4ae90 <memset>
	feat = feat_land_octet0(ll_feat_get(),
   399bc:	f7fd fd0a 	bl	373d4 <ll_feat_get>
	feat_result = feat_to_keep & feat_octet0;
   399c0:	f8d4 3138 	ldr.w	r3, [r4, #312]	; 0x138
	dst[0] = val;
   399c4:	7329      	strb	r1, [r5, #12]
	feat_result |= feat_to_keep & LL_FEAT_FILTER_OCTET0;
   399c6:	f063 03ff 	orn	r3, r3, #255	; 0xff
   399ca:	4003      	ands	r3, r0
   399cc:	60ab      	str	r3, [r5, #8]
	dst[1] = val >> 8;
   399ce:	f8a5 700d 	strh.w	r7, [r5, #13]
   399d2:	73ef      	strb	r7, [r5, #15]
	ctrl_tx_sec_enqueue(conn, tx);
   399d4:	4629      	mov	r1, r5
   399d6:	4620      	mov	r0, r4
   399d8:	f7ff fe00 	bl	395dc <ctrl_tx_sec_enqueue>
	rx->hdr.type = NODE_RX_TYPE_RELEASE;
   399dc:	2301      	movs	r3, #1
   399de:	f888 3004 	strb.w	r3, [r8, #4]
	return 0;
   399e2:	2000      	movs	r0, #0
}
   399e4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		*err = -ENOBUFS;
   399e8:	f06f 0068 	mvn.w	r0, #104	; 0x68
   399ec:	e7fa      	b.n	399e4 <feature_rsp_send+0xd4>
   399ee:	bf00      	nop
   399f0:	20005384 	.word	0x20005384
   399f4:	087830d0 	.word	0x087830d0

000399f8 <reject_ext_ind_send>:
{
   399f8:	e92d 41e8 	stmdb	sp!, {r3, r5, r6, r7, r8, lr}
   399fc:	4605      	mov	r5, r0
	if (conn->common.txn_lock) {
   399fe:	f890 00e4 	ldrb.w	r0, [r0, #228]	; 0xe4
{
   39a02:	460e      	mov	r6, r1
	if (conn->common.txn_lock) {
   39a04:	0781      	lsls	r1, r0, #30
   39a06:	d444      	bmi.n	39a92 <reject_ext_ind_send+0x9a>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
   39a08:	4832      	ldr	r0, [pc, #200]	; (39ad4 <reject_ext_ind_send+0xdc>)
   39a0a:	4690      	mov	r8, r2
   39a0c:	461f      	mov	r7, r3
   39a0e:	f7fa fd53 	bl	344b8 <mem_acquire>
	if (!tx) {
   39a12:	2800      	cmp	r0, #0
   39a14:	d048      	beq.n	39aa8 <reject_ext_ind_send+0xb0>
	conn->common.txn_lock = 1U;
   39a16:	f895 30e4 	ldrb.w	r3, [r5, #228]	; 0xe4
   39a1a:	f043 0302 	orr.w	r3, r3, #2
   39a1e:	f885 30e4 	strb.w	r3, [r5, #228]	; 0xe4
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   39a22:	7903      	ldrb	r3, [r0, #4]
	pdu_ctrl_tx->llctrl.reject_ext_ind.reject_opcode = reject_opcode;
   39a24:	f880 8008 	strb.w	r8, [r0, #8]
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, reject_ext_ind) +
   39a28:	2203      	movs	r2, #3
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   39a2a:	4313      	orrs	r3, r2
   39a2c:	7103      	strb	r3, [r0, #4]
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND;
   39a2e:	2311      	movs	r3, #17
	pdu_ctrl_tx->llctrl.reject_ext_ind.error_code = error_code;
   39a30:	7247      	strb	r7, [r0, #9]
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, reject_ext_ind) +
   39a32:	7142      	strb	r2, [r0, #5]
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND;
   39a34:	71c3      	strb	r3, [r0, #7]
	    conn->tx_head &&
   39a36:	f8d5 31dc 	ldr.w	r3, [r5, #476]	; 0x1dc
	if (
   39a3a:	b1d3      	cbz	r3, 39a72 <reject_ext_ind_send+0x7a>
	    !conn->llcp_cu.pause_tx &&
   39a3c:	f895 211a 	ldrb.w	r2, [r5, #282]	; 0x11a
	    conn->tx_head &&
   39a40:	06d7      	lsls	r7, r2, #27
   39a42:	d416      	bmi.n	39a72 <reject_ext_ind_send+0x7a>
	    !conn->llcp_enc.pause_tx &&
   39a44:	f895 2176 	ldrb.w	r2, [r5, #374]	; 0x176
	    !conn->llcp_cu.pause_tx &&
   39a48:	0791      	lsls	r1, r2, #30
   39a4a:	d412      	bmi.n	39a72 <reject_ext_ind_send+0x7a>
	    !conn->llcp_phy.pause_tx &&
   39a4c:	f895 21d7 	ldrb.w	r2, [r5, #471]	; 0x1d7
   39a50:	07d2      	lsls	r2, r2, #31
   39a52:	d40e      	bmi.n	39a72 <reject_ext_ind_send+0x7a>
		if (conn->tx_head == conn->tx_data) {
   39a54:	f8d5 11e8 	ldr.w	r1, [r5, #488]	; 0x1e8
		if (!conn->tx_ctrl) {
   39a58:	f8d5 21e0 	ldr.w	r2, [r5, #480]	; 0x1e0
		if (conn->tx_head == conn->tx_data) {
   39a5c:	428b      	cmp	r3, r1
   39a5e:	d026      	beq.n	39aae <reject_ext_ind_send+0xb6>
		} else if (!conn->tx_ctrl) {
   39a60:	b952      	cbnz	r2, 39a78 <reject_ext_ind_send+0x80>
	if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   39a62:	791a      	ldrb	r2, [r3, #4]
   39a64:	f002 0203 	and.w	r2, r2, #3
   39a68:	2a03      	cmp	r2, #3
   39a6a:	d02d      	beq.n	39ac8 <reject_ext_ind_send+0xd0>
		conn->tx_ctrl = conn->tx_ctrl_last = conn->tx_head;
   39a6c:	e9c5 3378 	strd	r3, r3, [r5, #480]	; 0x1e0
   39a70:	e004      	b.n	39a7c <reject_ext_ind_send+0x84>
		if (!conn->tx_ctrl) {
   39a72:	f8d5 21e0 	ldr.w	r2, [r5, #480]	; 0x1e0
   39a76:	b18a      	cbz	r2, 39a9c <reject_ext_ind_send+0xa4>
	tx->next = conn->tx_ctrl_last->next;
   39a78:	f8d5 31e4 	ldr.w	r3, [r5, #484]	; 0x1e4
   39a7c:	681b      	ldr	r3, [r3, #0]
   39a7e:	6003      	str	r3, [r0, #0]
	conn->tx_ctrl_last->next = tx;
   39a80:	f8d5 31e4 	ldr.w	r3, [r5, #484]	; 0x1e4
   39a84:	6018      	str	r0, [r3, #0]
	conn->tx_ctrl_last = tx;
   39a86:	f8c5 01e4 	str.w	r0, [r5, #484]	; 0x1e4
	if (!tx->next) {
   39a8a:	6803      	ldr	r3, [r0, #0]
   39a8c:	b90b      	cbnz	r3, 39a92 <reject_ext_ind_send+0x9a>
		conn->tx_data_last = tx;
   39a8e:	f8c5 01ec 	str.w	r0, [r5, #492]	; 0x1ec
		rx->hdr.type = NODE_RX_TYPE_RELEASE;
   39a92:	2301      	movs	r3, #1
   39a94:	7133      	strb	r3, [r6, #4]
		*err = 0;
   39a96:	2000      	movs	r0, #0
}
   39a98:	e8bd 81e8 	ldmia.w	sp!, {r3, r5, r6, r7, r8, pc}
			tx->next = conn->tx_head;
   39a9c:	6003      	str	r3, [r0, #0]
			conn->tx_head = tx;
   39a9e:	f8c5 01dc 	str.w	r0, [r5, #476]	; 0x1dc
   39aa2:	f8c5 01e0 	str.w	r0, [r5, #480]	; 0x1e0
				conn->tx_ctrl_last = tx;
   39aa6:	e7ee      	b.n	39a86 <reject_ext_ind_send+0x8e>
		*err = -ENOBUFS;
   39aa8:	f06f 0068 	mvn.w	r0, #104	; 0x68
   39aac:	e7f4      	b.n	39a98 <reject_ext_ind_send+0xa0>
			conn->tx_data = conn->tx_data->next;
   39aae:	6819      	ldr	r1, [r3, #0]
   39ab0:	f8c5 11e8 	str.w	r1, [r5, #488]	; 0x1e8
		if (!conn->tx_ctrl) {
   39ab4:	2a00      	cmp	r2, #0
   39ab6:	d1df      	bne.n	39a78 <reject_ext_ind_send+0x80>
			tx->next = conn->tx_head->next;
   39ab8:	681b      	ldr	r3, [r3, #0]
   39aba:	6003      	str	r3, [r0, #0]
			conn->tx_head->next = tx;
   39abc:	f8d5 31dc 	ldr.w	r3, [r5, #476]	; 0x1dc
   39ac0:	6018      	str	r0, [r3, #0]
				conn->tx_ctrl = tx;
   39ac2:	f8c5 01e0 	str.w	r0, [r5, #480]	; 0x1e0
				conn->tx_ctrl_last = tx;
   39ac6:	e7de      	b.n	39a86 <reject_ext_ind_send+0x8e>
	    ((pdu_data_tx->llctrl.opcode !=
   39ac8:	79da      	ldrb	r2, [r3, #7]
	if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   39aca:	2a03      	cmp	r2, #3
   39acc:	d0f4      	beq.n	39ab8 <reject_ext_ind_send+0xc0>
	      PDU_DATA_LLCTRL_TYPE_ENC_REQ) &&
   39ace:	2a0a      	cmp	r2, #10
   39ad0:	d1cc      	bne.n	39a6c <reject_ext_ind_send+0x74>
   39ad2:	e7f1      	b.n	39ab8 <reject_ext_ind_send+0xc0>
   39ad4:	20005384 	.word	0x20005384

00039ad8 <event_len_prep>:
{
   39ad8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	switch (conn->llcp_length.state) {
   39ada:	f890 31c6 	ldrb.w	r3, [r0, #454]	; 0x1c6
   39ade:	f003 0207 	and.w	r2, r3, #7
{
   39ae2:	4604      	mov	r4, r0
	switch (conn->llcp_length.state) {
   39ae4:	2a06      	cmp	r2, #6
   39ae6:	f200 80e1 	bhi.w	39cac <event_len_prep+0x1d4>
   39aea:	e8df f002 	tbb	[pc, r2]
   39aee:	4c04      	.short	0x4c04
   39af0:	4d4d4c4c 	.word	0x4d4d4c4c
   39af4:	4c          	.byte	0x4c
   39af5:	00          	.byte	0x00
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
   39af6:	4874      	ldr	r0, [pc, #464]	; (39cc8 <event_len_prep+0x1f0>)
   39af8:	f7fa fcde 	bl	344b8 <mem_acquire>
		if (!tx) {
   39afc:	2800      	cmp	r0, #0
   39afe:	d042      	beq.n	39b86 <event_len_prep+0xae>
		conn->llcp_length.state = LLCP_LENGTH_STATE_REQ_ACK_WAIT;
   39b00:	f894 21c6 	ldrb.w	r2, [r4, #454]	; 0x1c6
		conn->default_tx_octets = conn->llcp_length.tx_octets;
   39b04:	f8b4 11ca 	ldrh.w	r1, [r4, #458]	; 0x1ca
   39b08:	f8a4 10d2 	strh.w	r1, [r4, #210]	; 0xd2
		conn->llcp_length.state = LLCP_LENGTH_STATE_REQ_ACK_WAIT;
   39b0c:	2301      	movs	r3, #1
		conn->default_tx_time = conn->llcp_length.tx_time;
   39b0e:	f8b4 11ce 	ldrh.w	r1, [r4, #462]	; 0x1ce
   39b12:	f8a4 10d4 	strh.w	r1, [r4, #212]	; 0xd4
		conn->llcp_length.state = LLCP_LENGTH_STATE_REQ_ACK_WAIT;
   39b16:	f363 0202 	bfi	r2, r3, #0, #3
   39b1a:	f884 21c6 	strb.w	r2, [r4, #454]	; 0x1c6
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   39b1e:	7902      	ldrb	r2, [r0, #4]
   39b20:	f042 0203 	orr.w	r2, r2, #3
   39b24:	7102      	strb	r2, [r0, #4]
		pdu_ctrl_tx->len =
   39b26:	2109      	movs	r1, #9
		pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_REQ;
   39b28:	2214      	movs	r2, #20
		pdu_ctrl_tx->len =
   39b2a:	7141      	strb	r1, [r0, #5]
		pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_REQ;
   39b2c:	71c2      	strb	r2, [r0, #7]
		lr->max_rx_octets = sys_cpu_to_le16(LL_LENGTH_OCTETS_RX_MAX);
   39b2e:	2100      	movs	r1, #0
   39b30:	221b      	movs	r2, #27
   39b32:	7202      	strb	r2, [r0, #8]
   39b34:	7241      	strb	r1, [r0, #9]
		lr->max_tx_octets = sys_cpu_to_le16(conn->default_tx_octets);
   39b36:	f8b4 10d2 	ldrh.w	r1, [r4, #210]	; 0xd2
   39b3a:	8181      	strh	r1, [r0, #12]
		lr->max_rx_time = sys_cpu_to_le16(rx_time);
   39b3c:	2248      	movs	r2, #72	; 0x48
   39b3e:	7282      	strb	r2, [r0, #10]
   39b40:	72c3      	strb	r3, [r0, #11]
		lr->max_tx_time = sys_cpu_to_le16(tx_time);
   39b42:	7382      	strb	r2, [r0, #14]
   39b44:	73c3      	strb	r3, [r0, #15]
	    conn->tx_head &&
   39b46:	f8d4 31dc 	ldr.w	r3, [r4, #476]	; 0x1dc
	if (
   39b4a:	b13b      	cbz	r3, 39b5c <event_len_prep+0x84>
	    !conn->llcp_cu.pause_tx &&
   39b4c:	f894 211a 	ldrb.w	r2, [r4, #282]	; 0x11a
	    conn->tx_head &&
   39b50:	06d5      	lsls	r5, r2, #27
   39b52:	d403      	bmi.n	39b5c <event_len_prep+0x84>
	    !conn->llcp_enc.pause_tx &&
   39b54:	f894 2176 	ldrb.w	r2, [r4, #374]	; 0x176
	    !conn->llcp_cu.pause_tx &&
   39b58:	0791      	lsls	r1, r2, #30
   39b5a:	d578      	bpl.n	39c4e <event_len_prep+0x176>
		if (!conn->tx_ctrl) {
   39b5c:	f8d4 21e0 	ldr.w	r2, [r4, #480]	; 0x1e0
   39b60:	2a00      	cmp	r2, #0
   39b62:	f000 8089 	beq.w	39c78 <event_len_prep+0x1a0>
	tx->next = conn->tx_ctrl_last->next;
   39b66:	f8d4 31e4 	ldr.w	r3, [r4, #484]	; 0x1e4
   39b6a:	681b      	ldr	r3, [r3, #0]
   39b6c:	6003      	str	r3, [r0, #0]
	conn->tx_ctrl_last->next = tx;
   39b6e:	f8d4 31e4 	ldr.w	r3, [r4, #484]	; 0x1e4
   39b72:	6018      	str	r0, [r3, #0]
	conn->tx_ctrl_last = tx;
   39b74:	f8c4 01e4 	str.w	r0, [r4, #484]	; 0x1e4
	if (!tx->next) {
   39b78:	6803      	ldr	r3, [r0, #0]
   39b7a:	2b00      	cmp	r3, #0
   39b7c:	d056      	beq.n	39c2c <event_len_prep+0x154>
		conn->procedure_expire = conn->procedure_reload;
   39b7e:	f8b4 30c6 	ldrh.w	r3, [r4, #198]	; 0xc6
   39b82:	f8a4 30c8 	strh.w	r3, [r4, #200]	; 0xc8
}
   39b86:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (conn->llcp_length.state == LLCP_LENGTH_STATE_RESIZE) {
   39b88:	f003 0207 	and.w	r2, r3, #7
		lll->max_rx_octets = conn->llcp_length.rx_octets;
   39b8c:	f8b0 01c8 	ldrh.w	r0, [r0, #456]	; 0x1c8
		lll->max_rx_time = conn->llcp_length.rx_time;
   39b90:	f8b4 11cc 	ldrh.w	r1, [r4, #460]	; 0x1cc
		tx_octets = conn->llcp_length.tx_octets;
   39b94:	f8b4 71ca 	ldrh.w	r7, [r4, #458]	; 0x1ca
		uint16_t tx_time = conn->llcp_length.tx_time;
   39b98:	f8b4 61ce 	ldrh.w	r6, [r4, #462]	; 0x1ce
		lll->max_rx_octets = conn->llcp_length.rx_octets;
   39b9c:	f8a4 005a 	strh.w	r0, [r4, #90]	; 0x5a
		if (conn->llcp_length.state == LLCP_LENGTH_STATE_RESIZE) {
   39ba0:	2a04      	cmp	r2, #4
		lll->max_rx_time = conn->llcp_length.rx_time;
   39ba2:	f8a4 105e 	strh.w	r1, [r4, #94]	; 0x5e
		if (conn->llcp_length.state == LLCP_LENGTH_STATE_RESIZE) {
   39ba6:	d028      	beq.n	39bfa <event_len_prep+0x122>
			conn->llcp_length.state =
   39ba8:	2206      	movs	r2, #6
   39baa:	f362 0302 	bfi	r3, r2, #0, #3
   39bae:	f884 31c6 	strb.w	r3, [r4, #454]	; 0x1c6
		rx = conn->llcp_rx;
   39bb2:	f8d4 5114 	ldr.w	r5, [r4, #276]	; 0x114
		LL_ASSERT(rx && rx->hdr.link);
   39bb6:	b355      	cbz	r5, 39c0e <event_len_prep+0x136>
   39bb8:	682b      	ldr	r3, [r5, #0]
   39bba:	b343      	cbz	r3, 39c0e <event_len_prep+0x136>
		conn->llcp_rx = rx->hdr.link->mem;
   39bbc:	685b      	ldr	r3, [r3, #4]
   39bbe:	f8c4 3114 	str.w	r3, [r4, #276]	; 0x114
		rx->hdr.handle = conn->lll.handle;
   39bc2:	8d23      	ldrh	r3, [r4, #40]	; 0x28
   39bc4:	80eb      	strh	r3, [r5, #6]
		rx->hdr.type = NODE_RX_TYPE_DC_PDU;
   39bc6:	2303      	movs	r3, #3
   39bc8:	712b      	strb	r3, [r5, #4]
		pdu_ctrl_rx->ll_id = PDU_DATA_LLID_CTRL;
   39bca:	7f2b      	ldrb	r3, [r5, #28]
		ll_rx_put(rx->hdr.link, rx);
   39bcc:	6828      	ldr	r0, [r5, #0]
		pdu_ctrl_rx->ll_id = PDU_DATA_LLID_CTRL;
   39bce:	f043 0303 	orr.w	r3, r3, #3
   39bd2:	772b      	strb	r3, [r5, #28]
		pdu_ctrl_rx->len =
   39bd4:	2309      	movs	r3, #9
   39bd6:	776b      	strb	r3, [r5, #29]
		pdu_ctrl_rx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_RSP;
   39bd8:	2315      	movs	r3, #21
   39bda:	77eb      	strb	r3, [r5, #31]
		lr->max_rx_octets = sys_cpu_to_le16(lll->max_rx_octets);
   39bdc:	f8b4 305a 	ldrh.w	r3, [r4, #90]	; 0x5a
   39be0:	842b      	strh	r3, [r5, #32]
		lr->max_tx_octets = sys_cpu_to_le16(tx_octets);
   39be2:	84af      	strh	r7, [r5, #36]	; 0x24
		lr->max_rx_time = sys_cpu_to_le16(lll->max_rx_time);
   39be4:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
   39be8:	846b      	strh	r3, [r5, #34]	; 0x22
		lr->max_tx_time = sys_cpu_to_le16(tx_time);
   39bea:	84ee      	strh	r6, [r5, #38]	; 0x26
		ll_rx_put(rx->hdr.link, rx);
   39bec:	4629      	mov	r1, r5
   39bee:	f7fe f8c9 	bl	37d84 <ll_rx_put>
}
   39bf2:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		ll_rx_sched();
   39bf6:	f7fe b8cf 	b.w	37d98 <ll_rx_sched>
			if (!conn->llcp_length.cache.tx_octets) {
   39bfa:	f8b4 21d0 	ldrh.w	r2, [r4, #464]	; 0x1d0
   39bfe:	b9c2      	cbnz	r2, 39c32 <event_len_prep+0x15a>
				conn->llcp_length.ack = conn->llcp_length.req;
   39c00:	f894 31c4 	ldrb.w	r3, [r4, #452]	; 0x1c4
   39c04:	f884 31c5 	strb.w	r3, [r4, #453]	; 0x1c5
				conn->procedure_expire = 0U;
   39c08:	f8a4 20c8 	strh.w	r2, [r4, #200]	; 0xc8
   39c0c:	e7d1      	b.n	39bb2 <event_len_prep+0xda>
		LL_ASSERT(rx && rx->hdr.link);
   39c0e:	4a2f      	ldr	r2, [pc, #188]	; (39ccc <event_len_prep+0x1f4>)
   39c10:	492f      	ldr	r1, [pc, #188]	; (39cd0 <event_len_prep+0x1f8>)
   39c12:	4830      	ldr	r0, [pc, #192]	; (39cd4 <event_len_prep+0x1fc>)
   39c14:	f241 13a4 	movw	r3, #4516	; 0x11a4
   39c18:	f00f fa34 	bl	49084 <assert_print>
   39c1c:	4040      	eors	r0, r0
   39c1e:	f380 8811 	msr	BASEPRI, r0
   39c22:	f04f 0003 	mov.w	r0, #3
   39c26:	df02      	svc	2
		conn->llcp_rx = rx->hdr.link->mem;
   39c28:	682b      	ldr	r3, [r5, #0]
   39c2a:	e7c7      	b.n	39bbc <event_len_prep+0xe4>
		conn->tx_data_last = tx;
   39c2c:	f8c4 01ec 	str.w	r0, [r4, #492]	; 0x1ec
   39c30:	e7a5      	b.n	39b7e <event_len_prep+0xa6>
				conn->llcp_length.tx_octets =
   39c32:	f8a4 21ca 	strh.w	r2, [r4, #458]	; 0x1ca
				conn->llcp_length.cache.tx_octets = 0U;
   39c36:	2200      	movs	r2, #0
				conn->llcp_length.state = LLCP_LENGTH_STATE_REQ;
   39c38:	f362 0302 	bfi	r3, r2, #0, #3
   39c3c:	f884 31c6 	strb.w	r3, [r4, #454]	; 0x1c6
				conn->llcp_length.tx_time =
   39c40:	f8b4 31d2 	ldrh.w	r3, [r4, #466]	; 0x1d2
				conn->llcp_length.cache.tx_octets = 0U;
   39c44:	f8a4 21d0 	strh.w	r2, [r4, #464]	; 0x1d0
				conn->llcp_length.tx_time =
   39c48:	f8a4 31ce 	strh.w	r3, [r4, #462]	; 0x1ce
				conn->llcp_length.state = LLCP_LENGTH_STATE_REQ;
   39c4c:	e7b1      	b.n	39bb2 <event_len_prep+0xda>
	    !conn->llcp_phy.pause_tx &&
   39c4e:	f894 21d7 	ldrb.w	r2, [r4, #471]	; 0x1d7
   39c52:	07d2      	lsls	r2, r2, #31
   39c54:	d482      	bmi.n	39b5c <event_len_prep+0x84>
		if (conn->tx_head == conn->tx_data) {
   39c56:	f8d4 21e8 	ldr.w	r2, [r4, #488]	; 0x1e8
		if (!conn->tx_ctrl) {
   39c5a:	f8d4 11e0 	ldr.w	r1, [r4, #480]	; 0x1e0
		if (conn->tx_head == conn->tx_data) {
   39c5e:	4293      	cmp	r3, r2
   39c60:	d010      	beq.n	39c84 <event_len_prep+0x1ac>
		} else if (!conn->tx_ctrl) {
   39c62:	2900      	cmp	r1, #0
   39c64:	f47f af7f 	bne.w	39b66 <event_len_prep+0x8e>
	if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   39c68:	791a      	ldrb	r2, [r3, #4]
   39c6a:	f002 0203 	and.w	r2, r2, #3
   39c6e:	2a03      	cmp	r2, #3
   39c70:	d016      	beq.n	39ca0 <event_len_prep+0x1c8>
		conn->tx_ctrl = conn->tx_ctrl_last = conn->tx_head;
   39c72:	e9c4 3378 	strd	r3, r3, [r4, #480]	; 0x1e0
   39c76:	e778      	b.n	39b6a <event_len_prep+0x92>
			tx->next = conn->tx_head;
   39c78:	6003      	str	r3, [r0, #0]
			conn->tx_head = tx;
   39c7a:	f8c4 01dc 	str.w	r0, [r4, #476]	; 0x1dc
   39c7e:	f8c4 01e0 	str.w	r0, [r4, #480]	; 0x1e0
				conn->tx_ctrl_last = tx;
   39c82:	e777      	b.n	39b74 <event_len_prep+0x9c>
			conn->tx_data = conn->tx_data->next;
   39c84:	681a      	ldr	r2, [r3, #0]
   39c86:	f8c4 21e8 	str.w	r2, [r4, #488]	; 0x1e8
		if (!conn->tx_ctrl) {
   39c8a:	2900      	cmp	r1, #0
   39c8c:	f47f af6b 	bne.w	39b66 <event_len_prep+0x8e>
			tx->next = conn->tx_head->next;
   39c90:	681b      	ldr	r3, [r3, #0]
   39c92:	6003      	str	r3, [r0, #0]
			conn->tx_head->next = tx;
   39c94:	f8d4 31dc 	ldr.w	r3, [r4, #476]	; 0x1dc
   39c98:	6018      	str	r0, [r3, #0]
				conn->tx_ctrl = tx;
   39c9a:	f8c4 01e0 	str.w	r0, [r4, #480]	; 0x1e0
				conn->tx_ctrl_last = tx;
   39c9e:	e769      	b.n	39b74 <event_len_prep+0x9c>
	    ((pdu_data_tx->llctrl.opcode !=
   39ca0:	79da      	ldrb	r2, [r3, #7]
	if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   39ca2:	2a03      	cmp	r2, #3
   39ca4:	d0f4      	beq.n	39c90 <event_len_prep+0x1b8>
	      PDU_DATA_LLCTRL_TYPE_ENC_REQ) &&
   39ca6:	2a0a      	cmp	r2, #10
   39ca8:	d1e3      	bne.n	39c72 <event_len_prep+0x19a>
   39caa:	e7f1      	b.n	39c90 <event_len_prep+0x1b8>
		LL_ASSERT(0);
   39cac:	4a07      	ldr	r2, [pc, #28]	; (39ccc <event_len_prep+0x1f4>)
   39cae:	490a      	ldr	r1, [pc, #40]	; (39cd8 <event_len_prep+0x200>)
   39cb0:	4808      	ldr	r0, [pc, #32]	; (39cd4 <event_len_prep+0x1fc>)
   39cb2:	f241 13ce 	movw	r3, #4558	; 0x11ce
   39cb6:	f00f f9e5 	bl	49084 <assert_print>
   39cba:	4040      	eors	r0, r0
   39cbc:	f380 8811 	msr	BASEPRI, r0
   39cc0:	f04f 0003 	mov.w	r0, #3
   39cc4:	df02      	svc	2
}
   39cc6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   39cc8:	20005384 	.word	0x20005384
   39ccc:	0005269c 	.word	0x0005269c
   39cd0:	00052768 	.word	0x00052768
   39cd4:	0005214c 	.word	0x0005214c
   39cd8:	000521ac 	.word	0x000521ac

00039cdc <event_phy_upd_ind_prep>:
{
   39cdc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	if (conn->llcp.phy_upd_ind.initiate) {
   39ce0:	f890 30f4 	ldrb.w	r3, [r0, #244]	; 0xf4
   39ce4:	f013 0601 	ands.w	r6, r3, #1
{
   39ce8:	4604      	mov	r4, r0
   39cea:	460d      	mov	r5, r1
	if (conn->llcp.phy_upd_ind.initiate) {
   39cec:	f040 8093 	bne.w	39e16 <event_phy_upd_ind_prep+0x13a>
	} else if (((event_counter - conn->llcp.phy_upd_ind.instant) &
   39cf0:	f8b0 10f6 	ldrh.w	r1, [r0, #246]	; 0xf6
   39cf4:	1a69      	subs	r1, r5, r1
   39cf6:	040a      	lsls	r2, r1, #16
   39cf8:	f100 8094 	bmi.w	39e24 <event_phy_upd_ind_prep+0x148>
		if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
   39cfc:	f990 1039 	ldrsb.w	r1, [r0, #57]	; 0x39
   39d00:	2900      	cmp	r1, #0
   39d02:	f2c0 8148 	blt.w	39f96 <event_phy_upd_ind_prep+0x2ba>
		rx = conn->llcp_rx;
   39d06:	f8d0 5114 	ldr.w	r5, [r0, #276]	; 0x114
   39d0a:	461a      	mov	r2, r3
			conn->llcp_ack = conn->llcp_req;
   39d0c:	f894 10f0 	ldrb.w	r1, [r4, #240]	; 0xf0
   39d10:	f884 10f1 	strb.w	r1, [r4, #241]	; 0xf1
		old_tx = lll->phy_tx;
   39d14:	f894 1060 	ldrb.w	r1, [r4, #96]	; 0x60
		old_rx = lll->phy_rx;
   39d18:	f894 8061 	ldrb.w	r8, [r4, #97]	; 0x61
		uint16_t eff_tx_time = lll->max_tx_time;
   39d1c:	f8b4 605c 	ldrh.w	r6, [r4, #92]	; 0x5c
		uint16_t eff_rx_time = lll->max_rx_time;
   39d20:	f8b4 705e 	ldrh.w	r7, [r4, #94]	; 0x5e
		if (conn->llcp.phy_upd_ind.tx) {
   39d24:	f013 0f1c 	tst.w	r3, #28
		old_rx = lll->phy_rx;
   39d28:	f008 0807 	and.w	r8, r8, #7
		old_tx = lll->phy_tx;
   39d2c:	f001 0907 	and.w	r9, r1, #7
		if (conn->llcp.phy_upd_ind.tx) {
   39d30:	d00a      	beq.n	39d48 <event_phy_upd_ind_prep+0x6c>
			if (conn->llcp.phy_upd_ind.tx & phy_bitmask) {
   39d32:	f013 0f0c 	tst.w	r3, #12
				lll->phy_tx = conn->llcp.phy_upd_ind.tx &
   39d36:	f3c3 0081 	ubfx	r0, r3, #2, #2
   39d3a:	bf1c      	itt	ne
   39d3c:	f360 0102 	bfine	r1, r0, #0, #3
   39d40:	f884 1060 	strbne.w	r1, [r4, #96]	; 0x60
			eff_tx_time = calc_eff_time(lll->max_tx_octets,
   39d44:	f44f 76a4 	mov.w	r6, #328	; 0x148
		if (conn->llcp.phy_upd_ind.rx) {
   39d48:	2b1f      	cmp	r3, #31
   39d4a:	d86d      	bhi.n	39e28 <event_phy_upd_ind_prep+0x14c>
		LL_ASSERT(rx && rx->hdr.link);
   39d4c:	2d00      	cmp	r5, #0
   39d4e:	f000 8102 	beq.w	39f56 <event_phy_upd_ind_prep+0x27a>
   39d52:	682b      	ldr	r3, [r5, #0]
   39d54:	2b00      	cmp	r3, #0
   39d56:	f000 80fe 	beq.w	39f56 <event_phy_upd_ind_prep+0x27a>
		conn->llcp_rx = rx->hdr.link->mem;
   39d5a:	685b      	ldr	r3, [r3, #4]
   39d5c:	f8c4 3114 	str.w	r3, [r4, #276]	; 0x114
		if (!conn->llcp.phy_upd_ind.cmd && (lll->phy_tx == old_tx) &&
   39d60:	0793      	lsls	r3, r2, #30
   39d62:	d406      	bmi.n	39d72 <event_phy_upd_ind_prep+0x96>
   39d64:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
   39d68:	f003 0307 	and.w	r3, r3, #7
   39d6c:	454b      	cmp	r3, r9
   39d6e:	f000 80cf 	beq.w	39f10 <event_phy_upd_ind_prep+0x234>
		rx->hdr.handle = lll->handle;
   39d72:	8d23      	ldrh	r3, [r4, #40]	; 0x28
   39d74:	80eb      	strh	r3, [r5, #6]
		rx->hdr.type = NODE_RX_TYPE_PHY_UPDATE;
   39d76:	231d      	movs	r3, #29
   39d78:	712b      	strb	r3, [r5, #4]
		upd->status = 0U;
   39d7a:	2300      	movs	r3, #0
   39d7c:	772b      	strb	r3, [r5, #28]
		upd->tx = lll->phy_tx;
   39d7e:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
		ll_rx_put(rx->hdr.link, rx);
   39d82:	6828      	ldr	r0, [r5, #0]
		upd->tx = lll->phy_tx;
   39d84:	f3c3 0302 	ubfx	r3, r3, #0, #3
   39d88:	776b      	strb	r3, [r5, #29]
		upd->rx = lll->phy_rx;
   39d8a:	f894 3061 	ldrb.w	r3, [r4, #97]	; 0x61
   39d8e:	f3c3 0302 	ubfx	r3, r3, #0, #3
   39d92:	77ab      	strb	r3, [r5, #30]
		ll_rx_put(rx->hdr.link, rx);
   39d94:	4629      	mov	r1, r5
   39d96:	f7fd fff5 	bl	37d84 <ll_rx_put>
		rx = conn->llcp_rx;
   39d9a:	f8d4 5114 	ldr.w	r5, [r4, #276]	; 0x114
		LL_ASSERT(rx && rx->hdr.link);
   39d9e:	2d00      	cmp	r5, #0
   39da0:	f000 80ea 	beq.w	39f78 <event_phy_upd_ind_prep+0x29c>
   39da4:	682b      	ldr	r3, [r5, #0]
   39da6:	2b00      	cmp	r3, #0
   39da8:	f000 80e6 	beq.w	39f78 <event_phy_upd_ind_prep+0x29c>
		conn->llcp_rx = rx->hdr.link->mem;
   39dac:	685b      	ldr	r3, [r3, #4]
   39dae:	f8c4 3114 	str.w	r3, [r4, #276]	; 0x114
		if ((eff_tx_time <= lll->max_tx_time) &&
   39db2:	f8b4 305c 	ldrh.w	r3, [r4, #92]	; 0x5c
   39db6:	42b3      	cmp	r3, r6
   39db8:	d30a      	bcc.n	39dd0 <event_phy_upd_ind_prep+0xf4>
   39dba:	f5b3 7fa4 	cmp.w	r3, #328	; 0x148
   39dbe:	d807      	bhi.n	39dd0 <event_phy_upd_ind_prep+0xf4>
		    (eff_rx_time <= lll->max_rx_time) &&
   39dc0:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
		    (lll->max_tx_time <= max_tx_time) &&
   39dc4:	42bb      	cmp	r3, r7
   39dc6:	d303      	bcc.n	39dd0 <event_phy_upd_ind_prep+0xf4>
		    (eff_rx_time <= lll->max_rx_time) &&
   39dc8:	f5b3 7fa4 	cmp.w	r3, #328	; 0x148
   39dcc:	f240 80b9 	bls.w	39f42 <event_phy_upd_ind_prep+0x266>
		lll->max_tx_time = eff_tx_time;
   39dd0:	f8a4 605c 	strh.w	r6, [r4, #92]	; 0x5c
		lll->max_rx_time = eff_rx_time;
   39dd4:	f8a4 705e 	strh.w	r7, [r4, #94]	; 0x5e
		pdu_rx->ll_id = PDU_DATA_LLID_CTRL;
   39dd8:	7f2b      	ldrb	r3, [r5, #28]
		rx->hdr.handle = lll->handle;
   39dda:	8d21      	ldrh	r1, [r4, #40]	; 0x28
   39ddc:	80e9      	strh	r1, [r5, #6]
		rx->hdr.type = NODE_RX_TYPE_DC_PDU;
   39dde:	2203      	movs	r2, #3
   39de0:	712a      	strb	r2, [r5, #4]
		pdu_rx->ll_id = PDU_DATA_LLID_CTRL;
   39de2:	4313      	orrs	r3, r2
		pdu_rx->len = offsetof(struct pdu_data_llctrl, length_rsp) +
   39de4:	2109      	movs	r1, #9
		pdu_rx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_RSP;
   39de6:	2215      	movs	r2, #21
		pdu_rx->len = offsetof(struct pdu_data_llctrl, length_rsp) +
   39de8:	7769      	strb	r1, [r5, #29]
		pdu_rx->ll_id = PDU_DATA_LLID_CTRL;
   39dea:	772b      	strb	r3, [r5, #28]
		pdu_rx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_RSP;
   39dec:	77ea      	strb	r2, [r5, #31]
		lr->max_rx_octets = sys_cpu_to_le16(lll->max_rx_octets);
   39dee:	f8b4 305a 	ldrh.w	r3, [r4, #90]	; 0x5a
   39df2:	842b      	strh	r3, [r5, #32]
		lr->max_tx_octets = sys_cpu_to_le16(lll->max_tx_octets);
   39df4:	f8b4 3058 	ldrh.w	r3, [r4, #88]	; 0x58
   39df8:	84ab      	strh	r3, [r5, #36]	; 0x24
		lr->max_rx_time = sys_cpu_to_le16(lll->max_rx_time);
   39dfa:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
   39dfe:	846b      	strh	r3, [r5, #34]	; 0x22
		lr->max_tx_time = sys_cpu_to_le16(lll->max_tx_time);
   39e00:	f8b4 305c 	ldrh.w	r3, [r4, #92]	; 0x5c
		ll_rx_put(rx->hdr.link, rx);
   39e04:	6828      	ldr	r0, [r5, #0]
		lr->max_tx_time = sys_cpu_to_le16(lll->max_tx_time);
   39e06:	84eb      	strh	r3, [r5, #38]	; 0x26
		ll_rx_put(rx->hdr.link, rx);
   39e08:	4629      	mov	r1, r5
   39e0a:	f7fd ffbb 	bl	37d84 <ll_rx_put>
}
   39e0e:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
			ll_rx_sched();
   39e12:	f7fd bfc1 	b.w	37d98 <ll_rx_sched>
		if (memq_peek(conn->lll.memq_tx.head, conn->lll.memq_tx.tail,
   39e16:	e9d0 0119 	ldrd	r0, r1, [r0, #100]	; 0x64
   39e1a:	2200      	movs	r2, #0
   39e1c:	f7fa fbbc 	bl	34598 <memq_peek>
   39e20:	4606      	mov	r6, r0
   39e22:	b178      	cbz	r0, 39e44 <event_phy_upd_ind_prep+0x168>
}
   39e24:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			if (conn->llcp.phy_upd_ind.rx & phy_bitmask) {
   39e28:	f013 0f60 	tst.w	r3, #96	; 0x60
   39e2c:	f3c3 1141 	ubfx	r1, r3, #5, #2
   39e30:	d005      	beq.n	39e3e <event_phy_upd_ind_prep+0x162>
				lll->phy_rx = conn->llcp.phy_upd_ind.rx &
   39e32:	f894 3061 	ldrb.w	r3, [r4, #97]	; 0x61
   39e36:	f361 0302 	bfi	r3, r1, #0, #3
   39e3a:	f884 3061 	strb.w	r3, [r4, #97]	; 0x61
				calc_eff_time(lll->max_rx_octets, lll->phy_rx,
   39e3e:	f44f 77a4 	mov.w	r7, #328	; 0x148
   39e42:	e783      	b.n	39d4c <event_phy_upd_ind_prep+0x70>
		rx = ll_pdu_rx_alloc_peek(2);
   39e44:	2002      	movs	r0, #2
   39e46:	f7fd ffad 	bl	37da4 <ll_pdu_rx_alloc_peek>
		if (!rx) {
   39e4a:	4680      	mov	r8, r0
   39e4c:	2800      	cmp	r0, #0
   39e4e:	d0e9      	beq.n	39e24 <event_phy_upd_ind_prep+0x148>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
   39e50:	4894      	ldr	r0, [pc, #592]	; (3a0a4 <event_phy_upd_ind_prep+0x3c8>)
   39e52:	f7fa fb31 	bl	344b8 <mem_acquire>
		if (!tx) {
   39e56:	4607      	mov	r7, r0
   39e58:	2800      	cmp	r0, #0
   39e5a:	d0e3      	beq.n	39e24 <event_phy_upd_ind_prep+0x148>
		conn->llcp.phy_upd_ind.initiate = 0U;
   39e5c:	f894 30f4 	ldrb.w	r3, [r4, #244]	; 0xf4
   39e60:	f366 0300 	bfi	r3, r6, #0, #1
		       conn->llcp.phy_upd_ind.rx) & 0x07)) {
   39e64:	f3c3 1242 	ubfx	r2, r3, #5, #3
		if (!((conn->llcp.phy_upd_ind.tx |
   39e68:	ea42 0293 	orr.w	r2, r2, r3, lsr #2
   39e6c:	f012 0607 	ands.w	r6, r2, #7
		conn->llcp.phy_upd_ind.initiate = 0U;
   39e70:	f884 30f4 	strb.w	r3, [r4, #244]	; 0xf4
		if (!((conn->llcp.phy_upd_ind.tx |
   39e74:	b2db      	uxtb	r3, r3
   39e76:	f040 80aa 	bne.w	39fce <event_phy_upd_ind_prep+0x2f2>
			conn->llcp_ack = conn->llcp_req;
   39e7a:	f894 20f0 	ldrb.w	r2, [r4, #240]	; 0xf0
			conn->llcp.phy_upd_ind.instant = 0U;
   39e7e:	f8a4 60f6 	strh.w	r6, [r4, #246]	; 0xf6
			if (conn->llcp.phy_upd_ind.cmd) {
   39e82:	079b      	lsls	r3, r3, #30
			conn->llcp_ack = conn->llcp_req;
   39e84:	f884 20f1 	strb.w	r2, [r4, #241]	; 0xf1
			if (conn->llcp.phy_upd_ind.cmd) {
   39e88:	f100 80c3 	bmi.w	3a012 <event_phy_upd_ind_prep+0x336>
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   39e8c:	793b      	ldrb	r3, [r7, #4]
		pdu_ctrl_tx->len =
   39e8e:	2105      	movs	r1, #5
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   39e90:	f043 0303 	orr.w	r3, r3, #3
		pdu_ctrl_tx->llctrl.opcode =
   39e94:	2218      	movs	r2, #24
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   39e96:	713b      	strb	r3, [r7, #4]
		pdu_ctrl_tx->len =
   39e98:	7179      	strb	r1, [r7, #5]
		pdu_ctrl_tx->llctrl.opcode =
   39e9a:	71fa      	strb	r2, [r7, #7]
		ind->c_to_p_phy = conn->llcp.phy_upd_ind.tx;
   39e9c:	f894 30f4 	ldrb.w	r3, [r4, #244]	; 0xf4
   39ea0:	f3c3 0382 	ubfx	r3, r3, #2, #3
   39ea4:	723b      	strb	r3, [r7, #8]
		ind->p_to_c_phy = conn->llcp.phy_upd_ind.rx;
   39ea6:	f894 30f4 	ldrb.w	r3, [r4, #244]	; 0xf4
   39eaa:	f3c3 1342 	ubfx	r3, r3, #5, #3
   39eae:	727b      	strb	r3, [r7, #9]
		ind->instant = sys_cpu_to_le16(conn->llcp.phy_upd_ind.instant);
   39eb0:	f8b4 30f6 	ldrh.w	r3, [r4, #246]	; 0xf6
   39eb4:	817b      	strh	r3, [r7, #10]
	    conn->tx_head &&
   39eb6:	f8d4 31dc 	ldr.w	r3, [r4, #476]	; 0x1dc
	if (
   39eba:	2b00      	cmp	r3, #0
   39ebc:	f000 809e 	beq.w	39ffc <event_phy_upd_ind_prep+0x320>
	    !conn->llcp_cu.pause_tx &&
   39ec0:	f894 211a 	ldrb.w	r2, [r4, #282]	; 0x11a
	    conn->tx_head &&
   39ec4:	06d5      	lsls	r5, r2, #27
   39ec6:	f100 8099 	bmi.w	39ffc <event_phy_upd_ind_prep+0x320>
	    !conn->llcp_enc.pause_tx &&
   39eca:	f894 2176 	ldrb.w	r2, [r4, #374]	; 0x176
	    !conn->llcp_cu.pause_tx &&
   39ece:	0790      	lsls	r0, r2, #30
   39ed0:	f100 8094 	bmi.w	39ffc <event_phy_upd_ind_prep+0x320>
	    !conn->llcp_phy.pause_tx &&
   39ed4:	f894 21d7 	ldrb.w	r2, [r4, #471]	; 0x1d7
   39ed8:	07d1      	lsls	r1, r2, #31
   39eda:	f100 808f 	bmi.w	39ffc <event_phy_upd_ind_prep+0x320>
		if (conn->tx_head == conn->tx_data) {
   39ede:	f8d4 11e8 	ldr.w	r1, [r4, #488]	; 0x1e8
		if (!conn->tx_ctrl) {
   39ee2:	f8d4 21e0 	ldr.w	r2, [r4, #480]	; 0x1e0
		if (conn->tx_head == conn->tx_data) {
   39ee6:	428b      	cmp	r3, r1
   39ee8:	f000 80c0 	beq.w	3a06c <event_phy_upd_ind_prep+0x390>
		} else if (!conn->tx_ctrl) {
   39eec:	2a00      	cmp	r2, #0
   39eee:	f000 80cb 	beq.w	3a088 <event_phy_upd_ind_prep+0x3ac>
	tx->next = conn->tx_ctrl_last->next;
   39ef2:	f8d4 31e4 	ldr.w	r3, [r4, #484]	; 0x1e4
   39ef6:	681b      	ldr	r3, [r3, #0]
   39ef8:	603b      	str	r3, [r7, #0]
	conn->tx_ctrl_last->next = tx;
   39efa:	f8d4 31e4 	ldr.w	r3, [r4, #484]	; 0x1e4
   39efe:	601f      	str	r7, [r3, #0]
	conn->tx_ctrl_last = tx;
   39f00:	f8c4 71e4 	str.w	r7, [r4, #484]	; 0x1e4
	if (!tx->next) {
   39f04:	683b      	ldr	r3, [r7, #0]
   39f06:	2b00      	cmp	r3, #0
   39f08:	d18c      	bne.n	39e24 <event_phy_upd_ind_prep+0x148>
		conn->tx_data_last = tx;
   39f0a:	f8c4 71ec 	str.w	r7, [r4, #492]	; 0x1ec
   39f0e:	e789      	b.n	39e24 <event_phy_upd_ind_prep+0x148>
		    (lll->phy_rx == old_rx)) {
   39f10:	f894 3061 	ldrb.w	r3, [r4, #97]	; 0x61
		if (!conn->llcp.phy_upd_ind.cmd && (lll->phy_tx == old_tx) &&
   39f14:	f003 0307 	and.w	r3, r3, #7
   39f18:	4543      	cmp	r3, r8
   39f1a:	f47f af2a 	bne.w	39d72 <event_phy_upd_ind_prep+0x96>
			rx->hdr.type = NODE_RX_TYPE_RELEASE;
   39f1e:	2301      	movs	r3, #1
			ll_rx_put(rx->hdr.link, rx);
   39f20:	6828      	ldr	r0, [r5, #0]
			rx->hdr.type = NODE_RX_TYPE_RELEASE;
   39f22:	712b      	strb	r3, [r5, #4]
			ll_rx_put(rx->hdr.link, rx);
   39f24:	4629      	mov	r1, r5
   39f26:	f7fd ff2d 	bl	37d84 <ll_rx_put>
				rx = conn->llcp_rx;
   39f2a:	f8d4 5114 	ldr.w	r5, [r4, #276]	; 0x114
				LL_ASSERT(rx && rx->hdr.link);
   39f2e:	2d00      	cmp	r5, #0
   39f30:	f000 808d 	beq.w	3a04e <event_phy_upd_ind_prep+0x372>
   39f34:	682b      	ldr	r3, [r5, #0]
   39f36:	2b00      	cmp	r3, #0
   39f38:	f000 8089 	beq.w	3a04e <event_phy_upd_ind_prep+0x372>
				conn->llcp_rx = rx->hdr.link->mem;
   39f3c:	685b      	ldr	r3, [r3, #4]
   39f3e:	f8c4 3114 	str.w	r3, [r4, #276]	; 0x114
			rx->hdr.type = NODE_RX_TYPE_RELEASE;
   39f42:	2301      	movs	r3, #1
			ll_rx_put(rx->hdr.link, rx);
   39f44:	6828      	ldr	r0, [r5, #0]
			rx->hdr.type = NODE_RX_TYPE_RELEASE;
   39f46:	712b      	strb	r3, [r5, #4]
			ll_rx_put(rx->hdr.link, rx);
   39f48:	4629      	mov	r1, r5
   39f4a:	f7fd ff1b 	bl	37d84 <ll_rx_put>
}
   39f4e:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
			ll_rx_sched();
   39f52:	f7fd bf21 	b.w	37d98 <ll_rx_sched>
		LL_ASSERT(rx && rx->hdr.link);
   39f56:	4a54      	ldr	r2, [pc, #336]	; (3a0a8 <event_phy_upd_ind_prep+0x3cc>)
   39f58:	4954      	ldr	r1, [pc, #336]	; (3a0ac <event_phy_upd_ind_prep+0x3d0>)
   39f5a:	4855      	ldr	r0, [pc, #340]	; (3a0b0 <event_phy_upd_ind_prep+0x3d4>)
   39f5c:	f241 3310 	movw	r3, #4880	; 0x1310
   39f60:	f00f f890 	bl	49084 <assert_print>
   39f64:	4040      	eors	r0, r0
   39f66:	f380 8811 	msr	BASEPRI, r0
   39f6a:	f04f 0003 	mov.w	r0, #3
   39f6e:	df02      	svc	2
		conn->llcp_rx = rx->hdr.link->mem;
   39f70:	682b      	ldr	r3, [r5, #0]
		if (!conn->llcp.phy_upd_ind.cmd && (lll->phy_tx == old_tx) &&
   39f72:	f894 20f4 	ldrb.w	r2, [r4, #244]	; 0xf4
   39f76:	e6f0      	b.n	39d5a <event_phy_upd_ind_prep+0x7e>
		LL_ASSERT(rx && rx->hdr.link);
   39f78:	4a4b      	ldr	r2, [pc, #300]	; (3a0a8 <event_phy_upd_ind_prep+0x3cc>)
   39f7a:	494c      	ldr	r1, [pc, #304]	; (3a0ac <event_phy_upd_ind_prep+0x3d0>)
   39f7c:	484c      	ldr	r0, [pc, #304]	; (3a0b0 <event_phy_upd_ind_prep+0x3d4>)
   39f7e:	f241 3344 	movw	r3, #4932	; 0x1344
   39f82:	f00f f87f 	bl	49084 <assert_print>
   39f86:	4040      	eors	r0, r0
   39f88:	f380 8811 	msr	BASEPRI, r0
   39f8c:	f04f 0003 	mov.w	r0, #3
   39f90:	df02      	svc	2
		conn->llcp_rx = rx->hdr.link->mem;
   39f92:	682b      	ldr	r3, [r5, #0]
   39f94:	e70a      	b.n	39dac <event_phy_upd_ind_prep+0xd0>
			rx = ll_pdu_rx_alloc();
   39f96:	f7fd ff27 	bl	37de8 <ll_pdu_rx_alloc>
			if (!rx) {
   39f9a:	4605      	mov	r5, r0
   39f9c:	2800      	cmp	r0, #0
   39f9e:	f43f af41 	beq.w	39e24 <event_phy_upd_ind_prep+0x148>
			rx->hdr.link->mem = conn->llcp_rx;
   39fa2:	6803      	ldr	r3, [r0, #0]
   39fa4:	f8d4 2114 	ldr.w	r2, [r4, #276]	; 0x114
   39fa8:	605a      	str	r2, [r3, #4]
		if (conn->lll.role && (conn->periph.llcp_type != LLCP_NONE)) {
   39faa:	f994 3039 	ldrsb.w	r3, [r4, #57]	; 0x39
			conn->llcp_rx = rx;
   39fae:	f8c4 0114 	str.w	r0, [r4, #276]	; 0x114
		if (conn->lll.role && (conn->periph.llcp_type != LLCP_NONE)) {
   39fb2:	2b00      	cmp	r3, #0
		if (conn->llcp.phy_upd_ind.tx) {
   39fb4:	f894 30f4 	ldrb.w	r3, [r4, #244]	; 0xf4
   39fb8:	461a      	mov	r2, r3
		if (conn->lll.role && (conn->periph.llcp_type != LLCP_NONE)) {
   39fba:	f6bf aea7 	bge.w	39d0c <event_phy_upd_ind_prep+0x30>
   39fbe:	f894 10e5 	ldrb.w	r1, [r4, #229]	; 0xe5
   39fc2:	2900      	cmp	r1, #0
   39fc4:	f43f aea2 	beq.w	39d0c <event_phy_upd_ind_prep+0x30>
			conn->periph.llcp_type = LLCP_NONE;
   39fc8:	f884 60e5 	strb.w	r6, [r4, #229]	; 0xe5
   39fcc:	e6a2      	b.n	39d14 <event_phy_upd_ind_prep+0x38>
							 lll->latency +
   39fce:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
   39fd0:	1da9      	adds	r1, r5, #6
   39fd2:	4419      	add	r1, r3
			conn->llcp.phy_upd_ind.instant = event_counter +
   39fd4:	f8a4 10f6 	strh.w	r1, [r4, #246]	; 0xf6
			(void)ll_pdu_rx_alloc();
   39fd8:	f7fd ff06 	bl	37de8 <ll_pdu_rx_alloc>
			rx->hdr.link->mem = conn->llcp_rx;
   39fdc:	f8d8 3000 	ldr.w	r3, [r8]
   39fe0:	f8d4 2114 	ldr.w	r2, [r4, #276]	; 0x114
   39fe4:	605a      	str	r2, [r3, #4]
			conn->llcp_rx = rx;
   39fe6:	f8c4 8114 	str.w	r8, [r4, #276]	; 0x114
				rx = ll_pdu_rx_alloc();
   39fea:	f7fd fefd 	bl	37de8 <ll_pdu_rx_alloc>
				rx->hdr.link->mem = conn->llcp_rx;
   39fee:	6803      	ldr	r3, [r0, #0]
   39ff0:	f8d4 2114 	ldr.w	r2, [r4, #276]	; 0x114
   39ff4:	605a      	str	r2, [r3, #4]
				conn->llcp_rx = rx;
   39ff6:	f8c4 0114 	str.w	r0, [r4, #276]	; 0x114
   39ffa:	e747      	b.n	39e8c <event_phy_upd_ind_prep+0x1b0>
		if (!conn->tx_ctrl) {
   39ffc:	f8d4 21e0 	ldr.w	r2, [r4, #480]	; 0x1e0
   3a000:	2a00      	cmp	r2, #0
   3a002:	f47f af76 	bne.w	39ef2 <event_phy_upd_ind_prep+0x216>
			tx->next = conn->tx_head;
   3a006:	603b      	str	r3, [r7, #0]
			conn->tx_head = tx;
   3a008:	f8c4 71dc 	str.w	r7, [r4, #476]	; 0x1dc
   3a00c:	f8c4 71e0 	str.w	r7, [r4, #480]	; 0x1e0
				conn->tx_ctrl_last = tx;
   3a010:	e776      	b.n	39f00 <event_phy_upd_ind_prep+0x224>
				(void)ll_pdu_rx_alloc();
   3a012:	f7fd fee9 	bl	37de8 <ll_pdu_rx_alloc>
				rx->hdr.handle = lll->handle;
   3a016:	8d23      	ldrh	r3, [r4, #40]	; 0x28
   3a018:	f8a8 3006 	strh.w	r3, [r8, #6]
				rx->hdr.type = NODE_RX_TYPE_PHY_UPDATE;
   3a01c:	231d      	movs	r3, #29
   3a01e:	f888 3004 	strb.w	r3, [r8, #4]
				upd->status = 0U;
   3a022:	f888 601c 	strb.w	r6, [r8, #28]
				upd->tx = lll->phy_tx;
   3a026:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
				ll_rx_put(rx->hdr.link, rx);
   3a02a:	f8d8 0000 	ldr.w	r0, [r8]
				upd->tx = lll->phy_tx;
   3a02e:	f3c3 0302 	ubfx	r3, r3, #0, #3
   3a032:	f888 301d 	strb.w	r3, [r8, #29]
				upd->rx = lll->phy_rx;
   3a036:	f894 3061 	ldrb.w	r3, [r4, #97]	; 0x61
   3a03a:	f3c3 0302 	ubfx	r3, r3, #0, #3
   3a03e:	f888 301e 	strb.w	r3, [r8, #30]
				ll_rx_put(rx->hdr.link, rx);
   3a042:	4641      	mov	r1, r8
   3a044:	f7fd fe9e 	bl	37d84 <ll_rx_put>
				ll_rx_sched();
   3a048:	f7fd fea6 	bl	37d98 <ll_rx_sched>
   3a04c:	e71e      	b.n	39e8c <event_phy_upd_ind_prep+0x1b0>
				LL_ASSERT(rx && rx->hdr.link);
   3a04e:	4a16      	ldr	r2, [pc, #88]	; (3a0a8 <event_phy_upd_ind_prep+0x3cc>)
   3a050:	4916      	ldr	r1, [pc, #88]	; (3a0ac <event_phy_upd_ind_prep+0x3d0>)
   3a052:	4817      	ldr	r0, [pc, #92]	; (3a0b0 <event_phy_upd_ind_prep+0x3d4>)
   3a054:	f241 3322 	movw	r3, #4898	; 0x1322
   3a058:	f00f f814 	bl	49084 <assert_print>
   3a05c:	4040      	eors	r0, r0
   3a05e:	f380 8811 	msr	BASEPRI, r0
   3a062:	f04f 0003 	mov.w	r0, #3
   3a066:	df02      	svc	2
				conn->llcp_rx = rx->hdr.link->mem;
   3a068:	682b      	ldr	r3, [r5, #0]
   3a06a:	e767      	b.n	39f3c <event_phy_upd_ind_prep+0x260>
			conn->tx_data = conn->tx_data->next;
   3a06c:	6819      	ldr	r1, [r3, #0]
   3a06e:	f8c4 11e8 	str.w	r1, [r4, #488]	; 0x1e8
		if (!conn->tx_ctrl) {
   3a072:	2a00      	cmp	r2, #0
   3a074:	f47f af3d 	bne.w	39ef2 <event_phy_upd_ind_prep+0x216>
			tx->next = conn->tx_head->next;
   3a078:	681b      	ldr	r3, [r3, #0]
   3a07a:	603b      	str	r3, [r7, #0]
			conn->tx_head->next = tx;
   3a07c:	f8d4 31dc 	ldr.w	r3, [r4, #476]	; 0x1dc
   3a080:	601f      	str	r7, [r3, #0]
				conn->tx_ctrl = tx;
   3a082:	f8c4 71e0 	str.w	r7, [r4, #480]	; 0x1e0
				conn->tx_ctrl_last = tx;
   3a086:	e73b      	b.n	39f00 <event_phy_upd_ind_prep+0x224>
	if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   3a088:	791a      	ldrb	r2, [r3, #4]
   3a08a:	f002 0203 	and.w	r2, r2, #3
   3a08e:	2a03      	cmp	r2, #3
   3a090:	d002      	beq.n	3a098 <event_phy_upd_ind_prep+0x3bc>
		conn->tx_ctrl = conn->tx_ctrl_last = conn->tx_head;
   3a092:	e9c4 3378 	strd	r3, r3, [r4, #480]	; 0x1e0
   3a096:	e72c      	b.n	39ef2 <event_phy_upd_ind_prep+0x216>
	    ((pdu_data_tx->llctrl.opcode !=
   3a098:	79da      	ldrb	r2, [r3, #7]
	if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   3a09a:	2a03      	cmp	r2, #3
   3a09c:	d0ec      	beq.n	3a078 <event_phy_upd_ind_prep+0x39c>
	      PDU_DATA_LLCTRL_TYPE_ENC_REQ) &&
   3a09e:	2a0a      	cmp	r2, #10
   3a0a0:	d1f7      	bne.n	3a092 <event_phy_upd_ind_prep+0x3b6>
   3a0a2:	e7e9      	b.n	3a078 <event_phy_upd_ind_prep+0x39c>
   3a0a4:	20005384 	.word	0x20005384
   3a0a8:	0005269c 	.word	0x0005269c
   3a0ac:	00052768 	.word	0x00052768
   3a0b0:	0005214c 	.word	0x0005214c

0003a0b4 <ll_conn_acquire>:
	return mem_acquire(&conn_free);
   3a0b4:	4801      	ldr	r0, [pc, #4]	; (3a0bc <ll_conn_acquire+0x8>)
   3a0b6:	f7fa b9ff 	b.w	344b8 <mem_acquire>
   3a0ba:	bf00      	nop
   3a0bc:	20005274 	.word	0x20005274

0003a0c0 <ll_conn_release>:
	mem_release(conn, &conn_free);
   3a0c0:	4901      	ldr	r1, [pc, #4]	; (3a0c8 <ll_conn_release+0x8>)
   3a0c2:	f7fa ba15 	b.w	344f0 <mem_release>
   3a0c6:	bf00      	nop
   3a0c8:	20005274 	.word	0x20005274

0003a0cc <ll_conn_handle_get>:
	return mem_index_get(conn, conn_pool, sizeof(struct ll_conn));
   3a0cc:	4902      	ldr	r1, [pc, #8]	; (3a0d8 <ll_conn_handle_get+0xc>)
   3a0ce:	f44f 72fc 	mov.w	r2, #504	; 0x1f8
   3a0d2:	f7fa ba29 	b.w	34528 <mem_index_get>
   3a0d6:	bf00      	nop
   3a0d8:	200028e8 	.word	0x200028e8

0003a0dc <ll_conn_get>:
{
   3a0dc:	4602      	mov	r2, r0
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
   3a0de:	f44f 71fc 	mov.w	r1, #504	; 0x1f8
   3a0e2:	4801      	ldr	r0, [pc, #4]	; (3a0e8 <ll_conn_get+0xc>)
   3a0e4:	f7fa ba1c 	b.w	34520 <mem_get>
   3a0e8:	200028e8 	.word	0x200028e8

0003a0ec <ll_connected_get>:
	if (handle >= CONFIG_BT_MAX_CONN) {
   3a0ec:	2805      	cmp	r0, #5
   3a0ee:	d80d      	bhi.n	3a10c <ll_connected_get+0x20>
{
   3a0f0:	b510      	push	{r4, lr}
   3a0f2:	4604      	mov	r4, r0
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
   3a0f4:	4622      	mov	r2, r4
   3a0f6:	4806      	ldr	r0, [pc, #24]	; (3a110 <ll_connected_get+0x24>)
   3a0f8:	f44f 71fc 	mov.w	r1, #504	; 0x1f8
   3a0fc:	f7fa fa10 	bl	34520 <mem_get>
	if (conn->lll.handle != handle) {
   3a100:	8d03      	ldrh	r3, [r0, #40]	; 0x28
   3a102:	42a3      	cmp	r3, r4
   3a104:	d100      	bne.n	3a108 <ll_connected_get+0x1c>
}
   3a106:	bd10      	pop	{r4, pc}
		return NULL;
   3a108:	2000      	movs	r0, #0
}
   3a10a:	bd10      	pop	{r4, pc}
		return NULL;
   3a10c:	2000      	movs	r0, #0
}
   3a10e:	4770      	bx	lr
   3a110:	200028e8 	.word	0x200028e8

0003a114 <ll_tx_mem_acquire>:
	return mem_acquire(&mem_conn_tx.free);
   3a114:	4801      	ldr	r0, [pc, #4]	; (3a11c <ll_tx_mem_acquire+0x8>)
   3a116:	f7fa b9cf 	b.w	344b8 <mem_acquire>
   3a11a:	bf00      	nop
   3a11c:	200057a8 	.word	0x200057a8

0003a120 <ll_tx_mem_release>:
	mem_release(tx, &mem_conn_tx.free);
   3a120:	4901      	ldr	r1, [pc, #4]	; (3a128 <ll_tx_mem_release+0x8>)
   3a122:	f7fa b9e5 	b.w	344f0 <mem_release>
   3a126:	bf00      	nop
   3a128:	200057a8 	.word	0x200057a8

0003a12c <ll_tx_mem_enqueue>:
	if (handle >= CONFIG_BT_MAX_CONN) {
   3a12c:	2805      	cmp	r0, #5
   3a12e:	d842      	bhi.n	3a1b6 <ll_tx_mem_enqueue+0x8a>
{
   3a130:	b570      	push	{r4, r5, r6, lr}
   3a132:	4604      	mov	r4, r0
   3a134:	460e      	mov	r6, r1
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
   3a136:	4821      	ldr	r0, [pc, #132]	; (3a1bc <ll_tx_mem_enqueue+0x90>)
   3a138:	4622      	mov	r2, r4
   3a13a:	f44f 71fc 	mov.w	r1, #504	; 0x1f8
   3a13e:	f7fa f9ef 	bl	34520 <mem_get>
	if (conn->lll.handle != handle) {
   3a142:	8d03      	ldrh	r3, [r0, #40]	; 0x28
   3a144:	42a3      	cmp	r3, r4
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
   3a146:	4605      	mov	r5, r0
	if (conn->lll.handle != handle) {
   3a148:	d11f      	bne.n	3a18a <ll_tx_mem_enqueue+0x5e>
	idx = MFIFO_ENQUEUE_GET(conn_tx, (void **) &lll_tx);
   3a14a:	4a1d      	ldr	r2, [pc, #116]	; (3a1c0 <ll_tx_mem_enqueue+0x94>)
   3a14c:	f892 c005 	ldrb.w	ip, [r2, #5]
	if (last == count) {
   3a150:	7891      	ldrb	r1, [r2, #2]
   3a152:	7810      	ldrb	r0, [r2, #0]
	last = last + 1;
   3a154:	f10c 0301 	add.w	r3, ip, #1
   3a158:	b2db      	uxtb	r3, r3
		last = 0U;
   3a15a:	4299      	cmp	r1, r3
   3a15c:	bf08      	it	eq
   3a15e:	2300      	moveq	r3, #0
   3a160:	7911      	ldrb	r1, [r2, #4]
	if (last == first) {
   3a162:	4299      	cmp	r1, r3
   3a164:	d024      	beq.n	3a1b0 <ll_tx_mem_enqueue+0x84>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
   3a166:	fb1c fc00 	smulbb	ip, ip, r0
   3a16a:	f102 0108 	add.w	r1, r2, #8
	lll_tx->handle = handle;
   3a16e:	f821 400c 	strh.w	r4, [r1, ip]
   3a172:	448c      	add	ip, r1
	lll_tx->node = tx;
   3a174:	f8cc 6004 	str.w	r6, [ip, #4]
	*last = idx; /* Commit: Update write index */
   3a178:	7153      	strb	r3, [r2, #5]
   3a17a:	782b      	ldrb	r3, [r5, #0]
	if (ull_ref_get(&conn->ull)) {
   3a17c:	b943      	cbnz	r3, 3a190 <ll_tx_mem_enqueue+0x64>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn->lll.role) {
   3a17e:	f995 3039 	ldrsb.w	r3, [r5, #57]	; 0x39
   3a182:	2b00      	cmp	r3, #0
   3a184:	db0f      	blt.n	3a1a6 <ll_tx_mem_enqueue+0x7a>
	return 0;
   3a186:	2000      	movs	r0, #0
}
   3a188:	bd70      	pop	{r4, r5, r6, pc}
		return -EINVAL;
   3a18a:	f06f 0015 	mvn.w	r0, #21
}
   3a18e:	bd70      	pop	{r4, r5, r6, pc}
	mfy.param = conn;
   3a190:	4b0c      	ldr	r3, [pc, #48]	; (3a1c4 <ll_tx_mem_enqueue+0x98>)
	mayfly_enqueue(TICKER_USER_ID_THREAD, TICKER_USER_ID_ULL_HIGH, 0U, &mfy);
   3a192:	2200      	movs	r2, #0
   3a194:	2101      	movs	r1, #1
   3a196:	2003      	movs	r0, #3
	mfy.param = conn;
   3a198:	609d      	str	r5, [r3, #8]
	mayfly_enqueue(TICKER_USER_ID_THREAD, TICKER_USER_ID_ULL_HIGH, 0U, &mfy);
   3a19a:	f7fa fa69 	bl	34670 <mayfly_enqueue>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn->lll.role) {
   3a19e:	f995 3039 	ldrsb.w	r3, [r5, #57]	; 0x39
   3a1a2:	2b00      	cmp	r3, #0
   3a1a4:	daef      	bge.n	3a186 <ll_tx_mem_enqueue+0x5a>
		ull_periph_latency_cancel(conn, handle);
   3a1a6:	4621      	mov	r1, r4
   3a1a8:	4628      	mov	r0, r5
   3a1aa:	f004 f9fb 	bl	3e5a4 <ull_periph_latency_cancel>
   3a1ae:	e7ea      	b.n	3a186 <ll_tx_mem_enqueue+0x5a>
		return -ENOBUFS;
   3a1b0:	f06f 0068 	mvn.w	r0, #104	; 0x68
}
   3a1b4:	bd70      	pop	{r4, r5, r6, pc}
		return -EINVAL;
   3a1b6:	f06f 0015 	mvn.w	r0, #21
}
   3a1ba:	4770      	bx	lr
   3a1bc:	200028e8 	.word	0x200028e8
   3a1c0:	20000c04 	.word	0x20000c04
   3a1c4:	20000adc 	.word	0x20000adc

0003a1c8 <ll_conn_update>:
{
   3a1c8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if (handle >= CONFIG_BT_MAX_CONN) {
   3a1cc:	2805      	cmp	r0, #5
{
   3a1ce:	f8bd 8020 	ldrh.w	r8, [sp, #32]
   3a1d2:	f8bd 9024 	ldrh.w	r9, [sp, #36]	; 0x24
   3a1d6:	f8bd 7028 	ldrh.w	r7, [sp, #40]	; 0x28
	if (handle >= CONFIG_BT_MAX_CONN) {
   3a1da:	d82b      	bhi.n	3a234 <ll_conn_update+0x6c>
   3a1dc:	4682      	mov	sl, r0
   3a1de:	460c      	mov	r4, r1
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
   3a1e0:	4848      	ldr	r0, [pc, #288]	; (3a304 <ll_conn_update+0x13c>)
   3a1e2:	4615      	mov	r5, r2
   3a1e4:	f44f 71fc 	mov.w	r1, #504	; 0x1f8
   3a1e8:	4652      	mov	r2, sl
   3a1ea:	461e      	mov	r6, r3
   3a1ec:	f7fa f998 	bl	34520 <mem_get>
	if (conn->lll.handle != handle) {
   3a1f0:	8d03      	ldrh	r3, [r0, #40]	; 0x28
   3a1f2:	4553      	cmp	r3, sl
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
   3a1f4:	4684      	mov	ip, r0
	if (conn->lll.handle != handle) {
   3a1f6:	d11d      	bne.n	3a234 <ll_conn_update+0x6c>
	if (!cmd) {
   3a1f8:	b1fc      	cbz	r4, 3a23a <ll_conn_update+0x72>
		cmd--;
   3a1fa:	3c01      	subs	r4, #1
		if (cmd) {
   3a1fc:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
   3a200:	d023      	beq.n	3a24a <ll_conn_update+0x82>
			if ((conn->llcp_conn_param.req ==
   3a202:	f890 2195 	ldrb.w	r2, [r0, #405]	; 0x195
   3a206:	f890 3194 	ldrb.w	r3, [r0, #404]	; 0x194
   3a20a:	429a      	cmp	r2, r3
   3a20c:	d045      	beq.n	3a29a <ll_conn_update+0xd2>
			    (conn->llcp_conn_param.state !=
   3a20e:	f890 3196 	ldrb.w	r3, [r0, #406]	; 0x196
			     conn->llcp_conn_param.ack) ||
   3a212:	f003 020f 	and.w	r2, r3, #15
   3a216:	2a03      	cmp	r2, #3
   3a218:	d13f      	bne.n	3a29a <ll_conn_update+0xd2>
			conn->llcp_conn_param.state = cmd;
   3a21a:	f004 040f 	and.w	r4, r4, #15
   3a21e:	f044 0410 	orr.w	r4, r4, #16
   3a222:	f023 031f 	bic.w	r3, r3, #31
   3a226:	431c      	orrs	r4, r3
			conn->llcp_conn_param.status = status;
   3a228:	f880 5197 	strb.w	r5, [r0, #407]	; 0x197
			conn->llcp_conn_param.state = cmd;
   3a22c:	f880 4196 	strb.w	r4, [r0, #406]	; 0x196
				return BT_HCI_ERR_SUCCESS;
   3a230:	2000      	movs	r0, #0
   3a232:	e000      	b.n	3a236 <ll_conn_update+0x6e>
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
   3a234:	2002      	movs	r0, #2
}
   3a236:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		if (!conn->llcp_conn_param.disabled &&
   3a23a:	f890 3196 	ldrb.w	r3, [r0, #406]	; 0x196
   3a23e:	065d      	lsls	r5, r3, #25
   3a240:	d421      	bmi.n	3a286 <ll_conn_update+0xbe>
		    (!conn->common.fex_valid ||
   3a242:	f890 30e4 	ldrb.w	r3, [r0, #228]	; 0xe4
		if (!conn->llcp_conn_param.disabled &&
   3a246:	07dc      	lsls	r4, r3, #31
   3a248:	d419      	bmi.n	3a27e <ll_conn_update+0xb6>
   3a24a:	2300      	movs	r3, #0
			if (conn->llcp_conn_param.req !=
   3a24c:	f89c 0194 	ldrb.w	r0, [ip, #404]	; 0x194
   3a250:	f89c 1195 	ldrb.w	r1, [ip, #405]	; 0x195
   3a254:	461a      	mov	r2, r3
   3a256:	f369 020f 	bfi	r2, r9, #0, #16
   3a25a:	f366 030f 	bfi	r3, r6, #0, #16
   3a25e:	4281      	cmp	r1, r0
   3a260:	f368 431f 	bfi	r3, r8, #16, #16
   3a264:	f367 421f 	bfi	r2, r7, #16, #16
   3a268:	d032      	beq.n	3a2d0 <ll_conn_update+0x108>
				if (!conn->llcp_conn_param.remote ||
   3a26a:	f89c 1196 	ldrb.w	r1, [ip, #406]	; 0x196
   3a26e:	0689      	lsls	r1, r1, #26
   3a270:	d513      	bpl.n	3a29a <ll_conn_update+0xd2>
   3a272:	f8bc 11a6 	ldrh.w	r1, [ip, #422]	; 0x1a6
   3a276:	b981      	cbnz	r1, 3a29a <ll_conn_update+0xd2>
				conn->llcp_conn_param.cache.interval_min =
   3a278:	e9cc 3268 	strd	r3, r2, [ip, #416]	; 0x1a0
				return BT_HCI_ERR_SUCCESS;
   3a27c:	e7d8      	b.n	3a230 <ll_conn_update+0x68>
		     (conn->llcp_feature.features_conn &
   3a27e:	f8d0 3138 	ldr.w	r3, [r0, #312]	; 0x138
		    (!conn->common.fex_valid ||
   3a282:	0798      	lsls	r0, r3, #30
   3a284:	d4e1      	bmi.n	3a24a <ll_conn_update+0x82>
		} else if (conn->lll.role) {
   3a286:	f99c 3039 	ldrsb.w	r3, [ip, #57]	; 0x39
   3a28a:	2b00      	cmp	r3, #0
   3a28c:	db38      	blt.n	3a300 <ll_conn_update+0x138>
		if (conn->llcp_cu.req != conn->llcp_cu.ack) {
   3a28e:	f89c 2118 	ldrb.w	r2, [ip, #280]	; 0x118
   3a292:	f89c 3119 	ldrb.w	r3, [ip, #281]	; 0x119
   3a296:	4293      	cmp	r3, r2
   3a298:	d002      	beq.n	3a2a0 <ll_conn_update+0xd8>
			return BT_HCI_ERR_CMD_DISALLOWED;
   3a29a:	200c      	movs	r0, #12
}
   3a29c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		conn->llcp_cu.state = LLCP_CUI_STATE_USE;
   3a2a0:	f89c 211a 	ldrb.w	r2, [ip, #282]	; 0x11a
		conn->llcp_cu.interval = interval_max;
   3a2a4:	f8ac 811c 	strh.w	r8, [ip, #284]	; 0x11c
		conn->llcp_cu.state = LLCP_CUI_STATE_USE;
   3a2a8:	f022 020f 	bic.w	r2, r2, #15
		conn->llcp_cu.req++;
   3a2ac:	3301      	adds	r3, #1
		conn->llcp_cu.state = LLCP_CUI_STATE_USE;
   3a2ae:	f042 0209 	orr.w	r2, r2, #9
   3a2b2:	f88c 211a 	strb.w	r2, [ip, #282]	; 0x11a
		conn->llcp_cu.req++;
   3a2b6:	f88c 3118 	strb.w	r3, [ip, #280]	; 0x118
		conn->llcp_cu.win_size = 1U;
   3a2ba:	2201      	movs	r2, #1
		conn->llcp_cu.win_offset_us = 0U;
   3a2bc:	2300      	movs	r3, #0
		conn->llcp_cu.latency = latency;
   3a2be:	f8ac 911e 	strh.w	r9, [ip, #286]	; 0x11e
		conn->llcp_cu.timeout = timeout;
   3a2c2:	f8ac 7120 	strh.w	r7, [ip, #288]	; 0x120
		conn->llcp_cu.win_size = 1U;
   3a2c6:	f88c 2128 	strb.w	r2, [ip, #296]	; 0x128
		conn->llcp_cu.win_offset_us = 0U;
   3a2ca:	f8cc 3124 	str.w	r3, [ip, #292]	; 0x124
		conn->llcp_cu.req++;
   3a2ce:	e7af      	b.n	3a230 <ll_conn_update+0x68>
			conn->llcp_conn_param.interval_min = interval_min;
   3a2d0:	f8cc 3198 	str.w	r3, [ip, #408]	; 0x198
			conn->llcp_conn_param.state = cmd;
   3a2d4:	f8bc 3196 	ldrh.w	r3, [ip, #406]	; 0x196
			conn->llcp_conn_param.interval_min = interval_min;
   3a2d8:	f8cc 219c 	str.w	r2, [ip, #412]	; 0x19c
			conn->llcp_conn_param.state = cmd;
   3a2dc:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   3a2e0:	f043 0310 	orr.w	r3, r3, #16
   3a2e4:	f8ac 3196 	strh.w	r3, [ip, #406]	; 0x196
			if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
   3a2e8:	f99c 3039 	ldrsb.w	r3, [ip, #57]	; 0x39
			conn->llcp_conn_param.req++;
   3a2ec:	3101      	adds	r1, #1
			if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
   3a2ee:	2b00      	cmp	r3, #0
			conn->llcp_conn_param.req++;
   3a2f0:	f88c 1194 	strb.w	r1, [ip, #404]	; 0x194
			if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
   3a2f4:	da9c      	bge.n	3a230 <ll_conn_update+0x68>
				ull_periph_latency_cancel(conn, handle);
   3a2f6:	4651      	mov	r1, sl
   3a2f8:	4660      	mov	r0, ip
   3a2fa:	f004 f953 	bl	3e5a4 <ull_periph_latency_cancel>
   3a2fe:	e797      	b.n	3a230 <ll_conn_update+0x68>
			return BT_HCI_ERR_UNSUPP_REMOTE_FEATURE;
   3a300:	201a      	movs	r0, #26
   3a302:	e798      	b.n	3a236 <ll_conn_update+0x6e>
   3a304:	200028e8 	.word	0x200028e8

0003a308 <ll_chm_get>:
	if (handle >= CONFIG_BT_MAX_CONN) {
   3a308:	2805      	cmp	r0, #5
   3a30a:	d81d      	bhi.n	3a348 <ll_chm_get+0x40>
{
   3a30c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   3a30e:	4606      	mov	r6, r0
   3a310:	460d      	mov	r5, r1
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
   3a312:	480e      	ldr	r0, [pc, #56]	; (3a34c <ll_chm_get+0x44>)
   3a314:	4632      	mov	r2, r6
   3a316:	f44f 71fc 	mov.w	r1, #504	; 0x1f8
   3a31a:	f7fa f901 	bl	34520 <mem_get>
	if (conn->lll.handle != handle) {
   3a31e:	8d03      	ldrh	r3, [r0, #40]	; 0x28
   3a320:	42b3      	cmp	r3, r6
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
   3a322:	4604      	mov	r4, r0
	if (conn->lll.handle != handle) {
   3a324:	d10e      	bne.n	3a344 <ll_chm_get+0x3c>
		memcpy(chm, conn->lll.data_chan_map,
   3a326:	f100 0734 	add.w	r7, r0, #52	; 0x34
		conn->chm_updated = 0U;
   3a32a:	2600      	movs	r6, #0
   3a32c:	f884 61f0 	strb.w	r6, [r4, #496]	; 0x1f0
		memcpy(chm, conn->lll.data_chan_map,
   3a330:	2205      	movs	r2, #5
   3a332:	4639      	mov	r1, r7
   3a334:	4628      	mov	r0, r5
   3a336:	f010 fda0 	bl	4ae7a <memcpy>
	} while (conn->chm_updated);
   3a33a:	f894 01f0 	ldrb.w	r0, [r4, #496]	; 0x1f0
   3a33e:	2800      	cmp	r0, #0
   3a340:	d1f4      	bne.n	3a32c <ll_chm_get+0x24>
}
   3a342:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
   3a344:	2002      	movs	r0, #2
}
   3a346:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
   3a348:	2002      	movs	r0, #2
}
   3a34a:	4770      	bx	lr
   3a34c:	200028e8 	.word	0x200028e8

0003a350 <ll_terminate_ind_send>:
	if (IS_ACL_HANDLE(handle)) {
   3a350:	2805      	cmp	r0, #5
   3a352:	d901      	bls.n	3a358 <ll_terminate_ind_send+0x8>
	return BT_HCI_ERR_UNKNOWN_CONN_ID;
   3a354:	2002      	movs	r0, #2
}
   3a356:	4770      	bx	lr
{
   3a358:	b538      	push	{r3, r4, r5, lr}
   3a35a:	4604      	mov	r4, r0
   3a35c:	460d      	mov	r5, r1
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
   3a35e:	4818      	ldr	r0, [pc, #96]	; (3a3c0 <ll_terminate_ind_send+0x70>)
   3a360:	4622      	mov	r2, r4
   3a362:	f44f 71fc 	mov.w	r1, #504	; 0x1f8
   3a366:	f7fa f8db 	bl	34520 <mem_get>
	if (conn->lll.handle != handle) {
   3a36a:	8d03      	ldrh	r3, [r0, #40]	; 0x28
   3a36c:	42a3      	cmp	r3, r4
   3a36e:	d120      	bne.n	3a3b2 <ll_terminate_ind_send+0x62>
		if (conn->llcp_terminate.req != conn->llcp_terminate.ack) {
   3a370:	f890 3150 	ldrb.w	r3, [r0, #336]	; 0x150
   3a374:	f890 2151 	ldrb.w	r2, [r0, #337]	; 0x151
   3a378:	429a      	cmp	r2, r3
   3a37a:	d11a      	bne.n	3a3b2 <ll_terminate_ind_send+0x62>
	switch (reason) {
   3a37c:	2d1a      	cmp	r5, #26
   3a37e:	d803      	bhi.n	3a388 <ll_terminate_ind_send+0x38>
   3a380:	2d04      	cmp	r5, #4
   3a382:	d810      	bhi.n	3a3a6 <ll_terminate_ind_send+0x56>
   3a384:	2012      	movs	r0, #18
}
   3a386:	bd38      	pop	{r3, r4, r5, pc}
	switch (reason) {
   3a388:	2d29      	cmp	r5, #41	; 0x29
   3a38a:	d001      	beq.n	3a390 <ll_terminate_ind_send+0x40>
   3a38c:	2d3b      	cmp	r5, #59	; 0x3b
   3a38e:	d1f9      	bne.n	3a384 <ll_terminate_ind_send+0x34>
		if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn->lll.role) {
   3a390:	f990 2039 	ldrsb.w	r2, [r0, #57]	; 0x39
		conn->llcp_terminate.reason_own = reason;
   3a394:	f880 5152 	strb.w	r5, [r0, #338]	; 0x152
		conn->llcp_terminate.req++; /* (req - ack) == 1, TERM_REQ */
   3a398:	3301      	adds	r3, #1
		if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn->lll.role) {
   3a39a:	2a00      	cmp	r2, #0
		conn->llcp_terminate.req++; /* (req - ack) == 1, TERM_REQ */
   3a39c:	f880 3150 	strb.w	r3, [r0, #336]	; 0x150
		if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn->lll.role) {
   3a3a0:	db09      	blt.n	3a3b6 <ll_terminate_ind_send+0x66>
		return 0;
   3a3a2:	2000      	movs	r0, #0
}
   3a3a4:	bd38      	pop	{r3, r4, r5, pc}
	switch (reason) {
   3a3a6:	4a07      	ldr	r2, [pc, #28]	; (3a3c4 <ll_terminate_ind_send+0x74>)
   3a3a8:	40ea      	lsrs	r2, r5
   3a3aa:	07d2      	lsls	r2, r2, #31
   3a3ac:	d4f0      	bmi.n	3a390 <ll_terminate_ind_send+0x40>
   3a3ae:	2012      	movs	r0, #18
   3a3b0:	e7e9      	b.n	3a386 <ll_terminate_ind_send+0x36>
			return BT_HCI_ERR_CMD_DISALLOWED;
   3a3b2:	200c      	movs	r0, #12
}
   3a3b4:	bd38      	pop	{r3, r4, r5, pc}
			ull_periph_latency_cancel(conn, handle);
   3a3b6:	4621      	mov	r1, r4
   3a3b8:	f004 f8f4 	bl	3e5a4 <ull_periph_latency_cancel>
   3a3bc:	e7f1      	b.n	3a3a2 <ll_terminate_ind_send+0x52>
   3a3be:	bf00      	nop
   3a3c0:	200028e8 	.word	0x200028e8
   3a3c4:	04380020 	.word	0x04380020

0003a3c8 <ll_feature_req_send>:
	if (handle >= CONFIG_BT_MAX_CONN) {
   3a3c8:	2805      	cmp	r0, #5
   3a3ca:	d821      	bhi.n	3a410 <ll_feature_req_send+0x48>
{
   3a3cc:	b510      	push	{r4, lr}
   3a3ce:	4604      	mov	r4, r0
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
   3a3d0:	f44f 71fc 	mov.w	r1, #504	; 0x1f8
   3a3d4:	480f      	ldr	r0, [pc, #60]	; (3a414 <ll_feature_req_send+0x4c>)
   3a3d6:	4622      	mov	r2, r4
   3a3d8:	f7fa f8a2 	bl	34520 <mem_get>
	if (conn->lll.handle != handle) {
   3a3dc:	8d01      	ldrh	r1, [r0, #40]	; 0x28
   3a3de:	42a1      	cmp	r1, r4
   3a3e0:	d10e      	bne.n	3a400 <ll_feature_req_send+0x38>
	if (conn->llcp_feature.req != conn->llcp_feature.ack) {
   3a3e2:	f890 4130 	ldrb.w	r4, [r0, #304]	; 0x130
   3a3e6:	f890 2131 	ldrb.w	r2, [r0, #305]	; 0x131
   3a3ea:	42a2      	cmp	r2, r4
   3a3ec:	d10a      	bne.n	3a404 <ll_feature_req_send+0x3c>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
   3a3ee:	f990 4039 	ldrsb.w	r4, [r0, #57]	; 0x39
	conn->llcp_feature.req++;
   3a3f2:	3201      	adds	r2, #1
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
   3a3f4:	2c00      	cmp	r4, #0
	conn->llcp_feature.req++;
   3a3f6:	f880 2130 	strb.w	r2, [r0, #304]	; 0x130
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
   3a3fa:	db05      	blt.n	3a408 <ll_feature_req_send+0x40>
	return 0;
   3a3fc:	2000      	movs	r0, #0
}
   3a3fe:	bd10      	pop	{r4, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
   3a400:	2002      	movs	r0, #2
}
   3a402:	bd10      	pop	{r4, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
   3a404:	200c      	movs	r0, #12
}
   3a406:	bd10      	pop	{r4, pc}
		ull_periph_latency_cancel(conn, handle);
   3a408:	f004 f8cc 	bl	3e5a4 <ull_periph_latency_cancel>
	return 0;
   3a40c:	2000      	movs	r0, #0
   3a40e:	e7f6      	b.n	3a3fe <ll_feature_req_send+0x36>
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
   3a410:	2002      	movs	r0, #2
}
   3a412:	4770      	bx	lr
   3a414:	200028e8 	.word	0x200028e8

0003a418 <ll_version_ind_send>:
	if (handle >= CONFIG_BT_MAX_CONN) {
   3a418:	2805      	cmp	r0, #5
   3a41a:	d821      	bhi.n	3a460 <ll_version_ind_send+0x48>
{
   3a41c:	b510      	push	{r4, lr}
   3a41e:	4604      	mov	r4, r0
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
   3a420:	f44f 71fc 	mov.w	r1, #504	; 0x1f8
   3a424:	480f      	ldr	r0, [pc, #60]	; (3a464 <ll_version_ind_send+0x4c>)
   3a426:	4622      	mov	r2, r4
   3a428:	f7fa f87a 	bl	34520 <mem_get>
	if (conn->lll.handle != handle) {
   3a42c:	8d01      	ldrh	r1, [r0, #40]	; 0x28
   3a42e:	42a1      	cmp	r1, r4
   3a430:	d10e      	bne.n	3a450 <ll_version_ind_send+0x38>
	if (conn->llcp_version.req != conn->llcp_version.ack) {
   3a432:	f890 4148 	ldrb.w	r4, [r0, #328]	; 0x148
   3a436:	f890 2149 	ldrb.w	r2, [r0, #329]	; 0x149
   3a43a:	42a2      	cmp	r2, r4
   3a43c:	d10a      	bne.n	3a454 <ll_version_ind_send+0x3c>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn->lll.role) {
   3a43e:	f990 4039 	ldrsb.w	r4, [r0, #57]	; 0x39
	conn->llcp_version.req++;
   3a442:	3201      	adds	r2, #1
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn->lll.role) {
   3a444:	2c00      	cmp	r4, #0
	conn->llcp_version.req++;
   3a446:	f880 2148 	strb.w	r2, [r0, #328]	; 0x148
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn->lll.role) {
   3a44a:	db05      	blt.n	3a458 <ll_version_ind_send+0x40>
	return 0;
   3a44c:	2000      	movs	r0, #0
}
   3a44e:	bd10      	pop	{r4, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
   3a450:	2002      	movs	r0, #2
}
   3a452:	bd10      	pop	{r4, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
   3a454:	200c      	movs	r0, #12
}
   3a456:	bd10      	pop	{r4, pc}
		ull_periph_latency_cancel(conn, handle);
   3a458:	f004 f8a4 	bl	3e5a4 <ull_periph_latency_cancel>
	return 0;
   3a45c:	2000      	movs	r0, #0
   3a45e:	e7f6      	b.n	3a44e <ll_version_ind_send+0x36>
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
   3a460:	2002      	movs	r0, #2
}
   3a462:	4770      	bx	lr
   3a464:	200028e8 	.word	0x200028e8

0003a468 <ll_length_req_send>:
	if (handle >= CONFIG_BT_MAX_CONN) {
   3a468:	2805      	cmp	r0, #5
   3a46a:	d851      	bhi.n	3a510 <ll_length_req_send+0xa8>
{
   3a46c:	b570      	push	{r4, r5, r6, lr}
   3a46e:	4604      	mov	r4, r0
   3a470:	460e      	mov	r6, r1
   3a472:	4615      	mov	r5, r2
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
   3a474:	f44f 71fc 	mov.w	r1, #504	; 0x1f8
   3a478:	4602      	mov	r2, r0
   3a47a:	4826      	ldr	r0, [pc, #152]	; (3a514 <ll_length_req_send+0xac>)
   3a47c:	f7fa f850 	bl	34520 <mem_get>
	if (conn->lll.handle != handle) {
   3a480:	8d03      	ldrh	r3, [r0, #40]	; 0x28
   3a482:	42a3      	cmp	r3, r4
   3a484:	d13e      	bne.n	3a504 <ll_length_req_send+0x9c>
	if (conn->llcp_length.disabled ||
   3a486:	f890 31c6 	ldrb.w	r3, [r0, #454]	; 0x1c6
   3a48a:	071a      	lsls	r2, r3, #28
   3a48c:	d43c      	bmi.n	3a508 <ll_length_req_send+0xa0>
	    (conn->common.fex_valid &&
   3a48e:	f890 20e4 	ldrb.w	r2, [r0, #228]	; 0xe4
	if (conn->llcp_length.disabled ||
   3a492:	07d1      	lsls	r1, r2, #31
   3a494:	d503      	bpl.n	3a49e <ll_length_req_send+0x36>
	     !(conn->llcp_feature.features_conn & BIT64(BT_LE_FEAT_BIT_DLE)))) {
   3a496:	f8d0 2138 	ldr.w	r2, [r0, #312]	; 0x138
	    (conn->common.fex_valid &&
   3a49a:	0692      	lsls	r2, r2, #26
   3a49c:	d534      	bpl.n	3a508 <ll_length_req_send+0xa0>
	if (tx_time > tx_time_max) {
   3a49e:	f5b5 7fa4 	cmp.w	r5, #328	; 0x148
   3a4a2:	462a      	mov	r2, r5
	if (conn->llcp_length.req != conn->llcp_length.ack) {
   3a4a4:	f890 11c5 	ldrb.w	r1, [r0, #453]	; 0x1c5
   3a4a8:	f890 51c4 	ldrb.w	r5, [r0, #452]	; 0x1c4
	if (tx_time > tx_time_max) {
   3a4ac:	bf28      	it	cs
   3a4ae:	f44f 72a4 	movcs.w	r2, #328	; 0x148
	if (conn->llcp_length.req != conn->llcp_length.ack) {
   3a4b2:	42a9      	cmp	r1, r5
   3a4b4:	d011      	beq.n	3a4da <ll_length_req_send+0x72>
		switch (conn->llcp_length.state) {
   3a4b6:	f003 0307 	and.w	r3, r3, #7
   3a4ba:	2b03      	cmp	r3, #3
   3a4bc:	d004      	beq.n	3a4c8 <ll_length_req_send+0x60>
   3a4be:	3303      	adds	r3, #3
   3a4c0:	f003 0307 	and.w	r3, r3, #7
   3a4c4:	2b01      	cmp	r3, #1
   3a4c6:	d821      	bhi.n	3a50c <ll_length_req_send+0xa4>
			if (!conn->llcp_length.cache.tx_octets) {
   3a4c8:	f8b0 31d0 	ldrh.w	r3, [r0, #464]	; 0x1d0
   3a4cc:	b9f3      	cbnz	r3, 3a50c <ll_length_req_send+0xa4>
				conn->llcp_length.cache.tx_octets = tx_octets;
   3a4ce:	f8a0 61d0 	strh.w	r6, [r0, #464]	; 0x1d0
				conn->llcp_length.cache.tx_time = tx_time;
   3a4d2:	f8a0 21d2 	strh.w	r2, [r0, #466]	; 0x1d2
	return 0;
   3a4d6:	2000      	movs	r0, #0
}
   3a4d8:	bd70      	pop	{r4, r5, r6, pc}
	conn->llcp_length.state = LLCP_LENGTH_STATE_REQ;
   3a4da:	f890 31c6 	ldrb.w	r3, [r0, #454]	; 0x1c6
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn->lll.role) {
   3a4de:	f990 5039 	ldrsb.w	r5, [r0, #57]	; 0x39
	conn->llcp_length.tx_octets = tx_octets;
   3a4e2:	f8a0 61ca 	strh.w	r6, [r0, #458]	; 0x1ca
	conn->llcp_length.req++;
   3a4e6:	3101      	adds	r1, #1
	conn->llcp_length.state = LLCP_LENGTH_STATE_REQ;
   3a4e8:	f36f 0302 	bfc	r3, #0, #3
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn->lll.role) {
   3a4ec:	2d00      	cmp	r5, #0
	conn->llcp_length.tx_time = tx_time;
   3a4ee:	f8a0 21ce 	strh.w	r2, [r0, #462]	; 0x1ce
	conn->llcp_length.req++;
   3a4f2:	f880 11c4 	strb.w	r1, [r0, #452]	; 0x1c4
	conn->llcp_length.state = LLCP_LENGTH_STATE_REQ;
   3a4f6:	f880 31c6 	strb.w	r3, [r0, #454]	; 0x1c6
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn->lll.role) {
   3a4fa:	daec      	bge.n	3a4d6 <ll_length_req_send+0x6e>
		ull_periph_latency_cancel(conn, handle);
   3a4fc:	4621      	mov	r1, r4
   3a4fe:	f004 f851 	bl	3e5a4 <ull_periph_latency_cancel>
   3a502:	e7e8      	b.n	3a4d6 <ll_length_req_send+0x6e>
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
   3a504:	2002      	movs	r0, #2
}
   3a506:	bd70      	pop	{r4, r5, r6, pc}
		return BT_HCI_ERR_UNSUPP_REMOTE_FEATURE;
   3a508:	201a      	movs	r0, #26
}
   3a50a:	bd70      	pop	{r4, r5, r6, pc}
			return BT_HCI_ERR_CMD_DISALLOWED;
   3a50c:	200c      	movs	r0, #12
}
   3a50e:	bd70      	pop	{r4, r5, r6, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
   3a510:	2002      	movs	r0, #2
}
   3a512:	4770      	bx	lr
   3a514:	200028e8 	.word	0x200028e8

0003a518 <ll_length_default_get>:
	*max_tx_octets = default_tx_octets;
   3a518:	4a03      	ldr	r2, [pc, #12]	; (3a528 <ll_length_default_get+0x10>)
	*max_tx_time = default_tx_time;
   3a51a:	4b04      	ldr	r3, [pc, #16]	; (3a52c <ll_length_default_get+0x14>)
	*max_tx_octets = default_tx_octets;
   3a51c:	8812      	ldrh	r2, [r2, #0]
	*max_tx_time = default_tx_time;
   3a51e:	881b      	ldrh	r3, [r3, #0]
	*max_tx_octets = default_tx_octets;
   3a520:	8002      	strh	r2, [r0, #0]
	*max_tx_time = default_tx_time;
   3a522:	800b      	strh	r3, [r1, #0]
}
   3a524:	4770      	bx	lr
   3a526:	bf00      	nop
   3a528:	20006a32 	.word	0x20006a32
   3a52c:	20006a30 	.word	0x20006a30

0003a530 <ll_length_default_set>:
	default_tx_octets = max_tx_octets;
   3a530:	4a02      	ldr	r2, [pc, #8]	; (3a53c <ll_length_default_set+0xc>)
	default_tx_time = max_tx_time;
   3a532:	4b03      	ldr	r3, [pc, #12]	; (3a540 <ll_length_default_set+0x10>)
	default_tx_octets = max_tx_octets;
   3a534:	8010      	strh	r0, [r2, #0]
	default_tx_time = max_tx_time;
   3a536:	8019      	strh	r1, [r3, #0]
}
   3a538:	2000      	movs	r0, #0
   3a53a:	4770      	bx	lr
   3a53c:	20006a32 	.word	0x20006a32
   3a540:	20006a30 	.word	0x20006a30

0003a544 <ll_length_max_get>:
	*max_tx_octets = LL_LENGTH_OCTETS_RX_MAX;
   3a544:	f04f 0c1b 	mov.w	ip, #27
   3a548:	f8a0 c000 	strh.w	ip, [r0]
	*max_tx_time = PDU_DC_MAX_US(LL_LENGTH_OCTETS_RX_MAX, PHY);
   3a54c:	f44f 70a4 	mov.w	r0, #328	; 0x148
	*max_rx_octets = LL_LENGTH_OCTETS_RX_MAX;
   3a550:	f8a2 c000 	strh.w	ip, [r2]
	*max_tx_time = PDU_DC_MAX_US(LL_LENGTH_OCTETS_RX_MAX, PHY);
   3a554:	8008      	strh	r0, [r1, #0]
	*max_rx_time = PDU_DC_MAX_US(LL_LENGTH_OCTETS_RX_MAX, PHY);
   3a556:	8018      	strh	r0, [r3, #0]
}
   3a558:	4770      	bx	lr
   3a55a:	bf00      	nop

0003a55c <ll_phy_get>:
	if (handle >= CONFIG_BT_MAX_CONN) {
   3a55c:	2805      	cmp	r0, #5
   3a55e:	d81b      	bhi.n	3a598 <ll_phy_get+0x3c>
{
   3a560:	b570      	push	{r4, r5, r6, lr}
   3a562:	4604      	mov	r4, r0
   3a564:	460e      	mov	r6, r1
   3a566:	4615      	mov	r5, r2
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
   3a568:	f44f 71fc 	mov.w	r1, #504	; 0x1f8
   3a56c:	4602      	mov	r2, r0
   3a56e:	480b      	ldr	r0, [pc, #44]	; (3a59c <ll_phy_get+0x40>)
   3a570:	f7f9 ffd6 	bl	34520 <mem_get>
	if (conn->lll.handle != handle) {
   3a574:	8d02      	ldrh	r2, [r0, #40]	; 0x28
   3a576:	42a2      	cmp	r2, r4
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
   3a578:	4603      	mov	r3, r0
	if (conn->lll.handle != handle) {
   3a57a:	d10b      	bne.n	3a594 <ll_phy_get+0x38>
	*tx = conn->lll.phy_tx;
   3a57c:	f890 4060 	ldrb.w	r4, [r0, #96]	; 0x60
   3a580:	f3c4 0402 	ubfx	r4, r4, #0, #3
   3a584:	7034      	strb	r4, [r6, #0]
	*rx = conn->lll.phy_rx;
   3a586:	f893 3061 	ldrb.w	r3, [r3, #97]	; 0x61
   3a58a:	f3c3 0302 	ubfx	r3, r3, #0, #3
   3a58e:	702b      	strb	r3, [r5, #0]
	return 0;
   3a590:	2000      	movs	r0, #0
}
   3a592:	bd70      	pop	{r4, r5, r6, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
   3a594:	2002      	movs	r0, #2
}
   3a596:	bd70      	pop	{r4, r5, r6, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
   3a598:	2002      	movs	r0, #2
}
   3a59a:	4770      	bx	lr
   3a59c:	200028e8 	.word	0x200028e8

0003a5a0 <ll_phy_default_set>:
	default_phy_tx = tx;
   3a5a0:	4a02      	ldr	r2, [pc, #8]	; (3a5ac <ll_phy_default_set+0xc>)
	default_phy_rx = rx;
   3a5a2:	4b03      	ldr	r3, [pc, #12]	; (3a5b0 <ll_phy_default_set+0x10>)
	default_phy_tx = tx;
   3a5a4:	7010      	strb	r0, [r2, #0]
	default_phy_rx = rx;
   3a5a6:	7019      	strb	r1, [r3, #0]
}
   3a5a8:	2000      	movs	r0, #0
   3a5aa:	4770      	bx	lr
   3a5ac:	20006bac 	.word	0x20006bac
   3a5b0:	20006bab 	.word	0x20006bab

0003a5b4 <ll_phy_req_send>:
	if (handle >= CONFIG_BT_MAX_CONN) {
   3a5b4:	2805      	cmp	r0, #5
{
   3a5b6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (handle >= CONFIG_BT_MAX_CONN) {
   3a5ba:	d843      	bhi.n	3a644 <ll_phy_req_send+0x90>
   3a5bc:	4606      	mov	r6, r0
   3a5be:	460c      	mov	r4, r1
   3a5c0:	4617      	mov	r7, r2
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
   3a5c2:	f44f 71fc 	mov.w	r1, #504	; 0x1f8
   3a5c6:	4602      	mov	r2, r0
   3a5c8:	4824      	ldr	r0, [pc, #144]	; (3a65c <ll_phy_req_send+0xa8>)
   3a5ca:	4698      	mov	r8, r3
   3a5cc:	f7f9 ffa8 	bl	34520 <mem_get>
	if (conn->lll.handle != handle) {
   3a5d0:	8d03      	ldrh	r3, [r0, #40]	; 0x28
   3a5d2:	42b3      	cmp	r3, r6
   3a5d4:	d136      	bne.n	3a644 <ll_phy_req_send+0x90>
	if (conn->llcp_phy.disabled ||
   3a5d6:	f890 51d7 	ldrb.w	r5, [r0, #471]	; 0x1d7
   3a5da:	f015 0508 	ands.w	r5, r5, #8
   3a5de:	d139      	bne.n	3a654 <ll_phy_req_send+0xa0>
	    (conn->common.fex_valid &&
   3a5e0:	f890 30e4 	ldrb.w	r3, [r0, #228]	; 0xe4
	if (conn->llcp_phy.disabled ||
   3a5e4:	07db      	lsls	r3, r3, #31
   3a5e6:	d504      	bpl.n	3a5f2 <ll_phy_req_send+0x3e>
	     !(conn->llcp_feature.features_conn & BIT64(BT_LE_FEAT_BIT_PHY_2M)) &&
   3a5e8:	f8d0 3138 	ldr.w	r3, [r0, #312]	; 0x138
   3a5ec:	f413 6f10 	tst.w	r3, #2304	; 0x900
   3a5f0:	d030      	beq.n	3a654 <ll_phy_req_send+0xa0>
	if (conn->llcp_phy.req != conn->llcp_phy.ack) {
   3a5f2:	f890 31d4 	ldrb.w	r3, [r0, #468]	; 0x1d4
   3a5f6:	f890 21d5 	ldrb.w	r2, [r0, #469]	; 0x1d5
   3a5fa:	429a      	cmp	r2, r3
   3a5fc:	d126      	bne.n	3a64c <ll_phy_req_send+0x98>
	conn->llcp_phy.req++;
   3a5fe:	3201      	adds	r2, #1
	conn->llcp_phy.state = LLCP_PHY_STATE_REQ;
   3a600:	f004 0407 	and.w	r4, r4, #7
   3a604:	00a4      	lsls	r4, r4, #2
	conn->llcp_phy.req++;
   3a606:	f880 21d4 	strb.w	r2, [r0, #468]	; 0x1d4
	conn->llcp_phy.state = LLCP_PHY_STATE_REQ;
   3a60a:	f8b0 21d6 	ldrh.w	r2, [r0, #470]	; 0x1d6
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn->lll.role) {
   3a60e:	f990 1039 	ldrsb.w	r1, [r0, #57]	; 0x39
	conn->llcp_phy.state = LLCP_PHY_STATE_REQ;
   3a612:	f444 6480 	orr.w	r4, r4, #1024	; 0x400
   3a616:	f008 0807 	and.w	r8, r8, #7
   3a61a:	ea44 1348 	orr.w	r3, r4, r8, lsl #5
   3a61e:	f007 0701 	and.w	r7, r7, #1
   3a622:	f422 62df 	bic.w	r2, r2, #1784	; 0x6f8
   3a626:	ea43 2347 	orr.w	r3, r3, r7, lsl #9
   3a62a:	f022 0207 	bic.w	r2, r2, #7
   3a62e:	4313      	orrs	r3, r2
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn->lll.role) {
   3a630:	2900      	cmp	r1, #0
	conn->llcp_phy.state = LLCP_PHY_STATE_REQ;
   3a632:	f8a0 31d6 	strh.w	r3, [r0, #470]	; 0x1d6
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn->lll.role) {
   3a636:	da06      	bge.n	3a646 <ll_phy_req_send+0x92>
		ull_periph_latency_cancel(conn, handle);
   3a638:	4631      	mov	r1, r6
   3a63a:	f003 ffb3 	bl	3e5a4 <ull_periph_latency_cancel>
}
   3a63e:	4628      	mov	r0, r5
   3a640:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
   3a644:	2502      	movs	r5, #2
}
   3a646:	4628      	mov	r0, r5
   3a648:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
   3a64c:	250c      	movs	r5, #12
}
   3a64e:	4628      	mov	r0, r5
   3a650:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return BT_HCI_ERR_UNSUPP_REMOTE_FEATURE;
   3a654:	251a      	movs	r5, #26
}
   3a656:	4628      	mov	r0, r5
   3a658:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   3a65c:	200028e8 	.word	0x200028e8

0003a660 <ll_apto_get>:
	if (handle >= CONFIG_BT_MAX_CONN) {
   3a660:	2805      	cmp	r0, #5
   3a662:	d81d      	bhi.n	3a6a0 <ll_apto_get+0x40>
{
   3a664:	b538      	push	{r3, r4, r5, lr}
   3a666:	4604      	mov	r4, r0
   3a668:	460d      	mov	r5, r1
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
   3a66a:	480e      	ldr	r0, [pc, #56]	; (3a6a4 <ll_apto_get+0x44>)
   3a66c:	4622      	mov	r2, r4
   3a66e:	f44f 71fc 	mov.w	r1, #504	; 0x1f8
   3a672:	f7f9 ff55 	bl	34520 <mem_get>
	if (conn->lll.handle != handle) {
   3a676:	8d03      	ldrh	r3, [r0, #40]	; 0x28
   3a678:	42a3      	cmp	r3, r4
   3a67a:	d10f      	bne.n	3a69c <ll_apto_get+0x3c>
	*apto = conn->apto_reload * conn->lll.interval * 125U / 1000;
   3a67c:	8d41      	ldrh	r1, [r0, #42]	; 0x2a
   3a67e:	f8b0 30ce 	ldrh.w	r3, [r0, #206]	; 0xce
   3a682:	4a09      	ldr	r2, [pc, #36]	; (3a6a8 <ll_apto_get+0x48>)
   3a684:	fb01 f303 	mul.w	r3, r1, r3
   3a688:	ebc3 1143 	rsb	r1, r3, r3, lsl #5
   3a68c:	eb03 0381 	add.w	r3, r3, r1, lsl #2
   3a690:	fba2 2303 	umull	r2, r3, r2, r3
   3a694:	099b      	lsrs	r3, r3, #6
   3a696:	802b      	strh	r3, [r5, #0]
	return 0;
   3a698:	2000      	movs	r0, #0
}
   3a69a:	bd38      	pop	{r3, r4, r5, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
   3a69c:	2002      	movs	r0, #2
}
   3a69e:	bd38      	pop	{r3, r4, r5, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
   3a6a0:	2002      	movs	r0, #2
}
   3a6a2:	4770      	bx	lr
   3a6a4:	200028e8 	.word	0x200028e8
   3a6a8:	10624dd3 	.word	0x10624dd3

0003a6ac <ll_apto_set>:
	if (handle >= CONFIG_BT_MAX_CONN) {
   3a6ac:	2805      	cmp	r0, #5
   3a6ae:	d81e      	bhi.n	3a6ee <ll_apto_set+0x42>
{
   3a6b0:	b538      	push	{r3, r4, r5, lr}
   3a6b2:	4605      	mov	r5, r0
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
   3a6b4:	462a      	mov	r2, r5
   3a6b6:	480f      	ldr	r0, [pc, #60]	; (3a6f4 <ll_apto_set+0x48>)
   3a6b8:	460c      	mov	r4, r1
   3a6ba:	f44f 71fc 	mov.w	r1, #504	; 0x1f8
   3a6be:	f7f9 ff2f 	bl	34520 <mem_get>
	if (conn->lll.handle != handle) {
   3a6c2:	8d02      	ldrh	r2, [r0, #40]	; 0x28
   3a6c4:	42aa      	cmp	r2, r5
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
   3a6c6:	4603      	mov	r3, r0
	if (conn->lll.handle != handle) {
   3a6c8:	d10f      	bne.n	3a6ea <ll_apto_set+0x3e>
	conn->apto_reload = RADIO_CONN_EVENTS(apto * 10U * 1000U,
   3a6ca:	8d42      	ldrh	r2, [r0, #42]	; 0x2a
   3a6cc:	f240 41e2 	movw	r1, #1250	; 0x4e2
   3a6d0:	fb01 f202 	mul.w	r2, r1, r2
   3a6d4:	f242 7110 	movw	r1, #10000	; 0x2710
   3a6d8:	fb01 2104 	mla	r1, r1, r4, r2
   3a6dc:	3901      	subs	r1, #1
   3a6de:	fbb1 f1f2 	udiv	r1, r1, r2
   3a6e2:	f8a3 10ce 	strh.w	r1, [r3, #206]	; 0xce
	return 0;
   3a6e6:	2000      	movs	r0, #0
}
   3a6e8:	bd38      	pop	{r3, r4, r5, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
   3a6ea:	2002      	movs	r0, #2
}
   3a6ec:	bd38      	pop	{r3, r4, r5, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
   3a6ee:	2002      	movs	r0, #2
}
   3a6f0:	4770      	bx	lr
   3a6f2:	bf00      	nop
   3a6f4:	200028e8 	.word	0x200028e8

0003a6f8 <ull_conn_init>:
	err = init_reset();
   3a6f8:	f7fe be44 	b.w	39384 <init_reset>

0003a6fc <ull_conn_reset>:
{
   3a6fc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	(void)ull_central_reset();
   3a700:	f004 f914 	bl	3e92c <ull_central_reset>
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
   3a704:	4e19      	ldr	r6, [pc, #100]	; (3a76c <ull_conn_reset+0x70>)
	LL_ASSERT(err == 0 || err == -EALREADY);
   3a706:	f8df 8068 	ldr.w	r8, [pc, #104]	; 3a770 <ull_conn_reset+0x74>
   3a70a:	4f1a      	ldr	r7, [pc, #104]	; (3a774 <ull_conn_reset+0x78>)
	(void)ull_central_reset();
   3a70c:	2500      	movs	r5, #0
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
   3a70e:	b2aa      	uxth	r2, r5
   3a710:	f44f 71fc 	mov.w	r1, #504	; 0x1f8
   3a714:	4630      	mov	r0, r6
   3a716:	f7f9 ff03 	bl	34520 <mem_get>
   3a71a:	4604      	mov	r4, r0
	err = ull_ticker_stop_with_mark(TICKER_ID_CONN_BASE + handle,
   3a71c:	1d68      	adds	r0, r5, #5
   3a71e:	f104 021c 	add.w	r2, r4, #28
   3a722:	4621      	mov	r1, r4
   3a724:	b2c0      	uxtb	r0, r0
   3a726:	f7fd fc6f 	bl	38008 <ull_ticker_stop_with_mark>
	LL_ASSERT(err == 0 || err == -EALREADY);
   3a72a:	b170      	cbz	r0, 3a74a <ull_conn_reset+0x4e>
   3a72c:	3078      	adds	r0, #120	; 0x78
   3a72e:	d00c      	beq.n	3a74a <ull_conn_reset+0x4e>
   3a730:	4811      	ldr	r0, [pc, #68]	; (3a778 <ull_conn_reset+0x7c>)
   3a732:	f640 13c9 	movw	r3, #2505	; 0x9c9
   3a736:	4642      	mov	r2, r8
   3a738:	4639      	mov	r1, r7
   3a73a:	f00e fca3 	bl	49084 <assert_print>
   3a73e:	4040      	eors	r0, r0
   3a740:	f380 8811 	msr	BASEPRI, r0
   3a744:	f04f 0003 	mov.w	r0, #3
   3a748:	df02      	svc	2
	for (handle = 0U; handle < CONFIG_BT_MAX_CONN; handle++) {
   3a74a:	3501      	adds	r5, #1
	conn->lll.handle = LLL_HANDLE_INVALID;
   3a74c:	f64f 72ff 	movw	r2, #65535	; 0xffff
	conn->lll.link_tx_free = NULL;
   3a750:	2300      	movs	r3, #0
	for (handle = 0U; handle < CONFIG_BT_MAX_CONN; handle++) {
   3a752:	2d06      	cmp	r5, #6
	conn->lll.handle = LLL_HANDLE_INVALID;
   3a754:	8522      	strh	r2, [r4, #40]	; 0x28
	conn->lll.link_tx_free = NULL;
   3a756:	6763      	str	r3, [r4, #116]	; 0x74
	for (handle = 0U; handle < CONFIG_BT_MAX_CONN; handle++) {
   3a758:	d1d9      	bne.n	3a70e <ull_conn_reset+0x12>
	MFIFO_INIT(conn_tx);
   3a75a:	4908      	ldr	r1, [pc, #32]	; (3a77c <ull_conn_reset+0x80>)
	MFIFO_INIT(conn_ack);
   3a75c:	4a08      	ldr	r2, [pc, #32]	; (3a780 <ull_conn_reset+0x84>)
	MFIFO_INIT(conn_tx);
   3a75e:	808b      	strh	r3, [r1, #4]
	MFIFO_INIT(conn_ack);
   3a760:	8093      	strh	r3, [r2, #4]
}
   3a762:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	err = init_reset();
   3a766:	f7fe be0d 	b.w	39384 <init_reset>
   3a76a:	bf00      	nop
   3a76c:	200028e8 	.word	0x200028e8
   3a770:	0005269c 	.word	0x0005269c
   3a774:	00052684 	.word	0x00052684
   3a778:	0005214c 	.word	0x0005214c
   3a77c:	20000c04 	.word	0x20000c04
   3a780:	20000aec 	.word	0x20000aec

0003a784 <ull_conn_default_tx_octets_get>:
	return default_tx_octets;
   3a784:	4b01      	ldr	r3, [pc, #4]	; (3a78c <ull_conn_default_tx_octets_get+0x8>)
}
   3a786:	8818      	ldrh	r0, [r3, #0]
   3a788:	4770      	bx	lr
   3a78a:	bf00      	nop
   3a78c:	20006a32 	.word	0x20006a32

0003a790 <ull_conn_default_tx_time_get>:
	return default_tx_time;
   3a790:	4b01      	ldr	r3, [pc, #4]	; (3a798 <ull_conn_default_tx_time_get+0x8>)
}
   3a792:	8818      	ldrh	r0, [r3, #0]
   3a794:	4770      	bx	lr
   3a796:	bf00      	nop
   3a798:	20006a30 	.word	0x20006a30

0003a79c <ull_conn_default_phy_tx_get>:
	return default_phy_tx;
   3a79c:	4b01      	ldr	r3, [pc, #4]	; (3a7a4 <ull_conn_default_phy_tx_get+0x8>)
}
   3a79e:	7818      	ldrb	r0, [r3, #0]
   3a7a0:	4770      	bx	lr
   3a7a2:	bf00      	nop
   3a7a4:	20006bac 	.word	0x20006bac

0003a7a8 <ull_conn_default_phy_rx_get>:
	return default_phy_rx;
   3a7a8:	4b01      	ldr	r3, [pc, #4]	; (3a7b0 <ull_conn_default_phy_rx_get+0x8>)
}
   3a7aa:	7818      	ldrb	r0, [r3, #0]
   3a7ac:	4770      	bx	lr
   3a7ae:	bf00      	nop
   3a7b0:	20006bab 	.word	0x20006bab

0003a7b4 <ull_conn_peer_connected>:
{
   3a7b4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
   3a7b8:	4f1a      	ldr	r7, [pc, #104]	; (3a824 <ull_conn_peer_connected+0x70>)
{
   3a7ba:	4681      	mov	r9, r0
   3a7bc:	468a      	mov	sl, r1
   3a7be:	4616      	mov	r6, r2
   3a7c0:	4698      	mov	r8, r3
   3a7c2:	2500      	movs	r5, #0
   3a7c4:	fa1f fb85 	uxth.w	fp, r5
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
   3a7c8:	465a      	mov	r2, fp
   3a7ca:	f44f 71fc 	mov.w	r1, #504	; 0x1f8
   3a7ce:	4638      	mov	r0, r7
   3a7d0:	f7f9 fea6 	bl	34520 <mem_get>
	if (conn->lll.handle != handle) {
   3a7d4:	8d03      	ldrh	r3, [r0, #40]	; 0x28
   3a7d6:	455b      	cmp	r3, fp
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
   3a7d8:	4604      	mov	r4, r0
	for (handle = 0U; handle < CONFIG_BT_MAX_CONN; handle++) {
   3a7da:	f105 0501 	add.w	r5, r5, #1
	if (conn->lll.handle != handle) {
   3a7de:	d105      	bne.n	3a7ec <ull_conn_peer_connected+0x38>
		    conn->peer_id_addr_type == peer_id_addr_type &&
   3a7e0:	f890 c0d6 	ldrb.w	ip, [r0, #214]	; 0xd6
   3a7e4:	f3cc 0c40 	ubfx	ip, ip, #1, #1
		if (conn &&
   3a7e8:	45b4      	cmp	ip, r6
   3a7ea:	d004      	beq.n	3a7f6 <ull_conn_peer_connected+0x42>
	for (handle = 0U; handle < CONFIG_BT_MAX_CONN; handle++) {
   3a7ec:	2d06      	cmp	r5, #6
   3a7ee:	d1e9      	bne.n	3a7c4 <ull_conn_peer_connected+0x10>
	return false;
   3a7f0:	2000      	movs	r0, #0
}
   3a7f2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		    !memcmp(conn->peer_id_addr, peer_id_addr, BDADDR_SIZE) &&
   3a7f6:	2206      	movs	r2, #6
   3a7f8:	4641      	mov	r1, r8
   3a7fa:	30dd      	adds	r0, #221	; 0xdd
   3a7fc:	f010 fb2d 	bl	4ae5a <memcmp>
		    conn->peer_id_addr_type == peer_id_addr_type &&
   3a800:	2800      	cmp	r0, #0
   3a802:	d1f3      	bne.n	3a7ec <ull_conn_peer_connected+0x38>
		    conn->own_id_addr_type == own_id_addr_type &&
   3a804:	f894 30d6 	ldrb.w	r3, [r4, #214]	; 0xd6
   3a808:	f003 0301 	and.w	r3, r3, #1
		    !memcmp(conn->peer_id_addr, peer_id_addr, BDADDR_SIZE) &&
   3a80c:	454b      	cmp	r3, r9
   3a80e:	d1ed      	bne.n	3a7ec <ull_conn_peer_connected+0x38>
		    !memcmp(conn->own_id_addr, own_id_addr, BDADDR_SIZE)) {
   3a810:	f104 00d7 	add.w	r0, r4, #215	; 0xd7
   3a814:	2206      	movs	r2, #6
   3a816:	4651      	mov	r1, sl
   3a818:	f010 fb1f 	bl	4ae5a <memcmp>
		    conn->own_id_addr_type == own_id_addr_type &&
   3a81c:	2800      	cmp	r0, #0
   3a81e:	d1e5      	bne.n	3a7ec <ull_conn_peer_connected+0x38>
			return true;
   3a820:	2001      	movs	r0, #1
   3a822:	e7e6      	b.n	3a7f2 <ull_conn_peer_connected+0x3e>
   3a824:	200028e8 	.word	0x200028e8

0003a828 <ull_conn_setup>:
{
   3a828:	b538      	push	{r3, r4, r5, lr}
	hdr = HDR_LLL2ULL(ftr->param);
   3a82a:	688b      	ldr	r3, [r1, #8]
	rx->link = rx_link;
   3a82c:	6008      	str	r0, [r1, #0]
	hdr = HDR_LLL2ULL(ftr->param);
   3a82e:	681d      	ldr	r5, [r3, #0]
   3a830:	782b      	ldrb	r3, [r5, #0]
{
   3a832:	460c      	mov	r4, r1
	if (ull_ref_get(hdr)) {
   3a834:	b193      	cbz	r3, 3a85c <ull_conn_setup+0x34>
		LL_ASSERT(!hdr->disabled_cb);
   3a836:	696b      	ldr	r3, [r5, #20]
   3a838:	b163      	cbz	r3, 3a854 <ull_conn_setup+0x2c>
   3a83a:	4a0b      	ldr	r2, [pc, #44]	; (3a868 <ull_conn_setup+0x40>)
   3a83c:	490b      	ldr	r1, [pc, #44]	; (3a86c <ull_conn_setup+0x44>)
   3a83e:	480c      	ldr	r0, [pc, #48]	; (3a870 <ull_conn_setup+0x48>)
   3a840:	f240 4322 	movw	r3, #1058	; 0x422
   3a844:	f00e fc1e 	bl	49084 <assert_print>
   3a848:	4040      	eors	r0, r0
   3a84a:	f380 8811 	msr	BASEPRI, r0
   3a84e:	f04f 0003 	mov.w	r0, #3
   3a852:	df02      	svc	2
		hdr->disabled_cb = conn_setup_adv_scan_disabled_cb;
   3a854:	4b07      	ldr	r3, [pc, #28]	; (3a874 <ull_conn_setup+0x4c>)
   3a856:	e9c5 3405 	strd	r3, r4, [r5, #20]
}
   3a85a:	bd38      	pop	{r3, r4, r5, pc}
   3a85c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		conn_setup_adv_scan_disabled_cb(rx);
   3a860:	4608      	mov	r0, r1
   3a862:	f7fe bf93 	b.w	3978c <conn_setup_adv_scan_disabled_cb>
   3a866:	bf00      	nop
   3a868:	0005269c 	.word	0x0005269c
   3a86c:	0005254c 	.word	0x0005254c
   3a870:	0005214c 	.word	0x0005214c
   3a874:	0003978d 	.word	0x0003978d

0003a878 <ull_conn_rx>:
{
   3a878:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	conn = ll_connected_get((*rx)->hdr.handle);
   3a87c:	680b      	ldr	r3, [r1, #0]
   3a87e:	88de      	ldrh	r6, [r3, #6]
	if (handle >= CONFIG_BT_MAX_CONN) {
   3a880:	2e05      	cmp	r6, #5
{
   3a882:	b085      	sub	sp, #20
	if (handle >= CONFIG_BT_MAX_CONN) {
   3a884:	d85f      	bhi.n	3a946 <ull_conn_rx+0xce>
   3a886:	460d      	mov	r5, r1
   3a888:	4607      	mov	r7, r0
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
   3a88a:	4632      	mov	r2, r6
   3a88c:	489c      	ldr	r0, [pc, #624]	; (3ab00 <ull_conn_rx+0x288>)
   3a88e:	f44f 71fc 	mov.w	r1, #504	; 0x1f8
   3a892:	f7f9 fe45 	bl	34520 <mem_get>
	if (conn->lll.handle != handle) {
   3a896:	8d03      	ldrh	r3, [r0, #40]	; 0x28
   3a898:	42b3      	cmp	r3, r6
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
   3a89a:	4604      	mov	r4, r0
	if (conn->lll.handle != handle) {
   3a89c:	d152      	bne.n	3a944 <ull_conn_rx+0xcc>
	pdu_rx = (void *)(*rx)->pdu;
   3a89e:	682e      	ldr	r6, [r5, #0]

	opcode = pdu_rx->llctrl.opcode;

#if defined(CONFIG_BT_CTLR_LE_ENC)
	/* FIXME: do check in individual case to reduce CPU time */
	if (conn->llcp_enc.pause_rx && ctrl_is_unexpected(conn, opcode)) {
   3a8a0:	f890 3176 	ldrb.w	r3, [r0, #374]	; 0x176
	switch (pdu_rx->ll_id) {
   3a8a4:	7f32      	ldrb	r2, [r6, #28]
   3a8a6:	f002 0203 	and.w	r2, r2, #3
   3a8aa:	2a03      	cmp	r2, #3
	if (conn->llcp_enc.pause_rx && ctrl_is_unexpected(conn, opcode)) {
   3a8ac:	f003 0001 	and.w	r0, r3, #1
	switch (pdu_rx->ll_id) {
   3a8b0:	d13b      	bne.n	3a92a <ull_conn_rx+0xb2>
	opcode = pdu_rx->llctrl.opcode;
   3a8b2:	f896 801f 	ldrb.w	r8, [r6, #31]
	pdu_rx = (void *)(*rx)->pdu;
   3a8b6:	f106 021c 	add.w	r2, r6, #28
	if (conn->llcp_enc.pause_rx && ctrl_is_unexpected(conn, opcode)) {
   3a8ba:	2800      	cmp	r0, #0
   3a8bc:	d049      	beq.n	3a952 <ull_conn_rx+0xda>
		  (opcode != PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND)))) ||
   3a8be:	f994 0039 	ldrsb.w	r0, [r4, #57]	; 0x39
   3a8c2:	2800      	cmp	r0, #0
		((!conn->llcp_enc.refresh &&
   3a8c4:	f003 0104 	and.w	r1, r3, #4
		  (opcode != PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND)))) ||
   3a8c8:	f2c0 8269 	blt.w	3ad9e <ull_conn_rx+0x526>
	return (!conn->lll.role &&
   3a8cc:	2900      	cmp	r1, #0
   3a8ce:	f040 80b2 	bne.w	3aa36 <ull_conn_rx+0x1be>
		((!conn->llcp_enc.refresh &&
   3a8d2:	f1b8 0f02 	cmp.w	r8, #2
   3a8d6:	f000 8271 	beq.w	3adbc <ull_conn_rx+0x544>
   3a8da:	f1b8 0f11 	cmp.w	r8, #17
   3a8de:	d82e      	bhi.n	3a93e <ull_conn_rx+0xc6>
   3a8e0:	4988      	ldr	r1, [pc, #544]	; (3ab04 <ull_conn_rx+0x28c>)
   3a8e2:	fa21 fc08 	lsr.w	ip, r1, r8
   3a8e6:	f01c 0f01 	tst.w	ip, #1
   3a8ea:	d028      	beq.n	3a93e <ull_conn_rx+0xc6>

		return 0;
	}
#endif /* CONFIG_BT_CTLR_LE_ENC */

	switch (opcode) {
   3a8ec:	f1b8 0f19 	cmp.w	r8, #25
   3a8f0:	d853      	bhi.n	3a99a <ull_conn_rx+0x122>
   3a8f2:	e8df f018 	tbh	[pc, r8, lsl #1]
   3a8f6:	0453      	.short	0x0453
   3a8f8:	0263041b 	.word	0x0263041b
   3a8fc:	05230541 	.word	0x05230541
   3a900:	02970501 	.word	0x02970501
   3a904:	004f026e 	.word	0x004f026e
   3a908:	02cb01ed 	.word	0x02cb01ed
   3a90c:	019c058c 	.word	0x019c058c
   3a910:	039e0156 	.word	0x039e0156
   3a914:	03ae0141 	.word	0x03ae0141
   3a918:	0233010b 	.word	0x0233010b
   3a91c:	00cb0229 	.word	0x00cb0229
   3a920:	01c200cb 	.word	0x01c200cb
   3a924:	0321035a 	.word	0x0321035a
   3a928:	04cb      	.short	0x04cb
	switch (pdu_rx->ll_id) {
   3a92a:	b93a      	cbnz	r2, 3a93c <ull_conn_rx+0xc4>
		if (conn->llcp_enc.pause_rx) {
   3a92c:	b118      	cbz	r0, 3a936 <ull_conn_rx+0xbe>
			conn->llcp_terminate.reason_final =
   3a92e:	233d      	movs	r3, #61	; 0x3d
   3a930:	f884 3153 	strb.w	r3, [r4, #339]	; 0x153
		(*rx)->hdr.type = NODE_RX_TYPE_RELEASE;
   3a934:	682e      	ldr	r6, [r5, #0]
   3a936:	2301      	movs	r3, #1
   3a938:	7133      	strb	r3, [r6, #4]
		break;
   3a93a:	e006      	b.n	3a94a <ull_conn_rx+0xd2>
		if (conn->llcp_enc.pause_rx) {
   3a93c:	b128      	cbz	r0, 3a94a <ull_conn_rx+0xd2>
			conn->llcp_terminate.reason_final =
   3a93e:	233d      	movs	r3, #61	; 0x3d
   3a940:	f884 3153 	strb.w	r3, [r4, #339]	; 0x153
			(*rx)->hdr.type = NODE_RX_TYPE_RELEASE;
   3a944:	682b      	ldr	r3, [r5, #0]
   3a946:	2201      	movs	r2, #1
   3a948:	711a      	strb	r2, [r3, #4]
		return 0;
   3a94a:	2000      	movs	r0, #0
}
   3a94c:	b005      	add	sp, #20
   3a94e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	switch (opcode) {
   3a952:	f1b8 0f19 	cmp.w	r8, #25
   3a956:	d820      	bhi.n	3a99a <ull_conn_rx+0x122>
   3a958:	e8df f018 	tbh	[pc, r8, lsl #1]
   3a95c:	03e6041e 	.word	0x03e6041e
   3a960:	050c0230 	.word	0x050c0230
   3a964:	04cc04eb 	.word	0x04cc04eb
   3a968:	023b0264 	.word	0x023b0264
   3a96c:	01ba001a 	.word	0x01ba001a
   3a970:	05590296 	.word	0x05590296
   3a974:	01230169 	.word	0x01230169
   3a978:	010e0369 	.word	0x010e0369
   3a97c:	00d80379 	.word	0x00d80379
   3a980:	01f60200 	.word	0x01f60200
   3a984:	00980098 	.word	0x00980098
   3a988:	0325018f 	.word	0x0325018f
   3a98c:	049602ec 	.word	0x049602ec
   3a990:	f994 0039 	ldrsb.w	r0, [r4, #57]	; 0x39
		break;
#endif /* CONFIG_BT_CTLR_LE_ENC */

#if defined(CONFIG_BT_PERIPHERAL)
	case PDU_DATA_LLCTRL_TYPE_FEATURE_REQ:
		if (!conn->lll.role ||
   3a994:	2800      	cmp	r0, #0
   3a996:	f2c0 834f 	blt.w	3b038 <ull_conn_rx+0x7c0>
	if (conn->common.txn_lock) {
   3a99a:	f894 30e4 	ldrb.w	r3, [r4, #228]	; 0xe4
   3a99e:	079f      	lsls	r7, r3, #30
   3a9a0:	d4c9      	bmi.n	3a936 <ull_conn_rx+0xbe>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
   3a9a2:	4859      	ldr	r0, [pc, #356]	; (3ab08 <ull_conn_rx+0x290>)
   3a9a4:	f7f9 fd88 	bl	344b8 <mem_acquire>
	if (!tx) {
   3a9a8:	2800      	cmp	r0, #0
   3a9aa:	f000 862e 	beq.w	3b60a <ull_conn_rx+0xd92>
	conn->common.txn_lock = 1U;
   3a9ae:	f894 30e4 	ldrb.w	r3, [r4, #228]	; 0xe4
   3a9b2:	f043 0302 	orr.w	r3, r3, #2
   3a9b6:	f884 30e4 	strb.w	r3, [r4, #228]	; 0xe4
	pdu->ll_id = PDU_DATA_LLID_CTRL;
   3a9ba:	7903      	ldrb	r3, [r0, #4]
	pdu->llctrl.unknown_rsp.type = type;
   3a9bc:	f880 8008 	strb.w	r8, [r0, #8]
	pdu->ll_id = PDU_DATA_LLID_CTRL;
   3a9c0:	f043 0303 	orr.w	r3, r3, #3
   3a9c4:	7103      	strb	r3, [r0, #4]
	pdu->len = offsetof(struct pdu_data_llctrl, unknown_rsp) +
   3a9c6:	2202      	movs	r2, #2
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_UNKNOWN_RSP;
   3a9c8:	2307      	movs	r3, #7
	pdu->len = offsetof(struct pdu_data_llctrl, unknown_rsp) +
   3a9ca:	7142      	strb	r2, [r0, #5]
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_UNKNOWN_RSP;
   3a9cc:	71c3      	strb	r3, [r0, #7]
	    conn->tx_head &&
   3a9ce:	f8d4 31dc 	ldr.w	r3, [r4, #476]	; 0x1dc
	if (
   3a9d2:	b1e3      	cbz	r3, 3aa0e <ull_conn_rx+0x196>
	    !conn->llcp_cu.pause_tx &&
   3a9d4:	f894 211a 	ldrb.w	r2, [r4, #282]	; 0x11a
	    conn->tx_head &&
   3a9d8:	06d5      	lsls	r5, r2, #27
   3a9da:	d418      	bmi.n	3aa0e <ull_conn_rx+0x196>
	    !conn->llcp_enc.pause_tx &&
   3a9dc:	f894 2176 	ldrb.w	r2, [r4, #374]	; 0x176
	    !conn->llcp_cu.pause_tx &&
   3a9e0:	0791      	lsls	r1, r2, #30
   3a9e2:	d414      	bmi.n	3aa0e <ull_conn_rx+0x196>
	    !conn->llcp_phy.pause_tx &&
   3a9e4:	f894 21d7 	ldrb.w	r2, [r4, #471]	; 0x1d7
   3a9e8:	07d2      	lsls	r2, r2, #31
   3a9ea:	d410      	bmi.n	3aa0e <ull_conn_rx+0x196>
		if (conn->tx_head == conn->tx_data) {
   3a9ec:	f8d4 21e8 	ldr.w	r2, [r4, #488]	; 0x1e8
		if (!conn->tx_ctrl) {
   3a9f0:	f8d4 11e0 	ldr.w	r1, [r4, #480]	; 0x1e0
		if (conn->tx_head == conn->tx_data) {
   3a9f4:	4293      	cmp	r3, r2
   3a9f6:	f000 860c 	beq.w	3b612 <ull_conn_rx+0xd9a>
		} else if (!conn->tx_ctrl) {
   3a9fa:	b969      	cbnz	r1, 3aa18 <ull_conn_rx+0x1a0>
	if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   3a9fc:	791a      	ldrb	r2, [r3, #4]
   3a9fe:	f002 0203 	and.w	r2, r2, #3
   3aa02:	2a03      	cmp	r2, #3
   3aa04:	f001 81a8 	beq.w	3bd58 <ull_conn_rx+0x14e0>
		conn->tx_ctrl = conn->tx_ctrl_last = conn->tx_head;
   3aa08:	e9c4 3378 	strd	r3, r3, [r4, #480]	; 0x1e0
   3aa0c:	e004      	b.n	3aa18 <ull_conn_rx+0x1a0>
		if (!conn->tx_ctrl) {
   3aa0e:	f8d4 21e0 	ldr.w	r2, [r4, #480]	; 0x1e0
   3aa12:	2a00      	cmp	r2, #0
   3aa14:	f000 85b2 	beq.w	3b57c <ull_conn_rx+0xd04>
	tx->next = conn->tx_ctrl_last->next;
   3aa18:	f8d4 31e4 	ldr.w	r3, [r4, #484]	; 0x1e4
   3aa1c:	681b      	ldr	r3, [r3, #0]
   3aa1e:	6003      	str	r3, [r0, #0]
	conn->tx_ctrl_last->next = tx;
   3aa20:	f8d4 31e4 	ldr.w	r3, [r4, #484]	; 0x1e4
   3aa24:	6018      	str	r0, [r3, #0]
	conn->tx_ctrl_last = tx;
   3aa26:	f8c4 01e4 	str.w	r0, [r4, #484]	; 0x1e4
	if (!tx->next) {
   3aa2a:	6803      	ldr	r3, [r0, #0]
   3aa2c:	2b00      	cmp	r3, #0
   3aa2e:	d182      	bne.n	3a936 <ull_conn_rx+0xbe>
		conn->tx_data_last = tx;
   3aa30:	f8c4 01ec 	str.w	r0, [r4, #492]	; 0x1ec
	rx->hdr.type = NODE_RX_TYPE_RELEASE;
   3aa34:	e77f      	b.n	3a936 <ull_conn_rx+0xbe>
   3aa36:	f1a8 0c02 	sub.w	ip, r8, #2
   3aa3a:	fa5f fc8c 	uxtb.w	ip, ip
   3aa3e:	f1bc 0f09 	cmp.w	ip, #9
   3aa42:	f63f af4a 	bhi.w	3a8da <ull_conn_rx+0x62>
   3aa46:	f240 2e05 	movw	lr, #517	; 0x205
   3aa4a:	fa2e fc0c 	lsr.w	ip, lr, ip
   3aa4e:	f01c 0f01 	tst.w	ip, #1
   3aa52:	f43f af45 	beq.w	3a8e0 <ull_conn_rx+0x68>
	switch (opcode) {
   3aa56:	f1a8 0703 	sub.w	r7, r8, #3
   3aa5a:	2f08      	cmp	r7, #8
   3aa5c:	f200 81ae 	bhi.w	3adbc <ull_conn_rx+0x544>
   3aa60:	f20f 0c04 	addw	ip, pc, #4
   3aa64:	f85c f027 	ldr.w	pc, [ip, r7, lsl #2]
   3aa68:	0003b379 	.word	0x0003b379
   3aa6c:	0003b337 	.word	0x0003b337
   3aa70:	0003b2f9 	.word	0x0003b2f9
   3aa74:	0003ae25 	.word	0x0003ae25
   3aa78:	0003add3 	.word	0x0003add3
   3aa7c:	0003a995 	.word	0x0003a995
   3aa80:	0003acd1 	.word	0x0003acd1
   3aa84:	0003ae8d 	.word	0x0003ae8d
   3aa88:	0003b40f 	.word	0x0003b40f
		break;

#if defined(CONFIG_BT_CTLR_DATA_LENGTH)
	case PDU_DATA_LLCTRL_TYPE_LENGTH_RSP:
	case PDU_DATA_LLCTRL_TYPE_LENGTH_REQ:
		if (PDU_DATA_LLCTRL_LEN(length_req) != pdu_rx->len) {
   3aa8c:	7f73      	ldrb	r3, [r6, #29]
   3aa8e:	2b09      	cmp	r3, #9
   3aa90:	d183      	bne.n	3a99a <ull_conn_rx+0x122>
	if (pdu_rx->llctrl.opcode == PDU_DATA_LLCTRL_TYPE_LENGTH_REQ) {
   3aa92:	f1b8 0f14 	cmp.w	r8, #20
   3aa96:	f000 85f0 	beq.w	3b67a <ull_conn_rx+0xe02>
	    ((conn->llcp_length.req == conn->llcp_length.ack) && tx) ||
   3aa9a:	f894 21c4 	ldrb.w	r2, [r4, #452]	; 0x1c4
	if (/* Local idle, and Peer request then complete the Peer procedure
   3aa9e:	f894 31c5 	ldrb.w	r3, [r4, #453]	; 0x1c5
	eff_tx_octets = conn->lll.max_tx_octets;
   3aaa2:	f8b4 1058 	ldrh.w	r1, [r4, #88]	; 0x58
	eff_rx_octets = conn->lll.max_rx_octets;
   3aaa6:	f8b4 905a 	ldrh.w	r9, [r4, #90]	; 0x5a
	eff_rx_time = conn->lll.max_rx_time;
   3aaaa:	f8b4 b05e 	ldrh.w	fp, [r4, #94]	; 0x5e
	eff_tx_time = conn->lll.max_tx_time;
   3aaae:	f8b4 a05c 	ldrh.w	sl, [r4, #92]	; 0x5c
	eff_tx_octets = conn->lll.max_tx_octets;
   3aab2:	9101      	str	r1, [sp, #4]
	if (/* Local idle, and Peer request then complete the Peer procedure
   3aab4:	4293      	cmp	r3, r2
   3aab6:	f001 8177 	beq.w	3bda8 <ull_conn_rx+0x1530>
	     ((((conn->llcp_length.state == LLCP_LENGTH_STATE_REQ) ||
   3aaba:	f894 11c6 	ldrb.w	r1, [r4, #454]	; 0x1c6
	struct node_tx *tx = NULL;
   3aabe:	2300      	movs	r3, #0
	       tx) ||
   3aac0:	f001 0107 	and.w	r1, r1, #7
   3aac4:	2902      	cmp	r1, #2
   3aac6:	f000 85f9 	beq.w	3b6bc <ull_conn_rx+0xe44>
   3aaca:	f896 801f 	ldrb.w	r8, [r6, #31]
		if (pdu_rx->llctrl.opcode != PDU_DATA_LLCTRL_TYPE_LENGTH_RSP) {
   3aace:	f1b8 0f15 	cmp.w	r8, #21
   3aad2:	f43f af3a 	beq.w	3a94a <ull_conn_rx+0xd2>
			mem_release(tx, &mem_conn_tx_ctrl.free);
   3aad6:	4618      	mov	r0, r3
   3aad8:	490b      	ldr	r1, [pc, #44]	; (3ab08 <ull_conn_rx+0x290>)
   3aada:	f7f9 fd09 	bl	344f0 <mem_release>
			if (conn->llcp_length.state ==
   3aade:	f894 31c6 	ldrb.w	r3, [r4, #454]	; 0x1c6
			conn->common.txn_lock = 0U;
   3aae2:	f894 20e4 	ldrb.w	r2, [r4, #228]	; 0xe4
			if (conn->llcp_length.state ==
   3aae6:	f003 0307 	and.w	r3, r3, #7
			conn->common.txn_lock = 0U;
   3aaea:	f36f 0241 	bfc	r2, #1, #1
			if (conn->llcp_length.state ==
   3aaee:	2b04      	cmp	r3, #4
			conn->common.txn_lock = 0U;
   3aaf0:	f884 20e4 	strb.w	r2, [r4, #228]	; 0xe4
			if (conn->llcp_length.state ==
   3aaf4:	f47f af29 	bne.w	3a94a <ull_conn_rx+0xd2>
				return -EBUSY;
   3aaf8:	f06f 000f 	mvn.w	r0, #15
   3aafc:	e726      	b.n	3a94c <ull_conn_rx+0xd4>
   3aafe:	bf00      	nop
   3ab00:	200028e8 	.word	0x200028e8
   3ab04:	00022060 	.word	0x00022060
   3ab08:	20005384 	.word	0x20005384
		if (PDU_DATA_LLCTRL_LEN(reject_ext_ind) != pdu_rx->len) {
   3ab0c:	7f73      	ldrb	r3, [r6, #29]
   3ab0e:	2b03      	cmp	r3, #3
   3ab10:	f47f af43 	bne.w	3a99a <ull_conn_rx+0x122>
	switch (rej_ext_ind->reject_opcode) {
   3ab14:	f896 3020 	ldrb.w	r3, [r6, #32]
   3ab18:	3b03      	subs	r3, #3
   3ab1a:	2b13      	cmp	r3, #19
   3ab1c:	f63f af0b 	bhi.w	3a936 <ull_conn_rx+0xbe>
   3ab20:	a101      	add	r1, pc, #4	; (adr r1, 3ab28 <ull_conn_rx+0x2b0>)
   3ab22:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
   3ab26:	bf00      	nop
   3ab28:	0003b4eb 	.word	0x0003b4eb
   3ab2c:	0003a937 	.word	0x0003a937
   3ab30:	0003a937 	.word	0x0003a937
   3ab34:	0003a937 	.word	0x0003a937
   3ab38:	0003a937 	.word	0x0003a937
   3ab3c:	0003a937 	.word	0x0003a937
   3ab40:	0003a937 	.word	0x0003a937
   3ab44:	0003a937 	.word	0x0003a937
   3ab48:	0003a937 	.word	0x0003a937
   3ab4c:	0003a937 	.word	0x0003a937
   3ab50:	0003a937 	.word	0x0003a937
   3ab54:	0003a937 	.word	0x0003a937
   3ab58:	0003b47f 	.word	0x0003b47f
   3ab5c:	0003a937 	.word	0x0003a937
   3ab60:	0003a937 	.word	0x0003a937
   3ab64:	0003a937 	.word	0x0003a937
   3ab68:	0003a937 	.word	0x0003a937
   3ab6c:	0003b443 	.word	0x0003b443
   3ab70:	0003a937 	.word	0x0003a937
   3ab74:	0003b531 	.word	0x0003b531
		if (PDU_DATA_LLCTRL_LEN(conn_param_req) != pdu_rx->len) {
   3ab78:	7f72      	ldrb	r2, [r6, #29]
   3ab7a:	2a18      	cmp	r2, #24
   3ab7c:	f47f af0d 	bne.w	3a99a <ull_conn_rx+0x122>
	return conn_upd_curr && (conn_upd_curr != conn);
   3ab80:	4fbe      	ldr	r7, [pc, #760]	; (3ae7c <ull_conn_rx+0x604>)
   3ab82:	683a      	ldr	r2, [r7, #0]
   3ab84:	2a00      	cmp	r2, #0
   3ab86:	f000 854c 	beq.w	3b622 <ull_conn_rx+0xdaa>
   3ab8a:	4294      	cmp	r4, r2
   3ab8c:	f000 8549 	beq.w	3b622 <ull_conn_rx+0xdaa>
			nack = reject_ext_ind_send(conn, *rx,
   3ab90:	2320      	movs	r3, #32
   3ab92:	220f      	movs	r2, #15
			} else if (((conn->llcp_req - conn->llcp_ack) &
				    0x03) == 0x02) {
#endif /* !CONFIG_BT_CTLR_LE_ENC */
#endif /* !CONFIG_BT_CTLR_CONN_PARAM_REQ */
				/* Different procedure collision */
				nack = reject_ext_ind_send(conn, *rx,
   3ab94:	4631      	mov	r1, r6
   3ab96:	4620      	mov	r0, r4
}
   3ab98:	b005      	add	sp, #20
   3ab9a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
				nack = reject_ext_ind_send(conn, *rx,
   3ab9e:	f7fe bf2b 	b.w	399f8 <reject_ext_ind_send>
		if (PDU_DATA_LLCTRL_LEN(reject_ind) != pdu_rx->len) {
   3aba2:	7f73      	ldrb	r3, [r6, #29]
   3aba4:	2b02      	cmp	r3, #2
   3aba6:	f47f aef8 	bne.w	3a99a <ull_conn_rx+0x122>
	} else if ((conn->llcp_ack != conn->llcp_req) &&
   3abaa:	f894 30f0 	ldrb.w	r3, [r4, #240]	; 0xf0
   3abae:	f894 10f1 	ldrb.w	r1, [r4, #241]	; 0xf1
   3abb2:	4299      	cmp	r1, r3
   3abb4:	d004      	beq.n	3abc0 <ull_conn_rx+0x348>
   3abb6:	f894 10f2 	ldrb.w	r1, [r4, #242]	; 0xf2
   3abba:	2903      	cmp	r1, #3
   3abbc:	f001 8007 	beq.w	3bbce <ull_conn_rx+0x1356>
	} else if (conn->llcp_phy.ack != conn->llcp_phy.req) {
   3abc0:	f894 11d5 	ldrb.w	r1, [r4, #469]	; 0x1d5
   3abc4:	f894 31d4 	ldrb.w	r3, [r4, #468]	; 0x1d4
   3abc8:	4299      	cmp	r1, r3
   3abca:	f000 85cc 	beq.w	3b766 <ull_conn_rx+0xeee>
		rej_ext_ind->error_code = rej_ind->error_code;
   3abce:	f896 3020 	ldrb.w	r3, [r6, #32]
   3abd2:	f886 3021 	strb.w	r3, [r6, #33]	; 0x21
	if (rej_ext_ind->error_code != BT_HCI_ERR_LL_PROC_COLLISION) {
   3abd6:	2b23      	cmp	r3, #35	; 0x23
   3abd8:	d014      	beq.n	3ac04 <ull_conn_rx+0x38c>
		conn->lll.phy_tx_time = conn->lll.phy_tx;
   3abda:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
		conn->llcp_phy.ack = conn->llcp_phy.req;
   3abde:	f894 11d4 	ldrb.w	r1, [r4, #468]	; 0x1d4
   3abe2:	f884 11d5 	strb.w	r1, [r4, #469]	; 0x1d5
		conn->lll.phy_tx_time = conn->lll.phy_tx;
   3abe6:	f3c3 0202 	ubfx	r2, r3, #0, #3
   3abea:	f362 1306 	bfi	r3, r2, #4, #3
		conn->llcp_phy.pause_tx = 0U;
   3abee:	f894 21d7 	ldrb.w	r2, [r4, #471]	; 0x1d7
		conn->lll.phy_tx_time = conn->lll.phy_tx;
   3abf2:	f884 3060 	strb.w	r3, [r4, #96]	; 0x60
		conn->llcp_phy.pause_tx = 0U;
   3abf6:	f36f 0200 	bfc	r2, #0, #1
		conn->procedure_expire = 0U;
   3abfa:	2300      	movs	r3, #0
		conn->llcp_phy.pause_tx = 0U;
   3abfc:	f884 21d7 	strb.w	r2, [r4, #471]	; 0x1d7
		conn->procedure_expire = 0U;
   3ac00:	f8a4 30c8 	strh.w	r3, [r4, #200]	; 0xc8
	if (!conn->llcp_phy.cmd) {
   3ac04:	f894 31d7 	ldrb.w	r3, [r4, #471]	; 0x1d7
   3ac08:	0758      	lsls	r0, r3, #29
   3ac0a:	f57f ae94 	bpl.w	3a936 <ull_conn_rx+0xbe>
	rx->hdr.type = NODE_RX_TYPE_PHY_UPDATE;
   3ac0e:	221d      	movs	r2, #29
	p->status = rej_ext_ind->error_code;
   3ac10:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
	rx->hdr.type = NODE_RX_TYPE_PHY_UPDATE;
   3ac14:	7132      	strb	r2, [r6, #4]
		p->status = 0U;
   3ac16:	7733      	strb	r3, [r6, #28]
		p->tx = conn->lll.phy_tx;
   3ac18:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
   3ac1c:	f3c3 0302 	ubfx	r3, r3, #0, #3
   3ac20:	7773      	strb	r3, [r6, #29]
		p->rx = conn->lll.phy_rx;
   3ac22:	f894 3061 	ldrb.w	r3, [r4, #97]	; 0x61
   3ac26:	f3c3 0302 	ubfx	r3, r3, #0, #3
   3ac2a:	77b3      	strb	r3, [r6, #30]
		    PDU_DATA_LLCTRL_LEN(phy_upd_ind) != pdu_rx->len) {
			goto ull_conn_rx_unknown_rsp_send;
		}

		err = phy_upd_ind_recv(conn, link, rx, pdu_rx);
		if (err) {
   3ac2c:	e68d      	b.n	3a94a <ull_conn_rx+0xd2>
		if (PDU_DATA_LLCTRL_LEN(version_ind) != pdu_rx->len) {
   3ac2e:	7f75      	ldrb	r5, [r6, #29]
   3ac30:	2d06      	cmp	r5, #6
   3ac32:	f47f aeb2 	bne.w	3a99a <ull_conn_rx+0x122>
	if (!conn->llcp_version.tx) {
   3ac36:	f894 314a 	ldrb.w	r3, [r4, #330]	; 0x14a
   3ac3a:	07df      	lsls	r7, r3, #31
   3ac3c:	f140 8715 	bpl.w	3ba6a <ull_conn_rx+0x11f2>
	} else if (!conn->llcp_version.rx) {
   3ac40:	f013 0302 	ands.w	r3, r3, #2
   3ac44:	f47f ae77 	bne.w	3a936 <ull_conn_rx+0xbe>
		conn->llcp_version.ack = conn->llcp_version.req;
   3ac48:	f894 2148 	ldrb.w	r2, [r4, #328]	; 0x148
   3ac4c:	f884 2149 	strb.w	r2, [r4, #329]	; 0x149
		conn->procedure_expire = 0U;
   3ac50:	f8a4 30c8 	strh.w	r3, [r4, #200]	; 0xc8
	conn->llcp_version.version_number = v->version_number;
   3ac54:	f896 3020 	ldrb.w	r3, [r6, #32]
   3ac58:	f884 314b 	strb.w	r3, [r4, #331]	; 0x14b
	conn->llcp_version.company_id = sys_le16_to_cpu(v->company_id);
   3ac5c:	f8b6 2021 	ldrh.w	r2, [r6, #33]	; 0x21
	conn->llcp_version.rx = 1U;
   3ac60:	f894 314a 	ldrb.w	r3, [r4, #330]	; 0x14a
	conn->llcp_version.company_id = sys_le16_to_cpu(v->company_id);
   3ac64:	f8a4 214c 	strh.w	r2, [r4, #332]	; 0x14c
		sys_le16_to_cpu(v->sub_version_number);
   3ac68:	f8b6 2023 	ldrh.w	r2, [r6, #35]	; 0x23
	conn->llcp_version.sub_version_number =
   3ac6c:	f8a4 214e 	strh.w	r2, [r4, #334]	; 0x14e
	conn->llcp_version.rx = 1U;
   3ac70:	f043 0302 	orr.w	r3, r3, #2
   3ac74:	f884 314a 	strb.w	r3, [r4, #330]	; 0x14a
	return 0;
   3ac78:	e667      	b.n	3a94a <ull_conn_rx+0xd2>
		if (PDU_DATA_LLCTRL_LEN(phy_req) != pdu_rx->len) {
   3ac7a:	7f73      	ldrb	r3, [r6, #29]
   3ac7c:	2b03      	cmp	r3, #3
   3ac7e:	f47f ae8c 	bne.w	3a99a <ull_conn_rx+0x122>
		if (!conn->lll.role) {
   3ac82:	f994 3039 	ldrsb.w	r3, [r4, #57]	; 0x39
   3ac86:	2b00      	cmp	r3, #0
   3ac88:	f2c0 85a7 	blt.w	3b7da <ull_conn_rx+0xf62>
			if ((conn->llcp_phy.ack !=
   3ac8c:	f894 21d5 	ldrb.w	r2, [r4, #469]	; 0x1d5
			     conn->llcp_phy.req) &&
   3ac90:	f894 11d4 	ldrb.w	r1, [r4, #468]	; 0x1d4
			if ((conn->llcp_phy.ack !=
   3ac94:	428a      	cmp	r2, r1
   3ac96:	d007      	beq.n	3aca8 <ull_conn_rx+0x430>
			      LLCP_PHY_STATE_RSP_WAIT) ||
   3ac98:	f894 31d6 	ldrb.w	r3, [r4, #470]	; 0x1d6
   3ac9c:	f003 0303 	and.w	r3, r3, #3
			     conn->llcp_phy.req) &&
   3aca0:	3b01      	subs	r3, #1
   3aca2:	2b02      	cmp	r3, #2
   3aca4:	f240 871a 	bls.w	3badc <ull_conn_rx+0x1264>
			} else if (((((conn->llcp_req - conn->llcp_ack) &
   3aca8:	f894 30f0 	ldrb.w	r3, [r4, #240]	; 0xf0
   3acac:	f894 00f1 	ldrb.w	r0, [r4, #241]	; 0xf1
   3acb0:	1a1b      	subs	r3, r3, r0
   3acb2:	f003 0303 	and.w	r3, r3, #3
   3acb6:	2b02      	cmp	r3, #2
   3acb8:	f000 8665 	beq.w	3b986 <ull_conn_rx+0x110e>
				     LLCP_ENCRYPTION)) ||
   3acbc:	f894 0194 	ldrb.w	r0, [r4, #404]	; 0x194
   3acc0:	f894 3195 	ldrb.w	r3, [r4, #405]	; 0x195
   3acc4:	4298      	cmp	r0, r3
   3acc6:	f000 8714 	beq.w	3baf2 <ull_conn_rx+0x127a>
				nack = reject_ext_ind_send(conn, *rx,
   3acca:	232a      	movs	r3, #42	; 0x2a
   3accc:	2216      	movs	r2, #22
   3acce:	e761      	b.n	3ab94 <ull_conn_rx+0x31c>
		if ((!IS_ENABLED(CONFIG_BT_CTLR_PER_INIT_FEAT_XCHG) &&
   3acd0:	7f73      	ldrb	r3, [r6, #29]
   3acd2:	2b09      	cmp	r3, #9
   3acd4:	f47f ae61 	bne.w	3a99a <ull_conn_rx+0x122>
	return ((uint64_t)sys_get_le32(&src[4]) << 32) | sys_get_le32(&src[0]);
   3acd8:	6a32      	ldr	r2, [r6, #32]
	feat &= LL_FEAT_BIT_MASK;
   3acda:	4969      	ldr	r1, [pc, #420]	; (3ae80 <ull_conn_rx+0x608>)
   3acdc:	6a73      	ldr	r3, [r6, #36]	; 0x24
   3acde:	4311      	orrs	r1, r2
	conn->llcp_feature.features_conn &= feat_get(&rsp->features[0]);
   3ace0:	f8d4 2138 	ldr.w	r2, [r4, #312]	; 0x138
   3ace4:	400a      	ands	r2, r1
   3ace6:	f8c4 2138 	str.w	r2, [r4, #312]	; 0x138
	feat &= LL_FEAT_BIT_MASK;
   3acea:	f003 03ff 	and.w	r3, r3, #255	; 0xff
	conn->llcp_feature.features_conn &= feat_get(&rsp->features[0]);
   3acee:	f8d4 213c 	ldr.w	r2, [r4, #316]	; 0x13c
	feat &= LL_FEAT_BIT_MASK;
   3acf2:	f043 0310 	orr.w	r3, r3, #16
	conn->llcp_feature.features_conn &= feat_get(&rsp->features[0]);
   3acf6:	401a      	ands	r2, r3
   3acf8:	f8c4 213c 	str.w	r2, [r4, #316]	; 0x13c
   3acfc:	6a75      	ldr	r5, [r6, #36]	; 0x24
   3acfe:	6a37      	ldr	r7, [r6, #32]
		feat_land_octet0(feat_get(&rsp->features[0]), ll_feat_get());
   3ad00:	f7fc fb68 	bl	373d4 <ll_feat_get>
	feat_result = feat_to_keep & feat_octet0;
   3ad04:	f005 03ff 	and.w	r3, r5, #255	; 0xff
	feat_result |= feat_to_keep & LL_FEAT_FILTER_OCTET0;
   3ad08:	f043 0310 	orr.w	r3, r3, #16
	conn->llcp_feature.features_peer =
   3ad0c:	f8c4 3144 	str.w	r3, [r4, #324]	; 0x144
	conn->common.fex_valid = 1U;
   3ad10:	f894 30e4 	ldrb.w	r3, [r4, #228]	; 0xe4
   3ad14:	f043 0301 	orr.w	r3, r3, #1
   3ad18:	f884 30e4 	strb.w	r3, [r4, #228]	; 0xe4
	conn->llcp_feature.ack = conn->llcp_feature.req;
   3ad1c:	f894 3130 	ldrb.w	r3, [r4, #304]	; 0x130
   3ad20:	f884 3131 	strb.w	r3, [r4, #305]	; 0x131
	feat &= LL_FEAT_BIT_MASK;
   3ad24:	4b56      	ldr	r3, [pc, #344]	; (3ae80 <ull_conn_rx+0x608>)
   3ad26:	433b      	orrs	r3, r7
	feat_result = feat_to_keep & feat_octet0;
   3ad28:	4003      	ands	r3, r0
	feat_result &= 0xFF;
   3ad2a:	f003 03ff 	and.w	r3, r3, #255	; 0xff
   3ad2e:	f027 07ff 	bic.w	r7, r7, #255	; 0xff
   3ad32:	433b      	orrs	r3, r7
	feat_result |= feat_to_keep & LL_FEAT_FILTER_OCTET0;
   3ad34:	f043 6307 	orr.w	r3, r3, #141557760	; 0x8700000
	feat_result &= 0xFF;
   3ad38:	2200      	movs	r2, #0
	feat_result |= feat_to_keep & LL_FEAT_FILTER_OCTET0;
   3ad3a:	f443 2303 	orr.w	r3, r3, #536576	; 0x83000
	conn->procedure_expire = 0U;
   3ad3e:	f8a4 20c8 	strh.w	r2, [r4, #200]	; 0xc8
	conn->llcp_feature.features_peer =
   3ad42:	f8c4 3140 	str.w	r3, [r4, #320]	; 0x140
}
   3ad46:	e600      	b.n	3a94a <ull_conn_rx+0xd2>
		if (PDU_DATA_LLCTRL_LEN(ping_rsp) != pdu_rx->len) {
   3ad48:	7f73      	ldrb	r3, [r6, #29]
   3ad4a:	2b01      	cmp	r3, #1
   3ad4c:	f47f ae25 	bne.w	3a99a <ull_conn_rx+0x122>
		conn->procedure_expire = 0U;
   3ad50:	2200      	movs	r2, #0
   3ad52:	f8a4 20c8 	strh.w	r2, [r4, #200]	; 0xc8
		(*rx)->hdr.type = NODE_RX_TYPE_RELEASE;
   3ad56:	682a      	ldr	r2, [r5, #0]
   3ad58:	7113      	strb	r3, [r2, #4]
		break;
   3ad5a:	e5f6      	b.n	3a94a <ull_conn_rx+0xd2>
		if (PDU_DATA_LLCTRL_LEN(ping_req) != pdu_rx->len) {
   3ad5c:	7f75      	ldrb	r5, [r6, #29]
   3ad5e:	2d01      	cmp	r5, #1
   3ad60:	f47f ae1b 	bne.w	3a99a <ull_conn_rx+0x122>
	if (conn->common.txn_lock) {
   3ad64:	f894 30e4 	ldrb.w	r3, [r4, #228]	; 0xe4
   3ad68:	079f      	lsls	r7, r3, #30
   3ad6a:	d416      	bmi.n	3ad9a <ull_conn_rx+0x522>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
   3ad6c:	4845      	ldr	r0, [pc, #276]	; (3ae84 <ull_conn_rx+0x60c>)
   3ad6e:	f7f9 fba3 	bl	344b8 <mem_acquire>
	if (!tx) {
   3ad72:	4601      	mov	r1, r0
   3ad74:	2800      	cmp	r0, #0
   3ad76:	f000 8448 	beq.w	3b60a <ull_conn_rx+0xd92>
	conn->common.txn_lock = 1U;
   3ad7a:	f894 30e4 	ldrb.w	r3, [r4, #228]	; 0xe4
   3ad7e:	f043 0302 	orr.w	r3, r3, #2
   3ad82:	f884 30e4 	strb.w	r3, [r4, #228]	; 0xe4
	pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
   3ad86:	7903      	ldrb	r3, [r0, #4]
	pdu_tx->len = offsetof(struct pdu_data_llctrl, ping_rsp) +
   3ad88:	7145      	strb	r5, [r0, #5]
	pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
   3ad8a:	f043 0303 	orr.w	r3, r3, #3
   3ad8e:	7103      	strb	r3, [r0, #4]
	pdu_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PING_RSP;
   3ad90:	2313      	movs	r3, #19
   3ad92:	71c3      	strb	r3, [r0, #7]
	ctrl_tx_sec_enqueue(conn, tx);
   3ad94:	4620      	mov	r0, r4
   3ad96:	f7fe fc21 	bl	395dc <ctrl_tx_sec_enqueue>
	rx->hdr.type = NODE_RX_TYPE_RELEASE;
   3ad9a:	7135      	strb	r5, [r6, #4]
	return 0;
   3ad9c:	e5d5      	b.n	3a94a <ull_conn_rx+0xd2>
	       (conn->lll.role &&
   3ad9e:	2900      	cmp	r1, #0
   3ada0:	f000 83f1 	beq.w	3b586 <ull_conn_rx+0xd0e>
   3ada4:	f1b8 0f03 	cmp.w	r8, #3
   3ada8:	f200 8420 	bhi.w	3b5ec <ull_conn_rx+0xd74>
   3adac:	f1b8 0f01 	cmp.w	r8, #1
   3adb0:	f67f adc5 	bls.w	3a93e <ull_conn_rx+0xc6>
	switch (opcode) {
   3adb4:	f1b8 0f03 	cmp.w	r8, #3
   3adb8:	f000 82de 	beq.w	3b378 <ull_conn_rx+0xb00>
		if (PDU_DATA_LLCTRL_LEN(terminate_ind) != pdu_rx->len) {
   3adbc:	7f73      	ldrb	r3, [r6, #29]
   3adbe:	2b02      	cmp	r3, #2
   3adc0:	f47f adeb 	bne.w	3a99a <ull_conn_rx+0x122>
		pdu->llctrl.terminate_ind.error_code;
   3adc4:	f896 2020 	ldrb.w	r2, [r6, #32]
	conn->llcp_terminate.reason_final =
   3adc8:	f884 2153 	strb.w	r2, [r4, #339]	; 0x153
	rx->hdr.type = NODE_RX_TYPE_RELEASE;
   3adcc:	2301      	movs	r3, #1
   3adce:	7133      	strb	r3, [r6, #4]
}
   3add0:	e5bb      	b.n	3a94a <ull_conn_rx+0xd2>
		if (PDU_DATA_LLCTRL_LEN(unknown_rsp) != pdu_rx->len) {
   3add2:	7f73      	ldrb	r3, [r6, #29]
   3add4:	2b02      	cmp	r3, #2
   3add6:	f47f ade0 	bne.w	3a99a <ull_conn_rx+0x122>
			    conn->llcp_conn_param.req) &&
   3adda:	f894 1194 	ldrb.w	r1, [r4, #404]	; 0x194
		} else if ((conn->llcp_conn_param.ack !=
   3adde:	f894 0195 	ldrb.w	r0, [r4, #405]	; 0x195
	conn->llcp_cu.win_size = pdu->llctrl.conn_update_ind.win_size;
   3ade2:	f896 3020 	ldrb.w	r3, [r6, #32]
		} else if ((conn->llcp_conn_param.ack !=
   3ade6:	4288      	cmp	r0, r1
   3ade8:	d002      	beq.n	3adf0 <ull_conn_rx+0x578>
			    conn->llcp_conn_param.req) &&
   3adea:	2b0f      	cmp	r3, #15
   3adec:	f000 8584 	beq.w	3b8f8 <ull_conn_rx+0x1080>
		} else if ((conn->llcp_length.req != conn->llcp_length.ack) &&
   3adf0:	f894 21c4 	ldrb.w	r2, [r4, #452]	; 0x1c4
   3adf4:	f894 11c5 	ldrb.w	r1, [r4, #453]	; 0x1c5
   3adf8:	4291      	cmp	r1, r2
   3adfa:	d002      	beq.n	3ae02 <ull_conn_rx+0x58a>
   3adfc:	2b14      	cmp	r3, #20
   3adfe:	f000 8658 	beq.w	3bab2 <ull_conn_rx+0x123a>
		} else if ((conn->llcp_phy.req != conn->llcp_phy.ack) &&
   3ae02:	f894 11d4 	ldrb.w	r1, [r4, #468]	; 0x1d4
   3ae06:	f894 21d5 	ldrb.w	r2, [r4, #469]	; 0x1d5
   3ae0a:	428a      	cmp	r2, r1
   3ae0c:	d002      	beq.n	3ae14 <ull_conn_rx+0x59c>
   3ae0e:	2b16      	cmp	r3, #22
   3ae10:	f000 86b7 	beq.w	3bb82 <ull_conn_rx+0x130a>
			switch (llctrl->unknown_rsp.type) {
   3ae14:	2b12      	cmp	r3, #18
				(*rx)->hdr.type = NODE_RX_TYPE_RELEASE;
   3ae16:	bf04      	itt	eq
   3ae18:	2301      	moveq	r3, #1
   3ae1a:	7133      	strbeq	r3, [r6, #4]
		conn->procedure_expire = 0U;
   3ae1c:	2300      	movs	r3, #0
   3ae1e:	f8a4 30c8 	strh.w	r3, [r4, #200]	; 0xc8
		break;
   3ae22:	e592      	b.n	3a94a <ull_conn_rx+0xd2>
		if ((conn->llcp_req == conn->llcp_ack) ||
   3ae24:	f894 20f0 	ldrb.w	r2, [r4, #240]	; 0xf0
   3ae28:	f894 00f1 	ldrb.w	r0, [r4, #241]	; 0xf1
   3ae2c:	4290      	cmp	r0, r2
   3ae2e:	f43f adb4 	beq.w	3a99a <ull_conn_rx+0x122>
   3ae32:	f894 00f2 	ldrb.w	r0, [r4, #242]	; 0xf2
   3ae36:	2803      	cmp	r0, #3
   3ae38:	f47f adaf 	bne.w	3a99a <ull_conn_rx+0x122>
		    (conn->llcp_type != LLCP_ENCRYPTION) ||
   3ae3c:	7f70      	ldrb	r0, [r6, #29]
   3ae3e:	2801      	cmp	r0, #1
   3ae40:	f47f adab 	bne.w	3a99a <ull_conn_rx+0x122>
		if (conn->lll.role) {
   3ae44:	f994 1039 	ldrsb.w	r1, [r4, #57]	; 0x39
   3ae48:	2900      	cmp	r1, #0
   3ae4a:	f2c0 864a 	blt.w	3bae2 <ull_conn_rx+0x126a>
			conn->llcp_enc.pause_rx = 0U;
   3ae4e:	f894 3176 	ldrb.w	r3, [r4, #374]	; 0x176
			conn->llcp_ack = conn->llcp_req;
   3ae52:	f884 20f1 	strb.w	r2, [r4, #241]	; 0xf1
			conn->procedure_expire = 0U;
   3ae56:	2100      	movs	r1, #0
			conn->llcp_enc.pause_rx = 0U;
   3ae58:	f023 0303 	bic.w	r3, r3, #3
   3ae5c:	f884 3176 	strb.w	r3, [r4, #374]	; 0x176
			conn->procedure_expire = 0U;
   3ae60:	f8a4 10c8 	strh.w	r1, [r4, #200]	; 0xc8
		if (conn->llcp_enc.refresh) {
   3ae64:	075e      	lsls	r6, r3, #29
   3ae66:	f57f ad70 	bpl.w	3a94a <ull_conn_rx+0xd2>
			conn->llcp_enc.refresh = 0U;
   3ae6a:	f36f 0382 	bfc	r3, #2, #1
   3ae6e:	f884 3176 	strb.w	r3, [r4, #374]	; 0x176
			(*rx)->hdr.type = NODE_RX_TYPE_ENC_REFRESH;
   3ae72:	682b      	ldr	r3, [r5, #0]
   3ae74:	221a      	movs	r2, #26
   3ae76:	711a      	strb	r2, [r3, #4]
   3ae78:	e567      	b.n	3a94a <ull_conn_rx+0xd2>
   3ae7a:	bf00      	nop
   3ae7c:	200058f0 	.word	0x200058f0
   3ae80:	087830d0 	.word	0x087830d0
   3ae84:	20005384 	.word	0x20005384
   3ae88:	f994 0039 	ldrsb.w	r0, [r4, #57]	; 0x39
		if (!conn->lll.role ||
   3ae8c:	2800      	cmp	r0, #0
   3ae8e:	f6bf ad84 	bge.w	3a99a <ull_conn_rx+0x122>
   3ae92:	7f75      	ldrb	r5, [r6, #29]
   3ae94:	2d01      	cmp	r5, #1
   3ae96:	f47f ad80 	bne.w	3a99a <ull_conn_rx+0x122>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
   3ae9a:	48be      	ldr	r0, [pc, #760]	; (3b194 <ull_conn_rx+0x91c>)
   3ae9c:	f7f9 fb0c 	bl	344b8 <mem_acquire>
		if (!tx) {
   3aea0:	2800      	cmp	r0, #0
   3aea2:	f000 83b2 	beq.w	3b60a <ull_conn_rx+0xd92>
	conn->llcp_enc.pause_rx = 1U;
   3aea6:	f894 3176 	ldrb.w	r3, [r4, #374]	; 0x176
   3aeaa:	f023 0305 	bic.w	r3, r3, #5
   3aeae:	f043 0305 	orr.w	r3, r3, #5
   3aeb2:	f884 3176 	strb.w	r3, [r4, #374]	; 0x176
	conn->lll.enc_rx = 0U;
   3aeb6:	f894 307a 	ldrb.w	r3, [r4, #122]	; 0x7a
   3aeba:	f36f 03c3 	bfc	r3, #3, #1
   3aebe:	f884 307a 	strb.w	r3, [r4, #122]	; 0x7a
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   3aec2:	7903      	ldrb	r3, [r0, #4]
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, enc_rsp);
   3aec4:	7145      	strb	r5, [r0, #5]
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   3aec6:	f043 0303 	orr.w	r3, r3, #3
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PAUSE_ENC_RSP;
   3aeca:	210b      	movs	r1, #11
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   3aecc:	7103      	strb	r3, [r0, #4]
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PAUSE_ENC_RSP;
   3aece:	71c1      	strb	r1, [r0, #7]
	    conn->tx_head &&
   3aed0:	f8d4 31dc 	ldr.w	r3, [r4, #476]	; 0x1dc
	if (
   3aed4:	2b00      	cmp	r3, #0
   3aed6:	f000 834c 	beq.w	3b572 <ull_conn_rx+0xcfa>
	    !conn->llcp_cu.pause_tx &&
   3aeda:	f894 111a 	ldrb.w	r1, [r4, #282]	; 0x11a
	    conn->tx_head &&
   3aede:	06cd      	lsls	r5, r1, #27
   3aee0:	f100 8347 	bmi.w	3b572 <ull_conn_rx+0xcfa>
	    !conn->llcp_enc.pause_tx &&
   3aee4:	f894 1176 	ldrb.w	r1, [r4, #374]	; 0x176
	    !conn->llcp_cu.pause_tx &&
   3aee8:	0789      	lsls	r1, r1, #30
   3aeea:	f100 8342 	bmi.w	3b572 <ull_conn_rx+0xcfa>
	    !conn->llcp_phy.pause_tx &&
   3aeee:	f894 11d7 	ldrb.w	r1, [r4, #471]	; 0x1d7
   3aef2:	07ca      	lsls	r2, r1, #31
   3aef4:	f100 833d 	bmi.w	3b572 <ull_conn_rx+0xcfa>
		if (conn->tx_head == conn->tx_data) {
   3aef8:	f8d4 21e8 	ldr.w	r2, [r4, #488]	; 0x1e8
		if (!conn->tx_ctrl) {
   3aefc:	f8d4 11e0 	ldr.w	r1, [r4, #480]	; 0x1e0
		if (conn->tx_head == conn->tx_data) {
   3af00:	4293      	cmp	r3, r2
   3af02:	f000 8386 	beq.w	3b612 <ull_conn_rx+0xd9a>
		} else if (!conn->tx_ctrl) {
   3af06:	2900      	cmp	r1, #0
   3af08:	f47f ad86 	bne.w	3aa18 <ull_conn_rx+0x1a0>
	if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   3af0c:	7919      	ldrb	r1, [r3, #4]
   3af0e:	f001 0103 	and.w	r1, r1, #3
   3af12:	2903      	cmp	r1, #3
   3af14:	f47f ad78 	bne.w	3aa08 <ull_conn_rx+0x190>
	    ((pdu_data_tx->llctrl.opcode !=
   3af18:	79d9      	ldrb	r1, [r3, #7]
	if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   3af1a:	2903      	cmp	r1, #3
   3af1c:	d002      	beq.n	3af24 <ull_conn_rx+0x6ac>
	      PDU_DATA_LLCTRL_TYPE_ENC_REQ) &&
   3af1e:	290a      	cmp	r1, #10
   3af20:	f47f ad72 	bne.w	3aa08 <ull_conn_rx+0x190>
			tx->next = conn->tx_head->next;
   3af24:	681b      	ldr	r3, [r3, #0]
   3af26:	6003      	str	r3, [r0, #0]
			conn->tx_head->next = tx;
   3af28:	f8d4 31dc 	ldr.w	r3, [r4, #476]	; 0x1dc
   3af2c:	6018      	str	r0, [r3, #0]
				conn->tx_ctrl = tx;
   3af2e:	f8c4 01e0 	str.w	r0, [r4, #480]	; 0x1e0
				conn->tx_ctrl_last = tx;
   3af32:	e578      	b.n	3aa26 <ull_conn_rx+0x1ae>
   3af34:	f994 0039 	ldrsb.w	r0, [r4, #57]	; 0x39
		if (!conn->lll.role ||
   3af38:	2800      	cmp	r0, #0
   3af3a:	f6bf ad2e 	bge.w	3a99a <ull_conn_rx+0x122>
   3af3e:	7f73      	ldrb	r3, [r6, #29]
   3af40:	2b05      	cmp	r3, #5
   3af42:	f47f ad2a 	bne.w	3a99a <ull_conn_rx+0x122>
	if (!((ind->c_to_p_phy | ind->p_to_c_phy) & 0x07)) {
   3af46:	f896 2020 	ldrb.w	r2, [r6, #32]
   3af4a:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
   3af4e:	4313      	orrs	r3, r2
   3af50:	f013 0307 	ands.w	r3, r3, #7
   3af54:	f040 8656 	bne.w	3bc04 <ull_conn_rx+0x138c>
		if ((conn->llcp_phy.ack == conn->llcp_phy.req) ||
   3af58:	f894 11d4 	ldrb.w	r1, [r4, #468]	; 0x1d4
   3af5c:	f894 21d5 	ldrb.w	r2, [r4, #469]	; 0x1d5
   3af60:	428a      	cmp	r2, r1
   3af62:	f43f ace8 	beq.w	3a936 <ull_conn_rx+0xbe>
		    (conn->llcp_phy.state != LLCP_PHY_STATE_RSP_WAIT)) {
   3af66:	f894 21d6 	ldrb.w	r2, [r4, #470]	; 0x1d6
		if ((conn->llcp_phy.ack == conn->llcp_phy.req) ||
   3af6a:	f002 0203 	and.w	r2, r2, #3
   3af6e:	2a02      	cmp	r2, #2
   3af70:	f47f ace1 	bne.w	3a936 <ull_conn_rx+0xbe>
		conn->lll.phy_tx_time = conn->lll.phy_tx;
   3af74:	f894 2060 	ldrb.w	r2, [r4, #96]	; 0x60
		conn->llcp_phy.ack = conn->llcp_phy.req;
   3af78:	f884 11d5 	strb.w	r1, [r4, #469]	; 0x1d5
		conn->llcp_phy.pause_tx = 0U;
   3af7c:	f894 11d7 	ldrb.w	r1, [r4, #471]	; 0x1d7
		conn->procedure_expire = 0U;
   3af80:	f8a4 30c8 	strh.w	r3, [r4, #200]	; 0xc8
		conn->lll.phy_tx_time = conn->lll.phy_tx;
   3af84:	f3c2 0002 	ubfx	r0, r2, #0, #3
		conn->llcp_phy.pause_tx = 0U;
   3af88:	f363 0100 	bfi	r1, r3, #0, #1
		conn->lll.phy_tx_time = conn->lll.phy_tx;
   3af8c:	f360 1206 	bfi	r2, r0, #4, #3
   3af90:	f884 2060 	strb.w	r2, [r4, #96]	; 0x60
		if (!conn->llcp_phy.cmd) {
   3af94:	074a      	lsls	r2, r1, #29
		conn->llcp_phy.pause_tx = 0U;
   3af96:	f884 11d7 	strb.w	r1, [r4, #471]	; 0x1d7
		if (!conn->llcp_phy.cmd) {
   3af9a:	f57f acd3 	bpl.w	3a944 <ull_conn_rx+0xcc>
		(*rx)->hdr.type = NODE_RX_TYPE_PHY_UPDATE;
   3af9e:	682a      	ldr	r2, [r5, #0]
   3afa0:	211d      	movs	r1, #29
   3afa2:	7111      	strb	r1, [r2, #4]
   3afa4:	e637      	b.n	3ac16 <ull_conn_rx+0x39e>
   3afa6:	f994 0039 	ldrsb.w	r0, [r4, #57]	; 0x39
		if (conn->lll.role ||
   3afaa:	2800      	cmp	r0, #0
   3afac:	f6ff acf5 	blt.w	3a99a <ull_conn_rx+0x122>
   3afb0:	7f73      	ldrb	r3, [r6, #29]
   3afb2:	2b03      	cmp	r3, #3
   3afb4:	f47f acf1 	bne.w	3a99a <ull_conn_rx+0x122>
		if (!conn->lll.role &&
   3afb8:	f894 21d5 	ldrb.w	r2, [r4, #469]	; 0x1d5
   3afbc:	f894 31d4 	ldrb.w	r3, [r4, #468]	; 0x1d4
   3afc0:	429a      	cmp	r2, r3
   3afc2:	f43f acb8 	beq.w	3a936 <ull_conn_rx+0xbe>
		    (conn->llcp_phy.state == LLCP_PHY_STATE_RSP_WAIT)) {
   3afc6:	f894 31d6 	ldrb.w	r3, [r4, #470]	; 0x1d6
		    (conn->llcp_phy.ack != conn->llcp_phy.req) &&
   3afca:	f003 0203 	and.w	r2, r3, #3
   3afce:	2a02      	cmp	r2, #2
   3afd0:	f47f acb1 	bne.w	3a936 <ull_conn_rx+0xbe>
			conn->llcp_phy.state = LLCP_PHY_STATE_UPD;
   3afd4:	f043 0303 	orr.w	r3, r3, #3
   3afd8:	f884 31d6 	strb.w	r3, [r4, #470]	; 0x1d6
			conn->llcp_phy.tx &= p->rx_phys;
   3afdc:	f896 2021 	ldrb.w	r2, [r6, #33]	; 0x21
   3afe0:	f3c3 0182 	ubfx	r1, r3, #2, #3
   3afe4:	400a      	ands	r2, r1
   3afe6:	f362 0384 	bfi	r3, r2, #2, #3
   3afea:	f884 31d6 	strb.w	r3, [r4, #470]	; 0x1d6
			conn->llcp_phy.rx &= p->tx_phys;
   3afee:	f896 2020 	ldrb.w	r2, [r6, #32]
   3aff2:	f3c3 1142 	ubfx	r1, r3, #5, #3
   3aff6:	400a      	ands	r2, r1
   3aff8:	f362 1347 	bfi	r3, r2, #5, #3
			if (!conn->llcp_phy.tx || !conn->llcp_phy.rx) {
   3affc:	f003 021c 	and.w	r2, r3, #28
			conn->llcp_phy.rx &= p->tx_phys;
   3b000:	f884 31d6 	strb.w	r3, [r4, #470]	; 0x1d6
			if (!conn->llcp_phy.tx || !conn->llcp_phy.rx) {
   3b004:	b2db      	uxtb	r3, r3
   3b006:	b10a      	cbz	r2, 3b00c <ull_conn_rx+0x794>
   3b008:	2b1f      	cmp	r3, #31
   3b00a:	d805      	bhi.n	3b018 <ull_conn_rx+0x7a0>
				conn->llcp_phy.tx = 0U;
   3b00c:	f894 31d6 	ldrb.w	r3, [r4, #470]	; 0x1d6
   3b010:	f003 0303 	and.w	r3, r3, #3
   3b014:	f884 31d6 	strb.w	r3, [r4, #470]	; 0x1d6
			conn->llcp_phy.pause_tx = 1U;
   3b018:	f894 31d7 	ldrb.w	r3, [r4, #471]	; 0x1d7
			conn->procedure_expire = 0U;
   3b01c:	2200      	movs	r2, #0
			conn->llcp_phy.pause_tx = 1U;
   3b01e:	f043 0301 	orr.w	r3, r3, #1
   3b022:	f884 31d7 	strb.w	r3, [r4, #471]	; 0x1d7
			conn->procedure_expire = 0U;
   3b026:	f8a4 20c8 	strh.w	r2, [r4, #200]	; 0xc8
		(*rx)->hdr.type = NODE_RX_TYPE_RELEASE;
   3b02a:	682e      	ldr	r6, [r5, #0]
   3b02c:	e483      	b.n	3a936 <ull_conn_rx+0xbe>
   3b02e:	f994 0039 	ldrsb.w	r0, [r4, #57]	; 0x39
		if (conn->lll.role ||
   3b032:	2800      	cmp	r0, #0
   3b034:	f6ff acb1 	blt.w	3a99a <ull_conn_rx+0x122>
   3b038:	7f73      	ldrb	r3, [r6, #29]
   3b03a:	2b09      	cmp	r3, #9
   3b03c:	f47f acad 	bne.w	3a99a <ull_conn_rx+0x122>
		nack = feature_rsp_send(conn, *rx, pdu_rx);
   3b040:	4631      	mov	r1, r6
   3b042:	4620      	mov	r0, r4
}
   3b044:	b005      	add	sp, #20
   3b046:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		nack = feature_rsp_send(conn, *rx, pdu_rx);
   3b04a:	f7fe bc61 	b.w	39910 <feature_rsp_send>
   3b04e:	f994 0039 	ldrsb.w	r0, [r4, #57]	; 0x39
		if (conn->lll.role ||
   3b052:	2800      	cmp	r0, #0
   3b054:	f6ff aca1 	blt.w	3a99a <ull_conn_rx+0x122>
   3b058:	7f73      	ldrb	r3, [r6, #29]
   3b05a:	2b18      	cmp	r3, #24
   3b05c:	f47f ac9d 	bne.w	3a99a <ull_conn_rx+0x122>
		if (!conn->lll.role &&
   3b060:	f894 2194 	ldrb.w	r2, [r4, #404]	; 0x194
   3b064:	f894 3195 	ldrb.w	r3, [r4, #405]	; 0x195
   3b068:	429a      	cmp	r2, r3
   3b06a:	f43f ac64 	beq.w	3a936 <ull_conn_rx+0xbe>
		    (conn->llcp_conn_param.state ==
   3b06e:	f894 3196 	ldrb.w	r3, [r4, #406]	; 0x196
		     conn->llcp_conn_param.ack) &&
   3b072:	f003 030f 	and.w	r3, r3, #15
   3b076:	2b04      	cmp	r3, #4
   3b078:	f47f ac5d 	bne.w	3a936 <ull_conn_rx+0xbe>
			uint16_t interval_min = sys_le16_to_cpu(cpr->interval_min);
   3b07c:	6a37      	ldr	r7, [r6, #32]
   3b07e:	6a70      	ldr	r0, [r6, #36]	; 0x24
				cpr->preferred_periodicity;
   3b080:	f896 c028 	ldrb.w	ip, [r6, #40]	; 0x28
			if ((interval_min < CONN_INTERVAL_MIN(conn)) ||
   3b084:	b2bb      	uxth	r3, r7
   3b086:	2b05      	cmp	r3, #5
   3b088:	f240 8577 	bls.w	3bb7a <ull_conn_rx+0x1302>
   3b08c:	0c39      	lsrs	r1, r7, #16
   3b08e:	f5b1 6f48 	cmp.w	r1, #3200	; 0xc80
   3b092:	f200 8572 	bhi.w	3bb7a <ull_conn_rx+0x1302>
			    (interval_max > 3200) ||
   3b096:	428b      	cmp	r3, r1
   3b098:	f200 856f 	bhi.w	3bb7a <ull_conn_rx+0x1302>
   3b09c:	b283      	uxth	r3, r0
			    (interval_min > interval_max) ||
   3b09e:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
   3b0a2:	f080 856a 	bcs.w	3bb7a <ull_conn_rx+0x1302>
   3b0a6:	ea4f 4e10 	mov.w	lr, r0, lsr #16
			    (latency > 499) ||
   3b0aa:	f1ae 020a 	sub.w	r2, lr, #10
   3b0ae:	b292      	uxth	r2, r2
   3b0b0:	f640 4876 	movw	r8, #3190	; 0xc76
   3b0b4:	4542      	cmp	r2, r8
   3b0b6:	f200 8560 	bhi.w	3bb7a <ull_conn_rx+0x1302>
			     ((latency + 1) * interval_max)) ||
   3b0ba:	3301      	adds	r3, #1
   3b0bc:	b29b      	uxth	r3, r3
   3b0be:	fb01 f303 	mul.w	r3, r1, r3
			    (timeout < 10) || (timeout > 3200) ||
   3b0c2:	ebb3 0f8e 	cmp.w	r3, lr, lsl #2
   3b0c6:	f080 8558 	bcs.w	3bb7a <ull_conn_rx+0x1302>
			     ((latency + 1) * interval_max)) ||
   3b0ca:	458c      	cmp	ip, r1
   3b0cc:	f200 8555 	bhi.w	3bb7a <ull_conn_rx+0x1302>
			conn->llcp_conn_param.state = LLCP_CPR_STATE_RSP;
   3b0d0:	f894 3196 	ldrb.w	r3, [r4, #406]	; 0x196
			conn->llcp_conn_param.preferred_periodicity =
   3b0d4:	f884 c1a8 	strb.w	ip, [r4, #424]	; 0x1a8
			conn->llcp_conn_param.interval_min = interval_min;
   3b0d8:	e9c4 7066 	strd	r7, r0, [r4, #408]	; 0x198
			conn->llcp_conn_param.state = LLCP_CPR_STATE_RSP;
   3b0dc:	2201      	movs	r2, #1
   3b0de:	f362 0303 	bfi	r3, r2, #0, #4
			conn->procedure_expire = 0U;
   3b0e2:	2200      	movs	r2, #0
   3b0e4:	f8a4 20c8 	strh.w	r2, [r4, #200]	; 0xc8
				sys_le16_to_cpu(cpr->reference_conn_event_count);
   3b0e8:	f8b6 2029 	ldrh.w	r2, [r6, #41]	; 0x29
			conn->llcp_conn_param.reference_conn_event_count =
   3b0ec:	f8a4 21aa 	strh.w	r2, [r4, #426]	; 0x1aa
				sys_le16_to_cpu(cpr->offset0);
   3b0f0:	f8b6 202b 	ldrh.w	r2, [r6, #43]	; 0x2b
			conn->llcp_conn_param.offset0 =
   3b0f4:	f8a4 21ac 	strh.w	r2, [r4, #428]	; 0x1ac
				sys_le16_to_cpu(cpr->offset1);
   3b0f8:	f8b6 202d 	ldrh.w	r2, [r6, #45]	; 0x2d
			conn->llcp_conn_param.offset1 =
   3b0fc:	f8a4 21ae 	strh.w	r2, [r4, #430]	; 0x1ae
				sys_le16_to_cpu(cpr->offset2);
   3b100:	f8b6 202f 	ldrh.w	r2, [r6, #47]	; 0x2f
			conn->llcp_conn_param.offset2 =
   3b104:	f8a4 21b0 	strh.w	r2, [r4, #432]	; 0x1b0
				sys_le16_to_cpu(cpr->offset3);
   3b108:	f8b6 2031 	ldrh.w	r2, [r6, #49]	; 0x31
			conn->llcp_conn_param.offset3 =
   3b10c:	f8a4 21b2 	strh.w	r2, [r4, #434]	; 0x1b2
				sys_le16_to_cpu(cpr->offset4);
   3b110:	f8b6 2033 	ldrh.w	r2, [r6, #51]	; 0x33
			conn->llcp_conn_param.offset4 =
   3b114:	f8a4 21b4 	strh.w	r2, [r4, #436]	; 0x1b4
				sys_le16_to_cpu(cpr->offset5);
   3b118:	f8b6 2035 	ldrh.w	r2, [r6, #53]	; 0x35
			conn->llcp_conn_param.offset5 =
   3b11c:	f8a4 21b6 	strh.w	r2, [r4, #438]	; 0x1b6
			conn->llcp_conn_param.state = LLCP_CPR_STATE_RSP;
   3b120:	f884 3196 	strb.w	r3, [r4, #406]	; 0x196
		(*rx)->hdr.type = NODE_RX_TYPE_RELEASE;
   3b124:	682e      	ldr	r6, [r5, #0]
   3b126:	e406      	b.n	3a936 <ull_conn_rx+0xbe>
   3b128:	f994 0039 	ldrsb.w	r0, [r4, #57]	; 0x39
		if (!conn->lll.role ||
   3b12c:	2800      	cmp	r0, #0
   3b12e:	f6bf ac34 	bge.w	3a99a <ull_conn_rx+0x122>
   3b132:	7f73      	ldrb	r3, [r6, #29]
   3b134:	2b08      	cmp	r3, #8
   3b136:	f47f ac30 	bne.w	3a99a <ull_conn_rx+0x122>
	instant = sys_le16_to_cpu(pdu->llctrl.chan_map_ind.instant);
   3b13a:	f8b6 5025 	ldrh.w	r5, [r6, #37]	; 0x25
	if (((instant - conn->lll.event_counter) & 0xffff) > 0x7fff) {
   3b13e:	8e63      	ldrh	r3, [r4, #50]	; 0x32
   3b140:	1aeb      	subs	r3, r5, r3
   3b142:	041f      	lsls	r7, r3, #16
   3b144:	f100 8606 	bmi.w	3bd54 <ull_conn_rx+0x14dc>
	if (((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) {
   3b148:	f894 30f0 	ldrb.w	r3, [r4, #240]	; 0xf0
   3b14c:	f894 20f1 	ldrb.w	r2, [r4, #241]	; 0xf1
   3b150:	1a9b      	subs	r3, r3, r2
   3b152:	f003 0303 	and.w	r3, r3, #3
   3b156:	2b02      	cmp	r3, #2
   3b158:	f000 85f5 	beq.w	3bd46 <ull_conn_rx+0x14ce>
	memcpy(&conn->llcp.chan_map.chm[0], &pdu->llctrl.chan_map_ind.chm[0],
   3b15c:	2205      	movs	r2, #5
   3b15e:	f106 0120 	add.w	r1, r6, #32
   3b162:	f104 00f5 	add.w	r0, r4, #245	; 0xf5
   3b166:	f00f fe88 	bl	4ae7a <memcpy>
	conn->llcp.chan_map.initiate = 0U;
   3b16a:	f894 20f4 	ldrb.w	r2, [r4, #244]	; 0xf4
	conn->llcp_ack -= 2U;
   3b16e:	f894 30f1 	ldrb.w	r3, [r4, #241]	; 0xf1
	conn->llcp.chan_map.instant = instant;
   3b172:	f8a4 50fa 	strh.w	r5, [r4, #250]	; 0xfa
	conn->llcp.chan_map.initiate = 0U;
   3b176:	f36f 0200 	bfc	r2, #0, #1
   3b17a:	f884 20f4 	strb.w	r2, [r4, #244]	; 0xf4
	conn->llcp_type = LLCP_CHAN_MAP;
   3b17e:	2102      	movs	r1, #2
	conn->llcp_ack -= 2U;
   3b180:	3b02      	subs	r3, #2
	rx->hdr.type = NODE_RX_TYPE_RELEASE;
   3b182:	2201      	movs	r2, #1
	conn->llcp_type = LLCP_CHAN_MAP;
   3b184:	f884 10f2 	strb.w	r1, [r4, #242]	; 0xf2
	conn->llcp_ack -= 2U;
   3b188:	f884 30f1 	strb.w	r3, [r4, #241]	; 0xf1
	rx->hdr.type = NODE_RX_TYPE_RELEASE;
   3b18c:	7132      	strb	r2, [r6, #4]
		if (err) {
   3b18e:	f7ff bbdc 	b.w	3a94a <ull_conn_rx+0xd2>
   3b192:	bf00      	nop
   3b194:	20005384 	.word	0x20005384
   3b198:	f994 0039 	ldrsb.w	r0, [r4, #57]	; 0x39
		if (!conn->lll.role ||
   3b19c:	2800      	cmp	r0, #0
   3b19e:	f6bf abfc 	bge.w	3a99a <ull_conn_rx+0x122>
   3b1a2:	7f73      	ldrb	r3, [r6, #29]
   3b1a4:	2b0c      	cmp	r3, #12
   3b1a6:	f47f abf8 	bne.w	3a99a <ull_conn_rx+0x122>
	instant = sys_le16_to_cpu(pdu->llctrl.conn_update_ind.instant);
   3b1aa:	f8b6 2029 	ldrh.w	r2, [r6, #41]	; 0x29
	if (((instant - conn->lll.event_counter) & 0xFFFF) > 0x7FFF) {
   3b1ae:	8e63      	ldrh	r3, [r4, #50]	; 0x32
   3b1b0:	1ad3      	subs	r3, r2, r3
   3b1b2:	041b      	lsls	r3, r3, #16
   3b1b4:	f100 85ce 	bmi.w	3bd54 <ull_conn_rx+0x14dc>
	if (((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) {
   3b1b8:	f894 30f0 	ldrb.w	r3, [r4, #240]	; 0xf0
   3b1bc:	f894 10f1 	ldrb.w	r1, [r4, #241]	; 0xf1
   3b1c0:	1a5b      	subs	r3, r3, r1
   3b1c2:	f003 0303 	and.w	r3, r3, #3
   3b1c6:	2b02      	cmp	r3, #2
   3b1c8:	f000 85bd 	beq.w	3bd46 <ull_conn_rx+0x14ce>
	if (!conn_upd_curr) {
   3b1cc:	4bd6      	ldr	r3, [pc, #856]	; (3b528 <ull_conn_rx+0xcb0>)
   3b1ce:	6819      	ldr	r1, [r3, #0]
   3b1d0:	2900      	cmp	r1, #0
   3b1d2:	f000 85ca 	beq.w	3bd6a <ull_conn_rx+0x14f2>
	conn->llcp_cu.win_size = pdu->llctrl.conn_update_ind.win_size;
   3b1d6:	f896 3020 	ldrb.w	r3, [r6, #32]
   3b1da:	f884 3128 	strb.w	r3, [r4, #296]	; 0x128
		sys_le16_to_cpu(pdu->llctrl.conn_update_ind.win_offset) *
   3b1de:	f8b6 3021 	ldrh.w	r3, [r6, #33]	; 0x21
   3b1e2:	f240 41e2 	movw	r1, #1250	; 0x4e2
   3b1e6:	fb01 f303 	mul.w	r3, r1, r3
	conn->llcp_cu.win_offset_us =
   3b1ea:	f8c4 3124 	str.w	r3, [r4, #292]	; 0x124
		sys_le16_to_cpu(pdu->llctrl.conn_update_ind.interval);
   3b1ee:	f8b6 3023 	ldrh.w	r3, [r6, #35]	; 0x23
	conn->llcp_cu.interval =
   3b1f2:	f8a4 311c 	strh.w	r3, [r4, #284]	; 0x11c
	conn->llcp_cu.state = LLCP_CUI_STATE_INPROG;
   3b1f6:	f894 311a 	ldrb.w	r3, [r4, #282]	; 0x11a
		sys_le16_to_cpu(pdu->llctrl.conn_update_ind.latency);
   3b1fa:	f8b6 1025 	ldrh.w	r1, [r6, #37]	; 0x25
	conn->llcp_cu.latency =
   3b1fe:	f8a4 111e 	strh.w	r1, [r4, #286]	; 0x11e
	conn->llcp_cu.state = LLCP_CUI_STATE_INPROG;
   3b202:	f023 030f 	bic.w	r3, r3, #15
   3b206:	f043 0308 	orr.w	r3, r3, #8
		sys_le16_to_cpu(pdu->llctrl.conn_update_ind.timeout);
   3b20a:	f8b6 1027 	ldrh.w	r1, [r6, #39]	; 0x27
	conn->llcp_cu.state = LLCP_CUI_STATE_INPROG;
   3b20e:	f884 311a 	strb.w	r3, [r4, #282]	; 0x11a
	conn->llcp_cu.ack--;
   3b212:	f894 3119 	ldrb.w	r3, [r4, #281]	; 0x119
	conn->llcp.conn_upd.instant = instant;
   3b216:	f8a4 20f4 	strh.w	r2, [r4, #244]	; 0xf4
	conn->llcp_cu.ack--;
   3b21a:	3b01      	subs	r3, #1
	link->mem = conn->llcp_rx;
   3b21c:	f8d4 2114 	ldr.w	r2, [r4, #276]	; 0x114
	conn->llcp_cu.timeout =
   3b220:	f8a4 1120 	strh.w	r1, [r4, #288]	; 0x120
	conn->llcp_cu.ack--;
   3b224:	f884 3119 	strb.w	r3, [r4, #281]	; 0x119
	link->mem = conn->llcp_rx;
   3b228:	607a      	str	r2, [r7, #4]
	(*rx)->hdr.link = link;
   3b22a:	682b      	ldr	r3, [r5, #0]
   3b22c:	601f      	str	r7, [r3, #0]
	conn->llcp_rx = *rx;
   3b22e:	682b      	ldr	r3, [r5, #0]
   3b230:	f8c4 3114 	str.w	r3, [r4, #276]	; 0x114
	*rx = NULL;
   3b234:	2100      	movs	r1, #0
   3b236:	6029      	str	r1, [r5, #0]
	if ((conn->llcp_conn_param.req != conn->llcp_conn_param.ack) &&
   3b238:	f894 2194 	ldrb.w	r2, [r4, #404]	; 0x194
   3b23c:	f894 3195 	ldrb.w	r3, [r4, #405]	; 0x195
   3b240:	4293      	cmp	r3, r2
   3b242:	f43f adeb 	beq.w	3ae1c <ull_conn_rx+0x5a4>
	    ((conn->llcp_conn_param.state == LLCP_CPR_STATE_RSP_WAIT) ||
   3b246:	f894 3196 	ldrb.w	r3, [r4, #406]	; 0x196
	if ((conn->llcp_conn_param.req != conn->llcp_conn_param.ack) &&
   3b24a:	f003 030e 	and.w	r3, r3, #14
   3b24e:	2b04      	cmp	r3, #4
   3b250:	f47f ade4 	bne.w	3ae1c <ull_conn_rx+0x5a4>
	if (conn->llcp_conn_param.cache.timeout) {
   3b254:	f8b4 01a6 	ldrh.w	r0, [r4, #422]	; 0x1a6
   3b258:	2800      	cmp	r0, #0
   3b25a:	f000 86c8 	beq.w	3bfee <ull_conn_rx+0x1776>
		conn->llcp_conn_param.state = LLCP_CPR_STATE_REQ;
   3b25e:	f8b4 3196 	ldrh.w	r3, [r4, #406]	; 0x196
		conn->llcp_conn_param.interval_min =
   3b262:	f8d4 21a0 	ldr.w	r2, [r4, #416]	; 0x1a0
   3b266:	f8c4 2198 	str.w	r2, [r4, #408]	; 0x198
		conn->llcp_conn_param.state = LLCP_CPR_STATE_REQ;
   3b26a:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
		conn->llcp_conn_param.latency =
   3b26e:	f8b4 21a4 	ldrh.w	r2, [r4, #420]	; 0x1a4
   3b272:	f8a4 219c 	strh.w	r2, [r4, #412]	; 0x19c
		conn->llcp_conn_param.state = LLCP_CPR_STATE_REQ;
   3b276:	f043 0310 	orr.w	r3, r3, #16
		conn->llcp_conn_param.timeout =
   3b27a:	f8a4 019e 	strh.w	r0, [r4, #414]	; 0x19e
		conn->llcp_conn_param.state = LLCP_CPR_STATE_REQ;
   3b27e:	f8a4 3196 	strh.w	r3, [r4, #406]	; 0x196
		conn->llcp_conn_param.cache.timeout = 0U;
   3b282:	f8a4 11a6 	strh.w	r1, [r4, #422]	; 0x1a6
		if (err) {
   3b286:	e5c9      	b.n	3ae1c <ull_conn_rx+0x5a4>
   3b288:	f994 0039 	ldrsb.w	r0, [r4, #57]	; 0x39
#endif /* CONFIG_BT_CTLR_PHY */

#if defined(CONFIG_BT_CTLR_MIN_USED_CHAN)
#if defined(CONFIG_BT_CENTRAL)
	case PDU_DATA_LLCTRL_TYPE_MIN_USED_CHAN_IND:
		if (conn->lll.role ||
   3b28c:	2800      	cmp	r0, #0
   3b28e:	f6ff ab84 	blt.w	3a99a <ull_conn_rx+0x122>
   3b292:	7f73      	ldrb	r3, [r6, #29]
   3b294:	2b03      	cmp	r3, #3
   3b296:	f47f ab80 	bne.w	3a99a <ull_conn_rx+0x122>
		if (!conn->lll.role) {
			struct pdu_data_llctrl_min_used_chans_ind *p =
				&pdu_rx->llctrl.min_used_chans_ind;

#if defined(CONFIG_BT_CTLR_PHY)
			if (!(p->phys & (conn->lll.phy_tx |
   3b29a:	f894 1060 	ldrb.w	r1, [r4, #96]	; 0x60
					 conn->lll.phy_rx))) {
   3b29e:	f894 3061 	ldrb.w	r3, [r4, #97]	; 0x61
			if (!(p->phys & (conn->lll.phy_tx |
   3b2a2:	f896 2020 	ldrb.w	r2, [r6, #32]
   3b2a6:	430b      	orrs	r3, r1
   3b2a8:	f003 0307 	and.w	r3, r3, #7
   3b2ac:	4213      	tst	r3, r2
   3b2ae:	f43f ab4c 	beq.w	3a94a <ull_conn_rx+0xd2>
			if (!(p->phys & 0x01)) {
#endif /* !CONFIG_BT_CTLR_PHY */
				break;
			}

			if (((conn->llcp_req - conn->llcp_ack) & 0x03) ==
   3b2b2:	f894 30f0 	ldrb.w	r3, [r4, #240]	; 0xf0
   3b2b6:	f894 20f1 	ldrb.w	r2, [r4, #241]	; 0xf1
   3b2ba:	1a9b      	subs	r3, r3, r2
   3b2bc:	f003 0303 	and.w	r3, r3, #3
   3b2c0:	2b02      	cmp	r3, #2
   3b2c2:	f43f ab42 	beq.w	3a94a <ull_conn_rx+0xd2>
			    0x02) {
				break;
			}

			ull_chan_map_get(conn->llcp.chan_map.chm);
   3b2c6:	f104 00f5 	add.w	r0, r4, #245	; 0xf5
   3b2ca:	f003 fe2f 	bl	3ef2c <ull_chan_map_get>
			/* conn->llcp.chan_map.instant = 0U; filled in initiate
			 * state.
			 */
			conn->llcp.chan_map.initiate = 1U;
   3b2ce:	f894 20f4 	ldrb.w	r2, [r4, #244]	; 0xf4

			conn->llcp_type = LLCP_CHAN_MAP;
			conn->llcp_ack -= 2U;
   3b2d2:	f894 30f1 	ldrb.w	r3, [r4, #241]	; 0xf1
			conn->llcp.chan_map.initiate = 1U;
   3b2d6:	f042 0201 	orr.w	r2, r2, #1
			conn->llcp_ack -= 2U;
   3b2da:	3b02      	subs	r3, #2
			conn->llcp_type = LLCP_CHAN_MAP;
   3b2dc:	2102      	movs	r1, #2
			conn->llcp.chan_map.initiate = 1U;
   3b2de:	f884 20f4 	strb.w	r2, [r4, #244]	; 0xf4
			conn->llcp_type = LLCP_CHAN_MAP;
   3b2e2:	f884 10f2 	strb.w	r1, [r4, #242]	; 0xf2
			conn->llcp_ack -= 2U;
   3b2e6:	f884 30f1 	strb.w	r3, [r4, #241]	; 0xf1
		}

		/* Mark for buffer for release */
		(*rx)->hdr.type = NODE_RX_TYPE_RELEASE;
   3b2ea:	682b      	ldr	r3, [r5, #0]
   3b2ec:	2201      	movs	r2, #1
   3b2ee:	711a      	strb	r2, [r3, #4]

		break;
   3b2f0:	f7ff bb2b 	b.w	3a94a <ull_conn_rx+0xd2>
   3b2f4:	f994 0039 	ldrsb.w	r0, [r4, #57]	; 0x39
		if (conn->lll.role || (conn->llcp_req == conn->llcp_ack) ||
   3b2f8:	2800      	cmp	r0, #0
   3b2fa:	f6ff ab4e 	blt.w	3a99a <ull_conn_rx+0x122>
   3b2fe:	f894 20f0 	ldrb.w	r2, [r4, #240]	; 0xf0
   3b302:	f894 30f1 	ldrb.w	r3, [r4, #241]	; 0xf1
   3b306:	429a      	cmp	r2, r3
   3b308:	f43f ab47 	beq.w	3a99a <ull_conn_rx+0x122>
   3b30c:	f894 30f2 	ldrb.w	r3, [r4, #242]	; 0xf2
   3b310:	2b03      	cmp	r3, #3
   3b312:	f47f ab42 	bne.w	3a99a <ull_conn_rx+0x122>
		    (conn->llcp_type != LLCP_ENCRYPTION) ||
   3b316:	7f73      	ldrb	r3, [r6, #29]
   3b318:	2b01      	cmp	r3, #1
   3b31a:	f47f ab3e 	bne.w	3a99a <ull_conn_rx+0x122>
		conn->llcp.encryption.state = LLCP_ENC_STATE_INPROG;
   3b31e:	f894 2100 	ldrb.w	r2, [r4, #256]	; 0x100
   3b322:	f36f 0201 	bfc	r2, #0, #2
   3b326:	f884 2100 	strb.w	r2, [r4, #256]	; 0x100
		(*rx)->hdr.type = NODE_RX_TYPE_RELEASE;
   3b32a:	682a      	ldr	r2, [r5, #0]
   3b32c:	7113      	strb	r3, [r2, #4]
		break;
   3b32e:	f7ff bb0c 	b.w	3a94a <ull_conn_rx+0xd2>
   3b332:	f994 0039 	ldrsb.w	r0, [r4, #57]	; 0x39
		if (conn->lll.role ||
   3b336:	2800      	cmp	r0, #0
   3b338:	f6ff ab2f 	blt.w	3a99a <ull_conn_rx+0x122>
   3b33c:	7f73      	ldrb	r3, [r6, #29]
   3b33e:	2b0d      	cmp	r3, #13
   3b340:	f47f ab2b 	bne.w	3a99a <ull_conn_rx+0x122>
		memcpy(&conn->llcp.encryption.skd[8],
   3b344:	2208      	movs	r2, #8
   3b346:	f106 0120 	add.w	r1, r6, #32
   3b34a:	f504 7085 	add.w	r0, r4, #266	; 0x10a
   3b34e:	f00f fd94 	bl	4ae7a <memcpy>
		memcpy(&conn->lll.ccm_rx.iv[4],
   3b352:	2204      	movs	r2, #4
   3b354:	f106 0128 	add.w	r1, r6, #40	; 0x28
   3b358:	f104 0098 	add.w	r0, r4, #152	; 0x98
   3b35c:	f00f fd8d 	bl	4ae7a <memcpy>
		conn->llcp_enc.pause_rx = 1U;
   3b360:	f894 3176 	ldrb.w	r3, [r4, #374]	; 0x176
		(*rx)->hdr.type = NODE_RX_TYPE_RELEASE;
   3b364:	2201      	movs	r2, #1
		conn->llcp_enc.pause_rx = 1U;
   3b366:	4313      	orrs	r3, r2
   3b368:	f884 3176 	strb.w	r3, [r4, #374]	; 0x176
		(*rx)->hdr.type = NODE_RX_TYPE_RELEASE;
   3b36c:	682b      	ldr	r3, [r5, #0]
   3b36e:	711a      	strb	r2, [r3, #4]
		break;
   3b370:	f7ff baeb 	b.w	3a94a <ull_conn_rx+0xd2>
   3b374:	f994 0039 	ldrsb.w	r0, [r4, #57]	; 0x39
		if (!conn->lll.role ||
   3b378:	2800      	cmp	r0, #0
   3b37a:	f6bf ab0e 	bge.w	3a99a <ull_conn_rx+0x122>
   3b37e:	7f73      	ldrb	r3, [r6, #29]
   3b380:	2b17      	cmp	r3, #23
   3b382:	f47f ab0a 	bne.w	3a99a <ull_conn_rx+0x122>
		if (unlikely(((conn->llcp_req - conn->llcp_ack) & 0x03) ==
   3b386:	f894 20f1 	ldrb.w	r2, [r4, #241]	; 0xf1
   3b38a:	f894 30f0 	ldrb.w	r3, [r4, #240]	; 0xf0
   3b38e:	1a9b      	subs	r3, r3, r2
   3b390:	f003 0303 	and.w	r3, r3, #3
   3b394:	2b02      	cmp	r3, #2
   3b396:	f000 851e 	beq.w	3bdd6 <ull_conn_rx+0x155e>
		memcpy(&conn->llcp_enc.rand[0],
   3b39a:	2208      	movs	r2, #8
   3b39c:	f106 0120 	add.w	r1, r6, #32
   3b3a0:	f204 1079 	addw	r0, r4, #377	; 0x179
   3b3a4:	f00f fd69 	bl	4ae7a <memcpy>
		conn->llcp_enc.ediv[0] = pdu_rx->llctrl.enc_req.ediv[0];
   3b3a8:	f896 3028 	ldrb.w	r3, [r6, #40]	; 0x28
   3b3ac:	f884 3177 	strb.w	r3, [r4, #375]	; 0x177
		conn->llcp_enc.ediv[1] = pdu_rx->llctrl.enc_req.ediv[1];
   3b3b0:	f896 3029 	ldrb.w	r3, [r6, #41]	; 0x29
		conn->llcp.encryption.state = LLCP_ENC_STATE_INIT;
   3b3b4:	f894 2100 	ldrb.w	r2, [r4, #256]	; 0x100
		conn->llcp_enc.ediv[1] = pdu_rx->llctrl.enc_req.ediv[1];
   3b3b8:	f884 3178 	strb.w	r3, [r4, #376]	; 0x178
		conn->llcp.encryption.state = LLCP_ENC_STATE_INIT;
   3b3bc:	2301      	movs	r3, #1
   3b3be:	f363 0201 	bfi	r2, r3, #0, #2
   3b3c2:	f884 2100 	strb.w	r2, [r4, #256]	; 0x100
		(*rx)->hdr.type = NODE_RX_TYPE_RELEASE;
   3b3c6:	682a      	ldr	r2, [r5, #0]
   3b3c8:	7113      	strb	r3, [r2, #4]
		conn->llcp_ack -= 2U;
   3b3ca:	f894 30f1 	ldrb.w	r3, [r4, #241]	; 0xf1
		conn->llcp_type = LLCP_ENCRYPTION;
   3b3ce:	2103      	movs	r1, #3
		conn->llcp_ack -= 2U;
   3b3d0:	3b02      	subs	r3, #2
   3b3d2:	f884 30f1 	strb.w	r3, [r4, #241]	; 0xf1
		memcpy(&conn->llcp.encryption.skd[0],
   3b3d6:	2208      	movs	r2, #8
		conn->llcp_type = LLCP_ENCRYPTION;
   3b3d8:	f884 10f2 	strb.w	r1, [r4, #242]	; 0xf2
		memcpy(&conn->llcp.encryption.skd[0],
   3b3dc:	f504 7081 	add.w	r0, r4, #258	; 0x102
   3b3e0:	f106 012a 	add.w	r1, r6, #42	; 0x2a
   3b3e4:	f00f fd49 	bl	4ae7a <memcpy>
		memcpy(&conn->lll.ccm_rx.iv[0],
   3b3e8:	2204      	movs	r2, #4
   3b3ea:	f106 0132 	add.w	r1, r6, #50	; 0x32
   3b3ee:	f104 0094 	add.w	r0, r4, #148	; 0x94
   3b3f2:	f00f fd42 	bl	4ae7a <memcpy>
		conn->llcp_enc.pause_rx = 1U;
   3b3f6:	f894 3176 	ldrb.w	r3, [r4, #374]	; 0x176
		conn->procedure_expire = conn->procedure_reload;
   3b3fa:	f8b4 20c6 	ldrh.w	r2, [r4, #198]	; 0xc6
   3b3fe:	f8a4 20c8 	strh.w	r2, [r4, #200]	; 0xc8
		conn->llcp_enc.pause_rx = 1U;
   3b402:	f043 0301 	orr.w	r3, r3, #1
   3b406:	f884 3176 	strb.w	r3, [r4, #374]	; 0x176
		break;
   3b40a:	f7ff ba9e 	b.w	3a94a <ull_conn_rx+0xd2>
		if (PDU_DATA_LLCTRL_LEN(pause_enc_rsp) != pdu_rx->len) {
   3b40e:	7f75      	ldrb	r5, [r6, #29]
   3b410:	2d01      	cmp	r5, #1
   3b412:	f47f aac2 	bne.w	3a99a <ull_conn_rx+0x122>
	} else if (!conn->lll.role) {
   3b416:	f994 3039 	ldrsb.w	r3, [r4, #57]	; 0x39
   3b41a:	2b00      	cmp	r3, #0
   3b41c:	f2c0 80ed 	blt.w	3b5fa <ull_conn_rx+0xd82>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
   3b420:	4842      	ldr	r0, [pc, #264]	; (3b52c <ull_conn_rx+0xcb4>)
   3b422:	f7f9 f849 	bl	344b8 <mem_acquire>
		if (!tx) {
   3b426:	2800      	cmp	r0, #0
   3b428:	f000 80ef 	beq.w	3b60a <ull_conn_rx+0xd92>
	conn->llcp_enc.pause_rx = 1U;
   3b42c:	f894 3176 	ldrb.w	r3, [r4, #374]	; 0x176
   3b430:	f043 0301 	orr.w	r3, r3, #1
   3b434:	f884 3176 	strb.w	r3, [r4, #374]	; 0x176
	conn->lll.enc_rx = 0U;
   3b438:	f894 307a 	ldrb.w	r3, [r4, #122]	; 0x7a
   3b43c:	f023 0318 	bic.w	r3, r3, #24
   3b440:	e53d      	b.n	3aebe <ull_conn_rx+0x646>
		if (conn->llcp_length.ack != conn->llcp_length.req) {
   3b442:	f894 31c4 	ldrb.w	r3, [r4, #452]	; 0x1c4
   3b446:	f894 21c5 	ldrb.w	r2, [r4, #453]	; 0x1c5
   3b44a:	429a      	cmp	r2, r3
   3b44c:	f43f aa73 	beq.w	3a936 <ull_conn_rx+0xbe>
	conn->llcp_length.ack = conn->llcp_length.req;
   3b450:	f884 31c5 	strb.w	r3, [r4, #453]	; 0x1c5
	conn->procedure_expire = 0U;
   3b454:	2100      	movs	r1, #0
	pdu_rx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_RSP;
   3b456:	2315      	movs	r3, #21
	pdu_rx->len = offsetof(struct pdu_data_llctrl, length_rsp) +
   3b458:	2209      	movs	r2, #9
	conn->procedure_expire = 0U;
   3b45a:	f8a4 10c8 	strh.w	r1, [r4, #200]	; 0xc8
	pdu_rx->len = offsetof(struct pdu_data_llctrl, length_rsp) +
   3b45e:	7772      	strb	r2, [r6, #29]
	pdu_rx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_RSP;
   3b460:	77f3      	strb	r3, [r6, #31]
	lr->max_rx_octets = sys_cpu_to_le16(conn->lll.max_rx_octets);
   3b462:	f8b4 305a 	ldrh.w	r3, [r4, #90]	; 0x5a
   3b466:	8433      	strh	r3, [r6, #32]
	lr->max_tx_octets = sys_cpu_to_le16(conn->lll.max_tx_octets);
   3b468:	f8b4 3058 	ldrh.w	r3, [r4, #88]	; 0x58
   3b46c:	84b3      	strh	r3, [r6, #36]	; 0x24
	lr->max_rx_time = sys_cpu_to_le16(conn->lll.max_rx_time);
   3b46e:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
   3b472:	8473      	strh	r3, [r6, #34]	; 0x22
	lr->max_tx_time = sys_cpu_to_le16(conn->lll.max_tx_time);
   3b474:	f8b4 305c 	ldrh.w	r3, [r4, #92]	; 0x5c
   3b478:	84f3      	strh	r3, [r6, #38]	; 0x26
	if (err) {
   3b47a:	f7ff ba66 	b.w	3a94a <ull_conn_rx+0xd2>
		if (conn->llcp_conn_param.ack != conn->llcp_conn_param.req) {
   3b47e:	f894 1194 	ldrb.w	r1, [r4, #404]	; 0x194
   3b482:	f894 3195 	ldrb.w	r3, [r4, #405]	; 0x195
   3b486:	428b      	cmp	r3, r1
   3b488:	f43f aa55 	beq.w	3a936 <ull_conn_rx+0xbe>
	if (!lll->role && (rej_ext_ind->error_code ==
   3b48c:	f994 0039 	ldrsb.w	r0, [r4, #57]	; 0x39
	return ((uint16_t)src[1] << 8) | src[0];
   3b490:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
   3b494:	2800      	cmp	r0, #0
   3b496:	f2c0 85a2 	blt.w	3bfde <ull_conn_rx+0x1766>
   3b49a:	2b1a      	cmp	r3, #26
   3b49c:	f000 85ab 	beq.w	3bff6 <ull_conn_rx+0x177e>
	if (conn->llcp_conn_param.state == LLCP_CPR_STATE_RSP_WAIT) {
   3b4a0:	f894 3196 	ldrb.w	r3, [r4, #406]	; 0x196
   3b4a4:	f003 000f 	and.w	r0, r3, #15
   3b4a8:	2804      	cmp	r0, #4
   3b4aa:	f000 8589 	beq.w	3bfc0 <ull_conn_rx+0x1748>
	if (!conn->llcp_conn_param.cmd) {
   3b4ae:	06d9      	lsls	r1, r3, #27
   3b4b0:	f57f aa41 	bpl.w	3a936 <ull_conn_rx+0xbe>
	rx->hdr.type = NODE_RX_TYPE_CONN_UPDATE;
   3b4b4:	2319      	movs	r3, #25
   3b4b6:	7133      	strb	r3, [r6, #4]
	LL_ASSERT(IS_PTR_ALIGNED(node, struct node_rx_cu));
   3b4b8:	07d3      	lsls	r3, r2, #31
   3b4ba:	f100 847d 	bmi.w	3bdb8 <ull_conn_rx+0x1540>
	cu->status = rej_ext_ind->error_code;
   3b4be:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
   3b4c2:	7733      	strb	r3, [r6, #28]
	cu->interval = lll->interval;
   3b4c4:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
   3b4c6:	83f3      	strh	r3, [r6, #30]
	cu->latency = lll->latency;
   3b4c8:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
   3b4ca:	8433      	strh	r3, [r6, #32]
	cu->timeout = conn->supervision_reload *
   3b4cc:	f8b4 30c2 	ldrh.w	r3, [r4, #194]	; 0xc2
		      lll->interval * 125U / 1000;
   3b4d0:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
   3b4d2:	227d      	movs	r2, #125	; 0x7d
	cu->timeout = conn->supervision_reload *
   3b4d4:	fb01 f303 	mul.w	r3, r1, r3
		      lll->interval * 125U / 1000;
   3b4d8:	fb02 f303 	mul.w	r3, r2, r3
   3b4dc:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   3b4e0:	fbb3 f3f2 	udiv	r3, r3, r2
	cu->timeout = conn->supervision_reload *
   3b4e4:	8473      	strh	r3, [r6, #34]	; 0x22
	if (err) {
   3b4e6:	f7ff ba30 	b.w	3a94a <ull_conn_rx+0xd2>
		if ((conn->llcp_ack != conn->llcp_req) &&
   3b4ea:	f894 20f0 	ldrb.w	r2, [r4, #240]	; 0xf0
   3b4ee:	f894 30f1 	ldrb.w	r3, [r4, #241]	; 0xf1
   3b4f2:	4293      	cmp	r3, r2
   3b4f4:	f43f aa1f 	beq.w	3a936 <ull_conn_rx+0xbe>
   3b4f8:	f894 30f2 	ldrb.w	r3, [r4, #242]	; 0xf2
   3b4fc:	2b03      	cmp	r3, #3
   3b4fe:	f47f aa1a 	bne.w	3a936 <ull_conn_rx+0xbe>
	conn->llcp_enc.pause_rx = 0U;
   3b502:	f894 3176 	ldrb.w	r3, [r4, #374]	; 0x176
	conn->llcp_ack = conn->llcp_req;
   3b506:	f884 20f1 	strb.w	r2, [r4, #241]	; 0xf1
	conn->llcp_enc.pause_rx = 0U;
   3b50a:	f023 0303 	bic.w	r3, r3, #3
	conn->procedure_expire = 0U;
   3b50e:	2100      	movs	r1, #0
	conn->llcp_enc.pause_rx = 0U;
   3b510:	f884 3176 	strb.w	r3, [r4, #374]	; 0x176
	conn->procedure_expire = 0U;
   3b514:	f8a4 10c8 	strh.w	r1, [r4, #200]	; 0xc8
	pdu_rx->llctrl.reject_ind.error_code = rej_ext_ind->error_code;
   3b518:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
   3b51c:	f886 3020 	strb.w	r3, [r6, #32]
	pdu_rx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_IND;
   3b520:	220d      	movs	r2, #13
   3b522:	77f2      	strb	r2, [r6, #31]
	if (err) {
   3b524:	f7ff ba11 	b.w	3a94a <ull_conn_rx+0xd2>
   3b528:	200058f0 	.word	0x200058f0
   3b52c:	20005384 	.word	0x20005384
		if (conn->llcp_phy.ack != conn->llcp_phy.req) {
   3b530:	f894 21d4 	ldrb.w	r2, [r4, #468]	; 0x1d4
   3b534:	f894 31d5 	ldrb.w	r3, [r4, #469]	; 0x1d5
   3b538:	4293      	cmp	r3, r2
   3b53a:	f43f a9fc 	beq.w	3a936 <ull_conn_rx+0xbe>
	if (rej_ext_ind->error_code != BT_HCI_ERR_LL_PROC_COLLISION) {
   3b53e:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
   3b542:	2b23      	cmp	r3, #35	; 0x23
   3b544:	f43f ab5e 	beq.w	3ac04 <ull_conn_rx+0x38c>
		conn->lll.phy_tx_time = conn->lll.phy_tx;
   3b548:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
		conn->llcp_phy.ack = conn->llcp_phy.req;
   3b54c:	f884 21d5 	strb.w	r2, [r4, #469]	; 0x1d5
		conn->lll.phy_tx_time = conn->lll.phy_tx;
   3b550:	f3c3 0202 	ubfx	r2, r3, #0, #3
   3b554:	f362 1306 	bfi	r3, r2, #4, #3
		conn->llcp_phy.pause_tx = 0U;
   3b558:	f894 21d7 	ldrb.w	r2, [r4, #471]	; 0x1d7
		conn->lll.phy_tx_time = conn->lll.phy_tx;
   3b55c:	f884 3060 	strb.w	r3, [r4, #96]	; 0x60
		conn->procedure_expire = 0U;
   3b560:	2100      	movs	r1, #0
		conn->llcp_phy.pause_tx = 0U;
   3b562:	f36f 0200 	bfc	r2, #0, #1
   3b566:	f884 21d7 	strb.w	r2, [r4, #471]	; 0x1d7
		conn->procedure_expire = 0U;
   3b56a:	f8a4 10c8 	strh.w	r1, [r4, #200]	; 0xc8
   3b56e:	f7ff bb49 	b.w	3ac04 <ull_conn_rx+0x38c>
		if (!conn->tx_ctrl) {
   3b572:	f8d4 11e0 	ldr.w	r1, [r4, #480]	; 0x1e0
   3b576:	2900      	cmp	r1, #0
   3b578:	f47f aa4e 	bne.w	3aa18 <ull_conn_rx+0x1a0>
			tx->next = conn->tx_head;
   3b57c:	6003      	str	r3, [r0, #0]
				conn->tx_ctrl = tx;
   3b57e:	e9c4 0077 	strd	r0, r0, [r4, #476]	; 0x1dc
				conn->tx_ctrl_last = tx;
   3b582:	f7ff ba50 	b.w	3aa26 <ull_conn_rx+0x1ae>
		((!conn->llcp_enc.refresh &&
   3b586:	f1b8 0f07 	cmp.w	r8, #7
   3b58a:	f43f ac22 	beq.w	3add2 <ull_conn_rx+0x55a>
		  (opcode != PDU_DATA_LLCTRL_TYPE_UNKNOWN_RSP) &&
   3b58e:	f1b8 0f02 	cmp.w	r8, #2
   3b592:	f43f ac13 	beq.w	3adbc <ull_conn_rx+0x544>
   3b596:	f1a8 0706 	sub.w	r7, r8, #6
   3b59a:	b2ff      	uxtb	r7, r7
   3b59c:	2f0b      	cmp	r7, #11
   3b59e:	f63f a9ce 	bhi.w	3a93e <ull_conn_rx+0xc6>
		  (opcode != PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND)))) ||
   3b5a2:	49d2      	ldr	r1, [pc, #840]	; (3b8ec <ull_conn_rx+0x1074>)
   3b5a4:	f851 7027 	ldr.w	r7, [r1, r7, lsl #2]
	if (conn->llcp_enc.pause_rx && ctrl_is_unexpected(conn, opcode)) {
   3b5a8:	07f9      	lsls	r1, r7, #31
   3b5aa:	f53f a9c8 	bmi.w	3a93e <ull_conn_rx+0xc6>
	switch (opcode) {
   3b5ae:	f1a8 0707 	sub.w	r7, r8, #7
   3b5b2:	2f0a      	cmp	r7, #10
   3b5b4:	f63f ac36 	bhi.w	3ae24 <ull_conn_rx+0x5ac>
   3b5b8:	f20f 0c04 	addw	ip, pc, #4
   3b5bc:	f85c f027 	ldr.w	pc, [ip, r7, lsl #2]
   3b5c0:	0003add3 	.word	0x0003add3
   3b5c4:	0003a995 	.word	0x0003a995
   3b5c8:	0003acd1 	.word	0x0003acd1
   3b5cc:	0003ae8d 	.word	0x0003ae8d
   3b5d0:	0003b40f 	.word	0x0003b40f
   3b5d4:	0003ac2f 	.word	0x0003ac2f
   3b5d8:	0003aba3 	.word	0x0003aba3
   3b5dc:	0003b033 	.word	0x0003b033
   3b5e0:	0003ab79 	.word	0x0003ab79
   3b5e4:	0003b053 	.word	0x0003b053
   3b5e8:	0003ab0d 	.word	0x0003ab0d
   3b5ec:	f1b8 0f0b 	cmp.w	r8, #11
   3b5f0:	d1d1      	bne.n	3b596 <ull_conn_rx+0xd1e>
		if (PDU_DATA_LLCTRL_LEN(pause_enc_rsp) != pdu_rx->len) {
   3b5f2:	7f73      	ldrb	r3, [r6, #29]
   3b5f4:	2b01      	cmp	r3, #1
   3b5f6:	f47f a9d0 	bne.w	3a99a <ull_conn_rx+0x122>
		conn->lll.enc_tx = 0U;
   3b5fa:	f894 307a 	ldrb.w	r3, [r4, #122]	; 0x7a
   3b5fe:	f36f 1304 	bfc	r3, #4, #1
   3b602:	f884 307a 	strb.w	r3, [r4, #122]	; 0x7a
		goto pause_enc_rsp_send_exit;
   3b606:	f7ff b996 	b.w	3a936 <ull_conn_rx+0xbe>
			return -ENOBUFS;
   3b60a:	f06f 0068 	mvn.w	r0, #104	; 0x68
   3b60e:	f7ff b99d 	b.w	3a94c <ull_conn_rx+0xd4>
			conn->tx_data = conn->tx_data->next;
   3b612:	681a      	ldr	r2, [r3, #0]
   3b614:	f8c4 21e8 	str.w	r2, [r4, #488]	; 0x1e8
		if (!conn->tx_ctrl) {
   3b618:	2900      	cmp	r1, #0
   3b61a:	f43f ac83 	beq.w	3af24 <ull_conn_rx+0x6ac>
   3b61e:	f7ff b9fb 	b.w	3aa18 <ull_conn_rx+0x1a0>
		if (!conn->lll.role) {
   3b622:	f994 c039 	ldrsb.w	ip, [r4, #57]	; 0x39
	} else if (conn->llcp_conn_param.ack != conn->llcp_conn_param.req) {
   3b626:	f894 0194 	ldrb.w	r0, [r4, #404]	; 0x194
   3b62a:	f894 1195 	ldrb.w	r1, [r4, #405]	; 0x195
		if (!conn->lll.role) {
   3b62e:	f1bc 0f00 	cmp.w	ip, #0
   3b632:	f2c0 81af 	blt.w	3b994 <ull_conn_rx+0x111c>
			if ((conn->llcp_conn_param.req !=
   3b636:	4288      	cmp	r0, r1
   3b638:	d009      	beq.n	3b64e <ull_conn_rx+0xdd6>
			    ((conn->llcp_conn_param.state ==
   3b63a:	f894 c196 	ldrb.w	ip, [r4, #406]	; 0x196
					conn->llcp_conn_param.ack) &&
   3b63e:	2051      	movs	r0, #81	; 0x51
   3b640:	f00c 0c0f 	and.w	ip, ip, #15
   3b644:	fa20 f00c 	lsr.w	r0, r0, ip
   3b648:	07c0      	lsls	r0, r0, #31
   3b64a:	f100 82cd 	bmi.w	3bbe8 <ull_conn_rx+0x1370>
			} else if (((((conn->llcp_req - conn->llcp_ack) &
   3b64e:	f894 00f0 	ldrb.w	r0, [r4, #240]	; 0xf0
   3b652:	f894 c0f1 	ldrb.w	ip, [r4, #241]	; 0xf1
   3b656:	eba0 000c 	sub.w	r0, r0, ip
   3b65a:	f000 0003 	and.w	r0, r0, #3
   3b65e:	2802      	cmp	r0, #2
   3b660:	f000 8477 	beq.w	3bf52 <ull_conn_rx+0x16da>
				    (conn->llcp_type != LLCP_ENCRYPTION)) ||
   3b664:	f894 c1d4 	ldrb.w	ip, [r4, #468]	; 0x1d4
   3b668:	f894 01d5 	ldrb.w	r0, [r4, #469]	; 0x1d5
   3b66c:	4584      	cmp	ip, r0
   3b66e:	f000 8403 	beq.w	3be78 <ull_conn_rx+0x1600>
				nack = reject_ext_ind_send(conn, *rx,
   3b672:	232a      	movs	r3, #42	; 0x2a
   3b674:	220f      	movs	r2, #15
   3b676:	f7ff ba8d 	b.w	3ab94 <ull_conn_rx+0x31c>
	if (conn->common.txn_lock) {
   3b67a:	f894 30e4 	ldrb.w	r3, [r4, #228]	; 0xe4
   3b67e:	079b      	lsls	r3, r3, #30
   3b680:	f53f a959 	bmi.w	3a936 <ull_conn_rx+0xbe>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
   3b684:	489a      	ldr	r0, [pc, #616]	; (3b8f0 <ull_conn_rx+0x1078>)
   3b686:	f7f8 ff17 	bl	344b8 <mem_acquire>
	if (!tx) {
   3b68a:	4603      	mov	r3, r0
   3b68c:	2800      	cmp	r0, #0
   3b68e:	d0bc      	beq.n	3b60a <ull_conn_rx+0xd92>
	conn->common.txn_lock = 1U;
   3b690:	f894 20e4 	ldrb.w	r2, [r4, #228]	; 0xe4
	    ((conn->llcp_length.req == conn->llcp_length.ack) && tx) ||
   3b694:	f894 11c5 	ldrb.w	r1, [r4, #453]	; 0x1c5
	eff_tx_octets = conn->lll.max_tx_octets;
   3b698:	f8b4 0058 	ldrh.w	r0, [r4, #88]	; 0x58
	eff_rx_octets = conn->lll.max_rx_octets;
   3b69c:	f8b4 905a 	ldrh.w	r9, [r4, #90]	; 0x5a
	eff_rx_time = conn->lll.max_rx_time;
   3b6a0:	f8b4 b05e 	ldrh.w	fp, [r4, #94]	; 0x5e
	eff_tx_time = conn->lll.max_tx_time;
   3b6a4:	f8b4 a05c 	ldrh.w	sl, [r4, #92]	; 0x5c
	eff_tx_octets = conn->lll.max_tx_octets;
   3b6a8:	9001      	str	r0, [sp, #4]
	conn->common.txn_lock = 1U;
   3b6aa:	f042 0202 	orr.w	r2, r2, #2
   3b6ae:	f884 20e4 	strb.w	r2, [r4, #228]	; 0xe4
	    ((conn->llcp_length.req == conn->llcp_length.ack) && tx) ||
   3b6b2:	f894 21c4 	ldrb.w	r2, [r4, #452]	; 0x1c4
	if (/* Local idle, and Peer request then complete the Peer procedure
   3b6b6:	428a      	cmp	r2, r1
   3b6b8:	f040 84db 	bne.w	3c072 <ull_conn_rx+0x17fa>
		max_rx_octets = sys_le16_to_cpu(lr->max_rx_octets);
   3b6bc:	8c30      	ldrh	r0, [r6, #32]
		if (max_rx_octets >= PDU_DC_PAYLOAD_SIZE_MIN) {
   3b6be:	281a      	cmp	r0, #26
   3b6c0:	f240 820a 	bls.w	3bad8 <ull_conn_rx+0x1260>
			eff_tx_octets = MIN(max_rx_octets,
   3b6c4:	f8b4 10d2 	ldrh.w	r1, [r4, #210]	; 0xd2
   3b6c8:	4281      	cmp	r1, r0
   3b6ca:	bf28      	it	cs
   3b6cc:	4601      	movcs	r1, r0
		if (max_tx_octets >= PDU_DC_PAYLOAD_SIZE_MIN) {
   3b6ce:	8cb0      	ldrh	r0, [r6, #36]	; 0x24
		lr_tx_time = sys_le16_to_cpu(lr->max_tx_time);
   3b6d0:	f8b6 c026 	ldrh.w	ip, [r6, #38]	; 0x26
		if (max_tx_octets >= PDU_DC_PAYLOAD_SIZE_MIN) {
   3b6d4:	281a      	cmp	r0, #26
		if (lr_rx_time >= PDU_DC_MAX_US(PDU_DC_PAYLOAD_SIZE_MIN,
   3b6d6:	8c70      	ldrh	r0, [r6, #34]	; 0x22
		if (max_tx_octets >= PDU_DC_PAYLOAD_SIZE_MIN) {
   3b6d8:	bf94      	ite	ls
   3b6da:	46ce      	movls	lr, r9
   3b6dc:	f04f 0e1b 	movhi.w	lr, #27
		if (lr_rx_time >= PDU_DC_MAX_US(PDU_DC_PAYLOAD_SIZE_MIN,
   3b6e0:	f5b0 7fa4 	cmp.w	r0, #328	; 0x148
   3b6e4:	bf34      	ite	cc
   3b6e6:	4650      	movcc	r0, sl
   3b6e8:	f44f 70a4 	movcs.w	r0, #328	; 0x148
		if (lr_tx_time >= PDU_DC_MAX_US(PDU_DC_PAYLOAD_SIZE_MIN,
   3b6ec:	f5bc 7fa4 	cmp.w	ip, #328	; 0x148
   3b6f0:	bf34      	ite	cc
   3b6f2:	46dc      	movcc	ip, fp
   3b6f4:	f44f 7ca4 	movcs.w	ip, #328	; 0x148
		if (eff_rx_octets != conn->lll.max_rx_octets) {
   3b6f8:	45ce      	cmp	lr, r9
   3b6fa:	f000 82fd 	beq.w	3bcf8 <ull_conn_rx+0x1480>
			conn->llcp_length.ack = conn->llcp_length.req - 1;
   3b6fe:	3a01      	subs	r2, #1
   3b700:	f884 21c5 	strb.w	r2, [r4, #453]	; 0x1c5
			conn->llcp_length.rx_octets = eff_rx_octets;
   3b704:	f8a4 e1c8 	strh.w	lr, [r4, #456]	; 0x1c8
			link->mem = conn->llcp_rx;
   3b708:	f8d4 2114 	ldr.w	r2, [r4, #276]	; 0x114
			conn->llcp_length.tx_octets = eff_tx_octets;
   3b70c:	f8a4 11ca 	strh.w	r1, [r4, #458]	; 0x1ca
			conn->llcp_length.rx_time = eff_rx_time;
   3b710:	f8a4 c1cc 	strh.w	ip, [r4, #460]	; 0x1cc
			conn->llcp_length.tx_time = eff_tx_time;
   3b714:	f8a4 01ce 	strh.w	r0, [r4, #462]	; 0x1ce
			if (tx) {
   3b718:	2b00      	cmp	r3, #0
   3b71a:	f000 8329 	beq.w	3bd70 <ull_conn_rx+0x14f8>
				conn->llcp_length.state =
   3b71e:	f894 61c6 	ldrb.w	r6, [r4, #454]	; 0x1c6
   3b722:	f04f 0805 	mov.w	r8, #5
   3b726:	f368 0602 	bfi	r6, r8, #0, #3
   3b72a:	f884 61c6 	strb.w	r6, [r4, #454]	; 0x1c6
			link->mem = conn->llcp_rx;
   3b72e:	607a      	str	r2, [r7, #4]
			(*rx)->hdr.link = link;
   3b730:	682a      	ldr	r2, [r5, #0]
   3b732:	6017      	str	r7, [r2, #0]
			conn->llcp_rx = *rx;
   3b734:	682a      	ldr	r2, [r5, #0]
   3b736:	f8c4 2114 	str.w	r2, [r4, #276]	; 0x114
			*rx = NULL;
   3b73a:	2200      	movs	r2, #0
   3b73c:	602a      	str	r2, [r5, #0]
	pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
   3b73e:	791a      	ldrb	r2, [r3, #4]
	pdu_tx->llctrl.length_rsp.max_tx_time = sys_cpu_to_le16(eff_tx_time);
   3b740:	81d8      	strh	r0, [r3, #14]
	pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
   3b742:	f042 0203 	orr.w	r2, r2, #3
	ctrl_tx_sec_enqueue(conn, tx);
   3b746:	4620      	mov	r0, r4
	pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
   3b748:	711a      	strb	r2, [r3, #4]
	pdu_tx->len = offsetof(struct pdu_data_llctrl, length_rsp) +
   3b74a:	2409      	movs	r4, #9
	pdu_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_RSP;
   3b74c:	2215      	movs	r2, #21
	pdu_tx->llctrl.length_rsp.max_tx_octets =
   3b74e:	8199      	strh	r1, [r3, #12]
	pdu_tx->llctrl.length_rsp.max_rx_octets =
   3b750:	f8a3 e008 	strh.w	lr, [r3, #8]
	pdu_tx->llctrl.length_rsp.max_rx_time = sys_cpu_to_le16(eff_rx_time);
   3b754:	f8a3 c00a 	strh.w	ip, [r3, #10]
	ctrl_tx_sec_enqueue(conn, tx);
   3b758:	4619      	mov	r1, r3
	pdu_tx->len = offsetof(struct pdu_data_llctrl, length_rsp) +
   3b75a:	715c      	strb	r4, [r3, #5]
	pdu_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_RSP;
   3b75c:	71da      	strb	r2, [r3, #7]
	ctrl_tx_sec_enqueue(conn, tx);
   3b75e:	f7fd ff3d 	bl	395dc <ctrl_tx_sec_enqueue>
}
   3b762:	f7ff b8f2 	b.w	3a94a <ull_conn_rx+0xd2>
	} else if (conn->llcp_conn_param.ack != conn->llcp_conn_param.req) {
   3b766:	f894 1195 	ldrb.w	r1, [r4, #405]	; 0x195
   3b76a:	f894 3194 	ldrb.w	r3, [r4, #404]	; 0x194
   3b76e:	4299      	cmp	r1, r3
   3b770:	f43f ae67 	beq.w	3b442 <ull_conn_rx+0xbca>
		rej_ext_ind->error_code = rej_ind->error_code;
   3b774:	f896 3020 	ldrb.w	r3, [r6, #32]
   3b778:	f886 3021 	strb.w	r3, [r6, #33]	; 0x21
	if (!lll->role && (rej_ext_ind->error_code ==
   3b77c:	f994 1039 	ldrsb.w	r1, [r4, #57]	; 0x39
   3b780:	2900      	cmp	r1, #0
   3b782:	f2c0 8372 	blt.w	3be6a <ull_conn_rx+0x15f2>
   3b786:	2b1a      	cmp	r3, #26
   3b788:	f000 8435 	beq.w	3bff6 <ull_conn_rx+0x177e>
	if (conn->llcp_conn_param.state == LLCP_CPR_STATE_RSP_WAIT) {
   3b78c:	f894 3196 	ldrb.w	r3, [r4, #406]	; 0x196
   3b790:	f003 010f 	and.w	r1, r3, #15
   3b794:	2904      	cmp	r1, #4
   3b796:	f47f ae8a 	bne.w	3b4ae <ull_conn_rx+0xc36>
	conn_upd_curr = NULL;
   3b79a:	4d56      	ldr	r5, [pc, #344]	; (3b8f4 <ull_conn_rx+0x107c>)
	if (conn->llcp_conn_param.cache.timeout) {
   3b79c:	f8b4 01a6 	ldrh.w	r0, [r4, #422]	; 0x1a6
   3b7a0:	2100      	movs	r1, #0
   3b7a2:	6029      	str	r1, [r5, #0]
   3b7a4:	2800      	cmp	r0, #0
   3b7a6:	f000 8403 	beq.w	3bfb0 <ull_conn_rx+0x1738>
		conn->llcp_conn_param.state = LLCP_CPR_STATE_REQ;
   3b7aa:	f8b4 3196 	ldrh.w	r3, [r4, #406]	; 0x196
		conn->llcp_conn_param.timeout =
   3b7ae:	f8a4 019e 	strh.w	r0, [r4, #414]	; 0x19e
		conn->llcp_conn_param.cache.timeout = 0U;
   3b7b2:	f8a4 11a6 	strh.w	r1, [r4, #422]	; 0x1a6
		conn->llcp_conn_param.interval_min =
   3b7b6:	f8d4 11a0 	ldr.w	r1, [r4, #416]	; 0x1a0
   3b7ba:	f8c4 1198 	str.w	r1, [r4, #408]	; 0x198
		conn->llcp_conn_param.state = LLCP_CPR_STATE_REQ;
   3b7be:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
		conn->llcp_conn_param.latency =
   3b7c2:	f8b4 11a4 	ldrh.w	r1, [r4, #420]	; 0x1a4
   3b7c6:	f8a4 119c 	strh.w	r1, [r4, #412]	; 0x19c
		conn->llcp_conn_param.state = LLCP_CPR_STATE_REQ;
   3b7ca:	f043 0310 	orr.w	r3, r3, #16
   3b7ce:	f8a4 3196 	strh.w	r3, [r4, #406]	; 0x196
		conn->procedure_expire = 0U;
   3b7d2:	2100      	movs	r1, #0
   3b7d4:	f8a4 10c8 	strh.w	r1, [r4, #200]	; 0xc8
   3b7d8:	e669      	b.n	3b4ae <ull_conn_rx+0xc36>
	if (conn->common.txn_lock) {
   3b7da:	f894 30e4 	ldrb.w	r3, [r4, #228]	; 0xe4
   3b7de:	079f      	lsls	r7, r3, #30
   3b7e0:	f53f a8a9 	bmi.w	3a936 <ull_conn_rx+0xbe>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
   3b7e4:	4842      	ldr	r0, [pc, #264]	; (3b8f0 <ull_conn_rx+0x1078>)
   3b7e6:	f7f8 fe67 	bl	344b8 <mem_acquire>
	if (!tx) {
   3b7ea:	4603      	mov	r3, r0
   3b7ec:	2800      	cmp	r0, #0
   3b7ee:	f43f af0c 	beq.w	3b60a <ull_conn_rx+0xd92>
	conn->common.txn_lock = 1U;
   3b7f2:	f894 20e4 	ldrb.w	r2, [r4, #228]	; 0xe4
	conn->llcp_phy.state = LLCP_PHY_STATE_RSP_WAIT;
   3b7f6:	f894 11d6 	ldrb.w	r1, [r4, #470]	; 0x1d6
	if (conn->llcp_phy.ack ==
   3b7fa:	f894 01d5 	ldrb.w	r0, [r4, #469]	; 0x1d5
	conn->common.txn_lock = 1U;
   3b7fe:	f042 0202 	orr.w	r2, r2, #2
   3b802:	f884 20e4 	strb.w	r2, [r4, #228]	; 0xe4
	conn->llcp_phy.state = LLCP_PHY_STATE_RSP_WAIT;
   3b806:	2202      	movs	r2, #2
   3b808:	f362 0101 	bfi	r1, r2, #0, #2
	if (conn->llcp_phy.ack ==
   3b80c:	f894 21d4 	ldrb.w	r2, [r4, #468]	; 0x1d4
	conn->llcp_phy.state = LLCP_PHY_STATE_RSP_WAIT;
   3b810:	f884 11d6 	strb.w	r1, [r4, #470]	; 0x1d6
	if (conn->llcp_phy.ack ==
   3b814:	4282      	cmp	r2, r0
   3b816:	d115      	bne.n	3b844 <ull_conn_rx+0xfcc>
		conn->llcp_phy.tx =
   3b818:	f8b4 11d6 	ldrh.w	r1, [r4, #470]	; 0x1d6
			conn->phy_pref_rx;
   3b81c:	f894 01d8 	ldrb.w	r0, [r4, #472]	; 0x1d8
		conn->llcp_phy.ack--;
   3b820:	3a01      	subs	r2, #1
   3b822:	f884 21d5 	strb.w	r2, [r4, #469]	; 0x1d5
		conn->llcp_phy.tx =
   3b826:	f421 619f 	bic.w	r1, r1, #1272	; 0x4f8
   3b82a:	f240 42fc 	movw	r2, #1276	; 0x4fc
   3b82e:	f021 0104 	bic.w	r1, r1, #4
   3b832:	ea02 0280 	and.w	r2, r2, r0, lsl #2
   3b836:	430a      	orrs	r2, r1
		conn->procedure_expire =
   3b838:	f8b4 10c6 	ldrh.w	r1, [r4, #198]	; 0xc6
		conn->llcp_phy.tx =
   3b83c:	f8a4 21d6 	strh.w	r2, [r4, #470]	; 0x1d6
		conn->procedure_expire =
   3b840:	f8a4 10c8 	strh.w	r1, [r4, #200]	; 0xc8
	conn->llcp_phy.tx &= p->rx_phys;
   3b844:	f894 21d6 	ldrb.w	r2, [r4, #470]	; 0x1d6
   3b848:	f896 1021 	ldrb.w	r1, [r6, #33]	; 0x21
   3b84c:	f3c2 0082 	ubfx	r0, r2, #2, #3
   3b850:	4001      	ands	r1, r0
   3b852:	f361 0284 	bfi	r2, r1, #2, #3
   3b856:	f884 21d6 	strb.w	r2, [r4, #470]	; 0x1d6
	conn->llcp_phy.rx &= p->tx_phys;
   3b85a:	f896 1020 	ldrb.w	r1, [r6, #32]
   3b85e:	f3c2 1042 	ubfx	r0, r2, #5, #3
   3b862:	4001      	ands	r1, r0
   3b864:	f361 1247 	bfi	r2, r1, #5, #3
   3b868:	f884 21d6 	strb.w	r2, [r4, #470]	; 0x1d6
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   3b86c:	791a      	ldrb	r2, [r3, #4]
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, phy_rsp) +
   3b86e:	2103      	movs	r1, #3
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   3b870:	430a      	orrs	r2, r1
   3b872:	711a      	strb	r2, [r3, #4]
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PHY_RSP;
   3b874:	2217      	movs	r2, #23
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, phy_rsp) +
   3b876:	7159      	strb	r1, [r3, #5]
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PHY_RSP;
   3b878:	71da      	strb	r2, [r3, #7]
	pdu_ctrl_tx->llctrl.phy_rsp.tx_phys = conn->phy_pref_tx;
   3b87a:	f894 21d8 	ldrb.w	r2, [r4, #472]	; 0x1d8
   3b87e:	f3c2 0202 	ubfx	r2, r2, #0, #3
   3b882:	721a      	strb	r2, [r3, #8]
	pdu_ctrl_tx->llctrl.phy_rsp.rx_phys = conn->phy_pref_rx;
   3b884:	f894 21d8 	ldrb.w	r2, [r4, #472]	; 0x1d8
   3b888:	f3c2 02c2 	ubfx	r2, r2, #3, #3
   3b88c:	725a      	strb	r2, [r3, #9]
	    conn->tx_head &&
   3b88e:	f8d4 21dc 	ldr.w	r2, [r4, #476]	; 0x1dc
	if (
   3b892:	2a00      	cmp	r2, #0
   3b894:	f000 8117 	beq.w	3bac6 <ull_conn_rx+0x124e>
	    !conn->llcp_cu.pause_tx &&
   3b898:	f894 111a 	ldrb.w	r1, [r4, #282]	; 0x11a
	    conn->tx_head &&
   3b89c:	06cd      	lsls	r5, r1, #27
   3b89e:	f100 8112 	bmi.w	3bac6 <ull_conn_rx+0x124e>
	    !conn->llcp_enc.pause_tx &&
   3b8a2:	f894 1176 	ldrb.w	r1, [r4, #374]	; 0x176
	    !conn->llcp_cu.pause_tx &&
   3b8a6:	0788      	lsls	r0, r1, #30
   3b8a8:	f100 810d 	bmi.w	3bac6 <ull_conn_rx+0x124e>
	    !conn->llcp_phy.pause_tx &&
   3b8ac:	f894 11d7 	ldrb.w	r1, [r4, #471]	; 0x1d7
   3b8b0:	07c9      	lsls	r1, r1, #31
   3b8b2:	f100 8108 	bmi.w	3bac6 <ull_conn_rx+0x124e>
		if (conn->tx_head == conn->tx_data) {
   3b8b6:	f8d4 01e8 	ldr.w	r0, [r4, #488]	; 0x1e8
		if (!conn->tx_ctrl) {
   3b8ba:	f8d4 11e0 	ldr.w	r1, [r4, #480]	; 0x1e0
		if (conn->tx_head == conn->tx_data) {
   3b8be:	4282      	cmp	r2, r0
   3b8c0:	f000 83df 	beq.w	3c082 <ull_conn_rx+0x180a>
		} else if (!conn->tx_ctrl) {
   3b8c4:	2900      	cmp	r1, #0
   3b8c6:	f000 8447 	beq.w	3c158 <ull_conn_rx+0x18e0>
	tx->next = conn->tx_ctrl_last->next;
   3b8ca:	f8d4 21e4 	ldr.w	r2, [r4, #484]	; 0x1e4
   3b8ce:	6812      	ldr	r2, [r2, #0]
   3b8d0:	601a      	str	r2, [r3, #0]
	conn->tx_ctrl_last->next = tx;
   3b8d2:	f8d4 21e4 	ldr.w	r2, [r4, #484]	; 0x1e4
   3b8d6:	6013      	str	r3, [r2, #0]
	conn->tx_ctrl_last = tx;
   3b8d8:	f8c4 31e4 	str.w	r3, [r4, #484]	; 0x1e4
	if (!tx->next) {
   3b8dc:	681a      	ldr	r2, [r3, #0]
   3b8de:	2a00      	cmp	r2, #0
   3b8e0:	f47f a829 	bne.w	3a936 <ull_conn_rx+0xbe>
		conn->tx_data_last = tx;
   3b8e4:	f8c4 31ec 	str.w	r3, [r4, #492]	; 0x1ec
	rx->hdr.type = NODE_RX_TYPE_RELEASE;
   3b8e8:	f7ff b825 	b.w	3a936 <ull_conn_rx+0xbe>
   3b8ec:	00052884 	.word	0x00052884
   3b8f0:	20005384 	.word	0x20005384
   3b8f4:	200058f0 	.word	0x200058f0
			conn->llcp_conn_param.disabled = 1U;
   3b8f8:	f894 3196 	ldrb.w	r3, [r4, #406]	; 0x196
   3b8fc:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   3b900:	f884 3196 	strb.w	r3, [r4, #406]	; 0x196
			if (!conn->lll.role) {
   3b904:	f994 3039 	ldrsb.w	r3, [r4, #57]	; 0x39
   3b908:	2b00      	cmp	r3, #0
   3b90a:	f2c0 8272 	blt.w	3bdf2 <ull_conn_rx+0x157a>
				LL_ASSERT(conn->llcp_cu.req ==
   3b90e:	f894 2118 	ldrb.w	r2, [r4, #280]	; 0x118
   3b912:	f894 3119 	ldrb.w	r3, [r4, #281]	; 0x119
   3b916:	429a      	cmp	r2, r3
   3b918:	d00e      	beq.n	3b938 <ull_conn_rx+0x10c0>
   3b91a:	4ab5      	ldr	r2, [pc, #724]	; (3bbf0 <ull_conn_rx+0x1378>)
   3b91c:	49b5      	ldr	r1, [pc, #724]	; (3bbf4 <ull_conn_rx+0x137c>)
   3b91e:	48b6      	ldr	r0, [pc, #728]	; (3bbf8 <ull_conn_rx+0x1380>)
   3b920:	f641 5346 	movw	r3, #7494	; 0x1d46
   3b924:	f00d fbae 	bl	49084 <assert_print>
   3b928:	4040      	eors	r0, r0
   3b92a:	f380 8811 	msr	BASEPRI, r0
   3b92e:	f04f 0003 	mov.w	r0, #3
   3b932:	df02      	svc	2
   3b934:	f894 3119 	ldrb.w	r3, [r4, #281]	; 0x119
				conn->llcp_conn_param.state =
   3b938:	f894 2196 	ldrb.w	r2, [r4, #406]	; 0x196
   3b93c:	2106      	movs	r1, #6
   3b93e:	f361 0203 	bfi	r2, r1, #0, #4
				conn->llcp_cu.ack--;
   3b942:	3b01      	subs	r3, #1
   3b944:	f884 3119 	strb.w	r3, [r4, #281]	; 0x119
				conn->llcp_conn_param.state =
   3b948:	f884 2196 	strb.w	r2, [r4, #406]	; 0x196
				conn->llcp_cu.cmd = conn->llcp_conn_param.cmd;
   3b94c:	f3c2 1300 	ubfx	r3, r2, #4, #1
				conn->llcp_cu.state = LLCP_CUI_STATE_USE;
   3b950:	f894 211a 	ldrb.w	r2, [r4, #282]	; 0x11a
				conn->llcp_cu.win_size = 1U;
   3b954:	2101      	movs	r1, #1
				conn->llcp_cu.state = LLCP_CUI_STATE_USE;
   3b956:	00db      	lsls	r3, r3, #3
   3b958:	f022 020f 	bic.w	r2, r2, #15
   3b95c:	430b      	orrs	r3, r1
   3b95e:	4313      	orrs	r3, r2
   3b960:	f884 311a 	strb.w	r3, [r4, #282]	; 0x11a
				conn->llcp_cu.timeout =
   3b964:	f8b4 319e 	ldrh.w	r3, [r4, #414]	; 0x19e
   3b968:	f8a4 3120 	strh.w	r3, [r4, #288]	; 0x120
					conn->llcp_conn_param.interval_max;
   3b96c:	f8d4 219a 	ldr.w	r2, [r4, #410]	; 0x19a
				conn->llcp_cu.win_size = 1U;
   3b970:	f884 1128 	strb.w	r1, [r4, #296]	; 0x128
				conn->llcp_cu.win_offset_us = 0U;
   3b974:	2300      	movs	r3, #0
				conn->llcp_cu.interval =
   3b976:	f8c4 211c 	str.w	r2, [r4, #284]	; 0x11c
				conn->llcp_cu.win_offset_us = 0U;
   3b97a:	f8c4 3124 	str.w	r3, [r4, #292]	; 0x124
				(*rx)->hdr.type = NODE_RX_TYPE_RELEASE;
   3b97e:	682b      	ldr	r3, [r5, #0]
   3b980:	7119      	strb	r1, [r3, #4]
				break;
   3b982:	f7fe bfe2 	b.w	3a94a <ull_conn_rx+0xd2>
				      0x03) == 0x02) &&
   3b986:	f894 30f2 	ldrb.w	r3, [r4, #242]	; 0xf2
   3b98a:	2b03      	cmp	r3, #3
   3b98c:	f47f a99d 	bne.w	3acca <ull_conn_rx+0x452>
   3b990:	f7ff b994 	b.w	3acbc <ull_conn_rx+0x444>
		} else if ((conn->llcp_conn_param.req ==
   3b994:	4288      	cmp	r0, r1
   3b996:	d005      	beq.n	3b9a4 <ull_conn_rx+0x112c>
			    conn->llcp_conn_param.ack) ||
   3b998:	f894 3196 	ldrb.w	r3, [r4, #406]	; 0x196
   3b99c:	f013 0f0b 	tst.w	r3, #11
   3b9a0:	f47e afc9 	bne.w	3a936 <ull_conn_rx+0xbe>
			uint16_t interval_min = sys_le16_to_cpu(cpr->interval_min);
   3b9a4:	f8d6 9020 	ldr.w	r9, [r6, #32]
   3b9a8:	f8d6 8024 	ldr.w	r8, [r6, #36]	; 0x24
				cpr->preferred_periodicity;
   3b9ac:	f896 a028 	ldrb.w	sl, [r6, #40]	; 0x28
			if ((interval_min < CONN_INTERVAL_MIN(conn)) ||
   3b9b0:	fa1f f389 	uxth.w	r3, r9
   3b9b4:	2b05      	cmp	r3, #5
   3b9b6:	d978      	bls.n	3baaa <ull_conn_rx+0x1232>
   3b9b8:	ea4f 4c19 	mov.w	ip, r9, lsr #16
   3b9bc:	f5bc 6f48 	cmp.w	ip, #3200	; 0xc80
   3b9c0:	d873      	bhi.n	3baaa <ull_conn_rx+0x1232>
			    (interval_max > 3200) ||
   3b9c2:	4563      	cmp	r3, ip
   3b9c4:	d871      	bhi.n	3baaa <ull_conn_rx+0x1232>
   3b9c6:	fa1f fe88 	uxth.w	lr, r8
			    (interval_min > interval_max) ||
   3b9ca:	f5be 7ffa 	cmp.w	lr, #500	; 0x1f4
   3b9ce:	d26c      	bcs.n	3baaa <ull_conn_rx+0x1232>
   3b9d0:	ea4f 4318 	mov.w	r3, r8, lsr #16
			    (latency > 499) ||
   3b9d4:	f1a3 000a 	sub.w	r0, r3, #10
   3b9d8:	b280      	uxth	r0, r0
   3b9da:	f640 4b76 	movw	fp, #3190	; 0xc76
   3b9de:	4558      	cmp	r0, fp
   3b9e0:	d863      	bhi.n	3baaa <ull_conn_rx+0x1232>
			     ((latency + 1) * interval_max)) ||
   3b9e2:	f10e 0001 	add.w	r0, lr, #1
   3b9e6:	b280      	uxth	r0, r0
   3b9e8:	fb0c f000 	mul.w	r0, ip, r0
			    (timeout < 10) || (timeout > 3200) ||
   3b9ec:	ebb0 0f83 	cmp.w	r0, r3, lsl #2
   3b9f0:	d25b      	bcs.n	3baaa <ull_conn_rx+0x1232>
			     ((latency + 1) * interval_max)) ||
   3b9f2:	45e2      	cmp	sl, ip
   3b9f4:	d859      	bhi.n	3baaa <ull_conn_rx+0x1232>
			conn->llcp_conn_param.interval_min = interval_min;
   3b9f6:	e9c4 9866 	strd	r9, r8, [r4, #408]	; 0x198
			conn->llcp_conn_param.preferred_periodicity =
   3b9fa:	f884 a1a8 	strb.w	sl, [r4, #424]	; 0x1a8
				sys_le16_to_cpu(cpr->reference_conn_event_count);
   3b9fe:	f8b6 0029 	ldrh.w	r0, [r6, #41]	; 0x29
			conn->llcp_conn_param.reference_conn_event_count =
   3ba02:	f8a4 01aa 	strh.w	r0, [r4, #426]	; 0x1aa
				sys_le16_to_cpu(cpr->offset0);
   3ba06:	f8b6 002b 	ldrh.w	r0, [r6, #43]	; 0x2b
			conn->llcp_conn_param.offset0 =
   3ba0a:	f8a4 01ac 	strh.w	r0, [r4, #428]	; 0x1ac
				sys_le16_to_cpu(cpr->offset1);
   3ba0e:	f8b6 002d 	ldrh.w	r0, [r6, #45]	; 0x2d
			conn->llcp_conn_param.offset1 =
   3ba12:	f8a4 01ae 	strh.w	r0, [r4, #430]	; 0x1ae
				sys_le16_to_cpu(cpr->offset2);
   3ba16:	f8b6 002f 	ldrh.w	r0, [r6, #47]	; 0x2f
			conn->llcp_conn_param.offset2 =
   3ba1a:	f8a4 01b0 	strh.w	r0, [r4, #432]	; 0x1b0
				sys_le16_to_cpu(cpr->offset3);
   3ba1e:	f8b6 0031 	ldrh.w	r0, [r6, #49]	; 0x31
			conn->llcp_conn_param.offset3 =
   3ba22:	f8a4 01b2 	strh.w	r0, [r4, #434]	; 0x1b2
				sys_le16_to_cpu(cpr->offset4);
   3ba26:	f8b6 0033 	ldrh.w	r0, [r6, #51]	; 0x33
			conn->llcp_conn_param.offset4 =
   3ba2a:	f8a4 01b4 	strh.w	r0, [r4, #436]	; 0x1b4
				sys_le16_to_cpu(cpr->offset5);
   3ba2e:	f8b6 0035 	ldrh.w	r0, [r6, #53]	; 0x35
			conn->llcp_conn_param.offset5 =
   3ba32:	f8a4 01b6 	strh.w	r0, [r4, #438]	; 0x1b6
			if ((conn->llcp_conn_param.interval_max !=
   3ba36:	8d60      	ldrh	r0, [r4, #42]	; 0x2a
   3ba38:	4560      	cmp	r0, ip
   3ba3a:	f000 8377 	beq.w	3c12c <ull_conn_rx+0x18b4>
				conn->llcp_conn_param.state =
   3ba3e:	f894 3196 	ldrb.w	r3, [r4, #406]	; 0x196
   3ba42:	2003      	movs	r0, #3
   3ba44:	f360 0303 	bfi	r3, r0, #0, #4
   3ba48:	f884 3196 	strb.w	r3, [r4, #406]	; 0x196
			conn->llcp_conn_param.remote = 1U;
   3ba4c:	f894 3196 	ldrb.w	r3, [r4, #406]	; 0x196
			conn->llcp_conn_param.ack--;
   3ba50:	3901      	subs	r1, #1
			conn->llcp_conn_param.remote = 1U;
   3ba52:	f043 0320 	orr.w	r3, r3, #32
   3ba56:	f884 3196 	strb.w	r3, [r4, #406]	; 0x196
			conn->llcp_conn_param.ack--;
   3ba5a:	f884 1195 	strb.w	r1, [r4, #405]	; 0x195
	if (!conn_upd_curr) {
   3ba5e:	2a00      	cmp	r2, #0
   3ba60:	f47e af73 	bne.w	3a94a <ull_conn_rx+0xd2>
		conn_upd_curr = conn;
   3ba64:	603c      	str	r4, [r7, #0]
   3ba66:	f7fe bf70 	b.w	3a94a <ull_conn_rx+0xd2>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
   3ba6a:	4864      	ldr	r0, [pc, #400]	; (3bbfc <ull_conn_rx+0x1384>)
   3ba6c:	f7f8 fd24 	bl	344b8 <mem_acquire>
		if (!tx) {
   3ba70:	4601      	mov	r1, r0
   3ba72:	2800      	cmp	r0, #0
   3ba74:	f43f adc9 	beq.w	3b60a <ull_conn_rx+0xd92>
		conn->llcp_version.tx = 1U;
   3ba78:	f894 314a 	ldrb.w	r3, [r4, #330]	; 0x14a
   3ba7c:	f043 0301 	orr.w	r3, r3, #1
   3ba80:	f884 314a 	strb.w	r3, [r4, #330]	; 0x14a
		pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
   3ba84:	7903      	ldrb	r3, [r0, #4]
		pdu_tx->len =
   3ba86:	7145      	strb	r5, [r0, #5]
		pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
   3ba88:	f043 0303 	orr.w	r3, r3, #3
   3ba8c:	7103      	strb	r3, [r0, #4]
		pdu_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_VERSION_IND;
   3ba8e:	f640 420c 	movw	r2, #3084	; 0xc0c
		v->company_id =	sys_cpu_to_le16(ll_settings_company_id());
   3ba92:	4b5b      	ldr	r3, [pc, #364]	; (3bc00 <ull_conn_rx+0x1388>)
   3ba94:	f8c0 3009 	str.w	r3, [r0, #9]
		pdu_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_VERSION_IND;
   3ba98:	f8a0 2007 	strh.w	r2, [r0, #7]
		ctrl_tx_sec_enqueue(conn, tx);
   3ba9c:	4620      	mov	r0, r4
   3ba9e:	f7fd fd9d 	bl	395dc <ctrl_tx_sec_enqueue>
		rx->hdr.type = NODE_RX_TYPE_RELEASE;
   3baa2:	2301      	movs	r3, #1
   3baa4:	7133      	strb	r3, [r6, #4]
   3baa6:	f7ff b8d5 	b.w	3ac54 <ull_conn_rx+0x3dc>
				nack = reject_ext_ind_send(conn, *rx,
   3baaa:	231e      	movs	r3, #30
   3baac:	220f      	movs	r2, #15
   3baae:	f7ff b871 	b.w	3ab94 <ull_conn_rx+0x31c>
			conn->llcp_length.disabled = 1U;
   3bab2:	f894 31c6 	ldrb.w	r3, [r4, #454]	; 0x1c6
			conn->llcp_length.ack = conn->llcp_length.req;
   3bab6:	f884 21c5 	strb.w	r2, [r4, #453]	; 0x1c5
			conn->llcp_length.disabled = 1U;
   3baba:	f043 0308 	orr.w	r3, r3, #8
   3babe:	f884 31c6 	strb.w	r3, [r4, #454]	; 0x1c6
			conn->llcp_length.ack = conn->llcp_length.req;
   3bac2:	f7ff b9ab 	b.w	3ae1c <ull_conn_rx+0x5a4>
		if (!conn->tx_ctrl) {
   3bac6:	f8d4 11e0 	ldr.w	r1, [r4, #480]	; 0x1e0
   3baca:	2900      	cmp	r1, #0
   3bacc:	f47f aefd 	bne.w	3b8ca <ull_conn_rx+0x1052>
			tx->next = conn->tx_head;
   3bad0:	601a      	str	r2, [r3, #0]
				conn->tx_ctrl = tx;
   3bad2:	e9c4 3377 	strd	r3, r3, [r4, #476]	; 0x1dc
				conn->tx_ctrl_last = tx;
   3bad6:	e6ff      	b.n	3b8d8 <ull_conn_rx+0x1060>
   3bad8:	9901      	ldr	r1, [sp, #4]
   3bada:	e5f8      	b.n	3b6ce <ull_conn_rx+0xe56>
				nack = reject_ext_ind_send(conn, *rx,
   3badc:	2323      	movs	r3, #35	; 0x23
   3bade:	f7ff b8f5 	b.w	3accc <ull_conn_rx+0x454>
			conn->llcp.encryption.state = LLCP_ENC_STATE_INPROG;
   3bae2:	f894 2100 	ldrb.w	r2, [r4, #256]	; 0x100
   3bae6:	f36f 0201 	bfc	r2, #0, #2
   3baea:	f884 2100 	strb.w	r2, [r4, #256]	; 0x100
   3baee:	f7ff b9b9 	b.w	3ae64 <ull_conn_rx+0x5ec>
				conn->llcp_phy.state =
   3baf2:	f894 31d6 	ldrb.w	r3, [r4, #470]	; 0x1d6
				if (conn->llcp_phy.ack ==
   3baf6:	428a      	cmp	r2, r1
				conn->llcp_phy.state =
   3baf8:	f043 0303 	orr.w	r3, r3, #3
   3bafc:	f884 31d6 	strb.w	r3, [r4, #470]	; 0x1d6
				if (conn->llcp_phy.ack ==
   3bb00:	d111      	bne.n	3bb26 <ull_conn_rx+0x12ae>
					conn->llcp_phy.ack--;
   3bb02:	1e53      	subs	r3, r2, #1
					conn->llcp_phy.tx =
   3bb04:	f8b4 21d6 	ldrh.w	r2, [r4, #470]	; 0x1d6
						conn->phy_pref_rx;
   3bb08:	f894 11d8 	ldrb.w	r1, [r4, #472]	; 0x1d8
					conn->llcp_phy.ack--;
   3bb0c:	f884 31d5 	strb.w	r3, [r4, #469]	; 0x1d5
					conn->llcp_phy.tx =
   3bb10:	f422 629f 	bic.w	r2, r2, #1272	; 0x4f8
   3bb14:	f240 43fc 	movw	r3, #1276	; 0x4fc
   3bb18:	f022 0204 	bic.w	r2, r2, #4
   3bb1c:	ea03 0381 	and.w	r3, r3, r1, lsl #2
   3bb20:	4313      	orrs	r3, r2
   3bb22:	f8a4 31d6 	strh.w	r3, [r4, #470]	; 0x1d6
				conn->llcp_phy.tx &= p->rx_phys;
   3bb26:	f894 31d6 	ldrb.w	r3, [r4, #470]	; 0x1d6
   3bb2a:	f896 2021 	ldrb.w	r2, [r6, #33]	; 0x21
   3bb2e:	f3c3 0182 	ubfx	r1, r3, #2, #3
   3bb32:	400a      	ands	r2, r1
   3bb34:	f362 0384 	bfi	r3, r2, #2, #3
   3bb38:	f884 31d6 	strb.w	r3, [r4, #470]	; 0x1d6
				conn->llcp_phy.rx &= p->tx_phys;
   3bb3c:	f896 2020 	ldrb.w	r2, [r6, #32]
   3bb40:	f3c3 1142 	ubfx	r1, r3, #5, #3
   3bb44:	400a      	ands	r2, r1
   3bb46:	f362 1347 	bfi	r3, r2, #5, #3
				if (!conn->llcp_phy.tx || !conn->llcp_phy.rx) {
   3bb4a:	f003 021c 	and.w	r2, r3, #28
				conn->llcp_phy.rx &= p->tx_phys;
   3bb4e:	f884 31d6 	strb.w	r3, [r4, #470]	; 0x1d6
				if (!conn->llcp_phy.tx || !conn->llcp_phy.rx) {
   3bb52:	b2db      	uxtb	r3, r3
   3bb54:	b10a      	cbz	r2, 3bb5a <ull_conn_rx+0x12e2>
   3bb56:	2b1f      	cmp	r3, #31
   3bb58:	d805      	bhi.n	3bb66 <ull_conn_rx+0x12ee>
					conn->llcp_phy.tx = 0U;
   3bb5a:	f894 31d6 	ldrb.w	r3, [r4, #470]	; 0x1d6
   3bb5e:	f003 0303 	and.w	r3, r3, #3
   3bb62:	f884 31d6 	strb.w	r3, [r4, #470]	; 0x1d6
				conn->llcp_phy.pause_tx = 1U;
   3bb66:	f894 31d7 	ldrb.w	r3, [r4, #471]	; 0x1d7
				(*rx)->hdr.type = NODE_RX_TYPE_RELEASE;
   3bb6a:	2201      	movs	r2, #1
				conn->llcp_phy.pause_tx = 1U;
   3bb6c:	4313      	orrs	r3, r2
   3bb6e:	f884 31d7 	strb.w	r3, [r4, #471]	; 0x1d7
				(*rx)->hdr.type = NODE_RX_TYPE_RELEASE;
   3bb72:	682b      	ldr	r3, [r5, #0]
   3bb74:	711a      	strb	r2, [r3, #4]
   3bb76:	f7fe bee8 	b.w	3a94a <ull_conn_rx+0xd2>
				nack = reject_ext_ind_send(conn, *rx,
   3bb7a:	231e      	movs	r3, #30
   3bb7c:	2210      	movs	r2, #16
   3bb7e:	f7ff b809 	b.w	3ab94 <ull_conn_rx+0x31c>
			lll->phy_tx_time = lll->phy_tx;
   3bb82:	f894 2060 	ldrb.w	r2, [r4, #96]	; 0x60
			conn->llcp_phy.pause_tx = 0U;
   3bb86:	f894 31d7 	ldrb.w	r3, [r4, #471]	; 0x1d7
			conn->llcp_phy.ack = conn->llcp_phy.req;
   3bb8a:	f884 11d5 	strb.w	r1, [r4, #469]	; 0x1d5
			conn->llcp_phy.pause_tx = 0U;
   3bb8e:	f023 0309 	bic.w	r3, r3, #9
			lll->phy_tx_time = lll->phy_tx;
   3bb92:	f3c2 0102 	ubfx	r1, r2, #0, #3
			conn->llcp_phy.pause_tx = 0U;
   3bb96:	f043 0308 	orr.w	r3, r3, #8
			lll->phy_tx_time = lll->phy_tx;
   3bb9a:	f361 1206 	bfi	r2, r1, #4, #3
   3bb9e:	f884 2060 	strb.w	r2, [r4, #96]	; 0x60
			if (conn->llcp_phy.cmd) {
   3bba2:	075a      	lsls	r2, r3, #29
			conn->llcp_phy.pause_tx = 0U;
   3bba4:	f884 31d7 	strb.w	r3, [r4, #471]	; 0x1d7
			if (conn->llcp_phy.cmd) {
   3bba8:	f140 8101 	bpl.w	3bdae <ull_conn_rx+0x1536>
				(*rx)->hdr.type = NODE_RX_TYPE_PHY_UPDATE;
   3bbac:	682a      	ldr	r2, [r5, #0]
				p->status = 0U;
   3bbae:	2300      	movs	r3, #0
				(*rx)->hdr.type = NODE_RX_TYPE_PHY_UPDATE;
   3bbb0:	211d      	movs	r1, #29
   3bbb2:	7111      	strb	r1, [r2, #4]
				p->status = 0U;
   3bbb4:	7733      	strb	r3, [r6, #28]
				p->tx = lll->phy_tx;
   3bbb6:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
   3bbba:	f3c3 0302 	ubfx	r3, r3, #0, #3
   3bbbe:	7773      	strb	r3, [r6, #29]
				p->rx = lll->phy_rx;
   3bbc0:	f894 3061 	ldrb.w	r3, [r4, #97]	; 0x61
   3bbc4:	f3c3 0302 	ubfx	r3, r3, #0, #3
   3bbc8:	77b3      	strb	r3, [r6, #30]
   3bbca:	f7ff b927 	b.w	3ae1c <ull_conn_rx+0x5a4>
	conn->llcp_enc.pause_rx = 0U;
   3bbce:	f894 2176 	ldrb.w	r2, [r4, #374]	; 0x176
	conn->llcp_ack = conn->llcp_req;
   3bbd2:	f884 30f1 	strb.w	r3, [r4, #241]	; 0xf1
	conn->procedure_expire = 0U;
   3bbd6:	2100      	movs	r1, #0
	conn->llcp_enc.pause_rx = 0U;
   3bbd8:	f022 0203 	bic.w	r2, r2, #3
   3bbdc:	f884 2176 	strb.w	r2, [r4, #374]	; 0x176
	conn->procedure_expire = 0U;
   3bbe0:	f8a4 10c8 	strh.w	r1, [r4, #200]	; 0xc8
	if (err) {
   3bbe4:	f7fe beb1 	b.w	3a94a <ull_conn_rx+0xd2>
				nack = reject_ext_ind_send(conn, *rx,
   3bbe8:	2323      	movs	r3, #35	; 0x23
   3bbea:	220f      	movs	r2, #15
   3bbec:	f7fe bfd2 	b.w	3ab94 <ull_conn_rx+0x31c>
   3bbf0:	0005269c 	.word	0x0005269c
   3bbf4:	000527d0 	.word	0x000527d0
   3bbf8:	0005214c 	.word	0x0005214c
   3bbfc:	20005384 	.word	0x20005384
   3bc00:	ffff05f1 	.word	0xffff05f1
	if (util_ones_count_get(&phy, sizeof(phy)) > 1U) {
   3bc04:	2101      	movs	r1, #1
   3bc06:	f10d 000f 	add.w	r0, sp, #15
	phy = ind->c_to_p_phy;
   3bc0a:	f88d 200f 	strb.w	r2, [sp, #15]
	if (util_ones_count_get(&phy, sizeof(phy)) > 1U) {
   3bc0e:	f7f8 fe35 	bl	3487c <util_ones_count_get>
   3bc12:	2801      	cmp	r0, #1
   3bc14:	f200 80c0 	bhi.w	3bd98 <ull_conn_rx+0x1520>
	phy = ind->p_to_c_phy;
   3bc18:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
   3bc1c:	f88d 300f 	strb.w	r3, [sp, #15]
	if (util_ones_count_get(&phy, sizeof(phy)) > 1U) {
   3bc20:	f10d 000f 	add.w	r0, sp, #15
   3bc24:	2101      	movs	r1, #1
   3bc26:	f7f8 fe29 	bl	3487c <util_ones_count_get>
   3bc2a:	2801      	cmp	r0, #1
   3bc2c:	f200 80b4 	bhi.w	3bd98 <ull_conn_rx+0x1520>
	instant = sys_le16_to_cpu(ind->instant);
   3bc30:	8c72      	ldrh	r2, [r6, #34]	; 0x22
	if (((instant - conn->lll.event_counter) & 0xffff) > 0x7fff) {
   3bc32:	8e63      	ldrh	r3, [r4, #50]	; 0x32
   3bc34:	1ad3      	subs	r3, r2, r3
   3bc36:	041b      	lsls	r3, r3, #16
   3bc38:	f100 8236 	bmi.w	3c0a8 <ull_conn_rx+0x1830>
	if (((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) {
   3bc3c:	f894 30f0 	ldrb.w	r3, [r4, #240]	; 0xf0
   3bc40:	f894 10f1 	ldrb.w	r1, [r4, #241]	; 0xf1
   3bc44:	1a5b      	subs	r3, r3, r1
   3bc46:	f003 0303 	and.w	r3, r3, #3
   3bc4a:	2b02      	cmp	r3, #2
   3bc4c:	f000 8227 	beq.w	3c09e <ull_conn_rx+0x1826>
	if ((conn->llcp_phy.ack != conn->llcp_phy.req) &&
   3bc50:	f894 11d4 	ldrb.w	r1, [r4, #468]	; 0x1d4
   3bc54:	f894 31d5 	ldrb.w	r3, [r4, #469]	; 0x1d5
   3bc58:	428b      	cmp	r3, r1
   3bc5a:	d018      	beq.n	3bc8e <ull_conn_rx+0x1416>
	    (conn->llcp_phy.state == LLCP_PHY_STATE_RSP_WAIT)) {
   3bc5c:	f894 31d6 	ldrb.w	r3, [r4, #470]	; 0x1d6
	if ((conn->llcp_phy.ack != conn->llcp_phy.req) &&
   3bc60:	f003 0303 	and.w	r3, r3, #3
   3bc64:	2b02      	cmp	r3, #2
   3bc66:	d112      	bne.n	3bc8e <ull_conn_rx+0x1416>
		conn->llcp_phy.pause_tx = 0U;
   3bc68:	f894 31d7 	ldrb.w	r3, [r4, #471]	; 0x1d7
		conn->llcp_phy.ack = conn->llcp_phy.req;
   3bc6c:	f884 11d5 	strb.w	r1, [r4, #469]	; 0x1d5
		conn->llcp_phy.pause_tx = 0U;
   3bc70:	f36f 0300 	bfc	r3, #0, #1
		conn->llcp.phy_upd_ind.cmd = conn->llcp_phy.cmd;
   3bc74:	f894 10f4 	ldrb.w	r1, [r4, #244]	; 0xf4
		conn->llcp_phy.pause_tx = 0U;
   3bc78:	f884 31d7 	strb.w	r3, [r4, #471]	; 0x1d7
		conn->llcp.phy_upd_ind.cmd = conn->llcp_phy.cmd;
   3bc7c:	f3c3 0380 	ubfx	r3, r3, #2, #1
   3bc80:	f363 0141 	bfi	r1, r3, #1, #1
		conn->procedure_expire = 0U;
   3bc84:	2300      	movs	r3, #0
		conn->llcp.phy_upd_ind.cmd = conn->llcp_phy.cmd;
   3bc86:	f884 10f4 	strb.w	r1, [r4, #244]	; 0xf4
		conn->procedure_expire = 0U;
   3bc8a:	f8a4 30c8 	strh.w	r3, [r4, #200]	; 0xc8
	conn->llcp.phy_upd_ind.tx = ind->p_to_c_phy;
   3bc8e:	f896 1021 	ldrb.w	r1, [r6, #33]	; 0x21
   3bc92:	f894 30f4 	ldrb.w	r3, [r4, #244]	; 0xf4
   3bc96:	f361 0384 	bfi	r3, r1, #2, #3
   3bc9a:	f884 30f4 	strb.w	r3, [r4, #244]	; 0xf4
	conn->llcp.phy_upd_ind.rx = ind->c_to_p_phy;
   3bc9e:	f896 1020 	ldrb.w	r1, [r6, #32]
	conn->llcp.phy_upd_ind.instant = instant;
   3bca2:	f8a4 20f6 	strh.w	r2, [r4, #246]	; 0xf6
	conn->llcp.phy_upd_ind.initiate = 0U;
   3bca6:	b2db      	uxtb	r3, r3
   3bca8:	f003 031e 	and.w	r3, r3, #30
	link->mem = conn->llcp_rx;
   3bcac:	f8d4 2114 	ldr.w	r2, [r4, #276]	; 0x114
	conn->llcp.phy_upd_ind.initiate = 0U;
   3bcb0:	ea43 1341 	orr.w	r3, r3, r1, lsl #5
   3bcb4:	f884 30f4 	strb.w	r3, [r4, #244]	; 0xf4
	link->mem = conn->llcp_rx;
   3bcb8:	607a      	str	r2, [r7, #4]
	(*rx)->hdr.link = link;
   3bcba:	682a      	ldr	r2, [r5, #0]
   3bcbc:	6017      	str	r7, [r2, #0]
	conn->llcp_rx = *rx;
   3bcbe:	682a      	ldr	r2, [r5, #0]
   3bcc0:	f8c4 2114 	str.w	r2, [r4, #276]	; 0x114
	*rx = NULL;
   3bcc4:	2300      	movs	r3, #0
   3bcc6:	602b      	str	r3, [r5, #0]
	conn->llcp_ack -= 2U;
   3bcc8:	f894 20f1 	ldrb.w	r2, [r4, #241]	; 0xf1
	if (conn->llcp.phy_upd_ind.tx) {
   3bccc:	f894 30f4 	ldrb.w	r3, [r4, #244]	; 0xf4
	conn->llcp_type = LLCP_PHY_UPD;
   3bcd0:	2106      	movs	r1, #6
	conn->llcp_ack -= 2U;
   3bcd2:	3a02      	subs	r2, #2
	if (conn->llcp.phy_upd_ind.tx) {
   3bcd4:	f013 0f1c 	tst.w	r3, #28
	conn->llcp_type = LLCP_PHY_UPD;
   3bcd8:	f884 10f2 	strb.w	r1, [r4, #242]	; 0xf2
	conn->llcp_ack -= 2U;
   3bcdc:	f884 20f1 	strb.w	r2, [r4, #241]	; 0xf1
	if (conn->llcp.phy_upd_ind.tx) {
   3bce0:	f43e ae33 	beq.w	3a94a <ull_conn_rx+0xd2>
		conn->lll.phy_tx_time = conn->llcp.phy_upd_ind.tx;
   3bce4:	f894 2060 	ldrb.w	r2, [r4, #96]	; 0x60
   3bce8:	f3c3 0382 	ubfx	r3, r3, #2, #3
   3bcec:	f363 1206 	bfi	r2, r3, #4, #3
   3bcf0:	f884 2060 	strb.w	r2, [r4, #96]	; 0x60
		if (err) {
   3bcf4:	f7fe be29 	b.w	3a94a <ull_conn_rx+0xd2>
			conn->procedure_expire = 0U;
   3bcf8:	2700      	movs	r7, #0
   3bcfa:	f8a4 70c8 	strh.w	r7, [r4, #200]	; 0xc8
			if (eff_tx_octets == conn->lll.max_tx_octets &&
   3bcfe:	9f01      	ldr	r7, [sp, #4]
			conn->llcp_length.ack = conn->llcp_length.req;
   3bd00:	f884 21c5 	strb.w	r2, [r4, #453]	; 0x1c5
			if (eff_tx_octets == conn->lll.max_tx_octets &&
   3bd04:	42b9      	cmp	r1, r7
   3bd06:	f000 812b 	beq.w	3bf60 <ull_conn_rx+0x16e8>
			conn->lll.max_rx_time = eff_rx_time;
   3bd0a:	f8a4 c05e 	strh.w	ip, [r4, #94]	; 0x5e
			if (tx) {
   3bd0e:	2b00      	cmp	r3, #0
   3bd10:	f000 8134 	beq.w	3bf7c <ull_conn_rx+0x1704>
					(conn->llcp_length.req - 1);
   3bd14:	3a01      	subs	r2, #1
				conn->llcp_length.ack =
   3bd16:	f884 21c5 	strb.w	r2, [r4, #453]	; 0x1c5
				conn->llcp_length.state =
   3bd1a:	f894 21c6 	ldrb.w	r2, [r4, #454]	; 0x1c6
				conn->llcp_length.rx_octets = eff_rx_octets;
   3bd1e:	f8a4 e1c8 	strh.w	lr, [r4, #456]	; 0x1c8
				conn->llcp_length.state =
   3bd22:	2503      	movs	r5, #3
   3bd24:	f365 0202 	bfi	r2, r5, #0, #3
				conn->llcp_length.tx_octets = eff_tx_octets;
   3bd28:	f8a4 11ca 	strh.w	r1, [r4, #458]	; 0x1ca
				conn->llcp_length.rx_time = eff_rx_time;
   3bd2c:	f8a4 c1cc 	strh.w	ip, [r4, #460]	; 0x1cc
				conn->llcp_length.tx_time = eff_tx_time;
   3bd30:	f8a4 01ce 	strh.w	r0, [r4, #462]	; 0x1ce
				conn->llcp_length.state =
   3bd34:	f884 21c6 	strb.w	r2, [r4, #454]	; 0x1c6
			lr->max_rx_octets = sys_cpu_to_le16(eff_rx_octets);
   3bd38:	f8a6 e020 	strh.w	lr, [r6, #32]
			lr->max_tx_octets = sys_cpu_to_le16(eff_tx_octets);
   3bd3c:	84b1      	strh	r1, [r6, #36]	; 0x24
			lr->max_rx_time = sys_cpu_to_le16(eff_rx_time);
   3bd3e:	f8a6 c022 	strh.w	ip, [r6, #34]	; 0x22
			lr->max_tx_time = sys_cpu_to_le16(eff_tx_time);
   3bd42:	84f0      	strh	r0, [r6, #38]	; 0x26
	if (tx) {
   3bd44:	e4fb      	b.n	3b73e <ull_conn_rx+0xec6>
		err = BT_HCI_ERR_DIFF_TRANS_COLLISION;
   3bd46:	232a      	movs	r3, #42	; 0x2a
	rx->hdr.type = NODE_RX_TYPE_RELEASE;
   3bd48:	2201      	movs	r2, #1
   3bd4a:	7132      	strb	r2, [r6, #4]
			conn->llcp_terminate.reason_final = err;
   3bd4c:	f884 3153 	strb.w	r3, [r4, #339]	; 0x153
   3bd50:	f7fe bdfb 	b.w	3a94a <ull_conn_rx+0xd2>
		err = BT_HCI_ERR_INSTANT_PASSED;
   3bd54:	2328      	movs	r3, #40	; 0x28
   3bd56:	e7f7      	b.n	3bd48 <ull_conn_rx+0x14d0>
	    ((pdu_data_tx->llctrl.opcode !=
   3bd58:	79da      	ldrb	r2, [r3, #7]
	if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   3bd5a:	2a03      	cmp	r2, #3
   3bd5c:	f43f a8e2 	beq.w	3af24 <ull_conn_rx+0x6ac>
	      PDU_DATA_LLCTRL_TYPE_ENC_REQ) &&
   3bd60:	2a0a      	cmp	r2, #10
   3bd62:	f47e ae51 	bne.w	3aa08 <ull_conn_rx+0x190>
   3bd66:	f7ff b8dd 	b.w	3af24 <ull_conn_rx+0x6ac>
   3bd6a:	601c      	str	r4, [r3, #0]
   3bd6c:	f7ff ba33 	b.w	3b1d6 <ull_conn_rx+0x95e>
				conn->lll.max_tx_octets = eff_tx_octets;
   3bd70:	f8a4 1058 	strh.w	r1, [r4, #88]	; 0x58
				conn->llcp_length.state =
   3bd74:	f894 11c6 	ldrb.w	r1, [r4, #454]	; 0x1c6
				conn->lll.max_tx_time = eff_tx_time;
   3bd78:	f8a4 005c 	strh.w	r0, [r4, #92]	; 0x5c
				conn->llcp_length.state =
   3bd7c:	2004      	movs	r0, #4
   3bd7e:	f360 0102 	bfi	r1, r0, #0, #3
   3bd82:	f884 11c6 	strb.w	r1, [r4, #454]	; 0x1c6
			link->mem = conn->llcp_rx;
   3bd86:	607a      	str	r2, [r7, #4]
			(*rx)->hdr.link = link;
   3bd88:	682a      	ldr	r2, [r5, #0]
   3bd8a:	6017      	str	r7, [r2, #0]
			conn->llcp_rx = *rx;
   3bd8c:	682a      	ldr	r2, [r5, #0]
   3bd8e:	f8c4 2114 	str.w	r2, [r4, #276]	; 0x114
			*rx = NULL;
   3bd92:	602b      	str	r3, [r5, #0]
	if (tx) {
   3bd94:	f7fe bdd9 	b.w	3a94a <ull_conn_rx+0xd2>
		(*rx)->hdr.type = NODE_RX_TYPE_RELEASE;
   3bd98:	682b      	ldr	r3, [r5, #0]
   3bd9a:	2201      	movs	r2, #1
   3bd9c:	711a      	strb	r2, [r3, #4]
		return BT_HCI_ERR_INVALID_LL_PARAM;
   3bd9e:	231e      	movs	r3, #30
			conn->llcp_terminate.reason_final = err;
   3bda0:	f884 3153 	strb.w	r3, [r4, #339]	; 0x153
   3bda4:	f7fe bdd1 	b.w	3a94a <ull_conn_rx+0xd2>
	struct node_tx *tx = NULL;
   3bda8:	2300      	movs	r3, #0
   3bdaa:	f7fe be90 	b.w	3aace <ull_conn_rx+0x256>
				(*rx)->hdr.type = NODE_RX_TYPE_RELEASE;
   3bdae:	682b      	ldr	r3, [r5, #0]
   3bdb0:	2201      	movs	r2, #1
   3bdb2:	711a      	strb	r2, [r3, #4]
   3bdb4:	f7ff b832 	b.w	3ae1c <ull_conn_rx+0x5a4>
	LL_ASSERT(IS_PTR_ALIGNED(node, struct node_rx_cu));
   3bdb8:	4acf      	ldr	r2, [pc, #828]	; (3c0f8 <ull_conn_rx+0x1880>)
   3bdba:	49d0      	ldr	r1, [pc, #832]	; (3c0fc <ull_conn_rx+0x1884>)
   3bdbc:	48d0      	ldr	r0, [pc, #832]	; (3c100 <ull_conn_rx+0x1888>)
   3bdbe:	f241 53e6 	movw	r3, #5606	; 0x15e6
   3bdc2:	f00d f95f 	bl	49084 <assert_print>
   3bdc6:	4040      	eors	r0, r0
   3bdc8:	f380 8811 	msr	BASEPRI, r0
   3bdcc:	f04f 0003 	mov.w	r0, #3
   3bdd0:	df02      	svc	2
   3bdd2:	f7ff bb74 	b.w	3b4be <ull_conn_rx+0xc46>
			LL_ASSERT(conn->periph.llcp_type == LLCP_NONE);
   3bdd6:	f894 30e5 	ldrb.w	r3, [r4, #229]	; 0xe5
			conn->llcp_ack += 2U;
   3bdda:	3202      	adds	r2, #2
   3bddc:	f884 20f1 	strb.w	r2, [r4, #241]	; 0xf1
			LL_ASSERT(conn->periph.llcp_type == LLCP_NONE);
   3bde0:	2b00      	cmp	r3, #0
   3bde2:	f040 80d7 	bne.w	3bf94 <ull_conn_rx+0x171c>
			conn->periph.llcp_type = conn->llcp_type;
   3bde6:	f894 30f2 	ldrb.w	r3, [r4, #242]	; 0xf2
   3bdea:	f884 30e5 	strb.w	r3, [r4, #229]	; 0xe5
   3bdee:	f7ff bad4 	b.w	3b39a <ull_conn_rx+0xb22>
	conn_upd_curr = NULL;
   3bdf2:	4fc4      	ldr	r7, [pc, #784]	; (3c104 <ull_conn_rx+0x188c>)
	if (conn->llcp_conn_param.cache.timeout) {
   3bdf4:	f8b4 01a6 	ldrh.w	r0, [r4, #422]	; 0x1a6
   3bdf8:	2300      	movs	r3, #0
   3bdfa:	603b      	str	r3, [r7, #0]
   3bdfc:	2800      	cmp	r0, #0
   3bdfe:	f000 80dc 	beq.w	3bfba <ull_conn_rx+0x1742>
		conn->llcp_conn_param.cache.timeout = 0U;
   3be02:	f8a4 31a6 	strh.w	r3, [r4, #422]	; 0x1a6
		conn->llcp_conn_param.state = LLCP_CPR_STATE_REQ;
   3be06:	f8b4 3196 	ldrh.w	r3, [r4, #406]	; 0x196
		conn->llcp_conn_param.timeout =
   3be0a:	f8a4 019e 	strh.w	r0, [r4, #414]	; 0x19e
		conn->llcp_conn_param.state = LLCP_CPR_STATE_REQ;
   3be0e:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   3be12:	f043 0310 	orr.w	r3, r3, #16
   3be16:	f8a4 3196 	strh.w	r3, [r4, #406]	; 0x196
		conn->llcp_conn_param.interval_min =
   3be1a:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
   3be1e:	f8c4 3198 	str.w	r3, [r4, #408]	; 0x198
		conn->llcp_conn_param.latency =
   3be22:	f8b4 31a4 	ldrh.w	r3, [r4, #420]	; 0x1a4
   3be26:	f8a4 319c 	strh.w	r3, [r4, #412]	; 0x19c
			if (!conn->llcp_conn_param.cmd) {
   3be2a:	f894 1196 	ldrb.w	r1, [r4, #406]	; 0x196
				(*rx)->hdr.type = NODE_RX_TYPE_RELEASE;
   3be2e:	682b      	ldr	r3, [r5, #0]
			if (!conn->llcp_conn_param.cmd) {
   3be30:	06c8      	lsls	r0, r1, #27
   3be32:	f57e ad88 	bpl.w	3a946 <ull_conn_rx+0xce>
			(*rx)->hdr.type = NODE_RX_TYPE_CONN_UPDATE;
   3be36:	2119      	movs	r1, #25
   3be38:	7119      	strb	r1, [r3, #4]
			LL_ASSERT(IS_PTR_ALIGNED(node, struct node_rx_cu));
   3be3a:	07d1      	lsls	r1, r2, #31
   3be3c:	f100 8168 	bmi.w	3c110 <ull_conn_rx+0x1898>
			cu->status = BT_HCI_ERR_UNSUPP_REMOTE_FEATURE;
   3be40:	231a      	movs	r3, #26
   3be42:	7733      	strb	r3, [r6, #28]
			cu->interval = lll->interval;
   3be44:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
   3be46:	83f3      	strh	r3, [r6, #30]
			cu->latency = lll->latency;
   3be48:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
   3be4a:	8433      	strh	r3, [r6, #32]
			cu->timeout = conn->supervision_reload *
   3be4c:	f8b4 30c2 	ldrh.w	r3, [r4, #194]	; 0xc2
				      lll->interval * 125U / 1000;
   3be50:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
   3be52:	227d      	movs	r2, #125	; 0x7d
			cu->timeout = conn->supervision_reload *
   3be54:	fb01 f303 	mul.w	r3, r1, r3
				      lll->interval * 125U / 1000;
   3be58:	fb02 f303 	mul.w	r3, r2, r3
   3be5c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   3be60:	fbb3 f3f2 	udiv	r3, r3, r2
			cu->timeout = conn->supervision_reload *
   3be64:	8473      	strh	r3, [r6, #34]	; 0x22
			    PDU_DATA_LLCTRL_TYPE_CONN_PARAM_REQ)) {
   3be66:	f7fe bfd9 	b.w	3ae1c <ull_conn_rx+0x5a4>
	else if (rej_ext_ind->error_code != BT_HCI_ERR_LL_PROC_COLLISION) {
   3be6a:	2b23      	cmp	r3, #35	; 0x23
			conn->periph.ticks_to_offset =
   3be6c:	bf1c      	itt	ne
   3be6e:	f8d4 31c0 	ldrne.w	r3, [r4, #448]	; 0x1c0
   3be72:	f8c4 30ec 	strne.w	r3, [r4, #236]	; 0xec
   3be76:	e489      	b.n	3b78c <ull_conn_rx+0xf14>
				uint16_t interval_min =
   3be78:	f8d6 9020 	ldr.w	r9, [r6, #32]
					cpr->preferred_periodicity;
   3be7c:	f896 a028 	ldrb.w	sl, [r6, #40]	; 0x28
				uint16_t interval_min =
   3be80:	f8d6 8024 	ldr.w	r8, [r6, #36]	; 0x24
					cpr->preferred_periodicity;
   3be84:	f8cd a004 	str.w	sl, [sp, #4]
   3be88:	fa1f f089 	uxth.w	r0, r9
				if ((interval_min < CONN_INTERVAL_MIN(conn)) ||
   3be8c:	2805      	cmp	r0, #5
   3be8e:	f67f ae0c 	bls.w	3baaa <ull_conn_rx+0x1232>
   3be92:	ea4f 4c19 	mov.w	ip, r9, lsr #16
   3be96:	f5bc 6f48 	cmp.w	ip, #3200	; 0xc80
   3be9a:	f63f ae06 	bhi.w	3baaa <ull_conn_rx+0x1232>
				    (interval_max > 3200) ||
   3be9e:	4560      	cmp	r0, ip
   3bea0:	f63f ae03 	bhi.w	3baaa <ull_conn_rx+0x1232>
   3bea4:	fa1f fe88 	uxth.w	lr, r8
				    (interval_min > interval_max) ||
   3bea8:	f5be 7ffa 	cmp.w	lr, #500	; 0x1f4
   3beac:	f4bf adfd 	bcs.w	3baaa <ull_conn_rx+0x1232>
   3beb0:	ea4f 4018 	mov.w	r0, r8, lsr #16
				    (latency > 499) ||
   3beb4:	f1a0 0a0a 	sub.w	sl, r0, #10
   3beb8:	fa1f fa8a 	uxth.w	sl, sl
   3bebc:	f640 4b76 	movw	fp, #3190	; 0xc76
   3bec0:	45da      	cmp	sl, fp
   3bec2:	f63f adf2 	bhi.w	3baaa <ull_conn_rx+0x1232>
				     ((latency + 1) * interval_max)) ||
   3bec6:	f10e 0a01 	add.w	sl, lr, #1
   3beca:	fa1f fa8a 	uxth.w	sl, sl
   3bece:	fb0c fa0a 	mul.w	sl, ip, sl
				    (timeout > 3200) ||
   3bed2:	ebba 0f80 	cmp.w	sl, r0, lsl #2
   3bed6:	f4bf ade8 	bcs.w	3baaa <ull_conn_rx+0x1232>
				     ((latency + 1) * interval_max)) ||
   3beda:	f8dd a004 	ldr.w	sl, [sp, #4]
   3bede:	45e2      	cmp	sl, ip
   3bee0:	f63f ade3 	bhi.w	3baaa <ull_conn_rx+0x1232>
				conn->llcp_conn_param.interval_min =
   3bee4:	e9c4 9866 	strd	r9, r8, [r4, #408]	; 0x198
				conn->llcp_conn_param.preferred_periodicity =
   3bee8:	f8dd 8004 	ldr.w	r8, [sp, #4]
   3beec:	f884 81a8 	strb.w	r8, [r4, #424]	; 0x1a8
					sys_le16_to_cpu(cpr->reference_conn_event_count);
   3bef0:	f8b6 8029 	ldrh.w	r8, [r6, #41]	; 0x29
				conn->llcp_conn_param.reference_conn_event_count =
   3bef4:	f8a4 81aa 	strh.w	r8, [r4, #426]	; 0x1aa
					sys_le16_to_cpu(cpr->offset0);
   3bef8:	f8b6 802b 	ldrh.w	r8, [r6, #43]	; 0x2b
				conn->llcp_conn_param.offset0 =
   3befc:	f8a4 81ac 	strh.w	r8, [r4, #428]	; 0x1ac
					sys_le16_to_cpu(cpr->offset1);
   3bf00:	f8b6 802d 	ldrh.w	r8, [r6, #45]	; 0x2d
				conn->llcp_conn_param.offset1 =
   3bf04:	f8a4 81ae 	strh.w	r8, [r4, #430]	; 0x1ae
					sys_le16_to_cpu(cpr->offset2);
   3bf08:	f8b6 802f 	ldrh.w	r8, [r6, #47]	; 0x2f
				conn->llcp_conn_param.offset2 =
   3bf0c:	f8a4 81b0 	strh.w	r8, [r4, #432]	; 0x1b0
					sys_le16_to_cpu(cpr->offset3);
   3bf10:	f8b6 8031 	ldrh.w	r8, [r6, #49]	; 0x31
				conn->llcp_conn_param.offset3 =
   3bf14:	f8a4 81b2 	strh.w	r8, [r4, #434]	; 0x1b2
					sys_le16_to_cpu(cpr->offset4);
   3bf18:	f8b6 8033 	ldrh.w	r8, [r6, #51]	; 0x33
				conn->llcp_conn_param.offset4 =
   3bf1c:	f8a4 81b4 	strh.w	r8, [r4, #436]	; 0x1b4
					sys_le16_to_cpu(cpr->offset5);
   3bf20:	f8b6 6035 	ldrh.w	r6, [r6, #53]	; 0x35
				conn->llcp_conn_param.offset5 =
   3bf24:	f8a4 61b6 	strh.w	r6, [r4, #438]	; 0x1b6
				if ((conn->llcp_conn_param.interval_max !=
   3bf28:	8d66      	ldrh	r6, [r4, #42]	; 0x2a
   3bf2a:	4566      	cmp	r6, ip
   3bf2c:	f000 80c1 	beq.w	3c0b2 <ull_conn_rx+0x183a>
					if (conn->llcp_enc.pause_tx) {
   3bf30:	f013 0f02 	tst.w	r3, #2
						conn->llcp_conn_param.state =
   3bf34:	f894 3196 	ldrb.w	r3, [r4, #406]	; 0x196
					if (conn->llcp_enc.pause_tx) {
   3bf38:	f43f ad83 	beq.w	3ba42 <ull_conn_rx+0x11ca>
						conn->llcp_conn_param.state =
   3bf3c:	2102      	movs	r1, #2
   3bf3e:	f361 0303 	bfi	r3, r1, #0, #4
   3bf42:	f884 3196 	strb.w	r3, [r4, #406]	; 0x196
						(*rx)->hdr.type =
   3bf46:	682b      	ldr	r3, [r5, #0]
   3bf48:	2101      	movs	r1, #1
   3bf4a:	7119      	strb	r1, [r3, #4]
   3bf4c:	f894 1195 	ldrb.w	r1, [r4, #405]	; 0x195
   3bf50:	e57c      	b.n	3ba4c <ull_conn_rx+0x11d4>
				      0x03) == 0x02) &&
   3bf52:	f894 00f2 	ldrb.w	r0, [r4, #242]	; 0xf2
   3bf56:	2803      	cmp	r0, #3
   3bf58:	f47f ab8b 	bne.w	3b672 <ull_conn_rx+0xdfa>
   3bf5c:	f7ff bb82 	b.w	3b664 <ull_conn_rx+0xdec>
			if (eff_tx_octets == conn->lll.max_tx_octets &&
   3bf60:	4550      	cmp	r0, sl
   3bf62:	f47f aed2 	bne.w	3bd0a <ull_conn_rx+0x1492>
			    eff_rx_time == conn->lll.max_rx_time &&
   3bf66:	45dc      	cmp	ip, fp
   3bf68:	f47f aecf 	bne.w	3bd0a <ull_conn_rx+0x1492>
				(*rx)->hdr.type = NODE_RX_TYPE_RELEASE;
   3bf6c:	682a      	ldr	r2, [r5, #0]
   3bf6e:	2501      	movs	r5, #1
   3bf70:	7115      	strb	r5, [r2, #4]
	if (tx) {
   3bf72:	2b00      	cmp	r3, #0
   3bf74:	f43e ace9 	beq.w	3a94a <ull_conn_rx+0xd2>
   3bf78:	f7ff bbe1 	b.w	3b73e <ull_conn_rx+0xec6>
				conn->lll.max_tx_octets = eff_tx_octets;
   3bf7c:	f8a4 1058 	strh.w	r1, [r4, #88]	; 0x58
				conn->lll.max_tx_time = eff_tx_time;
   3bf80:	f8a4 005c 	strh.w	r0, [r4, #92]	; 0x5c
			lr->max_rx_octets = sys_cpu_to_le16(eff_rx_octets);
   3bf84:	f8a6 e020 	strh.w	lr, [r6, #32]
			lr->max_tx_octets = sys_cpu_to_le16(eff_tx_octets);
   3bf88:	84b1      	strh	r1, [r6, #36]	; 0x24
			lr->max_rx_time = sys_cpu_to_le16(eff_rx_time);
   3bf8a:	f8a6 c022 	strh.w	ip, [r6, #34]	; 0x22
			lr->max_tx_time = sys_cpu_to_le16(eff_tx_time);
   3bf8e:	84f0      	strh	r0, [r6, #38]	; 0x26
	if (tx) {
   3bf90:	f7fe bcdb 	b.w	3a94a <ull_conn_rx+0xd2>
			LL_ASSERT(conn->periph.llcp_type == LLCP_NONE);
   3bf94:	4a58      	ldr	r2, [pc, #352]	; (3c0f8 <ull_conn_rx+0x1880>)
   3bf96:	495c      	ldr	r1, [pc, #368]	; (3c108 <ull_conn_rx+0x1890>)
   3bf98:	4859      	ldr	r0, [pc, #356]	; (3c100 <ull_conn_rx+0x1888>)
   3bf9a:	f641 23fa 	movw	r3, #6906	; 0x1afa
   3bf9e:	f00d f871 	bl	49084 <assert_print>
   3bfa2:	4040      	eors	r0, r0
   3bfa4:	f380 8811 	msr	BASEPRI, r0
   3bfa8:	f04f 0003 	mov.w	r0, #3
   3bfac:	df02      	svc	2
   3bfae:	e71a      	b.n	3bde6 <ull_conn_rx+0x156e>
		conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
   3bfb0:	f894 1194 	ldrb.w	r1, [r4, #404]	; 0x194
   3bfb4:	f884 1195 	strb.w	r1, [r4, #405]	; 0x195
		conn->procedure_expire = 0U;
   3bfb8:	e40b      	b.n	3b7d2 <ull_conn_rx+0xf5a>
		conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
   3bfba:	f884 1195 	strb.w	r1, [r4, #405]	; 0x195
   3bfbe:	e734      	b.n	3be2a <ull_conn_rx+0x15b2>
   3bfc0:	4f50      	ldr	r7, [pc, #320]	; (3c104 <ull_conn_rx+0x188c>)
	if (conn->llcp_conn_param.cache.timeout) {
   3bfc2:	f8b4 51a6 	ldrh.w	r5, [r4, #422]	; 0x1a6
   3bfc6:	2000      	movs	r0, #0
   3bfc8:	6038      	str	r0, [r7, #0]
   3bfca:	2d00      	cmp	r5, #0
   3bfcc:	d04d      	beq.n	3c06a <ull_conn_rx+0x17f2>
		conn->llcp_conn_param.state = LLCP_CPR_STATE_REQ;
   3bfce:	f8b4 3196 	ldrh.w	r3, [r4, #406]	; 0x196
		conn->llcp_conn_param.timeout =
   3bfd2:	f8a4 519e 	strh.w	r5, [r4, #414]	; 0x19e
		conn->llcp_conn_param.cache.timeout = 0U;
   3bfd6:	f8a4 01a6 	strh.w	r0, [r4, #422]	; 0x1a6
   3bfda:	f7ff bbec 	b.w	3b7b6 <ull_conn_rx+0xf3e>
	else if (rej_ext_ind->error_code != BT_HCI_ERR_LL_PROC_COLLISION) {
   3bfde:	2b23      	cmp	r3, #35	; 0x23
			conn->periph.ticks_to_offset =
   3bfe0:	bf1c      	itt	ne
   3bfe2:	f8d4 31c0 	ldrne.w	r3, [r4, #448]	; 0x1c0
   3bfe6:	f8c4 30ec 	strne.w	r3, [r4, #236]	; 0xec
   3bfea:	f7ff ba59 	b.w	3b4a0 <ull_conn_rx+0xc28>
		conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
   3bfee:	f884 2195 	strb.w	r2, [r4, #405]	; 0x195
		if (err) {
   3bff2:	f7fe bf13 	b.w	3ae1c <ull_conn_rx+0x5a4>
		LL_ASSERT(conn->llcp_cu.req == conn->llcp_cu.ack);
   3bff6:	f894 2118 	ldrb.w	r2, [r4, #280]	; 0x118
   3bffa:	f894 3119 	ldrb.w	r3, [r4, #281]	; 0x119
   3bffe:	429a      	cmp	r2, r3
   3c000:	d00e      	beq.n	3c020 <ull_conn_rx+0x17a8>
   3c002:	4a3d      	ldr	r2, [pc, #244]	; (3c0f8 <ull_conn_rx+0x1880>)
   3c004:	4941      	ldr	r1, [pc, #260]	; (3c10c <ull_conn_rx+0x1894>)
   3c006:	483e      	ldr	r0, [pc, #248]	; (3c100 <ull_conn_rx+0x1888>)
   3c008:	f241 53b5 	movw	r3, #5557	; 0x15b5
   3c00c:	f00d f83a 	bl	49084 <assert_print>
   3c010:	4040      	eors	r0, r0
   3c012:	f380 8811 	msr	BASEPRI, r0
   3c016:	f04f 0003 	mov.w	r0, #3
   3c01a:	df02      	svc	2
   3c01c:	f894 3119 	ldrb.w	r3, [r4, #281]	; 0x119
		conn->llcp_conn_param.state = LLCP_CPR_STATE_UPD;
   3c020:	f894 2196 	ldrb.w	r2, [r4, #406]	; 0x196
   3c024:	2106      	movs	r1, #6
   3c026:	f361 0203 	bfi	r2, r1, #0, #4
		conn->llcp_cu.ack--;
   3c02a:	3b01      	subs	r3, #1
   3c02c:	f884 3119 	strb.w	r3, [r4, #281]	; 0x119
		conn->llcp_conn_param.state = LLCP_CPR_STATE_UPD;
   3c030:	f884 2196 	strb.w	r2, [r4, #406]	; 0x196
		conn->llcp_cu.cmd = conn->llcp_conn_param.cmd;
   3c034:	f3c2 1300 	ubfx	r3, r2, #4, #1
		conn->llcp_cu.state = LLCP_CUI_STATE_USE;
   3c038:	f894 211a 	ldrb.w	r2, [r4, #282]	; 0x11a
		conn->llcp_cu.win_size = 1U;
   3c03c:	2101      	movs	r1, #1
		conn->llcp_cu.state = LLCP_CUI_STATE_USE;
   3c03e:	00db      	lsls	r3, r3, #3
   3c040:	430b      	orrs	r3, r1
   3c042:	f022 020f 	bic.w	r2, r2, #15
   3c046:	4313      	orrs	r3, r2
		conn->llcp_cu.win_size = 1U;
   3c048:	f884 1128 	strb.w	r1, [r4, #296]	; 0x128
		conn->llcp_cu.timeout = conn->llcp_conn_param.timeout;
   3c04c:	f8b4 219e 	ldrh.w	r2, [r4, #414]	; 0x19e
		conn->llcp_cu.interval = conn->llcp_conn_param.interval_max;
   3c050:	f8d4 119a 	ldr.w	r1, [r4, #410]	; 0x19a
		conn->llcp_cu.state = LLCP_CUI_STATE_USE;
   3c054:	f884 311a 	strb.w	r3, [r4, #282]	; 0x11a
		conn->llcp_cu.win_offset_us = 0U;
   3c058:	2000      	movs	r0, #0
   3c05a:	f8c4 0124 	str.w	r0, [r4, #292]	; 0x124
		conn->llcp_cu.interval = conn->llcp_conn_param.interval_max;
   3c05e:	f8c4 111c 	str.w	r1, [r4, #284]	; 0x11c
		conn->llcp_cu.timeout = conn->llcp_conn_param.timeout;
   3c062:	f8a4 2120 	strh.w	r2, [r4, #288]	; 0x120
	if (err) {
   3c066:	f7fe bc66 	b.w	3a936 <ull_conn_rx+0xbe>
		conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
   3c06a:	f884 1195 	strb.w	r1, [r4, #405]	; 0x195
   3c06e:	f7ff bbb0 	b.w	3b7d2 <ull_conn_rx+0xf5a>
	     ((((conn->llcp_length.state == LLCP_LENGTH_STATE_REQ) ||
   3c072:	f894 11c6 	ldrb.w	r1, [r4, #454]	; 0x1c6
	    ((conn->llcp_length.req != conn->llcp_length.ack) &&
   3c076:	f011 0f06 	tst.w	r1, #6
   3c07a:	f43f ab1f 	beq.w	3b6bc <ull_conn_rx+0xe44>
   3c07e:	f7fe bd1f 	b.w	3aac0 <ull_conn_rx+0x248>
			conn->tx_data = conn->tx_data->next;
   3c082:	6810      	ldr	r0, [r2, #0]
   3c084:	f8c4 01e8 	str.w	r0, [r4, #488]	; 0x1e8
		if (!conn->tx_ctrl) {
   3c088:	2900      	cmp	r1, #0
   3c08a:	f47f ac1e 	bne.w	3b8ca <ull_conn_rx+0x1052>
			tx->next = conn->tx_head->next;
   3c08e:	6812      	ldr	r2, [r2, #0]
   3c090:	601a      	str	r2, [r3, #0]
			conn->tx_head->next = tx;
   3c092:	f8d4 21dc 	ldr.w	r2, [r4, #476]	; 0x1dc
   3c096:	6013      	str	r3, [r2, #0]
				conn->tx_ctrl = tx;
   3c098:	f8c4 31e0 	str.w	r3, [r4, #480]	; 0x1e0
				conn->tx_ctrl_last = tx;
   3c09c:	e41c      	b.n	3b8d8 <ull_conn_rx+0x1060>
		(*rx)->hdr.type = NODE_RX_TYPE_RELEASE;
   3c09e:	682b      	ldr	r3, [r5, #0]
   3c0a0:	2201      	movs	r2, #1
   3c0a2:	711a      	strb	r2, [r3, #4]
		return BT_HCI_ERR_DIFF_TRANS_COLLISION;
   3c0a4:	232a      	movs	r3, #42	; 0x2a
   3c0a6:	e67b      	b.n	3bda0 <ull_conn_rx+0x1528>
		(*rx)->hdr.type = NODE_RX_TYPE_RELEASE;
   3c0a8:	682b      	ldr	r3, [r5, #0]
   3c0aa:	2201      	movs	r2, #1
   3c0ac:	711a      	strb	r2, [r3, #4]
		return BT_HCI_ERR_INSTANT_PASSED;
   3c0ae:	2328      	movs	r3, #40	; 0x28
   3c0b0:	e676      	b.n	3bda0 <ull_conn_rx+0x1528>
				     lll->interval) ||
   3c0b2:	8da6      	ldrh	r6, [r4, #44]	; 0x2c
   3c0b4:	4576      	cmp	r6, lr
   3c0b6:	f47f af3b 	bne.w	3bf30 <ull_conn_rx+0x16b8>
				    (RADIO_CONN_EVENTS(conn->llcp_conn_param.timeout *
   3c0ba:	f240 46e2 	movw	r6, #1250	; 0x4e2
   3c0be:	fb06 fc0c 	mul.w	ip, r6, ip
   3c0c2:	f242 7610 	movw	r6, #10000	; 0x2710
   3c0c6:	fb06 c000 	mla	r0, r6, r0, ip
				     lll->latency) ||
   3c0ca:	f8b4 60c2 	ldrh.w	r6, [r4, #194]	; 0xc2
				    (RADIO_CONN_EVENTS(conn->llcp_conn_param.timeout *
   3c0ce:	3801      	subs	r0, #1
   3c0d0:	fbb0 f0fc 	udiv	r0, r0, ip
				     lll->latency) ||
   3c0d4:	b280      	uxth	r0, r0
   3c0d6:	4286      	cmp	r6, r0
   3c0d8:	f47f af2a 	bne.w	3bf30 <ull_conn_rx+0x16b8>
				conn->llcp_conn_param.state =
   3c0dc:	f8b4 3196 	ldrh.w	r3, [r4, #406]	; 0x196
   3c0e0:	f003 03e0 	and.w	r3, r3, #224	; 0xe0
   3c0e4:	f043 0301 	orr.w	r3, r3, #1
   3c0e8:	f8a4 3196 	strh.w	r3, [r4, #406]	; 0x196
				(*rx)->hdr.type = NODE_RX_TYPE_RELEASE;
   3c0ec:	682b      	ldr	r3, [r5, #0]
   3c0ee:	2101      	movs	r1, #1
   3c0f0:	7119      	strb	r1, [r3, #4]
   3c0f2:	f894 1195 	ldrb.w	r1, [r4, #405]	; 0x195
   3c0f6:	e4a9      	b.n	3ba4c <ull_conn_rx+0x11d4>
   3c0f8:	0005269c 	.word	0x0005269c
   3c0fc:	0005229c 	.word	0x0005229c
   3c100:	0005214c 	.word	0x0005214c
   3c104:	200058f0 	.word	0x200058f0
   3c108:	000527ac 	.word	0x000527ac
   3c10c:	000527d0 	.word	0x000527d0
			LL_ASSERT(IS_PTR_ALIGNED(node, struct node_rx_cu));
   3c110:	4a19      	ldr	r2, [pc, #100]	; (3c178 <ull_conn_rx+0x1900>)
   3c112:	491a      	ldr	r1, [pc, #104]	; (3c17c <ull_conn_rx+0x1904>)
   3c114:	481a      	ldr	r0, [pc, #104]	; (3c180 <ull_conn_rx+0x1908>)
   3c116:	f641 5373 	movw	r3, #7539	; 0x1d73
   3c11a:	f00c ffb3 	bl	49084 <assert_print>
   3c11e:	4040      	eors	r0, r0
   3c120:	f380 8811 	msr	BASEPRI, r0
   3c124:	f04f 0003 	mov.w	r0, #3
   3c128:	df02      	svc	2
   3c12a:	e689      	b.n	3be40 <ull_conn_rx+0x15c8>
			     lll->interval) ||
   3c12c:	8da6      	ldrh	r6, [r4, #44]	; 0x2c
   3c12e:	4576      	cmp	r6, lr
   3c130:	f47f ac85 	bne.w	3ba3e <ull_conn_rx+0x11c6>
			    (RADIO_CONN_EVENTS(conn->llcp_conn_param.timeout *
   3c134:	f240 46e2 	movw	r6, #1250	; 0x4e2
   3c138:	fb06 f000 	mul.w	r0, r6, r0
   3c13c:	f242 7610 	movw	r6, #10000	; 0x2710
   3c140:	fb06 0303 	mla	r3, r6, r3, r0
   3c144:	3b01      	subs	r3, #1
   3c146:	fbb3 f3f0 	udiv	r3, r3, r0
			    (conn->llcp_conn_param.latency != lll->latency) ||
   3c14a:	f8b4 00c2 	ldrh.w	r0, [r4, #194]	; 0xc2
   3c14e:	b29b      	uxth	r3, r3
   3c150:	4298      	cmp	r0, r3
   3c152:	f47f ac74 	bne.w	3ba3e <ull_conn_rx+0x11c6>
   3c156:	e7c1      	b.n	3c0dc <ull_conn_rx+0x1864>
	if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   3c158:	7911      	ldrb	r1, [r2, #4]
   3c15a:	f001 0103 	and.w	r1, r1, #3
   3c15e:	2903      	cmp	r1, #3
   3c160:	d003      	beq.n	3c16a <ull_conn_rx+0x18f2>
		conn->tx_ctrl = conn->tx_ctrl_last = conn->tx_head;
   3c162:	e9c4 2278 	strd	r2, r2, [r4, #480]	; 0x1e0
   3c166:	f7ff bbb0 	b.w	3b8ca <ull_conn_rx+0x1052>
	    ((pdu_data_tx->llctrl.opcode !=
   3c16a:	79d1      	ldrb	r1, [r2, #7]
	if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   3c16c:	2903      	cmp	r1, #3
   3c16e:	d08e      	beq.n	3c08e <ull_conn_rx+0x1816>
	      PDU_DATA_LLCTRL_TYPE_ENC_REQ) &&
   3c170:	290a      	cmp	r1, #10
   3c172:	d1f6      	bne.n	3c162 <ull_conn_rx+0x18ea>
   3c174:	e78b      	b.n	3c08e <ull_conn_rx+0x1816>
   3c176:	bf00      	nop
   3c178:	0005269c 	.word	0x0005269c
   3c17c:	0005229c 	.word	0x0005229c
   3c180:	0005214c 	.word	0x0005214c

0003c184 <ull_conn_llcp>:
{
   3c184:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   3c188:	4604      	mov	r4, r0
	if ((conn->llcp_ack == conn->llcp_req) &&
   3c18a:	f890 00f1 	ldrb.w	r0, [r0, #241]	; 0xf1
   3c18e:	f894 30f0 	ldrb.w	r3, [r4, #240]	; 0xf0
   3c192:	4298      	cmp	r0, r3
{
   3c194:	460e      	mov	r6, r1
   3c196:	4615      	mov	r5, r2
	if ((conn->llcp_ack == conn->llcp_req) &&
   3c198:	d030      	beq.n	3c1fc <ull_conn_llcp+0x78>
	if (((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) {
   3c19a:	1a1b      	subs	r3, r3, r0
   3c19c:	f003 0303 	and.w	r3, r3, #3
   3c1a0:	2b02      	cmp	r3, #2
   3c1a2:	d010      	beq.n	3c1c6 <ull_conn_llcp+0x42>
   3c1a4:	f994 1039 	ldrsb.w	r1, [r4, #57]	; 0x39
   3c1a8:	460a      	mov	r2, r1
	if (conn->lll.role && (conn->periph.llcp_type != LLCP_NONE)) {
   3c1aa:	2a00      	cmp	r2, #0
   3c1ac:	db4b      	blt.n	3c246 <ull_conn_llcp+0xc2>
	if (((conn->llcp_terminate.req - conn->llcp_terminate.ack) & 0xFF) ==
   3c1ae:	f894 3150 	ldrb.w	r3, [r4, #336]	; 0x150
   3c1b2:	f894 2151 	ldrb.w	r2, [r4, #337]	; 0x151
   3c1b6:	1a9b      	subs	r3, r3, r2
   3c1b8:	b2db      	uxtb	r3, r3
   3c1ba:	2b01      	cmp	r3, #1
   3c1bc:	f000 8182 	beq.w	3c4c4 <ull_conn_llcp+0x340>
				return 0;
   3c1c0:	2000      	movs	r0, #0
}
   3c1c2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		} else if (conn->llcp_length.ack != conn->llcp_length.req) {
   3c1c6:	f894 21c5 	ldrb.w	r2, [r4, #453]	; 0x1c5
   3c1ca:	f894 31c4 	ldrb.w	r3, [r4, #452]	; 0x1c4
   3c1ce:	429a      	cmp	r2, r3
   3c1d0:	d006      	beq.n	3c1e0 <ull_conn_llcp+0x5c>
			     LLCP_LENGTH_STATE_RESIZE) ||
   3c1d2:	f894 31c6 	ldrb.w	r3, [r4, #454]	; 0x1c6
			if ((conn->llcp_length.state ==
   3c1d6:	f003 0306 	and.w	r3, r3, #6
   3c1da:	2b04      	cmp	r3, #4
   3c1dc:	f000 8219 	beq.w	3c612 <ull_conn_llcp+0x48e>
		switch (conn->llcp_type) {
   3c1e0:	f894 70f2 	ldrb.w	r7, [r4, #242]	; 0xf2
   3c1e4:	1e7b      	subs	r3, r7, #1
   3c1e6:	2b05      	cmp	r3, #5
   3c1e8:	f200 815e 	bhi.w	3c4a8 <ull_conn_llcp+0x324>
   3c1ec:	e8df f013 	tbh	[pc, r3, lsl #1]
   3c1f0:	01200151 	.word	0x01200151
   3c1f4:	015c0095 	.word	0x015c0095
   3c1f8:	00460051 	.word	0x00460051
   3c1fc:	f994 1039 	ldrsb.w	r1, [r4, #57]	; 0x39
	if ((conn->llcp_ack == conn->llcp_req) &&
   3c200:	2900      	cmp	r1, #0
   3c202:	460a      	mov	r2, r1
   3c204:	f2c0 81b1 	blt.w	3c56a <ull_conn_llcp+0x3e6>
	    !conn->llcp_enc.pause_rx) {
   3c208:	f894 7176 	ldrb.w	r7, [r4, #374]	; 0x176
	    (!conn->lll.role || (conn->periph.llcp_type == LLCP_NONE)) &&
   3c20c:	f017 0f01 	tst.w	r7, #1
   3c210:	d1cd      	bne.n	3c1ae <ull_conn_llcp+0x2a>
		if (conn->llcp_cu.ack != conn->llcp_cu.req) {
   3c212:	f894 c119 	ldrb.w	ip, [r4, #281]	; 0x119
   3c216:	f894 e118 	ldrb.w	lr, [r4, #280]	; 0x118
   3c21a:	45e6      	cmp	lr, ip
   3c21c:	f000 81b4 	beq.w	3c588 <ull_conn_llcp+0x404>
			if (memq_peek(conn->lll.memq_tx.head,
   3c220:	e9d4 0119 	ldrd	r0, r1, [r4, #100]	; 0x64
   3c224:	2200      	movs	r2, #0
   3c226:	f7f8 f9b7 	bl	34598 <memq_peek>
   3c22a:	2800      	cmp	r0, #0
   3c22c:	d1c8      	bne.n	3c1c0 <ull_conn_llcp+0x3c>
			conn->llcp_ack -= 2U;
   3c22e:	f894 00f1 	ldrb.w	r0, [r4, #241]	; 0xf1
   3c232:	3802      	subs	r0, #2
			conn->llcp_type = LLCP_CONN_UPD;
   3c234:	2301      	movs	r3, #1
			conn->llcp_ack -= 2U;
   3c236:	b2c0      	uxtb	r0, r0
			conn->llcp_type = LLCP_CONN_UPD;
   3c238:	f884 30f2 	strb.w	r3, [r4, #242]	; 0xf2
			conn->llcp_ack -= 2U;
   3c23c:	f884 00f1 	strb.w	r0, [r4, #241]	; 0xf1
	if (((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) {
   3c240:	f894 30f0 	ldrb.w	r3, [r4, #240]	; 0xf0
   3c244:	e7a9      	b.n	3c19a <ull_conn_llcp+0x16>
	if (conn->lll.role && (conn->periph.llcp_type != LLCP_NONE)) {
   3c246:	f894 70e5 	ldrb.w	r7, [r4, #229]	; 0xe5
   3c24a:	2f00      	cmp	r7, #0
   3c24c:	d0af      	beq.n	3c1ae <ull_conn_llcp+0x2a>
		switch (conn->periph.llcp_type) {
   3c24e:	2f02      	cmp	r7, #2
   3c250:	f000 8317 	beq.w	3c882 <ull_conn_llcp+0x6fe>
   3c254:	2f06      	cmp	r7, #6
   3c256:	f000 8348 	beq.w	3c8ea <ull_conn_llcp+0x766>
   3c25a:	2f01      	cmp	r7, #1
   3c25c:	f000 833a 	beq.w	3c8d4 <ull_conn_llcp+0x750>
			LL_ASSERT(0);
   3c260:	4ac5      	ldr	r2, [pc, #788]	; (3c578 <ull_conn_llcp+0x3f4>)
   3c262:	49c6      	ldr	r1, [pc, #792]	; (3c57c <ull_conn_llcp+0x3f8>)
   3c264:	48c6      	ldr	r0, [pc, #792]	; (3c580 <ull_conn_llcp+0x3fc>)
   3c266:	f240 5356 	movw	r3, #1366	; 0x556
   3c26a:	f00c ff0b 	bl	49084 <assert_print>
   3c26e:	4040      	eors	r0, r0
   3c270:	f380 8811 	msr	BASEPRI, r0
   3c274:	f04f 0003 	mov.w	r0, #3
   3c278:	df02      	svc	2
			break;
   3c27a:	e798      	b.n	3c1ae <ull_conn_llcp+0x2a>
			event_counter = lll->event_counter +
   3c27c:	8e61      	ldrh	r1, [r4, #50]	; 0x32
   3c27e:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
   3c280:	4419      	add	r1, r3
   3c282:	4429      	add	r1, r5
			event_phy_upd_ind_prep(conn, event_counter);
   3c284:	b289      	uxth	r1, r1
   3c286:	4620      	mov	r0, r4
   3c288:	f7fd fd28 	bl	39cdc <event_phy_upd_ind_prep>
		break;
   3c28c:	f994 2039 	ldrsb.w	r2, [r4, #57]	; 0x39
   3c290:	e78b      	b.n	3c1aa <ull_conn_llcp+0x26>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
   3c292:	48bc      	ldr	r0, [pc, #752]	; (3c584 <ull_conn_llcp+0x400>)
   3c294:	f7f8 f910 	bl	344b8 <mem_acquire>
	if (tx) {
   3c298:	2800      	cmp	r0, #0
   3c29a:	f000 8102 	beq.w	3c4a2 <ull_conn_llcp+0x31e>
		conn->llcp_ack = conn->llcp_req;
   3c29e:	f894 30f0 	ldrb.w	r3, [r4, #240]	; 0xf0
   3c2a2:	f884 30f1 	strb.w	r3, [r4, #241]	; 0xf1
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   3c2a6:	7903      	ldrb	r3, [r0, #4]
   3c2a8:	f043 0303 	orr.w	r3, r3, #3
   3c2ac:	7103      	strb	r3, [r0, #4]
		pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, ping_req) +
   3c2ae:	2301      	movs	r3, #1
   3c2b0:	7143      	strb	r3, [r0, #5]
		pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PING_REQ;
   3c2b2:	2312      	movs	r3, #18
   3c2b4:	71c3      	strb	r3, [r0, #7]
	    conn->tx_head &&
   3c2b6:	f8d4 31dc 	ldr.w	r3, [r4, #476]	; 0x1dc
	if (
   3c2ba:	2b00      	cmp	r3, #0
   3c2bc:	f000 8325 	beq.w	3c90a <ull_conn_llcp+0x786>
	    !conn->llcp_cu.pause_tx &&
   3c2c0:	f894 211a 	ldrb.w	r2, [r4, #282]	; 0x11a
	    conn->tx_head &&
   3c2c4:	06d1      	lsls	r1, r2, #27
   3c2c6:	f100 8320 	bmi.w	3c90a <ull_conn_llcp+0x786>
	    !conn->llcp_enc.pause_tx &&
   3c2ca:	f894 2176 	ldrb.w	r2, [r4, #374]	; 0x176
	    !conn->llcp_cu.pause_tx &&
   3c2ce:	0792      	lsls	r2, r2, #30
   3c2d0:	f100 831b 	bmi.w	3c90a <ull_conn_llcp+0x786>
	    !conn->llcp_phy.pause_tx &&
   3c2d4:	f894 21d7 	ldrb.w	r2, [r4, #471]	; 0x1d7
   3c2d8:	07d7      	lsls	r7, r2, #31
   3c2da:	f100 8316 	bmi.w	3c90a <ull_conn_llcp+0x786>
		if (conn->tx_head == conn->tx_data) {
   3c2de:	f8d4 11e8 	ldr.w	r1, [r4, #488]	; 0x1e8
		if (!conn->tx_ctrl) {
   3c2e2:	f8d4 21e0 	ldr.w	r2, [r4, #480]	; 0x1e0
		if (conn->tx_head == conn->tx_data) {
   3c2e6:	428b      	cmp	r3, r1
   3c2e8:	f000 874e 	beq.w	3d188 <ull_conn_llcp+0x1004>
		} else if (!conn->tx_ctrl) {
   3c2ec:	2a00      	cmp	r2, #0
   3c2ee:	f000 87c7 	beq.w	3d280 <ull_conn_llcp+0x10fc>
	tx->next = conn->tx_ctrl_last->next;
   3c2f2:	f8d4 31e4 	ldr.w	r3, [r4, #484]	; 0x1e4
   3c2f6:	681b      	ldr	r3, [r3, #0]
   3c2f8:	6003      	str	r3, [r0, #0]
	conn->tx_ctrl_last->next = tx;
   3c2fa:	f8d4 31e4 	ldr.w	r3, [r4, #484]	; 0x1e4
   3c2fe:	6018      	str	r0, [r3, #0]
	conn->tx_ctrl_last = tx;
   3c300:	f8c4 01e4 	str.w	r0, [r4, #484]	; 0x1e4
	if (!tx->next) {
   3c304:	6803      	ldr	r3, [r0, #0]
   3c306:	2b00      	cmp	r3, #0
   3c308:	f000 8527 	beq.w	3cd5a <ull_conn_llcp+0xbd6>
		conn->procedure_expire = conn->procedure_reload;
   3c30c:	f8b4 30c6 	ldrh.w	r3, [r4, #198]	; 0xc6
   3c310:	f994 2039 	ldrsb.w	r2, [r4, #57]	; 0x39
   3c314:	f8a4 30c8 	strh.w	r3, [r4, #200]	; 0xc8
   3c318:	e747      	b.n	3c1aa <ull_conn_llcp+0x26>
	if (conn->llcp.encryption.state) {
   3c31a:	f894 3100 	ldrb.w	r3, [r4, #256]	; 0x100
   3c31e:	f013 0903 	ands.w	r9, r3, #3
   3c322:	f000 81b4 	beq.w	3c68e <ull_conn_llcp+0x50a>
		if (lll->role &&
   3c326:	f994 3039 	ldrsb.w	r3, [r4, #57]	; 0x39
   3c32a:	2b00      	cmp	r3, #0
   3c32c:	f6bf af3f 	bge.w	3c1ae <ull_conn_llcp+0x2a>
   3c330:	f1b9 0f01 	cmp.w	r9, #1
   3c334:	d187      	bne.n	3c246 <ull_conn_llcp+0xc2>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
   3c336:	4893      	ldr	r0, [pc, #588]	; (3c584 <ull_conn_llcp+0x400>)
   3c338:	f7f8 f8be 	bl	344b8 <mem_acquire>
	if (!tx) {
   3c33c:	4607      	mov	r7, r0
   3c33e:	2800      	cmp	r0, #0
   3c340:	f000 80af 	beq.w	3c4a2 <ull_conn_llcp+0x31e>
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   3c344:	7903      	ldrb	r3, [r0, #4]
   3c346:	f043 0303 	orr.w	r3, r3, #3
   3c34a:	7103      	strb	r3, [r0, #4]
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_ENC_RSP;
   3c34c:	f04f 0904 	mov.w	r9, #4
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, enc_rsp) +
   3c350:	230d      	movs	r3, #13
	lll_csrand_isr_get(pdu_ctrl_tx->llctrl.enc_rsp.skds,
   3c352:	f100 0808 	add.w	r8, r0, #8
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, enc_rsp) +
   3c356:	7143      	strb	r3, [r0, #5]
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_ENC_RSP;
   3c358:	f880 9007 	strb.w	r9, [r0, #7]
	lll_csrand_isr_get(pdu_ctrl_tx->llctrl.enc_rsp.skds,
   3c35c:	210c      	movs	r1, #12
   3c35e:	4640      	mov	r0, r8
   3c360:	f003 f944 	bl	3f5ec <lll_csrand_isr_get>
	memcpy(&conn->llcp.encryption.skd[8],
   3c364:	4641      	mov	r1, r8
   3c366:	2208      	movs	r2, #8
   3c368:	f504 7085 	add.w	r0, r4, #266	; 0x10a
   3c36c:	f00e fd85 	bl	4ae7a <memcpy>
	memcpy(&conn->lll.ccm_rx.iv[4],
   3c370:	464a      	mov	r2, r9
   3c372:	f107 0110 	add.w	r1, r7, #16
   3c376:	f104 0098 	add.w	r0, r4, #152	; 0x98
   3c37a:	f00e fd7e 	bl	4ae7a <memcpy>
	    conn->tx_head &&
   3c37e:	f8d4 31dc 	ldr.w	r3, [r4, #476]	; 0x1dc
	if (
   3c382:	2b00      	cmp	r3, #0
   3c384:	f000 8512 	beq.w	3cdac <ull_conn_llcp+0xc28>
	    !conn->llcp_cu.pause_tx &&
   3c388:	f894 211a 	ldrb.w	r2, [r4, #282]	; 0x11a
	    conn->tx_head &&
   3c38c:	06d0      	lsls	r0, r2, #27
   3c38e:	f100 850d 	bmi.w	3cdac <ull_conn_llcp+0xc28>
	    !conn->llcp_enc.pause_tx &&
   3c392:	f894 2176 	ldrb.w	r2, [r4, #374]	; 0x176
	    !conn->llcp_cu.pause_tx &&
   3c396:	0791      	lsls	r1, r2, #30
   3c398:	f100 8508 	bmi.w	3cdac <ull_conn_llcp+0xc28>
	    !conn->llcp_phy.pause_tx &&
   3c39c:	f894 21d7 	ldrb.w	r2, [r4, #471]	; 0x1d7
   3c3a0:	07d2      	lsls	r2, r2, #31
   3c3a2:	f100 8503 	bmi.w	3cdac <ull_conn_llcp+0xc28>
		if (conn->tx_head == conn->tx_data) {
   3c3a6:	f8d4 11e8 	ldr.w	r1, [r4, #488]	; 0x1e8
		if (!conn->tx_ctrl) {
   3c3aa:	f8d4 21e0 	ldr.w	r2, [r4, #480]	; 0x1e0
		if (conn->tx_head == conn->tx_data) {
   3c3ae:	428b      	cmp	r3, r1
   3c3b0:	f000 879f 	beq.w	3d2f2 <ull_conn_llcp+0x116e>
		} else if (!conn->tx_ctrl) {
   3c3b4:	2a00      	cmp	r2, #0
   3c3b6:	f001 80e7 	beq.w	3d588 <ull_conn_llcp+0x1404>
	tx->next = conn->tx_ctrl_last->next;
   3c3ba:	f8d4 31e4 	ldr.w	r3, [r4, #484]	; 0x1e4
   3c3be:	681b      	ldr	r3, [r3, #0]
   3c3c0:	603b      	str	r3, [r7, #0]
	conn->tx_ctrl_last->next = tx;
   3c3c2:	f8d4 31e4 	ldr.w	r3, [r4, #484]	; 0x1e4
   3c3c6:	601f      	str	r7, [r3, #0]
	conn->tx_ctrl_last = tx;
   3c3c8:	f8c4 71e4 	str.w	r7, [r4, #484]	; 0x1e4
	if (!tx->next) {
   3c3cc:	683b      	ldr	r3, [r7, #0]
   3c3ce:	2b00      	cmp	r3, #0
   3c3d0:	f000 8673 	beq.w	3d0ba <ull_conn_llcp+0xf36>
			rx = ll_pdu_rx_alloc();
   3c3d4:	f7fb fd08 	bl	37de8 <ll_pdu_rx_alloc>
			if (!rx) {
   3c3d8:	4607      	mov	r7, r0
   3c3da:	2800      	cmp	r0, #0
   3c3dc:	d061      	beq.n	3c4a2 <ull_conn_llcp+0x31e>
			rx->hdr.handle = conn->lll.handle;
   3c3de:	8d23      	ldrh	r3, [r4, #40]	; 0x28
   3c3e0:	80c3      	strh	r3, [r0, #6]
			rx->hdr.type = NODE_RX_TYPE_DC_PDU;
   3c3e2:	2303      	movs	r3, #3
   3c3e4:	7103      	strb	r3, [r0, #4]
			pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_ENC_REQ;
   3c3e6:	77c3      	strb	r3, [r0, #31]
			pdu->ll_id = PDU_DATA_LLID_CTRL;
   3c3e8:	7f03      	ldrb	r3, [r0, #28]
   3c3ea:	f043 0303 	orr.w	r3, r3, #3
   3c3ee:	7703      	strb	r3, [r0, #28]
			pdu->len = offsetof(struct pdu_data_llctrl, enc_req) +
   3c3f0:	2317      	movs	r3, #23
			memcpy(&pdu->llctrl.enc_req.rand[0],
   3c3f2:	2208      	movs	r2, #8
			pdu->len = offsetof(struct pdu_data_llctrl, enc_req) +
   3c3f4:	7743      	strb	r3, [r0, #29]
			memcpy(&pdu->llctrl.enc_req.rand[0],
   3c3f6:	f204 1179 	addw	r1, r4, #377	; 0x179
   3c3fa:	3020      	adds	r0, #32
   3c3fc:	f00e fd3d 	bl	4ae7a <memcpy>
			pdu->llctrl.enc_req.ediv[0] = conn->llcp_enc.ediv[0];
   3c400:	f894 3177 	ldrb.w	r3, [r4, #375]	; 0x177
   3c404:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
			pdu->llctrl.enc_req.ediv[1] = conn->llcp_enc.ediv[1];
   3c408:	f894 3178 	ldrb.w	r3, [r4, #376]	; 0x178
   3c40c:	f887 3029 	strb.w	r3, [r7, #41]	; 0x29
			ll_rx_put(rx->hdr.link, rx);
   3c410:	6838      	ldr	r0, [r7, #0]
   3c412:	4639      	mov	r1, r7
   3c414:	f7fb fcb6 	bl	37d84 <ll_rx_put>
			ll_rx_sched();
   3c418:	f7fb fcbe 	bl	37d98 <ll_rx_sched>
			conn->llcp.encryption.state = LLCP_ENC_STATE_LTK_WAIT;
   3c41c:	f894 3100 	ldrb.w	r3, [r4, #256]	; 0x100
   3c420:	2202      	movs	r2, #2
   3c422:	f362 0301 	bfi	r3, r2, #0, #2
   3c426:	f884 3100 	strb.w	r3, [r4, #256]	; 0x100
   3c42a:	f994 2039 	ldrsb.w	r2, [r4, #57]	; 0x39
   3c42e:	e6bc      	b.n	3c1aa <ull_conn_llcp+0x26>
			event_counter = lll->event_counter +
   3c430:	8de2      	ldrh	r2, [r4, #46]	; 0x2e
   3c432:	8e63      	ldrh	r3, [r4, #50]	; 0x32
   3c434:	4413      	add	r3, r2
	if (conn->llcp.chan_map.initiate) {
   3c436:	f894 20f4 	ldrb.w	r2, [r4, #244]	; 0xf4
			event_counter = lll->event_counter +
   3c43a:	442b      	add	r3, r5
	if (conn->llcp.chan_map.initiate) {
   3c43c:	f012 0101 	ands.w	r1, r2, #1
			event_counter = lll->event_counter +
   3c440:	b29f      	uxth	r7, r3
	if (conn->llcp.chan_map.initiate) {
   3c442:	f040 81b8 	bne.w	3c7b6 <ull_conn_llcp+0x632>
	} else if (((event_counter - conn->llcp.chan_map.instant) & 0xFFFF)
   3c446:	f8b4 30fa 	ldrh.w	r3, [r4, #250]	; 0xfa
   3c44a:	f994 2039 	ldrsb.w	r2, [r4, #57]	; 0x39
   3c44e:	1afb      	subs	r3, r7, r3
   3c450:	041f      	lsls	r7, r3, #16
   3c452:	f53f aeaa 	bmi.w	3c1aa <ull_conn_llcp+0x26>
		if (conn->lll.role && (conn->periph.llcp_type != LLCP_NONE)) {
   3c456:	2a00      	cmp	r2, #0
   3c458:	f2c0 8483 	blt.w	3cd62 <ull_conn_llcp+0xbde>
			conn->llcp_ack = conn->llcp_req;
   3c45c:	f894 30f0 	ldrb.w	r3, [r4, #240]	; 0xf0
   3c460:	f884 30f1 	strb.w	r3, [r4, #241]	; 0xf1
		memcpy(&lll->data_chan_map[0],
   3c464:	f104 0734 	add.w	r7, r4, #52	; 0x34
   3c468:	2205      	movs	r2, #5
   3c46a:	f104 01f5 	add.w	r1, r4, #245	; 0xf5
   3c46e:	4638      	mov	r0, r7
   3c470:	f00e fd03 	bl	4ae7a <memcpy>
			util_ones_count_get(&lll->data_chan_map[0],
   3c474:	2105      	movs	r1, #5
   3c476:	4638      	mov	r0, r7
   3c478:	f7f8 fa00 	bl	3487c <util_ones_count_get>
		lll->data_chan_count =
   3c47c:	f894 2039 	ldrb.w	r2, [r4, #57]	; 0x39
		conn->chm_updated = 1U;
   3c480:	2301      	movs	r3, #1
		lll->data_chan_count =
   3c482:	f360 0205 	bfi	r2, r0, #0, #6
   3c486:	f884 2039 	strb.w	r2, [r4, #57]	; 0x39
		conn->chm_updated = 1U;
   3c48a:	f884 31f0 	strb.w	r3, [r4, #496]	; 0x1f0
   3c48e:	b252      	sxtb	r2, r2
   3c490:	e68b      	b.n	3c1aa <ull_conn_llcp+0x26>
			if (event_conn_upd_prep(conn, lazy,
   3c492:	4632      	mov	r2, r6
   3c494:	4629      	mov	r1, r5
   3c496:	4620      	mov	r0, r4
   3c498:	f7ea fd86 	bl	26fa8 <event_conn_upd_prep>
   3c49c:	2800      	cmp	r0, #0
   3c49e:	f000 8221 	beq.w	3c8e4 <ull_conn_llcp+0x760>
			break;
   3c4a2:	f994 2039 	ldrsb.w	r2, [r4, #57]	; 0x39
   3c4a6:	e680      	b.n	3c1aa <ull_conn_llcp+0x26>
			LL_ASSERT(0);
   3c4a8:	4a33      	ldr	r2, [pc, #204]	; (3c578 <ull_conn_llcp+0x3f4>)
   3c4aa:	4934      	ldr	r1, [pc, #208]	; (3c57c <ull_conn_llcp+0x3f8>)
   3c4ac:	4834      	ldr	r0, [pc, #208]	; (3c580 <ull_conn_llcp+0x3fc>)
   3c4ae:	f240 5325 	movw	r3, #1317	; 0x525
   3c4b2:	f00c fde7 	bl	49084 <assert_print>
   3c4b6:	4040      	eors	r0, r0
   3c4b8:	f380 8811 	msr	BASEPRI, r0
   3c4bc:	f04f 0003 	mov.w	r0, #3
   3c4c0:	df02      	svc	2
   3c4c2:	e7ee      	b.n	3c4a2 <ull_conn_llcp+0x31e>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
   3c4c4:	482f      	ldr	r0, [pc, #188]	; (3c584 <ull_conn_llcp+0x400>)
   3c4c6:	f7f7 fff7 	bl	344b8 <mem_acquire>
		if (tx) {
   3c4ca:	2800      	cmp	r0, #0
   3c4cc:	d040      	beq.n	3c550 <ull_conn_llcp+0x3cc>
			conn->llcp_terminate.ack--;
   3c4ce:	f894 3151 	ldrb.w	r3, [r4, #337]	; 0x151
   3c4d2:	3b01      	subs	r3, #1
   3c4d4:	f884 3151 	strb.w	r3, [r4, #337]	; 0x151
			pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
   3c4d8:	7903      	ldrb	r3, [r0, #4]
			pdu_tx->len = offsetof(struct pdu_data_llctrl,
   3c4da:	2202      	movs	r2, #2
			pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
   3c4dc:	f043 0303 	orr.w	r3, r3, #3
			pdu_tx->len = offsetof(struct pdu_data_llctrl,
   3c4e0:	7142      	strb	r2, [r0, #5]
			pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
   3c4e2:	7103      	strb	r3, [r0, #4]
			pdu_tx->llctrl.opcode =
   3c4e4:	71c2      	strb	r2, [r0, #7]
				conn->llcp_terminate.reason_own;
   3c4e6:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
			pdu_tx->llctrl.terminate_ind.error_code =
   3c4ea:	7203      	strb	r3, [r0, #8]
	    conn->tx_head &&
   3c4ec:	f8d4 31dc 	ldr.w	r3, [r4, #476]	; 0x1dc
	if (
   3c4f0:	b1e3      	cbz	r3, 3c52c <ull_conn_llcp+0x3a8>
	    !conn->llcp_cu.pause_tx &&
   3c4f2:	f894 211a 	ldrb.w	r2, [r4, #282]	; 0x11a
	    conn->tx_head &&
   3c4f6:	06d5      	lsls	r5, r2, #27
   3c4f8:	d418      	bmi.n	3c52c <ull_conn_llcp+0x3a8>
	    !conn->llcp_enc.pause_tx &&
   3c4fa:	f894 2176 	ldrb.w	r2, [r4, #374]	; 0x176
	    !conn->llcp_cu.pause_tx &&
   3c4fe:	0791      	lsls	r1, r2, #30
   3c500:	d414      	bmi.n	3c52c <ull_conn_llcp+0x3a8>
	    !conn->llcp_phy.pause_tx &&
   3c502:	f894 21d7 	ldrb.w	r2, [r4, #471]	; 0x1d7
   3c506:	07d2      	lsls	r2, r2, #31
   3c508:	d410      	bmi.n	3c52c <ull_conn_llcp+0x3a8>
		if (conn->tx_head == conn->tx_data) {
   3c50a:	f8d4 21e8 	ldr.w	r2, [r4, #488]	; 0x1e8
		if (!conn->tx_ctrl) {
   3c50e:	f8d4 11e0 	ldr.w	r1, [r4, #480]	; 0x1e0
		if (conn->tx_head == conn->tx_data) {
   3c512:	4293      	cmp	r3, r2
   3c514:	f000 8597 	beq.w	3d046 <ull_conn_llcp+0xec2>
		} else if (!conn->tx_ctrl) {
   3c518:	b969      	cbnz	r1, 3c536 <ull_conn_llcp+0x3b2>
	if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   3c51a:	791a      	ldrb	r2, [r3, #4]
   3c51c:	f002 0203 	and.w	r2, r2, #3
   3c520:	2a03      	cmp	r2, #3
   3c522:	f000 864d 	beq.w	3d1c0 <ull_conn_llcp+0x103c>
		conn->tx_ctrl = conn->tx_ctrl_last = conn->tx_head;
   3c526:	e9c4 3378 	strd	r3, r3, [r4, #480]	; 0x1e0
   3c52a:	e004      	b.n	3c536 <ull_conn_llcp+0x3b2>
		if (!conn->tx_ctrl) {
   3c52c:	f8d4 21e0 	ldr.w	r2, [r4, #480]	; 0x1e0
   3c530:	2a00      	cmp	r2, #0
   3c532:	f000 81e6 	beq.w	3c902 <ull_conn_llcp+0x77e>
	tx->next = conn->tx_ctrl_last->next;
   3c536:	f8d4 31e4 	ldr.w	r3, [r4, #484]	; 0x1e4
   3c53a:	681b      	ldr	r3, [r3, #0]
   3c53c:	6003      	str	r3, [r0, #0]
	conn->tx_ctrl_last->next = tx;
   3c53e:	f8d4 31e4 	ldr.w	r3, [r4, #484]	; 0x1e4
   3c542:	6018      	str	r0, [r3, #0]
	conn->tx_ctrl_last = tx;
   3c544:	f8c4 01e4 	str.w	r0, [r4, #484]	; 0x1e4
	if (!tx->next) {
   3c548:	6803      	ldr	r3, [r0, #0]
   3c54a:	2b00      	cmp	r3, #0
   3c54c:	f000 81d6 	beq.w	3c8fc <ull_conn_llcp+0x778>
		if (!conn->procedure_expire) {
   3c550:	f8b4 30c8 	ldrh.w	r3, [r4, #200]	; 0xc8
   3c554:	2b00      	cmp	r3, #0
   3c556:	f47f ae33 	bne.w	3c1c0 <ull_conn_llcp+0x3c>
			conn->procedure_expire = conn->supervision_reload;
   3c55a:	f8b4 30c2 	ldrh.w	r3, [r4, #194]	; 0xc2
			if (conn->procedure_expire <= 1U) {
   3c55e:	2b01      	cmp	r3, #1
				conn->procedure_expire++;
   3c560:	bf98      	it	ls
   3c562:	3301      	addls	r3, #1
   3c564:	f8a4 30c8 	strh.w	r3, [r4, #200]	; 0xc8
   3c568:	e62a      	b.n	3c1c0 <ull_conn_llcp+0x3c>
	    (!conn->lll.role || (conn->periph.llcp_type == LLCP_NONE)) &&
   3c56a:	f894 70e5 	ldrb.w	r7, [r4, #229]	; 0xe5
   3c56e:	2f00      	cmp	r7, #0
   3c570:	f47f ae6d 	bne.w	3c24e <ull_conn_llcp+0xca>
   3c574:	e648      	b.n	3c208 <ull_conn_llcp+0x84>
   3c576:	bf00      	nop
   3c578:	0005269c 	.word	0x0005269c
   3c57c:	000521ac 	.word	0x000521ac
   3c580:	0005214c 	.word	0x0005214c
   3c584:	20005384 	.word	0x20005384
		} else if (conn->llcp_feature.ack != conn->llcp_feature.req) {
   3c588:	f894 e131 	ldrb.w	lr, [r4, #305]	; 0x131
   3c58c:	f894 8130 	ldrb.w	r8, [r4, #304]	; 0x130
   3c590:	45c6      	cmp	lr, r8
   3c592:	d142      	bne.n	3c61a <ull_conn_llcp+0x496>
		} else if (conn->llcp_version.ack != conn->llcp_version.req) {
   3c594:	f894 e149 	ldrb.w	lr, [r4, #329]	; 0x149
   3c598:	f894 8148 	ldrb.w	r8, [r4, #328]	; 0x148
   3c59c:	45c6      	cmp	lr, r8
   3c59e:	f000 81bd 	beq.w	3c91c <ull_conn_llcp+0x798>
	if (!((conn->llcp_version.ack - conn->llcp_version.req) & 0x01)) {
   3c5a2:	ebae 0e08 	sub.w	lr, lr, r8
   3c5a6:	f01e 0f01 	tst.w	lr, #1
   3c5aa:	f43f adfe 	beq.w	3c1aa <ull_conn_llcp+0x26>
	if (conn->llcp_version.tx == 0U) {
   3c5ae:	f894 314a 	ldrb.w	r3, [r4, #330]	; 0x14a
   3c5b2:	07da      	lsls	r2, r3, #31
   3c5b4:	f140 84c3 	bpl.w	3cf3e <ull_conn_llcp+0xdba>
	} else if (conn->llcp_version.rx) {
   3c5b8:	079b      	lsls	r3, r3, #30
   3c5ba:	f140 8510 	bpl.w	3cfde <ull_conn_llcp+0xe5a>
		rx = ll_pdu_rx_alloc();
   3c5be:	f7fb fc13 	bl	37de8 <ll_pdu_rx_alloc>
		if (!rx) {
   3c5c2:	4601      	mov	r1, r0
   3c5c4:	b300      	cbz	r0, 3c608 <ull_conn_llcp+0x484>
		conn->llcp_version.ack = conn->llcp_version.req;
   3c5c6:	f894 3148 	ldrb.w	r3, [r4, #328]	; 0x148
   3c5ca:	f884 3149 	strb.w	r3, [r4, #329]	; 0x149
		rx->hdr.handle = conn->lll.handle;
   3c5ce:	8d23      	ldrh	r3, [r4, #40]	; 0x28
   3c5d0:	80c3      	strh	r3, [r0, #6]
		rx->hdr.type = NODE_RX_TYPE_DC_PDU;
   3c5d2:	2303      	movs	r3, #3
   3c5d4:	7103      	strb	r3, [r0, #4]
		pdu->ll_id = PDU_DATA_LLID_CTRL;
   3c5d6:	7f03      	ldrb	r3, [r0, #28]
   3c5d8:	f043 0303 	orr.w	r3, r3, #3
   3c5dc:	7703      	strb	r3, [r0, #28]
		pdu->len = offsetof(struct pdu_data_llctrl, version_ind) +
   3c5de:	2306      	movs	r3, #6
   3c5e0:	7743      	strb	r3, [r0, #29]
		pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_VERSION_IND;
   3c5e2:	230c      	movs	r3, #12
   3c5e4:	77c3      	strb	r3, [r0, #31]
			conn->llcp_version.version_number;
   3c5e6:	f894 314b 	ldrb.w	r3, [r4, #331]	; 0x14b
		pdu->llctrl.version_ind.version_number =
   3c5ea:	f880 3020 	strb.w	r3, [r0, #32]
			sys_cpu_to_le16(conn->llcp_version.company_id);
   3c5ee:	f8b4 314c 	ldrh.w	r3, [r4, #332]	; 0x14c
		pdu->llctrl.version_ind.company_id =
   3c5f2:	f8a0 3021 	strh.w	r3, [r0, #33]	; 0x21
			sys_cpu_to_le16(conn->llcp_version.sub_version_number);
   3c5f6:	f8b4 314e 	ldrh.w	r3, [r4, #334]	; 0x14e
		pdu->llctrl.version_ind.sub_version_number =
   3c5fa:	f8a0 3023 	strh.w	r3, [r0, #35]	; 0x23
		ll_rx_put(rx->hdr.link, rx);
   3c5fe:	6808      	ldr	r0, [r1, #0]
   3c600:	f7fb fbc0 	bl	37d84 <ll_rx_put>
		ll_rx_sched();
   3c604:	f7fb fbc8 	bl	37d98 <ll_rx_sched>
	if (((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) {
   3c608:	f894 30f0 	ldrb.w	r3, [r4, #240]	; 0xf0
   3c60c:	f894 00f1 	ldrb.w	r0, [r4, #241]	; 0xf1
		return;
   3c610:	e5c3      	b.n	3c19a <ull_conn_llcp+0x16>
				event_len_prep(conn);
   3c612:	4620      	mov	r0, r4
   3c614:	f7fd fa60 	bl	39ad8 <event_len_prep>
   3c618:	e5e2      	b.n	3c1e0 <ull_conn_llcp+0x5c>
	if (!((conn->llcp_feature.ack - conn->llcp_feature.req) & 0x01)) {
   3c61a:	ebae 0e08 	sub.w	lr, lr, r8
   3c61e:	f01e 0f01 	tst.w	lr, #1
   3c622:	f43f adc2 	beq.w	3c1aa <ull_conn_llcp+0x26>
	if (conn->common.fex_valid) {
   3c626:	f894 30e4 	ldrb.w	r3, [r4, #228]	; 0xe4
   3c62a:	f013 0701 	ands.w	r7, r3, #1
   3c62e:	f000 8313 	beq.w	3cc58 <ull_conn_llcp+0xad4>
		rx = ll_pdu_rx_alloc();
   3c632:	f7fb fbd9 	bl	37de8 <ll_pdu_rx_alloc>
		if (!rx) {
   3c636:	4607      	mov	r7, r0
   3c638:	2800      	cmp	r0, #0
   3c63a:	d0e5      	beq.n	3c608 <ull_conn_llcp+0x484>
		conn->llcp_feature.ack = conn->llcp_feature.req;
   3c63c:	f894 3130 	ldrb.w	r3, [r4, #304]	; 0x130
   3c640:	f884 3131 	strb.w	r3, [r4, #305]	; 0x131
		rx->hdr.handle = conn->lll.handle;
   3c644:	8d23      	ldrh	r3, [r4, #40]	; 0x28
   3c646:	80c3      	strh	r3, [r0, #6]
		rx->hdr.type = NODE_RX_TYPE_DC_PDU;
   3c648:	2303      	movs	r3, #3
   3c64a:	7103      	strb	r3, [r0, #4]
		pdu->ll_id = PDU_DATA_LLID_CTRL;
   3c64c:	7f03      	ldrb	r3, [r0, #28]
   3c64e:	f043 0303 	orr.w	r3, r3, #3
   3c652:	7703      	strb	r3, [r0, #28]
		pdu->len = offsetof(struct pdu_data_llctrl, feature_rsp) +
   3c654:	2309      	movs	r3, #9
   3c656:	7743      	strb	r3, [r0, #29]
		pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_FEATURE_RSP;
   3c658:	77c3      	strb	r3, [r0, #31]
		(void)memset(&pdu->llctrl.feature_rsp.features[0], 0x00,
   3c65a:	2208      	movs	r2, #8
   3c65c:	2100      	movs	r1, #0
   3c65e:	3020      	adds	r0, #32
   3c660:	f00e fc16 	bl	4ae90 <memset>
	sys_put_le32(val >> 32, &dst[4]);
   3c664:	f8d4 3144 	ldr.w	r3, [r4, #324]	; 0x144
	dst[0] = val;
   3c668:	2200      	movs	r2, #0
	dst[1] = val >> 8;
   3c66a:	f3c3 2107 	ubfx	r1, r3, #8, #8
	dst[0] = val;
   3c66e:	f363 0207 	bfi	r2, r3, #0, #8
   3c672:	f361 220f 	bfi	r2, r1, #8, #8
	sys_put_le16(val >> 16, &dst[2]);
   3c676:	0c1b      	lsrs	r3, r3, #16
	dst[0] = val;
   3c678:	f363 4217 	bfi	r2, r3, #16, #8
	dst[1] = val >> 8;
   3c67c:	0a1b      	lsrs	r3, r3, #8
	dst[0] = val;
   3c67e:	f363 621f 	bfi	r2, r3, #24, #8
   3c682:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
   3c686:	623b      	str	r3, [r7, #32]
   3c688:	627a      	str	r2, [r7, #36]	; 0x24
		ll_rx_put(rx->hdr.link, rx);
   3c68a:	4639      	mov	r1, r7
   3c68c:	e7b7      	b.n	3c5fe <ull_conn_llcp+0x47a>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
   3c68e:	48bd      	ldr	r0, [pc, #756]	; (3c984 <ull_conn_llcp+0x800>)
   3c690:	f7f7 ff12 	bl	344b8 <mem_acquire>
	if (!tx) {
   3c694:	4680      	mov	r8, r0
   3c696:	2800      	cmp	r0, #0
   3c698:	f43f af03 	beq.w	3c4a2 <ull_conn_llcp+0x31e>
	if (!lll->role) {
   3c69c:	f994 3039 	ldrsb.w	r3, [r4, #57]	; 0x39
   3c6a0:	2b00      	cmp	r3, #0
   3c6a2:	f280 8399 	bge.w	3cdd8 <ull_conn_llcp+0xc54>
	else if (!lll->enc_rx) {
   3c6a6:	f894 307a 	ldrb.w	r3, [r4, #122]	; 0x7a
   3c6aa:	0719      	lsls	r1, r3, #28
   3c6ac:	f100 849c 	bmi.w	3cfe8 <ull_conn_llcp+0xe64>
		if (conn->llcp.encryption.error_code) {
   3c6b0:	f894 9101 	ldrb.w	r9, [r4, #257]	; 0x101
   3c6b4:	f1b9 0f00 	cmp.w	r9, #0
   3c6b8:	f040 8503 	bne.w	3d0c2 <ull_conn_llcp+0xf3e>
			ecb_encrypt(&conn->llcp_enc.ltk[0],
   3c6bc:	f104 077b 	add.w	r7, r4, #123	; 0x7b
   3c6c0:	463b      	mov	r3, r7
   3c6c2:	464a      	mov	r2, r9
   3c6c4:	f504 7181 	add.w	r1, r4, #258	; 0x102
   3c6c8:	f204 1081 	addw	r0, r4, #385	; 0x181
   3c6cc:	f005 f9d8 	bl	41a80 <ecb_encrypt>
			memcpy(&lll->ccm_tx.key[0],
   3c6d0:	4639      	mov	r1, r7
   3c6d2:	2210      	movs	r2, #16
   3c6d4:	f104 009c 	add.w	r0, r4, #156	; 0x9c
   3c6d8:	f00e fbcf 	bl	4ae7a <memcpy>
			memcpy(&lll->ccm_tx.iv[0], &lll->ccm_rx.iv[0],
   3c6dc:	2208      	movs	r2, #8
   3c6de:	f104 0194 	add.w	r1, r4, #148	; 0x94
   3c6e2:	f104 00b5 	add.w	r0, r4, #181	; 0xb5
   3c6e6:	f00e fbc8 	bl	4ae7a <memcpy>
			lll->ccm_rx.direction = 1U;
   3c6ea:	f894 3093 	ldrb.w	r3, [r4, #147]	; 0x93
			lll->ccm_rx.counter = 0U;
   3c6ee:	f884 908b 	strb.w	r9, [r4, #139]	; 0x8b
			lll->ccm_rx.direction = 1U;
   3c6f2:	f043 0301 	orr.w	r3, r3, #1
   3c6f6:	f884 3093 	strb.w	r3, [r4, #147]	; 0x93
			lll->ccm_tx.direction = 0U;
   3c6fa:	f894 30b4 	ldrb.w	r3, [r4, #180]	; 0xb4
			lll->ccm_rx.counter = 0U;
   3c6fe:	f884 908c 	strb.w	r9, [r4, #140]	; 0x8c
			lll->ccm_tx.direction = 0U;
   3c702:	f369 0300 	bfi	r3, r9, #0, #1
   3c706:	f884 30b4 	strb.w	r3, [r4, #180]	; 0xb4
			lll->enc_rx = 1U;
   3c70a:	f894 307a 	ldrb.w	r3, [r4, #122]	; 0x7a
			lll->ccm_rx.counter = 0U;
   3c70e:	f884 908d 	strb.w	r9, [r4, #141]	; 0x8d
			lll->ccm_tx.counter = 0U;
   3c712:	e9c4 992b 	strd	r9, r9, [r4, #172]	; 0xac
			lll->enc_rx = 1U;
   3c716:	f043 0308 	orr.w	r3, r3, #8
			lll->ccm_rx.counter = 0U;
   3c71a:	f884 908e 	strb.w	r9, [r4, #142]	; 0x8e
   3c71e:	f884 908f 	strb.w	r9, [r4, #143]	; 0x8f
   3c722:	f884 9090 	strb.w	r9, [r4, #144]	; 0x90
   3c726:	f884 9091 	strb.w	r9, [r4, #145]	; 0x91
   3c72a:	f884 9092 	strb.w	r9, [r4, #146]	; 0x92
			lll->enc_rx = 1U;
   3c72e:	f884 307a 	strb.w	r3, [r4, #122]	; 0x7a
			pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   3c732:	f898 3004 	ldrb.w	r3, [r8, #4]
   3c736:	f043 0303 	orr.w	r3, r3, #3
   3c73a:	f888 3004 	strb.w	r3, [r8, #4]
			pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl,
   3c73e:	2301      	movs	r3, #1
   3c740:	f888 3005 	strb.w	r3, [r8, #5]
			pdu_ctrl_tx->llctrl.opcode =
   3c744:	2305      	movs	r3, #5
   3c746:	f888 3007 	strb.w	r3, [r8, #7]
	    conn->tx_head &&
   3c74a:	f8d4 21dc 	ldr.w	r2, [r4, #476]	; 0x1dc
	if (
   3c74e:	2a00      	cmp	r2, #0
   3c750:	f000 82f9 	beq.w	3cd46 <ull_conn_llcp+0xbc2>
	    !conn->llcp_cu.pause_tx &&
   3c754:	f894 311a 	ldrb.w	r3, [r4, #282]	; 0x11a
	    conn->tx_head &&
   3c758:	06df      	lsls	r7, r3, #27
   3c75a:	f100 82f4 	bmi.w	3cd46 <ull_conn_llcp+0xbc2>
	    !conn->llcp_enc.pause_tx &&
   3c75e:	f894 3176 	ldrb.w	r3, [r4, #374]	; 0x176
	    !conn->llcp_cu.pause_tx &&
   3c762:	0798      	lsls	r0, r3, #30
   3c764:	f100 82ef 	bmi.w	3cd46 <ull_conn_llcp+0xbc2>
	    !conn->llcp_phy.pause_tx &&
   3c768:	f894 31d7 	ldrb.w	r3, [r4, #471]	; 0x1d7
   3c76c:	07d9      	lsls	r1, r3, #31
   3c76e:	f100 82ea 	bmi.w	3cd46 <ull_conn_llcp+0xbc2>
		if (conn->tx_head == conn->tx_data) {
   3c772:	f8d4 11e8 	ldr.w	r1, [r4, #488]	; 0x1e8
		if (!conn->tx_ctrl) {
   3c776:	f8d4 31e0 	ldr.w	r3, [r4, #480]	; 0x1e0
		if (conn->tx_head == conn->tx_data) {
   3c77a:	428a      	cmp	r2, r1
   3c77c:	d072      	beq.n	3c864 <ull_conn_llcp+0x6e0>
		} else if (!conn->tx_ctrl) {
   3c77e:	2b00      	cmp	r3, #0
   3c780:	f000 870b 	beq.w	3d59a <ull_conn_llcp+0x1416>
	tx->next = conn->tx_ctrl_last->next;
   3c784:	f8d4 31e4 	ldr.w	r3, [r4, #484]	; 0x1e4
   3c788:	681b      	ldr	r3, [r3, #0]
   3c78a:	f8c8 3000 	str.w	r3, [r8]
	conn->tx_ctrl_last->next = tx;
   3c78e:	f8d4 31e4 	ldr.w	r3, [r4, #484]	; 0x1e4
   3c792:	f8c3 8000 	str.w	r8, [r3]
	conn->tx_ctrl_last = tx;
   3c796:	f8c4 81e4 	str.w	r8, [r4, #484]	; 0x1e4
	if (!tx->next) {
   3c79a:	f8d8 3000 	ldr.w	r3, [r8]
   3c79e:	2b00      	cmp	r3, #0
   3c7a0:	f000 8419 	beq.w	3cfd6 <ull_conn_llcp+0xe52>
	conn->llcp.encryption.state = LLCP_ENC_STATE_ENC_WAIT;
   3c7a4:	f894 3100 	ldrb.w	r3, [r4, #256]	; 0x100
   3c7a8:	f994 2039 	ldrsb.w	r2, [r4, #57]	; 0x39
   3c7ac:	f043 0303 	orr.w	r3, r3, #3
   3c7b0:	f884 3100 	strb.w	r3, [r4, #256]	; 0x100
   3c7b4:	e4f9      	b.n	3c1aa <ull_conn_llcp+0x26>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
   3c7b6:	4873      	ldr	r0, [pc, #460]	; (3c984 <ull_conn_llcp+0x800>)
   3c7b8:	f7f7 fe7e 	bl	344b8 <mem_acquire>
		if (tx) {
   3c7bc:	4680      	mov	r8, r0
   3c7be:	2800      	cmp	r0, #0
   3c7c0:	f43f ae6f 	beq.w	3c4a2 <ull_conn_llcp+0x31e>
						      conn->lll.latency + 6;
   3c7c4:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
   3c7c6:	3306      	adds	r3, #6
   3c7c8:	443b      	add	r3, r7
			conn->llcp.chan_map.instant = event_counter +
   3c7ca:	f8a4 30fa 	strh.w	r3, [r4, #250]	; 0xfa
			conn->llcp.chan_map.initiate = 0U;
   3c7ce:	f894 30f4 	ldrb.w	r3, [r4, #244]	; 0xf4
   3c7d2:	f36f 0300 	bfc	r3, #0, #1
   3c7d6:	f884 30f4 	strb.w	r3, [r4, #244]	; 0xf4
			pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   3c7da:	7903      	ldrb	r3, [r0, #4]
   3c7dc:	f043 0303 	orr.w	r3, r3, #3
   3c7e0:	7103      	strb	r3, [r0, #4]
			pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl,
   3c7e2:	2308      	movs	r3, #8
   3c7e4:	7143      	strb	r3, [r0, #5]
			pdu_ctrl_tx->llctrl.opcode =
   3c7e6:	2301      	movs	r3, #1
   3c7e8:	71c3      	strb	r3, [r0, #7]
			memcpy(&pdu_ctrl_tx->llctrl.chan_map_ind.chm[0],
   3c7ea:	2205      	movs	r2, #5
   3c7ec:	f104 01f5 	add.w	r1, r4, #245	; 0xf5
   3c7f0:	3008      	adds	r0, #8
   3c7f2:	f00e fb42 	bl	4ae7a <memcpy>
				sys_cpu_to_le16(conn->llcp.chan_map.instant);
   3c7f6:	f8b4 30fa 	ldrh.w	r3, [r4, #250]	; 0xfa
			pdu_ctrl_tx->llctrl.chan_map_ind.instant =
   3c7fa:	f8a8 300d 	strh.w	r3, [r8, #13]
	    conn->tx_head &&
   3c7fe:	f8d4 31dc 	ldr.w	r3, [r4, #476]	; 0x1dc
	if (
   3c802:	2b00      	cmp	r3, #0
   3c804:	f000 82b6 	beq.w	3cd74 <ull_conn_llcp+0xbf0>
	    !conn->llcp_cu.pause_tx &&
   3c808:	f894 211a 	ldrb.w	r2, [r4, #282]	; 0x11a
	    conn->tx_head &&
   3c80c:	06d0      	lsls	r0, r2, #27
   3c80e:	f100 82b1 	bmi.w	3cd74 <ull_conn_llcp+0xbf0>
	    !conn->llcp_enc.pause_tx &&
   3c812:	f894 2176 	ldrb.w	r2, [r4, #374]	; 0x176
	    !conn->llcp_cu.pause_tx &&
   3c816:	0791      	lsls	r1, r2, #30
   3c818:	f100 82ac 	bmi.w	3cd74 <ull_conn_llcp+0xbf0>
	    !conn->llcp_phy.pause_tx &&
   3c81c:	f894 21d7 	ldrb.w	r2, [r4, #471]	; 0x1d7
   3c820:	07d2      	lsls	r2, r2, #31
   3c822:	f100 82a7 	bmi.w	3cd74 <ull_conn_llcp+0xbf0>
		if (conn->tx_head == conn->tx_data) {
   3c826:	f8d4 11e8 	ldr.w	r1, [r4, #488]	; 0x1e8
		if (!conn->tx_ctrl) {
   3c82a:	f8d4 21e0 	ldr.w	r2, [r4, #480]	; 0x1e0
		if (conn->tx_head == conn->tx_data) {
   3c82e:	428b      	cmp	r3, r1
   3c830:	f000 8530 	beq.w	3d294 <ull_conn_llcp+0x1110>
		} else if (!conn->tx_ctrl) {
   3c834:	2a00      	cmp	r2, #0
   3c836:	f000 864e 	beq.w	3d4d6 <ull_conn_llcp+0x1352>
	tx->next = conn->tx_ctrl_last->next;
   3c83a:	f8d4 31e4 	ldr.w	r3, [r4, #484]	; 0x1e4
   3c83e:	681b      	ldr	r3, [r3, #0]
   3c840:	f8c8 3000 	str.w	r3, [r8]
	conn->tx_ctrl_last->next = tx;
   3c844:	f8d4 31e4 	ldr.w	r3, [r4, #484]	; 0x1e4
   3c848:	f8c3 8000 	str.w	r8, [r3]
	conn->tx_ctrl_last = tx;
   3c84c:	f8c4 81e4 	str.w	r8, [r4, #484]	; 0x1e4
	if (!tx->next) {
   3c850:	f8d8 3000 	ldr.w	r3, [r8]
	if (conn->lll.role && (conn->periph.llcp_type != LLCP_NONE)) {
   3c854:	f894 2039 	ldrb.w	r2, [r4, #57]	; 0x39
	if (!tx->next) {
   3c858:	2b00      	cmp	r3, #0
   3c85a:	f47f ae18 	bne.w	3c48e <ull_conn_llcp+0x30a>
		conn->tx_data_last = tx;
   3c85e:	f8c4 81ec 	str.w	r8, [r4, #492]	; 0x1ec
   3c862:	e614      	b.n	3c48e <ull_conn_llcp+0x30a>
			conn->tx_data = conn->tx_data->next;
   3c864:	6809      	ldr	r1, [r1, #0]
   3c866:	f8c4 11e8 	str.w	r1, [r4, #488]	; 0x1e8
		if (!conn->tx_ctrl) {
   3c86a:	2b00      	cmp	r3, #0
   3c86c:	d18a      	bne.n	3c784 <ull_conn_llcp+0x600>
			tx->next = conn->tx_head->next;
   3c86e:	6813      	ldr	r3, [r2, #0]
   3c870:	f8c8 3000 	str.w	r3, [r8]
			conn->tx_head->next = tx;
   3c874:	f8d4 31dc 	ldr.w	r3, [r4, #476]	; 0x1dc
   3c878:	f8c3 8000 	str.w	r8, [r3]
				conn->tx_ctrl = tx;
   3c87c:	f8c4 81e0 	str.w	r8, [r4, #480]	; 0x1e0
				conn->tx_ctrl_last = tx;
   3c880:	e789      	b.n	3c796 <ull_conn_llcp+0x612>
			event_counter = lll->event_counter +
   3c882:	8e63      	ldrh	r3, [r4, #50]	; 0x32
   3c884:	8de1      	ldrh	r1, [r4, #46]	; 0x2e
	if (conn->llcp.chan_map.initiate) {
   3c886:	f894 20f4 	ldrb.w	r2, [r4, #244]	; 0xf4
			event_counter = lll->event_counter +
   3c88a:	440b      	add	r3, r1
   3c88c:	442b      	add	r3, r5
	if (conn->llcp.chan_map.initiate) {
   3c88e:	f012 0601 	ands.w	r6, r2, #1
			event_counter = lll->event_counter +
   3c892:	b29d      	uxth	r5, r3
	if (conn->llcp.chan_map.initiate) {
   3c894:	f040 818d 	bne.w	3cbb2 <ull_conn_llcp+0xa2e>
	} else if (((event_counter - conn->llcp.chan_map.instant) & 0xFFFF)
   3c898:	f8b4 30fa 	ldrh.w	r3, [r4, #250]	; 0xfa
   3c89c:	1aeb      	subs	r3, r5, r3
   3c89e:	041f      	lsls	r7, r3, #16
   3c8a0:	f53f ac85 	bmi.w	3c1ae <ull_conn_llcp+0x2a>
		memcpy(&lll->data_chan_map[0],
   3c8a4:	f104 0534 	add.w	r5, r4, #52	; 0x34
   3c8a8:	2205      	movs	r2, #5
   3c8aa:	f104 01f5 	add.w	r1, r4, #245	; 0xf5
			conn->periph.llcp_type = LLCP_NONE;
   3c8ae:	f884 60e5 	strb.w	r6, [r4, #229]	; 0xe5
		memcpy(&lll->data_chan_map[0],
   3c8b2:	4628      	mov	r0, r5
   3c8b4:	f00e fae1 	bl	4ae7a <memcpy>
			util_ones_count_get(&lll->data_chan_map[0],
   3c8b8:	2105      	movs	r1, #5
   3c8ba:	4628      	mov	r0, r5
   3c8bc:	f7f7 ffde 	bl	3487c <util_ones_count_get>
		lll->data_chan_count =
   3c8c0:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
		conn->chm_updated = 1U;
   3c8c4:	2201      	movs	r2, #1
		lll->data_chan_count =
   3c8c6:	f360 0305 	bfi	r3, r0, #0, #6
   3c8ca:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
		conn->chm_updated = 1U;
   3c8ce:	f884 21f0 	strb.w	r2, [r4, #496]	; 0x1f0
   3c8d2:	e46c      	b.n	3c1ae <ull_conn_llcp+0x2a>
			if (event_conn_upd_prep(conn, lazy,
   3c8d4:	4632      	mov	r2, r6
   3c8d6:	4629      	mov	r1, r5
   3c8d8:	4620      	mov	r0, r4
   3c8da:	f7ea fb65 	bl	26fa8 <event_conn_upd_prep>
   3c8de:	2800      	cmp	r0, #0
   3c8e0:	f47f ac65 	bne.w	3c1ae <ull_conn_llcp+0x2a>
				return -ECANCELED;
   3c8e4:	f06f 008b 	mvn.w	r0, #139	; 0x8b
   3c8e8:	e46b      	b.n	3c1c2 <ull_conn_llcp+0x3e>
			event_counter = lll->event_counter +
   3c8ea:	8e61      	ldrh	r1, [r4, #50]	; 0x32
   3c8ec:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
   3c8ee:	4419      	add	r1, r3
   3c8f0:	4429      	add	r1, r5
			event_phy_upd_ind_prep(conn, event_counter);
   3c8f2:	4620      	mov	r0, r4
   3c8f4:	b289      	uxth	r1, r1
   3c8f6:	f7fd f9f1 	bl	39cdc <event_phy_upd_ind_prep>
		break;
   3c8fa:	e458      	b.n	3c1ae <ull_conn_llcp+0x2a>
		conn->tx_data_last = tx;
   3c8fc:	f8c4 01ec 	str.w	r0, [r4, #492]	; 0x1ec
   3c900:	e626      	b.n	3c550 <ull_conn_llcp+0x3cc>
			tx->next = conn->tx_head;
   3c902:	6003      	str	r3, [r0, #0]
				conn->tx_ctrl = tx;
   3c904:	e9c4 0077 	strd	r0, r0, [r4, #476]	; 0x1dc
				conn->tx_ctrl_last = tx;
   3c908:	e61c      	b.n	3c544 <ull_conn_llcp+0x3c0>
		if (!conn->tx_ctrl) {
   3c90a:	f8d4 21e0 	ldr.w	r2, [r4, #480]	; 0x1e0
   3c90e:	2a00      	cmp	r2, #0
   3c910:	f47f acef 	bne.w	3c2f2 <ull_conn_llcp+0x16e>
			tx->next = conn->tx_head;
   3c914:	6003      	str	r3, [r0, #0]
				conn->tx_ctrl = tx;
   3c916:	e9c4 0077 	strd	r0, r0, [r4, #476]	; 0x1dc
				conn->tx_ctrl_last = tx;
   3c91a:	e4f1      	b.n	3c300 <ull_conn_llcp+0x17c>
		} else if (conn->llcp_conn_param.ack !=
   3c91c:	f894 8195 	ldrb.w	r8, [r4, #405]	; 0x195
   3c920:	f894 e194 	ldrb.w	lr, [r4, #404]	; 0x194
   3c924:	45f0      	cmp	r8, lr
   3c926:	f000 81fe 	beq.w	3cd26 <ull_conn_llcp+0xba2>
	return conn_upd_curr && (conn_upd_curr != conn);
   3c92a:	f8df 805c 	ldr.w	r8, [pc, #92]	; 3c988 <ull_conn_llcp+0x804>
			event_counter = lll->event_counter +
   3c92e:	f8b4 9032 	ldrh.w	r9, [r4, #50]	; 0x32
   3c932:	f8d8 e000 	ldr.w	lr, [r8]
					lll->latency_prepare + lazy;
   3c936:	f8b4 a02e 	ldrh.w	sl, [r4, #46]	; 0x2e
   3c93a:	f1be 0f00 	cmp.w	lr, #0
   3c93e:	f000 839c 	beq.w	3d07a <ull_conn_llcp+0xef6>
   3c942:	4574      	cmp	r4, lr
   3c944:	f47f ac31 	bne.w	3c1aa <ull_conn_llcp+0x26>
	switch (conn->llcp_conn_param.state) {
   3c948:	f894 e196 	ldrb.w	lr, [r4, #406]	; 0x196
   3c94c:	f00e 0e0f 	and.w	lr, lr, #15
   3c950:	f1be 0f08 	cmp.w	lr, #8
   3c954:	f200 86d7 	bhi.w	3d706 <ull_conn_llcp+0x1582>
   3c958:	f20f 0b04 	addw	fp, pc, #4
   3c95c:	f85b f02e 	ldr.w	pc, [fp, lr, lsl #2]
   3c960:	0003caf7 	.word	0x0003caf7
   3c964:	0003ca79 	.word	0x0003ca79
   3c968:	0003ca17 	.word	0x0003ca17
   3c96c:	0003c19b 	.word	0x0003c19b
   3c970:	0003c19b 	.word	0x0003c19b
   3c974:	0003c19b 	.word	0x0003c19b
   3c978:	0003c19b 	.word	0x0003c19b
   3c97c:	0003c19b 	.word	0x0003c19b
   3c980:	0003c98d 	.word	0x0003c98d
   3c984:	20005384 	.word	0x20005384
   3c988:	200058f0 	.word	0x200058f0
			CONTAINER_OF(conn->llcp_conn_param.pdu_win_offset0,
   3c98c:	f8d4 11b8 	ldr.w	r1, [r4, #440]	; 0x1b8
			event_counter = lll->event_counter +
   3c990:	eb09 030a 	add.w	r3, r9, sl
   3c994:	442b      	add	r3, r5
		pdu_ctrl_tx->llctrl.conn_param_req.reference_conn_event_count =
   3c996:	f821 3c02 	strh.w	r3, [r1, #-2]
		conn->llcp_conn_param.state = LLCP_CPR_STATE_RSP_WAIT;
   3c99a:	f894 3196 	ldrb.w	r3, [r4, #406]	; 0x196
   3c99e:	2204      	movs	r2, #4
   3c9a0:	f362 0303 	bfi	r3, r2, #0, #4
   3c9a4:	f884 3196 	strb.w	r3, [r4, #406]	; 0x196
	    conn->tx_head &&
   3c9a8:	f8d4 31dc 	ldr.w	r3, [r4, #476]	; 0x1dc
		tx = CONTAINER_OF(pdu_ctrl_tx, struct node_tx, pdu);
   3c9ac:	f1a1 0213 	sub.w	r2, r1, #19
	if (
   3c9b0:	2b00      	cmp	r3, #0
   3c9b2:	f000 83f8 	beq.w	3d1a6 <ull_conn_llcp+0x1022>
	    !conn->llcp_cu.pause_tx &&
   3c9b6:	f894 011a 	ldrb.w	r0, [r4, #282]	; 0x11a
	    conn->tx_head &&
   3c9ba:	06c0      	lsls	r0, r0, #27
   3c9bc:	f100 83f3 	bmi.w	3d1a6 <ull_conn_llcp+0x1022>
	    !conn->llcp_enc.pause_tx &&
   3c9c0:	f894 0176 	ldrb.w	r0, [r4, #374]	; 0x176
	    !conn->llcp_cu.pause_tx &&
   3c9c4:	0787      	lsls	r7, r0, #30
   3c9c6:	f100 83ee 	bmi.w	3d1a6 <ull_conn_llcp+0x1022>
	    !conn->llcp_phy.pause_tx &&
   3c9ca:	f894 01d7 	ldrb.w	r0, [r4, #471]	; 0x1d7
   3c9ce:	07c0      	lsls	r0, r0, #31
   3c9d0:	f100 83e9 	bmi.w	3d1a6 <ull_conn_llcp+0x1022>
		if (conn->tx_head == conn->tx_data) {
   3c9d4:	f8d4 71e8 	ldr.w	r7, [r4, #488]	; 0x1e8
		if (!conn->tx_ctrl) {
   3c9d8:	f8d4 01e0 	ldr.w	r0, [r4, #480]	; 0x1e0
		if (conn->tx_head == conn->tx_data) {
   3c9dc:	42bb      	cmp	r3, r7
   3c9de:	f000 861f 	beq.w	3d620 <ull_conn_llcp+0x149c>
		} else if (!conn->tx_ctrl) {
   3c9e2:	2800      	cmp	r0, #0
   3c9e4:	f000 864a 	beq.w	3d67c <ull_conn_llcp+0x14f8>
	tx->next = conn->tx_ctrl_last->next;
   3c9e8:	f8d4 31e4 	ldr.w	r3, [r4, #484]	; 0x1e4
   3c9ec:	681b      	ldr	r3, [r3, #0]
   3c9ee:	f841 3c13 	str.w	r3, [r1, #-19]
	conn->tx_ctrl_last->next = tx;
   3c9f2:	f8d4 31e4 	ldr.w	r3, [r4, #484]	; 0x1e4
   3c9f6:	601a      	str	r2, [r3, #0]
	conn->tx_ctrl_last = tx;
   3c9f8:	f8c4 21e4 	str.w	r2, [r4, #484]	; 0x1e4
	if (!tx->next) {
   3c9fc:	f851 1c13 	ldr.w	r1, [r1, #-19]
	if (((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) {
   3ca00:	f894 30f0 	ldrb.w	r3, [r4, #240]	; 0xf0
   3ca04:	f894 00f1 	ldrb.w	r0, [r4, #241]	; 0xf1
	if (!tx->next) {
   3ca08:	2900      	cmp	r1, #0
   3ca0a:	f47f abc6 	bne.w	3c19a <ull_conn_llcp+0x16>
		conn->tx_data_last = tx;
   3ca0e:	f8c4 21ec 	str.w	r2, [r4, #492]	; 0x1ec
   3ca12:	f7ff bbc2 	b.w	3c19a <ull_conn_llcp+0x16>
	if (conn->llcp_enc.pause_tx) {
   3ca16:	07bf      	lsls	r7, r7, #30
   3ca18:	f53f abc7 	bmi.w	3c1aa <ull_conn_llcp+0x26>
	rx = ll_pdu_rx_alloc();
   3ca1c:	f7fb f9e4 	bl	37de8 <ll_pdu_rx_alloc>
	if (!rx) {
   3ca20:	4601      	mov	r1, r0
   3ca22:	2800      	cmp	r0, #0
   3ca24:	f43f adf0 	beq.w	3c608 <ull_conn_llcp+0x484>
	conn->llcp_conn_param.state = LLCP_CPR_STATE_APP_WAIT;
   3ca28:	f894 3196 	ldrb.w	r3, [r4, #406]	; 0x196
   3ca2c:	2203      	movs	r2, #3
   3ca2e:	f362 0303 	bfi	r3, r2, #0, #4
   3ca32:	f884 3196 	strb.w	r3, [r4, #406]	; 0x196
	pdu->ll_id = PDU_DATA_LLID_CTRL;
   3ca36:	7f03      	ldrb	r3, [r0, #28]
	rx->hdr.handle = conn->lll.handle;
   3ca38:	8d20      	ldrh	r0, [r4, #40]	; 0x28
   3ca3a:	80c8      	strh	r0, [r1, #6]
	pdu->ll_id = PDU_DATA_LLID_CTRL;
   3ca3c:	4313      	orrs	r3, r2
   3ca3e:	770b      	strb	r3, [r1, #28]
	pdu->len = offsetof(struct pdu_data_llctrl, conn_param_req) +
   3ca40:	2318      	movs	r3, #24
   3ca42:	774b      	strb	r3, [r1, #29]
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_CONN_PARAM_REQ;
   3ca44:	230f      	movs	r3, #15
	rx->hdr.type = NODE_RX_TYPE_DC_PDU;
   3ca46:	710a      	strb	r2, [r1, #4]
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_CONN_PARAM_REQ;
   3ca48:	77cb      	strb	r3, [r1, #31]
	p->interval_min = sys_cpu_to_le16(conn->llcp_conn_param.interval_min);
   3ca4a:	f8b4 3198 	ldrh.w	r3, [r4, #408]	; 0x198
   3ca4e:	840b      	strh	r3, [r1, #32]
	p->interval_max = sys_cpu_to_le16(conn->llcp_conn_param.interval_max);
   3ca50:	f8b4 319a 	ldrh.w	r3, [r4, #410]	; 0x19a
   3ca54:	844b      	strh	r3, [r1, #34]	; 0x22
	p->latency = sys_cpu_to_le16(conn->llcp_conn_param.latency);
   3ca56:	f8b4 319c 	ldrh.w	r3, [r4, #412]	; 0x19c
   3ca5a:	848b      	strh	r3, [r1, #36]	; 0x24
	p->timeout = sys_cpu_to_le16(conn->llcp_conn_param.timeout);
   3ca5c:	f8b4 319e 	ldrh.w	r3, [r4, #414]	; 0x19e
	ll_rx_put(rx->hdr.link, rx);
   3ca60:	6808      	ldr	r0, [r1, #0]
	p->timeout = sys_cpu_to_le16(conn->llcp_conn_param.timeout);
   3ca62:	84cb      	strh	r3, [r1, #38]	; 0x26
	ll_rx_put(rx->hdr.link, rx);
   3ca64:	f7fb f98e 	bl	37d84 <ll_rx_put>
	ll_rx_sched();
   3ca68:	f7fb f996 	bl	37d98 <ll_rx_sched>
	if (((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) {
   3ca6c:	f894 30f0 	ldrb.w	r3, [r4, #240]	; 0xf0
   3ca70:	f894 00f1 	ldrb.w	r0, [r4, #241]	; 0xf1
   3ca74:	f7ff bb91 	b.w	3c19a <ull_conn_llcp+0x16>
	if (conn->llcp_conn_param.status) {
   3ca78:	f894 3197 	ldrb.w	r3, [r4, #407]	; 0x197
   3ca7c:	2b00      	cmp	r3, #0
   3ca7e:	f040 8447 	bne.w	3d310 <ull_conn_llcp+0x118c>
	if (!conn->lll.role) {
   3ca82:	2900      	cmp	r1, #0
   3ca84:	f2c0 84a1 	blt.w	3d3ca <ull_conn_llcp+0x1246>
		conn->llcp_conn_param.state = LLCP_CPR_STATE_UPD;
   3ca88:	f894 2196 	ldrb.w	r2, [r4, #406]	; 0x196
		conn->llcp_cu.win_offset_us = 0U;
   3ca8c:	f8c4 3124 	str.w	r3, [r4, #292]	; 0x124
		conn->llcp_conn_param.state = LLCP_CPR_STATE_UPD;
   3ca90:	2106      	movs	r1, #6
   3ca92:	f361 0203 	bfi	r2, r1, #0, #4
		preferred_periodicity = conn->llcp_conn_param.preferred_periodicity;
   3ca96:	f894 11a8 	ldrb.w	r1, [r4, #424]	; 0x1a8
		conn->llcp_conn_param.state = LLCP_CPR_STATE_UPD;
   3ca9a:	f884 2196 	strb.w	r2, [r4, #406]	; 0x196
		conn->llcp_cu.win_size = 1U;
   3ca9e:	2001      	movs	r0, #1
		interval_max = conn->llcp_conn_param.interval_max;
   3caa0:	f8b4 219a 	ldrh.w	r2, [r4, #410]	; 0x19a
		conn->llcp_cu.win_size = 1U;
   3caa4:	f884 0128 	strb.w	r0, [r4, #296]	; 0x128
		if (preferred_periodicity) {
   3caa8:	2900      	cmp	r1, #0
   3caaa:	f000 8510 	beq.w	3d4ce <ull_conn_llcp+0x134a>
			conn->llcp_cu.interval = (interval_max / preferred_periodicity) *
   3caae:	fbb2 f3f1 	udiv	r3, r2, r1
   3cab2:	fb13 f301 	smulbb	r3, r3, r1
			if (conn->llcp_cu.interval < conn->llcp_conn_param.interval_min) {
   3cab6:	f8b4 1198 	ldrh.w	r1, [r4, #408]	; 0x198
			conn->llcp_cu.interval = (interval_max / preferred_periodicity) *
   3caba:	b29b      	uxth	r3, r3
				conn->llcp_cu.interval = interval_max;
   3cabc:	4299      	cmp	r1, r3
   3cabe:	bf98      	it	ls
   3cac0:	461a      	movls	r2, r3
   3cac2:	f8a4 211c 	strh.w	r2, [r4, #284]	; 0x11c
		conn->llcp_cu.cmd = conn->llcp_conn_param.cmd;
   3cac6:	f894 3196 	ldrb.w	r3, [r4, #406]	; 0x196
		conn->llcp_cu.state = LLCP_CUI_STATE_SELECT;
   3caca:	f894 211a 	ldrb.w	r2, [r4, #282]	; 0x11a
		conn->llcp_cu.latency = conn->llcp_conn_param.latency;
   3cace:	f8d4 119c 	ldr.w	r1, [r4, #412]	; 0x19c
   3cad2:	f8c4 111e 	str.w	r1, [r4, #286]	; 0x11e
		conn->llcp_cu.cmd = conn->llcp_conn_param.cmd;
   3cad6:	f3c3 1300 	ubfx	r3, r3, #4, #1
		conn->llcp_cu.state = LLCP_CUI_STATE_SELECT;
   3cada:	00db      	lsls	r3, r3, #3
   3cadc:	f043 0302 	orr.w	r3, r3, #2
   3cae0:	f022 020f 	bic.w	r2, r2, #15
   3cae4:	4313      	orrs	r3, r2
		conn->llcp_cu.ack--;
   3cae6:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
		conn->llcp_cu.state = LLCP_CUI_STATE_SELECT;
   3caea:	f884 311a 	strb.w	r3, [r4, #282]	; 0x11a
		conn->llcp_cu.ack--;
   3caee:	f884 c119 	strb.w	ip, [r4, #281]	; 0x119
	if (conn->lll.role && (conn->periph.llcp_type != LLCP_NONE)) {
   3caf2:	f7ff bb5c 	b.w	3c1ae <ull_conn_llcp+0x2a>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
   3caf6:	48b2      	ldr	r0, [pc, #712]	; (3cdc0 <ull_conn_llcp+0xc3c>)
   3caf8:	f7f7 fcde 	bl	344b8 <mem_acquire>
	if (!tx) {
   3cafc:	2800      	cmp	r0, #0
   3cafe:	f43f ad83 	beq.w	3c608 <ull_conn_llcp+0x484>
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   3cb02:	7902      	ldrb	r2, [r0, #4]
	conn_upd_curr = conn;
   3cb04:	f8c8 4000 	str.w	r4, [r8]
   3cb08:	f042 0203 	orr.w	r2, r2, #3
   3cb0c:	7102      	strb	r2, [r0, #4]
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, conn_param_req) +
   3cb0e:	2218      	movs	r2, #24
   3cb10:	7142      	strb	r2, [r0, #5]
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_CONN_PARAM_REQ;
   3cb12:	220f      	movs	r2, #15
   3cb14:	71c2      	strb	r2, [r0, #7]
	p->interval_min = sys_cpu_to_le16(conn->llcp_conn_param.interval_min);
   3cb16:	f8b4 2198 	ldrh.w	r2, [r4, #408]	; 0x198
   3cb1a:	8102      	strh	r2, [r0, #8]
	p->interval_max = sys_cpu_to_le16(conn->llcp_conn_param.interval_max);
   3cb1c:	f8b4 219a 	ldrh.w	r2, [r4, #410]	; 0x19a
   3cb20:	8142      	strh	r2, [r0, #10]
	p->latency = sys_cpu_to_le16(conn->llcp_conn_param.latency);
   3cb22:	f8b4 219c 	ldrh.w	r2, [r4, #412]	; 0x19c
   3cb26:	8182      	strh	r2, [r0, #12]
	p->timeout = sys_cpu_to_le16(conn->llcp_conn_param.timeout);
   3cb28:	f8b4 219e 	ldrh.w	r2, [r4, #414]	; 0x19e
   3cb2c:	81c2      	strh	r2, [r0, #14]
	p->preferred_periodicity = 0U;
   3cb2e:	2200      	movs	r2, #0
   3cb30:	7402      	strb	r2, [r0, #16]
	p->offset0 = sys_cpu_to_le16(0x0000);
   3cb32:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   3cb36:	f8c0 2017 	str.w	r2, [r0, #23]
   3cb3a:	f8c0 201b 	str.w	r2, [r0, #27]
   3cb3e:	4aa1      	ldr	r2, [pc, #644]	; (3cdc4 <ull_conn_llcp+0xc40>)
   3cb40:	f8c0 2013 	str.w	r2, [r0, #19]
	conn->llcp_conn_param.state = LLCP_CPR_STATE_OFFS_REQ;
   3cb44:	f894 3196 	ldrb.w	r3, [r4, #406]	; 0x196
		conn->llcp_conn_param.ticks_ref = ticks_at_expire;
   3cb48:	f8c4 61bc 	str.w	r6, [r4, #444]	; 0x1bc
	conn->llcp_conn_param.state = LLCP_CPR_STATE_OFFS_REQ;
   3cb4c:	2207      	movs	r2, #7
   3cb4e:	f362 0303 	bfi	r3, r2, #0, #4
   3cb52:	f884 3196 	strb.w	r3, [r4, #406]	; 0x196
		if (conn->ull.ticks_prepare_to_start & XON_BITMASK) {
   3cb56:	68a3      	ldr	r3, [r4, #8]
	conn->procedure_expire = conn->procedure_reload;
   3cb58:	f8b4 20c6 	ldrh.w	r2, [r4, #198]	; 0xc6
   3cb5c:	f8a4 20c8 	strh.w	r2, [r4, #200]	; 0xc8
		if (conn->ull.ticks_prepare_to_start & XON_BITMASK) {
   3cb60:	2b00      	cmp	r3, #0
   3cb62:	f100 0113 	add.w	r1, r0, #19
   3cb66:	da0a      	bge.n	3cb7e <ull_conn_llcp+0x9fa>
			uint32_t ticks_prepare_to_start =
   3cb68:	68e7      	ldr	r7, [r4, #12]
   3cb6a:	6860      	ldr	r0, [r4, #4]
				(conn->ull.ticks_prepare_to_start &
   3cb6c:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
			conn->llcp_conn_param.ticks_ref -=
   3cb70:	4287      	cmp	r7, r0
   3cb72:	bf2c      	ite	cs
   3cb74:	19f2      	addcs	r2, r6, r7
   3cb76:	1832      	addcc	r2, r6, r0
   3cb78:	1ad3      	subs	r3, r2, r3
   3cb7a:	f8c4 31bc 	str.w	r3, [r4, #444]	; 0x1bc
		s_mfy_sched_offset.param = (void *)conn;
   3cb7e:	4b92      	ldr	r3, [pc, #584]	; (3cdc8 <ull_conn_llcp+0xc44>)
		conn->llcp_conn_param.pdu_win_offset0 = win_offs;
   3cb80:	f8c4 11b8 	str.w	r1, [r4, #440]	; 0x1b8
		retval = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
   3cb84:	2201      	movs	r2, #1
   3cb86:	2102      	movs	r1, #2
   3cb88:	4610      	mov	r0, r2
		s_mfy_sched_offset.param = (void *)conn;
   3cb8a:	609c      	str	r4, [r3, #8]
		retval = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
   3cb8c:	f7f7 fd70 	bl	34670 <mayfly_enqueue>
		LL_ASSERT(!retval);
   3cb90:	2800      	cmp	r0, #0
   3cb92:	f43f ad39 	beq.w	3c608 <ull_conn_llcp+0x484>
   3cb96:	4a8d      	ldr	r2, [pc, #564]	; (3cdcc <ull_conn_llcp+0xc48>)
   3cb98:	498d      	ldr	r1, [pc, #564]	; (3cdd0 <ull_conn_llcp+0xc4c>)
   3cb9a:	f640 73da 	movw	r3, #4058	; 0xfda
		LL_ASSERT(0);
   3cb9e:	488d      	ldr	r0, [pc, #564]	; (3cdd4 <ull_conn_llcp+0xc50>)
   3cba0:	f00c fa70 	bl	49084 <assert_print>
   3cba4:	4040      	eors	r0, r0
   3cba6:	f380 8811 	msr	BASEPRI, r0
   3cbaa:	f04f 0003 	mov.w	r0, #3
   3cbae:	df02      	svc	2
		break;
   3cbb0:	e52a      	b.n	3c608 <ull_conn_llcp+0x484>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
   3cbb2:	4883      	ldr	r0, [pc, #524]	; (3cdc0 <ull_conn_llcp+0xc3c>)
   3cbb4:	f7f7 fc80 	bl	344b8 <mem_acquire>
		if (tx) {
   3cbb8:	4606      	mov	r6, r0
   3cbba:	2800      	cmp	r0, #0
   3cbbc:	f43f aaf7 	beq.w	3c1ae <ull_conn_llcp+0x2a>
						      conn->lll.latency + 6;
   3cbc0:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
			conn->llcp.chan_map.initiate = 0U;
   3cbc2:	f894 20f4 	ldrb.w	r2, [r4, #244]	; 0xf4
						      conn->lll.latency + 6;
   3cbc6:	3306      	adds	r3, #6
			conn->llcp.chan_map.initiate = 0U;
   3cbc8:	f36f 0200 	bfc	r2, #0, #1
						      conn->lll.latency + 6;
   3cbcc:	442b      	add	r3, r5
			conn->llcp.chan_map.initiate = 0U;
   3cbce:	f884 20f4 	strb.w	r2, [r4, #244]	; 0xf4
			conn->llcp.chan_map.instant = event_counter +
   3cbd2:	f8a4 30fa 	strh.w	r3, [r4, #250]	; 0xfa
			pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   3cbd6:	7903      	ldrb	r3, [r0, #4]
			pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl,
   3cbd8:	2108      	movs	r1, #8
			pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   3cbda:	f043 0303 	orr.w	r3, r3, #3
			pdu_ctrl_tx->llctrl.opcode =
   3cbde:	2201      	movs	r2, #1
			pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   3cbe0:	7103      	strb	r3, [r0, #4]
			pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl,
   3cbe2:	7141      	strb	r1, [r0, #5]
			pdu_ctrl_tx->llctrl.opcode =
   3cbe4:	71c2      	strb	r2, [r0, #7]
			memcpy(&pdu_ctrl_tx->llctrl.chan_map_ind.chm[0],
   3cbe6:	f104 01f5 	add.w	r1, r4, #245	; 0xf5
   3cbea:	2205      	movs	r2, #5
   3cbec:	3008      	adds	r0, #8
   3cbee:	f00e f944 	bl	4ae7a <memcpy>
				sys_cpu_to_le16(conn->llcp.chan_map.instant);
   3cbf2:	f8b4 30fa 	ldrh.w	r3, [r4, #250]	; 0xfa
			pdu_ctrl_tx->llctrl.chan_map_ind.instant =
   3cbf6:	f8a6 300d 	strh.w	r3, [r6, #13]
	    conn->tx_head &&
   3cbfa:	f8d4 31dc 	ldr.w	r3, [r4, #476]	; 0x1dc
	if (
   3cbfe:	2b00      	cmp	r3, #0
   3cc00:	f000 80c2 	beq.w	3cd88 <ull_conn_llcp+0xc04>
	    !conn->llcp_cu.pause_tx &&
   3cc04:	f894 211a 	ldrb.w	r2, [r4, #282]	; 0x11a
	    conn->tx_head &&
   3cc08:	06d0      	lsls	r0, r2, #27
   3cc0a:	f100 80bd 	bmi.w	3cd88 <ull_conn_llcp+0xc04>
	    !conn->llcp_enc.pause_tx &&
   3cc0e:	f894 2176 	ldrb.w	r2, [r4, #374]	; 0x176
	    !conn->llcp_cu.pause_tx &&
   3cc12:	0791      	lsls	r1, r2, #30
   3cc14:	f100 80b8 	bmi.w	3cd88 <ull_conn_llcp+0xc04>
	    !conn->llcp_phy.pause_tx &&
   3cc18:	f894 21d7 	ldrb.w	r2, [r4, #471]	; 0x1d7
   3cc1c:	07d2      	lsls	r2, r2, #31
   3cc1e:	f100 80b3 	bmi.w	3cd88 <ull_conn_llcp+0xc04>
		if (conn->tx_head == conn->tx_data) {
   3cc22:	f8d4 11e8 	ldr.w	r1, [r4, #488]	; 0x1e8
		if (!conn->tx_ctrl) {
   3cc26:	f8d4 21e0 	ldr.w	r2, [r4, #480]	; 0x1e0
		if (conn->tx_head == conn->tx_data) {
   3cc2a:	428b      	cmp	r3, r1
   3cc2c:	f000 8343 	beq.w	3d2b6 <ull_conn_llcp+0x1132>
		} else if (!conn->tx_ctrl) {
   3cc30:	2a00      	cmp	r2, #0
   3cc32:	f000 8466 	beq.w	3d502 <ull_conn_llcp+0x137e>
	tx->next = conn->tx_ctrl_last->next;
   3cc36:	f8d4 31e4 	ldr.w	r3, [r4, #484]	; 0x1e4
   3cc3a:	681b      	ldr	r3, [r3, #0]
   3cc3c:	6033      	str	r3, [r6, #0]
	conn->tx_ctrl_last->next = tx;
   3cc3e:	f8d4 31e4 	ldr.w	r3, [r4, #484]	; 0x1e4
   3cc42:	601e      	str	r6, [r3, #0]
	conn->tx_ctrl_last = tx;
   3cc44:	f8c4 61e4 	str.w	r6, [r4, #484]	; 0x1e4
	if (!tx->next) {
   3cc48:	6833      	ldr	r3, [r6, #0]
   3cc4a:	2b00      	cmp	r3, #0
   3cc4c:	f47f aaaf 	bne.w	3c1ae <ull_conn_llcp+0x2a>
		conn->tx_data_last = tx;
   3cc50:	f8c4 61ec 	str.w	r6, [r4, #492]	; 0x1ec
   3cc54:	f7ff baab 	b.w	3c1ae <ull_conn_llcp+0x2a>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
   3cc58:	4859      	ldr	r0, [pc, #356]	; (3cdc0 <ull_conn_llcp+0xc3c>)
   3cc5a:	f7f7 fc2d 	bl	344b8 <mem_acquire>
	if (tx) {
   3cc5e:	4680      	mov	r8, r0
   3cc60:	2800      	cmp	r0, #0
   3cc62:	f43f acd1 	beq.w	3c608 <ull_conn_llcp+0x484>
		conn->llcp_feature.ack--;
   3cc66:	f894 3131 	ldrb.w	r3, [r4, #305]	; 0x131
   3cc6a:	3b01      	subs	r3, #1
   3cc6c:	f884 3131 	strb.w	r3, [r4, #305]	; 0x131
		pdu->ll_id = PDU_DATA_LLID_CTRL;
   3cc70:	7903      	ldrb	r3, [r0, #4]
   3cc72:	f043 0303 	orr.w	r3, r3, #3
   3cc76:	7103      	strb	r3, [r0, #4]
		pdu->len = offsetof(struct pdu_data_llctrl, feature_req) +
   3cc78:	2309      	movs	r3, #9
   3cc7a:	7143      	strb	r3, [r0, #5]
		pdu->llctrl.opcode = !conn->lll.role ?
   3cc7c:	f994 3039 	ldrsb.w	r3, [r4, #57]	; 0x39
   3cc80:	2b00      	cmp	r3, #0
   3cc82:	bfb4      	ite	lt
   3cc84:	230e      	movlt	r3, #14
   3cc86:	2308      	movge	r3, #8
		(void)memset(&pdu->llctrl.feature_req.features[0],
   3cc88:	2208      	movs	r2, #8
		pdu->llctrl.opcode = !conn->lll.role ?
   3cc8a:	71c3      	strb	r3, [r0, #7]
		(void)memset(&pdu->llctrl.feature_req.features[0],
   3cc8c:	4639      	mov	r1, r7
   3cc8e:	4410      	add	r0, r2
   3cc90:	f00e f8fe 	bl	4ae90 <memset>
	sys_put_le32(val >> 32, &dst[4]);
   3cc94:	f8d4 213c 	ldr.w	r2, [r4, #316]	; 0x13c
	dst[0] = val;
   3cc98:	463b      	mov	r3, r7
   3cc9a:	f362 0307 	bfi	r3, r2, #0, #8
	dst[1] = val >> 8;
   3cc9e:	f3c2 2107 	ubfx	r1, r2, #8, #8
	dst[0] = val;
   3cca2:	f361 230f 	bfi	r3, r1, #8, #8
	sys_put_le16(val >> 16, &dst[2]);
   3cca6:	0c12      	lsrs	r2, r2, #16
	dst[0] = val;
   3cca8:	f362 4317 	bfi	r3, r2, #16, #8
	dst[1] = val >> 8;
   3ccac:	0a12      	lsrs	r2, r2, #8
	dst[0] = val;
   3ccae:	f362 631f 	bfi	r3, r2, #24, #8
   3ccb2:	f8d4 2138 	ldr.w	r2, [r4, #312]	; 0x138
   3ccb6:	f8c8 2008 	str.w	r2, [r8, #8]
   3ccba:	f8c8 300c 	str.w	r3, [r8, #12]
	    conn->tx_head &&
   3ccbe:	f8d4 31dc 	ldr.w	r3, [r4, #476]	; 0x1dc
	if (
   3ccc2:	2b00      	cmp	r3, #0
   3ccc4:	d069      	beq.n	3cd9a <ull_conn_llcp+0xc16>
	    !conn->llcp_cu.pause_tx &&
   3ccc6:	f894 211a 	ldrb.w	r2, [r4, #282]	; 0x11a
	    conn->tx_head &&
   3ccca:	06d7      	lsls	r7, r2, #27
   3cccc:	d465      	bmi.n	3cd9a <ull_conn_llcp+0xc16>
	    !conn->llcp_enc.pause_tx &&
   3ccce:	f894 2176 	ldrb.w	r2, [r4, #374]	; 0x176
	    !conn->llcp_cu.pause_tx &&
   3ccd2:	0790      	lsls	r0, r2, #30
   3ccd4:	d461      	bmi.n	3cd9a <ull_conn_llcp+0xc16>
	    !conn->llcp_phy.pause_tx &&
   3ccd6:	f894 21d7 	ldrb.w	r2, [r4, #471]	; 0x1d7
   3ccda:	07d1      	lsls	r1, r2, #31
   3ccdc:	d45d      	bmi.n	3cd9a <ull_conn_llcp+0xc16>
		if (conn->tx_head == conn->tx_data) {
   3ccde:	f8d4 11e8 	ldr.w	r1, [r4, #488]	; 0x1e8
		if (!conn->tx_ctrl) {
   3cce2:	f8d4 21e0 	ldr.w	r2, [r4, #480]	; 0x1e0
		if (conn->tx_head == conn->tx_data) {
   3cce6:	428b      	cmp	r3, r1
   3cce8:	f000 82f3 	beq.w	3d2d2 <ull_conn_llcp+0x114e>
		} else if (!conn->tx_ctrl) {
   3ccec:	2a00      	cmp	r2, #0
   3ccee:	f000 8441 	beq.w	3d574 <ull_conn_llcp+0x13f0>
	tx->next = conn->tx_ctrl_last->next;
   3ccf2:	f8d4 31e4 	ldr.w	r3, [r4, #484]	; 0x1e4
   3ccf6:	681b      	ldr	r3, [r3, #0]
   3ccf8:	f8c8 3000 	str.w	r3, [r8]
	conn->tx_ctrl_last->next = tx;
   3ccfc:	f8d4 31e4 	ldr.w	r3, [r4, #484]	; 0x1e4
   3cd00:	f8c3 8000 	str.w	r8, [r3]
	conn->tx_ctrl_last = tx;
   3cd04:	f8c4 81e4 	str.w	r8, [r4, #484]	; 0x1e4
	if (!tx->next) {
   3cd08:	f8d8 3000 	ldr.w	r3, [r8]
   3cd0c:	2b00      	cmp	r3, #0
   3cd0e:	f000 81d1 	beq.w	3d0b4 <ull_conn_llcp+0xf30>
		conn->procedure_expire = conn->procedure_reload;
   3cd12:	f8b4 20c6 	ldrh.w	r2, [r4, #198]	; 0xc6
	if (((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) {
   3cd16:	f894 30f0 	ldrb.w	r3, [r4, #240]	; 0xf0
   3cd1a:	f894 00f1 	ldrb.w	r0, [r4, #241]	; 0xf1
		conn->procedure_expire = conn->procedure_reload;
   3cd1e:	f8a4 20c8 	strh.w	r2, [r4, #200]	; 0xc8
	break;
   3cd22:	f7ff ba3a 	b.w	3c19a <ull_conn_llcp+0x16>
		} else if (conn->llcp_length.ack != conn->llcp_length.req) {
   3cd26:	f894 71c5 	ldrb.w	r7, [r4, #453]	; 0x1c5
   3cd2a:	f894 31c4 	ldrb.w	r3, [r4, #452]	; 0x1c4
   3cd2e:	429f      	cmp	r7, r3
   3cd30:	f000 80bd 	beq.w	3ceae <ull_conn_llcp+0xd2a>
			event_len_prep(conn);
   3cd34:	4620      	mov	r0, r4
   3cd36:	f7fc fecf 	bl	39ad8 <event_len_prep>
	if (((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) {
   3cd3a:	f894 30f0 	ldrb.w	r3, [r4, #240]	; 0xf0
   3cd3e:	f894 00f1 	ldrb.w	r0, [r4, #241]	; 0xf1
   3cd42:	f7ff ba2a 	b.w	3c19a <ull_conn_llcp+0x16>
		if (!conn->tx_ctrl) {
   3cd46:	f8d4 31e0 	ldr.w	r3, [r4, #480]	; 0x1e0
   3cd4a:	2b00      	cmp	r3, #0
   3cd4c:	f47f ad1a 	bne.w	3c784 <ull_conn_llcp+0x600>
			tx->next = conn->tx_head;
   3cd50:	f8c8 2000 	str.w	r2, [r8]
				conn->tx_ctrl = tx;
   3cd54:	e9c4 8877 	strd	r8, r8, [r4, #476]	; 0x1dc
				conn->tx_ctrl_last = tx;
   3cd58:	e51d      	b.n	3c796 <ull_conn_llcp+0x612>
		conn->tx_data_last = tx;
   3cd5a:	f8c4 01ec 	str.w	r0, [r4, #492]	; 0x1ec
   3cd5e:	f7ff bad5 	b.w	3c30c <ull_conn_llcp+0x188>
		if (conn->lll.role && (conn->periph.llcp_type != LLCP_NONE)) {
   3cd62:	f894 30e5 	ldrb.w	r3, [r4, #229]	; 0xe5
   3cd66:	2b00      	cmp	r3, #0
   3cd68:	f43f ab78 	beq.w	3c45c <ull_conn_llcp+0x2d8>
			conn->periph.llcp_type = LLCP_NONE;
   3cd6c:	f884 10e5 	strb.w	r1, [r4, #229]	; 0xe5
   3cd70:	f7ff bb78 	b.w	3c464 <ull_conn_llcp+0x2e0>
		if (!conn->tx_ctrl) {
   3cd74:	f8d4 21e0 	ldr.w	r2, [r4, #480]	; 0x1e0
   3cd78:	2a00      	cmp	r2, #0
   3cd7a:	f47f ad5e 	bne.w	3c83a <ull_conn_llcp+0x6b6>
			tx->next = conn->tx_head;
   3cd7e:	f8c8 3000 	str.w	r3, [r8]
				conn->tx_ctrl = tx;
   3cd82:	e9c4 8877 	strd	r8, r8, [r4, #476]	; 0x1dc
				conn->tx_ctrl_last = tx;
   3cd86:	e561      	b.n	3c84c <ull_conn_llcp+0x6c8>
		if (!conn->tx_ctrl) {
   3cd88:	f8d4 21e0 	ldr.w	r2, [r4, #480]	; 0x1e0
   3cd8c:	2a00      	cmp	r2, #0
   3cd8e:	f47f af52 	bne.w	3cc36 <ull_conn_llcp+0xab2>
			tx->next = conn->tx_head;
   3cd92:	6033      	str	r3, [r6, #0]
				conn->tx_ctrl = tx;
   3cd94:	e9c4 6677 	strd	r6, r6, [r4, #476]	; 0x1dc
				conn->tx_ctrl_last = tx;
   3cd98:	e754      	b.n	3cc44 <ull_conn_llcp+0xac0>
		if (!conn->tx_ctrl) {
   3cd9a:	f8d4 21e0 	ldr.w	r2, [r4, #480]	; 0x1e0
   3cd9e:	2a00      	cmp	r2, #0
   3cda0:	d1a7      	bne.n	3ccf2 <ull_conn_llcp+0xb6e>
			tx->next = conn->tx_head;
   3cda2:	f8c8 3000 	str.w	r3, [r8]
				conn->tx_ctrl = tx;
   3cda6:	e9c4 8877 	strd	r8, r8, [r4, #476]	; 0x1dc
				conn->tx_ctrl_last = tx;
   3cdaa:	e7ab      	b.n	3cd04 <ull_conn_llcp+0xb80>
		if (!conn->tx_ctrl) {
   3cdac:	f8d4 21e0 	ldr.w	r2, [r4, #480]	; 0x1e0
   3cdb0:	2a00      	cmp	r2, #0
   3cdb2:	f47f ab02 	bne.w	3c3ba <ull_conn_llcp+0x236>
			tx->next = conn->tx_head;
   3cdb6:	603b      	str	r3, [r7, #0]
				conn->tx_ctrl = tx;
   3cdb8:	e9c4 7777 	strd	r7, r7, [r4, #476]	; 0x1dc
				conn->tx_ctrl_last = tx;
   3cdbc:	f7ff bb04 	b.w	3c3c8 <ull_conn_llcp+0x244>
   3cdc0:	20005384 	.word	0x20005384
   3cdc4:	ffff0000 	.word	0xffff0000
   3cdc8:	20000acc 	.word	0x20000acc
   3cdcc:	0005269c 	.word	0x0005269c
   3cdd0:	00052458 	.word	0x00052458
   3cdd4:	0005214c 	.word	0x0005214c
		ecb_encrypt(&conn->llcp_enc.ltk[0],
   3cdd8:	f104 077b 	add.w	r7, r4, #123	; 0x7b
   3cddc:	463b      	mov	r3, r7
   3cdde:	464a      	mov	r2, r9
   3cde0:	f504 7181 	add.w	r1, r4, #258	; 0x102
   3cde4:	f204 1081 	addw	r0, r4, #385	; 0x181
   3cde8:	f004 fe4a 	bl	41a80 <ecb_encrypt>
		memcpy(&lll->ccm_tx.key[0], &lll->ccm_rx.key[0],
   3cdec:	4639      	mov	r1, r7
   3cdee:	2210      	movs	r2, #16
   3cdf0:	f104 009c 	add.w	r0, r4, #156	; 0x9c
   3cdf4:	f00e f841 	bl	4ae7a <memcpy>
		memcpy(&lll->ccm_tx.iv[0], &lll->ccm_rx.iv[0],
   3cdf8:	2208      	movs	r2, #8
   3cdfa:	f104 0194 	add.w	r1, r4, #148	; 0x94
   3cdfe:	f104 00b5 	add.w	r0, r4, #181	; 0xb5
   3ce02:	f00e f83a 	bl	4ae7a <memcpy>
		lll->enc_rx = 1U;
   3ce06:	f894 307a 	ldrb.w	r3, [r4, #122]	; 0x7a
		lll->ccm_rx.counter = 0U;
   3ce0a:	f884 908b 	strb.w	r9, [r4, #139]	; 0x8b
		lll->enc_rx = 1U;
   3ce0e:	f023 0318 	bic.w	r3, r3, #24
   3ce12:	f043 0318 	orr.w	r3, r3, #24
   3ce16:	f884 307a 	strb.w	r3, [r4, #122]	; 0x7a
		lll->ccm_rx.direction = 0U;
   3ce1a:	f894 3093 	ldrb.w	r3, [r4, #147]	; 0x93
		lll->ccm_rx.counter = 0U;
   3ce1e:	f884 908c 	strb.w	r9, [r4, #140]	; 0x8c
		lll->ccm_rx.direction = 0U;
   3ce22:	f369 0300 	bfi	r3, r9, #0, #1
   3ce26:	f884 3093 	strb.w	r3, [r4, #147]	; 0x93
		lll->ccm_tx.direction = 1U;
   3ce2a:	f894 30b4 	ldrb.w	r3, [r4, #180]	; 0xb4
		lll->ccm_rx.counter = 0U;
   3ce2e:	f884 908d 	strb.w	r9, [r4, #141]	; 0x8d
		lll->ccm_tx.counter = 0U;
   3ce32:	e9c4 992b 	strd	r9, r9, [r4, #172]	; 0xac
		lll->ccm_tx.direction = 1U;
   3ce36:	f043 0301 	orr.w	r3, r3, #1
		lll->ccm_rx.counter = 0U;
   3ce3a:	f884 908e 	strb.w	r9, [r4, #142]	; 0x8e
   3ce3e:	f884 908f 	strb.w	r9, [r4, #143]	; 0x8f
   3ce42:	f884 9090 	strb.w	r9, [r4, #144]	; 0x90
   3ce46:	f884 9091 	strb.w	r9, [r4, #145]	; 0x91
   3ce4a:	f884 9092 	strb.w	r9, [r4, #146]	; 0x92
		lll->ccm_tx.direction = 1U;
   3ce4e:	f884 30b4 	strb.w	r3, [r4, #180]	; 0xb4
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   3ce52:	f898 3004 	ldrb.w	r3, [r8, #4]
   3ce56:	f043 0303 	orr.w	r3, r3, #3
   3ce5a:	f888 3004 	strb.w	r3, [r8, #4]
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, enc_rsp);
   3ce5e:	2301      	movs	r3, #1
   3ce60:	f888 3005 	strb.w	r3, [r8, #5]
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_START_ENC_RSP;
   3ce64:	2306      	movs	r3, #6
   3ce66:	f888 3007 	strb.w	r3, [r8, #7]
	    conn->tx_head &&
   3ce6a:	f8d4 21dc 	ldr.w	r2, [r4, #476]	; 0x1dc
	if (
   3ce6e:	2a00      	cmp	r2, #0
   3ce70:	f43f af69 	beq.w	3cd46 <ull_conn_llcp+0xbc2>
	    !conn->llcp_cu.pause_tx &&
   3ce74:	f894 311a 	ldrb.w	r3, [r4, #282]	; 0x11a
	    conn->tx_head &&
   3ce78:	06db      	lsls	r3, r3, #27
   3ce7a:	f53f af64 	bmi.w	3cd46 <ull_conn_llcp+0xbc2>
	    !conn->llcp_enc.pause_tx &&
   3ce7e:	f894 3176 	ldrb.w	r3, [r4, #374]	; 0x176
	    !conn->llcp_cu.pause_tx &&
   3ce82:	079f      	lsls	r7, r3, #30
   3ce84:	f53f af5f 	bmi.w	3cd46 <ull_conn_llcp+0xbc2>
	    !conn->llcp_phy.pause_tx &&
   3ce88:	f894 31d7 	ldrb.w	r3, [r4, #471]	; 0x1d7
   3ce8c:	07d8      	lsls	r0, r3, #31
   3ce8e:	f53f af5a 	bmi.w	3cd46 <ull_conn_llcp+0xbc2>
		if (conn->tx_head == conn->tx_data) {
   3ce92:	f8d4 11e8 	ldr.w	r1, [r4, #488]	; 0x1e8
		if (!conn->tx_ctrl) {
   3ce96:	f8d4 31e0 	ldr.w	r3, [r4, #480]	; 0x1e0
		if (conn->tx_head == conn->tx_data) {
   3ce9a:	428a      	cmp	r2, r1
   3ce9c:	f47f ac6f 	bne.w	3c77e <ull_conn_llcp+0x5fa>
			conn->tx_data = conn->tx_data->next;
   3cea0:	6811      	ldr	r1, [r2, #0]
   3cea2:	f8c4 11e8 	str.w	r1, [r4, #488]	; 0x1e8
		if (!conn->tx_ctrl) {
   3cea6:	2b00      	cmp	r3, #0
   3cea8:	f43f ace1 	beq.w	3c86e <ull_conn_llcp+0x6ea>
   3ceac:	e46a      	b.n	3c784 <ull_conn_llcp+0x600>
		} else if (conn->llcp_phy.ack != conn->llcp_phy.req) {
   3ceae:	f894 31d4 	ldrb.w	r3, [r4, #468]	; 0x1d4
   3ceb2:	f894 71d5 	ldrb.w	r7, [r4, #469]	; 0x1d5
   3ceb6:	429f      	cmp	r7, r3
   3ceb8:	f43f a977 	beq.w	3c1aa <ull_conn_llcp+0x26>
	switch (conn->llcp_phy.state) {
   3cebc:	f894 21d6 	ldrb.w	r2, [r4, #470]	; 0x1d6
   3cec0:	f002 0703 	and.w	r7, r2, #3
   3cec4:	2f03      	cmp	r7, #3
   3cec6:	f000 818b 	beq.w	3d1e0 <ull_conn_llcp+0x105c>
   3ceca:	2f00      	cmp	r7, #0
   3cecc:	f47f a96c 	bne.w	3c1a8 <ull_conn_llcp+0x24>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
   3ced0:	48bf      	ldr	r0, [pc, #764]	; (3d1d0 <ull_conn_llcp+0x104c>)
   3ced2:	f7f7 faf1 	bl	344b8 <mem_acquire>
		if (!tx) {
   3ced6:	4601      	mov	r1, r0
   3ced8:	2800      	cmp	r0, #0
   3ceda:	f43f ab95 	beq.w	3c608 <ull_conn_llcp+0x484>
		conn->phy_pref_tx = conn->llcp_phy.tx;
   3cede:	f894 01d8 	ldrb.w	r0, [r4, #472]	; 0x1d8
   3cee2:	f894 31d6 	ldrb.w	r3, [r4, #470]	; 0x1d6
   3cee6:	f020 003f 	bic.w	r0, r0, #63	; 0x3f
   3ceea:	ea40 0093 	orr.w	r0, r0, r3, lsr #2
   3ceee:	f884 01d8 	strb.w	r0, [r4, #472]	; 0x1d8
		conn->lll.phy_flags = conn->llcp_phy.flags;
   3cef2:	f894 01d7 	ldrb.w	r0, [r4, #471]	; 0x1d7
	ctrl_tx_pause_enqueue(conn, tx, false);
   3cef6:	463a      	mov	r2, r7
		conn->lll.phy_flags = conn->llcp_phy.flags;
   3cef8:	f894 7060 	ldrb.w	r7, [r4, #96]	; 0x60
   3cefc:	f3c0 0040 	ubfx	r0, r0, #1, #1
   3cf00:	f360 07c3 	bfi	r7, r0, #3, #1
		conn->llcp_phy.state = LLCP_PHY_STATE_ACK_WAIT;
   3cf04:	2001      	movs	r0, #1
   3cf06:	f360 0301 	bfi	r3, r0, #0, #2
   3cf0a:	f884 31d6 	strb.w	r3, [r4, #470]	; 0x1d6
		conn->lll.phy_flags = conn->llcp_phy.flags;
   3cf0e:	f884 7060 	strb.w	r7, [r4, #96]	; 0x60
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   3cf12:	790b      	ldrb	r3, [r1, #4]
   3cf14:	f043 0303 	orr.w	r3, r3, #3
   3cf18:	710b      	strb	r3, [r1, #4]
		pdu_ctrl_tx->len =
   3cf1a:	2303      	movs	r3, #3
   3cf1c:	714b      	strb	r3, [r1, #5]
		pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PHY_REQ;
   3cf1e:	2316      	movs	r3, #22
   3cf20:	71cb      	strb	r3, [r1, #7]
		pr->tx_phys = conn->llcp_phy.tx;
   3cf22:	f894 31d6 	ldrb.w	r3, [r4, #470]	; 0x1d6
   3cf26:	f3c3 0382 	ubfx	r3, r3, #2, #3
   3cf2a:	720b      	strb	r3, [r1, #8]
		pr->rx_phys = conn->llcp_phy.rx;
   3cf2c:	f894 31d6 	ldrb.w	r3, [r4, #470]	; 0x1d6
   3cf30:	f3c3 1342 	ubfx	r3, r3, #5, #3
   3cf34:	724b      	strb	r3, [r1, #9]
	ctrl_tx_pause_enqueue(conn, tx, false);
   3cf36:	4620      	mov	r0, r4
   3cf38:	f7fc fa64 	bl	39404 <ctrl_tx_pause_enqueue>
   3cf3c:	e6e9      	b.n	3cd12 <ull_conn_llcp+0xb8e>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
   3cf3e:	48a4      	ldr	r0, [pc, #656]	; (3d1d0 <ull_conn_llcp+0x104c>)
   3cf40:	f7f7 faba 	bl	344b8 <mem_acquire>
		if (tx) {
   3cf44:	2800      	cmp	r0, #0
   3cf46:	f43f ab5f 	beq.w	3c608 <ull_conn_llcp+0x484>
			conn->llcp_version.ack--;
   3cf4a:	f894 3149 	ldrb.w	r3, [r4, #329]	; 0x149
   3cf4e:	3b01      	subs	r3, #1
   3cf50:	f884 3149 	strb.w	r3, [r4, #329]	; 0x149
			conn->llcp_version.tx = 1U;
   3cf54:	f894 314a 	ldrb.w	r3, [r4, #330]	; 0x14a
   3cf58:	f043 0301 	orr.w	r3, r3, #1
   3cf5c:	f884 314a 	strb.w	r3, [r4, #330]	; 0x14a
			pdu->ll_id = PDU_DATA_LLID_CTRL;
   3cf60:	7903      	ldrb	r3, [r0, #4]
   3cf62:	f043 0303 	orr.w	r3, r3, #3
   3cf66:	7103      	strb	r3, [r0, #4]
			pdu->len =
   3cf68:	2306      	movs	r3, #6
   3cf6a:	7143      	strb	r3, [r0, #5]
			pdu->llctrl.opcode =
   3cf6c:	f640 430c 	movw	r3, #3084	; 0xc0c
   3cf70:	f8a0 3007 	strh.w	r3, [r0, #7]
			pdu->llctrl.version_ind.company_id = cid;
   3cf74:	4b97      	ldr	r3, [pc, #604]	; (3d1d4 <ull_conn_llcp+0x1050>)
   3cf76:	f8c0 3009 	str.w	r3, [r0, #9]
	    conn->tx_head &&
   3cf7a:	f8d4 31dc 	ldr.w	r3, [r4, #476]	; 0x1dc
	if (
   3cf7e:	2b00      	cmp	r3, #0
   3cf80:	f000 80e7 	beq.w	3d152 <ull_conn_llcp+0xfce>
	    !conn->llcp_cu.pause_tx &&
   3cf84:	f894 211a 	ldrb.w	r2, [r4, #282]	; 0x11a
	    conn->tx_head &&
   3cf88:	06d7      	lsls	r7, r2, #27
   3cf8a:	f100 80e2 	bmi.w	3d152 <ull_conn_llcp+0xfce>
	    !conn->llcp_enc.pause_tx &&
   3cf8e:	f894 2176 	ldrb.w	r2, [r4, #374]	; 0x176
	    !conn->llcp_cu.pause_tx &&
   3cf92:	0791      	lsls	r1, r2, #30
   3cf94:	f100 80dd 	bmi.w	3d152 <ull_conn_llcp+0xfce>
	    !conn->llcp_phy.pause_tx &&
   3cf98:	f894 21d7 	ldrb.w	r2, [r4, #471]	; 0x1d7
   3cf9c:	07d2      	lsls	r2, r2, #31
   3cf9e:	f100 80d8 	bmi.w	3d152 <ull_conn_llcp+0xfce>
		if (conn->tx_head == conn->tx_data) {
   3cfa2:	f8d4 11e8 	ldr.w	r1, [r4, #488]	; 0x1e8
		if (!conn->tx_ctrl) {
   3cfa6:	f8d4 21e0 	ldr.w	r2, [r4, #480]	; 0x1e0
		if (conn->tx_head == conn->tx_data) {
   3cfaa:	428b      	cmp	r3, r1
   3cfac:	f000 82b3 	beq.w	3d516 <ull_conn_llcp+0x1392>
		} else if (!conn->tx_ctrl) {
   3cfb0:	2a00      	cmp	r2, #0
   3cfb2:	f000 834d 	beq.w	3d650 <ull_conn_llcp+0x14cc>
	tx->next = conn->tx_ctrl_last->next;
   3cfb6:	f8d4 31e4 	ldr.w	r3, [r4, #484]	; 0x1e4
   3cfba:	681b      	ldr	r3, [r3, #0]
   3cfbc:	6003      	str	r3, [r0, #0]
	conn->tx_ctrl_last->next = tx;
   3cfbe:	f8d4 31e4 	ldr.w	r3, [r4, #484]	; 0x1e4
   3cfc2:	6018      	str	r0, [r3, #0]
	conn->tx_ctrl_last = tx;
   3cfc4:	f8c4 01e4 	str.w	r0, [r4, #484]	; 0x1e4
	if (!tx->next) {
   3cfc8:	6803      	ldr	r3, [r0, #0]
   3cfca:	2b00      	cmp	r3, #0
   3cfcc:	f47f aea1 	bne.w	3cd12 <ull_conn_llcp+0xb8e>
		conn->tx_data_last = tx;
   3cfd0:	f8c4 01ec 	str.w	r0, [r4, #492]	; 0x1ec
			conn->procedure_expire = conn->procedure_reload;
   3cfd4:	e69d      	b.n	3cd12 <ull_conn_llcp+0xb8e>
		conn->tx_data_last = tx;
   3cfd6:	f8c4 81ec 	str.w	r8, [r4, #492]	; 0x1ec
   3cfda:	f7ff bbe3 	b.w	3c7a4 <ull_conn_llcp+0x620>
		LL_ASSERT(0);
   3cfde:	4a7e      	ldr	r2, [pc, #504]	; (3d1d8 <ull_conn_llcp+0x1054>)
   3cfe0:	497e      	ldr	r1, [pc, #504]	; (3d1dc <ull_conn_llcp+0x1058>)
   3cfe2:	f640 7385 	movw	r3, #3973	; 0xf85
   3cfe6:	e5da      	b.n	3cb9e <ull_conn_llcp+0xa1a>
	conn->lll.enc_tx = 1;
   3cfe8:	f043 0310 	orr.w	r3, r3, #16
   3cfec:	f884 307a 	strb.w	r3, [r4, #122]	; 0x7a
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   3cff0:	7903      	ldrb	r3, [r0, #4]
   3cff2:	f043 0303 	orr.w	r3, r3, #3
   3cff6:	7103      	strb	r3, [r0, #4]
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, enc_rsp);
   3cff8:	2301      	movs	r3, #1
   3cffa:	7143      	strb	r3, [r0, #5]
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_START_ENC_RSP;
   3cffc:	2306      	movs	r3, #6
   3cffe:	71c3      	strb	r3, [r0, #7]
	    conn->tx_head &&
   3d000:	f8d4 31dc 	ldr.w	r3, [r4, #476]	; 0x1dc
	if (
   3d004:	b373      	cbz	r3, 3d064 <ull_conn_llcp+0xee0>
	    !conn->llcp_cu.pause_tx &&
   3d006:	f894 211a 	ldrb.w	r2, [r4, #282]	; 0x11a
	    conn->tx_head &&
   3d00a:	06d2      	lsls	r2, r2, #27
   3d00c:	d42a      	bmi.n	3d064 <ull_conn_llcp+0xee0>
	    !conn->llcp_enc.pause_tx &&
   3d00e:	f894 2176 	ldrb.w	r2, [r4, #374]	; 0x176
	    !conn->llcp_cu.pause_tx &&
   3d012:	0797      	lsls	r7, r2, #30
   3d014:	d426      	bmi.n	3d064 <ull_conn_llcp+0xee0>
	    !conn->llcp_phy.pause_tx &&
   3d016:	f894 21d7 	ldrb.w	r2, [r4, #471]	; 0x1d7
   3d01a:	07d0      	lsls	r0, r2, #31
   3d01c:	d422      	bmi.n	3d064 <ull_conn_llcp+0xee0>
		if (conn->tx_head == conn->tx_data) {
   3d01e:	f8d4 11e8 	ldr.w	r1, [r4, #488]	; 0x1e8
		if (!conn->tx_ctrl) {
   3d022:	f8d4 21e0 	ldr.w	r2, [r4, #480]	; 0x1e0
		if (conn->tx_head == conn->tx_data) {
   3d026:	428b      	cmp	r3, r1
   3d028:	f000 8293 	beq.w	3d552 <ull_conn_llcp+0x13ce>
		} else if (!conn->tx_ctrl) {
   3d02c:	2a00      	cmp	r2, #0
   3d02e:	f47f aba9 	bne.w	3c784 <ull_conn_llcp+0x600>
	if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   3d032:	791a      	ldrb	r2, [r3, #4]
   3d034:	f002 0203 	and.w	r2, r2, #3
   3d038:	2a03      	cmp	r2, #3
   3d03a:	f000 833e 	beq.w	3d6ba <ull_conn_llcp+0x1536>
		conn->tx_ctrl = conn->tx_ctrl_last = conn->tx_head;
   3d03e:	e9c4 3378 	strd	r3, r3, [r4, #480]	; 0x1e0
   3d042:	f7ff bb9f 	b.w	3c784 <ull_conn_llcp+0x600>
			conn->tx_data = conn->tx_data->next;
   3d046:	681a      	ldr	r2, [r3, #0]
   3d048:	f8c4 21e8 	str.w	r2, [r4, #488]	; 0x1e8
		if (!conn->tx_ctrl) {
   3d04c:	2900      	cmp	r1, #0
   3d04e:	f47f aa72 	bne.w	3c536 <ull_conn_llcp+0x3b2>
			tx->next = conn->tx_head->next;
   3d052:	681b      	ldr	r3, [r3, #0]
   3d054:	6003      	str	r3, [r0, #0]
			conn->tx_head->next = tx;
   3d056:	f8d4 31dc 	ldr.w	r3, [r4, #476]	; 0x1dc
   3d05a:	6018      	str	r0, [r3, #0]
				conn->tx_ctrl = tx;
   3d05c:	f8c4 01e0 	str.w	r0, [r4, #480]	; 0x1e0
				conn->tx_ctrl_last = tx;
   3d060:	f7ff ba70 	b.w	3c544 <ull_conn_llcp+0x3c0>
		if (!conn->tx_ctrl) {
   3d064:	f8d4 21e0 	ldr.w	r2, [r4, #480]	; 0x1e0
   3d068:	2a00      	cmp	r2, #0
   3d06a:	f47f ab8b 	bne.w	3c784 <ull_conn_llcp+0x600>
			tx->next = conn->tx_head;
   3d06e:	f8c8 3000 	str.w	r3, [r8]
				conn->tx_ctrl = tx;
   3d072:	e9c4 8877 	strd	r8, r8, [r4, #476]	; 0x1dc
				conn->tx_ctrl_last = tx;
   3d076:	f7ff bb8e 	b.w	3c796 <ull_conn_llcp+0x612>
	switch (conn->llcp_conn_param.state) {
   3d07a:	f894 3196 	ldrb.w	r3, [r4, #406]	; 0x196
   3d07e:	f003 030f 	and.w	r3, r3, #15
   3d082:	2b08      	cmp	r3, #8
   3d084:	f200 833f 	bhi.w	3d706 <ull_conn_llcp+0x1582>
   3d088:	a001      	add	r0, pc, #4	; (adr r0, 3d090 <ull_conn_llcp+0xf0c>)
   3d08a:	f850 f023 	ldr.w	pc, [r0, r3, lsl #2]
   3d08e:	bf00      	nop
   3d090:	0003caf7 	.word	0x0003caf7
   3d094:	0003ca79 	.word	0x0003ca79
   3d098:	0003ca17 	.word	0x0003ca17
   3d09c:	0003c1ab 	.word	0x0003c1ab
   3d0a0:	0003c1ab 	.word	0x0003c1ab
   3d0a4:	0003c1ab 	.word	0x0003c1ab
   3d0a8:	0003c1ab 	.word	0x0003c1ab
   3d0ac:	0003c1ab 	.word	0x0003c1ab
   3d0b0:	0003c98d 	.word	0x0003c98d
		conn->tx_data_last = tx;
   3d0b4:	f8c4 81ec 	str.w	r8, [r4, #492]	; 0x1ec
		conn->procedure_expire = conn->procedure_reload;
   3d0b8:	e62b      	b.n	3cd12 <ull_conn_llcp+0xb8e>
		conn->tx_data_last = tx;
   3d0ba:	f8c4 71ec 	str.w	r7, [r4, #492]	; 0x1ec
			if (err) {
   3d0be:	f7ff b989 	b.w	3c3d4 <ull_conn_llcp+0x250>
	pdu->ll_id = PDU_DATA_LLID_CTRL;
   3d0c2:	7903      	ldrb	r3, [r0, #4]
   3d0c4:	f043 0303 	orr.w	r3, r3, #3
   3d0c8:	7103      	strb	r3, [r0, #4]
	if (conn->common.fex_valid &&
   3d0ca:	f894 30e4 	ldrb.w	r3, [r4, #228]	; 0xe4
   3d0ce:	07da      	lsls	r2, r3, #31
   3d0d0:	d551      	bpl.n	3d176 <ull_conn_llcp+0xff2>
	    (conn->llcp_feature.features_conn &
   3d0d2:	f8d4 3138 	ldr.w	r3, [r4, #312]	; 0x138
	if (conn->common.fex_valid &&
   3d0d6:	075b      	lsls	r3, r3, #29
   3d0d8:	d54d      	bpl.n	3d176 <ull_conn_llcp+0xff2>
		pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND;
   3d0da:	f240 3311 	movw	r3, #785	; 0x311
   3d0de:	f8a0 3007 	strh.w	r3, [r0, #7]
		p->error_code = conn->llcp.encryption.error_code;
   3d0e2:	f894 3101 	ldrb.w	r3, [r4, #257]	; 0x101
   3d0e6:	7243      	strb	r3, [r0, #9]
	pdu->len += offsetof(struct pdu_data_llctrl, reject_ind);
   3d0e8:	f888 7005 	strb.w	r7, [r8, #5]
	conn->llcp.encryption.error_code = 0U;
   3d0ec:	2300      	movs	r3, #0
   3d0ee:	f884 3101 	strb.w	r3, [r4, #257]	; 0x101
	    conn->tx_head &&
   3d0f2:	f8d4 31dc 	ldr.w	r3, [r4, #476]	; 0x1dc
	if (
   3d0f6:	b3ab      	cbz	r3, 3d164 <ull_conn_llcp+0xfe0>
	    !conn->llcp_cu.pause_tx &&
   3d0f8:	f894 211a 	ldrb.w	r2, [r4, #282]	; 0x11a
	    conn->tx_head &&
   3d0fc:	06d0      	lsls	r0, r2, #27
   3d0fe:	d431      	bmi.n	3d164 <ull_conn_llcp+0xfe0>
	    !conn->llcp_enc.pause_tx &&
   3d100:	f894 2176 	ldrb.w	r2, [r4, #374]	; 0x176
	    !conn->llcp_cu.pause_tx &&
   3d104:	0791      	lsls	r1, r2, #30
   3d106:	d42d      	bmi.n	3d164 <ull_conn_llcp+0xfe0>
	    !conn->llcp_phy.pause_tx &&
   3d108:	f894 21d7 	ldrb.w	r2, [r4, #471]	; 0x1d7
   3d10c:	07d2      	lsls	r2, r2, #31
   3d10e:	d429      	bmi.n	3d164 <ull_conn_llcp+0xfe0>
		if (conn->tx_head == conn->tx_data) {
   3d110:	f8d4 11e8 	ldr.w	r1, [r4, #488]	; 0x1e8
		if (!conn->tx_ctrl) {
   3d114:	f8d4 21e0 	ldr.w	r2, [r4, #480]	; 0x1e0
		if (conn->tx_head == conn->tx_data) {
   3d118:	428b      	cmp	r3, r1
   3d11a:	f000 820a 	beq.w	3d532 <ull_conn_llcp+0x13ae>
		} else if (!conn->tx_ctrl) {
   3d11e:	2a00      	cmp	r2, #0
   3d120:	f000 82d3 	beq.w	3d6ca <ull_conn_llcp+0x1546>
	tx->next = conn->tx_ctrl_last->next;
   3d124:	f8d4 31e4 	ldr.w	r3, [r4, #484]	; 0x1e4
   3d128:	681b      	ldr	r3, [r3, #0]
   3d12a:	f8c8 3000 	str.w	r3, [r8]
	conn->tx_ctrl_last->next = tx;
   3d12e:	f8d4 31e4 	ldr.w	r3, [r4, #484]	; 0x1e4
   3d132:	f8c3 8000 	str.w	r8, [r3]
	conn->tx_ctrl_last = tx;
   3d136:	f8c4 81e4 	str.w	r8, [r4, #484]	; 0x1e4
	if (!tx->next) {
   3d13a:	f8d8 3000 	ldr.w	r3, [r8]
   3d13e:	2b00      	cmp	r3, #0
   3d140:	d03b      	beq.n	3d1ba <ull_conn_llcp+0x1036>
			conn->llcp_ack = conn->llcp_req;
   3d142:	f894 30f0 	ldrb.w	r3, [r4, #240]	; 0xf0
   3d146:	f994 2039 	ldrsb.w	r2, [r4, #57]	; 0x39
   3d14a:	f884 30f1 	strb.w	r3, [r4, #241]	; 0xf1
			return;
   3d14e:	f7ff b82c 	b.w	3c1aa <ull_conn_llcp+0x26>
		if (!conn->tx_ctrl) {
   3d152:	f8d4 21e0 	ldr.w	r2, [r4, #480]	; 0x1e0
   3d156:	2a00      	cmp	r2, #0
   3d158:	f47f af2d 	bne.w	3cfb6 <ull_conn_llcp+0xe32>
			tx->next = conn->tx_head;
   3d15c:	6003      	str	r3, [r0, #0]
				conn->tx_ctrl = tx;
   3d15e:	e9c4 0077 	strd	r0, r0, [r4, #476]	; 0x1dc
				conn->tx_ctrl_last = tx;
   3d162:	e72f      	b.n	3cfc4 <ull_conn_llcp+0xe40>
		if (!conn->tx_ctrl) {
   3d164:	f8d4 21e0 	ldr.w	r2, [r4, #480]	; 0x1e0
   3d168:	2a00      	cmp	r2, #0
   3d16a:	d1db      	bne.n	3d124 <ull_conn_llcp+0xfa0>
			tx->next = conn->tx_head;
   3d16c:	f8c8 3000 	str.w	r3, [r8]
				conn->tx_ctrl = tx;
   3d170:	e9c4 8877 	strd	r8, r8, [r4, #476]	; 0x1dc
				conn->tx_ctrl_last = tx;
   3d174:	e7df      	b.n	3d136 <ull_conn_llcp+0xfb2>
		pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_IND;
   3d176:	230d      	movs	r3, #13
   3d178:	f888 3007 	strb.w	r3, [r8, #7]
		p->error_code =	conn->llcp.encryption.error_code;
   3d17c:	f894 3101 	ldrb.w	r3, [r4, #257]	; 0x101
   3d180:	f888 3008 	strb.w	r3, [r8, #8]
   3d184:	2702      	movs	r7, #2
   3d186:	e7af      	b.n	3d0e8 <ull_conn_llcp+0xf64>
			conn->tx_data = conn->tx_data->next;
   3d188:	6819      	ldr	r1, [r3, #0]
   3d18a:	f8c4 11e8 	str.w	r1, [r4, #488]	; 0x1e8
		if (!conn->tx_ctrl) {
   3d18e:	2a00      	cmp	r2, #0
   3d190:	f47f a8af 	bne.w	3c2f2 <ull_conn_llcp+0x16e>
			tx->next = conn->tx_head->next;
   3d194:	681b      	ldr	r3, [r3, #0]
   3d196:	6003      	str	r3, [r0, #0]
			conn->tx_head->next = tx;
   3d198:	f8d4 31dc 	ldr.w	r3, [r4, #476]	; 0x1dc
   3d19c:	6018      	str	r0, [r3, #0]
				conn->tx_ctrl = tx;
   3d19e:	f8c4 01e0 	str.w	r0, [r4, #480]	; 0x1e0
				conn->tx_ctrl_last = tx;
   3d1a2:	f7ff b8ad 	b.w	3c300 <ull_conn_llcp+0x17c>
		if (!conn->tx_ctrl) {
   3d1a6:	f8d4 01e0 	ldr.w	r0, [r4, #480]	; 0x1e0
   3d1aa:	2800      	cmp	r0, #0
   3d1ac:	f47f ac1c 	bne.w	3c9e8 <ull_conn_llcp+0x864>
			tx->next = conn->tx_head;
   3d1b0:	f841 3c13 	str.w	r3, [r1, #-19]
				conn->tx_ctrl = tx;
   3d1b4:	e9c4 2277 	strd	r2, r2, [r4, #476]	; 0x1dc
				conn->tx_ctrl_last = tx;
   3d1b8:	e41e      	b.n	3c9f8 <ull_conn_llcp+0x874>
		conn->tx_data_last = tx;
   3d1ba:	f8c4 81ec 	str.w	r8, [r4, #492]	; 0x1ec
   3d1be:	e7c0      	b.n	3d142 <ull_conn_llcp+0xfbe>
	    ((pdu_data_tx->llctrl.opcode !=
   3d1c0:	79da      	ldrb	r2, [r3, #7]
	if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   3d1c2:	2a03      	cmp	r2, #3
   3d1c4:	f43f af45 	beq.w	3d052 <ull_conn_llcp+0xece>
	      PDU_DATA_LLCTRL_TYPE_ENC_REQ) &&
   3d1c8:	2a0a      	cmp	r2, #10
   3d1ca:	f47f a9ac 	bne.w	3c526 <ull_conn_llcp+0x3a2>
   3d1ce:	e740      	b.n	3d052 <ull_conn_llcp+0xece>
   3d1d0:	20005384 	.word	0x20005384
   3d1d4:	ffff05f1 	.word	0xffff05f1
   3d1d8:	0005269c 	.word	0x0005269c
   3d1dc:	000521ac 	.word	0x000521ac
		conn->llcp_phy.ack = conn->llcp_phy.req;
   3d1e0:	f884 31d5 	strb.w	r3, [r4, #469]	; 0x1d5
		if (conn->llcp_phy.tx & PHY_2M) {
   3d1e4:	f3c2 0382 	ubfx	r3, r2, #2, #3
   3d1e8:	0712      	lsls	r2, r2, #28
   3d1ea:	f100 8188 	bmi.w	3d4fe <ull_conn_llcp+0x137a>
		} else if (conn->llcp_phy.tx & PHY_1M) {
   3d1ee:	f013 0201 	ands.w	r2, r3, #1
   3d1f2:	d104      	bne.n	3d1fe <ull_conn_llcp+0x107a>
		} else if (conn->llcp_phy.tx & PHY_CODED) {
   3d1f4:	2b03      	cmp	r3, #3
   3d1f6:	bf94      	ite	ls
   3d1f8:	2300      	movls	r3, #0
   3d1fa:	2301      	movhi	r3, #1
   3d1fc:	009a      	lsls	r2, r3, #2
			conn->llcp_phy.tx = PHY_2M;
   3d1fe:	f894 11d6 	ldrb.w	r1, [r4, #470]	; 0x1d6
   3d202:	f362 0184 	bfi	r1, r2, #2, #3
		if (conn->llcp_phy.rx & PHY_2M) {
   3d206:	064f      	lsls	r7, r1, #25
			conn->llcp_phy.tx = PHY_2M;
   3d208:	f884 11d6 	strb.w	r1, [r4, #470]	; 0x1d6
		if (conn->llcp_phy.rx & PHY_2M) {
   3d20c:	f3c1 1342 	ubfx	r3, r1, #5, #3
   3d210:	f100 8173 	bmi.w	3d4fa <ull_conn_llcp+0x1376>
		} else if (conn->llcp_phy.rx & PHY_1M) {
   3d214:	f013 0101 	ands.w	r1, r3, #1
   3d218:	d104      	bne.n	3d224 <ull_conn_llcp+0x10a0>
		} else if (conn->llcp_phy.rx & PHY_CODED) {
   3d21a:	2b03      	cmp	r3, #3
   3d21c:	bf94      	ite	ls
   3d21e:	2300      	movls	r3, #0
   3d220:	2301      	movhi	r3, #1
   3d222:	0099      	lsls	r1, r3, #2
		if (conn->llcp_phy.tx != conn->lll.phy_tx) {
   3d224:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
			conn->llcp_phy.rx = PHY_2M;
   3d228:	f894 71d6 	ldrb.w	r7, [r4, #470]	; 0x1d6
		if (conn->llcp_phy.tx != conn->lll.phy_tx) {
   3d22c:	f003 0307 	and.w	r3, r3, #7
			conn->llcp.phy_upd_ind.tx = 0U;
   3d230:	4293      	cmp	r3, r2
   3d232:	bf08      	it	eq
   3d234:	2200      	moveq	r2, #0
		conn->llcp_ack -= 2U;
   3d236:	3802      	subs	r0, #2
		conn->llcp.phy_upd_ind.cmd = conn->llcp_phy.cmd;
   3d238:	f894 31d7 	ldrb.w	r3, [r4, #471]	; 0x1d7
		conn->llcp_ack -= 2U;
   3d23c:	f884 00f1 	strb.w	r0, [r4, #241]	; 0xf1
		if (conn->llcp_phy.rx != conn->lll.phy_rx) {
   3d240:	f894 0061 	ldrb.w	r0, [r4, #97]	; 0x61
		conn->llcp.phy_upd_ind.cmd = conn->llcp_phy.cmd;
   3d244:	f3c3 0380 	ubfx	r3, r3, #2, #1
		conn->llcp.phy_upd_ind.initiate = 1U;
   3d248:	005b      	lsls	r3, r3, #1
		if (conn->llcp_phy.rx != conn->lll.phy_rx) {
   3d24a:	f000 0007 	and.w	r0, r0, #7
			conn->llcp_phy.rx = PHY_2M;
   3d24e:	f361 1747 	bfi	r7, r1, #5, #3
		conn->llcp.phy_upd_ind.initiate = 1U;
   3d252:	f043 0301 	orr.w	r3, r3, #1
			conn->llcp.phy_upd_ind.rx = 0U;
   3d256:	4288      	cmp	r0, r1
   3d258:	bf08      	it	eq
   3d25a:	2100      	moveq	r1, #0
		conn->llcp.phy_upd_ind.initiate = 1U;
   3d25c:	ea43 1341 	orr.w	r3, r3, r1, lsl #5
   3d260:	f894 10f4 	ldrb.w	r1, [r4, #244]	; 0xf4
			conn->llcp_phy.rx = PHY_2M;
   3d264:	f884 71d6 	strb.w	r7, [r4, #470]	; 0x1d6
		conn->llcp.phy_upd_ind.cmd = conn->llcp_phy.cmd;
   3d268:	f362 0184 	bfi	r1, r2, #2, #3
		conn->llcp.phy_upd_ind.initiate = 1U;
   3d26c:	f001 011c 	and.w	r1, r1, #28
   3d270:	430b      	orrs	r3, r1
		conn->llcp_type = LLCP_PHY_UPD;
   3d272:	2206      	movs	r2, #6
		conn->llcp.phy_upd_ind.initiate = 1U;
   3d274:	f884 30f4 	strb.w	r3, [r4, #244]	; 0xf4
		conn->llcp_type = LLCP_PHY_UPD;
   3d278:	f884 20f2 	strb.w	r2, [r4, #242]	; 0xf2
		} else if (conn->llcp_length.ack != conn->llcp_length.req) {
   3d27c:	f7fe bfb0 	b.w	3c1e0 <ull_conn_llcp+0x5c>
	if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   3d280:	791a      	ldrb	r2, [r3, #4]
   3d282:	f002 0203 	and.w	r2, r2, #3
   3d286:	2a03      	cmp	r2, #3
   3d288:	f000 812f 	beq.w	3d4ea <ull_conn_llcp+0x1366>
		conn->tx_ctrl = conn->tx_ctrl_last = conn->tx_head;
   3d28c:	e9c4 3378 	strd	r3, r3, [r4, #480]	; 0x1e0
   3d290:	f7ff b82f 	b.w	3c2f2 <ull_conn_llcp+0x16e>
			conn->tx_data = conn->tx_data->next;
   3d294:	6819      	ldr	r1, [r3, #0]
   3d296:	f8c4 11e8 	str.w	r1, [r4, #488]	; 0x1e8
		if (!conn->tx_ctrl) {
   3d29a:	2a00      	cmp	r2, #0
   3d29c:	f47f aacd 	bne.w	3c83a <ull_conn_llcp+0x6b6>
			tx->next = conn->tx_head->next;
   3d2a0:	681b      	ldr	r3, [r3, #0]
   3d2a2:	f8c8 3000 	str.w	r3, [r8]
			conn->tx_head->next = tx;
   3d2a6:	f8d4 31dc 	ldr.w	r3, [r4, #476]	; 0x1dc
   3d2aa:	f8c3 8000 	str.w	r8, [r3]
				conn->tx_ctrl = tx;
   3d2ae:	f8c4 81e0 	str.w	r8, [r4, #480]	; 0x1e0
				conn->tx_ctrl_last = tx;
   3d2b2:	f7ff bacb 	b.w	3c84c <ull_conn_llcp+0x6c8>
			conn->tx_data = conn->tx_data->next;
   3d2b6:	6819      	ldr	r1, [r3, #0]
   3d2b8:	f8c4 11e8 	str.w	r1, [r4, #488]	; 0x1e8
		if (!conn->tx_ctrl) {
   3d2bc:	2a00      	cmp	r2, #0
   3d2be:	f47f acba 	bne.w	3cc36 <ull_conn_llcp+0xab2>
			tx->next = conn->tx_head->next;
   3d2c2:	681b      	ldr	r3, [r3, #0]
   3d2c4:	6033      	str	r3, [r6, #0]
			conn->tx_head->next = tx;
   3d2c6:	f8d4 31dc 	ldr.w	r3, [r4, #476]	; 0x1dc
   3d2ca:	601e      	str	r6, [r3, #0]
				conn->tx_ctrl = tx;
   3d2cc:	f8c4 61e0 	str.w	r6, [r4, #480]	; 0x1e0
				conn->tx_ctrl_last = tx;
   3d2d0:	e4b8      	b.n	3cc44 <ull_conn_llcp+0xac0>
			conn->tx_data = conn->tx_data->next;
   3d2d2:	6819      	ldr	r1, [r3, #0]
   3d2d4:	f8c4 11e8 	str.w	r1, [r4, #488]	; 0x1e8
		if (!conn->tx_ctrl) {
   3d2d8:	2a00      	cmp	r2, #0
   3d2da:	f47f ad0a 	bne.w	3ccf2 <ull_conn_llcp+0xb6e>
			tx->next = conn->tx_head->next;
   3d2de:	681b      	ldr	r3, [r3, #0]
   3d2e0:	f8c8 3000 	str.w	r3, [r8]
			conn->tx_head->next = tx;
   3d2e4:	f8d4 31dc 	ldr.w	r3, [r4, #476]	; 0x1dc
   3d2e8:	f8c3 8000 	str.w	r8, [r3]
				conn->tx_ctrl = tx;
   3d2ec:	f8c4 81e0 	str.w	r8, [r4, #480]	; 0x1e0
				conn->tx_ctrl_last = tx;
   3d2f0:	e508      	b.n	3cd04 <ull_conn_llcp+0xb80>
			conn->tx_data = conn->tx_data->next;
   3d2f2:	6819      	ldr	r1, [r3, #0]
   3d2f4:	f8c4 11e8 	str.w	r1, [r4, #488]	; 0x1e8
		if (!conn->tx_ctrl) {
   3d2f8:	2a00      	cmp	r2, #0
   3d2fa:	f47f a85e 	bne.w	3c3ba <ull_conn_llcp+0x236>
			tx->next = conn->tx_head->next;
   3d2fe:	681b      	ldr	r3, [r3, #0]
   3d300:	603b      	str	r3, [r7, #0]
			conn->tx_head->next = tx;
   3d302:	f8d4 31dc 	ldr.w	r3, [r4, #476]	; 0x1dc
   3d306:	601f      	str	r7, [r3, #0]
				conn->tx_ctrl = tx;
   3d308:	f8c4 71e0 	str.w	r7, [r4, #480]	; 0x1e0
				conn->tx_ctrl_last = tx;
   3d30c:	f7ff b85c 	b.w	3c3c8 <ull_conn_llcp+0x244>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
   3d310:	48c2      	ldr	r0, [pc, #776]	; (3d61c <ull_conn_llcp+0x1498>)
   3d312:	f7f7 f8d1 	bl	344b8 <mem_acquire>
		if (!tx) {
   3d316:	2800      	cmp	r0, #0
   3d318:	f43f a976 	beq.w	3c608 <ull_conn_llcp+0x484>
		pdu->ll_id = PDU_DATA_LLID_CTRL;
   3d31c:	7902      	ldrb	r2, [r0, #4]
   3d31e:	f042 0203 	orr.w	r2, r2, #3
   3d322:	7102      	strb	r2, [r0, #4]
		pdu->len = offsetof(struct pdu_data_llctrl, reject_ext_ind) +
   3d324:	2203      	movs	r2, #3
   3d326:	7142      	strb	r2, [r0, #5]
		pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND;
   3d328:	f640 7211 	movw	r2, #3857	; 0xf11
   3d32c:	f8a0 2007 	strh.w	r2, [r0, #7]
		rej->error_code = conn->llcp_conn_param.status;
   3d330:	f894 2197 	ldrb.w	r2, [r4, #407]	; 0x197
   3d334:	7242      	strb	r2, [r0, #9]
	    conn->tx_head &&
   3d336:	f8d4 21dc 	ldr.w	r2, [r4, #476]	; 0x1dc
	if (
   3d33a:	2a00      	cmp	r2, #0
   3d33c:	f000 80be 	beq.w	3d4bc <ull_conn_llcp+0x1338>
	    !conn->llcp_cu.pause_tx &&
   3d340:	f894 111a 	ldrb.w	r1, [r4, #282]	; 0x11a
	    conn->tx_head &&
   3d344:	06cf      	lsls	r7, r1, #27
   3d346:	f100 80b9 	bmi.w	3d4bc <ull_conn_llcp+0x1338>
	    !conn->llcp_enc.pause_tx &&
   3d34a:	f894 1176 	ldrb.w	r1, [r4, #374]	; 0x176
	    !conn->llcp_cu.pause_tx &&
   3d34e:	0789      	lsls	r1, r1, #30
   3d350:	f100 80b4 	bmi.w	3d4bc <ull_conn_llcp+0x1338>
	    !conn->llcp_phy.pause_tx &&
   3d354:	f894 11d7 	ldrb.w	r1, [r4, #471]	; 0x1d7
   3d358:	07cb      	lsls	r3, r1, #31
   3d35a:	f100 80af 	bmi.w	3d4bc <ull_conn_llcp+0x1338>
		if (conn->tx_head == conn->tx_data) {
   3d35e:	f8d4 31e8 	ldr.w	r3, [r4, #488]	; 0x1e8
		if (!conn->tx_ctrl) {
   3d362:	f8d4 11e0 	ldr.w	r1, [r4, #480]	; 0x1e0
		if (conn->tx_head == conn->tx_data) {
   3d366:	429a      	cmp	r2, r3
   3d368:	f000 81b7 	beq.w	3d6da <ull_conn_llcp+0x1556>
		} else if (!conn->tx_ctrl) {
   3d36c:	2900      	cmp	r1, #0
   3d36e:	f000 813a 	beq.w	3d5e6 <ull_conn_llcp+0x1462>
	tx->next = conn->tx_ctrl_last->next;
   3d372:	f8d4 21e4 	ldr.w	r2, [r4, #484]	; 0x1e4
   3d376:	6812      	ldr	r2, [r2, #0]
   3d378:	6002      	str	r2, [r0, #0]
	conn->tx_ctrl_last->next = tx;
   3d37a:	f8d4 21e4 	ldr.w	r2, [r4, #484]	; 0x1e4
   3d37e:	6010      	str	r0, [r2, #0]
	conn->tx_ctrl_last = tx;
   3d380:	f8c4 01e4 	str.w	r0, [r4, #484]	; 0x1e4
	if (!tx->next) {
   3d384:	6802      	ldr	r2, [r0, #0]
   3d386:	2a00      	cmp	r2, #0
   3d388:	f000 812a 	beq.w	3d5e0 <ull_conn_llcp+0x145c>
	if (conn->llcp_conn_param.cache.timeout) {
   3d38c:	f8b4 31a6 	ldrh.w	r3, [r4, #422]	; 0x1a6
   3d390:	2b00      	cmp	r3, #0
   3d392:	f000 8086 	beq.w	3d4a2 <ull_conn_llcp+0x131e>
		conn->llcp_conn_param.timeout =
   3d396:	f8a4 319e 	strh.w	r3, [r4, #414]	; 0x19e
		conn->llcp_conn_param.state = LLCP_CPR_STATE_REQ;
   3d39a:	f8b4 3196 	ldrh.w	r3, [r4, #406]	; 0x196
   3d39e:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   3d3a2:	f043 0310 	orr.w	r3, r3, #16
   3d3a6:	f8a4 3196 	strh.w	r3, [r4, #406]	; 0x196
		conn->llcp_conn_param.cache.timeout = 0U;
   3d3aa:	2300      	movs	r3, #0
   3d3ac:	f8a4 31a6 	strh.w	r3, [r4, #422]	; 0x1a6
		conn->llcp_conn_param.interval_min =
   3d3b0:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
   3d3b4:	f8c4 3198 	str.w	r3, [r4, #408]	; 0x198
		conn->llcp_conn_param.latency =
   3d3b8:	f8b4 31a4 	ldrh.w	r3, [r4, #420]	; 0x1a4
   3d3bc:	f8a4 319c 	strh.w	r3, [r4, #412]	; 0x19c
	conn_upd_curr = NULL;
   3d3c0:	2300      	movs	r3, #0
   3d3c2:	f8c8 3000 	str.w	r3, [r8]
   3d3c6:	f7ff b91f 	b.w	3c608 <ull_conn_llcp+0x484>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
   3d3ca:	4894      	ldr	r0, [pc, #592]	; (3d61c <ull_conn_llcp+0x1498>)
   3d3cc:	f7f7 f874 	bl	344b8 <mem_acquire>
	if (!tx) {
   3d3d0:	2800      	cmp	r0, #0
   3d3d2:	f43f a919 	beq.w	3c608 <ull_conn_llcp+0x484>
	pdu->ll_id = PDU_DATA_LLID_CTRL;
   3d3d6:	7902      	ldrb	r2, [r0, #4]
   3d3d8:	f042 0203 	orr.w	r2, r2, #3
   3d3dc:	7102      	strb	r2, [r0, #4]
	pdu->len = offsetof(struct pdu_data_llctrl, conn_param_rsp) +
   3d3de:	2218      	movs	r2, #24
   3d3e0:	7142      	strb	r2, [r0, #5]
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_CONN_PARAM_RSP;
   3d3e2:	2210      	movs	r2, #16
   3d3e4:	71c2      	strb	r2, [r0, #7]
		sys_cpu_to_le16(conn->llcp_conn_param.interval_min);
   3d3e6:	f8b4 2198 	ldrh.w	r2, [r4, #408]	; 0x198
	rsp->interval_min =
   3d3ea:	8102      	strh	r2, [r0, #8]
		sys_cpu_to_le16(conn->llcp_conn_param.interval_max);
   3d3ec:	f8b4 219a 	ldrh.w	r2, [r4, #410]	; 0x19a
	rsp->interval_max =
   3d3f0:	8142      	strh	r2, [r0, #10]
		sys_cpu_to_le16(conn->llcp_conn_param.latency);
   3d3f2:	f8b4 219c 	ldrh.w	r2, [r4, #412]	; 0x19c
	rsp->latency =
   3d3f6:	8182      	strh	r2, [r0, #12]
		sys_cpu_to_le16(conn->llcp_conn_param.timeout);
   3d3f8:	f8b4 219e 	ldrh.w	r2, [r4, #414]	; 0x19e
	rsp->timeout =
   3d3fc:	81c2      	strh	r2, [r0, #14]
		conn->llcp_conn_param.preferred_periodicity;
   3d3fe:	f894 21a8 	ldrb.w	r2, [r4, #424]	; 0x1a8
	rsp->preferred_periodicity =
   3d402:	7402      	strb	r2, [r0, #16]
		sys_cpu_to_le16(conn->llcp_conn_param.reference_conn_event_count);
   3d404:	f8b4 21aa 	ldrh.w	r2, [r4, #426]	; 0x1aa
	rsp->reference_conn_event_count =
   3d408:	f8a0 2011 	strh.w	r2, [r0, #17]
	rsp->offset0 = sys_cpu_to_le16(conn->llcp_conn_param.offset0);
   3d40c:	f8b4 21ac 	ldrh.w	r2, [r4, #428]	; 0x1ac
   3d410:	f8a0 2013 	strh.w	r2, [r0, #19]
	rsp->offset1 = sys_cpu_to_le16(conn->llcp_conn_param.offset1);
   3d414:	f8b4 21ae 	ldrh.w	r2, [r4, #430]	; 0x1ae
   3d418:	f8a0 2015 	strh.w	r2, [r0, #21]
	rsp->offset2 = sys_cpu_to_le16(conn->llcp_conn_param.offset2);
   3d41c:	f8b4 21b0 	ldrh.w	r2, [r4, #432]	; 0x1b0
   3d420:	f8a0 2017 	strh.w	r2, [r0, #23]
	rsp->offset3 = sys_cpu_to_le16(conn->llcp_conn_param.offset3);
   3d424:	f8b4 21b2 	ldrh.w	r2, [r4, #434]	; 0x1b2
   3d428:	f8a0 2019 	strh.w	r2, [r0, #25]
	rsp->offset4 = sys_cpu_to_le16(conn->llcp_conn_param.offset4);
   3d42c:	f8b4 21b4 	ldrh.w	r2, [r4, #436]	; 0x1b4
   3d430:	f8a0 201b 	strh.w	r2, [r0, #27]
	rsp->offset5 = sys_cpu_to_le16(conn->llcp_conn_param.offset5);
   3d434:	f8b4 21b6 	ldrh.w	r2, [r4, #438]	; 0x1b6
   3d438:	f8a0 201d 	strh.w	r2, [r0, #29]
	    conn->tx_head &&
   3d43c:	f8d4 21dc 	ldr.w	r2, [r4, #476]	; 0x1dc
	if (
   3d440:	b3a2      	cbz	r2, 3d4ac <ull_conn_llcp+0x1328>
	    !conn->llcp_cu.pause_tx &&
   3d442:	f894 111a 	ldrb.w	r1, [r4, #282]	; 0x11a
	    conn->tx_head &&
   3d446:	06cf      	lsls	r7, r1, #27
   3d448:	d430      	bmi.n	3d4ac <ull_conn_llcp+0x1328>
	    !conn->llcp_enc.pause_tx &&
   3d44a:	f894 1176 	ldrb.w	r1, [r4, #374]	; 0x176
	    !conn->llcp_cu.pause_tx &&
   3d44e:	0789      	lsls	r1, r1, #30
   3d450:	d42c      	bmi.n	3d4ac <ull_conn_llcp+0x1328>
	    !conn->llcp_phy.pause_tx &&
   3d452:	f894 11d7 	ldrb.w	r1, [r4, #471]	; 0x1d7
   3d456:	07cb      	lsls	r3, r1, #31
   3d458:	d428      	bmi.n	3d4ac <ull_conn_llcp+0x1328>
		if (conn->tx_head == conn->tx_data) {
   3d45a:	f8d4 31e8 	ldr.w	r3, [r4, #488]	; 0x1e8
		if (!conn->tx_ctrl) {
   3d45e:	f8d4 11e0 	ldr.w	r1, [r4, #480]	; 0x1e0
		if (conn->tx_head == conn->tx_data) {
   3d462:	429a      	cmp	r2, r3
   3d464:	f000 80a3 	beq.w	3d5ae <ull_conn_llcp+0x142a>
		} else if (!conn->tx_ctrl) {
   3d468:	2900      	cmp	r1, #0
   3d46a:	f000 80b1 	beq.w	3d5d0 <ull_conn_llcp+0x144c>
	tx->next = conn->tx_ctrl_last->next;
   3d46e:	f8d4 21e4 	ldr.w	r2, [r4, #484]	; 0x1e4
   3d472:	6812      	ldr	r2, [r2, #0]
   3d474:	6002      	str	r2, [r0, #0]
	conn->tx_ctrl_last->next = tx;
   3d476:	f8d4 21e4 	ldr.w	r2, [r4, #484]	; 0x1e4
   3d47a:	6010      	str	r0, [r2, #0]
	conn->tx_ctrl_last = tx;
   3d47c:	f8c4 01e4 	str.w	r0, [r4, #484]	; 0x1e4
	if (!tx->next) {
   3d480:	6802      	ldr	r2, [r0, #0]
   3d482:	2a00      	cmp	r2, #0
   3d484:	f000 80a1 	beq.w	3d5ca <ull_conn_llcp+0x1446>
	conn->llcp_conn_param.state = LLCP_CPR_STATE_UPD_WAIT;
   3d488:	f894 2196 	ldrb.w	r2, [r4, #406]	; 0x196
	if (((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) {
   3d48c:	f894 00f1 	ldrb.w	r0, [r4, #241]	; 0xf1
	conn->llcp_conn_param.state = LLCP_CPR_STATE_UPD_WAIT;
   3d490:	2305      	movs	r3, #5
   3d492:	f363 0203 	bfi	r2, r3, #0, #4
   3d496:	f884 2196 	strb.w	r2, [r4, #406]	; 0x196
	if (((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) {
   3d49a:	f894 30f0 	ldrb.w	r3, [r4, #240]	; 0xf0
   3d49e:	f7fe be7c 	b.w	3c19a <ull_conn_llcp+0x16>
		conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
   3d4a2:	f894 3194 	ldrb.w	r3, [r4, #404]	; 0x194
   3d4a6:	f884 3195 	strb.w	r3, [r4, #405]	; 0x195
   3d4aa:	e789      	b.n	3d3c0 <ull_conn_llcp+0x123c>
		if (!conn->tx_ctrl) {
   3d4ac:	f8d4 11e0 	ldr.w	r1, [r4, #480]	; 0x1e0
   3d4b0:	2900      	cmp	r1, #0
   3d4b2:	d1dc      	bne.n	3d46e <ull_conn_llcp+0x12ea>
			tx->next = conn->tx_head;
   3d4b4:	6002      	str	r2, [r0, #0]
				conn->tx_ctrl = tx;
   3d4b6:	e9c4 0077 	strd	r0, r0, [r4, #476]	; 0x1dc
				conn->tx_ctrl_last = tx;
   3d4ba:	e7df      	b.n	3d47c <ull_conn_llcp+0x12f8>
		if (!conn->tx_ctrl) {
   3d4bc:	f8d4 11e0 	ldr.w	r1, [r4, #480]	; 0x1e0
   3d4c0:	2900      	cmp	r1, #0
   3d4c2:	f47f af56 	bne.w	3d372 <ull_conn_llcp+0x11ee>
			tx->next = conn->tx_head;
   3d4c6:	6002      	str	r2, [r0, #0]
				conn->tx_ctrl = tx;
   3d4c8:	e9c4 0077 	strd	r0, r0, [r4, #476]	; 0x1dc
				conn->tx_ctrl_last = tx;
   3d4cc:	e758      	b.n	3d380 <ull_conn_llcp+0x11fc>
			conn->llcp_cu.interval = interval_max;
   3d4ce:	f8a4 211c 	strh.w	r2, [r4, #284]	; 0x11c
   3d4d2:	f7ff baf8 	b.w	3cac6 <ull_conn_llcp+0x942>
	if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   3d4d6:	791a      	ldrb	r2, [r3, #4]
   3d4d8:	f002 0203 	and.w	r2, r2, #3
   3d4dc:	2a03      	cmp	r2, #3
   3d4de:	f000 80d6 	beq.w	3d68e <ull_conn_llcp+0x150a>
		conn->tx_ctrl = conn->tx_ctrl_last = conn->tx_head;
   3d4e2:	e9c4 3378 	strd	r3, r3, [r4, #480]	; 0x1e0
   3d4e6:	f7ff b9a8 	b.w	3c83a <ull_conn_llcp+0x6b6>
	    ((pdu_data_tx->llctrl.opcode !=
   3d4ea:	79da      	ldrb	r2, [r3, #7]
	if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   3d4ec:	2a03      	cmp	r2, #3
   3d4ee:	f43f ae51 	beq.w	3d194 <ull_conn_llcp+0x1010>
	      PDU_DATA_LLCTRL_TYPE_ENC_REQ) &&
   3d4f2:	2a0a      	cmp	r2, #10
   3d4f4:	f47f aeca 	bne.w	3d28c <ull_conn_llcp+0x1108>
   3d4f8:	e64c      	b.n	3d194 <ull_conn_llcp+0x1010>
   3d4fa:	2102      	movs	r1, #2
   3d4fc:	e692      	b.n	3d224 <ull_conn_llcp+0x10a0>
   3d4fe:	2202      	movs	r2, #2
   3d500:	e67d      	b.n	3d1fe <ull_conn_llcp+0x107a>
	if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   3d502:	791a      	ldrb	r2, [r3, #4]
   3d504:	f002 0203 	and.w	r2, r2, #3
   3d508:	2a03      	cmp	r2, #3
   3d50a:	f000 8099 	beq.w	3d640 <ull_conn_llcp+0x14bc>
		conn->tx_ctrl = conn->tx_ctrl_last = conn->tx_head;
   3d50e:	e9c4 3378 	strd	r3, r3, [r4, #480]	; 0x1e0
   3d512:	f7ff bb90 	b.w	3cc36 <ull_conn_llcp+0xab2>
			conn->tx_data = conn->tx_data->next;
   3d516:	6819      	ldr	r1, [r3, #0]
   3d518:	f8c4 11e8 	str.w	r1, [r4, #488]	; 0x1e8
		if (!conn->tx_ctrl) {
   3d51c:	2a00      	cmp	r2, #0
   3d51e:	f47f ad4a 	bne.w	3cfb6 <ull_conn_llcp+0xe32>
			tx->next = conn->tx_head->next;
   3d522:	681b      	ldr	r3, [r3, #0]
   3d524:	6003      	str	r3, [r0, #0]
			conn->tx_head->next = tx;
   3d526:	f8d4 31dc 	ldr.w	r3, [r4, #476]	; 0x1dc
   3d52a:	6018      	str	r0, [r3, #0]
				conn->tx_ctrl = tx;
   3d52c:	f8c4 01e0 	str.w	r0, [r4, #480]	; 0x1e0
				conn->tx_ctrl_last = tx;
   3d530:	e548      	b.n	3cfc4 <ull_conn_llcp+0xe40>
			conn->tx_data = conn->tx_data->next;
   3d532:	6819      	ldr	r1, [r3, #0]
   3d534:	f8c4 11e8 	str.w	r1, [r4, #488]	; 0x1e8
		if (!conn->tx_ctrl) {
   3d538:	2a00      	cmp	r2, #0
   3d53a:	f47f adf3 	bne.w	3d124 <ull_conn_llcp+0xfa0>
			tx->next = conn->tx_head->next;
   3d53e:	681b      	ldr	r3, [r3, #0]
   3d540:	f8c8 3000 	str.w	r3, [r8]
			conn->tx_head->next = tx;
   3d544:	f8d4 31dc 	ldr.w	r3, [r4, #476]	; 0x1dc
   3d548:	f8c3 8000 	str.w	r8, [r3]
				conn->tx_ctrl = tx;
   3d54c:	f8c4 81e0 	str.w	r8, [r4, #480]	; 0x1e0
				conn->tx_ctrl_last = tx;
   3d550:	e5f1      	b.n	3d136 <ull_conn_llcp+0xfb2>
			conn->tx_data = conn->tx_data->next;
   3d552:	6819      	ldr	r1, [r3, #0]
   3d554:	f8c4 11e8 	str.w	r1, [r4, #488]	; 0x1e8
		if (!conn->tx_ctrl) {
   3d558:	2a00      	cmp	r2, #0
   3d55a:	f47f a913 	bne.w	3c784 <ull_conn_llcp+0x600>
			tx->next = conn->tx_head->next;
   3d55e:	681b      	ldr	r3, [r3, #0]
   3d560:	f8c8 3000 	str.w	r3, [r8]
			conn->tx_head->next = tx;
   3d564:	f8d4 31dc 	ldr.w	r3, [r4, #476]	; 0x1dc
   3d568:	f8c3 8000 	str.w	r8, [r3]
				conn->tx_ctrl = tx;
   3d56c:	f8c4 81e0 	str.w	r8, [r4, #480]	; 0x1e0
				conn->tx_ctrl_last = tx;
   3d570:	f7ff b911 	b.w	3c796 <ull_conn_llcp+0x612>
	if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   3d574:	791a      	ldrb	r2, [r3, #4]
   3d576:	f002 0203 	and.w	r2, r2, #3
   3d57a:	2a03      	cmp	r2, #3
   3d57c:	f000 8095 	beq.w	3d6aa <ull_conn_llcp+0x1526>
		conn->tx_ctrl = conn->tx_ctrl_last = conn->tx_head;
   3d580:	e9c4 3378 	strd	r3, r3, [r4, #480]	; 0x1e0
   3d584:	f7ff bbb5 	b.w	3ccf2 <ull_conn_llcp+0xb6e>
	if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   3d588:	791a      	ldrb	r2, [r3, #4]
   3d58a:	f002 0203 	and.w	r2, r2, #3
   3d58e:	2a03      	cmp	r2, #3
   3d590:	d066      	beq.n	3d660 <ull_conn_llcp+0x14dc>
		conn->tx_ctrl = conn->tx_ctrl_last = conn->tx_head;
   3d592:	e9c4 3378 	strd	r3, r3, [r4, #480]	; 0x1e0
   3d596:	f7fe bf10 	b.w	3c3ba <ull_conn_llcp+0x236>
	if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   3d59a:	7913      	ldrb	r3, [r2, #4]
   3d59c:	f003 0303 	and.w	r3, r3, #3
   3d5a0:	2b03      	cmp	r3, #3
   3d5a2:	f000 80a0 	beq.w	3d6e6 <ull_conn_llcp+0x1562>
		conn->tx_ctrl = conn->tx_ctrl_last = conn->tx_head;
   3d5a6:	e9c4 2278 	strd	r2, r2, [r4, #480]	; 0x1e0
   3d5aa:	f7ff b8eb 	b.w	3c784 <ull_conn_llcp+0x600>
			conn->tx_data = conn->tx_data->next;
   3d5ae:	6813      	ldr	r3, [r2, #0]
   3d5b0:	f8c4 31e8 	str.w	r3, [r4, #488]	; 0x1e8
		if (!conn->tx_ctrl) {
   3d5b4:	2900      	cmp	r1, #0
   3d5b6:	f47f af5a 	bne.w	3d46e <ull_conn_llcp+0x12ea>
			tx->next = conn->tx_head->next;
   3d5ba:	6812      	ldr	r2, [r2, #0]
   3d5bc:	6002      	str	r2, [r0, #0]
			conn->tx_head->next = tx;
   3d5be:	f8d4 21dc 	ldr.w	r2, [r4, #476]	; 0x1dc
   3d5c2:	6010      	str	r0, [r2, #0]
				conn->tx_ctrl = tx;
   3d5c4:	f8c4 01e0 	str.w	r0, [r4, #480]	; 0x1e0
				conn->tx_ctrl_last = tx;
   3d5c8:	e758      	b.n	3d47c <ull_conn_llcp+0x12f8>
		conn->tx_data_last = tx;
   3d5ca:	f8c4 01ec 	str.w	r0, [r4, #492]	; 0x1ec
   3d5ce:	e75b      	b.n	3d488 <ull_conn_llcp+0x1304>
	if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   3d5d0:	7911      	ldrb	r1, [r2, #4]
   3d5d2:	f001 0103 	and.w	r1, r1, #3
   3d5d6:	2903      	cmp	r1, #3
   3d5d8:	d00d      	beq.n	3d5f6 <ull_conn_llcp+0x1472>
		conn->tx_ctrl = conn->tx_ctrl_last = conn->tx_head;
   3d5da:	e9c4 2278 	strd	r2, r2, [r4, #480]	; 0x1e0
   3d5de:	e746      	b.n	3d46e <ull_conn_llcp+0x12ea>
		conn->tx_data_last = tx;
   3d5e0:	f8c4 01ec 	str.w	r0, [r4, #492]	; 0x1ec
   3d5e4:	e6d2      	b.n	3d38c <ull_conn_llcp+0x1208>
	if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   3d5e6:	7911      	ldrb	r1, [r2, #4]
   3d5e8:	f001 0103 	and.w	r1, r1, #3
   3d5ec:	2903      	cmp	r1, #3
   3d5ee:	d008      	beq.n	3d602 <ull_conn_llcp+0x147e>
		conn->tx_ctrl = conn->tx_ctrl_last = conn->tx_head;
   3d5f0:	e9c4 2278 	strd	r2, r2, [r4, #480]	; 0x1e0
   3d5f4:	e6bd      	b.n	3d372 <ull_conn_llcp+0x11ee>
	    ((pdu_data_tx->llctrl.opcode !=
   3d5f6:	79d1      	ldrb	r1, [r2, #7]
	if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   3d5f8:	2903      	cmp	r1, #3
   3d5fa:	d0de      	beq.n	3d5ba <ull_conn_llcp+0x1436>
	      PDU_DATA_LLCTRL_TYPE_ENC_REQ) &&
   3d5fc:	290a      	cmp	r1, #10
   3d5fe:	d1ec      	bne.n	3d5da <ull_conn_llcp+0x1456>
   3d600:	e7db      	b.n	3d5ba <ull_conn_llcp+0x1436>
	    ((pdu_data_tx->llctrl.opcode !=
   3d602:	79d1      	ldrb	r1, [r2, #7]
	if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   3d604:	2903      	cmp	r1, #3
   3d606:	d001      	beq.n	3d60c <ull_conn_llcp+0x1488>
	      PDU_DATA_LLCTRL_TYPE_ENC_REQ) &&
   3d608:	290a      	cmp	r1, #10
   3d60a:	d1f1      	bne.n	3d5f0 <ull_conn_llcp+0x146c>
			tx->next = conn->tx_head->next;
   3d60c:	6812      	ldr	r2, [r2, #0]
   3d60e:	6002      	str	r2, [r0, #0]
			conn->tx_head->next = tx;
   3d610:	f8d4 21dc 	ldr.w	r2, [r4, #476]	; 0x1dc
   3d614:	6010      	str	r0, [r2, #0]
				conn->tx_ctrl = tx;
   3d616:	f8c4 01e0 	str.w	r0, [r4, #480]	; 0x1e0
				conn->tx_ctrl_last = tx;
   3d61a:	e6b1      	b.n	3d380 <ull_conn_llcp+0x11fc>
   3d61c:	20005384 	.word	0x20005384
			conn->tx_data = conn->tx_data->next;
   3d620:	681f      	ldr	r7, [r3, #0]
   3d622:	f8c4 71e8 	str.w	r7, [r4, #488]	; 0x1e8
		if (!conn->tx_ctrl) {
   3d626:	2800      	cmp	r0, #0
   3d628:	f47f a9de 	bne.w	3c9e8 <ull_conn_llcp+0x864>
			tx->next = conn->tx_head->next;
   3d62c:	681b      	ldr	r3, [r3, #0]
   3d62e:	f841 3c13 	str.w	r3, [r1, #-19]
			conn->tx_head->next = tx;
   3d632:	f8d4 31dc 	ldr.w	r3, [r4, #476]	; 0x1dc
   3d636:	601a      	str	r2, [r3, #0]
				conn->tx_ctrl = tx;
   3d638:	f8c4 21e0 	str.w	r2, [r4, #480]	; 0x1e0
				conn->tx_ctrl_last = tx;
   3d63c:	f7ff b9dc 	b.w	3c9f8 <ull_conn_llcp+0x874>
	    ((pdu_data_tx->llctrl.opcode !=
   3d640:	79da      	ldrb	r2, [r3, #7]
	if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   3d642:	2a03      	cmp	r2, #3
   3d644:	f43f ae3d 	beq.w	3d2c2 <ull_conn_llcp+0x113e>
	      PDU_DATA_LLCTRL_TYPE_ENC_REQ) &&
   3d648:	2a0a      	cmp	r2, #10
   3d64a:	f47f af60 	bne.w	3d50e <ull_conn_llcp+0x138a>
   3d64e:	e638      	b.n	3d2c2 <ull_conn_llcp+0x113e>
	if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   3d650:	791a      	ldrb	r2, [r3, #4]
   3d652:	f002 0203 	and.w	r2, r2, #3
   3d656:	2a03      	cmp	r2, #3
   3d658:	d009      	beq.n	3d66e <ull_conn_llcp+0x14ea>
		conn->tx_ctrl = conn->tx_ctrl_last = conn->tx_head;
   3d65a:	e9c4 3378 	strd	r3, r3, [r4, #480]	; 0x1e0
   3d65e:	e4aa      	b.n	3cfb6 <ull_conn_llcp+0xe32>
	    ((pdu_data_tx->llctrl.opcode !=
   3d660:	79da      	ldrb	r2, [r3, #7]
	if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   3d662:	2a03      	cmp	r2, #3
   3d664:	f43f ae4b 	beq.w	3d2fe <ull_conn_llcp+0x117a>
	      PDU_DATA_LLCTRL_TYPE_ENC_REQ) &&
   3d668:	2a0a      	cmp	r2, #10
   3d66a:	d192      	bne.n	3d592 <ull_conn_llcp+0x140e>
   3d66c:	e647      	b.n	3d2fe <ull_conn_llcp+0x117a>
	    ((pdu_data_tx->llctrl.opcode !=
   3d66e:	79da      	ldrb	r2, [r3, #7]
	if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   3d670:	2a03      	cmp	r2, #3
   3d672:	f43f af56 	beq.w	3d522 <ull_conn_llcp+0x139e>
	      PDU_DATA_LLCTRL_TYPE_ENC_REQ) &&
   3d676:	2a0a      	cmp	r2, #10
   3d678:	d1ef      	bne.n	3d65a <ull_conn_llcp+0x14d6>
   3d67a:	e752      	b.n	3d522 <ull_conn_llcp+0x139e>
	if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   3d67c:	7918      	ldrb	r0, [r3, #4]
   3d67e:	f000 0003 	and.w	r0, r0, #3
   3d682:	2803      	cmp	r0, #3
   3d684:	d00b      	beq.n	3d69e <ull_conn_llcp+0x151a>
		conn->tx_ctrl = conn->tx_ctrl_last = conn->tx_head;
   3d686:	e9c4 3378 	strd	r3, r3, [r4, #480]	; 0x1e0
   3d68a:	f7ff b9ad 	b.w	3c9e8 <ull_conn_llcp+0x864>
	    ((pdu_data_tx->llctrl.opcode !=
   3d68e:	79da      	ldrb	r2, [r3, #7]
	if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   3d690:	2a03      	cmp	r2, #3
   3d692:	f43f ae05 	beq.w	3d2a0 <ull_conn_llcp+0x111c>
	      PDU_DATA_LLCTRL_TYPE_ENC_REQ) &&
   3d696:	2a0a      	cmp	r2, #10
   3d698:	f47f af23 	bne.w	3d4e2 <ull_conn_llcp+0x135e>
   3d69c:	e600      	b.n	3d2a0 <ull_conn_llcp+0x111c>
	    ((pdu_data_tx->llctrl.opcode !=
   3d69e:	79d8      	ldrb	r0, [r3, #7]
	if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   3d6a0:	2803      	cmp	r0, #3
   3d6a2:	d0c3      	beq.n	3d62c <ull_conn_llcp+0x14a8>
	      PDU_DATA_LLCTRL_TYPE_ENC_REQ) &&
   3d6a4:	280a      	cmp	r0, #10
   3d6a6:	d1ee      	bne.n	3d686 <ull_conn_llcp+0x1502>
   3d6a8:	e7c0      	b.n	3d62c <ull_conn_llcp+0x14a8>
	    ((pdu_data_tx->llctrl.opcode !=
   3d6aa:	79da      	ldrb	r2, [r3, #7]
	if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   3d6ac:	2a03      	cmp	r2, #3
   3d6ae:	f43f ae16 	beq.w	3d2de <ull_conn_llcp+0x115a>
	      PDU_DATA_LLCTRL_TYPE_ENC_REQ) &&
   3d6b2:	2a0a      	cmp	r2, #10
   3d6b4:	f47f af64 	bne.w	3d580 <ull_conn_llcp+0x13fc>
   3d6b8:	e611      	b.n	3d2de <ull_conn_llcp+0x115a>
	    ((pdu_data_tx->llctrl.opcode !=
   3d6ba:	79da      	ldrb	r2, [r3, #7]
	if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   3d6bc:	2a03      	cmp	r2, #3
   3d6be:	f43f af4e 	beq.w	3d55e <ull_conn_llcp+0x13da>
	      PDU_DATA_LLCTRL_TYPE_ENC_REQ) &&
   3d6c2:	2a0a      	cmp	r2, #10
   3d6c4:	f47f acbb 	bne.w	3d03e <ull_conn_llcp+0xeba>
   3d6c8:	e749      	b.n	3d55e <ull_conn_llcp+0x13da>
	if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   3d6ca:	791a      	ldrb	r2, [r3, #4]
   3d6cc:	f002 0203 	and.w	r2, r2, #3
   3d6d0:	2a03      	cmp	r2, #3
   3d6d2:	d011      	beq.n	3d6f8 <ull_conn_llcp+0x1574>
		conn->tx_ctrl = conn->tx_ctrl_last = conn->tx_head;
   3d6d4:	e9c4 3378 	strd	r3, r3, [r4, #480]	; 0x1e0
   3d6d8:	e524      	b.n	3d124 <ull_conn_llcp+0xfa0>
			conn->tx_data = conn->tx_data->next;
   3d6da:	6813      	ldr	r3, [r2, #0]
   3d6dc:	f8c4 31e8 	str.w	r3, [r4, #488]	; 0x1e8
		if (!conn->tx_ctrl) {
   3d6e0:	2900      	cmp	r1, #0
   3d6e2:	d093      	beq.n	3d60c <ull_conn_llcp+0x1488>
   3d6e4:	e645      	b.n	3d372 <ull_conn_llcp+0x11ee>
	    ((pdu_data_tx->llctrl.opcode !=
   3d6e6:	79d3      	ldrb	r3, [r2, #7]
	if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   3d6e8:	2b03      	cmp	r3, #3
   3d6ea:	f43f a8c0 	beq.w	3c86e <ull_conn_llcp+0x6ea>
	      PDU_DATA_LLCTRL_TYPE_ENC_REQ) &&
   3d6ee:	2b0a      	cmp	r3, #10
   3d6f0:	f47f af59 	bne.w	3d5a6 <ull_conn_llcp+0x1422>
   3d6f4:	f7ff b8bb 	b.w	3c86e <ull_conn_llcp+0x6ea>
	    ((pdu_data_tx->llctrl.opcode !=
   3d6f8:	79da      	ldrb	r2, [r3, #7]
	if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   3d6fa:	2a03      	cmp	r2, #3
   3d6fc:	f43f af1f 	beq.w	3d53e <ull_conn_llcp+0x13ba>
	      PDU_DATA_LLCTRL_TYPE_ENC_REQ) &&
   3d700:	2a0a      	cmp	r2, #10
   3d702:	d1e7      	bne.n	3d6d4 <ull_conn_llcp+0x1550>
   3d704:	e71b      	b.n	3d53e <ull_conn_llcp+0x13ba>
		LL_ASSERT(0);
   3d706:	4a03      	ldr	r2, [pc, #12]	; (3d714 <ull_conn_llcp+0x1590>)
   3d708:	4903      	ldr	r1, [pc, #12]	; (3d718 <ull_conn_llcp+0x1594>)
   3d70a:	f241 03c5 	movw	r3, #4293	; 0x10c5
   3d70e:	f7ff ba46 	b.w	3cb9e <ull_conn_llcp+0xa1a>
   3d712:	bf00      	nop
   3d714:	0005269c 	.word	0x0005269c
   3d718:	000521ac 	.word	0x000521ac

0003d71c <ull_conn_tx_demux>:
{
   3d71c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		lll_tx = MFIFO_DEQUEUE_GET(conn_tx);
   3d720:	4c27      	ldr	r4, [pc, #156]	; (3d7c0 <ull_conn_tx_demux+0xa4>)
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
   3d722:	4f28      	ldr	r7, [pc, #160]	; (3d7c4 <ull_conn_tx_demux+0xa8>)
		lll_tx = MFIFO_DEQUEUE_GET(conn_tx);
   3d724:	7962      	ldrb	r2, [r4, #5]
{
   3d726:	4605      	mov	r5, r0
	return (void *)(fifo + first * size);
   3d728:	f104 0608 	add.w	r6, r4, #8
   3d72c:	e024      	b.n	3d778 <ull_conn_tx_demux+0x5c>
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
   3d72e:	4642      	mov	r2, r8
   3d730:	f44f 71fc 	mov.w	r1, #504	; 0x1f8
   3d734:	4638      	mov	r0, r7
   3d736:	f7f6 fef3 	bl	34520 <mem_get>
	if (conn->lll.handle != handle) {
   3d73a:	8d03      	ldrh	r3, [r0, #40]	; 0x28
   3d73c:	4543      	cmp	r3, r8
   3d73e:	d128      	bne.n	3d792 <ull_conn_tx_demux+0x76>
			struct node_tx *tx = lll_tx->node;
   3d740:	f8d9 3004 	ldr.w	r3, [r9, #4]
			tx->next = NULL;
   3d744:	2200      	movs	r2, #0
   3d746:	601a      	str	r2, [r3, #0]
			if (!conn->tx_data) {
   3d748:	f8d0 21e8 	ldr.w	r2, [r0, #488]	; 0x1e8
   3d74c:	b362      	cbz	r2, 3d7a8 <ull_conn_tx_demux+0x8c>
			if (conn->tx_data_last) {
   3d74e:	f8d0 21ec 	ldr.w	r2, [r0, #492]	; 0x1ec
   3d752:	b102      	cbz	r2, 3d756 <ull_conn_tx_demux+0x3a>
				conn->tx_data_last->next = tx;
   3d754:	6013      	str	r3, [r2, #0]
			conn->tx_data_last = tx;
   3d756:	f8c0 31ec 	str.w	r3, [r0, #492]	; 0x1ec
		MFIFO_DEQUEUE(conn_tx);
   3d75a:	7962      	ldrb	r2, [r4, #5]
	uint8_t _first = *first; /* Copy read-index */
   3d75c:	7923      	ldrb	r3, [r4, #4]
   3d75e:	78a1      	ldrb	r1, [r4, #2]
	if (_first == last) {
   3d760:	429a      	cmp	r2, r3
   3d762:	d005      	beq.n	3d770 <ull_conn_tx_demux+0x54>
	_first += 1U;
   3d764:	3301      	adds	r3, #1
   3d766:	b2db      	uxtb	r3, r3
		_first = 0U;
   3d768:	4299      	cmp	r1, r3
   3d76a:	bf08      	it	eq
   3d76c:	2300      	moveq	r3, #0
	*first = _first; /* Write back read-index */
   3d76e:	7123      	strb	r3, [r4, #4]
	} while (--count);
   3d770:	3d01      	subs	r5, #1
   3d772:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
   3d776:	d020      	beq.n	3d7ba <ull_conn_tx_demux+0x9e>
		lll_tx = MFIFO_DEQUEUE_GET(conn_tx);
   3d778:	7923      	ldrb	r3, [r4, #4]
   3d77a:	7821      	ldrb	r1, [r4, #0]
	if (first == last) {
   3d77c:	4293      	cmp	r3, r2
   3d77e:	d01c      	beq.n	3d7ba <ull_conn_tx_demux+0x9e>
	return (void *)(fifo + first * size);
   3d780:	fb13 f301 	smulbb	r3, r3, r1
   3d784:	eb03 0906 	add.w	r9, r3, r6
		conn = ll_connected_get(lll_tx->handle);
   3d788:	f836 8003 	ldrh.w	r8, [r6, r3]
	if (handle >= CONFIG_BT_MAX_CONN) {
   3d78c:	f1b8 0f05 	cmp.w	r8, #5
   3d790:	d9cd      	bls.n	3d72e <ull_conn_tx_demux+0x12>
			struct node_tx *tx = lll_tx->node;
   3d792:	f8d9 1004 	ldr.w	r1, [r9, #4]
			p->ll_id = PDU_DATA_LLID_RESV;
   3d796:	790b      	ldrb	r3, [r1, #4]
   3d798:	f36f 0301 	bfc	r3, #0, #2
			ll_tx_ack_put(LLL_HANDLE_INVALID, tx);
   3d79c:	f64f 70ff 	movw	r0, #65535	; 0xffff
			p->ll_id = PDU_DATA_LLID_RESV;
   3d7a0:	710b      	strb	r3, [r1, #4]
			ll_tx_ack_put(LLL_HANDLE_INVALID, tx);
   3d7a2:	f7fa fb37 	bl	37e14 <ll_tx_ack_put>
   3d7a6:	e7d8      	b.n	3d75a <ull_conn_tx_demux+0x3e>
				if (!conn->tx_head) {
   3d7a8:	f8d0 21dc 	ldr.w	r2, [r0, #476]	; 0x1dc
				conn->tx_data = tx;
   3d7ac:	f8c0 31e8 	str.w	r3, [r0, #488]	; 0x1e8
				if (!conn->tx_head) {
   3d7b0:	2a00      	cmp	r2, #0
   3d7b2:	d1cc      	bne.n	3d74e <ull_conn_tx_demux+0x32>
					conn->tx_head = tx;
   3d7b4:	f8c0 31dc 	str.w	r3, [r0, #476]	; 0x1dc
			if (conn->tx_data_last) {
   3d7b8:	e7cd      	b.n	3d756 <ull_conn_tx_demux+0x3a>
}
   3d7ba:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   3d7be:	bf00      	nop
   3d7c0:	20000c04 	.word	0x20000c04
   3d7c4:	200028e8 	.word	0x200028e8

0003d7c8 <conn_cleanup>:
{
   3d7c8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if (conn == conn_upd_curr) {
   3d7cc:	4b38      	ldr	r3, [pc, #224]	; (3d8b0 <conn_cleanup+0xe8>)
	rx = conn->llcp_rx;
   3d7ce:	f8d0 4114 	ldr.w	r4, [r0, #276]	; 0x114
   3d7d2:	681a      	ldr	r2, [r3, #0]
	*((uint8_t *)rx->pdu) = reason;
   3d7d4:	f880 1170 	strb.w	r1, [r0, #368]	; 0x170
   3d7d8:	4290      	cmp	r0, r2
		conn_upd_curr = NULL;
   3d7da:	bf04      	itt	eq
   3d7dc:	2200      	moveq	r2, #0
   3d7de:	601a      	streq	r2, [r3, #0]
	rx->hdr.handle = conn->lll.handle;
   3d7e0:	8d02      	ldrh	r2, [r0, #40]	; 0x28
   3d7e2:	f8a0 215a 	strh.w	r2, [r0, #346]	; 0x15a
	rx->hdr.type = NODE_RX_TYPE_TERMINATE;
   3d7e6:	2318      	movs	r3, #24
{
   3d7e8:	b082      	sub	sp, #8
   3d7ea:	4606      	mov	r6, r0
	rx->hdr.type = NODE_RX_TYPE_TERMINATE;
   3d7ec:	f880 3158 	strb.w	r3, [r0, #344]	; 0x158
	while (rx) {
   3d7f0:	b144      	cbz	r4, 3d804 <conn_cleanup+0x3c>
		hdr->type = NODE_RX_TYPE_RELEASE;
   3d7f2:	2501      	movs	r5, #1
		rx = hdr->link->mem;
   3d7f4:	6820      	ldr	r0, [r4, #0]
		hdr = &rx->hdr;
   3d7f6:	4621      	mov	r1, r4
		rx = hdr->link->mem;
   3d7f8:	6844      	ldr	r4, [r0, #4]
		hdr->type = NODE_RX_TYPE_RELEASE;
   3d7fa:	710d      	strb	r5, [r1, #4]
		ll_rx_put(hdr->link, hdr);
   3d7fc:	f7fa fac2 	bl	37d84 <ll_rx_put>
	while (rx) {
   3d800:	2c00      	cmp	r4, #0
   3d802:	d1f7      	bne.n	3d7f4 <conn_cleanup+0x2c>
	while (conn->tx_head) {
   3d804:	f8d6 11dc 	ldr.w	r1, [r6, #476]	; 0x1dc
   3d808:	b381      	cbz	r1, 3d86c <conn_cleanup+0xa4>
		link = mem_acquire(&mem_link_tx.free);
   3d80a:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 3d8b4 <conn_cleanup+0xec>
		LL_ASSERT(link);
   3d80e:	f8df a0a8 	ldr.w	sl, [pc, #168]	; 3d8b8 <conn_cleanup+0xf0>
   3d812:	f8df 90a8 	ldr.w	r9, [pc, #168]	; 3d8bc <conn_cleanup+0xf4>
		memq_enqueue(link, tx, &conn->lll.memq_tx.tail);
   3d816:	f106 0768 	add.w	r7, r6, #104	; 0x68
   3d81a:	e007      	b.n	3d82c <conn_cleanup+0x64>
   3d81c:	4629      	mov	r1, r5
   3d81e:	463a      	mov	r2, r7
   3d820:	4620      	mov	r0, r4
   3d822:	f7f6 feaf 	bl	34584 <memq_enqueue>
	while (conn->tx_head) {
   3d826:	f8d6 11dc 	ldr.w	r1, [r6, #476]	; 0x1dc
   3d82a:	b1f9      	cbz	r1, 3d86c <conn_cleanup+0xa4>
		tx = tx_ull_dequeue(conn, conn->tx_head);
   3d82c:	4630      	mov	r0, r6
   3d82e:	f7fc f831 	bl	39894 <tx_ull_dequeue>
   3d832:	4605      	mov	r5, r0
		link = mem_acquire(&mem_link_tx.free);
   3d834:	4640      	mov	r0, r8
   3d836:	f7f6 fe3f 	bl	344b8 <mem_acquire>
		LL_ASSERT(link);
   3d83a:	4604      	mov	r4, r0
   3d83c:	2800      	cmp	r0, #0
   3d83e:	d1ed      	bne.n	3d81c <conn_cleanup+0x54>
   3d840:	481f      	ldr	r0, [pc, #124]	; (3d8c0 <conn_cleanup+0xf8>)
   3d842:	f640 2349 	movw	r3, #2633	; 0xa49
   3d846:	4652      	mov	r2, sl
   3d848:	4649      	mov	r1, r9
   3d84a:	f00b fc1b 	bl	49084 <assert_print>
   3d84e:	4040      	eors	r0, r0
   3d850:	f380 8811 	msr	BASEPRI, r0
   3d854:	f04f 0003 	mov.w	r0, #3
   3d858:	df02      	svc	2
		memq_enqueue(link, tx, &conn->lll.memq_tx.tail);
   3d85a:	4629      	mov	r1, r5
   3d85c:	463a      	mov	r2, r7
   3d85e:	4620      	mov	r0, r4
   3d860:	f7f6 fe90 	bl	34584 <memq_enqueue>
	while (conn->tx_head) {
   3d864:	f8d6 11dc 	ldr.w	r1, [r6, #476]	; 0x1dc
   3d868:	2900      	cmp	r1, #0
   3d86a:	d1df      	bne.n	3d82c <conn_cleanup+0x64>
	ticker_status = ticker_stop(TICKER_INSTANCE_ID_CTLR,
   3d86c:	8d32      	ldrh	r2, [r6, #40]	; 0x28
   3d86e:	4b15      	ldr	r3, [pc, #84]	; (3d8c4 <conn_cleanup+0xfc>)
   3d870:	9600      	str	r6, [sp, #0]
   3d872:	3205      	adds	r2, #5
   3d874:	b2d2      	uxtb	r2, r2
   3d876:	2101      	movs	r1, #1
   3d878:	2000      	movs	r0, #0
   3d87a:	f7f8 f91f 	bl	35abc <ticker_stop>
	LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
   3d87e:	f030 0302 	bics.w	r3, r0, #2
   3d882:	d00c      	beq.n	3d89e <conn_cleanup+0xd6>
   3d884:	4a0c      	ldr	r2, [pc, #48]	; (3d8b8 <conn_cleanup+0xf0>)
   3d886:	4910      	ldr	r1, [pc, #64]	; (3d8c8 <conn_cleanup+0x100>)
   3d888:	480d      	ldr	r0, [pc, #52]	; (3d8c0 <conn_cleanup+0xf8>)
   3d88a:	f640 230e 	movw	r3, #2574	; 0xa0e
   3d88e:	f00b fbf9 	bl	49084 <assert_print>
   3d892:	4040      	eors	r0, r0
   3d894:	f380 8811 	msr	BASEPRI, r0
   3d898:	f04f 0003 	mov.w	r0, #3
   3d89c:	df02      	svc	2
	lll->handle = LLL_HANDLE_INVALID;
   3d89e:	f64f 73ff 	movw	r3, #65535	; 0xffff
	ull_conn_tx_demux(UINT8_MAX);
   3d8a2:	20ff      	movs	r0, #255	; 0xff
	lll->handle = LLL_HANDLE_INVALID;
   3d8a4:	8533      	strh	r3, [r6, #40]	; 0x28
}
   3d8a6:	b002      	add	sp, #8
   3d8a8:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	ull_conn_tx_demux(UINT8_MAX);
   3d8ac:	f7ff bf36 	b.w	3d71c <ull_conn_tx_demux>
   3d8b0:	200058f0 	.word	0x200058f0
   3d8b4:	20005278 	.word	0x20005278
   3d8b8:	0005269c 	.word	0x0005269c
   3d8bc:	000526f4 	.word	0x000526f4
   3d8c0:	0005214c 	.word	0x0005214c
   3d8c4:	00039669 	.word	0x00039669
   3d8c8:	0005277c 	.word	0x0005277c

0003d8cc <ull_conn_done>:
{
   3d8cc:	b5f0      	push	{r4, r5, r6, r7, lr}
	conn = CONTAINER_OF(done->param, struct ll_conn, ull);
   3d8ce:	69c4      	ldr	r4, [r0, #28]
	if (unlikely(lll->handle == LLL_HANDLE_INVALID)) {
   3d8d0:	8d22      	ldrh	r2, [r4, #40]	; 0x28
   3d8d2:	f64f 73ff 	movw	r3, #65535	; 0xffff
   3d8d6:	429a      	cmp	r2, r3
{
   3d8d8:	b08b      	sub	sp, #44	; 0x2c
	if (unlikely(lll->handle == LLL_HANDLE_INVALID)) {
   3d8da:	d077      	beq.n	3d9cc <ull_conn_done+0x100>
	switch (done->extra.mic_state) {
   3d8dc:	f890 3027 	ldrb.w	r3, [r0, #39]	; 0x27
   3d8e0:	2b01      	cmp	r3, #1
   3d8e2:	4605      	mov	r5, r0
   3d8e4:	f000 80f9 	beq.w	3dada <ull_conn_done+0x20e>
   3d8e8:	2b02      	cmp	r3, #2
   3d8ea:	f000 8099 	beq.w	3da20 <ull_conn_done+0x154>
   3d8ee:	2b00      	cmp	r3, #0
   3d8f0:	f000 80d9 	beq.w	3daa6 <ull_conn_done+0x1da>
	reason_final = conn->llcp_terminate.reason_final;
   3d8f4:	f894 1153 	ldrb.w	r1, [r4, #339]	; 0x153
	if (reason_final && (
   3d8f8:	2900      	cmp	r1, #0
   3d8fa:	f040 8094 	bne.w	3da26 <ull_conn_done+0x15a>
	if (lll->latency_prepare) {
   3d8fe:	8de6      	ldrh	r6, [r4, #46]	; 0x2e
	latency_event = lll->latency_event;
   3d900:	8e27      	ldrh	r7, [r4, #48]	; 0x30
	if (lll->latency_prepare) {
   3d902:	2e00      	cmp	r6, #0
   3d904:	d164      	bne.n	3d9d0 <ull_conn_done+0x104>
	if (done->extra.trx_cnt) {
   3d906:	8caa      	ldrh	r2, [r5, #36]	; 0x24
		elapsed_event = latency_event + 1U;
   3d908:	1c7e      	adds	r6, r7, #1
	ticks_drift_plus = 0U;
   3d90a:	2300      	movs	r3, #0
	ticks_drift_minus = 0U;
   3d90c:	e9cd 3308 	strd	r3, r3, [sp, #32]
		elapsed_event = latency_event + 1U;
   3d910:	b2b6      	uxth	r6, r6
	if (done->extra.trx_cnt) {
   3d912:	2a00      	cmp	r2, #0
   3d914:	d064      	beq.n	3d9e0 <ull_conn_done+0x114>
		} else if (lll->role) {
   3d916:	f994 3039 	ldrsb.w	r3, [r4, #57]	; 0x39
   3d91a:	2b00      	cmp	r3, #0
   3d91c:	f2c0 8132 	blt.w	3db84 <ull_conn_done+0x2b8>
		} else if (reason_final) {
   3d920:	b129      	cbz	r1, 3d92e <ull_conn_done+0x62>
			conn->central.terminate_ack = 1;
   3d922:	f894 30e4 	ldrb.w	r3, [r4, #228]	; 0xe4
   3d926:	f043 0304 	orr.w	r3, r3, #4
   3d92a:	f884 30e4 	strb.w	r3, [r4, #228]	; 0xe4
		conn->connect_expire = 0U;
   3d92e:	2300      	movs	r3, #0
   3d930:	f8a4 30c0 	strh.w	r3, [r4, #192]	; 0xc0
	if (done->extra.crc_valid) {
   3d934:	f895 3026 	ldrb.w	r3, [r5, #38]	; 0x26
   3d938:	07d9      	lsls	r1, r3, #31
   3d93a:	f140 80d4 	bpl.w	3dae6 <ull_conn_done+0x21a>
		conn->supervision_expire = 0U;
   3d93e:	2300      	movs	r3, #0
   3d940:	f8a4 30c4 	strh.w	r3, [r4, #196]	; 0xc4
	force = 0U;
   3d944:	2500      	movs	r5, #0
	if (conn->procedure_expire != 0U) {
   3d946:	f8b4 30c8 	ldrh.w	r3, [r4, #200]	; 0xc8
   3d94a:	b12b      	cbz	r3, 3d958 <ull_conn_done+0x8c>
		if (conn->procedure_expire > elapsed_event) {
   3d94c:	42b3      	cmp	r3, r6
   3d94e:	f240 8129 	bls.w	3dba4 <ull_conn_done+0x2d8>
			conn->procedure_expire -= elapsed_event;
   3d952:	1b9b      	subs	r3, r3, r6
   3d954:	f8a4 30c8 	strh.w	r3, [r4, #200]	; 0xc8
	if (conn->apto_expire != 0U) {
   3d958:	f8b4 30d0 	ldrh.w	r3, [r4, #208]	; 0xd0
   3d95c:	b12b      	cbz	r3, 3d96a <ull_conn_done+0x9e>
		if (conn->apto_expire > elapsed_event) {
   3d95e:	42b3      	cmp	r3, r6
   3d960:	f240 80e6 	bls.w	3db30 <ull_conn_done+0x264>
			conn->apto_expire -= elapsed_event;
   3d964:	1b9b      	subs	r3, r3, r6
   3d966:	f8a4 30d0 	strh.w	r3, [r4, #208]	; 0xd0
	if (conn->appto_expire != 0U) {
   3d96a:	f8b4 20cc 	ldrh.w	r2, [r4, #204]	; 0xcc
	if (((((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) &&
   3d96e:	f894 30f0 	ldrb.w	r3, [r4, #240]	; 0xf0
   3d972:	f894 10f1 	ldrb.w	r1, [r4, #241]	; 0xf1
	if (conn->appto_expire != 0U) {
   3d976:	b15a      	cbz	r2, 3d990 <ull_conn_done+0xc4>
		if (conn->appto_expire > elapsed_event) {
   3d978:	42b2      	cmp	r2, r6
   3d97a:	f200 80bd 	bhi.w	3daf8 <ull_conn_done+0x22c>
			if ((conn->procedure_expire == 0U) &&
   3d97e:	f8b4 20c8 	ldrh.w	r2, [r4, #200]	; 0xc8
			conn->appto_expire = 0U;
   3d982:	2000      	movs	r0, #0
   3d984:	f8a4 00cc 	strh.w	r0, [r4, #204]	; 0xcc
			if ((conn->procedure_expire == 0U) &&
   3d988:	b912      	cbnz	r2, 3d990 <ull_conn_done+0xc4>
   3d98a:	4299      	cmp	r1, r3
   3d98c:	f000 8113 	beq.w	3dbb6 <ull_conn_done+0x2ea>
	if (((((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) &&
   3d990:	1a5b      	subs	r3, r3, r1
   3d992:	f003 0303 	and.w	r3, r3, #3
   3d996:	2b02      	cmp	r3, #2
   3d998:	f000 80b7 	beq.w	3db0a <ull_conn_done+0x23e>
	      (conn->llcp_type == LLCP_CHAN_MAP))) ||
   3d99c:	f894 2118 	ldrb.w	r2, [r4, #280]	; 0x118
   3d9a0:	f894 3119 	ldrb.w	r3, [r4, #281]	; 0x119
   3d9a4:	429a      	cmp	r2, r3
   3d9a6:	f000 80d5 	beq.w	3db54 <ull_conn_done+0x288>
		lll->latency_event = 0U;
   3d9aa:	2200      	movs	r2, #0
   3d9ac:	8622      	strh	r2, [r4, #48]	; 0x30
	if (ticks_drift_plus || ticks_drift_minus || lazy || force) {
   3d9ae:	e9dd 6308 	ldrd	r6, r3, [sp, #32]
	if ((force) || (latency_event != lll->latency_event)) {
   3d9b2:	2d00      	cmp	r5, #0
   3d9b4:	d150      	bne.n	3da58 <ull_conn_done+0x18c>
   3d9b6:	4297      	cmp	r7, r2
   3d9b8:	f000 80b4 	beq.w	3db24 <ull_conn_done+0x258>
		lazy = lll->latency_event + 1U;
   3d9bc:	3201      	adds	r2, #1
   3d9be:	b291      	uxth	r1, r2
	if (ticks_drift_plus || ticks_drift_minus || lazy || force) {
   3d9c0:	2b00      	cmp	r3, #0
   3d9c2:	d14b      	bne.n	3da5c <ull_conn_done+0x190>
   3d9c4:	2e00      	cmp	r6, #0
   3d9c6:	d149      	bne.n	3da5c <ull_conn_done+0x190>
   3d9c8:	2900      	cmp	r1, #0
   3d9ca:	d147      	bne.n	3da5c <ull_conn_done+0x190>
}
   3d9cc:	b00b      	add	sp, #44	; 0x2c
   3d9ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (done->extra.trx_cnt) {
   3d9d0:	8caa      	ldrh	r2, [r5, #36]	; 0x24
		elapsed_event = latency_event + lll->latency_prepare;
   3d9d2:	443e      	add	r6, r7
	ticks_drift_plus = 0U;
   3d9d4:	2300      	movs	r3, #0
	ticks_drift_minus = 0U;
   3d9d6:	e9cd 3308 	strd	r3, r3, [sp, #32]
		elapsed_event = latency_event + lll->latency_prepare;
   3d9da:	b2b6      	uxth	r6, r6
	if (done->extra.trx_cnt) {
   3d9dc:	2a00      	cmp	r2, #0
   3d9de:	d19a      	bne.n	3d916 <ull_conn_done+0x4a>
	if (done->extra.crc_valid) {
   3d9e0:	f895 3026 	ldrb.w	r3, [r5, #38]	; 0x26
   3d9e4:	07da      	lsls	r2, r3, #31
   3d9e6:	d4aa      	bmi.n	3d93e <ull_conn_done+0x72>
	else if (conn->connect_expire) {
   3d9e8:	f8b4 20c0 	ldrh.w	r2, [r4, #192]	; 0xc0
   3d9ec:	2a00      	cmp	r2, #0
   3d9ee:	d07a      	beq.n	3dae6 <ull_conn_done+0x21a>
		if (conn->connect_expire > elapsed_event) {
   3d9f0:	42b2      	cmp	r2, r6
   3d9f2:	f240 80e7 	bls.w	3dbc4 <ull_conn_done+0x2f8>
			conn->connect_expire -= elapsed_event;
   3d9f6:	1b92      	subs	r2, r2, r6
	if (conn->supervision_expire) {
   3d9f8:	f8b4 30c4 	ldrh.w	r3, [r4, #196]	; 0xc4
			conn->connect_expire -= elapsed_event;
   3d9fc:	f8a4 20c0 	strh.w	r2, [r4, #192]	; 0xc0
	if (conn->supervision_expire) {
   3da00:	2b00      	cmp	r3, #0
   3da02:	d09f      	beq.n	3d944 <ull_conn_done+0x78>
		if (conn->supervision_expire > elapsed_event) {
   3da04:	429e      	cmp	r6, r3
   3da06:	f080 80c8 	bcs.w	3db9a <ull_conn_done+0x2ce>
			conn->supervision_expire -= elapsed_event;
   3da0a:	1b9b      	subs	r3, r3, r6
   3da0c:	b29b      	uxth	r3, r3
			lll->latency_event = 0U;
   3da0e:	2200      	movs	r2, #0
			if (conn->supervision_expire <= 6U) {
   3da10:	2b06      	cmp	r3, #6
			conn->supervision_expire -= elapsed_event;
   3da12:	f8a4 30c4 	strh.w	r3, [r4, #196]	; 0xc4
			lll->latency_event = 0U;
   3da16:	8622      	strh	r2, [r4, #48]	; 0x30
			if (conn->supervision_expire <= 6U) {
   3da18:	f200 809e 	bhi.w	3db58 <ull_conn_done+0x28c>
				force = 1U;
   3da1c:	2501      	movs	r5, #1
   3da1e:	e792      	b.n	3d946 <ull_conn_done+0x7a>
		conn->llcp_terminate.reason_final =
   3da20:	213d      	movs	r1, #61	; 0x3d
   3da22:	f884 1153 	strb.w	r1, [r4, #339]	; 0x153
	if (reason_final && (
   3da26:	f994 3039 	ldrsb.w	r3, [r4, #57]	; 0x39
   3da2a:	2b00      	cmp	r3, #0
   3da2c:	db0e      	blt.n	3da4c <ull_conn_done+0x180>
			       conn->llcp_terminate.ack) & 0xFF) ==
   3da2e:	f894 3150 	ldrb.w	r3, [r4, #336]	; 0x150
   3da32:	f894 2151 	ldrb.w	r2, [r4, #337]	; 0x151
   3da36:	1a9b      	subs	r3, r3, r2
			    lll->role ||
   3da38:	b2db      	uxtb	r3, r3
   3da3a:	2b03      	cmp	r3, #3
   3da3c:	d006      	beq.n	3da4c <ull_conn_done+0x180>
			     TERM_ACKED) ||
   3da3e:	f894 30e4 	ldrb.w	r3, [r4, #228]	; 0xe4
   3da42:	075e      	lsls	r6, r3, #29
   3da44:	d402      	bmi.n	3da4c <ull_conn_done+0x180>
			    conn->central.terminate_ack ||
   3da46:	293d      	cmp	r1, #61	; 0x3d
   3da48:	f47f af59 	bne.w	3d8fe <ull_conn_done+0x32>
		conn_cleanup(conn, reason_final);
   3da4c:	4620      	mov	r0, r4
}
   3da4e:	b00b      	add	sp, #44	; 0x2c
   3da50:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		conn_cleanup(conn, reason_final);
   3da54:	f7ff beb8 	b.w	3d7c8 <conn_cleanup>
		lazy = lll->latency_event + 1U;
   3da58:	3201      	adds	r2, #1
   3da5a:	b291      	uxth	r1, r2
		uint8_t ticker_id = TICKER_ID_CONN_BASE + lll->handle;
   3da5c:	8d22      	ldrh	r2, [r4, #40]	; 0x28
		struct ll_conn *conn = lll->hdr.parent;
   3da5e:	69e4      	ldr	r4, [r4, #28]
		ticker_status = ticker_update(TICKER_INSTANCE_ID_CTLR,
   3da60:	9504      	str	r5, [sp, #16]
   3da62:	2000      	movs	r0, #0
   3da64:	4d67      	ldr	r5, [pc, #412]	; (3dc04 <ull_conn_done+0x338>)
   3da66:	9103      	str	r1, [sp, #12]
		uint8_t ticker_id = TICKER_ID_CONN_BASE + lll->handle;
   3da68:	3205      	adds	r2, #5
		ticker_status = ticker_update(TICKER_INSTANCE_ID_CTLR,
   3da6a:	e9cd 0001 	strd	r0, r0, [sp, #4]
   3da6e:	9406      	str	r4, [sp, #24]
   3da70:	9600      	str	r6, [sp, #0]
   3da72:	b2d2      	uxtb	r2, r2
   3da74:	2101      	movs	r1, #1
   3da76:	9505      	str	r5, [sp, #20]
   3da78:	f7f8 f808 	bl	35a8c <ticker_update>
		LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
   3da7c:	f030 0302 	bics.w	r3, r0, #2
   3da80:	d0a4      	beq.n	3d9cc <ull_conn_done+0x100>
   3da82:	f7fa fa5f 	bl	37f44 <ull_disable_mark_get>
   3da86:	4284      	cmp	r4, r0
   3da88:	d0a0      	beq.n	3d9cc <ull_conn_done+0x100>
   3da8a:	4a5f      	ldr	r2, [pc, #380]	; (3dc08 <ull_conn_done+0x33c>)
   3da8c:	495f      	ldr	r1, [pc, #380]	; (3dc0c <ull_conn_done+0x340>)
   3da8e:	4860      	ldr	r0, [pc, #384]	; (3dc10 <ull_conn_done+0x344>)
   3da90:	f240 7344 	movw	r3, #1860	; 0x744
   3da94:	f00b faf6 	bl	49084 <assert_print>
   3da98:	4040      	eors	r0, r0
   3da9a:	f380 8811 	msr	BASEPRI, r0
   3da9e:	f04f 0003 	mov.w	r0, #3
   3daa2:	df02      	svc	2
   3daa4:	e792      	b.n	3d9cc <ull_conn_done+0x100>
		if (lll->enc_rx || conn->llcp_enc.pause_rx) {
   3daa6:	f894 307a 	ldrb.w	r3, [r4, #122]	; 0x7a
   3daaa:	071b      	lsls	r3, r3, #28
   3daac:	d534      	bpl.n	3db18 <ull_conn_done+0x24c>
					    (lll->latency + 6)) ?
   3daae:	8da1      	ldrh	r1, [r4, #44]	; 0x2c
			appto_reload_new = (conn->apto_reload >
   3dab0:	f8b4 20ce 	ldrh.w	r2, [r4, #206]	; 0xce
					    (lll->latency + 6)) ?
   3dab4:	1d8b      	adds	r3, r1, #6
			appto_reload_new = (conn->apto_reload >
   3dab6:	429a      	cmp	r2, r3
   3dab8:	bfc4      	itt	gt
   3daba:	1f93      	subgt	r3, r2, #6
   3dabc:	1a5b      	subgt	r3, r3, r1
			if (conn->appto_reload != appto_reload_new) {
   3dabe:	f8b4 10ca 	ldrh.w	r1, [r4, #202]	; 0xca
			appto_reload_new = (conn->apto_reload >
   3dac2:	bfcc      	ite	gt
   3dac4:	b29b      	uxthgt	r3, r3
   3dac6:	4613      	movle	r3, r2
			if (conn->appto_reload != appto_reload_new) {
   3dac8:	4299      	cmp	r1, r3
   3daca:	d055      	beq.n	3db78 <ull_conn_done+0x2ac>
				conn->appto_reload = appto_reload_new;
   3dacc:	f8a4 30ca 	strh.w	r3, [r4, #202]	; 0xca
				conn->appto_expire = conn->appto_reload;
   3dad0:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
				conn->apto_expire = conn->apto_reload;
   3dad4:	f8a4 20d0 	strh.w	r2, [r4, #208]	; 0xd0
   3dad8:	e70c      	b.n	3d8f4 <ull_conn_done+0x28>
		conn->appto_expire = conn->apto_expire = 0U;
   3dada:	2300      	movs	r3, #0
   3dadc:	f8a4 30d0 	strh.w	r3, [r4, #208]	; 0xd0
   3dae0:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
		break;
   3dae4:	e706      	b.n	3d8f4 <ull_conn_done+0x28>
		if (!conn->supervision_expire) {
   3dae6:	f8b4 30c4 	ldrh.w	r3, [r4, #196]	; 0xc4
   3daea:	2b00      	cmp	r3, #0
   3daec:	d18a      	bne.n	3da04 <ull_conn_done+0x138>
			conn->supervision_expire = conn->supervision_reload;
   3daee:	f8b4 30c2 	ldrh.w	r3, [r4, #194]	; 0xc2
   3daf2:	f8a4 30c4 	strh.w	r3, [r4, #196]	; 0xc4
   3daf6:	e783      	b.n	3da00 <ull_conn_done+0x134>
	if (((((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) &&
   3daf8:	1a5b      	subs	r3, r3, r1
   3dafa:	f003 0303 	and.w	r3, r3, #3
			conn->appto_expire -= elapsed_event;
   3dafe:	1b92      	subs	r2, r2, r6
	if (((((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) &&
   3db00:	2b02      	cmp	r3, #2
			conn->appto_expire -= elapsed_event;
   3db02:	f8a4 20cc 	strh.w	r2, [r4, #204]	; 0xcc
	if (((((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) &&
   3db06:	f47f af49 	bne.w	3d99c <ull_conn_done+0xd0>
	     ((conn->llcp_type == LLCP_CONN_UPD) ||
   3db0a:	f894 30f2 	ldrb.w	r3, [r4, #242]	; 0xf2
	if (((((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) &&
   3db0e:	3b01      	subs	r3, #1
   3db10:	2b01      	cmp	r3, #1
   3db12:	f63f af43 	bhi.w	3d99c <ull_conn_done+0xd0>
   3db16:	e748      	b.n	3d9aa <ull_conn_done+0xde>
		if (lll->enc_rx || conn->llcp_enc.pause_rx) {
   3db18:	f894 3176 	ldrb.w	r3, [r4, #374]	; 0x176
   3db1c:	07df      	lsls	r7, r3, #31
   3db1e:	f57f aee9 	bpl.w	3d8f4 <ull_conn_done+0x28>
   3db22:	e7c4      	b.n	3daae <ull_conn_done+0x1e2>
	if (ticks_drift_plus || ticks_drift_minus || lazy || force) {
   3db24:	b913      	cbnz	r3, 3db2c <ull_conn_done+0x260>
   3db26:	2e00      	cmp	r6, #0
   3db28:	f43f af50 	beq.w	3d9cc <ull_conn_done+0x100>
	lazy = 0U;
   3db2c:	4629      	mov	r1, r5
   3db2e:	e795      	b.n	3da5c <ull_conn_done+0x190>
			rx = ll_pdu_rx_alloc();
   3db30:	f7fa f95a 	bl	37de8 <ll_pdu_rx_alloc>
			if (rx) {
   3db34:	4601      	mov	r1, r0
   3db36:	2800      	cmp	r0, #0
   3db38:	d039      	beq.n	3dbae <ull_conn_done+0x2e2>
				conn->apto_expire = 0U;
   3db3a:	2300      	movs	r3, #0
   3db3c:	f8a4 30d0 	strh.w	r3, [r4, #208]	; 0xd0
				rx->handle = lll->handle;
   3db40:	8d23      	ldrh	r3, [r4, #40]	; 0x28
   3db42:	80c3      	strh	r3, [r0, #6]
				rx->type = NODE_RX_TYPE_APTO;
   3db44:	231b      	movs	r3, #27
   3db46:	7103      	strb	r3, [r0, #4]
				ll_rx_put(rx->link, rx);
   3db48:	6800      	ldr	r0, [r0, #0]
   3db4a:	f7fa f91b 	bl	37d84 <ll_rx_put>
				ll_rx_sched();
   3db4e:	f7fa f923 	bl	37d98 <ll_rx_sched>
   3db52:	e70a      	b.n	3d96a <ull_conn_done+0x9e>
	if ((force) || (latency_event != lll->latency_event)) {
   3db54:	8e22      	ldrh	r2, [r4, #48]	; 0x30
   3db56:	e72a      	b.n	3d9ae <ull_conn_done+0xe2>
			else if (lll->role) {
   3db58:	f994 3039 	ldrsb.w	r3, [r4, #57]	; 0x39
   3db5c:	4293      	cmp	r3, r2
   3db5e:	f6bf aef1 	bge.w	3d944 <ull_conn_done+0x78>
				if (latency_event) {
   3db62:	2f00      	cmp	r7, #0
   3db64:	f47f af5a 	bne.w	3da1c <ull_conn_done+0x150>
					force = conn->periph.force & 0x01;
   3db68:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
					conn->periph.force >>= 1U;
   3db6c:	085a      	lsrs	r2, r3, #1
					if (force) {
   3db6e:	07db      	lsls	r3, r3, #31
   3db70:	d442      	bmi.n	3dbf8 <ull_conn_done+0x32c>
					conn->periph.force >>= 1U;
   3db72:	f8c4 20e8 	str.w	r2, [r4, #232]	; 0xe8
   3db76:	e6e5      	b.n	3d944 <ull_conn_done+0x78>
			if (conn->apto_expire == 0U) {
   3db78:	f8b4 10d0 	ldrh.w	r1, [r4, #208]	; 0xd0
   3db7c:	2900      	cmp	r1, #0
   3db7e:	f47f aeb9 	bne.w	3d8f4 <ull_conn_done+0x28>
   3db82:	e7a5      	b.n	3dad0 <ull_conn_done+0x204>
			ull_drift_ticks_get(done, &ticks_drift_plus,
   3db84:	aa08      	add	r2, sp, #32
   3db86:	a909      	add	r1, sp, #36	; 0x24
   3db88:	4628      	mov	r0, r5
   3db8a:	f7e8 fe29 	bl	267e0 <ull_drift_ticks_get>
			if (!conn->tx_head) {
   3db8e:	f8d4 31dc 	ldr.w	r3, [r4, #476]	; 0x1dc
   3db92:	b1e3      	cbz	r3, 3dbce <ull_conn_done+0x302>
				lll->latency_event = 0U;
   3db94:	2300      	movs	r3, #0
   3db96:	8623      	strh	r3, [r4, #48]	; 0x30
   3db98:	e6c9      	b.n	3d92e <ull_conn_done+0x62>
			conn_cleanup(conn, BT_HCI_ERR_CONN_TIMEOUT);
   3db9a:	2108      	movs	r1, #8
   3db9c:	4620      	mov	r0, r4
   3db9e:	f7ff fe13 	bl	3d7c8 <conn_cleanup>
			return;
   3dba2:	e713      	b.n	3d9cc <ull_conn_done+0x100>
			conn_cleanup(conn, BT_HCI_ERR_LL_RESP_TIMEOUT);
   3dba4:	2122      	movs	r1, #34	; 0x22
   3dba6:	4620      	mov	r0, r4
   3dba8:	f7ff fe0e 	bl	3d7c8 <conn_cleanup>
			return;
   3dbac:	e70e      	b.n	3d9cc <ull_conn_done+0x100>
				conn->apto_expire = 1U;
   3dbae:	2301      	movs	r3, #1
   3dbb0:	f8a4 30d0 	strh.w	r3, [r4, #208]	; 0xd0
   3dbb4:	e6d9      	b.n	3d96a <ull_conn_done+0x9e>
				conn->llcp_type = LLCP_PING;
   3dbb6:	2305      	movs	r3, #5
				conn->llcp_ack -= 2U;
   3dbb8:	3902      	subs	r1, #2
				conn->llcp_type = LLCP_PING;
   3dbba:	f884 30f2 	strb.w	r3, [r4, #242]	; 0xf2
				conn->llcp_ack -= 2U;
   3dbbe:	f884 10f1 	strb.w	r1, [r4, #241]	; 0xf1
	if (((((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) &&
   3dbc2:	e6eb      	b.n	3d99c <ull_conn_done+0xd0>
			conn_cleanup(conn, BT_HCI_ERR_CONN_FAIL_TO_ESTAB);
   3dbc4:	213e      	movs	r1, #62	; 0x3e
   3dbc6:	4620      	mov	r0, r4
   3dbc8:	f7ff fdfe 	bl	3d7c8 <conn_cleanup>
			return;
   3dbcc:	e6fe      	b.n	3d9cc <ull_conn_done+0x100>
				ull_conn_tx_demux(UINT8_MAX);
   3dbce:	20ff      	movs	r0, #255	; 0xff
   3dbd0:	f7ff fda4 	bl	3d71c <ull_conn_tx_demux>
			if (conn->tx_head || memq_peek(lll->memq_tx.head,
   3dbd4:	f8d4 21dc 	ldr.w	r2, [r4, #476]	; 0x1dc
   3dbd8:	2a00      	cmp	r2, #0
   3dbda:	d1db      	bne.n	3db94 <ull_conn_done+0x2c8>
   3dbdc:	e9d4 0119 	ldrd	r0, r1, [r4, #100]	; 0x64
   3dbe0:	f7f6 fcda 	bl	34598 <memq_peek>
   3dbe4:	2800      	cmp	r0, #0
   3dbe6:	d1d5      	bne.n	3db94 <ull_conn_done+0x2c8>
			} else if (lll->periph.latency_enabled) {
   3dbe8:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
   3dbec:	0758      	lsls	r0, r3, #29
   3dbee:	f57f ae9e 	bpl.w	3d92e <ull_conn_done+0x62>
				lll->latency_event = lll->latency;
   3dbf2:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
   3dbf4:	8623      	strh	r3, [r4, #48]	; 0x30
   3dbf6:	e69a      	b.n	3d92e <ull_conn_done+0x62>
						conn->periph.force |= BIT(31);
   3dbf8:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
   3dbfc:	f8c4 20e8 	str.w	r2, [r4, #232]	; 0xe8
   3dc00:	e70c      	b.n	3da1c <ull_conn_done+0x150>
   3dc02:	bf00      	nop
   3dc04:	00039855 	.word	0x00039855
   3dc08:	0005269c 	.word	0x0005269c
   3dc0c:	000527f8 	.word	0x000527f8
   3dc10:	0005214c 	.word	0x0005214c

0003dc14 <ull_conn_tx_lll_enqueue>:
	while (conn->tx_head &&
   3dc14:	f8d0 31dc 	ldr.w	r3, [r0, #476]	; 0x1dc
		(!pause_tx && (conn->tx_head == conn->tx_ctrl))) && count--) {
   3dc18:	2b00      	cmp	r3, #0
   3dc1a:	f000 80c1 	beq.w	3dda0 <ull_conn_tx_lll_enqueue+0x18c>
   3dc1e:	3901      	subs	r1, #1
{
   3dc20:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		link = mem_acquire(&mem_link_tx.free);
   3dc24:	f8df 81d8 	ldr.w	r8, [pc, #472]	; 3de00 <ull_conn_tx_lll_enqueue+0x1ec>
		LL_ASSERT(link);
   3dc28:	f8df a1d8 	ldr.w	sl, [pc, #472]	; 3de04 <ull_conn_tx_lll_enqueue+0x1f0>
   3dc2c:	f8df 91d8 	ldr.w	r9, [pc, #472]	; 3de08 <ull_conn_tx_lll_enqueue+0x1f4>
   3dc30:	4604      	mov	r4, r0
   3dc32:	b2cd      	uxtb	r5, r1
   3dc34:	e021      	b.n	3dc7a <ull_conn_tx_lll_enqueue+0x66>
		(!pause_tx && (conn->tx_head == conn->tx_ctrl))) && count--) {
   3dc36:	f8d4 21e0 	ldr.w	r2, [r4, #480]	; 0x1e0
   3dc3a:	429a      	cmp	r2, r3
   3dc3c:	d145      	bne.n	3dcca <ull_conn_tx_lll_enqueue+0xb6>
   3dc3e:	2dff      	cmp	r5, #255	; 0xff
   3dc40:	d043      	beq.n	3dcca <ull_conn_tx_lll_enqueue+0xb6>
		tx = tx_ull_dequeue(conn, conn->tx_head);
   3dc42:	f8d4 11dc 	ldr.w	r1, [r4, #476]	; 0x1dc
   3dc46:	4620      	mov	r0, r4
   3dc48:	f7fb fe24 	bl	39894 <tx_ull_dequeue>
		if (pdu_tx->ll_id == PDU_DATA_LLID_CTRL) {
   3dc4c:	7903      	ldrb	r3, [r0, #4]
   3dc4e:	f003 0303 	and.w	r3, r3, #3
   3dc52:	2b03      	cmp	r3, #3
		tx = tx_ull_dequeue(conn, conn->tx_head);
   3dc54:	4606      	mov	r6, r0
		if (pdu_tx->ll_id == PDU_DATA_LLID_CTRL) {
   3dc56:	d03a      	beq.n	3dcce <ull_conn_tx_lll_enqueue+0xba>
		link = mem_acquire(&mem_link_tx.free);
   3dc58:	4640      	mov	r0, r8
   3dc5a:	f7f6 fc2d 	bl	344b8 <mem_acquire>
		LL_ASSERT(link);
   3dc5e:	4607      	mov	r7, r0
   3dc60:	2800      	cmp	r0, #0
   3dc62:	d075      	beq.n	3dd50 <ull_conn_tx_lll_enqueue+0x13c>
		memq_enqueue(link, tx, &conn->lll.memq_tx.tail);
   3dc64:	f104 0268 	add.w	r2, r4, #104	; 0x68
   3dc68:	4631      	mov	r1, r6
   3dc6a:	4638      	mov	r0, r7
   3dc6c:	f7f6 fc8a 	bl	34584 <memq_enqueue>
	while (conn->tx_head &&
   3dc70:	f8d4 31dc 	ldr.w	r3, [r4, #476]	; 0x1dc
		(!pause_tx && (conn->tx_head == conn->tx_ctrl))) && count--) {
   3dc74:	3d01      	subs	r5, #1
   3dc76:	b2ed      	uxtb	r5, r5
   3dc78:	b33b      	cbz	r3, 3dcca <ull_conn_tx_lll_enqueue+0xb6>
	while (conn->tx_head &&
   3dc7a:	f894 1118 	ldrb.w	r1, [r4, #280]	; 0x118
   3dc7e:	f894 2119 	ldrb.w	r2, [r4, #281]	; 0x119
   3dc82:	4291      	cmp	r1, r2
   3dc84:	d1d7      	bne.n	3dc36 <ull_conn_tx_lll_enqueue+0x22>
		 !conn->llcp_phy.pause_tx &&
   3dc86:	f894 21d7 	ldrb.w	r2, [r4, #471]	; 0x1d7
		 (conn->llcp_cu.req == conn->llcp_cu.ack) &&
   3dc8a:	07d1      	lsls	r1, r2, #31
   3dc8c:	d4d3      	bmi.n	3dc36 <ull_conn_tx_lll_enqueue+0x22>
		 !conn->llcp_enc.pause_tx &&
   3dc8e:	f894 2176 	ldrb.w	r2, [r4, #374]	; 0x176
		 !conn->llcp_phy.pause_tx &&
   3dc92:	0792      	lsls	r2, r2, #30
   3dc94:	d4cf      	bmi.n	3dc36 <ull_conn_tx_lll_enqueue+0x22>
	if ((pdu_data_tx->ll_id == PDU_DATA_LLID_CTRL) &&
   3dc96:	791a      	ldrb	r2, [r3, #4]
   3dc98:	f002 0203 	and.w	r2, r2, #3
   3dc9c:	2a03      	cmp	r2, #3
   3dc9e:	d1ce      	bne.n	3dc3e <ull_conn_tx_lll_enqueue+0x2a>
	    ((pdu_data_tx->llctrl.opcode ==
   3dca0:	79da      	ldrb	r2, [r3, #7]
	if ((pdu_data_tx->ll_id == PDU_DATA_LLID_CTRL) &&
   3dca2:	2a03      	cmp	r2, #3
   3dca4:	d001      	beq.n	3dcaa <ull_conn_tx_lll_enqueue+0x96>
	      PDU_DATA_LLCTRL_TYPE_ENC_REQ) ||
   3dca6:	2a0a      	cmp	r2, #10
   3dca8:	d1c9      	bne.n	3dc3e <ull_conn_tx_lll_enqueue+0x2a>
		if (((conn->llcp_req != conn->llcp_ack) &&
   3dcaa:	f894 10f1 	ldrb.w	r1, [r4, #241]	; 0xf1
   3dcae:	f894 20f0 	ldrb.w	r2, [r4, #240]	; 0xf0
   3dcb2:	428a      	cmp	r2, r1
   3dcb4:	d075      	beq.n	3dda2 <ull_conn_tx_lll_enqueue+0x18e>
   3dcb6:	f894 20f2 	ldrb.w	r2, [r4, #242]	; 0xf2
   3dcba:	2a03      	cmp	r2, #3
   3dcbc:	d0bf      	beq.n	3dc3e <ull_conn_tx_lll_enqueue+0x2a>
			if ((tx->next != NULL) &&
   3dcbe:	681a      	ldr	r2, [r3, #0]
   3dcc0:	b11a      	cbz	r2, 3dcca <ull_conn_tx_lll_enqueue+0xb6>
   3dcc2:	f8d4 11e0 	ldr.w	r1, [r4, #480]	; 0x1e0
   3dcc6:	428a      	cmp	r2, r1
   3dcc8:	d057      	beq.n	3dd7a <ull_conn_tx_lll_enqueue+0x166>
}
   3dcca:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	switch (pdu_tx->llctrl.opcode) {
   3dcce:	79c3      	ldrb	r3, [r0, #7]
   3dcd0:	3b03      	subs	r3, #3
   3dcd2:	2b14      	cmp	r3, #20
   3dcd4:	d8c0      	bhi.n	3dc58 <ull_conn_tx_lll_enqueue+0x44>
   3dcd6:	a201      	add	r2, pc, #4	; (adr r2, 3dcdc <ull_conn_tx_lll_enqueue+0xc8>)
   3dcd8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   3dcdc:	0003dd39 	.word	0x0003dd39
   3dce0:	0003dd39 	.word	0x0003dd39
   3dce4:	0003dc59 	.word	0x0003dc59
   3dce8:	0003dc59 	.word	0x0003dc59
   3dcec:	0003dc59 	.word	0x0003dc59
   3dcf0:	0003dc59 	.word	0x0003dc59
   3dcf4:	0003dc59 	.word	0x0003dc59
   3dcf8:	0003dd39 	.word	0x0003dd39
   3dcfc:	0003dd31 	.word	0x0003dd31
   3dd00:	0003dc59 	.word	0x0003dc59
   3dd04:	0003dc59 	.word	0x0003dc59
   3dd08:	0003dc59 	.word	0x0003dc59
   3dd0c:	0003dc59 	.word	0x0003dc59
   3dd10:	0003dc59 	.word	0x0003dc59
   3dd14:	0003dc59 	.word	0x0003dc59
   3dd18:	0003dc59 	.word	0x0003dc59
   3dd1c:	0003dc59 	.word	0x0003dc59
   3dd20:	0003dc59 	.word	0x0003dc59
   3dd24:	0003dc59 	.word	0x0003dc59
   3dd28:	0003dd6d 	.word	0x0003dd6d
   3dd2c:	0003dd6d 	.word	0x0003dd6d
		if (!conn->lll.role) {
   3dd30:	f994 3039 	ldrsb.w	r3, [r4, #57]	; 0x39
   3dd34:	2b00      	cmp	r3, #0
   3dd36:	da8f      	bge.n	3dc58 <ull_conn_tx_lll_enqueue+0x44>
		conn->llcp_enc.pause_tx = 1U;
   3dd38:	f894 3176 	ldrb.w	r3, [r4, #374]	; 0x176
   3dd3c:	f043 0302 	orr.w	r3, r3, #2
   3dd40:	f884 3176 	strb.w	r3, [r4, #374]	; 0x176
		link = mem_acquire(&mem_link_tx.free);
   3dd44:	4640      	mov	r0, r8
   3dd46:	f7f6 fbb7 	bl	344b8 <mem_acquire>
		LL_ASSERT(link);
   3dd4a:	4607      	mov	r7, r0
   3dd4c:	2800      	cmp	r0, #0
   3dd4e:	d189      	bne.n	3dc64 <ull_conn_tx_lll_enqueue+0x50>
   3dd50:	482e      	ldr	r0, [pc, #184]	; (3de0c <ull_conn_tx_lll_enqueue+0x1f8>)
   3dd52:	f240 73aa 	movw	r3, #1962	; 0x7aa
   3dd56:	4652      	mov	r2, sl
   3dd58:	4649      	mov	r1, r9
   3dd5a:	f00b f993 	bl	49084 <assert_print>
   3dd5e:	4040      	eors	r0, r0
   3dd60:	f380 8811 	msr	BASEPRI, r0
   3dd64:	f04f 0003 	mov.w	r0, #3
   3dd68:	df02      	svc	2
   3dd6a:	e77b      	b.n	3dc64 <ull_conn_tx_lll_enqueue+0x50>
		conn->llcp_phy.pause_tx = 1U;
   3dd6c:	f894 31d7 	ldrb.w	r3, [r4, #471]	; 0x1d7
   3dd70:	f043 0301 	orr.w	r3, r3, #1
   3dd74:	f884 31d7 	strb.w	r3, [r4, #471]	; 0x1d7
		break;
   3dd78:	e76e      	b.n	3dc58 <ull_conn_tx_lll_enqueue+0x44>
				conn->tx_head = tx->next;
   3dd7a:	f8c4 21dc 	str.w	r2, [r4, #476]	; 0x1dc
				tx->next = conn->tx_ctrl_last->next;
   3dd7e:	f8d4 21e4 	ldr.w	r2, [r4, #484]	; 0x1e4
   3dd82:	6812      	ldr	r2, [r2, #0]
   3dd84:	601a      	str	r2, [r3, #0]
				conn->tx_ctrl_last->next = tx;
   3dd86:	f8d4 21e4 	ldr.w	r2, [r4, #484]	; 0x1e4
   3dd8a:	6013      	str	r3, [r2, #0]
				if (!conn->tx_data_last) {
   3dd8c:	f8d4 21ec 	ldr.w	r2, [r4, #492]	; 0x1ec
				conn->tx_data = tx;
   3dd90:	f8c4 31e8 	str.w	r3, [r4, #488]	; 0x1e8
				if (!conn->tx_data_last) {
   3dd94:	2a00      	cmp	r2, #0
   3dd96:	f47f af52 	bne.w	3dc3e <ull_conn_tx_lll_enqueue+0x2a>
					conn->tx_data_last = tx;
   3dd9a:	f8c4 31ec 	str.w	r3, [r4, #492]	; 0x1ec
   3dd9e:	e74e      	b.n	3dc3e <ull_conn_tx_lll_enqueue+0x2a>
   3dda0:	4770      	bx	lr
		    ((conn->llcp_req == conn->llcp_ack) &&
   3dda2:	f894 0131 	ldrb.w	r0, [r4, #305]	; 0x131
   3dda6:	f894 1130 	ldrb.w	r1, [r4, #304]	; 0x130
   3ddaa:	4288      	cmp	r0, r1
   3ddac:	d187      	bne.n	3dcbe <ull_conn_tx_lll_enqueue+0xaa>
		     ((conn->llcp_feature.ack != conn->llcp_feature.req) ||
   3ddae:	f894 0149 	ldrb.w	r0, [r4, #329]	; 0x149
   3ddb2:	f894 1148 	ldrb.w	r1, [r4, #328]	; 0x148
   3ddb6:	4288      	cmp	r0, r1
   3ddb8:	d181      	bne.n	3dcbe <ull_conn_tx_lll_enqueue+0xaa>
		      (conn->llcp_version.ack != conn->llcp_version.req) ||
   3ddba:	f894 0195 	ldrb.w	r0, [r4, #405]	; 0x195
   3ddbe:	f894 1194 	ldrb.w	r1, [r4, #404]	; 0x194
   3ddc2:	4288      	cmp	r0, r1
   3ddc4:	f47f af7b 	bne.w	3dcbe <ull_conn_tx_lll_enqueue+0xaa>
		       conn->llcp_conn_param.req) ||
   3ddc8:	f894 01c5 	ldrb.w	r0, [r4, #453]	; 0x1c5
   3ddcc:	f894 11c4 	ldrb.w	r1, [r4, #452]	; 0x1c4
   3ddd0:	4288      	cmp	r0, r1
   3ddd2:	f47f af74 	bne.w	3dcbe <ull_conn_tx_lll_enqueue+0xaa>
		      (conn->llcp_phy.ack != conn->llcp_phy.req) ||
   3ddd6:	f894 01d5 	ldrb.w	r0, [r4, #469]	; 0x1d5
   3ddda:	f894 11d4 	ldrb.w	r1, [r4, #468]	; 0x1d4
   3ddde:	4288      	cmp	r0, r1
   3dde0:	f47f af6d 	bne.w	3dcbe <ull_conn_tx_lll_enqueue+0xaa>
			conn->llcp.encryption.state = LLCP_ENC_STATE_INIT;
   3dde4:	f894 3100 	ldrb.w	r3, [r4, #256]	; 0x100
			conn->llcp_ack -= 2U;
   3dde8:	3a02      	subs	r2, #2
   3ddea:	f884 20f1 	strb.w	r2, [r4, #241]	; 0xf1
			conn->llcp.encryption.state = LLCP_ENC_STATE_INIT;
   3ddee:	2201      	movs	r2, #1
   3ddf0:	f362 0301 	bfi	r3, r2, #0, #2
   3ddf4:	f884 3100 	strb.w	r3, [r4, #256]	; 0x100
			conn->llcp_type = LLCP_ENCRYPTION;
   3ddf8:	2303      	movs	r3, #3
   3ddfa:	f884 30f2 	strb.w	r3, [r4, #242]	; 0xf2
			conn->llcp_ack -= 2U;
   3ddfe:	e71e      	b.n	3dc3e <ull_conn_tx_lll_enqueue+0x2a>
   3de00:	20005278 	.word	0x20005278
   3de04:	0005269c 	.word	0x0005269c
   3de08:	000526f4 	.word	0x000526f4
   3de0c:	0005214c 	.word	0x0005214c

0003de10 <tx_demux>:
{
   3de10:	b510      	push	{r4, lr}
   3de12:	4604      	mov	r4, r0
	ull_conn_tx_demux(1);
   3de14:	2001      	movs	r0, #1
   3de16:	f7ff fc81 	bl	3d71c <ull_conn_tx_demux>
	ull_conn_tx_lll_enqueue(param, 1);
   3de1a:	4620      	mov	r0, r4
   3de1c:	2101      	movs	r1, #1
}
   3de1e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	ull_conn_tx_lll_enqueue(param, 1);
   3de22:	f7ff bef7 	b.w	3dc14 <ull_conn_tx_lll_enqueue>
   3de26:	bf00      	nop

0003de28 <ull_conn_link_tx_release>:
	mem_release(link, &mem_link_tx.free);
   3de28:	4901      	ldr	r1, [pc, #4]	; (3de30 <ull_conn_link_tx_release+0x8>)
   3de2a:	f7f6 bb61 	b.w	344f0 <mem_release>
   3de2e:	bf00      	nop
   3de30:	20005278 	.word	0x20005278

0003de34 <ull_conn_ack_last_idx_get>:
	return mfifo_conn_ack.l;
   3de34:	4b01      	ldr	r3, [pc, #4]	; (3de3c <ull_conn_ack_last_idx_get+0x8>)
}
   3de36:	7958      	ldrb	r0, [r3, #5]
   3de38:	4770      	bx	lr
   3de3a:	bf00      	nop
   3de3c:	20000aec 	.word	0x20000aec

0003de40 <ull_conn_ack_peek>:
{
   3de40:	b510      	push	{r4, lr}
	lll_tx = MFIFO_DEQUEUE_GET(conn_ack);
   3de42:	4b0c      	ldr	r3, [pc, #48]	; (3de74 <ull_conn_ack_peek+0x34>)
   3de44:	f893 c004 	ldrb.w	ip, [r3, #4]
   3de48:	f893 e005 	ldrb.w	lr, [r3, #5]
   3de4c:	781c      	ldrb	r4, [r3, #0]
	if (first == last) {
   3de4e:	45f4      	cmp	ip, lr
   3de50:	d00d      	beq.n	3de6e <ull_conn_ack_peek+0x2e>
	return (void *)(fifo + first * size);
   3de52:	fb1c fc04 	smulbb	ip, ip, r4
   3de56:	3308      	adds	r3, #8
	*ack_last = mfifo_conn_ack.l;
   3de58:	f880 e000 	strb.w	lr, [r0]
   3de5c:	eb0c 0003 	add.w	r0, ip, r3
	*handle = lll_tx->handle;
   3de60:	f833 300c 	ldrh.w	r3, [r3, ip]
   3de64:	800b      	strh	r3, [r1, #0]
	*tx = lll_tx->node;
   3de66:	6843      	ldr	r3, [r0, #4]
   3de68:	6013      	str	r3, [r2, #0]
	return (*tx)->link;
   3de6a:	6818      	ldr	r0, [r3, #0]
}
   3de6c:	bd10      	pop	{r4, pc}
		return NULL;
   3de6e:	2000      	movs	r0, #0
}
   3de70:	bd10      	pop	{r4, pc}
   3de72:	bf00      	nop
   3de74:	20000aec 	.word	0x20000aec

0003de78 <ull_conn_ack_by_last_peek>:
{
   3de78:	b500      	push	{lr}
	lll_tx = mfifo_dequeue_get(mfifo_conn_ack.m, mfifo_conn_ack.s,
   3de7a:	4b0b      	ldr	r3, [pc, #44]	; (3dea8 <ull_conn_ack_by_last_peek+0x30>)
   3de7c:	f893 c004 	ldrb.w	ip, [r3, #4]
   3de80:	f893 e000 	ldrb.w	lr, [r3]
	if (first == last) {
   3de84:	4584      	cmp	ip, r0
   3de86:	d00c      	beq.n	3dea2 <ull_conn_ack_by_last_peek+0x2a>
	return (void *)(fifo + first * size);
   3de88:	fb1c fc0e 	smulbb	ip, ip, lr
   3de8c:	3308      	adds	r3, #8
   3de8e:	eb0c 0003 	add.w	r0, ip, r3
	*handle = lll_tx->handle;
   3de92:	f833 300c 	ldrh.w	r3, [r3, ip]
   3de96:	800b      	strh	r3, [r1, #0]
	*tx = lll_tx->node;
   3de98:	6843      	ldr	r3, [r0, #4]
   3de9a:	6013      	str	r3, [r2, #0]
	return (*tx)->link;
   3de9c:	6818      	ldr	r0, [r3, #0]
}
   3de9e:	f85d fb04 	ldr.w	pc, [sp], #4
		return NULL;
   3dea2:	2000      	movs	r0, #0
   3dea4:	e7fb      	b.n	3de9e <ull_conn_ack_by_last_peek+0x26>
   3dea6:	bf00      	nop
   3dea8:	20000aec 	.word	0x20000aec

0003deac <ull_conn_ack_dequeue>:
	return MFIFO_DEQUEUE(conn_ack);
   3deac:	4b09      	ldr	r3, [pc, #36]	; (3ded4 <ull_conn_ack_dequeue+0x28>)
	uint8_t _first = *first; /* Copy read-index */
   3deae:	7919      	ldrb	r1, [r3, #4]
	if (_first == last) {
   3deb0:	795a      	ldrb	r2, [r3, #5]
   3deb2:	7818      	ldrb	r0, [r3, #0]
   3deb4:	f893 c002 	ldrb.w	ip, [r3, #2]
   3deb8:	428a      	cmp	r2, r1
   3deba:	d009      	beq.n	3ded0 <ull_conn_ack_dequeue+0x24>
	_first += 1U;
   3debc:	1c4a      	adds	r2, r1, #1
	mem = *((void **)(fifo + _first * size));
   3debe:	fb01 3000 	mla	r0, r1, r0, r3
	_first += 1U;
   3dec2:	b2d2      	uxtb	r2, r2
		_first = 0U;
   3dec4:	4594      	cmp	ip, r2
   3dec6:	bf08      	it	eq
   3dec8:	2200      	moveq	r2, #0
	mem = *((void **)(fifo + _first * size));
   3deca:	6880      	ldr	r0, [r0, #8]
	*first = _first; /* Write back read-index */
   3decc:	711a      	strb	r2, [r3, #4]
	return mem;
   3dece:	4770      	bx	lr
		return NULL;
   3ded0:	2000      	movs	r0, #0
}
   3ded2:	4770      	bx	lr
   3ded4:	20000aec 	.word	0x20000aec

0003ded8 <ull_conn_lll_ack_enqueue>:
{
   3ded8:	b538      	push	{r3, r4, r5, lr}
	idx = MFIFO_ENQUEUE_GET(conn_ack, (void **)&lll_tx);
   3deda:	4c14      	ldr	r4, [pc, #80]	; (3df2c <ull_conn_lll_ack_enqueue+0x54>)
   3dedc:	7962      	ldrb	r2, [r4, #5]
	if (last == count) {
   3dede:	f894 e002 	ldrb.w	lr, [r4, #2]
   3dee2:	f894 c004 	ldrb.w	ip, [r4, #4]
   3dee6:	7825      	ldrb	r5, [r4, #0]
	last = last + 1;
   3dee8:	1c53      	adds	r3, r2, #1
   3deea:	b2db      	uxtb	r3, r3
		last = 0U;
   3deec:	459e      	cmp	lr, r3
   3deee:	bf08      	it	eq
   3def0:	2300      	moveq	r3, #0
	if (last == first) {
   3def2:	459c      	cmp	ip, r3
   3def4:	d009      	beq.n	3df0a <ull_conn_lll_ack_enqueue+0x32>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
   3def6:	fb12 f205 	smulbb	r2, r2, r5
   3defa:	f104 0c08 	add.w	ip, r4, #8
	lll_tx->handle = handle;
   3defe:	f82c 0002 	strh.w	r0, [ip, r2]
   3df02:	4462      	add	r2, ip
	lll_tx->node = tx;
   3df04:	6051      	str	r1, [r2, #4]
	*last = idx; /* Commit: Update write index */
   3df06:	7163      	strb	r3, [r4, #5]
}
   3df08:	bd38      	pop	{r3, r4, r5, pc}
	LL_ASSERT(lll_tx);
   3df0a:	4a09      	ldr	r2, [pc, #36]	; (3df30 <ull_conn_lll_ack_enqueue+0x58>)
   3df0c:	4909      	ldr	r1, [pc, #36]	; (3df34 <ull_conn_lll_ack_enqueue+0x5c>)
   3df0e:	480a      	ldr	r0, [pc, #40]	; (3df38 <ull_conn_lll_ack_enqueue+0x60>)
   3df10:	f240 73fa 	movw	r3, #2042	; 0x7fa
   3df14:	f00b f8b6 	bl	49084 <assert_print>
   3df18:	4040      	eors	r0, r0
   3df1a:	f380 8811 	msr	BASEPRI, r0
   3df1e:	f04f 0003 	mov.w	r0, #3
   3df22:	df02      	svc	2
	lll_tx->handle = handle;
   3df24:	2300      	movs	r3, #0
   3df26:	801b      	strh	r3, [r3, #0]
   3df28:	deff      	udf	#255	; 0xff
   3df2a:	bf00      	nop
   3df2c:	20000aec 	.word	0x20000aec
   3df30:	0005269c 	.word	0x0005269c
   3df34:	000526e4 	.word	0x000526e4
   3df38:	0005214c 	.word	0x0005214c

0003df3c <ull_conn_tx_ack>:
{
   3df3c:	b5f0      	push	{r4, r5, r6, r7, lr}
	LL_ASSERT(pdu_tx->len);
   3df3e:	7953      	ldrb	r3, [r2, #5]
{
   3df40:	b083      	sub	sp, #12
   3df42:	4614      	mov	r4, r2
   3df44:	4605      	mov	r5, r0
   3df46:	460e      	mov	r6, r1
	LL_ASSERT(pdu_tx->len);
   3df48:	b37b      	cbz	r3, 3dfaa <ull_conn_tx_ack+0x6e>
	if (pdu_tx->ll_id == PDU_DATA_LLID_CTRL) {
   3df4a:	7923      	ldrb	r3, [r4, #4]
   3df4c:	f003 0203 	and.w	r2, r3, #3
   3df50:	2a03      	cmp	r2, #3
   3df52:	d00d      	beq.n	3df70 <ull_conn_tx_ack+0x34>
	} else if (handle == LLL_HANDLE_INVALID) {
   3df54:	f64f 72ff 	movw	r2, #65535	; 0xffff
   3df58:	4295      	cmp	r5, r2
		pdu_tx->ll_id = PDU_DATA_LLID_RESV;
   3df5a:	bf04      	itt	eq
   3df5c:	f36f 0301 	bfceq	r3, #0, #2
   3df60:	7123      	strbeq	r3, [r4, #4]
	ll_tx_ack_put(handle, tx);
   3df62:	4621      	mov	r1, r4
   3df64:	4628      	mov	r0, r5
}
   3df66:	b003      	add	sp, #12
   3df68:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	ll_tx_ack_put(handle, tx);
   3df6c:	f7f9 bf52 	b.w	37e14 <ll_tx_ack_put>
		if (handle != LLL_HANDLE_INVALID) {
   3df70:	f64f 73ff 	movw	r3, #65535	; 0xffff
   3df74:	429d      	cmp	r5, r3
   3df76:	d126      	bne.n	3dfc6 <ull_conn_tx_ack+0x8a>
		if (link->next == (void *)tx) {
   3df78:	6833      	ldr	r3, [r6, #0]
   3df7a:	42a3      	cmp	r3, r4
   3df7c:	d05c      	beq.n	3e038 <ull_conn_tx_ack+0xfc>
		LL_ASSERT(!link->next);
   3df7e:	2b00      	cmp	r3, #0
   3df80:	d0ef      	beq.n	3df62 <ull_conn_tx_ack+0x26>
   3df82:	4abd      	ldr	r2, [pc, #756]	; (3e278 <ull_conn_tx_ack+0x33c>)
   3df84:	49bd      	ldr	r1, [pc, #756]	; (3e27c <ull_conn_tx_ack+0x340>)
   3df86:	48be      	ldr	r0, [pc, #760]	; (3e280 <ull_conn_tx_ack+0x344>)
   3df88:	f640 032a 	movw	r3, #2090	; 0x82a
   3df8c:	f00b f87a 	bl	49084 <assert_print>
   3df90:	4040      	eors	r0, r0
   3df92:	f380 8811 	msr	BASEPRI, r0
   3df96:	f04f 0003 	mov.w	r0, #3
   3df9a:	df02      	svc	2
	ll_tx_ack_put(handle, tx);
   3df9c:	4621      	mov	r1, r4
   3df9e:	4628      	mov	r0, r5
}
   3dfa0:	b003      	add	sp, #12
   3dfa2:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	ll_tx_ack_put(handle, tx);
   3dfa6:	f7f9 bf35 	b.w	37e14 <ll_tx_ack_put>
	LL_ASSERT(pdu_tx->len);
   3dfaa:	4ab3      	ldr	r2, [pc, #716]	; (3e278 <ull_conn_tx_ack+0x33c>)
   3dfac:	49b5      	ldr	r1, [pc, #724]	; (3e284 <ull_conn_tx_ack+0x348>)
   3dfae:	48b4      	ldr	r0, [pc, #720]	; (3e280 <ull_conn_tx_ack+0x344>)
   3dfb0:	f640 0307 	movw	r3, #2055	; 0x807
   3dfb4:	f00b f866 	bl	49084 <assert_print>
   3dfb8:	4040      	eors	r0, r0
   3dfba:	f380 8811 	msr	BASEPRI, r0
   3dfbe:	f04f 0003 	mov.w	r0, #3
   3dfc2:	df02      	svc	2
   3dfc4:	e7c1      	b.n	3df4a <ull_conn_tx_ack+0xe>
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
   3dfc6:	48b0      	ldr	r0, [pc, #704]	; (3e288 <ull_conn_tx_ack+0x34c>)
   3dfc8:	462a      	mov	r2, r5
   3dfca:	f44f 71fc 	mov.w	r1, #504	; 0x1f8
   3dfce:	f7f6 faa7 	bl	34520 <mem_get>
	switch (pdu_tx->llctrl.opcode) {
   3dfd2:	79e3      	ldrb	r3, [r4, #7]
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
   3dfd4:	4607      	mov	r7, r0
	switch (pdu_tx->llctrl.opcode) {
   3dfd6:	2b18      	cmp	r3, #24
   3dfd8:	d835      	bhi.n	3e046 <ull_conn_tx_ack+0x10a>
   3dfda:	e8df f013 	tbh	[pc, r3, lsl #1]
   3dfde:	00a3      	.short	0x00a3
   3dfe0:	00930034 	.word	0x00930034
   3dfe4:	015d0072 	.word	0x015d0072
   3dfe8:	01680059 	.word	0x01680059
   3dfec:	00340038 	.word	0x00340038
   3dff0:	00b80038 	.word	0x00b80038
   3dff4:	0034013d 	.word	0x0034013d
   3dff8:	00340064 	.word	0x00340064
   3dffc:	00340034 	.word	0x00340034
   3e000:	003400ae 	.word	0x003400ae
   3e004:	01010038 	.word	0x01010038
   3e008:	004200cd 	.word	0x004200cd
   3e00c:	0112011d 	.word	0x0112011d
		conn->tx_data_last = tx;
   3e010:	f8c7 41ec 	str.w	r4, [r7, #492]	; 0x1ec
		if (link->next == (void *)tx) {
   3e014:	6833      	ldr	r3, [r6, #0]
   3e016:	2b00      	cmp	r3, #0
   3e018:	f040 81a3 	bne.w	3e362 <ull_conn_tx_ack+0x426>
			LL_ASSERT(link->next);
   3e01c:	4a96      	ldr	r2, [pc, #600]	; (3e278 <ull_conn_tx_ack+0x33c>)
   3e01e:	499b      	ldr	r1, [pc, #620]	; (3e28c <ull_conn_tx_ack+0x350>)
   3e020:	4897      	ldr	r0, [pc, #604]	; (3e280 <ull_conn_tx_ack+0x344>)
   3e022:	f640 031c 	movw	r3, #2076	; 0x81c
   3e026:	f00b f82d 	bl	49084 <assert_print>
   3e02a:	4040      	eors	r0, r0
   3e02c:	f380 8811 	msr	BASEPRI, r0
   3e030:	f04f 0003 	mov.w	r0, #3
   3e034:	df02      	svc	2
   3e036:	2400      	movs	r4, #0
			mem_release(tx, &mem_conn_tx_ctrl.free);
   3e038:	4995      	ldr	r1, [pc, #596]	; (3e290 <ull_conn_tx_ack+0x354>)
   3e03a:	4620      	mov	r0, r4
}
   3e03c:	b003      	add	sp, #12
   3e03e:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
			mem_release(tx, &mem_conn_tx_ctrl.free);
   3e042:	f7f6 ba55 	b.w	344f0 <mem_release>
		if (link->next == (void *)tx) {
   3e046:	6833      	ldr	r3, [r6, #0]
   3e048:	429c      	cmp	r4, r3
   3e04a:	d198      	bne.n	3df7e <ull_conn_tx_ack+0x42>
   3e04c:	e7f4      	b.n	3e038 <ull_conn_tx_ack+0xfc>
		conn->common.txn_lock = 0U;
   3e04e:	f890 30e4 	ldrb.w	r3, [r0, #228]	; 0xe4
   3e052:	f36f 0341 	bfc	r3, #1, #1
   3e056:	f880 30e4 	strb.w	r3, [r0, #228]	; 0xe4
		if (link->next == (void *)tx) {
   3e05a:	6833      	ldr	r3, [r6, #0]
   3e05c:	42a3      	cmp	r3, r4
   3e05e:	d18e      	bne.n	3df7e <ull_conn_tx_ack+0x42>
   3e060:	e7ea      	b.n	3e038 <ull_conn_tx_ack+0xfc>
		conn->llcp_phy.state = LLCP_PHY_STATE_RSP_WAIT;
   3e062:	f890 31d6 	ldrb.w	r3, [r0, #470]	; 0x1d6
   3e066:	2202      	movs	r2, #2
   3e068:	f362 0301 	bfi	r3, r2, #0, #2
   3e06c:	f880 31d6 	strb.w	r3, [r0, #470]	; 0x1d6
		if (conn->lll.role) {
   3e070:	f990 3039 	ldrsb.w	r3, [r0, #57]	; 0x39
   3e074:	2b00      	cmp	r3, #0
   3e076:	f2c0 8131 	blt.w	3e2dc <ull_conn_tx_ack+0x3a0>
		conn->llcp_phy.pause_tx = 0U;
   3e07a:	f897 31d7 	ldrb.w	r3, [r7, #471]	; 0x1d7
   3e07e:	f36f 0300 	bfc	r3, #0, #1
   3e082:	f887 31d7 	strb.w	r3, [r7, #471]	; 0x1d7
		if (link->next == (void *)tx) {
   3e086:	6833      	ldr	r3, [r6, #0]
   3e088:	429c      	cmp	r4, r3
   3e08a:	f47f af78 	bne.w	3df7e <ull_conn_tx_ack+0x42>
   3e08e:	e7d3      	b.n	3e038 <ull_conn_tx_ack+0xfc>
			conn->llcp.encryption.state = LLCP_ENC_STATE_ENC_WAIT;
   3e090:	f897 3100 	ldrb.w	r3, [r7, #256]	; 0x100
   3e094:	f043 0303 	orr.w	r3, r3, #3
   3e098:	f887 3100 	strb.w	r3, [r7, #256]	; 0x100
		if (link->next == (void *)tx) {
   3e09c:	6833      	ldr	r3, [r6, #0]
   3e09e:	429c      	cmp	r4, r3
   3e0a0:	f47f af6d 	bne.w	3df7e <ull_conn_tx_ack+0x42>
   3e0a4:	e7c8      	b.n	3e038 <ull_conn_tx_ack+0xfc>
		conn->llcp_enc.pause_rx = 0U;
   3e0a6:	f897 3176 	ldrb.w	r3, [r7, #374]	; 0x176
   3e0aa:	f023 0303 	bic.w	r3, r3, #3
   3e0ae:	f887 3176 	strb.w	r3, [r7, #374]	; 0x176
		conn->procedure_expire = 0U;
   3e0b2:	2300      	movs	r3, #0
   3e0b4:	f8a7 30c8 	strh.w	r3, [r7, #200]	; 0xc8
		if (link->next == (void *)tx) {
   3e0b8:	6833      	ldr	r3, [r6, #0]
   3e0ba:	429c      	cmp	r4, r3
   3e0bc:	f47f af5f 	bne.w	3df7e <ull_conn_tx_ack+0x42>
   3e0c0:	e7ba      	b.n	3e038 <ull_conn_tx_ack+0xfc>
		memcpy(&conn->llcp.encryption.skd[0],
   3e0c2:	2208      	movs	r2, #8
   3e0c4:	f104 0112 	add.w	r1, r4, #18
   3e0c8:	f500 7081 	add.w	r0, r0, #258	; 0x102
   3e0cc:	f00c fed5 	bl	4ae7a <memcpy>
		memcpy(&conn->lll.ccm_rx.iv[0],
   3e0d0:	2204      	movs	r2, #4
   3e0d2:	f104 011a 	add.w	r1, r4, #26
   3e0d6:	f107 0094 	add.w	r0, r7, #148	; 0x94
   3e0da:	f00c fece 	bl	4ae7a <memcpy>
		conn->llcp_enc.pause_tx = 1U;
   3e0de:	f897 3176 	ldrb.w	r3, [r7, #374]	; 0x176
   3e0e2:	f043 0302 	orr.w	r3, r3, #2
   3e0e6:	f887 3176 	strb.w	r3, [r7, #374]	; 0x176
		conn->procedure_expire = conn->procedure_reload;
   3e0ea:	f8b7 30c6 	ldrh.w	r3, [r7, #198]	; 0xc6
   3e0ee:	f8a7 30c8 	strh.w	r3, [r7, #200]	; 0xc8
		conn->llcp_enc.ack = conn->llcp_enc.req;
   3e0f2:	f897 3174 	ldrb.w	r3, [r7, #372]	; 0x174
   3e0f6:	f887 3175 	strb.w	r3, [r7, #373]	; 0x175
		if (link->next == (void *)tx) {
   3e0fa:	6833      	ldr	r3, [r6, #0]
   3e0fc:	42a3      	cmp	r3, r4
   3e0fe:	f47f af3e 	bne.w	3df7e <ull_conn_tx_ack+0x42>
   3e102:	e799      	b.n	3e038 <ull_conn_tx_ack+0xfc>
		if (pdu_tx->llctrl.terminate_ind.error_code ==
   3e104:	7a23      	ldrb	r3, [r4, #8]
			conn->llcp_terminate.reason_final =
   3e106:	2b13      	cmp	r3, #19
   3e108:	bf08      	it	eq
   3e10a:	2316      	moveq	r3, #22
   3e10c:	f880 3153 	strb.w	r3, [r0, #339]	; 0x153
		conn->llcp_terminate.ack--;
   3e110:	f890 3151 	ldrb.w	r3, [r0, #337]	; 0x151
   3e114:	3b01      	subs	r3, #1
   3e116:	f880 3151 	strb.w	r3, [r0, #337]	; 0x151
		if (link->next == (void *)tx) {
   3e11a:	6833      	ldr	r3, [r6, #0]
   3e11c:	429c      	cmp	r4, r3
   3e11e:	f47f af2e 	bne.w	3df7e <ull_conn_tx_ack+0x42>
   3e122:	e789      	b.n	3e038 <ull_conn_tx_ack+0xfc>
		conn->llcp_cu.pause_tx = 0U;
   3e124:	f890 311a 	ldrb.w	r3, [r0, #282]	; 0x11a
   3e128:	f36f 1304 	bfc	r3, #4, #1
   3e12c:	f880 311a 	strb.w	r3, [r0, #282]	; 0x11a
		if (link->next == (void *)tx) {
   3e130:	6833      	ldr	r3, [r6, #0]
   3e132:	42a3      	cmp	r3, r4
   3e134:	f47f af23 	bne.w	3df7e <ull_conn_tx_ack+0x42>
   3e138:	e77e      	b.n	3e038 <ull_conn_tx_ack+0xfc>
		if (pdu_tx->llctrl.reject_ext_ind.reject_opcode !=
   3e13a:	7a23      	ldrb	r3, [r4, #8]
   3e13c:	2b03      	cmp	r3, #3
   3e13e:	d0b2      	beq.n	3e0a6 <ull_conn_tx_ack+0x16a>
			conn->common.txn_lock = 0U;
   3e140:	f890 30e4 	ldrb.w	r3, [r0, #228]	; 0xe4
   3e144:	f36f 0341 	bfc	r3, #1, #1
   3e148:	f880 30e4 	strb.w	r3, [r0, #228]	; 0xe4
		if (link->next == (void *)tx) {
   3e14c:	e714      	b.n	3df78 <ull_conn_tx_ack+0x3c>
		conn->llcp_enc.pause_tx = 1U;
   3e14e:	f890 3176 	ldrb.w	r3, [r0, #374]	; 0x176
   3e152:	f023 0306 	bic.w	r3, r3, #6
   3e156:	f043 0306 	orr.w	r3, r3, #6
   3e15a:	f880 3176 	strb.w	r3, [r0, #374]	; 0x176
		conn->procedure_expire = conn->procedure_reload;
   3e15e:	f8b0 30c6 	ldrh.w	r3, [r0, #198]	; 0xc6
   3e162:	f8a0 30c8 	strh.w	r3, [r0, #200]	; 0xc8
		conn->llcp_enc.ack = conn->llcp_enc.req;
   3e166:	f890 3174 	ldrb.w	r3, [r0, #372]	; 0x174
   3e16a:	f880 3175 	strb.w	r3, [r0, #373]	; 0x175
		if (link->next == (void *)tx) {
   3e16e:	6833      	ldr	r3, [r6, #0]
   3e170:	429c      	cmp	r4, r3
   3e172:	f47f af04 	bne.w	3df7e <ull_conn_tx_ack+0x42>
   3e176:	e75f      	b.n	3e038 <ull_conn_tx_ack+0xfc>
		conn->common.txn_lock = 0U;
   3e178:	f890 30e4 	ldrb.w	r3, [r0, #228]	; 0xe4
		if (conn->llcp_length.req != conn->llcp_length.ack) {
   3e17c:	f890 11c4 	ldrb.w	r1, [r0, #452]	; 0x1c4
		conn->common.txn_lock = 0U;
   3e180:	f36f 0341 	bfc	r3, #1, #1
   3e184:	f880 30e4 	strb.w	r3, [r0, #228]	; 0xe4
		if (conn->llcp_length.req != conn->llcp_length.ack) {
   3e188:	f890 31c5 	ldrb.w	r3, [r0, #453]	; 0x1c5
   3e18c:	428b      	cmp	r3, r1
   3e18e:	f43f af5a 	beq.w	3e046 <ull_conn_tx_ack+0x10a>
			switch (conn->llcp_length.state) {
   3e192:	f890 21c6 	ldrb.w	r2, [r0, #454]	; 0x1c6
   3e196:	f002 0307 	and.w	r3, r2, #7
   3e19a:	2b03      	cmp	r3, #3
   3e19c:	d005      	beq.n	3e1aa <ull_conn_tx_ack+0x26e>
   3e19e:	3303      	adds	r3, #3
   3e1a0:	f003 0307 	and.w	r3, r3, #7
   3e1a4:	2b01      	cmp	r3, #1
   3e1a6:	f63f af4e 	bhi.w	3e046 <ull_conn_tx_ack+0x10a>
				conn->lll.max_tx_octets =
   3e1aa:	f8b7 31ca 	ldrh.w	r3, [r7, #458]	; 0x1ca
   3e1ae:	f8a7 3058 	strh.w	r3, [r7, #88]	; 0x58
				conn->lll.max_tx_time =
   3e1b2:	f8b7 31ce 	ldrh.w	r3, [r7, #462]	; 0x1ce
   3e1b6:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
				if (conn->llcp_length.state ==
   3e1ba:	f002 0307 	and.w	r3, r2, #7
   3e1be:	2b05      	cmp	r3, #5
   3e1c0:	f000 80ed 	beq.w	3e39e <ull_conn_tx_ack+0x462>
				if (!conn->llcp_length.cache.tx_octets) {
   3e1c4:	f8b7 31d0 	ldrh.w	r3, [r7, #464]	; 0x1d0
   3e1c8:	2b00      	cmp	r3, #0
   3e1ca:	f040 80d6 	bne.w	3e37a <ull_conn_tx_ack+0x43e>
					conn->llcp_length.ack =
   3e1ce:	f887 11c5 	strb.w	r1, [r7, #453]	; 0x1c5
					conn->procedure_expire = 0U;
   3e1d2:	f8a7 30c8 	strh.w	r3, [r7, #200]	; 0xc8
		if (link->next == (void *)tx) {
   3e1d6:	6833      	ldr	r3, [r6, #0]
   3e1d8:	429c      	cmp	r4, r3
   3e1da:	f47f aed0 	bne.w	3df7e <ull_conn_tx_ack+0x42>
   3e1de:	e72b      	b.n	3e038 <ull_conn_tx_ack+0xfc>
		if (conn->llcp_length.state == LLCP_LENGTH_STATE_REQ_ACK_WAIT) {
   3e1e0:	f890 31c6 	ldrb.w	r3, [r0, #454]	; 0x1c6
   3e1e4:	f003 0207 	and.w	r2, r3, #7
   3e1e8:	2a01      	cmp	r2, #1
   3e1ea:	f47f aec5 	bne.w	3df78 <ull_conn_tx_ack+0x3c>
			conn->llcp_length.state = LLCP_LENGTH_STATE_RSP_WAIT;
   3e1ee:	2202      	movs	r2, #2
   3e1f0:	f362 0302 	bfi	r3, r2, #0, #3
   3e1f4:	f880 31c6 	strb.w	r3, [r0, #454]	; 0x1c6
		if (link->next == (void *)tx) {
   3e1f8:	6833      	ldr	r3, [r6, #0]
   3e1fa:	429c      	cmp	r4, r3
   3e1fc:	f47f aebf 	bne.w	3df7e <ull_conn_tx_ack+0x42>
   3e200:	e71a      	b.n	3e038 <ull_conn_tx_ack+0xfc>
		conn->lll.phy_tx_time = conn->llcp.phy_upd_ind.tx;
   3e202:	f890 30f4 	ldrb.w	r3, [r0, #244]	; 0xf4
   3e206:	f890 2060 	ldrb.w	r2, [r0, #96]	; 0x60
   3e20a:	f3c3 0382 	ubfx	r3, r3, #2, #3
			lll->phy_tx_time = phy_tx_time[phys];
   3e20e:	f363 1206 	bfi	r2, r3, #4, #3
   3e212:	f887 2060 	strb.w	r2, [r7, #96]	; 0x60
   3e216:	e730      	b.n	3e07a <ull_conn_tx_ack+0x13e>
		if (conn->lll.role) {
   3e218:	f990 2039 	ldrsb.w	r2, [r0, #57]	; 0x39
   3e21c:	2a00      	cmp	r2, #0
   3e21e:	f6bf af2c 	bge.w	3e07a <ull_conn_tx_ack+0x13e>
			uint8_t phy_tx_time[8] = {PHY_1M, PHY_1M, PHY_2M,
   3e222:	4a1c      	ldr	r2, [pc, #112]	; (3e294 <ull_conn_tx_ack+0x358>)
   3e224:	e892 0003 	ldmia.w	r2, {r0, r1}
			if (pdu_tx->llctrl.opcode ==
   3e228:	2b17      	cmp	r3, #23
			uint8_t phy_tx_time[8] = {PHY_1M, PHY_1M, PHY_2M,
   3e22a:	aa02      	add	r2, sp, #8
   3e22c:	e902 0003 	stmdb	r2, {r0, r1}
			if (pdu_tx->llctrl.opcode ==
   3e230:	d105      	bne.n	3e23e <ull_conn_tx_ack+0x302>
				conn->common.txn_lock = 0U;
   3e232:	f897 30e4 	ldrb.w	r3, [r7, #228]	; 0xe4
   3e236:	f36f 0341 	bfc	r3, #1, #1
   3e23a:	f887 30e4 	strb.w	r3, [r7, #228]	; 0xe4
			phys = conn->llcp_phy.tx | lll->phy_tx;
   3e23e:	f897 31d6 	ldrb.w	r3, [r7, #470]	; 0x1d6
   3e242:	f897 2060 	ldrb.w	r2, [r7, #96]	; 0x60
   3e246:	ea42 0393 	orr.w	r3, r2, r3, lsr #2
			lll->phy_tx_time = phy_tx_time[phys];
   3e24a:	f003 0307 	and.w	r3, r3, #7
   3e24e:	3308      	adds	r3, #8
   3e250:	446b      	add	r3, sp
   3e252:	f813 3c08 	ldrb.w	r3, [r3, #-8]
   3e256:	e7da      	b.n	3e20e <ull_conn_tx_ack+0x2d2>
		if (!conn->lll.role) {
   3e258:	f990 3039 	ldrsb.w	r3, [r0, #57]	; 0x39
   3e25c:	2b00      	cmp	r3, #0
   3e25e:	da3f      	bge.n	3e2e0 <ull_conn_tx_ack+0x3a4>
			conn->llcp_enc.pause_tx = 1U;
   3e260:	f890 3176 	ldrb.w	r3, [r0, #374]	; 0x176
   3e264:	f043 0302 	orr.w	r3, r3, #2
   3e268:	f880 3176 	strb.w	r3, [r0, #374]	; 0x176
		if (link->next == (void *)tx) {
   3e26c:	6833      	ldr	r3, [r6, #0]
   3e26e:	429c      	cmp	r4, r3
   3e270:	f47f ae85 	bne.w	3df7e <ull_conn_tx_ack+0x42>
   3e274:	e6e0      	b.n	3e038 <ull_conn_tx_ack+0xfc>
   3e276:	bf00      	nop
   3e278:	0005269c 	.word	0x0005269c
   3e27c:	0005286c 	.word	0x0005286c
   3e280:	0005214c 	.word	0x0005214c
   3e284:	00052854 	.word	0x00052854
   3e288:	200028e8 	.word	0x200028e8
   3e28c:	00052860 	.word	0x00052860
   3e290:	20005384 	.word	0x20005384
   3e294:	00052878 	.word	0x00052878
		conn->llcp_enc.pause_tx = 1U;
   3e298:	f890 3176 	ldrb.w	r3, [r0, #374]	; 0x176
   3e29c:	f043 0302 	orr.w	r3, r3, #2
   3e2a0:	f880 3176 	strb.w	r3, [r0, #374]	; 0x176
		if (link->next == (void *)tx) {
   3e2a4:	6833      	ldr	r3, [r6, #0]
   3e2a6:	42a3      	cmp	r3, r4
   3e2a8:	f47f ae69 	bne.w	3df7e <ull_conn_tx_ack+0x42>
   3e2ac:	e6c4      	b.n	3e038 <ull_conn_tx_ack+0xfc>
		if (conn->lll.role) {
   3e2ae:	f990 3039 	ldrsb.w	r3, [r0, #57]	; 0x39
   3e2b2:	2b00      	cmp	r3, #0
   3e2b4:	f6bf aeec 	bge.w	3e090 <ull_conn_tx_ack+0x154>
			conn->llcp_enc.pause_rx = 0U;
   3e2b8:	f890 3176 	ldrb.w	r3, [r0, #374]	; 0x176
   3e2bc:	f023 0303 	bic.w	r3, r3, #3
   3e2c0:	f880 3176 	strb.w	r3, [r0, #374]	; 0x176
			conn->procedure_expire = 0U;
   3e2c4:	2300      	movs	r3, #0
   3e2c6:	f8a0 30c8 	strh.w	r3, [r0, #200]	; 0xc8
			conn->llcp_ack = conn->llcp_req;
   3e2ca:	f890 30f0 	ldrb.w	r3, [r0, #240]	; 0xf0
   3e2ce:	f880 30f1 	strb.w	r3, [r0, #241]	; 0xf1
		if (link->next == (void *)tx) {
   3e2d2:	6833      	ldr	r3, [r6, #0]
   3e2d4:	429c      	cmp	r4, r3
   3e2d6:	f47f ae52 	bne.w	3df7e <ull_conn_tx_ack+0x42>
   3e2da:	e6ad      	b.n	3e038 <ull_conn_tx_ack+0xfc>
   3e2dc:	79e3      	ldrb	r3, [r4, #7]
   3e2de:	e7a0      	b.n	3e222 <ull_conn_tx_ack+0x2e6>
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   3e2e0:	7923      	ldrb	r3, [r4, #4]
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, enc_req) +
   3e2e2:	2217      	movs	r2, #23
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   3e2e4:	f043 0303 	orr.w	r3, r3, #3
   3e2e8:	7123      	strb	r3, [r4, #4]
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, enc_req) +
   3e2ea:	7162      	strb	r2, [r4, #5]
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_ENC_REQ;
   3e2ec:	2303      	movs	r3, #3
	memcpy(&pdu_ctrl_tx->llctrl.enc_req.rand[0], &conn->llcp_enc.rand[0],
   3e2ee:	2208      	movs	r2, #8
   3e2f0:	f200 1179 	addw	r1, r0, #377	; 0x179
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_ENC_REQ;
   3e2f4:	71e3      	strb	r3, [r4, #7]
	memcpy(&pdu_ctrl_tx->llctrl.enc_req.rand[0], &conn->llcp_enc.rand[0],
   3e2f6:	18a0      	adds	r0, r4, r2
   3e2f8:	f00c fdbf 	bl	4ae7a <memcpy>
	pdu_ctrl_tx->llctrl.enc_req.ediv[0] = conn->llcp_enc.ediv[0];
   3e2fc:	f897 3177 	ldrb.w	r3, [r7, #375]	; 0x177
   3e300:	7423      	strb	r3, [r4, #16]
	pdu_ctrl_tx->llctrl.enc_req.ediv[1] = conn->llcp_enc.ediv[1];
   3e302:	f897 3178 	ldrb.w	r3, [r7, #376]	; 0x178
   3e306:	7463      	strb	r3, [r4, #17]
	lll_csrand_isr_get(pdu_ctrl_tx->llctrl.enc_req.skdm,
   3e308:	210c      	movs	r1, #12
   3e30a:	f104 0012 	add.w	r0, r4, #18
   3e30e:	f001 f96d 	bl	3f5ec <lll_csrand_isr_get>
	    conn->tx_head &&
   3e312:	f8d7 31dc 	ldr.w	r3, [r7, #476]	; 0x1dc
	if (
   3e316:	b333      	cbz	r3, 3e366 <ull_conn_tx_ack+0x42a>
	    !conn->llcp_cu.pause_tx &&
   3e318:	f897 211a 	ldrb.w	r2, [r7, #282]	; 0x11a
	    conn->tx_head &&
   3e31c:	06d0      	lsls	r0, r2, #27
   3e31e:	d422      	bmi.n	3e366 <ull_conn_tx_ack+0x42a>
	    !conn->llcp_enc.pause_tx &&
   3e320:	f897 2176 	ldrb.w	r2, [r7, #374]	; 0x176
	    !conn->llcp_cu.pause_tx &&
   3e324:	0791      	lsls	r1, r2, #30
   3e326:	d41e      	bmi.n	3e366 <ull_conn_tx_ack+0x42a>
	    !conn->llcp_phy.pause_tx &&
   3e328:	f897 21d7 	ldrb.w	r2, [r7, #471]	; 0x1d7
   3e32c:	07d2      	lsls	r2, r2, #31
   3e32e:	d41a      	bmi.n	3e366 <ull_conn_tx_ack+0x42a>
		if (conn->tx_head == conn->tx_data) {
   3e330:	f8d7 11e8 	ldr.w	r1, [r7, #488]	; 0x1e8
		if (!conn->tx_ctrl) {
   3e334:	f8d7 21e0 	ldr.w	r2, [r7, #480]	; 0x1e0
		if (conn->tx_head == conn->tx_data) {
   3e338:	428b      	cmp	r3, r1
   3e33a:	d03a      	beq.n	3e3b2 <ull_conn_tx_ack+0x476>
		} else if (!conn->tx_ctrl) {
   3e33c:	2a00      	cmp	r2, #0
   3e33e:	d045      	beq.n	3e3cc <ull_conn_tx_ack+0x490>
	tx->next = conn->tx_ctrl_last->next;
   3e340:	f8d7 31e4 	ldr.w	r3, [r7, #484]	; 0x1e4
   3e344:	681b      	ldr	r3, [r3, #0]
   3e346:	6023      	str	r3, [r4, #0]
	conn->tx_ctrl_last->next = tx;
   3e348:	f8d7 31e4 	ldr.w	r3, [r7, #484]	; 0x1e4
   3e34c:	601c      	str	r4, [r3, #0]
	conn->tx_ctrl_last = tx;
   3e34e:	f8c7 41e4 	str.w	r4, [r7, #484]	; 0x1e4
	if (!tx->next) {
   3e352:	6823      	ldr	r3, [r4, #0]
   3e354:	2b00      	cmp	r3, #0
   3e356:	f43f ae5b 	beq.w	3e010 <ull_conn_tx_ack+0xd4>
		if (link->next == (void *)tx) {
   3e35a:	6833      	ldr	r3, [r6, #0]
   3e35c:	2b00      	cmp	r3, #0
   3e35e:	f43f ae5d 	beq.w	3e01c <ull_conn_tx_ack+0xe0>
}
   3e362:	b003      	add	sp, #12
   3e364:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (!conn->tx_ctrl) {
   3e366:	f8d7 21e0 	ldr.w	r2, [r7, #480]	; 0x1e0
   3e36a:	2a00      	cmp	r2, #0
   3e36c:	d1e8      	bne.n	3e340 <ull_conn_tx_ack+0x404>
			tx->next = conn->tx_head;
   3e36e:	6023      	str	r3, [r4, #0]
			conn->tx_head = tx;
   3e370:	f8c7 41dc 	str.w	r4, [r7, #476]	; 0x1dc
   3e374:	f8c7 41e0 	str.w	r4, [r7, #480]	; 0x1e0
				conn->tx_ctrl_last = tx;
   3e378:	e7e9      	b.n	3e34e <ull_conn_tx_ack+0x412>
				conn->llcp_length.tx_octets =
   3e37a:	f8a7 31ca 	strh.w	r3, [r7, #458]	; 0x1ca
				conn->llcp_length.cache.tx_octets = 0U;
   3e37e:	2300      	movs	r3, #0
				conn->llcp_length.state = LLCP_LENGTH_STATE_REQ;
   3e380:	f363 0202 	bfi	r2, r3, #0, #3
				conn->llcp_length.cache.tx_octets = 0U;
   3e384:	f8a7 31d0 	strh.w	r3, [r7, #464]	; 0x1d0
				conn->llcp_length.tx_time =
   3e388:	f8b7 31d2 	ldrh.w	r3, [r7, #466]	; 0x1d2
				conn->llcp_length.state = LLCP_LENGTH_STATE_REQ;
   3e38c:	f887 21c6 	strb.w	r2, [r7, #454]	; 0x1c6
				conn->llcp_length.tx_time =
   3e390:	f8a7 31ce 	strh.w	r3, [r7, #462]	; 0x1ce
		if (link->next == (void *)tx) {
   3e394:	6833      	ldr	r3, [r6, #0]
   3e396:	429c      	cmp	r4, r3
   3e398:	f47f adf1 	bne.w	3df7e <ull_conn_tx_ack+0x42>
   3e39c:	e64c      	b.n	3e038 <ull_conn_tx_ack+0xfc>
					conn->llcp_length.state =
   3e39e:	2304      	movs	r3, #4
   3e3a0:	f363 0202 	bfi	r2, r3, #0, #3
   3e3a4:	f887 21c6 	strb.w	r2, [r7, #454]	; 0x1c6
		if (link->next == (void *)tx) {
   3e3a8:	6833      	ldr	r3, [r6, #0]
   3e3aa:	429c      	cmp	r4, r3
   3e3ac:	f47f ade7 	bne.w	3df7e <ull_conn_tx_ack+0x42>
   3e3b0:	e642      	b.n	3e038 <ull_conn_tx_ack+0xfc>
			conn->tx_data = conn->tx_data->next;
   3e3b2:	6819      	ldr	r1, [r3, #0]
   3e3b4:	f8c7 11e8 	str.w	r1, [r7, #488]	; 0x1e8
		if (!conn->tx_ctrl) {
   3e3b8:	2a00      	cmp	r2, #0
   3e3ba:	d1c1      	bne.n	3e340 <ull_conn_tx_ack+0x404>
			tx->next = conn->tx_head->next;
   3e3bc:	681b      	ldr	r3, [r3, #0]
   3e3be:	6023      	str	r3, [r4, #0]
			conn->tx_head->next = tx;
   3e3c0:	f8d7 31dc 	ldr.w	r3, [r7, #476]	; 0x1dc
   3e3c4:	601c      	str	r4, [r3, #0]
				conn->tx_ctrl = tx;
   3e3c6:	f8c7 41e0 	str.w	r4, [r7, #480]	; 0x1e0
				conn->tx_ctrl_last = tx;
   3e3ca:	e7c0      	b.n	3e34e <ull_conn_tx_ack+0x412>
	if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   3e3cc:	791a      	ldrb	r2, [r3, #4]
   3e3ce:	f002 0203 	and.w	r2, r2, #3
   3e3d2:	2a03      	cmp	r2, #3
   3e3d4:	d002      	beq.n	3e3dc <ull_conn_tx_ack+0x4a0>
		conn->tx_ctrl = conn->tx_ctrl_last = conn->tx_head;
   3e3d6:	e9c7 3378 	strd	r3, r3, [r7, #480]	; 0x1e0
   3e3da:	e7b1      	b.n	3e340 <ull_conn_tx_ack+0x404>
	    ((pdu_data_tx->llctrl.opcode !=
   3e3dc:	79da      	ldrb	r2, [r3, #7]
	if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   3e3de:	2a03      	cmp	r2, #3
   3e3e0:	d0ec      	beq.n	3e3bc <ull_conn_tx_ack+0x480>
	      PDU_DATA_LLCTRL_TYPE_ENC_REQ) &&
   3e3e2:	2a0a      	cmp	r2, #10
   3e3e4:	d1f7      	bne.n	3e3d6 <ull_conn_tx_ack+0x49a>
   3e3e6:	e7e9      	b.n	3e3bc <ull_conn_tx_ack+0x480>

0003e3e8 <ull_conn_llcp_req>:
	if (conn_hdr->llcp_req != conn_hdr->llcp_ack) {
   3e3e8:	f890 30f1 	ldrb.w	r3, [r0, #241]	; 0xf1
   3e3ec:	f890 20f0 	ldrb.w	r2, [r0, #240]	; 0xf0
   3e3f0:	4293      	cmp	r3, r2
	conn_hdr->llcp_req++;
   3e3f2:	bf03      	ittte	eq
   3e3f4:	3301      	addeq	r3, #1
   3e3f6:	f880 30f0 	strbeq.w	r3, [r0, #240]	; 0xf0
	return 0;
   3e3fa:	2000      	moveq	r0, #0
		return BT_HCI_ERR_CMD_DISALLOWED;
   3e3fc:	200c      	movne	r0, #12
}
   3e3fe:	4770      	bx	lr

0003e400 <ull_conn_lll_max_tx_octets_get>:
	switch (lll->phy_tx_time) {
   3e400:	f890 2044 	ldrb.w	r2, [r0, #68]	; 0x44
		max_tx_octets = (lll->max_tx_time >> 3) - 10;
   3e404:	f8b0 3040 	ldrh.w	r3, [r0, #64]	; 0x40
	switch (lll->phy_tx_time) {
   3e408:	f3c2 1202 	ubfx	r2, r2, #4, #3
   3e40c:	2a02      	cmp	r2, #2
		max_tx_octets = (lll->max_tx_time >> 3) - 10;
   3e40e:	bf14      	ite	ne
   3e410:	08db      	lsrne	r3, r3, #3
		max_tx_octets = (lll->max_tx_time >> 2) - 11;
   3e412:	089b      	lsreq	r3, r3, #2
	if (lll->enc_tx) {
   3e414:	f890 205e 	ldrb.w	r2, [r0, #94]	; 0x5e
	return max_tx_octets;
   3e418:	8f80      	ldrh	r0, [r0, #60]	; 0x3c
		max_tx_octets = (lll->max_tx_time >> 3) - 10;
   3e41a:	bf14      	ite	ne
   3e41c:	3b0a      	subne	r3, #10
		max_tx_octets = (lll->max_tx_time >> 2) - 11;
   3e41e:	3b0b      	subeq	r3, #11
   3e420:	b29b      	uxth	r3, r3
	if (lll->enc_tx) {
   3e422:	06d2      	lsls	r2, r2, #27
		max_tx_octets -= 4U;
   3e424:	bf44      	itt	mi
   3e426:	3b04      	submi	r3, #4
   3e428:	b29b      	uxthmi	r3, r3
}
   3e42a:	4298      	cmp	r0, r3
   3e42c:	bf28      	it	cs
   3e42e:	4618      	movcs	r0, r3
   3e430:	4770      	bx	lr
   3e432:	bf00      	nop

0003e434 <ull_pdu_data_init>:
}
   3e434:	4770      	bx	lr
   3e436:	bf00      	nop

0003e438 <ticker_update_latency_cancel_op_cb>:
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
}

static void ticker_update_latency_cancel_op_cb(uint32_t ticker_status,
					       void *param)
{
   3e438:	b510      	push	{r4, lr}
   3e43a:	460c      	mov	r4, r1
	struct ll_conn *conn = param;

	LL_ASSERT(ticker_status == TICKER_STATUS_SUCCESS);
   3e43c:	b930      	cbnz	r0, 3e44c <ticker_update_latency_cancel_op_cb+0x14>

	conn->periph.latency_cancel = 0U;
   3e43e:	f894 30e4 	ldrb.w	r3, [r4, #228]	; 0xe4
   3e442:	f36f 0382 	bfc	r3, #2, #1
   3e446:	f884 30e4 	strb.w	r3, [r4, #228]	; 0xe4
}
   3e44a:	bd10      	pop	{r4, pc}
	LL_ASSERT(ticker_status == TICKER_STATUS_SUCCESS);
   3e44c:	4a09      	ldr	r2, [pc, #36]	; (3e474 <ticker_update_latency_cancel_op_cb+0x3c>)
   3e44e:	490a      	ldr	r1, [pc, #40]	; (3e478 <ticker_update_latency_cancel_op_cb+0x40>)
   3e450:	480a      	ldr	r0, [pc, #40]	; (3e47c <ticker_update_latency_cancel_op_cb+0x44>)
   3e452:	f240 23b1 	movw	r3, #689	; 0x2b1
   3e456:	f00a fe15 	bl	49084 <assert_print>
   3e45a:	4040      	eors	r0, r0
   3e45c:	f380 8811 	msr	BASEPRI, r0
   3e460:	f04f 0003 	mov.w	r0, #3
   3e464:	df02      	svc	2
	conn->periph.latency_cancel = 0U;
   3e466:	f894 30e4 	ldrb.w	r3, [r4, #228]	; 0xe4
   3e46a:	f36f 0382 	bfc	r3, #2, #1
   3e46e:	f884 30e4 	strb.w	r3, [r4, #228]	; 0xe4
}
   3e472:	bd10      	pop	{r4, pc}
   3e474:	000528b4 	.word	0x000528b4
   3e478:	000528fc 	.word	0x000528fc
   3e47c:	0005214c 	.word	0x0005214c

0003e480 <ticker_op_cb>:
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
   3e480:	b900      	cbnz	r0, 3e484 <ticker_op_cb+0x4>
   3e482:	4770      	bx	lr
{
   3e484:	b508      	push	{r3, lr}
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
   3e486:	4a07      	ldr	r2, [pc, #28]	; (3e4a4 <ticker_op_cb+0x24>)
   3e488:	4907      	ldr	r1, [pc, #28]	; (3e4a8 <ticker_op_cb+0x28>)
   3e48a:	4808      	ldr	r0, [pc, #32]	; (3e4ac <ticker_op_cb+0x2c>)
   3e48c:	f240 23a9 	movw	r3, #681	; 0x2a9
   3e490:	f00a fdf8 	bl	49084 <assert_print>
   3e494:	4040      	eors	r0, r0
   3e496:	f380 8811 	msr	BASEPRI, r0
   3e49a:	f04f 0003 	mov.w	r0, #3
   3e49e:	df02      	svc	2
}
   3e4a0:	bd08      	pop	{r3, pc}
   3e4a2:	bf00      	nop
   3e4a4:	000528b4 	.word	0x000528b4
   3e4a8:	000526fc 	.word	0x000526fc
   3e4ac:	0005214c 	.word	0x0005214c

0003e4b0 <ticker_op_stop_adv_cb>:
	LL_ASSERT(status != TICKER_STATUS_FAILURE ||
   3e4b0:	2801      	cmp	r0, #1
   3e4b2:	d000      	beq.n	3e4b6 <ticker_op_stop_adv_cb+0x6>
   3e4b4:	4770      	bx	lr
{
   3e4b6:	b510      	push	{r4, lr}
   3e4b8:	460c      	mov	r4, r1
	LL_ASSERT(status != TICKER_STATUS_FAILURE ||
   3e4ba:	f7f9 fd43 	bl	37f44 <ull_disable_mark_get>
   3e4be:	4284      	cmp	r4, r0
   3e4c0:	d00c      	beq.n	3e4dc <ticker_op_stop_adv_cb+0x2c>
   3e4c2:	4a07      	ldr	r2, [pc, #28]	; (3e4e0 <ticker_op_stop_adv_cb+0x30>)
   3e4c4:	4907      	ldr	r1, [pc, #28]	; (3e4e4 <ticker_op_stop_adv_cb+0x34>)
   3e4c6:	4808      	ldr	r0, [pc, #32]	; (3e4e8 <ticker_op_stop_adv_cb+0x38>)
   3e4c8:	f240 23a1 	movw	r3, #673	; 0x2a1
   3e4cc:	f00a fdda 	bl	49084 <assert_print>
   3e4d0:	4040      	eors	r0, r0
   3e4d2:	f380 8811 	msr	BASEPRI, r0
   3e4d6:	f04f 0003 	mov.w	r0, #3
   3e4da:	df02      	svc	2
}
   3e4dc:	bd10      	pop	{r4, pc}
   3e4de:	bf00      	nop
   3e4e0:	000528b4 	.word	0x000528b4
   3e4e4:	00052910 	.word	0x00052910
   3e4e8:	0005214c 	.word	0x0005214c

0003e4ec <ull_periph_ticker_cb>:
{
   3e4ec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   3e4f0:	9c07      	ldr	r4, [sp, #28]
   3e4f2:	f89d 8018 	ldrb.w	r8, [sp, #24]
	if (unlikely(conn->lll.handle == 0xFFFF)) {
   3e4f6:	8d21      	ldrh	r1, [r4, #40]	; 0x28
{
   3e4f8:	461d      	mov	r5, r3
	if (unlikely(conn->lll.handle == 0xFFFF)) {
   3e4fa:	f64f 73ff 	movw	r3, #65535	; 0xffff
   3e4fe:	4299      	cmp	r1, r3
   3e500:	d026      	beq.n	3e550 <ull_periph_ticker_cb+0x64>
		ret = ull_conn_llcp(conn, ticks_at_expire, lazy);
   3e502:	4606      	mov	r6, r0
   3e504:	4617      	mov	r7, r2
   3e506:	4601      	mov	r1, r0
   3e508:	462a      	mov	r2, r5
   3e50a:	4620      	mov	r0, r4
   3e50c:	f7fd fe3a 	bl	3c184 <ull_conn_llcp>
		if (ret) {
   3e510:	b9f0      	cbnz	r0, 3e550 <ull_periph_ticker_cb+0x64>
	return ++hdr->ref;
   3e512:	7823      	ldrb	r3, [r4, #0]
   3e514:	3301      	adds	r3, #1
   3e516:	b2db      	uxtb	r3, r3
   3e518:	7023      	strb	r3, [r4, #0]
	LL_ASSERT(ref);
   3e51a:	b34b      	cbz	r3, 3e570 <ull_periph_ticker_cb+0x84>
	p.ticks_at_expire = ticks_at_expire;
   3e51c:	491b      	ldr	r1, [pc, #108]	; (3e58c <ull_periph_ticker_cb+0xa0>)
	mfy.param = &p;
   3e51e:	4b1c      	ldr	r3, [pc, #112]	; (3e590 <ull_periph_ticker_cb+0xa4>)
	p.lazy = lazy;
   3e520:	810d      	strh	r5, [r1, #8]
	p.param = &conn->lll;
   3e522:	f104 001c 	add.w	r0, r4, #28
	err = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
   3e526:	2200      	movs	r2, #0
	p.param = &conn->lll;
   3e528:	60c8      	str	r0, [r1, #12]
	p.remainder = remainder;
   3e52a:	e9c1 6700 	strd	r6, r7, [r1]
	p.force = force;
   3e52e:	f881 800a 	strb.w	r8, [r1, #10]
	mfy.param = &p;
   3e532:	6099      	str	r1, [r3, #8]
	err = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
   3e534:	2001      	movs	r0, #1
   3e536:	4611      	mov	r1, r2
   3e538:	f7f6 f89a 	bl	34670 <mayfly_enqueue>
	LL_ASSERT(!err);
   3e53c:	b950      	cbnz	r0, 3e554 <ull_periph_ticker_cb+0x68>
	ull_conn_tx_demux(UINT8_MAX);
   3e53e:	20ff      	movs	r0, #255	; 0xff
   3e540:	f7ff f8ec 	bl	3d71c <ull_conn_tx_demux>
	ull_conn_tx_lll_enqueue(conn, UINT8_MAX);
   3e544:	4620      	mov	r0, r4
   3e546:	21ff      	movs	r1, #255	; 0xff
}
   3e548:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	ull_conn_tx_lll_enqueue(conn, UINT8_MAX);
   3e54c:	f7ff bb62 	b.w	3dc14 <ull_conn_tx_lll_enqueue>
}
   3e550:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	LL_ASSERT(!err);
   3e554:	4a0f      	ldr	r2, [pc, #60]	; (3e594 <ull_periph_ticker_cb+0xa8>)
   3e556:	4910      	ldr	r1, [pc, #64]	; (3e598 <ull_periph_ticker_cb+0xac>)
   3e558:	4810      	ldr	r0, [pc, #64]	; (3e59c <ull_periph_ticker_cb+0xb0>)
   3e55a:	f44f 730e 	mov.w	r3, #568	; 0x238
   3e55e:	f00a fd91 	bl	49084 <assert_print>
   3e562:	4040      	eors	r0, r0
   3e564:	f380 8811 	msr	BASEPRI, r0
   3e568:	f04f 0003 	mov.w	r0, #3
   3e56c:	df02      	svc	2
   3e56e:	e7e6      	b.n	3e53e <ull_periph_ticker_cb+0x52>
	LL_ASSERT(ref);
   3e570:	4a08      	ldr	r2, [pc, #32]	; (3e594 <ull_periph_ticker_cb+0xa8>)
   3e572:	490b      	ldr	r1, [pc, #44]	; (3e5a0 <ull_periph_ticker_cb+0xb4>)
   3e574:	4809      	ldr	r0, [pc, #36]	; (3e59c <ull_periph_ticker_cb+0xb0>)
   3e576:	f240 232b 	movw	r3, #555	; 0x22b
   3e57a:	f00a fd83 	bl	49084 <assert_print>
   3e57e:	4040      	eors	r0, r0
   3e580:	f380 8811 	msr	BASEPRI, r0
   3e584:	f04f 0003 	mov.w	r0, #3
   3e588:	df02      	svc	2
   3e58a:	e7c7      	b.n	3e51c <ull_periph_ticker_cb+0x30>
   3e58c:	200058fc 	.word	0x200058fc
   3e590:	20000c5c 	.word	0x20000c5c
   3e594:	000528b4 	.word	0x000528b4
   3e598:	00052330 	.word	0x00052330
   3e59c:	0005214c 	.word	0x0005214c
   3e5a0:	000525c8 	.word	0x000525c8

0003e5a4 <ull_periph_latency_cancel>:
	if (conn->lll.latency_event && !conn->periph.latency_cancel) {
   3e5a4:	8e03      	ldrh	r3, [r0, #48]	; 0x30
   3e5a6:	b123      	cbz	r3, 3e5b2 <ull_periph_latency_cancel+0xe>
   3e5a8:	f890 20e4 	ldrb.w	r2, [r0, #228]	; 0xe4
   3e5ac:	f012 0304 	ands.w	r3, r2, #4
   3e5b0:	d000      	beq.n	3e5b4 <ull_periph_latency_cancel+0x10>
   3e5b2:	4770      	bx	lr
{
   3e5b4:	b510      	push	{r4, lr}
		conn->periph.latency_cancel = 1U;
   3e5b6:	f042 0204 	orr.w	r2, r2, #4
{
   3e5ba:	b088      	sub	sp, #32
			ticker_update(TICKER_INSTANCE_ID_CTLR,
   3e5bc:	4c11      	ldr	r4, [pc, #68]	; (3e604 <ull_periph_latency_cancel+0x60>)
		conn->periph.latency_cancel = 1U;
   3e5be:	f880 20e4 	strb.w	r2, [r0, #228]	; 0xe4
			ticker_update(TICKER_INSTANCE_ID_CTLR,
   3e5c2:	3105      	adds	r1, #5
   3e5c4:	2201      	movs	r2, #1
   3e5c6:	e9cd 3202 	strd	r3, r2, [sp, #8]
   3e5ca:	e9cd 3404 	strd	r3, r4, [sp, #16]
   3e5ce:	e9cd 3300 	strd	r3, r3, [sp]
   3e5d2:	9006      	str	r0, [sp, #24]
   3e5d4:	b2ca      	uxtb	r2, r1
   3e5d6:	4618      	mov	r0, r3
   3e5d8:	2103      	movs	r1, #3
   3e5da:	f7f7 fa57 	bl	35a8c <ticker_update>
		LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
   3e5de:	f030 0302 	bics.w	r3, r0, #2
   3e5e2:	d00c      	beq.n	3e5fe <ull_periph_latency_cancel+0x5a>
   3e5e4:	4a08      	ldr	r2, [pc, #32]	; (3e608 <ull_periph_latency_cancel+0x64>)
   3e5e6:	4909      	ldr	r1, [pc, #36]	; (3e60c <ull_periph_latency_cancel+0x68>)
   3e5e8:	4809      	ldr	r0, [pc, #36]	; (3e610 <ull_periph_latency_cancel+0x6c>)
   3e5ea:	f240 13f1 	movw	r3, #497	; 0x1f1
   3e5ee:	f00a fd49 	bl	49084 <assert_print>
   3e5f2:	4040      	eors	r0, r0
   3e5f4:	f380 8811 	msr	BASEPRI, r0
   3e5f8:	f04f 0003 	mov.w	r0, #3
   3e5fc:	df02      	svc	2
}
   3e5fe:	b008      	add	sp, #32
   3e600:	bd10      	pop	{r4, pc}
   3e602:	bf00      	nop
   3e604:	0003e439 	.word	0x0003e439
   3e608:	000528b4 	.word	0x000528b4
   3e60c:	0005277c 	.word	0x0005277c
   3e610:	0005214c 	.word	0x0005214c

0003e614 <ll_start_enc_req_send>:
{
   3e614:	b570      	push	{r4, r5, r6, lr}
   3e616:	460d      	mov	r5, r1
   3e618:	4616      	mov	r6, r2
	conn = ll_connected_get(handle);
   3e61a:	f7fb fd67 	bl	3a0ec <ll_connected_get>
	if (!conn) {
   3e61e:	b3f8      	cbz	r0, 3e6a0 <ll_start_enc_req_send+0x8c>
	if (error_code) {
   3e620:	4604      	mov	r4, r0
   3e622:	b95d      	cbnz	r5, 3e63c <ll_start_enc_req_send+0x28>
		if ((conn->llcp_req == conn->llcp_ack) ||
   3e624:	f890 20f0 	ldrb.w	r2, [r0, #240]	; 0xf0
   3e628:	f890 30f1 	ldrb.w	r3, [r0, #241]	; 0xf1
   3e62c:	429a      	cmp	r2, r3
   3e62e:	d003      	beq.n	3e638 <ll_start_enc_req_send+0x24>
   3e630:	f890 30f2 	ldrb.w	r3, [r0, #242]	; 0xf2
   3e634:	2b03      	cmp	r3, #3
   3e636:	d026      	beq.n	3e686 <ll_start_enc_req_send+0x72>
				return BT_HCI_ERR_CMD_DISALLOWED;
   3e638:	200c      	movs	r0, #12
}
   3e63a:	bd70      	pop	{r4, r5, r6, pc}
		if (conn->llcp_enc.refresh == 0U) {
   3e63c:	f890 3176 	ldrb.w	r3, [r0, #374]	; 0x176
   3e640:	f013 0304 	ands.w	r3, r3, #4
   3e644:	d113      	bne.n	3e66e <ll_start_enc_req_send+0x5a>
			if ((conn->llcp_req == conn->llcp_ack) ||
   3e646:	f890 10f0 	ldrb.w	r1, [r0, #240]	; 0xf0
   3e64a:	f890 20f1 	ldrb.w	r2, [r0, #241]	; 0xf1
   3e64e:	4291      	cmp	r1, r2
   3e650:	d0f2      	beq.n	3e638 <ll_start_enc_req_send+0x24>
   3e652:	f890 20f2 	ldrb.w	r2, [r0, #242]	; 0xf2
   3e656:	2a03      	cmp	r2, #3
   3e658:	d1ee      	bne.n	3e638 <ll_start_enc_req_send+0x24>
			conn->llcp.encryption.state = LLCP_ENC_STATE_INPROG;
   3e65a:	f890 2100 	ldrb.w	r2, [r0, #256]	; 0x100
			conn->llcp.encryption.error_code = error_code;
   3e65e:	f880 5101 	strb.w	r5, [r0, #257]	; 0x101
			conn->llcp.encryption.state = LLCP_ENC_STATE_INPROG;
   3e662:	f363 0201 	bfi	r2, r3, #0, #2
   3e666:	f880 2100 	strb.w	r2, [r0, #256]	; 0x100
	return 0;
   3e66a:	2000      	movs	r0, #0
}
   3e66c:	bd70      	pop	{r4, r5, r6, pc}
			    conn->llcp_terminate.req) {
   3e66e:	f890 2150 	ldrb.w	r2, [r0, #336]	; 0x150
			if (conn->llcp_terminate.ack !=
   3e672:	f890 3151 	ldrb.w	r3, [r0, #337]	; 0x151
   3e676:	4293      	cmp	r3, r2
   3e678:	d1de      	bne.n	3e638 <ll_start_enc_req_send+0x24>
			conn->llcp_terminate.req++;
   3e67a:	3301      	adds	r3, #1
			conn->llcp_terminate.reason_own = error_code;
   3e67c:	f880 5152 	strb.w	r5, [r0, #338]	; 0x152
			conn->llcp_terminate.req++;
   3e680:	f880 3150 	strb.w	r3, [r0, #336]	; 0x150
   3e684:	e7f1      	b.n	3e66a <ll_start_enc_req_send+0x56>
		memcpy(&conn->llcp_enc.ltk[0], ltk,
   3e686:	2210      	movs	r2, #16
   3e688:	4631      	mov	r1, r6
   3e68a:	f200 1081 	addw	r0, r0, #385	; 0x181
   3e68e:	f00c fbf4 	bl	4ae7a <memcpy>
		conn->llcp.encryption.state = LLCP_ENC_STATE_INPROG;
   3e692:	f8b4 3100 	ldrh.w	r3, [r4, #256]	; 0x100
   3e696:	f003 03fc 	and.w	r3, r3, #252	; 0xfc
   3e69a:	f8a4 3100 	strh.w	r3, [r4, #256]	; 0x100
   3e69e:	e7e4      	b.n	3e66a <ll_start_enc_req_send+0x56>
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
   3e6a0:	2002      	movs	r0, #2
}
   3e6a2:	bd70      	pop	{r4, r5, r6, pc}

0003e6a4 <ticker_op_stop_scan_cb>:
}
   3e6a4:	4770      	bx	lr
   3e6a6:	bf00      	nop

0003e6a8 <ticker_op_cb>:
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
   3e6a8:	b900      	cbnz	r0, 3e6ac <ticker_op_cb+0x4>
   3e6aa:	4770      	bx	lr
{
   3e6ac:	b508      	push	{r3, lr}
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
   3e6ae:	4a07      	ldr	r2, [pc, #28]	; (3e6cc <ticker_op_cb+0x24>)
   3e6b0:	4907      	ldr	r1, [pc, #28]	; (3e6d0 <ticker_op_cb+0x28>)
   3e6b2:	4808      	ldr	r0, [pc, #32]	; (3e6d4 <ticker_op_cb+0x2c>)
   3e6b4:	f240 43c9 	movw	r3, #1225	; 0x4c9
   3e6b8:	f00a fce4 	bl	49084 <assert_print>
   3e6bc:	4040      	eors	r0, r0
   3e6be:	f380 8811 	msr	BASEPRI, r0
   3e6c2:	f04f 0003 	mov.w	r0, #3
   3e6c6:	df02      	svc	2
}
   3e6c8:	bd08      	pop	{r3, pc}
   3e6ca:	bf00      	nop
   3e6cc:	00052940 	.word	0x00052940
   3e6d0:	000526fc 	.word	0x000526fc
   3e6d4:	0005214c 	.word	0x0005214c

0003e6d8 <ull_central_ticker_cb>:
{
   3e6d8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   3e6dc:	9c07      	ldr	r4, [sp, #28]
   3e6de:	f89d 8018 	ldrb.w	r8, [sp, #24]
	if (unlikely(conn->lll.handle == 0xFFFF)) {
   3e6e2:	8d21      	ldrh	r1, [r4, #40]	; 0x28
{
   3e6e4:	461d      	mov	r5, r3
	if (unlikely(conn->lll.handle == 0xFFFF)) {
   3e6e6:	f64f 73ff 	movw	r3, #65535	; 0xffff
   3e6ea:	4299      	cmp	r1, r3
   3e6ec:	d02d      	beq.n	3e74a <ull_central_ticker_cb+0x72>
		ret = ull_conn_llcp(conn, ticks_at_expire, lazy);
   3e6ee:	4606      	mov	r6, r0
   3e6f0:	4617      	mov	r7, r2
   3e6f2:	4601      	mov	r1, r0
   3e6f4:	462a      	mov	r2, r5
   3e6f6:	4620      	mov	r0, r4
   3e6f8:	f7fd fd44 	bl	3c184 <ull_conn_llcp>
		if (ret) {
   3e6fc:	bb28      	cbnz	r0, 3e74a <ull_central_ticker_cb+0x72>
   3e6fe:	7823      	ldrb	r3, [r4, #0]
   3e700:	3301      	adds	r3, #1
   3e702:	b2db      	uxtb	r3, r3
   3e704:	7023      	strb	r3, [r4, #0]
	LL_ASSERT(ref);
   3e706:	b383      	cbz	r3, 3e76a <ull_central_ticker_cb+0x92>
	ull_conn_tx_demux(2);
   3e708:	2002      	movs	r0, #2
   3e70a:	f7ff f807 	bl	3d71c <ull_conn_tx_demux>
	ull_conn_tx_lll_enqueue(conn, 2);
   3e70e:	2102      	movs	r1, #2
   3e710:	4620      	mov	r0, r4
   3e712:	f7ff fa7f 	bl	3dc14 <ull_conn_tx_lll_enqueue>
	p.ticks_at_expire = ticks_at_expire;
   3e716:	491c      	ldr	r1, [pc, #112]	; (3e788 <ull_central_ticker_cb+0xb0>)
	mfy.param = &p;
   3e718:	4b1c      	ldr	r3, [pc, #112]	; (3e78c <ull_central_ticker_cb+0xb4>)
	p.lazy = lazy;
   3e71a:	810d      	strh	r5, [r1, #8]
	p.param = &conn->lll;
   3e71c:	f104 001c 	add.w	r0, r4, #28
	err = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
   3e720:	2200      	movs	r2, #0
	p.param = &conn->lll;
   3e722:	60c8      	str	r0, [r1, #12]
	p.remainder = remainder;
   3e724:	e9c1 6700 	strd	r6, r7, [r1]
	p.force = force;
   3e728:	f881 800a 	strb.w	r8, [r1, #10]
	mfy.param = &p;
   3e72c:	6099      	str	r1, [r3, #8]
	err = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
   3e72e:	2001      	movs	r0, #1
   3e730:	4611      	mov	r1, r2
   3e732:	f7f5 ff9d 	bl	34670 <mayfly_enqueue>
	LL_ASSERT(!err);
   3e736:	b950      	cbnz	r0, 3e74e <ull_central_ticker_cb+0x76>
	ull_conn_tx_demux(UINT8_MAX);
   3e738:	20ff      	movs	r0, #255	; 0xff
   3e73a:	f7fe ffef 	bl	3d71c <ull_conn_tx_demux>
	ull_conn_tx_lll_enqueue(conn, UINT8_MAX);
   3e73e:	4620      	mov	r0, r4
   3e740:	21ff      	movs	r1, #255	; 0xff
}
   3e742:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	ull_conn_tx_lll_enqueue(conn, UINT8_MAX);
   3e746:	f7ff ba65 	b.w	3dc14 <ull_conn_tx_lll_enqueue>
}
   3e74a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	LL_ASSERT(!err);
   3e74e:	4a10      	ldr	r2, [pc, #64]	; (3e790 <ull_central_ticker_cb+0xb8>)
   3e750:	4910      	ldr	r1, [pc, #64]	; (3e794 <ull_central_ticker_cb+0xbc>)
   3e752:	4811      	ldr	r0, [pc, #68]	; (3e798 <ull_central_ticker_cb+0xc0>)
   3e754:	f240 4369 	movw	r3, #1129	; 0x469
   3e758:	f00a fc94 	bl	49084 <assert_print>
   3e75c:	4040      	eors	r0, r0
   3e75e:	f380 8811 	msr	BASEPRI, r0
   3e762:	f04f 0003 	mov.w	r0, #3
   3e766:	df02      	svc	2
   3e768:	e7e6      	b.n	3e738 <ull_central_ticker_cb+0x60>
	LL_ASSERT(ref);
   3e76a:	4a09      	ldr	r2, [pc, #36]	; (3e790 <ull_central_ticker_cb+0xb8>)
   3e76c:	490b      	ldr	r1, [pc, #44]	; (3e79c <ull_central_ticker_cb+0xc4>)
   3e76e:	480a      	ldr	r0, [pc, #40]	; (3e798 <ull_central_ticker_cb+0xc0>)
   3e770:	f240 4356 	movw	r3, #1110	; 0x456
   3e774:	f00a fc86 	bl	49084 <assert_print>
   3e778:	4040      	eors	r0, r0
   3e77a:	f380 8811 	msr	BASEPRI, r0
   3e77e:	f04f 0003 	mov.w	r0, #3
   3e782:	df02      	svc	2
   3e784:	e7c0      	b.n	3e708 <ull_central_ticker_cb+0x30>
   3e786:	bf00      	nop
   3e788:	20005914 	.word	0x20005914
   3e78c:	20000c6c 	.word	0x20000c6c
   3e790:	00052940 	.word	0x00052940
   3e794:	00052330 	.word	0x00052330
   3e798:	0005214c 	.word	0x0005214c
   3e79c:	000525c8 	.word	0x000525c8

0003e7a0 <ll_connect_disable>:
{
   3e7a0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   3e7a4:	4606      	mov	r6, r0
	scan = ull_scan_is_enabled_get(SCAN_HANDLE_1M);
   3e7a6:	2000      	movs	r0, #0
   3e7a8:	f7fa fdb8 	bl	3931c <ull_scan_is_enabled_get>
	if (!scan) {
   3e7ac:	b368      	cbz	r0, 3e80a <ll_connect_disable+0x6a>
	conn_lll = scan_lll->conn;
   3e7ae:	6a03      	ldr	r3, [r0, #32]
	if (!conn_lll) {
   3e7b0:	4604      	mov	r4, r0
   3e7b2:	b353      	cbz	r3, 3e80a <ll_connect_disable+0x6a>
	conn_lll->central.cancelled = 1U;
   3e7b4:	f893 2020 	ldrb.w	r2, [r3, #32]
   3e7b8:	f042 0202 	orr.w	r2, r2, #2
   3e7bc:	f883 2020 	strb.w	r2, [r3, #32]
	conn_lll = scan_lll->conn;
   3e7c0:	6a07      	ldr	r7, [r0, #32]
	if (!conn_lll) {
   3e7c2:	b317      	cbz	r7, 3e80a <ll_connect_disable+0x6a>
		err = ull_scan_disable(SCAN_HANDLE_1M, scan);
   3e7c4:	4601      	mov	r1, r0
   3e7c6:	2000      	movs	r0, #0
   3e7c8:	f7fa fd24 	bl	39214 <ull_scan_disable>
	if (!err) {
   3e7cc:	4605      	mov	r5, r0
   3e7ce:	b9c8      	cbnz	r0, 3e804 <ll_connect_disable+0x64>
		conn = HDR_LLL2ULL(conn_lll);
   3e7d0:	683f      	ldr	r7, [r7, #0]
		link = node_rx->hdr.link;
   3e7d2:	f8d7 8154 	ldr.w	r8, [r7, #340]	; 0x154
		node_rx = (void *)&conn->llcp_terminate.node_rx;
   3e7d6:	f507 79aa 	add.w	r9, r7, #340	; 0x154
		LL_ASSERT(link);
   3e7da:	f1b8 0f00 	cmp.w	r8, #0
   3e7de:	d018      	beq.n	3e812 <ll_connect_disable+0x72>
		ll_rx_link_release(link);
   3e7e0:	4640      	mov	r0, r8
   3e7e2:	f7f9 fabd 	bl	37d60 <ll_rx_link_release>
		node_rx->hdr.type = NODE_RX_TYPE_CONNECTION;
   3e7e6:	2317      	movs	r3, #23
   3e7e8:	f887 3158 	strb.w	r3, [r7, #344]	; 0x158
		node_rx->hdr.handle = 0xffff;
   3e7ec:	f64f 73ff 	movw	r3, #65535	; 0xffff
   3e7f0:	f8a7 315a 	strh.w	r3, [r7, #346]	; 0x15a
		scan_lll = &scan->lll;
   3e7f4:	341c      	adds	r4, #28
		cc->status = BT_HCI_ERR_UNKNOWN_CONN_ID;
   3e7f6:	2302      	movs	r3, #2
		node_rx->hdr.rx_ftr.param = scan_lll;
   3e7f8:	f8c7 415c 	str.w	r4, [r7, #348]	; 0x15c
		cc->status = BT_HCI_ERR_UNKNOWN_CONN_ID;
   3e7fc:	f887 3170 	strb.w	r3, [r7, #368]	; 0x170
		*rx = node_rx;
   3e800:	f8c6 9000 	str.w	r9, [r6]
}
   3e804:	4628      	mov	r0, r5
   3e806:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			return BT_HCI_ERR_CMD_DISALLOWED;
   3e80a:	250c      	movs	r5, #12
}
   3e80c:	4628      	mov	r0, r5
   3e80e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		LL_ASSERT(link);
   3e812:	4a07      	ldr	r2, [pc, #28]	; (3e830 <ll_connect_disable+0x90>)
   3e814:	4907      	ldr	r1, [pc, #28]	; (3e834 <ll_connect_disable+0x94>)
   3e816:	4808      	ldr	r0, [pc, #32]	; (3e838 <ll_connect_disable+0x98>)
   3e818:	f240 2377 	movw	r3, #631	; 0x277
   3e81c:	f00a fc32 	bl	49084 <assert_print>
   3e820:	4040      	eors	r0, r0
   3e822:	f380 8811 	msr	BASEPRI, r0
   3e826:	f04f 0003 	mov.w	r0, #3
   3e82a:	df02      	svc	2
   3e82c:	e7d8      	b.n	3e7e0 <ll_connect_disable+0x40>
   3e82e:	bf00      	nop
   3e830:	00052940 	.word	0x00052940
   3e834:	000526f4 	.word	0x000526f4
   3e838:	0005214c 	.word	0x0005214c

0003e83c <ll_enc_req_send>:
{
   3e83c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   3e840:	4607      	mov	r7, r0
   3e842:	4688      	mov	r8, r1
   3e844:	4691      	mov	r9, r2
   3e846:	461e      	mov	r6, r3
	conn = ll_connected_get(handle);
   3e848:	f7fb fc50 	bl	3a0ec <ll_connected_get>
	if (!conn) {
   3e84c:	2800      	cmp	r0, #0
   3e84e:	d06a      	beq.n	3e926 <ll_enc_req_send+0xea>
	if ((conn->llcp_enc.req != conn->llcp_enc.ack) ||
   3e850:	f890 2174 	ldrb.w	r2, [r0, #372]	; 0x174
   3e854:	f890 3175 	ldrb.w	r3, [r0, #373]	; 0x175
   3e858:	429a      	cmp	r2, r3
   3e85a:	4604      	mov	r4, r0
   3e85c:	d142      	bne.n	3e8e4 <ll_enc_req_send+0xa8>
   3e85e:	f890 20f0 	ldrb.w	r2, [r0, #240]	; 0xf0
   3e862:	f890 30f1 	ldrb.w	r3, [r0, #241]	; 0xf1
   3e866:	429a      	cmp	r2, r3
   3e868:	d003      	beq.n	3e872 <ll_enc_req_send+0x36>
	    ((conn->llcp_req != conn->llcp_ack) &&
   3e86a:	f890 30f2 	ldrb.w	r3, [r0, #242]	; 0xf2
   3e86e:	2b03      	cmp	r3, #3
   3e870:	d038      	beq.n	3e8e4 <ll_enc_req_send+0xa8>
	tx = ll_tx_mem_acquire();
   3e872:	f7fb fc4f 	bl	3a114 <ll_tx_mem_acquire>
	if (tx) {
   3e876:	4605      	mov	r5, r0
   3e878:	b3a0      	cbz	r0, 3e8e4 <ll_enc_req_send+0xa8>
		ull_pdu_data_init(pdu_data_tx);
   3e87a:	3004      	adds	r0, #4
   3e87c:	f7ff fdda 	bl	3e434 <ull_pdu_data_init>
		memcpy(&conn->llcp_enc.ltk[0], ltk, sizeof(conn->llcp_enc.ltk));
   3e880:	4631      	mov	r1, r6
   3e882:	2210      	movs	r2, #16
   3e884:	f204 1081 	addw	r0, r4, #385	; 0x181
   3e888:	f00c faf7 	bl	4ae7a <memcpy>
		if (!conn->lll.enc_rx && !conn->lll.enc_tx) {
   3e88c:	f894 307a 	ldrb.w	r3, [r4, #122]	; 0x7a
   3e890:	f013 0318 	ands.w	r3, r3, #24
   3e894:	d029      	beq.n	3e8ea <ll_enc_req_send+0xae>
		} else if (conn->lll.enc_rx && conn->lll.enc_tx) {
   3e896:	2b18      	cmp	r3, #24
   3e898:	d121      	bne.n	3e8de <ll_enc_req_send+0xa2>
			memcpy(&conn->llcp_enc.rand[0], rand_num,
   3e89a:	2208      	movs	r2, #8
   3e89c:	4641      	mov	r1, r8
   3e89e:	f204 1079 	addw	r0, r4, #377	; 0x179
   3e8a2:	f00c faea 	bl	4ae7a <memcpy>
			conn->llcp_enc.ediv[0] = ediv[0];
   3e8a6:	f899 3000 	ldrb.w	r3, [r9]
   3e8aa:	f884 3177 	strb.w	r3, [r4, #375]	; 0x177
			conn->llcp_enc.ediv[1] = ediv[1];
   3e8ae:	f899 3001 	ldrb.w	r3, [r9, #1]
   3e8b2:	f884 3178 	strb.w	r3, [r4, #376]	; 0x178
			pdu_data_tx->ll_id = PDU_DATA_LLID_CTRL;
   3e8b6:	792b      	ldrb	r3, [r5, #4]
   3e8b8:	f043 0303 	orr.w	r3, r3, #3
			pdu_data_tx->len = offsetof(struct pdu_data_llctrl,
   3e8bc:	2201      	movs	r2, #1
			pdu_data_tx->ll_id = PDU_DATA_LLID_CTRL;
   3e8be:	712b      	strb	r3, [r5, #4]
			pdu_data_tx->llctrl.opcode =
   3e8c0:	230a      	movs	r3, #10
			pdu_data_tx->len = offsetof(struct pdu_data_llctrl,
   3e8c2:	716a      	strb	r2, [r5, #5]
			pdu_data_tx->llctrl.opcode =
   3e8c4:	71eb      	strb	r3, [r5, #7]
		if (ll_tx_mem_enqueue(handle, tx)) {
   3e8c6:	4629      	mov	r1, r5
   3e8c8:	4638      	mov	r0, r7
   3e8ca:	f7fb fc2f 	bl	3a12c <ll_tx_mem_enqueue>
   3e8ce:	b930      	cbnz	r0, 3e8de <ll_enc_req_send+0xa2>
		conn->llcp_enc.req++;
   3e8d0:	f894 3174 	ldrb.w	r3, [r4, #372]	; 0x174
   3e8d4:	3301      	adds	r3, #1
   3e8d6:	f884 3174 	strb.w	r3, [r4, #372]	; 0x174
}
   3e8da:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			ll_tx_mem_release(tx);
   3e8de:	4628      	mov	r0, r5
   3e8e0:	f7fb fc1e 	bl	3a120 <ll_tx_mem_release>
		return BT_HCI_ERR_CMD_DISALLOWED;
   3e8e4:	200c      	movs	r0, #12
}
   3e8e6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			pdu_data_tx->ll_id = PDU_DATA_LLID_CTRL;
   3e8ea:	792b      	ldrb	r3, [r5, #4]
   3e8ec:	f043 0303 	orr.w	r3, r3, #3
   3e8f0:	712b      	strb	r3, [r5, #4]
			pdu_data_tx->len =
   3e8f2:	2317      	movs	r3, #23
			memcpy(enc_req->rand, rand_num, sizeof(enc_req->rand));
   3e8f4:	2208      	movs	r2, #8
			pdu_data_tx->len =
   3e8f6:	716b      	strb	r3, [r5, #5]
			pdu_data_tx->llctrl.opcode =
   3e8f8:	2303      	movs	r3, #3
			memcpy(enc_req->rand, rand_num, sizeof(enc_req->rand));
   3e8fa:	4641      	mov	r1, r8
			pdu_data_tx->llctrl.opcode =
   3e8fc:	71eb      	strb	r3, [r5, #7]
			memcpy(enc_req->rand, rand_num, sizeof(enc_req->rand));
   3e8fe:	18a8      	adds	r0, r5, r2
   3e900:	f00c fabb 	bl	4ae7a <memcpy>
			enc_req->ediv[0] = ediv[0];
   3e904:	f899 3000 	ldrb.w	r3, [r9]
   3e908:	742b      	strb	r3, [r5, #16]
			enc_req->ediv[1] = ediv[1];
   3e90a:	f899 3001 	ldrb.w	r3, [r9, #1]
   3e90e:	746b      	strb	r3, [r5, #17]
			lll_csrand_get(enc_req->skdm, sizeof(enc_req->skdm));
   3e910:	2108      	movs	r1, #8
   3e912:	f105 0012 	add.w	r0, r5, #18
   3e916:	f000 fe5f 	bl	3f5d8 <lll_csrand_get>
			lll_csrand_get(enc_req->ivm, sizeof(enc_req->ivm));
   3e91a:	2104      	movs	r1, #4
   3e91c:	f105 001a 	add.w	r0, r5, #26
   3e920:	f000 fe5a 	bl	3f5d8 <lll_csrand_get>
   3e924:	e7cf      	b.n	3e8c6 <ll_enc_req_send+0x8a>
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
   3e926:	2002      	movs	r0, #2
}
   3e928:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0003e92c <ull_central_reset>:
{
   3e92c:	b530      	push	{r4, r5, lr}
   3e92e:	b083      	sub	sp, #12
	err = ll_connect_disable(&rx);
   3e930:	a801      	add	r0, sp, #4
   3e932:	f7ff ff35 	bl	3e7a0 <ll_connect_disable>
	if (!err) {
   3e936:	4604      	mov	r4, r0
   3e938:	b110      	cbz	r0, 3e940 <ull_central_reset+0x14>
}
   3e93a:	4620      	mov	r0, r4
   3e93c:	b003      	add	sp, #12
   3e93e:	bd30      	pop	{r4, r5, pc}
		scan = ull_scan_is_enabled_get(SCAN_HANDLE_1M);
   3e940:	f7fa fcec 	bl	3931c <ull_scan_is_enabled_get>
		LL_ASSERT(scan);
   3e944:	4605      	mov	r5, r0
   3e946:	b150      	cbz	r0, 3e95e <ull_central_reset+0x32>
		scan->is_enabled = 0U;
   3e948:	f895 3040 	ldrb.w	r3, [r5, #64]	; 0x40
		scan->lll.conn = NULL;
   3e94c:	2200      	movs	r2, #0
		scan->is_enabled = 0U;
   3e94e:	f36f 0300 	bfc	r3, #0, #1
}
   3e952:	4620      	mov	r0, r4
		scan->is_enabled = 0U;
   3e954:	f885 3040 	strb.w	r3, [r5, #64]	; 0x40
		scan->lll.conn = NULL;
   3e958:	622a      	str	r2, [r5, #32]
}
   3e95a:	b003      	add	sp, #12
   3e95c:	bd30      	pop	{r4, r5, pc}
		LL_ASSERT(scan);
   3e95e:	4a07      	ldr	r2, [pc, #28]	; (3e97c <ull_central_reset+0x50>)
   3e960:	4907      	ldr	r1, [pc, #28]	; (3e980 <ull_central_reset+0x54>)
   3e962:	4808      	ldr	r0, [pc, #32]	; (3e984 <ull_central_reset+0x58>)
   3e964:	f240 3305 	movw	r3, #773	; 0x305
   3e968:	f00a fb8c 	bl	49084 <assert_print>
   3e96c:	4040      	eors	r0, r0
   3e96e:	f380 8811 	msr	BASEPRI, r0
   3e972:	f04f 0003 	mov.w	r0, #3
   3e976:	df02      	svc	2
   3e978:	e7e6      	b.n	3e948 <ull_central_reset+0x1c>
   3e97a:	bf00      	nop
   3e97c:	00052940 	.word	0x00052940
   3e980:	00052984 	.word	0x00052984
   3e984:	0005214c 	.word	0x0005214c

0003e988 <ull_central_cleanup>:
{
   3e988:	b570      	push	{r4, r5, r6, lr}
	scan = HDR_LLL2ULL(rx_free->rx_ftr.param);
   3e98a:	6883      	ldr	r3, [r0, #8]
   3e98c:	681d      	ldr	r5, [r3, #0]
	conn_lll = scan->lll.conn;
   3e98e:	6a2c      	ldr	r4, [r5, #32]
	LL_ASSERT(conn_lll);
   3e990:	b31c      	cbz	r4, 3e9da <ull_central_cleanup+0x52>
	scan->lll.conn = NULL;
   3e992:	2300      	movs	r3, #0
   3e994:	622b      	str	r3, [r5, #32]
	LL_ASSERT(!conn_lll->link_tx_free);
   3e996:	6da3      	ldr	r3, [r4, #88]	; 0x58
   3e998:	b163      	cbz	r3, 3e9b4 <ull_central_cleanup+0x2c>
   3e99a:	4a1e      	ldr	r2, [pc, #120]	; (3ea14 <ull_central_cleanup+0x8c>)
   3e99c:	491e      	ldr	r1, [pc, #120]	; (3ea18 <ull_central_cleanup+0x90>)
   3e99e:	481f      	ldr	r0, [pc, #124]	; (3ea1c <ull_central_cleanup+0x94>)
   3e9a0:	f240 3321 	movw	r3, #801	; 0x321
   3e9a4:	f00a fb6e 	bl	49084 <assert_print>
   3e9a8:	4040      	eors	r0, r0
   3e9aa:	f380 8811 	msr	BASEPRI, r0
   3e9ae:	f04f 0003 	mov.w	r0, #3
   3e9b2:	df02      	svc	2
	link = memq_deinit(&conn_lll->memq_tx.head,
   3e9b4:	f104 014c 	add.w	r1, r4, #76	; 0x4c
   3e9b8:	f104 0048 	add.w	r0, r4, #72	; 0x48
   3e9bc:	f7f5 fdd8 	bl	34570 <memq_deinit>
	LL_ASSERT(link);
   3e9c0:	4606      	mov	r6, r0
   3e9c2:	b1c0      	cbz	r0, 3e9f6 <ull_central_cleanup+0x6e>
	ll_conn_release(conn);
   3e9c4:	6820      	ldr	r0, [r4, #0]
	conn_lll->link_tx_free = link;
   3e9c6:	65a6      	str	r6, [r4, #88]	; 0x58
	ll_conn_release(conn);
   3e9c8:	f7fb fb7a 	bl	3a0c0 <ll_conn_release>
	scan->is_enabled = 0U;
   3e9cc:	f895 3040 	ldrb.w	r3, [r5, #64]	; 0x40
   3e9d0:	f36f 0300 	bfc	r3, #0, #1
   3e9d4:	f885 3040 	strb.w	r3, [r5, #64]	; 0x40
}
   3e9d8:	bd70      	pop	{r4, r5, r6, pc}
	LL_ASSERT(conn_lll);
   3e9da:	4a0e      	ldr	r2, [pc, #56]	; (3ea14 <ull_central_cleanup+0x8c>)
   3e9dc:	4910      	ldr	r1, [pc, #64]	; (3ea20 <ull_central_cleanup+0x98>)
   3e9de:	480f      	ldr	r0, [pc, #60]	; (3ea1c <ull_central_cleanup+0x94>)
   3e9e0:	f240 331e 	movw	r3, #798	; 0x31e
   3e9e4:	f00a fb4e 	bl	49084 <assert_print>
   3e9e8:	4040      	eors	r0, r0
   3e9ea:	f380 8811 	msr	BASEPRI, r0
   3e9ee:	f04f 0003 	mov.w	r0, #3
   3e9f2:	df02      	svc	2
   3e9f4:	e7cd      	b.n	3e992 <ull_central_cleanup+0xa>
	LL_ASSERT(link);
   3e9f6:	4a07      	ldr	r2, [pc, #28]	; (3ea14 <ull_central_cleanup+0x8c>)
   3e9f8:	490a      	ldr	r1, [pc, #40]	; (3ea24 <ull_central_cleanup+0x9c>)
   3e9fa:	4808      	ldr	r0, [pc, #32]	; (3ea1c <ull_central_cleanup+0x94>)
   3e9fc:	f44f 7349 	mov.w	r3, #804	; 0x324
   3ea00:	f00a fb40 	bl	49084 <assert_print>
   3ea04:	4040      	eors	r0, r0
   3ea06:	f380 8811 	msr	BASEPRI, r0
   3ea0a:	f04f 0003 	mov.w	r0, #3
   3ea0e:	df02      	svc	2
   3ea10:	e7d8      	b.n	3e9c4 <ull_central_cleanup+0x3c>
   3ea12:	bf00      	nop
   3ea14:	00052940 	.word	0x00052940
   3ea18:	000523b0 	.word	0x000523b0
   3ea1c:	0005214c 	.word	0x0005214c
   3ea20:	000523a4 	.word	0x000523a4
   3ea24:	000526f4 	.word	0x000526f4

0003ea28 <ull_central_chm_update>:
{
   3ea28:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	while (handle--) {
   3ea2a:	2505      	movs	r5, #5
		conn->llcp_type = LLCP_CHAN_MAP;
   3ea2c:	2702      	movs	r7, #2
	while (handle--) {
   3ea2e:	f64f 76ff 	movw	r6, #65535	; 0xffff
		conn = ll_connected_get(handle);
   3ea32:	4628      	mov	r0, r5
   3ea34:	f7fb fb5a 	bl	3a0ec <ll_connected_get>
		if (!conn || conn->lll.role) {
   3ea38:	4604      	mov	r4, r0
   3ea3a:	b1c0      	cbz	r0, 3ea6e <ull_central_chm_update+0x46>
   3ea3c:	f990 3039 	ldrsb.w	r3, [r0, #57]	; 0x39
   3ea40:	2b00      	cmp	r3, #0
   3ea42:	db14      	blt.n	3ea6e <ull_central_chm_update+0x46>
		ret = ull_conn_llcp_req(conn);
   3ea44:	f7ff fcd0 	bl	3e3e8 <ull_conn_llcp_req>
   3ea48:	4603      	mov	r3, r0
		ull_chan_map_get(conn->llcp.chan_map.chm);
   3ea4a:	f104 00f5 	add.w	r0, r4, #245	; 0xf5
		if (ret) {
   3ea4e:	b99b      	cbnz	r3, 3ea78 <ull_central_chm_update+0x50>
		ull_chan_map_get(conn->llcp.chan_map.chm);
   3ea50:	f000 fa6c 	bl	3ef2c <ull_chan_map_get>
		conn->llcp.chan_map.initiate = 1U;
   3ea54:	f894 20f4 	ldrb.w	r2, [r4, #244]	; 0xf4
		conn->llcp_req++;
   3ea58:	f894 30f0 	ldrb.w	r3, [r4, #240]	; 0xf0
		conn->llcp_type = LLCP_CHAN_MAP;
   3ea5c:	f884 70f2 	strb.w	r7, [r4, #242]	; 0xf2
		conn->llcp.chan_map.initiate = 1U;
   3ea60:	f042 0201 	orr.w	r2, r2, #1
		conn->llcp_req++;
   3ea64:	3301      	adds	r3, #1
		conn->llcp.chan_map.initiate = 1U;
   3ea66:	f884 20f4 	strb.w	r2, [r4, #244]	; 0xf4
		conn->llcp_req++;
   3ea6a:	f884 30f0 	strb.w	r3, [r4, #240]	; 0xf0
	while (handle--) {
   3ea6e:	3d01      	subs	r5, #1
   3ea70:	b2ad      	uxth	r5, r5
   3ea72:	42b5      	cmp	r5, r6
   3ea74:	d1dd      	bne.n	3ea32 <ull_central_chm_update+0xa>
	return 0;
   3ea76:	2300      	movs	r3, #0
}
   3ea78:	4618      	mov	r0, r3
   3ea7a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0003ea7c <ticker_op_cb>:
	*((uint32_t volatile *)param) = status;
   3ea7c:	6008      	str	r0, [r1, #0]
}
   3ea7e:	4770      	bx	lr

0003ea80 <win_offset_calc.constprop.0>:
static void win_offset_calc(struct ll_conn *conn_curr, uint8_t is_select,
   3ea80:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   3ea84:	b091      	sub	sp, #68	; 0x44
   3ea86:	e9cd 1208 	strd	r1, r2, [sp, #32]
   3ea8a:	9305      	str	r3, [sp, #20]
	if (conn_curr->lll.role) {
   3ea8c:	f990 3039 	ldrsb.w	r3, [r0, #57]	; 0x39
	ticks_slot_abs += conn_curr->ull.ticks_slot;
   3ea90:	6902      	ldr	r2, [r0, #16]
static void win_offset_calc(struct ll_conn *conn_curr, uint8_t is_select,
   3ea92:	9f1a      	ldr	r7, [sp, #104]	; 0x68
   3ea94:	f8dd a06c 	ldr.w	sl, [sp, #108]	; 0x6c
	ticks_slot_abs += conn_curr->ull.ticks_slot;
   3ea98:	920a      	str	r2, [sp, #40]	; 0x28
	if (conn_curr->lll.role) {
   3ea9a:	2b00      	cmp	r3, #0
static void win_offset_calc(struct ll_conn *conn_curr, uint8_t is_select,
   3ea9c:	4686      	mov	lr, r0
	if (conn_curr->lll.role) {
   3ea9e:	da02      	bge.n	3eaa6 <win_offset_calc.constprop.0+0x26>
		ticks_slot_abs += HAL_TICKER_US_TO_TICKS(EVENT_TIES_US);
   3eaa0:	4613      	mov	r3, r2
   3eaa2:	3314      	adds	r3, #20
   3eaa4:	930a      	str	r3, [sp, #40]	; 0x28
	ticks_to_expire = ticks_to_expire_prev = ticks_anchor =
   3eaa6:	2600      	movs	r6, #0
	ticker_id = ticker_id_prev = ticker_id_other = TICKER_NULL;
   3eaa8:	f04f 09ff 	mov.w	r9, #255	; 0xff
	ticks_to_expire = ticks_to_expire_prev = ticks_anchor =
   3eaac:	e9cd 660d 	strd	r6, r6, [sp, #52]	; 0x34
	ticker_id = ticker_id_prev = ticker_id_other = TICKER_NULL;
   3eab0:	f88d 9033 	strb.w	r9, [sp, #51]	; 0x33
		ticks_anchor_prev = offset_index = offset = 0U;
   3eab4:	4634      	mov	r4, r6
	ticker_id = ticker_id_prev = ticker_id_other = TICKER_NULL;
   3eab6:	f8cd 9010 	str.w	r9, [sp, #16]
		ticks_anchor_prev = offset_index = offset = 0U;
   3eaba:	46b0      	mov	r8, r6
	ticks_to_expire = ticks_to_expire_prev = ticks_anchor =
   3eabc:	4635      	mov	r5, r6
   3eabe:	46b3      	mov	fp, r6
   3eac0:	f8cd e01c 	str.w	lr, [sp, #28]
   3eac4:	e044      	b.n	3eb50 <win_offset_calc.constprop.0+0xd0>
		if (ticker_id == TICKER_NULL) {
   3eac6:	f89d 0033 	ldrb.w	r0, [sp, #51]	; 0x33
   3eaca:	28ff      	cmp	r0, #255	; 0xff
   3eacc:	d064      	beq.n	3eb98 <__kernel_ram_size+0x30>
		if ((ticker_id_prev != TICKER_NULL) &&
   3eace:	f1b9 0fff 	cmp.w	r9, #255	; 0xff
   3ead2:	d011      	beq.n	3eaf8 <win_offset_calc.constprop.0+0x78>
   3ead4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   3ead6:	4543      	cmp	r3, r8
   3ead8:	d00e      	beq.n	3eaf8 <win_offset_calc.constprop.0+0x78>
			LL_ASSERT(0);
   3eada:	498d      	ldr	r1, [pc, #564]	; (3ed10 <__kernel_ram_size+0x1a8>)
   3eadc:	4a8d      	ldr	r2, [pc, #564]	; (3ed14 <__kernel_ram_size+0x1ac>)
   3eade:	488e      	ldr	r0, [pc, #568]	; (3ed18 <__kernel_ram_size+0x1b0>)
   3eae0:	f44f 73e0 	mov.w	r3, #448	; 0x1c0
   3eae4:	f00a face 	bl	49084 <assert_print>
   3eae8:	4040      	eors	r0, r0
   3eaea:	f380 8811 	msr	BASEPRI, r0
   3eaee:	f04f 0003 	mov.w	r0, #3
   3eaf2:	df02      	svc	2
		if ((ticker_id < TICKER_ID_ADV_BASE) ||
   3eaf4:	f89d 0033 	ldrb.w	r0, [sp, #51]	; 0x33
   3eaf8:	1e83      	subs	r3, r0, #2
   3eafa:	2b08      	cmp	r3, #8
   3eafc:	f200 8082 	bhi.w	3ec04 <__kernel_ram_size+0x9c>
		if (ticker_id < TICKER_ID_CONN_BASE) {
   3eb00:	2804      	cmp	r0, #4
   3eb02:	d97e      	bls.n	3ec02 <__kernel_ram_size+0x9a>
		if (ticker_id_other != TICKER_NULL) {
   3eb04:	9b04      	ldr	r3, [sp, #16]
   3eb06:	2bff      	cmp	r3, #255	; 0xff
   3eb08:	d177      	bne.n	3ebfa <__kernel_ram_size+0x92>
		conn = ll_conn_get(ticker_id - TICKER_ID_CONN_BASE);
   3eb0a:	3805      	subs	r0, #5
   3eb0c:	b280      	uxth	r0, r0
   3eb0e:	f7fb fae5 	bl	3a0dc <ll_conn_get>
		if ((conn != conn_curr) && (is_select || !conn->lll.role)) {
   3eb12:	9b07      	ldr	r3, [sp, #28]
   3eb14:	4283      	cmp	r3, r0
   3eb16:	d075      	beq.n	3ec04 <__kernel_ram_size+0x9c>
   3eb18:	9a08      	ldr	r2, [sp, #32]
   3eb1a:	f990 3039 	ldrsb.w	r3, [r0, #57]	; 0x39
   3eb1e:	2a00      	cmp	r2, #0
   3eb20:	f040 8088 	bne.w	3ec34 <__kernel_ram_size+0xcc>
   3eb24:	2b00      	cmp	r3, #0
   3eb26:	db6d      	blt.n	3ec04 <__kernel_ram_size+0x9c>
			if (*ticks_to_offset_next < ticks_to_expire_normal) {
   3eb28:	9b09      	ldr	r3, [sp, #36]	; 0x24
			ticks_slot_abs_curr += conn->ull.ticks_slot +
   3eb2a:	6901      	ldr	r1, [r0, #16]
				ticks_to_expire + ticks_prepare_reduced;
   3eb2c:	9a0d      	ldr	r2, [sp, #52]	; 0x34
			if (*ticks_to_offset_next < ticks_to_expire_normal) {
   3eb2e:	6818      	ldr	r0, [r3, #0]
			uint32_t ticks_slot_margin = 0U;
   3eb30:	f8dd 8020 	ldr.w	r8, [sp, #32]
				while ((offset_index < *offset_max) &&
   3eb34:	783b      	ldrb	r3, [r7, #0]
			if (*ticks_to_offset_next < ticks_to_expire_normal) {
   3eb36:	4290      	cmp	r0, r2
			ticks_slot_abs_curr += conn->ull.ticks_slot +
   3eb38:	f101 0128 	add.w	r1, r1, #40	; 0x28
			if (*ticks_to_offset_next < ticks_to_expire_normal) {
   3eb3c:	f0c0 808a 	bcc.w	3ec54 <__kernel_ram_size+0xec>
	} while (offset_index < *offset_max);
   3eb40:	42a3      	cmp	r3, r4
			ticks_anchor_prev = ticks_anchor;
   3eb42:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
			ticker_id_prev = ticker_id;
   3eb46:	f89d 9033 	ldrb.w	r9, [sp, #51]	; 0x33
			ticks_slot_abs_prev = ticks_slot_abs_curr;
   3eb4a:	468b      	mov	fp, r1
			ticker_id_prev = ticker_id;
   3eb4c:	4615      	mov	r5, r2
	} while (offset_index < *offset_max);
   3eb4e:	d95c      	bls.n	3ec0a <__kernel_ram_size+0xa2>
		ret = ticker_next_slot_get(TICKER_INSTANCE_ID_CTLR,
   3eb50:	ab0f      	add	r3, sp, #60	; 0x3c
   3eb52:	9302      	str	r3, [sp, #8]
   3eb54:	4b71      	ldr	r3, [pc, #452]	; (3ed1c <__kernel_ram_size+0x1b4>)
   3eb56:	9301      	str	r3, [sp, #4]
   3eb58:	ab0d      	add	r3, sp, #52	; 0x34
   3eb5a:	9300      	str	r3, [sp, #0]
		ret_cb = TICKER_STATUS_BUSY;
   3eb5c:	2102      	movs	r1, #2
		ret = ticker_next_slot_get(TICKER_INSTANCE_ID_CTLR,
   3eb5e:	ab0e      	add	r3, sp, #56	; 0x38
   3eb60:	f10d 0233 	add.w	r2, sp, #51	; 0x33
   3eb64:	2000      	movs	r0, #0
		ret_cb = TICKER_STATUS_BUSY;
   3eb66:	910f      	str	r1, [sp, #60]	; 0x3c
		ret = ticker_next_slot_get(TICKER_INSTANCE_ID_CTLR,
   3eb68:	f7f6 ffea 	bl	35b40 <ticker_next_slot_get>
		if (ret == TICKER_STATUS_BUSY) {
   3eb6c:	2802      	cmp	r0, #2
   3eb6e:	d056      	beq.n	3ec1e <__kernel_ram_size+0xb6>
		success = (ret_cb == TICKER_STATUS_SUCCESS);
   3eb70:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
		LL_ASSERT(success);
   3eb72:	2b00      	cmp	r3, #0
   3eb74:	d0a7      	beq.n	3eac6 <win_offset_calc.constprop.0+0x46>
   3eb76:	4a67      	ldr	r2, [pc, #412]	; (3ed14 <__kernel_ram_size+0x1ac>)
   3eb78:	4969      	ldr	r1, [pc, #420]	; (3ed20 <__kernel_ram_size+0x1b8>)
   3eb7a:	4867      	ldr	r0, [pc, #412]	; (3ed18 <__kernel_ram_size+0x1b0>)
   3eb7c:	f240 13b7 	movw	r3, #439	; 0x1b7
   3eb80:	f00a fa80 	bl	49084 <assert_print>
   3eb84:	4040      	eors	r0, r0
   3eb86:	f380 8811 	msr	BASEPRI, r0
   3eb8a:	f04f 0003 	mov.w	r0, #3
   3eb8e:	df02      	svc	2
		if (ticker_id == TICKER_NULL) {
   3eb90:	f89d 0033 	ldrb.w	r0, [sp, #51]	; 0x33
   3eb94:	28ff      	cmp	r0, #255	; 0xff
   3eb96:	d19a      	bne.n	3eace <win_offset_calc.constprop.0+0x4e>
   3eb98:	46dc      	mov	ip, fp
		if (ticks_to_expire_prev < *ticks_to_offset_next) {
   3eb9a:	9b09      	ldr	r3, [sp, #36]	; 0x24
   3eb9c:	6819      	ldr	r1, [r3, #0]
		while (offset_index < *offset_max) {
   3eb9e:	783b      	ldrb	r3, [r7, #0]
   3eba0:	42a9      	cmp	r1, r5
   3eba2:	bf38      	it	cc
   3eba4:	4629      	movcc	r1, r5
   3eba6:	42a3      	cmp	r3, r4
   3eba8:	d925      	bls.n	3ebf6 <__kernel_ram_size+0x8e>
			offset = (ticks_to_expire_prev + ticks_slot_abs_prev) /
   3ebaa:	485e      	ldr	r0, [pc, #376]	; (3ed24 <__kernel_ram_size+0x1bc>)
			if (offset >= conn_interval) {
   3ebac:	9d05      	ldr	r5, [sp, #20]
			offset = (ticks_to_expire_prev + ticks_slot_abs_prev) /
   3ebae:	eb0c 0301 	add.w	r3, ip, r1
   3ebb2:	fba0 2303 	umull	r2, r3, r0, r3
   3ebb6:	f3c3 124f 	ubfx	r2, r3, #5, #16
			if (offset >= conn_interval) {
   3ebba:	4295      	cmp	r5, r2
			offset = (ticks_to_expire_prev + ticks_slot_abs_prev) /
   3ebbc:	ea4f 1353 	mov.w	r3, r3, lsr #5
			if (offset >= conn_interval) {
   3ebc0:	f240 8092 	bls.w	3ece8 <__kernel_ram_size+0x180>
   3ebc4:	9e05      	ldr	r6, [sp, #20]
   3ebc6:	e002      	b.n	3ebce <__kernel_ram_size+0x66>
   3ebc8:	4296      	cmp	r6, r2
   3ebca:	f240 808d 	bls.w	3ece8 <__kernel_ram_size+0x180>
			sys_put_le16(offset, (win_offset + (sizeof(uint16_t) *
   3ebce:	eb0a 0544 	add.w	r5, sl, r4, lsl #1
   3ebd2:	f80a 3014 	strb.w	r3, [sl, r4, lsl #1]
	dst[1] = val >> 8;
   3ebd6:	0a12      	lsrs	r2, r2, #8
   3ebd8:	706a      	strb	r2, [r5, #1]
		while (offset_index < *offset_max) {
   3ebda:	783d      	ldrb	r5, [r7, #0]
			offset_index++;
   3ebdc:	3401      	adds	r4, #1
			ticks_to_expire_prev += HAL_TICKER_US_TO_TICKS(
   3ebde:	3128      	adds	r1, #40	; 0x28
			offset_index++;
   3ebe0:	b2e4      	uxtb	r4, r4
			offset = (ticks_to_expire_prev + ticks_slot_abs_prev) /
   3ebe2:	eb0c 0301 	add.w	r3, ip, r1
   3ebe6:	fba0 2303 	umull	r2, r3, r0, r3
		while (offset_index < *offset_max) {
   3ebea:	42a5      	cmp	r5, r4
			offset = (ticks_to_expire_prev + ticks_slot_abs_prev) /
   3ebec:	f3c3 124f 	ubfx	r2, r3, #5, #16
   3ebf0:	ea4f 1353 	mov.w	r3, r3, lsr #5
		while (offset_index < *offset_max) {
   3ebf4:	d8e8      	bhi.n	3ebc8 <__kernel_ram_size+0x60>
		*ticks_to_offset_next = ticks_to_expire_prev;
   3ebf6:	9b09      	ldr	r3, [sp, #36]	; 0x24
   3ebf8:	6019      	str	r1, [r3, #0]
	*offset_max = offset_index;
   3ebfa:	703c      	strb	r4, [r7, #0]
}
   3ebfc:	b011      	add	sp, #68	; 0x44
   3ebfe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   3ec02:	9004      	str	r0, [sp, #16]
   3ec04:	783b      	ldrb	r3, [r7, #0]
	} while (offset_index < *offset_max);
   3ec06:	42a3      	cmp	r3, r4
   3ec08:	d8a2      	bhi.n	3eb50 <win_offset_calc.constprop.0+0xd0>
	if (ticker_id == TICKER_NULL) {
   3ec0a:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
   3ec0e:	2bff      	cmp	r3, #255	; 0xff
   3ec10:	d1f3      	bne.n	3ebfa <__kernel_ram_size+0x92>
		if (ticks_to_expire_prev < *ticks_to_offset_next) {
   3ec12:	9b09      	ldr	r3, [sp, #36]	; 0x24
   3ec14:	6819      	ldr	r1, [r3, #0]
   3ec16:	42a9      	cmp	r1, r5
   3ec18:	bf38      	it	cc
   3ec1a:	4629      	movcc	r1, r5
		while (offset_index < *offset_max) {
   3ec1c:	e7eb      	b.n	3ebf6 <__kernel_ram_size+0x8e>
			while (ret_cb == TICKER_STATUS_BUSY) {
   3ec1e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   3ec20:	2b02      	cmp	r3, #2
   3ec22:	d1a5      	bne.n	3eb70 <__kernel_ram_size+0x8>
				ticker_job_sched(TICKER_INSTANCE_ID_CTLR,
   3ec24:	2102      	movs	r1, #2
   3ec26:	2000      	movs	r0, #0
   3ec28:	f7f6 ffd0 	bl	35bcc <ticker_job_sched>
			while (ret_cb == TICKER_STATUS_BUSY) {
   3ec2c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   3ec2e:	2b02      	cmp	r3, #2
   3ec30:	d0f8      	beq.n	3ec24 <__kernel_ram_size+0xbc>
   3ec32:	e79d      	b.n	3eb70 <__kernel_ram_size+0x8>
			if (conn->lll.role) {
   3ec34:	2b00      	cmp	r3, #0
			if (*ticks_to_offset_next < ticks_to_expire_normal) {
   3ec36:	9b09      	ldr	r3, [sp, #36]	; 0x24
			ticks_slot_abs_curr += conn->ull.ticks_slot +
   3ec38:	6901      	ldr	r1, [r0, #16]
				ticks_to_expire + ticks_prepare_reduced;
   3ec3a:	9a0d      	ldr	r2, [sp, #52]	; 0x34
			if (*ticks_to_offset_next < ticks_to_expire_normal) {
   3ec3c:	6818      	ldr	r0, [r3, #0]
				while ((offset_index < *offset_max) &&
   3ec3e:	783b      	ldrb	r3, [r7, #0]
			ticks_slot_abs_curr += conn->ull.ticks_slot +
   3ec40:	bfa7      	ittee	ge
   3ec42:	3128      	addge	r1, #40	; 0x28
			uint32_t ticks_slot_margin = 0U;
   3ec44:	f04f 0800 	movge.w	r8, #0
				ticks_slot_abs_curr += ticks_slot_margin;
   3ec48:	313c      	addlt	r1, #60	; 0x3c
				ticks_slot_margin =
   3ec4a:	f04f 0814 	movlt.w	r8, #20
			if (*ticks_to_offset_next < ticks_to_expire_normal) {
   3ec4e:	4290      	cmp	r0, r2
   3ec50:	f4bf af76 	bcs.w	3eb40 <win_offset_calc.constprop.0+0xc0>
				if (ticks_to_expire_prev <
   3ec54:	4285      	cmp	r5, r0
   3ec56:	bf38      	it	cc
   3ec58:	4605      	movcc	r5, r0
				while ((offset_index < *offset_max) &&
   3ec5a:	429c      	cmp	r4, r3
   3ec5c:	d235      	bcs.n	3ecca <__kernel_ram_size+0x162>
					(ticks_slot_abs_prev + ticks_slot_abs +
   3ec5e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   3ec60:	f8cd a06c 	str.w	sl, [sp, #108]	; 0x6c
   3ec64:	445b      	add	r3, fp
   3ec66:	4498      	add	r8, r3
   3ec68:	46b2      	mov	sl, r6
						  ticks_slot_abs_prev) /
   3ec6a:	f8df 90b8 	ldr.w	r9, [pc, #184]	; 3ed24 <__kernel_ram_size+0x1bc>
   3ec6e:	9206      	str	r2, [sp, #24]
   3ec70:	462e      	mov	r6, r5
   3ec72:	910b      	str	r1, [sp, #44]	; 0x2c
   3ec74:	4645      	mov	r5, r8
   3ec76:	f8dd 806c 	ldr.w	r8, [sp, #108]	; 0x6c
   3ec7a:	e013      	b.n	3eca4 <__kernel_ram_size+0x13c>
					if (offset >= conn_interval) {
   3ec7c:	9a05      	ldr	r2, [sp, #20]
					offset = (ticks_to_expire_prev +
   3ec7e:	f3c3 1a4f 	ubfx	sl, r3, #5, #16
					if (offset >= conn_interval) {
   3ec82:	4592      	cmp	sl, r2
					ticks_to_expire_prev +=
   3ec84:	f106 0628 	add.w	r6, r6, #40	; 0x28
   3ec88:	ea4f 201a 	mov.w	r0, sl, lsr #8
						  ticks_slot_abs_prev) /
   3ec8c:	ea4f 1353 	mov.w	r3, r3, lsr #5
					if (offset >= conn_interval) {
   3ec90:	d22e      	bcs.n	3ecf0 <__kernel_ram_size+0x188>
	dst[0] = val;
   3ec92:	f808 3014 	strb.w	r3, [r8, r4, lsl #1]
	dst[1] = val >> 8;
   3ec96:	f88e 0001 	strb.w	r0, [lr, #1]
				while ((offset_index < *offset_max) &&
   3ec9a:	783b      	ldrb	r3, [r7, #0]
					offset_index++;
   3ec9c:	fa5f f48c 	uxtb.w	r4, ip
				while ((offset_index < *offset_max) &&
   3eca0:	42a3      	cmp	r3, r4
   3eca2:	d919      	bls.n	3ecd8 <__kernel_ram_size+0x170>
				       (ticker_ticks_diff_get(
   3eca4:	9806      	ldr	r0, [sp, #24]
   3eca6:	4631      	mov	r1, r6
   3eca8:	f7f6 ffaa 	bl	35c00 <ticker_ticks_diff_get>
					offset = (ticks_to_expire_prev +
   3ecac:	eb0b 0c06 	add.w	ip, fp, r6
				while ((offset_index < *offset_max) &&
   3ecb0:	42a8      	cmp	r0, r5
						  ticks_slot_abs_prev) /
   3ecb2:	fba9 c30c 	umull	ip, r3, r9, ip
					sys_put_le16(offset,
   3ecb6:	eb08 0e44 	add.w	lr, r8, r4, lsl #1
					offset_index++;
   3ecba:	f104 0c01 	add.w	ip, r4, #1
				while ((offset_index < *offset_max) &&
   3ecbe:	d2dd      	bcs.n	3ec7c <__kernel_ram_size+0x114>
   3ecc0:	9a06      	ldr	r2, [sp, #24]
   3ecc2:	990b      	ldr	r1, [sp, #44]	; 0x2c
   3ecc4:	4635      	mov	r5, r6
   3ecc6:	4656      	mov	r6, sl
   3ecc8:	46c2      	mov	sl, r8
				*ticks_to_offset_next = ticks_to_expire_prev;
   3ecca:	9b09      	ldr	r3, [sp, #36]	; 0x24
   3eccc:	601d      	str	r5, [r3, #0]
				if (offset >= conn_interval) {
   3ecce:	9b05      	ldr	r3, [sp, #20]
   3ecd0:	42b3      	cmp	r3, r6
   3ecd2:	d918      	bls.n	3ed06 <__kernel_ram_size+0x19e>
   3ecd4:	783b      	ldrb	r3, [r7, #0]
   3ecd6:	e733      	b.n	3eb40 <win_offset_calc.constprop.0+0xc0>
				*ticks_to_offset_next = ticks_to_expire_prev;
   3ecd8:	9b09      	ldr	r3, [sp, #36]	; 0x24
   3ecda:	9a06      	ldr	r2, [sp, #24]
   3ecdc:	990b      	ldr	r1, [sp, #44]	; 0x2c
   3ecde:	4635      	mov	r5, r6
   3ece0:	601d      	str	r5, [r3, #0]
   3ece2:	4656      	mov	r6, sl
   3ece4:	46c2      	mov	sl, r8
   3ece6:	e7f5      	b.n	3ecd4 <__kernel_ram_size+0x16c>
		*ticks_to_offset_next = ticks_to_expire_prev;
   3ece8:	9b09      	ldr	r3, [sp, #36]	; 0x24
				ticks_to_expire_prev = 0U;
   3ecea:	2100      	movs	r1, #0
		*ticks_to_offset_next = ticks_to_expire_prev;
   3ecec:	6019      	str	r1, [r3, #0]
   3ecee:	e784      	b.n	3ebfa <__kernel_ram_size+0x92>
				*ticks_to_offset_next = ticks_to_expire_prev;
   3ecf0:	9b09      	ldr	r3, [sp, #36]	; 0x24
   3ecf2:	2500      	movs	r5, #0
   3ecf4:	601d      	str	r5, [r3, #0]
	if (ticker_id == TICKER_NULL) {
   3ecf6:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
				*ticks_to_offset_next = ticks_to_expire_prev;
   3ecfa:	46dc      	mov	ip, fp
   3ecfc:	46c2      	mov	sl, r8
	if (ticker_id == TICKER_NULL) {
   3ecfe:	2bff      	cmp	r3, #255	; 0xff
   3ed00:	f47f af7b 	bne.w	3ebfa <__kernel_ram_size+0x92>
   3ed04:	e749      	b.n	3eb9a <__kernel_ram_size+0x32>
   3ed06:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
   3ed0a:	46dc      	mov	ip, fp
   3ed0c:	e7f7      	b.n	3ecfe <__kernel_ram_size+0x196>
   3ed0e:	bf00      	nop
   3ed10:	000521ac 	.word	0x000521ac
   3ed14:	0005298c 	.word	0x0005298c
   3ed18:	0005214c 	.word	0x0005214c
   3ed1c:	0003ea7d 	.word	0x0003ea7d
   3ed20:	000529d0 	.word	0x000529d0
   3ed24:	cccccccd 	.word	0xcccccccd

0003ed28 <after_match_slot_get.constprop.0>:
static uint8_t after_match_slot_get(uint8_t user_id, uint32_t ticks_slot_abs,
   3ed28:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   3ed2c:	b08f      	sub	sp, #60	; 0x3c
	ticker_id = ticker_id_prev = TICKER_NULL;
   3ed2e:	24ff      	movs	r4, #255	; 0xff
static uint8_t after_match_slot_get(uint8_t user_id, uint32_t ticks_slot_abs,
   3ed30:	9309      	str	r3, [sp, #36]	; 0x24
	ticks_slot_abs += HAL_TICKER_US_TO_TICKS(EVENT_JITTER_US << 3);
   3ed32:	1d0b      	adds	r3, r1, #4
   3ed34:	9308      	str	r3, [sp, #32]
	ticks_to_expire = ticks_to_expire_prev = 0U;
   3ed36:	2300      	movs	r3, #0
   3ed38:	e9cd 3305 	strd	r3, r3, [sp, #20]
   3ed3c:	f8df b100 	ldr.w	fp, [pc, #256]	; 3ee40 <after_match_slot_get.constprop.0+0x118>
	ticker_id = ticker_id_prev = TICKER_NULL;
   3ed40:	f88d 402b 	strb.w	r4, [sp, #43]	; 0x2b
static uint8_t after_match_slot_get(uint8_t user_id, uint32_t ticks_slot_abs,
   3ed44:	4605      	mov	r5, r0
   3ed46:	4616      	mov	r6, r2
	ticks_to_expire = ticks_to_expire_prev = 0U;
   3ed48:	930b      	str	r3, [sp, #44]	; 0x2c
	ticks_anchor_prev = 0U;
   3ed4a:	4698      	mov	r8, r3
	retry = 4U;
   3ed4c:	2704      	movs	r7, #4
   3ed4e:	f10d 0a30 	add.w	sl, sp, #48	; 0x30
   3ed52:	f10d 092c 	add.w	r9, sp, #44	; 0x2c
		ret_cb = TICKER_STATUS_BUSY;
   3ed56:	2302      	movs	r3, #2
   3ed58:	930c      	str	r3, [sp, #48]	; 0x30
		ret = ticker_next_slot_get(TICKER_INSTANCE_ID_CTLR, user_id,
   3ed5a:	e9cd ba01 	strd	fp, sl, [sp, #4]
   3ed5e:	f8cd 9000 	str.w	r9, [sp]
   3ed62:	4633      	mov	r3, r6
   3ed64:	f10d 022b 	add.w	r2, sp, #43	; 0x2b
   3ed68:	4629      	mov	r1, r5
   3ed6a:	2000      	movs	r0, #0
   3ed6c:	f7f6 fee8 	bl	35b40 <ticker_next_slot_get>
		if (ret == TICKER_STATUS_BUSY) {
   3ed70:	2802      	cmp	r0, #2
   3ed72:	d012      	beq.n	3ed9a <after_match_slot_get.constprop.0+0x72>
		success = (ret_cb == TICKER_STATUS_SUCCESS);
   3ed74:	9b0c      	ldr	r3, [sp, #48]	; 0x30
		LL_ASSERT(success);
   3ed76:	b9b3      	cbnz	r3, 3eda6 <after_match_slot_get.constprop.0+0x7e>
		if ((ticker_id_prev != TICKER_NULL) &&
   3ed78:	2cff      	cmp	r4, #255	; 0xff
   3ed7a:	d023      	beq.n	3edc4 <after_match_slot_get.constprop.0+0x9c>
   3ed7c:	6833      	ldr	r3, [r6, #0]
   3ed7e:	4543      	cmp	r3, r8
   3ed80:	d020      	beq.n	3edc4 <after_match_slot_get.constprop.0+0x9c>
			LL_ASSERT(retry);
   3ed82:	2f00      	cmp	r7, #0
   3ed84:	d041      	beq.n	3ee0a <after_match_slot_get.constprop.0+0xe2>
			retry--;
   3ed86:	3f01      	subs	r7, #1
			ticker_id = ticker_id_prev = TICKER_NULL;
   3ed88:	24ff      	movs	r4, #255	; 0xff
			retry--;
   3ed8a:	b2ff      	uxtb	r7, r7
			ticker_id = ticker_id_prev = TICKER_NULL;
   3ed8c:	f88d 402b 	strb.w	r4, [sp, #43]	; 0x2b
			continue;
   3ed90:	e7e1      	b.n	3ed56 <after_match_slot_get.constprop.0+0x2e>
				ticker_job_sched(TICKER_INSTANCE_ID_CTLR,
   3ed92:	4629      	mov	r1, r5
   3ed94:	2000      	movs	r0, #0
   3ed96:	f7f6 ff19 	bl	35bcc <ticker_job_sched>
			while (ret_cb == TICKER_STATUS_BUSY) {
   3ed9a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   3ed9c:	2b02      	cmp	r3, #2
   3ed9e:	d0f8      	beq.n	3ed92 <after_match_slot_get.constprop.0+0x6a>
		success = (ret_cb == TICKER_STATUS_SUCCESS);
   3eda0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
		LL_ASSERT(success);
   3eda2:	2b00      	cmp	r3, #0
   3eda4:	d0e8      	beq.n	3ed78 <after_match_slot_get.constprop.0+0x50>
   3eda6:	4a27      	ldr	r2, [pc, #156]	; (3ee44 <after_match_slot_get.constprop.0+0x11c>)
   3eda8:	4927      	ldr	r1, [pc, #156]	; (3ee48 <after_match_slot_get.constprop.0+0x120>)
   3edaa:	4828      	ldr	r0, [pc, #160]	; (3ee4c <after_match_slot_get.constprop.0+0x124>)
   3edac:	f44f 7333 	mov.w	r3, #716	; 0x2cc
   3edb0:	f00a f968 	bl	49084 <assert_print>
   3edb4:	4040      	eors	r0, r0
   3edb6:	f380 8811 	msr	BASEPRI, r0
   3edba:	f04f 0003 	mov.w	r0, #3
   3edbe:	df02      	svc	2
		if ((ticker_id_prev != TICKER_NULL) &&
   3edc0:	2cff      	cmp	r4, #255	; 0xff
   3edc2:	d1db      	bne.n	3ed7c <after_match_slot_get.constprop.0+0x54>
		if (ticker_id == TICKER_NULL) {
   3edc4:	f89d 002b 	ldrb.w	r0, [sp, #43]	; 0x2b
   3edc8:	28ff      	cmp	r0, #255	; 0xff
   3edca:	d02c      	beq.n	3ee26 <after_match_slot_get.constprop.0+0xfe>
		if (!ticker_match_op_cb(ticker_id, 0, 0, NULL)) {
   3edcc:	1f43      	subs	r3, r0, #5
   3edce:	2b05      	cmp	r3, #5
   3edd0:	d8c1      	bhi.n	3ed56 <after_match_slot_get.constprop.0+0x2e>
		hdr = ull_hdr_get_cb(ticker_id, &ticks_slot);
   3edd2:	a90d      	add	r1, sp, #52	; 0x34
   3edd4:	f7e9 fa14 	bl	28200 <ull_hdr_get_cb>
		if (!hdr) {
   3edd8:	2800      	cmp	r0, #0
   3edda:	d0bc      	beq.n	3ed56 <after_match_slot_get.constprop.0+0x2e>
		if ((ticker_id_prev != TICKER_NULL) &&
   3eddc:	2cff      	cmp	r4, #255	; 0xff
		ticks_to_expire_normal = ticks_to_expire;
   3edde:	f8dd 802c 	ldr.w	r8, [sp, #44]	; 0x2c
		ticks_slot_abs_curr += ticks_slot;
   3ede2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
		if ((ticker_id_prev != TICKER_NULL) &&
   3ede4:	d00a      	beq.n	3edfc <after_match_slot_get.constprop.0+0xd4>
		    (ticker_ticks_diff_get(ticks_to_expire_normal,
   3ede6:	9905      	ldr	r1, [sp, #20]
   3ede8:	9307      	str	r3, [sp, #28]
   3edea:	4640      	mov	r0, r8
   3edec:	f7f6 ff08 	bl	35c00 <ticker_ticks_diff_get>
		     (ticks_slot_abs_prev + ticks_slot_abs))) {
   3edf0:	9b08      	ldr	r3, [sp, #32]
   3edf2:	9a06      	ldr	r2, [sp, #24]
   3edf4:	189a      	adds	r2, r3, r2
		if ((ticker_id_prev != TICKER_NULL) &&
   3edf6:	4290      	cmp	r0, r2
   3edf8:	9b07      	ldr	r3, [sp, #28]
   3edfa:	d816      	bhi.n	3ee2a <after_match_slot_get.constprop.0+0x102>
		ticks_to_expire_prev = ticks_to_expire_normal;
   3edfc:	e9cd 8305 	strd	r8, r3, [sp, #20]
		ticker_id_prev = ticker_id;
   3ee00:	f89d 402b 	ldrb.w	r4, [sp, #43]	; 0x2b
		ticks_anchor_prev = *ticks_anchor;
   3ee04:	f8d6 8000 	ldr.w	r8, [r6]
		ticks_slot_abs_prev = ticks_slot_abs_curr;
   3ee08:	e7a5      	b.n	3ed56 <after_match_slot_get.constprop.0+0x2e>
			LL_ASSERT(retry);
   3ee0a:	4911      	ldr	r1, [pc, #68]	; (3ee50 <after_match_slot_get.constprop.0+0x128>)
   3ee0c:	4a0d      	ldr	r2, [pc, #52]	; (3ee44 <after_match_slot_get.constprop.0+0x11c>)
   3ee0e:	480f      	ldr	r0, [pc, #60]	; (3ee4c <after_match_slot_get.constprop.0+0x124>)
   3ee10:	f44f 7335 	mov.w	r3, #724	; 0x2d4
   3ee14:	f00a f936 	bl	49084 <assert_print>
   3ee18:	4040      	eors	r0, r0
   3ee1a:	f380 8811 	msr	BASEPRI, r0
   3ee1e:	f04f 0003 	mov.w	r0, #3
   3ee22:	df02      	svc	2
   3ee24:	e7af      	b.n	3ed86 <after_match_slot_get.constprop.0+0x5e>
	if (ticker_id_prev != TICKER_NULL) {
   3ee26:	2cff      	cmp	r4, #255	; 0xff
   3ee28:	d005      	beq.n	3ee36 <after_match_slot_get.constprop.0+0x10e>
		*ticks_to_expire_match = ticks_to_expire_prev;
   3ee2a:	9b09      	ldr	r3, [sp, #36]	; 0x24
   3ee2c:	9a05      	ldr	r2, [sp, #20]
   3ee2e:	601a      	str	r2, [r3, #0]
		*ticks_slot_match = ticks_slot_abs_prev;
   3ee30:	9b18      	ldr	r3, [sp, #96]	; 0x60
   3ee32:	9a06      	ldr	r2, [sp, #24]
   3ee34:	601a      	str	r2, [r3, #0]
}
   3ee36:	4620      	mov	r0, r4
   3ee38:	b00f      	add	sp, #60	; 0x3c
   3ee3a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   3ee3e:	bf00      	nop
   3ee40:	0003ea7d 	.word	0x0003ea7d
   3ee44:	0005298c 	.word	0x0005298c
   3ee48:	000529d0 	.word	0x000529d0
   3ee4c:	0005214c 	.word	0x0005214c
   3ee50:	000529d8 	.word	0x000529d8

0003ee54 <ull_sched_mfy_after_cen_offset_get>:
	struct lll_scan *lll = p->param;
   3ee54:	68c3      	ldr	r3, [r0, #12]
	after_cen_offset_get(lll->conn->interval,
   3ee56:	6802      	ldr	r2, [r0, #0]
	conn = HDR_LLL2ULL(lll->conn);
   3ee58:	6859      	ldr	r1, [r3, #4]
	after_cen_offset_get(lll->conn->interval,
   3ee5a:	6858      	ldr	r0, [r3, #4]
			     (ticks_slot_overhead + conn->ull.ticks_slot),
   3ee5c:	6809      	ldr	r1, [r1, #0]
	after_cen_offset_get(lll->conn->interval,
   3ee5e:	89c0      	ldrh	r0, [r0, #14]
   3ee60:	6909      	ldr	r1, [r1, #16]
   3ee62:	3310      	adds	r3, #16
   3ee64:	f7e9 b9fc 	b.w	28260 <after_cen_offset_get>

0003ee68 <ull_sched_mfy_win_offset_use>:
{
   3ee68:	b510      	push	{r4, lr}
   3ee6a:	4604      	mov	r4, r0
	after_cen_offset_get(conn->lll.interval,
   3ee6c:	f8d0 20fc 	ldr.w	r2, [r0, #252]	; 0xfc
   3ee70:	6901      	ldr	r1, [r0, #16]
   3ee72:	f500 7392 	add.w	r3, r0, #292	; 0x124
   3ee76:	8d40      	ldrh	r0, [r0, #42]	; 0x2a
   3ee78:	f7e9 f9f2 	bl	28260 <after_cen_offset_get>
	win_offset = conn->llcp_cu.win_offset_us / CONN_INT_UNIT_US;
   3ee7c:	f8d4 3124 	ldr.w	r3, [r4, #292]	; 0x124
   3ee80:	4908      	ldr	r1, [pc, #32]	; (3eea4 <ull_sched_mfy_win_offset_use+0x3c>)
	sys_put_le16(win_offset, (void *)conn->llcp.conn_upd.pdu_win_offset);
   3ee82:	f8d4 20f8 	ldr.w	r2, [r4, #248]	; 0xf8
	win_offset = conn->llcp_cu.win_offset_us / CONN_INT_UNIT_US;
   3ee86:	fba1 1303 	umull	r1, r3, r1, r3
   3ee8a:	0a9b      	lsrs	r3, r3, #10
   3ee8c:	f3c3 2107 	ubfx	r1, r3, #8, #8
	dst[0] = val;
   3ee90:	7013      	strb	r3, [r2, #0]
	dst[1] = val >> 8;
   3ee92:	7051      	strb	r1, [r2, #1]
	conn->llcp_cu.state = LLCP_CUI_STATE_OFFS_RDY;
   3ee94:	f894 311a 	ldrb.w	r3, [r4, #282]	; 0x11a
   3ee98:	2204      	movs	r2, #4
   3ee9a:	f362 0302 	bfi	r3, r2, #0, #3
   3ee9e:	f884 311a 	strb.w	r3, [r4, #282]	; 0x11a
}
   3eea2:	bd10      	pop	{r4, pc}
   3eea4:	d1b71759 	.word	0xd1b71759

0003eea8 <ull_sched_mfy_free_win_offset_calc>:
{
   3eea8:	b510      	push	{r4, lr}
	if (conn->lll.role) {
   3eeaa:	f990 3039 	ldrsb.w	r3, [r0, #57]	; 0x39
	uint32_t ticks_to_offset_default = 0U;
   3eeae:	2100      	movs	r1, #0
{
   3eeb0:	b084      	sub	sp, #16
	if (conn->lll.role) {
   3eeb2:	428b      	cmp	r3, r1
		conn->llcp_conn_param.ticks_to_offset_next =
   3eeb4:	bfbc      	itt	lt
   3eeb6:	f8d0 30ec 	ldrlt.w	r3, [r0, #236]	; 0xec
   3eeba:	f8c0 31c0 	strlt.w	r3, [r0, #448]	; 0x1c0
	uint8_t offset_max = 6U;
   3eebe:	f04f 0206 	mov.w	r2, #6
{
   3eec2:	4604      	mov	r4, r0
	uint8_t offset_max = 6U;
   3eec4:	f88d 200b 	strb.w	r2, [sp, #11]
		ticks_to_offset_next =
   3eec8:	bfb8      	it	lt
   3eeca:	f500 72e0 	addlt.w	r2, r0, #448	; 0x1c0
	win_offset_calc(conn, 0, ticks_to_offset_next,
   3eece:	f8d0 01b8 	ldr.w	r0, [r0, #440]	; 0x1b8
	uint32_t ticks_to_offset_default = 0U;
   3eed2:	9103      	str	r1, [sp, #12]
	win_offset_calc(conn, 0, ticks_to_offset_next,
   3eed4:	f10d 010b 	add.w	r1, sp, #11
   3eed8:	f8b4 319a 	ldrh.w	r3, [r4, #410]	; 0x19a
	ticks_to_offset_next = &ticks_to_offset_default;
   3eedc:	bfa8      	it	ge
   3eede:	aa03      	addge	r2, sp, #12
	win_offset_calc(conn, 0, ticks_to_offset_next,
   3eee0:	e9cd 1000 	strd	r1, r0, [sp]
   3eee4:	2100      	movs	r1, #0
   3eee6:	4620      	mov	r0, r4
   3eee8:	f7ff fdca 	bl	3ea80 <win_offset_calc.constprop.0>
	conn->llcp_conn_param.state = LLCP_CPR_STATE_OFFS_RDY;
   3eeec:	f894 3196 	ldrb.w	r3, [r4, #406]	; 0x196
   3eef0:	2208      	movs	r2, #8
   3eef2:	f362 0303 	bfi	r3, r2, #0, #4
   3eef6:	f884 3196 	strb.w	r3, [r4, #406]	; 0x196
}
   3eefa:	b004      	add	sp, #16
   3eefc:	bd10      	pop	{r4, pc}
   3eefe:	bf00      	nop

0003ef00 <ll_chm_update>:
static uint8_t count = 37U;

static void chan_map_set(uint8_t const *const chan_map);

uint8_t ll_chm_update(uint8_t const *const chm)
{
   3ef00:	b510      	push	{r4, lr}
	return count;
}

static void chan_map_set(uint8_t const *const chan_map)
{
	(void)memcpy(map, chan_map, sizeof(map));
   3ef02:	4c08      	ldr	r4, [pc, #32]	; (3ef24 <ll_chm_update+0x24>)
   3ef04:	2205      	movs	r2, #5
{
   3ef06:	4601      	mov	r1, r0
	(void)memcpy(map, chan_map, sizeof(map));
   3ef08:	4620      	mov	r0, r4
   3ef0a:	f00b ffb6 	bl	4ae7a <memcpy>
	count = util_ones_count_get(map, sizeof(map));
   3ef0e:	2105      	movs	r1, #5
   3ef10:	4620      	mov	r0, r4
   3ef12:	f7f5 fcb3 	bl	3487c <util_ones_count_get>
   3ef16:	4b04      	ldr	r3, [pc, #16]	; (3ef28 <ll_chm_update+0x28>)
   3ef18:	7018      	strb	r0, [r3, #0]
	(void)ull_central_chm_update();
   3ef1a:	f7ff fd85 	bl	3ea28 <ull_central_chm_update>
}
   3ef1e:	2000      	movs	r0, #0
   3ef20:	bd10      	pop	{r4, pc}
   3ef22:	bf00      	nop
   3ef24:	20000c7c 	.word	0x20000c7c
   3ef28:	20000fa0 	.word	0x20000fa0

0003ef2c <ull_chan_map_get>:
{
   3ef2c:	b508      	push	{r3, lr}
	(void)memcpy(chan_map, map, sizeof(map));
   3ef2e:	4903      	ldr	r1, [pc, #12]	; (3ef3c <ull_chan_map_get+0x10>)
   3ef30:	2205      	movs	r2, #5
   3ef32:	f00b ffa2 	bl	4ae7a <memcpy>
	return count;
   3ef36:	4b02      	ldr	r3, [pc, #8]	; (3ef40 <ull_chan_map_get+0x14>)
}
   3ef38:	7818      	ldrb	r0, [r3, #0]
   3ef3a:	bd08      	pop	{r3, pc}
   3ef3c:	20000c7c 	.word	0x20000c7c
   3ef40:	20000fa0 	.word	0x20000fa0

0003ef44 <lll_chan_sel_1>:
/* Refer to Bluetooth Specification v5.2 Vol 6, Part B, Section 4.5.8.2
 * Channel Selection algorithm #1
 */
uint8_t lll_chan_sel_1(uint8_t *chan_use, uint8_t hop, uint16_t latency, uint8_t *chan_map,
		    uint8_t chan_count)
{
   3ef44:	b530      	push	{r4, r5, lr}
   3ef46:	4604      	mov	r4, r0
	uint8_t chan_next;

	chan_next = ((*chan_use) + (hop * (1 + latency))) % 37;
   3ef48:	7800      	ldrb	r0, [r0, #0]
{
   3ef4a:	f89d 500c 	ldrb.w	r5, [sp, #12]
	chan_next = ((*chan_use) + (hop * (1 + latency))) % 37;
   3ef4e:	fb02 1101 	mla	r1, r2, r1, r1
   3ef52:	4a1f      	ldr	r2, [pc, #124]	; (3efd0 <lll_chan_sel_1+0x8c>)
   3ef54:	4401      	add	r1, r0
   3ef56:	fb82 0201 	smull	r0, r2, r2, r1
   3ef5a:	440a      	add	r2, r1
   3ef5c:	1152      	asrs	r2, r2, #5
   3ef5e:	eb02 00c2 	add.w	r0, r2, r2, lsl #3
   3ef62:	eb02 0280 	add.w	r2, r2, r0, lsl #2
   3ef66:	1a8a      	subs	r2, r1, r2
   3ef68:	b2d0      	uxtb	r0, r2
	*chan_use = chan_next;

	if ((chan_map[chan_next >> 3] & (1 << (chan_next % 8))) == 0U) {
   3ef6a:	08c1      	lsrs	r1, r0, #3
	*chan_use = chan_next;
   3ef6c:	7020      	strb	r0, [r4, #0]
	if ((chan_map[chan_next >> 3] & (1 << (chan_next % 8))) == 0U) {
   3ef6e:	5c59      	ldrb	r1, [r3, r1]
   3ef70:	f002 0207 	and.w	r2, r2, #7
   3ef74:	fa41 f202 	asr.w	r2, r1, r2
   3ef78:	f012 0201 	ands.w	r2, r2, #1
   3ef7c:	d11f      	bne.n	3efbe <lll_chan_sel_1+0x7a>
		uint8_t chan_index;

		chan_index = chan_next % chan_count;
   3ef7e:	fbb0 f4f5 	udiv	r4, r0, r5
   3ef82:	fb05 0414 	mls	r4, r5, r4, r0
   3ef86:	b2e4      	uxtb	r4, r4
	uint8_t chan_next;
	uint8_t byte_count;

	chan_next = 0U;
	byte_count = 5U;
	while (byte_count--) {
   3ef88:	1e5d      	subs	r5, r3, #1
	chan_next = 0U;
   3ef8a:	4610      	mov	r0, r2
   3ef8c:	3304      	adds	r3, #4
		uint8_t bite;
		uint8_t bit_count;

		bite = *chan_map;
   3ef8e:	f100 0e08 	add.w	lr, r0, #8
   3ef92:	f815 1f01 	ldrb.w	r1, [r5, #1]!
		bit_count = 8U;
		while (bit_count--) {
   3ef96:	fa5f fe8e 	uxtb.w	lr, lr
		bite = *chan_map;
   3ef9a:	4602      	mov	r2, r0
			if (bite & 0x01) {
   3ef9c:	f011 0f01 	tst.w	r1, #1
				if (chan_index == 0U) {
					break;
				}
				chan_index--;
			}
			chan_next++;
   3efa0:	f102 0c01 	add.w	ip, r2, #1
			bite >>= 1;
   3efa4:	ea4f 0151 	mov.w	r1, r1, lsr #1
			if (bite & 0x01) {
   3efa8:	d002      	beq.n	3efb0 <lll_chan_sel_1+0x6c>
				if (chan_index == 0U) {
   3efaa:	b14c      	cbz	r4, 3efc0 <lll_chan_sel_1+0x7c>
				chan_index--;
   3efac:	3c01      	subs	r4, #1
   3efae:	b2e4      	uxtb	r4, r4
			chan_next++;
   3efb0:	fa5f f28c 	uxtb.w	r2, ip
		while (bit_count--) {
   3efb4:	4572      	cmp	r2, lr
   3efb6:	d1f1      	bne.n	3ef9c <lll_chan_sel_1+0x58>
			chan_next++;
   3efb8:	4610      	mov	r0, r2
	while (byte_count--) {
   3efba:	429d      	cmp	r5, r3
   3efbc:	d1e7      	bne.n	3ef8e <lll_chan_sel_1+0x4a>
}
   3efbe:	bd30      	pop	{r4, r5, pc}
		}

		if (bit_count < 8) {
   3efc0:	1dc1      	adds	r1, r0, #7
   3efc2:	1a89      	subs	r1, r1, r2
   3efc4:	b2c9      	uxtb	r1, r1
   3efc6:	2907      	cmp	r1, #7
   3efc8:	4610      	mov	r0, r2
   3efca:	d8f6      	bhi.n	3efba <lll_chan_sel_1+0x76>
}
   3efcc:	bd30      	pop	{r4, r5, pc}
   3efce:	bf00      	nop
   3efd0:	dd67c8a7 	.word	0xdd67c8a7

0003efd4 <lll_chan_id>:
	return aa_ms ^ aa_ls;
   3efd4:	8842      	ldrh	r2, [r0, #2]
   3efd6:	8800      	ldrh	r0, [r0, #0]
}
   3efd8:	4050      	eors	r0, r2
   3efda:	4770      	bx	lr

0003efdc <lll_chan_sel_2>:
{
   3efdc:	b5f0      	push	{r4, r5, r6, r7, lr}
/* Refer to Bluetooth Specification v5.2 Vol 6, Part B, Section 4.5.8.3.2
 * Inputs and basic components, for below operations
 */
static uint8_t chan_rev_8(uint8_t b)
{
	b = (((uint32_t)b * 0x0802LU & 0x22110LU) |
   3efde:	4d34      	ldr	r5, [pc, #208]	; (3f0b0 <lll_chan_sel_2+0xd4>)
	     ((uint32_t)b * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16;
   3efe0:	4c34      	ldr	r4, [pc, #208]	; (3f0b4 <lll_chan_sel_2+0xd8>)
static uint16_t chan_prn_s(uint16_t counter, uint16_t chan_id)
{
	uint8_t iterate;
	uint16_t prn_s;

	prn_s = counter ^ chan_id;
   3efe2:	4048      	eors	r0, r1
   3efe4:	f04f 0c03 	mov.w	ip, #3
	b = (((uint32_t)b * 0x0802LU & 0x22110LU) |
   3efe8:	0a06      	lsrs	r6, r0, #8
   3efea:	fa5f fe80 	uxtb.w	lr, r0
   3efee:	eb0e 2e8e 	add.w	lr, lr, lr, lsl #10
   3eff2:	eb06 2086 	add.w	r0, r6, r6, lsl #10
	     ((uint32_t)b * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16;
   3eff6:	ea04 1740 	and.w	r7, r4, r0, lsl #5
	b = (((uint32_t)b * 0x0802LU & 0x22110LU) |
   3effa:	ea05 0640 	and.w	r6, r5, r0, lsl #1
   3effe:	ea05 004e 	and.w	r0, r5, lr, lsl #1
	     ((uint32_t)b * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16;
   3f002:	ea04 1e4e 	and.w	lr, r4, lr, lsl #5
	b = (((uint32_t)b * 0x0802LU & 0x22110LU) |
   3f006:	433e      	orrs	r6, r7
   3f008:	ea40 000e 	orr.w	r0, r0, lr
	     ((uint32_t)b * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16;
   3f00c:	eb00 2700 	add.w	r7, r0, r0, lsl #8
   3f010:	eb06 2e06 	add.w	lr, r6, r6, lsl #8
   3f014:	eb06 260e 	add.w	r6, r6, lr, lsl #8
   3f018:	eb00 2007 	add.w	r0, r0, r7, lsl #8
   3f01c:	0c36      	lsrs	r6, r6, #16
	return (chan_rev_8((i >> 8) & 0xFF) << 8) | chan_rev_8(i & 0xFF);
   3f01e:	f3c0 4007 	ubfx	r0, r0, #16, #8
   3f022:	ea40 2006 	orr.w	r0, r0, r6, lsl #8
	return ((uint32_t)a * 17U + b) & 0xFFFF;
   3f026:	eb00 1000 	add.w	r0, r0, r0, lsl #4

	for (iterate = 0U; iterate < 3; iterate++) {
   3f02a:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
	return ((uint32_t)a * 17U + b) & 0xFFFF;
   3f02e:	4408      	add	r0, r1
	for (iterate = 0U; iterate < 3; iterate++) {
   3f030:	f01c 0cff 	ands.w	ip, ip, #255	; 0xff
	return ((uint32_t)a * 17U + b) & 0xFFFF;
   3f034:	b280      	uxth	r0, r0
	for (iterate = 0U; iterate < 3; iterate++) {
   3f036:	d1d7      	bne.n	3efe8 <lll_chan_sel_2+0xc>
static uint16_t chan_prn_e(uint16_t counter, uint16_t chan_id)
{
	uint16_t prn_e;

	prn_e = chan_prn_s(counter, chan_id);
	prn_e ^= chan_id;
   3f038:	4041      	eors	r1, r0
	chan_next = prn_e % 37;
   3f03a:	481f      	ldr	r0, [pc, #124]	; (3f0b8 <lll_chan_sel_2+0xdc>)
   3f03c:	fba0 4001 	umull	r4, r0, r0, r1
   3f040:	1a0c      	subs	r4, r1, r0
   3f042:	eb00 0054 	add.w	r0, r0, r4, lsr #1
   3f046:	0940      	lsrs	r0, r0, #5
   3f048:	eb00 04c0 	add.w	r4, r0, r0, lsl #3
   3f04c:	eb00 0084 	add.w	r0, r0, r4, lsl #2
   3f050:	1a08      	subs	r0, r1, r0
	if ((chan_map[chan_next >> 3] & (1 << (chan_next % 8))) == 0U) {
   3f052:	f3c0 04c4 	ubfx	r4, r0, #3, #5
   3f056:	f000 0507 	and.w	r5, r0, #7
   3f05a:	5d14      	ldrb	r4, [r2, r4]
   3f05c:	412c      	asrs	r4, r5
   3f05e:	07e4      	lsls	r4, r4, #31
	chan_next = prn_e % 37;
   3f060:	b2c0      	uxtb	r0, r0
	if ((chan_map[chan_next >> 3] & (1 << (chan_next % 8))) == 0U) {
   3f062:	d41c      	bmi.n	3f09e <lll_chan_sel_2+0xc2>
		chan_index = ((uint32_t)chan_count * prn_e) >> 16;
   3f064:	fb01 f303 	mul.w	r3, r1, r3
   3f068:	1e56      	subs	r6, r2, #1
   3f06a:	f3c3 4307 	ubfx	r3, r3, #16, #8
	while (byte_count--) {
   3f06e:	3204      	adds	r2, #4
	chan_next = 0U;
   3f070:	4660      	mov	r0, ip
		bite = *chan_map;
   3f072:	f100 0508 	add.w	r5, r0, #8
   3f076:	f816 cf01 	ldrb.w	ip, [r6, #1]!
		while (bit_count--) {
   3f07a:	b2ed      	uxtb	r5, r5
		bite = *chan_map;
   3f07c:	4601      	mov	r1, r0
			if (bite & 0x01) {
   3f07e:	f01c 0f01 	tst.w	ip, #1
			chan_next++;
   3f082:	f101 0401 	add.w	r4, r1, #1
			bite >>= 1;
   3f086:	ea4f 0c5c 	mov.w	ip, ip, lsr #1
			if (bite & 0x01) {
   3f08a:	d002      	beq.n	3f092 <lll_chan_sel_2+0xb6>
				if (chan_index == 0U) {
   3f08c:	b143      	cbz	r3, 3f0a0 <lll_chan_sel_2+0xc4>
				chan_index--;
   3f08e:	3b01      	subs	r3, #1
   3f090:	b2db      	uxtb	r3, r3
			chan_next++;
   3f092:	b2e1      	uxtb	r1, r4
		while (bit_count--) {
   3f094:	42a9      	cmp	r1, r5
   3f096:	d1f2      	bne.n	3f07e <lll_chan_sel_2+0xa2>
			chan_next++;
   3f098:	4608      	mov	r0, r1
	while (byte_count--) {
   3f09a:	4296      	cmp	r6, r2
   3f09c:	d1e9      	bne.n	3f072 <lll_chan_sel_2+0x96>
}
   3f09e:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (bit_count < 8) {
   3f0a0:	3007      	adds	r0, #7
   3f0a2:	1a40      	subs	r0, r0, r1
   3f0a4:	b2c0      	uxtb	r0, r0
   3f0a6:	2807      	cmp	r0, #7
   3f0a8:	4608      	mov	r0, r1
   3f0aa:	d8f6      	bhi.n	3f09a <lll_chan_sel_2+0xbe>
}
   3f0ac:	bdf0      	pop	{r4, r5, r6, r7, pc}
   3f0ae:	bf00      	nop
   3f0b0:	00022110 	.word	0x00022110
   3f0b4:	00088440 	.word	0x00088440
   3f0b8:	bacf914d 	.word	0xbacf914d

0003f0bc <radio_nrf5_isr>:
static void mfy_ticker_job_idle_get(void *param);
static void ticker_op_job_disable(uint32_t status, void *op_context);
#endif
#endif /* CONFIG_BT_CTLR_LOW_LAT */

ISR_DIRECT_DECLARE(radio_nrf5_isr)
   3f0bc:	4668      	mov	r0, sp
   3f0be:	f020 0107 	bic.w	r1, r0, #7
   3f0c2:	468d      	mov	sp, r1
   3f0c4:	b501      	push	{r0, lr}
{
	DEBUG_RADIO_ISR(1);

	lll_prof_enter_radio();

	isr_radio();
   3f0c6:	f002 fcfd 	bl	41ac4 <isr_radio>

	ISR_DIRECT_PM();
   3f0ca:	f7ed febb 	bl	2ce44 <_arch_isr_direct_pm>
{
#ifdef CONFIG_TRACING_ISR
	sys_trace_isr_exit();
#endif
	if (maybe_swap != 0) {
		z_arm_int_exit();
   3f0ce:	f7ed ff8b 	bl	2cfe8 <z_arm_exc_exit>
ISR_DIRECT_DECLARE(radio_nrf5_isr)
   3f0d2:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
   3f0d6:	4685      	mov	sp, r0
   3f0d8:	4770      	bx	lr
   3f0da:	bf00      	nop

0003f0dc <rtc0_nrf5_isr>:
	DEBUG_RADIO_ISR(0);
	return 1;
}

static void rtc0_nrf5_isr(const void *arg)
{
   3f0dc:	b508      	push	{r3, lr}
	DEBUG_TICKER_ISR(1);

	lll_prof_enter_ull_high();

	/* On compare0 run ticker worker instance0 */
	if (NRF_RTC0->EVENTS_COMPARE[0]) {
   3f0de:	4b09      	ldr	r3, [pc, #36]	; (3f104 <rtc0_nrf5_isr+0x28>)
   3f0e0:	f8d3 2140 	ldr.w	r2, [r3, #320]	; 0x140
   3f0e4:	b93a      	cbnz	r2, 3f0f6 <rtc0_nrf5_isr+0x1a>
		NRF_RTC0->EVENTS_COMPARE[0] = 0;

		ticker_trigger(0);
	}

	mayfly_run(TICKER_USER_ID_ULL_HIGH);
   3f0e6:	2001      	movs	r0, #1
   3f0e8:	f7f5 fb20 	bl	3472c <mayfly_run>

	lll_prof_exit_ull_low();
#endif

	DEBUG_TICKER_ISR(0);
}
   3f0ec:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	mayfly_run(TICKER_USER_ID_ULL_LOW);
   3f0f0:	2002      	movs	r0, #2
   3f0f2:	f7f5 bb1b 	b.w	3472c <mayfly_run>
		NRF_RTC0->EVENTS_COMPARE[0] = 0;
   3f0f6:	2000      	movs	r0, #0
   3f0f8:	f8c3 0140 	str.w	r0, [r3, #320]	; 0x140
		ticker_trigger(0);
   3f0fc:	f7f6 fbe4 	bl	358c8 <ticker_trigger>
   3f100:	e7f1      	b.n	3f0e6 <rtc0_nrf5_isr+0xa>
   3f102:	bf00      	nop
   3f104:	4000b000 	.word	0x4000b000

0003f108 <swi_lll_nrf5_isr>:
{
	DEBUG_RADIO_ISR(1);

	lll_prof_enter_lll();

	mayfly_run(TICKER_USER_ID_LLL);
   3f108:	2000      	movs	r0, #0
   3f10a:	f7f5 bb0f 	b.w	3472c <mayfly_run>
   3f10e:	bf00      	nop

0003f110 <ticker_start_op_cb>:

	preempt_req = preempt_ack;
}

static void ticker_start_op_cb(uint32_t status, void *param)
{
   3f110:	b538      	push	{r3, r4, r5, lr}
	ARG_UNUSED(param);
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
   3f112:	b9f8      	cbnz	r0, 3f154 <ticker_start_op_cb+0x44>

	LL_ASSERT(preempt_start_req != preempt_start_ack);
   3f114:	4b1e      	ldr	r3, [pc, #120]	; (3f190 <ticker_start_op_cb+0x80>)
   3f116:	4d1f      	ldr	r5, [pc, #124]	; (3f194 <ticker_start_op_cb+0x84>)
   3f118:	781a      	ldrb	r2, [r3, #0]
   3f11a:	782b      	ldrb	r3, [r5, #0]
   3f11c:	429a      	cmp	r2, r3
   3f11e:	d027      	beq.n	3f170 <ticker_start_op_cb+0x60>
	preempt_start_ack++;

	LL_ASSERT(preempt_req == preempt_ack);
   3f120:	4a1d      	ldr	r2, [pc, #116]	; (3f198 <ticker_start_op_cb+0x88>)
   3f122:	4c1e      	ldr	r4, [pc, #120]	; (3f19c <ticker_start_op_cb+0x8c>)
   3f124:	7812      	ldrb	r2, [r2, #0]
   3f126:	7821      	ldrb	r1, [r4, #0]
	preempt_start_ack++;
   3f128:	3301      	adds	r3, #1
	LL_ASSERT(preempt_req == preempt_ack);
   3f12a:	4291      	cmp	r1, r2
	preempt_start_ack++;
   3f12c:	702b      	strb	r3, [r5, #0]
	LL_ASSERT(preempt_req == preempt_ack);
   3f12e:	b2d3      	uxtb	r3, r2
   3f130:	d00d      	beq.n	3f14e <ticker_start_op_cb+0x3e>
   3f132:	4a1b      	ldr	r2, [pc, #108]	; (3f1a0 <ticker_start_op_cb+0x90>)
   3f134:	491b      	ldr	r1, [pc, #108]	; (3f1a4 <ticker_start_op_cb+0x94>)
   3f136:	481c      	ldr	r0, [pc, #112]	; (3f1a8 <ticker_start_op_cb+0x98>)
   3f138:	f240 332e 	movw	r3, #814	; 0x32e
   3f13c:	f009 ffa2 	bl	49084 <assert_print>
   3f140:	4040      	eors	r0, r0
   3f142:	f380 8811 	msr	BASEPRI, r0
   3f146:	f04f 0003 	mov.w	r0, #3
   3f14a:	df02      	svc	2
	preempt_req++;
   3f14c:	7823      	ldrb	r3, [r4, #0]
   3f14e:	3301      	adds	r3, #1
   3f150:	7023      	strb	r3, [r4, #0]
}
   3f152:	bd38      	pop	{r3, r4, r5, pc}
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
   3f154:	4a12      	ldr	r2, [pc, #72]	; (3f1a0 <ticker_start_op_cb+0x90>)
   3f156:	4915      	ldr	r1, [pc, #84]	; (3f1ac <ticker_start_op_cb+0x9c>)
   3f158:	4813      	ldr	r0, [pc, #76]	; (3f1a8 <ticker_start_op_cb+0x98>)
   3f15a:	f240 3329 	movw	r3, #809	; 0x329
   3f15e:	f009 ff91 	bl	49084 <assert_print>
   3f162:	4040      	eors	r0, r0
   3f164:	f380 8811 	msr	BASEPRI, r0
   3f168:	f04f 0003 	mov.w	r0, #3
   3f16c:	df02      	svc	2
   3f16e:	e7d1      	b.n	3f114 <ticker_start_op_cb+0x4>
	LL_ASSERT(preempt_start_req != preempt_start_ack);
   3f170:	4a0b      	ldr	r2, [pc, #44]	; (3f1a0 <ticker_start_op_cb+0x90>)
   3f172:	490f      	ldr	r1, [pc, #60]	; (3f1b0 <ticker_start_op_cb+0xa0>)
   3f174:	480c      	ldr	r0, [pc, #48]	; (3f1a8 <ticker_start_op_cb+0x98>)
   3f176:	f240 332b 	movw	r3, #811	; 0x32b
   3f17a:	f009 ff83 	bl	49084 <assert_print>
   3f17e:	4040      	eors	r0, r0
   3f180:	f380 8811 	msr	BASEPRI, r0
   3f184:	f04f 0003 	mov.w	r0, #3
   3f188:	df02      	svc	2
	preempt_start_ack++;
   3f18a:	782b      	ldrb	r3, [r5, #0]
   3f18c:	e7c8      	b.n	3f120 <ticker_start_op_cb+0x10>
   3f18e:	bf00      	nop
   3f190:	20006bb2 	.word	0x20006bb2
   3f194:	20006bb1 	.word	0x20006bb1
   3f198:	20006bad 	.word	0x20006bad
   3f19c:	20006bae 	.word	0x20006bae
   3f1a0:	000529e0 	.word	0x000529e0
   3f1a4:	00052a50 	.word	0x00052a50
   3f1a8:	0005214c 	.word	0x0005214c
   3f1ac:	000526fc 	.word	0x000526fc
   3f1b0:	00052a28 	.word	0x00052a28

0003f1b4 <ticker_stop_op_cb>:
{
   3f1b4:	b510      	push	{r4, lr}
	LL_ASSERT(preempt_stop_req != preempt_stop_ack);
   3f1b6:	4b0e      	ldr	r3, [pc, #56]	; (3f1f0 <ticker_stop_op_cb+0x3c>)
   3f1b8:	4c0e      	ldr	r4, [pc, #56]	; (3f1f4 <ticker_stop_op_cb+0x40>)
   3f1ba:	781a      	ldrb	r2, [r3, #0]
   3f1bc:	7823      	ldrb	r3, [r4, #0]
   3f1be:	429a      	cmp	r2, r3
   3f1c0:	d006      	beq.n	3f1d0 <ticker_stop_op_cb+0x1c>
	preempt_req = preempt_ack;
   3f1c2:	490d      	ldr	r1, [pc, #52]	; (3f1f8 <ticker_stop_op_cb+0x44>)
   3f1c4:	4a0d      	ldr	r2, [pc, #52]	; (3f1fc <ticker_stop_op_cb+0x48>)
   3f1c6:	7809      	ldrb	r1, [r1, #0]
   3f1c8:	7011      	strb	r1, [r2, #0]
	preempt_stop_ack++;
   3f1ca:	3301      	adds	r3, #1
   3f1cc:	7023      	strb	r3, [r4, #0]
}
   3f1ce:	bd10      	pop	{r4, pc}
	LL_ASSERT(preempt_stop_req != preempt_stop_ack);
   3f1d0:	4a0b      	ldr	r2, [pc, #44]	; (3f200 <ticker_stop_op_cb+0x4c>)
   3f1d2:	490c      	ldr	r1, [pc, #48]	; (3f204 <ticker_stop_op_cb+0x50>)
   3f1d4:	480c      	ldr	r0, [pc, #48]	; (3f208 <ticker_stop_op_cb+0x54>)
   3f1d6:	f44f 7348 	mov.w	r3, #800	; 0x320
   3f1da:	f009 ff53 	bl	49084 <assert_print>
   3f1de:	4040      	eors	r0, r0
   3f1e0:	f380 8811 	msr	BASEPRI, r0
   3f1e4:	f04f 0003 	mov.w	r0, #3
   3f1e8:	df02      	svc	2
	preempt_stop_ack++;
   3f1ea:	7823      	ldrb	r3, [r4, #0]
   3f1ec:	e7e9      	b.n	3f1c2 <ticker_stop_op_cb+0xe>
   3f1ee:	bf00      	nop
   3f1f0:	20006bb0 	.word	0x20006bb0
   3f1f4:	20006baf 	.word	0x20006baf
   3f1f8:	20006bad 	.word	0x20006bad
   3f1fc:	20006bae 	.word	0x20006bae
   3f200:	000529e0 	.word	0x000529e0
   3f204:	00052a6c 	.word	0x00052a6c
   3f208:	0005214c 	.word	0x0005214c

0003f20c <isr_race>:
	radio_status_reset();
   3f20c:	f002 bd70 	b.w	41cf0 <radio_status_reset>

0003f210 <preempt_ticker_cb>:
}

static void preempt_ticker_cb(uint32_t ticks_at_expire, uint32_t ticks_drift,
			      uint32_t remainder, uint16_t lazy, uint8_t force,
			      void *param)
{
   3f210:	b510      	push	{r4, lr}
	static memq_link_t link;
	static struct mayfly mfy = {0, 0, &link, NULL, preempt};
	uint32_t ret;

	LL_ASSERT(preempt_ack != preempt_req);
   3f212:	4a18      	ldr	r2, [pc, #96]	; (3f274 <preempt_ticker_cb+0x64>)
   3f214:	4c18      	ldr	r4, [pc, #96]	; (3f278 <preempt_ticker_cb+0x68>)
   3f216:	7812      	ldrb	r2, [r2, #0]
   3f218:	7823      	ldrb	r3, [r4, #0]
   3f21a:	429a      	cmp	r2, r3
   3f21c:	d01b      	beq.n	3f256 <preempt_ticker_cb+0x46>
	preempt_ack++;
   3f21e:	7821      	ldrb	r1, [r4, #0]

	mfy.param = param;
   3f220:	4b16      	ldr	r3, [pc, #88]	; (3f27c <preempt_ticker_cb+0x6c>)
	preempt_ack++;
   3f222:	3101      	adds	r1, #1
   3f224:	b2c9      	uxtb	r1, r1
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
   3f226:	2200      	movs	r2, #0
	preempt_ack++;
   3f228:	7021      	strb	r1, [r4, #0]
	mfy.param = param;
   3f22a:	9903      	ldr	r1, [sp, #12]
   3f22c:	6099      	str	r1, [r3, #8]
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
   3f22e:	2001      	movs	r0, #1
   3f230:	4611      	mov	r1, r2
   3f232:	f7f5 fa1d 	bl	34670 <mayfly_enqueue>
			     0, &mfy);
	LL_ASSERT(!ret);
   3f236:	b900      	cbnz	r0, 3f23a <preempt_ticker_cb+0x2a>
}
   3f238:	bd10      	pop	{r4, pc}
	LL_ASSERT(!ret);
   3f23a:	4a11      	ldr	r2, [pc, #68]	; (3f280 <preempt_ticker_cb+0x70>)
   3f23c:	4911      	ldr	r1, [pc, #68]	; (3f284 <preempt_ticker_cb+0x74>)
   3f23e:	4812      	ldr	r0, [pc, #72]	; (3f288 <preempt_ticker_cb+0x78>)
   3f240:	f44f 736b 	mov.w	r3, #940	; 0x3ac
   3f244:	f009 ff1e 	bl	49084 <assert_print>
   3f248:	4040      	eors	r0, r0
   3f24a:	f380 8811 	msr	BASEPRI, r0
   3f24e:	f04f 0003 	mov.w	r0, #3
   3f252:	df02      	svc	2
}
   3f254:	bd10      	pop	{r4, pc}
	LL_ASSERT(preempt_ack != preempt_req);
   3f256:	4a0a      	ldr	r2, [pc, #40]	; (3f280 <preempt_ticker_cb+0x70>)
   3f258:	490c      	ldr	r1, [pc, #48]	; (3f28c <preempt_ticker_cb+0x7c>)
   3f25a:	480b      	ldr	r0, [pc, #44]	; (3f288 <preempt_ticker_cb+0x78>)
   3f25c:	f240 33a6 	movw	r3, #934	; 0x3a6
   3f260:	f009 ff10 	bl	49084 <assert_print>
   3f264:	4040      	eors	r0, r0
   3f266:	f380 8811 	msr	BASEPRI, r0
   3f26a:	f04f 0003 	mov.w	r0, #3
   3f26e:	df02      	svc	2
   3f270:	e7d5      	b.n	3f21e <preempt_ticker_cb+0xe>
   3f272:	bf00      	nop
   3f274:	20006bae 	.word	0x20006bae
   3f278:	20006bad 	.word	0x20006bad
   3f27c:	20000c84 	.word	0x20000c84
   3f280:	000529e0 	.word	0x000529e0
   3f284:	00052430 	.word	0x00052430
   3f288:	0005214c 	.word	0x0005214c
   3f28c:	00052a94 	.word	0x00052a94

0003f290 <preempt_ticker_start>:
{
   3f290:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if ((preempt_start_req != preempt_start_ack) ||
   3f294:	f8df 8144 	ldr.w	r8, [pc, #324]	; 3f3dc <preempt_ticker_start+0x14c>
{
   3f298:	4615      	mov	r5, r2
	if ((preempt_start_req != preempt_start_ack) ||
   3f29a:	4a51      	ldr	r2, [pc, #324]	; (3f3e0 <preempt_ticker_start+0x150>)
   3f29c:	f898 3000 	ldrb.w	r3, [r8]
   3f2a0:	7812      	ldrb	r2, [r2, #0]
   3f2a2:	429a      	cmp	r2, r3
{
   3f2a4:	b08a      	sub	sp, #40	; 0x28
   3f2a6:	460c      	mov	r4, r1
	if ((preempt_start_req != preempt_start_ack) ||
   3f2a8:	d04a      	beq.n	3f340 <preempt_ticker_start+0xb0>
		if (!prev || prev->is_aborted ||
   3f2aa:	2c00      	cmp	r4, #0
   3f2ac:	d063      	beq.n	3f376 <preempt_ticker_start+0xe6>
   3f2ae:	7f22      	ldrb	r2, [r4, #28]
   3f2b0:	f012 0202 	ands.w	r2, r2, #2
   3f2b4:	d15f      	bne.n	3f376 <preempt_ticker_start+0xe6>
		ull = HDR_LLL2ULL(p->param);
   3f2b6:	68eb      	ldr	r3, [r5, #12]
		preempt_anchor = p->ticks_at_expire;
   3f2b8:	f8d5 a000 	ldr.w	sl, [r5]
		ull = HDR_LLL2ULL(p->param);
   3f2bc:	681b      	ldr	r3, [r3, #0]
		diff = ticks_at_preempt_new - ticks_at_preempt;
   3f2be:	f8df 9124 	ldr.w	r9, [pc, #292]	; 3f3e4 <preempt_ticker_start+0x154>
		preempt_to = MAX(ull->ticks_active_to_start,
   3f2c2:	68df      	ldr	r7, [r3, #12]
   3f2c4:	e9d3 1001 	ldrd	r1, r0, [r3, #4]
   3f2c8:	4288      	cmp	r0, r1
   3f2ca:	bf2c      	ite	cs
   3f2cc:	ebc7 0700 	rsbcs	r7, r7, r0
   3f2d0:	ebc7 0701 	rsbcc	r7, r7, r1
		ticks_at_preempt_new = preempt_anchor + preempt_to;
   3f2d4:	eb0a 0607 	add.w	r6, sl, r7
		diff = ticks_at_preempt_new - ticks_at_preempt;
   3f2d8:	f8d9 0000 	ldr.w	r0, [r9]
		ticks_at_preempt_new &= HAL_TICKER_CNTR_MASK;
   3f2dc:	f026 467f 	bic.w	r6, r6, #4278190080	; 0xff000000
		diff = ticks_at_preempt_new - ticks_at_preempt;
   3f2e0:	1a30      	subs	r0, r6, r0
		if (!prev || prev->is_aborted ||
   3f2e2:	f410 0000 	ands.w	r0, r0, #8388608	; 0x800000
   3f2e6:	d047      	beq.n	3f378 <preempt_ticker_start+0xe8>
	if ((preempt_stop_req != preempt_stop_ack) ||
   3f2e8:	493f      	ldr	r1, [pc, #252]	; (3f3e8 <preempt_ticker_start+0x158>)
   3f2ea:	4b40      	ldr	r3, [pc, #256]	; (3f3ec <preempt_ticker_start+0x15c>)
   3f2ec:	7808      	ldrb	r0, [r1, #0]
   3f2ee:	7819      	ldrb	r1, [r3, #0]
   3f2f0:	4288      	cmp	r0, r1
   3f2f2:	d044      	beq.n	3f37e <preempt_ticker_start+0xee>
		prev->is_aborted = 1U;
   3f2f4:	7f23      	ldrb	r3, [r4, #28]
		prev->abort_cb(&prev->prepare_param, prev->prepare_param.param);
   3f2f6:	68e1      	ldr	r1, [r4, #12]
		ticks_at_preempt = ticks_at_preempt_new;
   3f2f8:	f8c9 6000 	str.w	r6, [r9]
		prev->is_aborted = 1U;
   3f2fc:	f043 0302 	orr.w	r3, r3, #2
   3f300:	7723      	strb	r3, [r4, #28]
		prev->abort_cb(&prev->prepare_param, prev->prepare_param.param);
   3f302:	4620      	mov	r0, r4
   3f304:	69a3      	ldr	r3, [r4, #24]
   3f306:	4798      	blx	r3
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
   3f308:	4b39      	ldr	r3, [pc, #228]	; (3f3f0 <preempt_ticker_start+0x160>)
	ticks_at_preempt = ticks_at_preempt_new;
   3f30a:	f8c9 6000 	str.w	r6, [r9]
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
   3f30e:	e9cd 3507 	strd	r3, r5, [sp, #28]
   3f312:	4b38      	ldr	r3, [pc, #224]	; (3f3f4 <preempt_ticker_start+0x164>)
   3f314:	9700      	str	r7, [sp, #0]
   3f316:	2200      	movs	r2, #0
   3f318:	e9cd 3505 	strd	r3, r5, [sp, #20]
   3f31c:	e9cd 2203 	strd	r2, r2, [sp, #12]
   3f320:	e9cd 2201 	strd	r2, r2, [sp, #4]
	preempt_start_req++;
   3f324:	f898 4000 	ldrb.w	r4, [r8]
   3f328:	3401      	adds	r4, #1
   3f32a:	b2e4      	uxtb	r4, r4
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
   3f32c:	4653      	mov	r3, sl
   3f32e:	4611      	mov	r1, r2
   3f330:	4610      	mov	r0, r2
	preempt_start_req++;
   3f332:	f888 4000 	strb.w	r4, [r8]
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
   3f336:	f7f6 fb35 	bl	359a4 <ticker_start>
}
   3f33a:	b00a      	add	sp, #40	; 0x28
   3f33c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	    (preempt_req != preempt_ack)) {
   3f340:	4b2d      	ldr	r3, [pc, #180]	; (3f3f8 <preempt_ticker_start+0x168>)
   3f342:	4a2e      	ldr	r2, [pc, #184]	; (3f3fc <preempt_ticker_start+0x16c>)
   3f344:	781b      	ldrb	r3, [r3, #0]
	if ((preempt_start_req != preempt_start_ack) ||
   3f346:	7812      	ldrb	r2, [r2, #0]
   3f348:	429a      	cmp	r2, r3
   3f34a:	d1ae      	bne.n	3f2aa <preempt_ticker_start+0x1a>
		ull = HDR_LLL2ULL(p->param);
   3f34c:	68c3      	ldr	r3, [r0, #12]
		preempt_anchor = p->ticks_at_expire;
   3f34e:	f8d0 a000 	ldr.w	sl, [r0]
		ull = HDR_LLL2ULL(p->param);
   3f352:	681b      	ldr	r3, [r3, #0]
		preempt_to = MAX(ull->ticks_active_to_start,
   3f354:	f8df 908c 	ldr.w	r9, [pc, #140]	; 3f3e4 <preempt_ticker_start+0x154>
   3f358:	68df      	ldr	r7, [r3, #12]
   3f35a:	e9d3 2101 	ldrd	r2, r1, [r3, #4]
   3f35e:	4291      	cmp	r1, r2
   3f360:	bf2c      	ite	cs
   3f362:	ebc7 0701 	rsbcs	r7, r7, r1
   3f366:	ebc7 0702 	rsbcc	r7, r7, r2
		ticks_at_preempt_new = preempt_anchor + preempt_to;
   3f36a:	eb0a 0607 	add.w	r6, sl, r7
		ticks_at_preempt_new &= HAL_TICKER_CNTR_MASK;
   3f36e:	4605      	mov	r5, r0
   3f370:	f026 467f 	bic.w	r6, r6, #4278190080	; 0xff000000
   3f374:	e7c8      	b.n	3f308 <preempt_ticker_start+0x78>
			return TICKER_STATUS_SUCCESS;
   3f376:	2000      	movs	r0, #0
}
   3f378:	b00a      	add	sp, #40	; 0x28
   3f37a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	    (preempt_req == preempt_ack)) {
   3f37e:	491e      	ldr	r1, [pc, #120]	; (3f3f8 <preempt_ticker_start+0x168>)
   3f380:	481e      	ldr	r0, [pc, #120]	; (3f3fc <preempt_ticker_start+0x16c>)
   3f382:	7809      	ldrb	r1, [r1, #0]
	if ((preempt_stop_req != preempt_stop_ack) ||
   3f384:	7800      	ldrb	r0, [r0, #0]
   3f386:	4288      	cmp	r0, r1
   3f388:	d0b4      	beq.n	3f2f4 <preempt_ticker_start+0x64>
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR,
   3f38a:	9200      	str	r2, [sp, #0]
	preempt_stop_req++;
   3f38c:	7819      	ldrb	r1, [r3, #0]
   3f38e:	3101      	adds	r1, #1
   3f390:	b2c9      	uxtb	r1, r1
   3f392:	7019      	strb	r1, [r3, #0]
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR,
   3f394:	4610      	mov	r0, r2
   3f396:	4b1a      	ldr	r3, [pc, #104]	; (3f400 <preempt_ticker_start+0x170>)
   3f398:	4611      	mov	r1, r2
   3f39a:	f7f6 fb8f 	bl	35abc <ticker_stop>
	LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
   3f39e:	f030 0302 	bics.w	r3, r0, #2
   3f3a2:	d0a7      	beq.n	3f2f4 <preempt_ticker_start+0x64>
   3f3a4:	4a17      	ldr	r2, [pc, #92]	; (3f404 <preempt_ticker_start+0x174>)
   3f3a6:	4918      	ldr	r1, [pc, #96]	; (3f408 <preempt_ticker_start+0x178>)
   3f3a8:	4818      	ldr	r0, [pc, #96]	; (3f40c <preempt_ticker_start+0x17c>)
   3f3aa:	f44f 7366 	mov.w	r3, #920	; 0x398
   3f3ae:	f009 fe69 	bl	49084 <assert_print>
   3f3b2:	4040      	eors	r0, r0
   3f3b4:	f380 8811 	msr	BASEPRI, r0
   3f3b8:	f04f 0003 	mov.w	r0, #3
   3f3bc:	df02      	svc	2
		LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
   3f3be:	4a11      	ldr	r2, [pc, #68]	; (3f404 <preempt_ticker_start+0x174>)
   3f3c0:	4911      	ldr	r1, [pc, #68]	; (3f408 <preempt_ticker_start+0x178>)
   3f3c2:	4812      	ldr	r0, [pc, #72]	; (3f40c <preempt_ticker_start+0x17c>)
   3f3c4:	f240 3357 	movw	r3, #855	; 0x357
   3f3c8:	f009 fe5c 	bl	49084 <assert_print>
   3f3cc:	4040      	eors	r0, r0
   3f3ce:	f380 8811 	msr	BASEPRI, r0
   3f3d2:	f04f 0003 	mov.w	r0, #3
   3f3d6:	df02      	svc	2
   3f3d8:	e78c      	b.n	3f2f4 <preempt_ticker_start+0x64>
   3f3da:	bf00      	nop
   3f3dc:	20006bb2 	.word	0x20006bb2
   3f3e0:	20006bb1 	.word	0x20006bb1
   3f3e4:	2000592c 	.word	0x2000592c
   3f3e8:	20006baf 	.word	0x20006baf
   3f3ec:	20006bb0 	.word	0x20006bb0
   3f3f0:	0003f111 	.word	0x0003f111
   3f3f4:	0003f211 	.word	0x0003f211
   3f3f8:	20006bad 	.word	0x20006bad
   3f3fc:	20006bae 	.word	0x20006bae
   3f400:	0003f1b5 	.word	0x0003f1b5
   3f404:	000529e0 	.word	0x000529e0
   3f408:	00052504 	.word	0x00052504
   3f40c:	0005214c 	.word	0x0005214c

0003f410 <preempt>:

static void preempt(void *param)
{
   3f410:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct lll_event *next;
	uint8_t idx;
	int err;

	/* No event to abort */
	if (!event.curr.abort_cb || !event.curr.param) {
   3f412:	4e4b      	ldr	r6, [pc, #300]	; (3f540 <preempt+0x130>)
   3f414:	68b3      	ldr	r3, [r6, #8]
{
   3f416:	b089      	sub	sp, #36	; 0x24
	if (!event.curr.abort_cb || !event.curr.param) {
   3f418:	b15b      	cbz	r3, 3f432 <preempt+0x22>
   3f41a:	6833      	ldr	r3, [r6, #0]
   3f41c:	b14b      	cbz	r3, 3f432 <preempt+0x22>
		return;
	}

	/* Check if any prepare in pipeline */
	idx = UINT8_MAX;
   3f41e:	23ff      	movs	r3, #255	; 0xff
   3f420:	4605      	mov	r5, r0
	next = ull_prepare_dequeue_iter(&idx);
   3f422:	f10d 000a 	add.w	r0, sp, #10
	idx = UINT8_MAX;
   3f426:	f88d 300a 	strb.w	r3, [sp, #10]
	next = ull_prepare_dequeue_iter(&idx);
   3f42a:	f7f8 febf 	bl	381ac <ull_prepare_dequeue_iter>
	if (!next) {
   3f42e:	4602      	mov	r2, r0
   3f430:	b930      	cbnz	r0, 3f440 <preempt+0x30>
		iter = resume_enqueue(resume_cb);
		LL_ASSERT(iter);
	} else {
		LL_ASSERT(err == -ECANCELED);
	}
}
   3f432:	b009      	add	sp, #36	; 0x24
   3f434:	bdf0      	pop	{r4, r5, r6, r7, pc}
		next = ull_prepare_dequeue_iter(&idx);
   3f436:	f7f8 feb9 	bl	381ac <ull_prepare_dequeue_iter>
	while (next && (next->is_aborted || next->is_resume)) {
   3f43a:	4602      	mov	r2, r0
   3f43c:	2800      	cmp	r0, #0
   3f43e:	d0f8      	beq.n	3f432 <preempt+0x22>
   3f440:	7f11      	ldrb	r1, [r2, #28]
   3f442:	f011 0403 	ands.w	r4, r1, #3
		next = ull_prepare_dequeue_iter(&idx);
   3f446:	f10d 000a 	add.w	r0, sp, #10
	while (next && (next->is_aborted || next->is_resume)) {
   3f44a:	d1f4      	bne.n	3f436 <preempt+0x26>
	if (next != param) {
   3f44c:	4295      	cmp	r5, r2
   3f44e:	d126      	bne.n	3f49e <preempt+0x8e>
	err = event.curr.is_abort_cb(next->prepare_param.param,
   3f450:	6873      	ldr	r3, [r6, #4]
   3f452:	6831      	ldr	r1, [r6, #0]
   3f454:	68e8      	ldr	r0, [r5, #12]
   3f456:	aa03      	add	r2, sp, #12
   3f458:	4798      	blx	r3
	if (!err) {
   3f45a:	4607      	mov	r7, r0
   3f45c:	b1b0      	cbz	r0, 3f48c <preempt+0x7c>
	event.curr.abort_cb(NULL, event.curr.param);
   3f45e:	68b3      	ldr	r3, [r6, #8]
   3f460:	6831      	ldr	r1, [r6, #0]
   3f462:	4620      	mov	r0, r4
   3f464:	4798      	blx	r3
	if (err == -EAGAIN) {
   3f466:	f117 0f0b 	cmn.w	r7, #11
   3f46a:	d02d      	beq.n	3f4c8 <preempt+0xb8>
		LL_ASSERT(err == -ECANCELED);
   3f46c:	378c      	adds	r7, #140	; 0x8c
   3f46e:	d0e0      	beq.n	3f432 <preempt+0x22>
   3f470:	4a34      	ldr	r2, [pc, #208]	; (3f544 <preempt+0x134>)
   3f472:	4935      	ldr	r1, [pc, #212]	; (3f548 <preempt+0x138>)
   3f474:	4835      	ldr	r0, [pc, #212]	; (3f54c <preempt+0x13c>)
   3f476:	f240 4306 	movw	r3, #1030	; 0x406
   3f47a:	f009 fe03 	bl	49084 <assert_print>
   3f47e:	4040      	eors	r0, r0
   3f480:	f380 8811 	msr	BASEPRI, r0
   3f484:	f04f 0003 	mov.w	r0, #3
   3f488:	df02      	svc	2
   3f48a:	e7d2      	b.n	3f432 <preempt+0x22>
		next->is_aborted = 1;
   3f48c:	7f2b      	ldrb	r3, [r5, #28]
		next->abort_cb(&next->prepare_param, next->prepare_param.param);
   3f48e:	69aa      	ldr	r2, [r5, #24]
   3f490:	68e9      	ldr	r1, [r5, #12]
		next->is_aborted = 1;
   3f492:	f043 0302 	orr.w	r3, r3, #2
   3f496:	772b      	strb	r3, [r5, #28]
		next->abort_cb(&next->prepare_param, next->prepare_param.param);
   3f498:	4628      	mov	r0, r5
   3f49a:	4790      	blx	r2
		return;
   3f49c:	e7c9      	b.n	3f432 <preempt+0x22>
		ret = preempt_ticker_start(next, NULL, next);
   3f49e:	4621      	mov	r1, r4
   3f4a0:	4610      	mov	r0, r2
   3f4a2:	f7ff fef5 	bl	3f290 <preempt_ticker_start>
		LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
   3f4a6:	f030 0302 	bics.w	r3, r0, #2
   3f4aa:	d0c2      	beq.n	3f432 <preempt+0x22>
   3f4ac:	4a25      	ldr	r2, [pc, #148]	; (3f544 <preempt+0x134>)
   3f4ae:	4928      	ldr	r1, [pc, #160]	; (3f550 <preempt+0x140>)
   3f4b0:	4826      	ldr	r0, [pc, #152]	; (3f54c <preempt+0x13c>)
   3f4b2:	f240 33d2 	movw	r3, #978	; 0x3d2
   3f4b6:	f009 fde5 	bl	49084 <assert_print>
   3f4ba:	4040      	eors	r0, r0
   3f4bc:	f380 8811 	msr	BASEPRI, r0
   3f4c0:	f04f 0003 	mov.w	r0, #3
   3f4c4:	df02      	svc	2
   3f4c6:	e7b4      	b.n	3f432 <preempt+0x22>
		iter_idx = UINT8_MAX;
   3f4c8:	24ff      	movs	r4, #255	; 0xff
		iter = ull_prepare_dequeue_iter(&iter_idx);
   3f4ca:	f10d 000b 	add.w	r0, sp, #11
		iter_idx = UINT8_MAX;
   3f4ce:	f88d 400b 	strb.w	r4, [sp, #11]
		iter = ull_prepare_dequeue_iter(&iter_idx);
   3f4d2:	f7f8 fe6b 	bl	381ac <ull_prepare_dequeue_iter>
		while (iter) {
   3f4d6:	b928      	cbnz	r0, 3f4e4 <preempt+0xd4>
   3f4d8:	e013      	b.n	3f502 <preempt+0xf2>
			iter = ull_prepare_dequeue_iter(&iter_idx);
   3f4da:	f10d 000b 	add.w	r0, sp, #11
   3f4de:	f7f8 fe65 	bl	381ac <ull_prepare_dequeue_iter>
		while (iter) {
   3f4e2:	b170      	cbz	r0, 3f502 <preempt+0xf2>
			if (!iter->is_aborted &&
   3f4e4:	7f03      	ldrb	r3, [r0, #28]
   3f4e6:	079a      	lsls	r2, r3, #30
   3f4e8:	d4f7      	bmi.n	3f4da <preempt+0xca>
			    event.curr.param == iter->prepare_param.param) {
   3f4ea:	68c2      	ldr	r2, [r0, #12]
			if (!iter->is_aborted &&
   3f4ec:	6831      	ldr	r1, [r6, #0]
   3f4ee:	4291      	cmp	r1, r2
   3f4f0:	d1f3      	bne.n	3f4da <preempt+0xca>
				iter->is_aborted = 1;
   3f4f2:	f043 0302 	orr.w	r3, r3, #2
   3f4f6:	7703      	strb	r3, [r0, #28]
				iter->abort_cb(&iter->prepare_param,
   3f4f8:	6983      	ldr	r3, [r0, #24]
   3f4fa:	4798      	blx	r3
				iter_idx = UINT8_MAX;
   3f4fc:	f88d 400b 	strb.w	r4, [sp, #11]
   3f500:	e7eb      	b.n	3f4da <preempt+0xca>
	return ull_prepare_enqueue(event.curr.is_abort_cb, event.curr.abort_cb,
   3f502:	2301      	movs	r3, #1
	prepare_param.param = event.curr.param;
   3f504:	6830      	ldr	r0, [r6, #0]
	return ull_prepare_enqueue(event.curr.is_abort_cb, event.curr.abort_cb,
   3f506:	9300      	str	r3, [sp, #0]
	struct lll_prepare_param prepare_param = {0};
   3f508:	2100      	movs	r1, #0
   3f50a:	e9cd 1104 	strd	r1, r1, [sp, #16]
   3f50e:	9106      	str	r1, [sp, #24]
	prepare_param.param = event.curr.param;
   3f510:	9007      	str	r0, [sp, #28]
	event.curr.param = NULL;
   3f512:	6031      	str	r1, [r6, #0]
	return ull_prepare_enqueue(event.curr.is_abort_cb, event.curr.abort_cb,
   3f514:	9b03      	ldr	r3, [sp, #12]
   3f516:	e9d6 0101 	ldrd	r0, r1, [r6, #4]
   3f51a:	aa04      	add	r2, sp, #16
   3f51c:	f7f8 fe06 	bl	3812c <ull_prepare_enqueue>
		LL_ASSERT(iter);
   3f520:	2800      	cmp	r0, #0
   3f522:	d186      	bne.n	3f432 <preempt+0x22>
   3f524:	4a07      	ldr	r2, [pc, #28]	; (3f544 <preempt+0x134>)
   3f526:	490b      	ldr	r1, [pc, #44]	; (3f554 <preempt+0x144>)
   3f528:	4808      	ldr	r0, [pc, #32]	; (3f54c <preempt+0x13c>)
   3f52a:	f240 4304 	movw	r3, #1028	; 0x404
   3f52e:	f009 fda9 	bl	49084 <assert_print>
   3f532:	4040      	eors	r0, r0
   3f534:	f380 8811 	msr	BASEPRI, r0
   3f538:	f04f 0003 	mov.w	r0, #3
   3f53c:	df02      	svc	2
   3f53e:	e778      	b.n	3f432 <preempt+0x22>
   3f540:	20005930 	.word	0x20005930
   3f544:	000529e0 	.word	0x000529e0
   3f548:	00052ab8 	.word	0x00052ab8
   3f54c:	0005214c 	.word	0x0005214c
   3f550:	00052504 	.word	0x00052504
   3f554:	00052ab0 	.word	0x00052ab0

0003f558 <lll_init>:
{
   3f558:	b510      	push	{r4, lr}
   3f55a:	4815      	ldr	r0, [pc, #84]	; (3f5b0 <lll_init+0x58>)
   3f55c:	f010 fa93 	bl	4fa86 <z_device_is_ready>
	if (!device_is_ready(dev_entropy)) {
   3f560:	b310      	cbz	r0, 3f5a8 <lll_init+0x50>
	event.curr.abort_cb = NULL;
   3f562:	4b14      	ldr	r3, [pc, #80]	; (3f5b4 <lll_init+0x5c>)
   3f564:	2400      	movs	r4, #0
   3f566:	609c      	str	r4, [r3, #8]
	err = lll_clock_init();
   3f568:	f000 fb06 	bl	3fb78 <lll_clock_init>
	if (err < 0) {
   3f56c:	2800      	cmp	r0, #0
   3f56e:	db1a      	blt.n	3f5a6 <lll_init+0x4e>
	IRQ_DIRECT_CONNECT(RADIO_IRQn, CONFIG_BT_CTLR_LLL_PRIO,
   3f570:	4621      	mov	r1, r4
   3f572:	2001      	movs	r0, #1
   3f574:	4622      	mov	r2, r4
   3f576:	f7ed fc4d 	bl	2ce14 <z_arm_irq_priority_set>
	IRQ_CONNECT(RTC0_IRQn, CONFIG_BT_CTLR_ULL_HIGH_PRIO,
   3f57a:	4622      	mov	r2, r4
   3f57c:	200b      	movs	r0, #11
   3f57e:	2101      	movs	r1, #1
   3f580:	f7ed fc48 	bl	2ce14 <z_arm_irq_priority_set>
	IRQ_CONNECT(HAL_SWI_RADIO_IRQ, CONFIG_BT_CTLR_LLL_PRIO,
   3f584:	4622      	mov	r2, r4
   3f586:	4621      	mov	r1, r4
   3f588:	2018      	movs	r0, #24
   3f58a:	f7ed fc43 	bl	2ce14 <z_arm_irq_priority_set>
	irq_enable(RADIO_IRQn);
   3f58e:	2001      	movs	r0, #1
   3f590:	f7ed fc10 	bl	2cdb4 <arch_irq_enable>
	irq_enable(RTC0_IRQn);
   3f594:	200b      	movs	r0, #11
   3f596:	f7ed fc0d 	bl	2cdb4 <arch_irq_enable>
	irq_enable(HAL_SWI_RADIO_IRQ);
   3f59a:	2018      	movs	r0, #24
   3f59c:	f7ed fc0a 	bl	2cdb4 <arch_irq_enable>
	radio_setup();
   3f5a0:	f002 fac0 	bl	41b24 <radio_setup>
	return 0;
   3f5a4:	4620      	mov	r0, r4
}
   3f5a6:	bd10      	pop	{r4, pc}
		return -ENODEV;
   3f5a8:	f06f 0012 	mvn.w	r0, #18
}
   3f5ac:	bd10      	pop	{r4, pc}
   3f5ae:	bf00      	nop
   3f5b0:	00050874 	.word	0x00050874
   3f5b4:	20005930 	.word	0x20005930

0003f5b8 <lll_deinit>:
{
   3f5b8:	b508      	push	{r3, lr}
	err = lll_clock_deinit();
   3f5ba:	f000 faed 	bl	3fb98 <lll_clock_deinit>
	if (err < 0) {
   3f5be:	2800      	cmp	r0, #0
   3f5c0:	db09      	blt.n	3f5d6 <lll_deinit+0x1e>
	irq_disable(RADIO_IRQn);
   3f5c2:	2001      	movs	r0, #1
   3f5c4:	f7ed fc04 	bl	2cdd0 <arch_irq_disable>
	irq_disable(RTC0_IRQn);
   3f5c8:	200b      	movs	r0, #11
   3f5ca:	f7ed fc01 	bl	2cdd0 <arch_irq_disable>
	irq_disable(HAL_SWI_RADIO_IRQ);
   3f5ce:	2018      	movs	r0, #24
   3f5d0:	f7ed fbfe 	bl	2cdd0 <arch_irq_disable>
	return 0;
   3f5d4:	2000      	movs	r0, #0
}
   3f5d6:	bd08      	pop	{r3, pc}

0003f5d8 <lll_csrand_get>:
{
   3f5d8:	4603      	mov	r3, r0
	const struct entropy_driver_api *api =
		(const struct entropy_driver_api *)dev->api;

	__ASSERT(api->get_entropy != NULL,
		"Callback pointer should not be NULL");
	return api->get_entropy(dev, buffer, length);
   3f5da:	4803      	ldr	r0, [pc, #12]	; (3f5e8 <lll_csrand_get+0x10>)
   3f5dc:	b28a      	uxth	r2, r1
   3f5de:	4619      	mov	r1, r3
   3f5e0:	6883      	ldr	r3, [r0, #8]
   3f5e2:	681b      	ldr	r3, [r3, #0]
   3f5e4:	4718      	bx	r3
   3f5e6:	bf00      	nop
   3f5e8:	00050874 	.word	0x00050874

0003f5ec <lll_csrand_isr_get>:
{
   3f5ec:	b430      	push	{r4, r5}
static inline int entropy_get_entropy_isr(const struct device *dev,
					  uint8_t *buffer,
					  uint16_t length,
					  uint32_t flags)
{
	const struct entropy_driver_api *api =
   3f5ee:	4d07      	ldr	r5, [pc, #28]	; (3f60c <lll_csrand_isr_get+0x20>)
		(const struct entropy_driver_api *)dev->api;

	if (unlikely(!api->get_entropy_isr)) {
   3f5f0:	68ab      	ldr	r3, [r5, #8]
   3f5f2:	685c      	ldr	r4, [r3, #4]
   3f5f4:	b134      	cbz	r4, 3f604 <lll_csrand_isr_get+0x18>
   3f5f6:	b28a      	uxth	r2, r1
		return -ENOTSUP;
	}

	return api->get_entropy_isr(dev, buffer, length, flags);
   3f5f8:	46a4      	mov	ip, r4
   3f5fa:	4601      	mov	r1, r0
   3f5fc:	2300      	movs	r3, #0
   3f5fe:	4628      	mov	r0, r5
}
   3f600:	bc30      	pop	{r4, r5}
   3f602:	4760      	bx	ip
   3f604:	f06f 0085 	mvn.w	r0, #133	; 0x85
   3f608:	bc30      	pop	{r4, r5}
   3f60a:	4770      	bx	lr
   3f60c:	00050874 	.word	0x00050874

0003f610 <lll_rand_isr_get>:
int lll_rand_isr_get(void *buf, size_t len)
   3f610:	b430      	push	{r4, r5}
   3f612:	4d07      	ldr	r5, [pc, #28]	; (3f630 <lll_rand_isr_get+0x20>)
   3f614:	68ab      	ldr	r3, [r5, #8]
   3f616:	685c      	ldr	r4, [r3, #4]
   3f618:	b134      	cbz	r4, 3f628 <lll_rand_isr_get+0x18>
   3f61a:	b28a      	uxth	r2, r1
   3f61c:	46a4      	mov	ip, r4
   3f61e:	4601      	mov	r1, r0
   3f620:	2300      	movs	r3, #0
   3f622:	4628      	mov	r0, r5
   3f624:	bc30      	pop	{r4, r5}
   3f626:	4760      	bx	ip
   3f628:	f06f 0085 	mvn.w	r0, #133	; 0x85
   3f62c:	bc30      	pop	{r4, r5}
   3f62e:	4770      	bx	lr
   3f630:	00050874 	.word	0x00050874

0003f634 <lll_reset>:
}
   3f634:	2000      	movs	r0, #0
   3f636:	4770      	bx	lr

0003f638 <lll_disable>:
{
   3f638:	b530      	push	{r4, r5, lr}
	if (!param || (param == event.curr.param)) {
   3f63a:	4604      	mov	r4, r0
{
   3f63c:	b083      	sub	sp, #12
	if (!param || (param == event.curr.param)) {
   3f63e:	b378      	cbz	r0, 3f6a0 <lll_disable+0x68>
   3f640:	4b23      	ldr	r3, [pc, #140]	; (3f6d0 <lll_disable+0x98>)
   3f642:	681a      	ldr	r2, [r3, #0]
   3f644:	4282      	cmp	r2, r0
   3f646:	d025      	beq.n	3f694 <lll_disable+0x5c>
		idx = UINT8_MAX;
   3f648:	25ff      	movs	r5, #255	; 0xff
		next = ull_prepare_dequeue_iter(&idx);
   3f64a:	f10d 0007 	add.w	r0, sp, #7
		idx = UINT8_MAX;
   3f64e:	f88d 5007 	strb.w	r5, [sp, #7]
		next = ull_prepare_dequeue_iter(&idx);
   3f652:	f7f8 fdab 	bl	381ac <ull_prepare_dequeue_iter>
		while (next) {
   3f656:	b938      	cbnz	r0, 3f668 <lll_disable+0x30>
   3f658:	e01a      	b.n	3f690 <lll_disable+0x58>
			    (!param || (param == next->prepare_param.param))) {
   3f65a:	42a1      	cmp	r1, r4
   3f65c:	d00a      	beq.n	3f674 <lll_disable+0x3c>
			next = ull_prepare_dequeue_iter(&idx);
   3f65e:	f10d 0007 	add.w	r0, sp, #7
   3f662:	f7f8 fda3 	bl	381ac <ull_prepare_dequeue_iter>
		while (next) {
   3f666:	b198      	cbz	r0, 3f690 <lll_disable+0x58>
			if (!next->is_aborted &&
   3f668:	7f03      	ldrb	r3, [r0, #28]
   3f66a:	079b      	lsls	r3, r3, #30
   3f66c:	d4f7      	bmi.n	3f65e <lll_disable+0x26>
			    (!param || (param == next->prepare_param.param))) {
   3f66e:	68c1      	ldr	r1, [r0, #12]
			if (!next->is_aborted &&
   3f670:	2c00      	cmp	r4, #0
   3f672:	d1f2      	bne.n	3f65a <lll_disable+0x22>
				next->is_aborted = 1;
   3f674:	7f03      	ldrb	r3, [r0, #28]
				next->abort_cb(&next->prepare_param,
   3f676:	6982      	ldr	r2, [r0, #24]
				next->is_aborted = 1;
   3f678:	f043 0302 	orr.w	r3, r3, #2
   3f67c:	7703      	strb	r3, [r0, #28]
				next->abort_cb(&next->prepare_param,
   3f67e:	4790      	blx	r2
			next = ull_prepare_dequeue_iter(&idx);
   3f680:	f10d 0007 	add.w	r0, sp, #7
				idx = UINT8_MAX;
   3f684:	f88d 5007 	strb.w	r5, [sp, #7]
			next = ull_prepare_dequeue_iter(&idx);
   3f688:	f7f8 fd90 	bl	381ac <ull_prepare_dequeue_iter>
		while (next) {
   3f68c:	2800      	cmp	r0, #0
   3f68e:	d1eb      	bne.n	3f668 <lll_disable+0x30>
}
   3f690:	b003      	add	sp, #12
   3f692:	bd30      	pop	{r4, r5, pc}
		if (event.curr.abort_cb && event.curr.param) {
   3f694:	689b      	ldr	r3, [r3, #8]
   3f696:	b16b      	cbz	r3, 3f6b4 <lll_disable+0x7c>
   3f698:	4601      	mov	r1, r0
			event.curr.abort_cb(NULL, event.curr.param);
   3f69a:	2000      	movs	r0, #0
   3f69c:	4798      	blx	r3
   3f69e:	e7d3      	b.n	3f648 <lll_disable+0x10>
		if (event.curr.abort_cb && event.curr.param) {
   3f6a0:	4a0b      	ldr	r2, [pc, #44]	; (3f6d0 <lll_disable+0x98>)
   3f6a2:	6893      	ldr	r3, [r2, #8]
   3f6a4:	2b00      	cmp	r3, #0
   3f6a6:	d0cf      	beq.n	3f648 <lll_disable+0x10>
   3f6a8:	6811      	ldr	r1, [r2, #0]
   3f6aa:	2900      	cmp	r1, #0
   3f6ac:	d0cc      	beq.n	3f648 <lll_disable+0x10>
			event.curr.abort_cb(NULL, event.curr.param);
   3f6ae:	2000      	movs	r0, #0
   3f6b0:	4798      	blx	r3
   3f6b2:	e7c9      	b.n	3f648 <lll_disable+0x10>
			LL_ASSERT(!param);
   3f6b4:	4a07      	ldr	r2, [pc, #28]	; (3f6d4 <lll_disable+0x9c>)
   3f6b6:	4908      	ldr	r1, [pc, #32]	; (3f6d8 <lll_disable+0xa0>)
   3f6b8:	4808      	ldr	r0, [pc, #32]	; (3f6dc <lll_disable+0xa4>)
   3f6ba:	f240 1313 	movw	r3, #275	; 0x113
   3f6be:	f009 fce1 	bl	49084 <assert_print>
   3f6c2:	4040      	eors	r0, r0
   3f6c4:	f380 8811 	msr	BASEPRI, r0
   3f6c8:	f04f 0003 	mov.w	r0, #3
   3f6cc:	df02      	svc	2
   3f6ce:	e7bb      	b.n	3f648 <lll_disable+0x10>
   3f6d0:	20005930 	.word	0x20005930
   3f6d4:	000529e0 	.word	0x000529e0
   3f6d8:	00052ac4 	.word	0x00052ac4
   3f6dc:	0005214c 	.word	0x0005214c

0003f6e0 <lll_prepare_done>:
}
   3f6e0:	2000      	movs	r0, #0
   3f6e2:	4770      	bx	lr

0003f6e4 <lll_done>:
{
   3f6e4:	b538      	push	{r3, r4, r5, lr}
   3f6e6:	4604      	mov	r4, r0
	next = ull_prepare_dequeue_get();
   3f6e8:	f7f8 fd52 	bl	38190 <ull_prepare_dequeue_get>
	LL_ASSERT(!param || next);
   3f6ec:	b154      	cbz	r4, 3f704 <lll_done+0x20>
   3f6ee:	b310      	cbz	r0, 3f736 <lll_done+0x52>
			ull = HDR_LLL2ULL(param);
   3f6f0:	6824      	ldr	r4, [r4, #0]
	ull_prepare_dequeue(TICKER_USER_ID_LLL);
   3f6f2:	2000      	movs	r0, #0
   3f6f4:	f7f8 fd7a 	bl	381ec <ull_prepare_dequeue>
	evdone = ull_event_done(ull);
   3f6f8:	4620      	mov	r0, r4
   3f6fa:	f7f8 fdeb 	bl	382d4 <ull_event_done>
	LL_ASSERT(evdone);
   3f6fe:	b158      	cbz	r0, 3f718 <lll_done+0x34>
}
   3f700:	2000      	movs	r0, #0
   3f702:	bd38      	pop	{r3, r4, r5, pc}
		LL_ASSERT(event.curr.abort_cb);
   3f704:	4d1a      	ldr	r5, [pc, #104]	; (3f770 <lll_done+0x8c>)
   3f706:	68ab      	ldr	r3, [r5, #8]
   3f708:	b31b      	cbz	r3, 3f752 <lll_done+0x6e>
		param = event.curr.param;
   3f70a:	682c      	ldr	r4, [r5, #0]
		event.curr.abort_cb = NULL;
   3f70c:	2300      	movs	r3, #0
   3f70e:	60ab      	str	r3, [r5, #8]
		event.curr.param = NULL;
   3f710:	602b      	str	r3, [r5, #0]
		if (param) {
   3f712:	2c00      	cmp	r4, #0
   3f714:	d1ec      	bne.n	3f6f0 <lll_done+0xc>
   3f716:	e7ec      	b.n	3f6f2 <lll_done+0xe>
	LL_ASSERT(evdone);
   3f718:	4a16      	ldr	r2, [pc, #88]	; (3f774 <lll_done+0x90>)
   3f71a:	4917      	ldr	r1, [pc, #92]	; (3f778 <lll_done+0x94>)
   3f71c:	4817      	ldr	r0, [pc, #92]	; (3f77c <lll_done+0x98>)
   3f71e:	f44f 73c2 	mov.w	r3, #388	; 0x184
   3f722:	f009 fcaf 	bl	49084 <assert_print>
   3f726:	4040      	eors	r0, r0
   3f728:	f380 8811 	msr	BASEPRI, r0
   3f72c:	f04f 0003 	mov.w	r0, #3
   3f730:	df02      	svc	2
}
   3f732:	2000      	movs	r0, #0
   3f734:	bd38      	pop	{r3, r4, r5, pc}
	LL_ASSERT(!param || next);
   3f736:	4a0f      	ldr	r2, [pc, #60]	; (3f774 <lll_done+0x90>)
   3f738:	4911      	ldr	r1, [pc, #68]	; (3f780 <lll_done+0x9c>)
   3f73a:	4810      	ldr	r0, [pc, #64]	; (3f77c <lll_done+0x98>)
   3f73c:	f240 134d 	movw	r3, #333	; 0x14d
   3f740:	f009 fca0 	bl	49084 <assert_print>
   3f744:	4040      	eors	r0, r0
   3f746:	f380 8811 	msr	BASEPRI, r0
   3f74a:	f04f 0003 	mov.w	r0, #3
   3f74e:	df02      	svc	2
		ull = HDR_LLL2ULL(param);
   3f750:	e7ce      	b.n	3f6f0 <lll_done+0xc>
		LL_ASSERT(event.curr.abort_cb);
   3f752:	4a08      	ldr	r2, [pc, #32]	; (3f774 <lll_done+0x90>)
   3f754:	490b      	ldr	r1, [pc, #44]	; (3f784 <lll_done+0xa0>)
   3f756:	4809      	ldr	r0, [pc, #36]	; (3f77c <lll_done+0x98>)
   3f758:	f44f 73a9 	mov.w	r3, #338	; 0x152
   3f75c:	f009 fc92 	bl	49084 <assert_print>
   3f760:	4040      	eors	r0, r0
   3f762:	f380 8811 	msr	BASEPRI, r0
   3f766:	f04f 0003 	mov.w	r0, #3
   3f76a:	df02      	svc	2
   3f76c:	e7cd      	b.n	3f70a <lll_done+0x26>
   3f76e:	bf00      	nop
   3f770:	20005930 	.word	0x20005930
   3f774:	000529e0 	.word	0x000529e0
   3f778:	00052af0 	.word	0x00052af0
   3f77c:	0005214c 	.word	0x0005214c
   3f780:	00052acc 	.word	0x00052acc
   3f784:	00052adc 	.word	0x00052adc

0003f788 <lll_is_done>:
	*is_resume = (param != event.curr.param);
   3f788:	4a05      	ldr	r2, [pc, #20]	; (3f7a0 <lll_is_done+0x18>)
   3f78a:	6813      	ldr	r3, [r2, #0]
	return !event.curr.abort_cb;
   3f78c:	6892      	ldr	r2, [r2, #8]
	*is_resume = (param != event.curr.param);
   3f78e:	1a1b      	subs	r3, r3, r0
   3f790:	bf18      	it	ne
   3f792:	2301      	movne	r3, #1
}
   3f794:	fab2 f082 	clz	r0, r2
	*is_resume = (param != event.curr.param);
   3f798:	700b      	strb	r3, [r1, #0]
}
   3f79a:	0940      	lsrs	r0, r0, #5
   3f79c:	4770      	bx	lr
   3f79e:	bf00      	nop
   3f7a0:	20005930 	.word	0x20005930

0003f7a4 <lll_is_abort_cb>:
}
   3f7a4:	f06f 008b 	mvn.w	r0, #139	; 0x8b
   3f7a8:	4770      	bx	lr
   3f7aa:	bf00      	nop

0003f7ac <lll_event_offset_get>:
		return MAX(ull->ticks_active_to_start,
   3f7ac:	e9d0 3201 	ldrd	r3, r2, [r0, #4]
	} else if (ull->ticks_prepare_to_start & XON_BITMASK) {
   3f7b0:	2a00      	cmp	r2, #0
   3f7b2:	db04      	blt.n	3f7be <lll_event_offset_get+0x12>
		return MAX(ull->ticks_active_to_start,
   3f7b4:	429a      	cmp	r2, r3
   3f7b6:	bf38      	it	cc
   3f7b8:	461a      	movcc	r2, r3
   3f7ba:	4610      	mov	r0, r2
}
   3f7bc:	4770      	bx	lr
		return MAX(ull->ticks_active_to_start,
   3f7be:	68c0      	ldr	r0, [r0, #12]
   3f7c0:	4298      	cmp	r0, r3
   3f7c2:	bf38      	it	cc
   3f7c4:	4618      	movcc	r0, r3
   3f7c6:	4770      	bx	lr

0003f7c8 <lll_preempt_calc>:
{
   3f7c8:	b510      	push	{r4, lr}
   3f7ca:	4614      	mov	r4, r2
	ticks_now = ticker_ticks_now_get();
   3f7cc:	f7f6 fa16 	bl	35bfc <ticker_ticks_now_get>
	diff = ticks_now - ticks_at_event;
   3f7d0:	1b02      	subs	r2, r0, r4
	if (diff & BIT(HAL_TICKER_CNTR_MSBIT)) {
   3f7d2:	0213      	lsls	r3, r2, #8
   3f7d4:	d405      	bmi.n	3f7e2 <lll_preempt_calc+0x1a>
	diff += HAL_TICKER_CNTR_CMP_OFFSET_MIN;
   3f7d6:	1cd0      	adds	r0, r2, #3
	if (diff > HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US)) {
   3f7d8:	2818      	cmp	r0, #24
   3f7da:	bf94      	ite	ls
   3f7dc:	2000      	movls	r0, #0
   3f7de:	2001      	movhi	r0, #1
}
   3f7e0:	bd10      	pop	{r4, pc}
		return 0;
   3f7e2:	2000      	movs	r0, #0
}
   3f7e4:	bd10      	pop	{r4, pc}
   3f7e6:	bf00      	nop

0003f7e8 <lll_chan_set>:
	switch (chan) {
   3f7e8:	2826      	cmp	r0, #38	; 0x26
{
   3f7ea:	b510      	push	{r4, lr}
   3f7ec:	4604      	mov	r4, r0
	switch (chan) {
   3f7ee:	d01c      	beq.n	3f82a <lll_chan_set+0x42>
   3f7f0:	2827      	cmp	r0, #39	; 0x27
   3f7f2:	d012      	beq.n	3f81a <lll_chan_set+0x32>
   3f7f4:	2825      	cmp	r0, #37	; 0x25
   3f7f6:	d008      	beq.n	3f80a <lll_chan_set+0x22>
		if (chan < 11) {
   3f7f8:	280a      	cmp	r0, #10
   3f7fa:	d91e      	bls.n	3f83a <lll_chan_set+0x52>
		} else if (chan < 40) {
   3f7fc:	2827      	cmp	r0, #39	; 0x27
   3f7fe:	d821      	bhi.n	3f844 <lll_chan_set+0x5c>
			radio_freq_chan_set(28 + ((chan - 11) * 2U));
   3f800:	3003      	adds	r0, #3
   3f802:	0040      	lsls	r0, r0, #1
   3f804:	f002 f9e2 	bl	41bcc <radio_freq_chan_set>
   3f808:	e002      	b.n	3f810 <lll_chan_set+0x28>
		radio_freq_chan_set(2);
   3f80a:	2002      	movs	r0, #2
   3f80c:	f002 f9de 	bl	41bcc <radio_freq_chan_set>
	radio_whiten_iv_set(chan);
   3f810:	4620      	mov	r0, r4
}
   3f812:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	radio_whiten_iv_set(chan);
   3f816:	f002 b9df 	b.w	41bd8 <radio_whiten_iv_set>
		radio_freq_chan_set(80);
   3f81a:	2050      	movs	r0, #80	; 0x50
   3f81c:	f002 f9d6 	bl	41bcc <radio_freq_chan_set>
	radio_whiten_iv_set(chan);
   3f820:	4620      	mov	r0, r4
}
   3f822:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	radio_whiten_iv_set(chan);
   3f826:	f002 b9d7 	b.w	41bd8 <radio_whiten_iv_set>
		radio_freq_chan_set(26);
   3f82a:	201a      	movs	r0, #26
   3f82c:	f002 f9ce 	bl	41bcc <radio_freq_chan_set>
	radio_whiten_iv_set(chan);
   3f830:	4620      	mov	r0, r4
}
   3f832:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	radio_whiten_iv_set(chan);
   3f836:	f002 b9cf 	b.w	41bd8 <radio_whiten_iv_set>
			radio_freq_chan_set(4 + (chan * 2U));
   3f83a:	3002      	adds	r0, #2
   3f83c:	0040      	lsls	r0, r0, #1
   3f83e:	f002 f9c5 	bl	41bcc <radio_freq_chan_set>
   3f842:	e7e5      	b.n	3f810 <lll_chan_set+0x28>
			LL_ASSERT(0);
   3f844:	4a06      	ldr	r2, [pc, #24]	; (3f860 <lll_chan_set+0x78>)
   3f846:	4907      	ldr	r1, [pc, #28]	; (3f864 <lll_chan_set+0x7c>)
   3f848:	4807      	ldr	r0, [pc, #28]	; (3f868 <lll_chan_set+0x80>)
   3f84a:	f44f 73fb 	mov.w	r3, #502	; 0x1f6
   3f84e:	f009 fc19 	bl	49084 <assert_print>
   3f852:	4040      	eors	r0, r0
   3f854:	f380 8811 	msr	BASEPRI, r0
   3f858:	f04f 0003 	mov.w	r0, #3
   3f85c:	df02      	svc	2
   3f85e:	e7d7      	b.n	3f810 <lll_chan_set+0x28>
   3f860:	000529e0 	.word	0x000529e0
   3f864:	000521ac 	.word	0x000521ac
   3f868:	0005214c 	.word	0x0005214c

0003f86c <lll_radio_tx_ready_delay_get>:
	return radio_tx_ready_delay_get(phy, flags);
   3f86c:	f002 ba10 	b.w	41c90 <radio_tx_ready_delay_get>

0003f870 <lll_radio_rx_ready_delay_get>:
	return radio_rx_ready_delay_get(phy, flags);
   3f870:	f002 ba16 	b.w	41ca0 <radio_rx_ready_delay_get>

0003f874 <lll_isr_tx_status_reset>:
{
   3f874:	b508      	push	{r3, lr}
	radio_status_reset();
   3f876:	f002 fa3b 	bl	41cf0 <radio_status_reset>
}
   3f87a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	radio_tmr_status_reset();
   3f87e:	f002 bb7b 	b.w	41f78 <radio_tmr_status_reset>
   3f882:	bf00      	nop

0003f884 <lll_isr_rx_status_reset>:
{
   3f884:	b508      	push	{r3, lr}
	radio_status_reset();
   3f886:	f002 fa33 	bl	41cf0 <radio_status_reset>
	radio_tmr_status_reset();
   3f88a:	f002 fb75 	bl	41f78 <radio_tmr_status_reset>
}
   3f88e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	radio_rssi_status_reset();
   3f892:	f002 bb3d 	b.w	41f10 <radio_rssi_status_reset>
   3f896:	bf00      	nop

0003f898 <lll_isr_status_reset>:
{
   3f898:	b508      	push	{r3, lr}
	radio_status_reset();
   3f89a:	f002 fa29 	bl	41cf0 <radio_status_reset>
	radio_tmr_status_reset();
   3f89e:	f002 fb6b 	bl	41f78 <radio_tmr_status_reset>
	radio_filter_status_reset();
   3f8a2:	f002 fb51 	bl	41f48 <radio_filter_status_reset>
}
   3f8a6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	radio_rssi_status_reset();
   3f8aa:	f002 bb31 	b.w	41f10 <radio_rssi_status_reset>
   3f8ae:	bf00      	nop

0003f8b0 <lll_isr_cleanup>:
{
   3f8b0:	b508      	push	{r3, lr}
   3f8b2:	4601      	mov	r1, r0
	radio_isr_set(isr_race, param);
   3f8b4:	4817      	ldr	r0, [pc, #92]	; (3f914 <lll_isr_cleanup+0x64>)
   3f8b6:	f002 f915 	bl	41ae4 <radio_isr_set>
	if (!radio_is_idle()) {
   3f8ba:	f002 fa39 	bl	41d30 <radio_is_idle>
   3f8be:	b160      	cbz	r0, 3f8da <lll_isr_cleanup+0x2a>
	radio_tmr_stop();
   3f8c0:	f002 fc30 	bl	42124 <radio_tmr_stop>
	radio_stop();
   3f8c4:	f002 f96a 	bl	41b9c <radio_stop>
	err = lll_hfclock_off();
   3f8c8:	f000 f9a2 	bl	3fc10 <lll_hfclock_off>
	LL_ASSERT(err >= 0);
   3f8cc:	2800      	cmp	r0, #0
   3f8ce:	db0e      	blt.n	3f8ee <lll_isr_cleanup+0x3e>
}
   3f8d0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	lll_done(NULL);
   3f8d4:	2000      	movs	r0, #0
   3f8d6:	f7ff bf05 	b.w	3f6e4 <lll_done>
		radio_disable();
   3f8da:	f002 f9f5 	bl	41cc8 <radio_disable>
	radio_tmr_stop();
   3f8de:	f002 fc21 	bl	42124 <radio_tmr_stop>
	radio_stop();
   3f8e2:	f002 f95b 	bl	41b9c <radio_stop>
	err = lll_hfclock_off();
   3f8e6:	f000 f993 	bl	3fc10 <lll_hfclock_off>
	LL_ASSERT(err >= 0);
   3f8ea:	2800      	cmp	r0, #0
   3f8ec:	daf0      	bge.n	3f8d0 <lll_isr_cleanup+0x20>
   3f8ee:	4a0a      	ldr	r2, [pc, #40]	; (3f918 <lll_isr_cleanup+0x68>)
   3f8f0:	490a      	ldr	r1, [pc, #40]	; (3f91c <lll_isr_cleanup+0x6c>)
   3f8f2:	480b      	ldr	r0, [pc, #44]	; (3f920 <lll_isr_cleanup+0x70>)
   3f8f4:	f44f 7317 	mov.w	r3, #604	; 0x25c
   3f8f8:	f009 fbc4 	bl	49084 <assert_print>
   3f8fc:	4040      	eors	r0, r0
   3f8fe:	f380 8811 	msr	BASEPRI, r0
   3f902:	f04f 0003 	mov.w	r0, #3
   3f906:	df02      	svc	2
	lll_done(NULL);
   3f908:	2000      	movs	r0, #0
}
   3f90a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	lll_done(NULL);
   3f90e:	f7ff bee9 	b.w	3f6e4 <lll_done>
   3f912:	bf00      	nop
   3f914:	0003f20d 	.word	0x0003f20d
   3f918:	000529e0 	.word	0x000529e0
   3f91c:	00052af8 	.word	0x00052af8
   3f920:	0005214c 	.word	0x0005214c

0003f924 <lll_isr_abort>:
{
   3f924:	b510      	push	{r4, lr}
   3f926:	4604      	mov	r4, r0
	radio_status_reset();
   3f928:	f002 f9e2 	bl	41cf0 <radio_status_reset>
	radio_tmr_status_reset();
   3f92c:	f002 fb24 	bl	41f78 <radio_tmr_status_reset>
	radio_filter_status_reset();
   3f930:	f002 fb0a 	bl	41f48 <radio_filter_status_reset>
	radio_rssi_status_reset();
   3f934:	f002 faec 	bl	41f10 <radio_rssi_status_reset>
	lll_isr_cleanup(param);
   3f938:	4620      	mov	r0, r4
}
   3f93a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lll_isr_cleanup(param);
   3f93e:	f7ff bfb7 	b.w	3f8b0 <lll_isr_cleanup>
   3f942:	bf00      	nop

0003f944 <lll_isr_early_abort>:
{
   3f944:	b508      	push	{r3, lr}
   3f946:	4601      	mov	r1, r0
	radio_isr_set(isr_race, param);
   3f948:	4813      	ldr	r0, [pc, #76]	; (3f998 <lll_isr_early_abort+0x54>)
   3f94a:	f002 f8cb 	bl	41ae4 <radio_isr_set>
	if (!radio_is_idle()) {
   3f94e:	f002 f9ef 	bl	41d30 <radio_is_idle>
   3f952:	b140      	cbz	r0, 3f966 <lll_isr_early_abort+0x22>
	err = lll_hfclock_off();
   3f954:	f000 f95c 	bl	3fc10 <lll_hfclock_off>
	LL_ASSERT(err >= 0);
   3f958:	2800      	cmp	r0, #0
   3f95a:	db0a      	blt.n	3f972 <lll_isr_early_abort+0x2e>
}
   3f95c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	lll_done(NULL);
   3f960:	2000      	movs	r0, #0
   3f962:	f7ff bebf 	b.w	3f6e4 <lll_done>
		radio_disable();
   3f966:	f002 f9af 	bl	41cc8 <radio_disable>
	err = lll_hfclock_off();
   3f96a:	f000 f951 	bl	3fc10 <lll_hfclock_off>
	LL_ASSERT(err >= 0);
   3f96e:	2800      	cmp	r0, #0
   3f970:	daf4      	bge.n	3f95c <lll_isr_early_abort+0x18>
   3f972:	4a0a      	ldr	r2, [pc, #40]	; (3f99c <lll_isr_early_abort+0x58>)
   3f974:	490a      	ldr	r1, [pc, #40]	; (3f9a0 <lll_isr_early_abort+0x5c>)
   3f976:	480b      	ldr	r0, [pc, #44]	; (3f9a4 <lll_isr_early_abort+0x60>)
   3f978:	f240 236b 	movw	r3, #619	; 0x26b
   3f97c:	f009 fb82 	bl	49084 <assert_print>
   3f980:	4040      	eors	r0, r0
   3f982:	f380 8811 	msr	BASEPRI, r0
   3f986:	f04f 0003 	mov.w	r0, #3
   3f98a:	df02      	svc	2
	lll_done(NULL);
   3f98c:	2000      	movs	r0, #0
}
   3f98e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	lll_done(NULL);
   3f992:	f7ff bea7 	b.w	3f6e4 <lll_done>
   3f996:	bf00      	nop
   3f998:	0003f20d 	.word	0x0003f20d
   3f99c:	000529e0 	.word	0x000529e0
   3f9a0:	00052af8 	.word	0x00052af8
   3f9a4:	0005214c 	.word	0x0005214c

0003f9a8 <lll_prepare_resolve>:
{
   3f9a8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   3f9ac:	b084      	sub	sp, #16
   3f9ae:	4606      	mov	r6, r0
   3f9b0:	461d      	mov	r5, r3
	p = ull_prepare_dequeue_iter(&idx);
   3f9b2:	f10d 000f 	add.w	r0, sp, #15
	idx = UINT8_MAX;
   3f9b6:	23ff      	movs	r3, #255	; 0xff
{
   3f9b8:	f89d 9030 	ldrb.w	r9, [sp, #48]	; 0x30
	idx = UINT8_MAX;
   3f9bc:	f88d 300f 	strb.w	r3, [sp, #15]
{
   3f9c0:	460f      	mov	r7, r1
   3f9c2:	4690      	mov	r8, r2
	p = ull_prepare_dequeue_iter(&idx);
   3f9c4:	f7f8 fbf2 	bl	381ac <ull_prepare_dequeue_iter>
	while (p && (p->is_aborted || p->is_resume)) {
   3f9c8:	4604      	mov	r4, r0
   3f9ca:	b928      	cbnz	r0, 3f9d8 <lll_prepare_resolve+0x30>
   3f9cc:	e03b      	b.n	3fa46 <lll_prepare_resolve+0x9e>
		p = ull_prepare_dequeue_iter(&idx);
   3f9ce:	f7f8 fbed 	bl	381ac <ull_prepare_dequeue_iter>
	while (p && (p->is_aborted || p->is_resume)) {
   3f9d2:	4604      	mov	r4, r0
   3f9d4:	2800      	cmp	r0, #0
   3f9d6:	d036      	beq.n	3fa46 <lll_prepare_resolve+0x9e>
   3f9d8:	f894 c01c 	ldrb.w	ip, [r4, #28]
   3f9dc:	f01c 0f03 	tst.w	ip, #3
		p = ull_prepare_dequeue_iter(&idx);
   3f9e0:	f10d 000f 	add.w	r0, sp, #15
	while (p && (p->is_aborted || p->is_resume)) {
   3f9e4:	d1f3      	bne.n	3f9ce <lll_prepare_resolve+0x26>
	    event.curr.abort_cb ||
   3f9e6:	f8df a11c 	ldr.w	sl, [pc, #284]	; 3fb04 <lll_prepare_resolve+0x15c>
	if ((!is_dequeue && !is_done_sync()) ||
   3f9ea:	f8da 3008 	ldr.w	r3, [sl, #8]
   3f9ee:	2b00      	cmp	r3, #0
   3f9f0:	d130      	bne.n	3fa54 <lll_prepare_resolve+0xac>
	    (p && is_resume)) {
   3f9f2:	f1b9 0f00 	cmp.w	r9, #0
   3f9f6:	d16b      	bne.n	3fad0 <lll_prepare_resolve+0x128>
	LL_ASSERT(!p || &p->prepare_param == prepare_param);
   3f9f8:	42ac      	cmp	r4, r5
   3f9fa:	d00c      	beq.n	3fa16 <lll_prepare_resolve+0x6e>
   3f9fc:	4a42      	ldr	r2, [pc, #264]	; (3fb08 <lll_prepare_resolve+0x160>)
   3f9fe:	4943      	ldr	r1, [pc, #268]	; (3fb0c <lll_prepare_resolve+0x164>)
   3fa00:	4843      	ldr	r0, [pc, #268]	; (3fb10 <lll_prepare_resolve+0x168>)
   3fa02:	f240 23da 	movw	r3, #730	; 0x2da
   3fa06:	f009 fb3d 	bl	49084 <assert_print>
   3fa0a:	4040      	eors	r0, r0
   3fa0c:	f380 8811 	msr	BASEPRI, r0
   3fa10:	f04f 0003 	mov.w	r0, #3
   3fa14:	df02      	svc	2
	event.curr.param = prepare_param->param;
   3fa16:	68eb      	ldr	r3, [r5, #12]
   3fa18:	f8ca 3000 	str.w	r3, [sl]
	event.curr.abort_cb = abort_cb;
   3fa1c:	e9ca 6701 	strd	r6, r7, [sl, #4]
	err = prepare_cb(prepare_param);
   3fa20:	4628      	mov	r0, r5
   3fa22:	47c0      	blx	r8
   3fa24:	4604      	mov	r4, r0
   3fa26:	e003      	b.n	3fa30 <lll_prepare_resolve+0x88>
	} while (p->is_aborted || p->is_resume);
   3fa28:	7f01      	ldrb	r1, [r0, #28]
   3fa2a:	f011 0103 	ands.w	r1, r1, #3
   3fa2e:	d039      	beq.n	3faa4 <lll_prepare_resolve+0xfc>
		p = ull_prepare_dequeue_iter(&idx);
   3fa30:	f10d 000f 	add.w	r0, sp, #15
   3fa34:	f7f8 fbba 	bl	381ac <ull_prepare_dequeue_iter>
   3fa38:	4602      	mov	r2, r0
		if (!p) {
   3fa3a:	2800      	cmp	r0, #0
   3fa3c:	d1f4      	bne.n	3fa28 <lll_prepare_resolve+0x80>
}
   3fa3e:	4620      	mov	r0, r4
   3fa40:	b004      	add	sp, #16
   3fa42:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	    event.curr.abort_cb ||
   3fa46:	f8df a0bc 	ldr.w	sl, [pc, #188]	; 3fb04 <lll_prepare_resolve+0x15c>
	if ((!is_dequeue && !is_done_sync()) ||
   3fa4a:	f8da 3008 	ldr.w	r3, [sl, #8]
   3fa4e:	2b00      	cmp	r3, #0
   3fa50:	d0e1      	beq.n	3fa16 <lll_prepare_resolve+0x6e>
{
   3fa52:	2400      	movs	r4, #0
		next = ull_prepare_enqueue(is_abort_cb, abort_cb, prepare_param,
   3fa54:	462a      	mov	r2, r5
   3fa56:	f8cd 9000 	str.w	r9, [sp]
   3fa5a:	4643      	mov	r3, r8
   3fa5c:	4639      	mov	r1, r7
   3fa5e:	4630      	mov	r0, r6
   3fa60:	f7f8 fb64 	bl	3812c <ull_prepare_enqueue>
		LL_ASSERT(next);
   3fa64:	4602      	mov	r2, r0
   3fa66:	2800      	cmp	r0, #0
   3fa68:	d03c      	beq.n	3fae4 <lll_prepare_resolve+0x13c>
		if (is_resume) {
   3fa6a:	f1b9 0f00 	cmp.w	r9, #0
   3fa6e:	d116      	bne.n	3fa9e <lll_prepare_resolve+0xf6>
		ret  = preempt_ticker_start(first, p, next);
   3fa70:	2c00      	cmp	r4, #0
   3fa72:	bf14      	ite	ne
   3fa74:	4620      	movne	r0, r4
   3fa76:	4610      	moveq	r0, r2
   3fa78:	4621      	mov	r1, r4
   3fa7a:	f7ff fc09 	bl	3f290 <preempt_ticker_start>
		LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
   3fa7e:	f030 0302 	bics.w	r3, r0, #2
   3fa82:	d00c      	beq.n	3fa9e <lll_prepare_resolve+0xf6>
   3fa84:	4a20      	ldr	r2, [pc, #128]	; (3fb08 <lll_prepare_resolve+0x160>)
   3fa86:	4923      	ldr	r1, [pc, #140]	; (3fb14 <lll_prepare_resolve+0x16c>)
   3fa88:	4821      	ldr	r0, [pc, #132]	; (3fb10 <lll_prepare_resolve+0x168>)
   3fa8a:	f44f 732d 	mov.w	r3, #692	; 0x2b4
   3fa8e:	f009 faf9 	bl	49084 <assert_print>
   3fa92:	4040      	eors	r0, r0
   3fa94:	f380 8811 	msr	BASEPRI, r0
   3fa98:	f04f 0003 	mov.w	r0, #3
   3fa9c:	df02      	svc	2
			return -EINPROGRESS;
   3fa9e:	f06f 0476 	mvn.w	r4, #118	; 0x76
   3faa2:	e7cc      	b.n	3fa3e <lll_prepare_resolve+0x96>
	ret = preempt_ticker_start(p, NULL, p);
   3faa4:	f7ff fbf4 	bl	3f290 <preempt_ticker_start>
	LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
   3faa8:	f030 0302 	bics.w	r3, r0, #2
   3faac:	d0c7      	beq.n	3fa3e <lll_prepare_resolve+0x96>
   3faae:	4a16      	ldr	r2, [pc, #88]	; (3fb08 <lll_prepare_resolve+0x160>)
   3fab0:	4918      	ldr	r1, [pc, #96]	; (3fb14 <lll_prepare_resolve+0x16c>)
   3fab2:	4817      	ldr	r0, [pc, #92]	; (3fb10 <lll_prepare_resolve+0x168>)
   3fab4:	f240 23f7 	movw	r3, #759	; 0x2f7
   3fab8:	f009 fae4 	bl	49084 <assert_print>
   3fabc:	4040      	eors	r0, r0
   3fabe:	f380 8811 	msr	BASEPRI, r0
   3fac2:	f04f 0003 	mov.w	r0, #3
   3fac6:	df02      	svc	2
}
   3fac8:	4620      	mov	r0, r4
   3faca:	b004      	add	sp, #16
   3facc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		next = ull_prepare_enqueue(is_abort_cb, abort_cb, prepare_param,
   3fad0:	f8cd 9000 	str.w	r9, [sp]
   3fad4:	4643      	mov	r3, r8
   3fad6:	462a      	mov	r2, r5
   3fad8:	4639      	mov	r1, r7
   3fada:	4630      	mov	r0, r6
   3fadc:	f7f8 fb26 	bl	3812c <ull_prepare_enqueue>
		LL_ASSERT(next);
   3fae0:	2800      	cmp	r0, #0
   3fae2:	d1dc      	bne.n	3fa9e <lll_prepare_resolve+0xf6>
   3fae4:	4a08      	ldr	r2, [pc, #32]	; (3fb08 <lll_prepare_resolve+0x160>)
   3fae6:	490c      	ldr	r1, [pc, #48]	; (3fb18 <lll_prepare_resolve+0x170>)
   3fae8:	4809      	ldr	r0, [pc, #36]	; (3fb10 <lll_prepare_resolve+0x168>)
   3faea:	f240 23a7 	movw	r3, #679	; 0x2a7
   3faee:	f009 fac9 	bl	49084 <assert_print>
   3faf2:	4040      	eors	r0, r0
   3faf4:	f380 8811 	msr	BASEPRI, r0
   3faf8:	f04f 0003 	mov.w	r0, #3
   3fafc:	df02      	svc	2
   3fafe:	2200      	movs	r2, #0
   3fb00:	e7b3      	b.n	3fa6a <lll_prepare_resolve+0xc2>
   3fb02:	bf00      	nop
   3fb04:	20005930 	.word	0x20005930
   3fb08:	000529e0 	.word	0x000529e0
   3fb0c:	00052b0c 	.word	0x00052b0c
   3fb10:	0005214c 	.word	0x0005214c
   3fb14:	00052504 	.word	0x00052504
   3fb18:	00052b04 	.word	0x00052b04

0003fb1c <clock_ready>:
	z_impl_k_sem_give(sem);
   3fb1c:	f101 0010 	add.w	r0, r1, #16
   3fb20:	f007 bb2a 	b.w	47178 <z_impl_k_sem_give>

0003fb24 <blocking_on>:

	k_sem_give(&clk_state->sem);
}

static int blocking_on(struct onoff_manager *mgr, uint32_t timeout)
{
   3fb24:	b570      	push	{r4, r5, r6, lr}
   3fb26:	4605      	mov	r5, r0
   3fb28:	b08a      	sub	sp, #40	; 0x28
   3fb2a:	460c      	mov	r4, r1
	return z_impl_k_sem_init(sem, initial_count, limit);
   3fb2c:	2201      	movs	r2, #1
   3fb2e:	2100      	movs	r1, #0
   3fb30:	a804      	add	r0, sp, #16
   3fb32:	f010 f9a1 	bl	4fe78 <z_impl_k_sem_init>
					      sys_notify_generic_callback handler)
{
	__ASSERT_NO_MSG(notify != NULL);
	__ASSERT_NO_MSG(handler != NULL);

	*notify = (struct sys_notify){
   3fb36:	4b0f      	ldr	r3, [pc, #60]	; (3fb74 <blocking_on+0x50>)
   3fb38:	9301      	str	r3, [sp, #4]
   3fb3a:	2600      	movs	r6, #0
   3fb3c:	2303      	movs	r3, #3
	struct lll_clock_state state;
	int err;

	k_sem_init(&state.sem, 0, 1);
	sys_notify_init_callback(&state.cli.notify, clock_ready);
	err = onoff_request(mgr, &state.cli);
   3fb3e:	4669      	mov	r1, sp
   3fb40:	4628      	mov	r0, r5
   3fb42:	9603      	str	r6, [sp, #12]
   3fb44:	9302      	str	r3, [sp, #8]
   3fb46:	f009 f835 	bl	48bb4 <onoff_request>
	if (err < 0) {
   3fb4a:	2800      	cmp	r0, #0
   3fb4c:	db10      	blt.n	3fb70 <blocking_on+0x4c>
   3fb4e:	f44f 4300 	mov.w	r3, #32768	; 0x8000
   3fb52:	4631      	mov	r1, r6
   3fb54:	f240 30e7 	movw	r0, #999	; 0x3e7
   3fb58:	fbe4 0103 	umlal	r0, r1, r4, r3
   3fb5c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   3fb60:	2300      	movs	r3, #0
   3fb62:	f7e6 facd 	bl	26100 <__aeabi_uldivmod>
   3fb66:	4602      	mov	r2, r0
   3fb68:	460b      	mov	r3, r1
	return z_impl_k_sem_take(sem, timeout);
   3fb6a:	a804      	add	r0, sp, #16
   3fb6c:	f007 fb2a 	bl	471c4 <z_impl_k_sem_take>
		return err;
	}

	return k_sem_take(&state.sem, K_MSEC(timeout));
}
   3fb70:	b00a      	add	sp, #40	; 0x28
   3fb72:	bd70      	pop	{r4, r5, r6, pc}
   3fb74:	0003fb1d 	.word	0x0003fb1d

0003fb78 <lll_clock_init>:

int lll_clock_init(void)
{
   3fb78:	b510      	push	{r4, lr}
	struct onoff_manager *mgr =
		z_nrf_clock_control_get_onoff(CLOCK_CONTROL_NRF_SUBSYS_LF);
   3fb7a:	2001      	movs	r0, #1
   3fb7c:	f004 f820 	bl	43bc0 <z_nrf_clock_control_get_onoff>
	*notify = (struct sys_notify){
   3fb80:	4904      	ldr	r1, [pc, #16]	; (3fb94 <lll_clock_init+0x1c>)
   3fb82:	2300      	movs	r3, #0
   3fb84:	2401      	movs	r4, #1
   3fb86:	604b      	str	r3, [r1, #4]
   3fb88:	608c      	str	r4, [r1, #8]
   3fb8a:	60cb      	str	r3, [r1, #12]

	sys_notify_init_spinwait(&lf_cli.notify);

	return onoff_request(mgr, &lf_cli);
}
   3fb8c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return onoff_request(mgr, &lf_cli);
   3fb90:	f009 b810 	b.w	48bb4 <onoff_request>
   3fb94:	20005940 	.word	0x20005940

0003fb98 <lll_clock_deinit>:

int lll_clock_deinit(void)
{
   3fb98:	b508      	push	{r3, lr}
	struct onoff_manager *mgr =
		z_nrf_clock_control_get_onoff(CLOCK_CONTROL_NRF_SUBSYS_LF);
   3fb9a:	2001      	movs	r0, #1
   3fb9c:	f004 f810 	bl	43bc0 <z_nrf_clock_control_get_onoff>

	return onoff_release(mgr);
}
   3fba0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	return onoff_release(mgr);
   3fba4:	f009 b85e 	b.w	48c64 <onoff_release>

0003fba8 <lll_clock_wait>:
{
	struct onoff_manager *mgr;
	static bool done;
	int err;

	if (done) {
   3fba8:	4b0c      	ldr	r3, [pc, #48]	; (3fbdc <lll_clock_wait+0x34>)
   3fbaa:	781a      	ldrb	r2, [r3, #0]
   3fbac:	b10a      	cbz	r2, 3fbb2 <lll_clock_wait+0xa>
		return 0;
   3fbae:	2000      	movs	r0, #0
	if (err != ONOFF_STATE_ON) {
		return -EIO;
	}

	return 0;
}
   3fbb0:	4770      	bx	lr
{
   3fbb2:	b510      	push	{r4, lr}
	done = true;
   3fbb4:	2001      	movs	r0, #1
   3fbb6:	7018      	strb	r0, [r3, #0]
	mgr = z_nrf_clock_control_get_onoff(CLOCK_CONTROL_NRF_SUBSYS_LF);
   3fbb8:	f004 f802 	bl	43bc0 <z_nrf_clock_control_get_onoff>
	err = blocking_on(mgr, LFCLOCK_TIMEOUT_MS);
   3fbbc:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
	mgr = z_nrf_clock_control_get_onoff(CLOCK_CONTROL_NRF_SUBSYS_LF);
   3fbc0:	4604      	mov	r4, r0
	err = blocking_on(mgr, LFCLOCK_TIMEOUT_MS);
   3fbc2:	f7ff ffaf 	bl	3fb24 <blocking_on>
	if (err) {
   3fbc6:	b938      	cbnz	r0, 3fbd8 <lll_clock_wait+0x30>
	err = onoff_release(mgr);
   3fbc8:	4620      	mov	r0, r4
   3fbca:	f009 f84b 	bl	48c64 <onoff_release>
	if (err != ONOFF_STATE_ON) {
   3fbce:	2802      	cmp	r0, #2
		return 0;
   3fbd0:	bf0c      	ite	eq
   3fbd2:	2000      	moveq	r0, #0
		return -EIO;
   3fbd4:	f06f 0004 	mvnne.w	r0, #4
}
   3fbd8:	bd10      	pop	{r4, pc}
   3fbda:	bf00      	nop
   3fbdc:	20006bb3 	.word	0x20006bb3

0003fbe0 <lll_hfclock_on>:

int lll_hfclock_on(void)
{
   3fbe0:	b508      	push	{r3, lr}
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   3fbe2:	4b0a      	ldr	r3, [pc, #40]	; (3fc0c <lll_hfclock_on+0x2c>)
   3fbe4:	f3bf 8f5b 	dmb	ish
   3fbe8:	e853 2f00 	ldrex	r2, [r3]
   3fbec:	1c51      	adds	r1, r2, #1
   3fbee:	e843 1000 	strex	r0, r1, [r3]
   3fbf2:	2800      	cmp	r0, #0
   3fbf4:	d1f8      	bne.n	3fbe8 <lll_hfclock_on+0x8>
   3fbf6:	f3bf 8f5b 	dmb	ish
	if (atomic_inc(&hf_refcnt) > 0) {
   3fbfa:	2a00      	cmp	r2, #0
   3fbfc:	dd01      	ble.n	3fc02 <lll_hfclock_on+0x22>

	z_nrf_clock_bt_ctlr_hf_request();
	DEBUG_RADIO_XTAL(1);

	return 0;
}
   3fbfe:	2000      	movs	r0, #0
   3fc00:	bd08      	pop	{r3, pc}
	z_nrf_clock_bt_ctlr_hf_request();
   3fc02:	f003 ffe5 	bl	43bd0 <z_nrf_clock_bt_ctlr_hf_request>
}
   3fc06:	2000      	movs	r0, #0
   3fc08:	bd08      	pop	{r3, pc}
   3fc0a:	bf00      	nop
   3fc0c:	2000593c 	.word	0x2000593c

0003fc10 <lll_hfclock_off>:

	return err;
}

int lll_hfclock_off(void)
{
   3fc10:	b508      	push	{r3, lr}
	if (hf_refcnt < 1) {
   3fc12:	4b0c      	ldr	r3, [pc, #48]	; (3fc44 <lll_hfclock_off+0x34>)
   3fc14:	681a      	ldr	r2, [r3, #0]
   3fc16:	2a00      	cmp	r2, #0
   3fc18:	dd11      	ble.n	3fc3e <lll_hfclock_off+0x2e>
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
   3fc1a:	f3bf 8f5b 	dmb	ish
   3fc1e:	e853 2f00 	ldrex	r2, [r3]
   3fc22:	1e51      	subs	r1, r2, #1
   3fc24:	e843 1000 	strex	r0, r1, [r3]
   3fc28:	2800      	cmp	r0, #0
   3fc2a:	d1f8      	bne.n	3fc1e <lll_hfclock_off+0xe>
   3fc2c:	f3bf 8f5b 	dmb	ish
		return -EALREADY;
	}

	if (atomic_dec(&hf_refcnt) > 1) {
   3fc30:	2a01      	cmp	r2, #1
   3fc32:	dd01      	ble.n	3fc38 <lll_hfclock_off+0x28>
		return 0;
   3fc34:	2000      	movs	r0, #0

	z_nrf_clock_bt_ctlr_hf_release();
	DEBUG_RADIO_XTAL(0);

	return 0;
}
   3fc36:	bd08      	pop	{r3, pc}
	z_nrf_clock_bt_ctlr_hf_release();
   3fc38:	f003 ffe0 	bl	43bfc <z_nrf_clock_bt_ctlr_hf_release>
	return 0;
   3fc3c:	e7fa      	b.n	3fc34 <lll_hfclock_off+0x24>
		return -EALREADY;
   3fc3e:	f06f 0077 	mvn.w	r0, #119	; 0x77
}
   3fc42:	bd08      	pop	{r3, pc}
   3fc44:	2000593c 	.word	0x2000593c

0003fc48 <lll_clock_sca_local_get>:

uint8_t lll_clock_sca_local_get(void)
{
	return CLOCK_CONTROL_NRF_K32SRC_ACCURACY;
}
   3fc48:	2005      	movs	r0, #5
   3fc4a:	4770      	bx	lr

0003fc4c <lll_clock_ppm_local_get>:

uint32_t lll_clock_ppm_local_get(void)
{
	return sca_ppm_lut[CLOCK_CONTROL_NRF_K32SRC_ACCURACY];
}
   3fc4c:	2032      	movs	r0, #50	; 0x32
   3fc4e:	4770      	bx	lr

0003fc50 <lll_clock_ppm_get>:

uint32_t lll_clock_ppm_get(uint8_t sca)
{
	return sca_ppm_lut[sca];
   3fc50:	4b01      	ldr	r3, [pc, #4]	; (3fc58 <lll_clock_ppm_get+0x8>)
}
   3fc52:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
   3fc56:	4770      	bx	lr
   3fc58:	00052b38 	.word	0x00052b38

0003fc5c <isr_abort>:

	lll_isr_cleanup(param);
}

static void isr_abort(void *param)
{
   3fc5c:	b510      	push	{r4, lr}
   3fc5e:	4604      	mov	r4, r0
	/* Clear radio status and events */
	lll_isr_status_reset();
   3fc60:	f7ff fe1a 	bl	3f898 <lll_isr_status_reset>

	/* Disable any filter that was setup */
	radio_filter_disable();
   3fc64:	f002 f966 	bl	41f34 <radio_filter_disable>

	/* Current LLL radio event is done*/
	lll_isr_cleanup(param);
   3fc68:	4620      	mov	r0, r4
}
   3fc6a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lll_isr_cleanup(param);
   3fc6e:	f7ff be1f 	b.w	3f8b0 <lll_isr_cleanup>
   3fc72:	bf00      	nop

0003fc74 <isr_tx>:
{
   3fc74:	b538      	push	{r3, r4, r5, lr}
   3fc76:	4605      	mov	r5, r0
	lll_isr_tx_status_reset();
   3fc78:	f7ff fdfc 	bl	3f874 <lll_isr_tx_status_reset>
	radio_tmr_tifs_set(EVENT_IFS_US);
   3fc7c:	2096      	movs	r0, #150	; 0x96
   3fc7e:	f002 f98b 	bl	41f98 <radio_tmr_tifs_set>
	radio_switch_complete_and_tx(phy_p, 0, phy_p, phy_flags);
   3fc82:	2300      	movs	r3, #0
   3fc84:	4618      	mov	r0, r3
   3fc86:	461a      	mov	r2, r3
   3fc88:	4619      	mov	r1, r3
   3fc8a:	f002 f8c1 	bl	41e10 <radio_switch_complete_and_tx>
	node_rx = ull_pdu_rx_alloc_peek(1);
   3fc8e:	2001      	movs	r0, #1
   3fc90:	f7f8 f9fc 	bl	3808c <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
   3fc94:	4604      	mov	r4, r0
   3fc96:	b368      	cbz	r0, 3fcf4 <isr_tx+0x80>
	radio_pkt_rx_set(node_rx->pdu);
   3fc98:	f104 001c 	add.w	r0, r4, #28
   3fc9c:	f001 ffec 	bl	41c78 <radio_pkt_rx_set>
	LL_ASSERT(!radio_is_ready());
   3fca0:	f002 f832 	bl	41d08 <radio_is_ready>
   3fca4:	b9c0      	cbnz	r0, 3fcd8 <isr_tx+0x64>
	radio_isr_set(isr_rx, param);
   3fca6:	4629      	mov	r1, r5
   3fca8:	4819      	ldr	r0, [pc, #100]	; (3fd10 <isr_tx+0x9c>)
   3fcaa:	f001 ff1b 	bl	41ae4 <radio_isr_set>
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 + 1;
   3fcae:	f002 fa8d 	bl	421cc <radio_tmr_tifs_base_get>
	hcto += radio_rx_chain_delay_get(phy_p, 0);
   3fcb2:	2100      	movs	r1, #0
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 + 1;
   3fcb4:	4604      	mov	r4, r0
	hcto += radio_rx_chain_delay_get(phy_p, 0);
   3fcb6:	4608      	mov	r0, r1
   3fcb8:	f001 fff4 	bl	41ca4 <radio_rx_chain_delay_get>
	hcto -= radio_tx_chain_delay_get(phy_p, 0);
   3fcbc:	2100      	movs	r1, #0
	hcto += radio_rx_chain_delay_get(phy_p, 0);
   3fcbe:	4605      	mov	r5, r0
	hcto -= radio_tx_chain_delay_get(phy_p, 0);
   3fcc0:	4608      	mov	r0, r1
   3fcc2:	f001 ffeb 	bl	41c9c <radio_tx_chain_delay_get>
   3fcc6:	442c      	add	r4, r5
   3fcc8:	34c3      	adds	r4, #195	; 0xc3
	radio_tmr_hcto_configure(hcto);
   3fcca:	1a20      	subs	r0, r4, r0
   3fccc:	f002 fa36 	bl	4213c <radio_tmr_hcto_configure>
}
   3fcd0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	radio_tmr_end_capture();
   3fcd4:	f002 ba6c 	b.w	421b0 <radio_tmr_end_capture>
	LL_ASSERT(!radio_is_ready());
   3fcd8:	4a0e      	ldr	r2, [pc, #56]	; (3fd14 <isr_tx+0xa0>)
   3fcda:	490f      	ldr	r1, [pc, #60]	; (3fd18 <isr_tx+0xa4>)
   3fcdc:	480f      	ldr	r0, [pc, #60]	; (3fd1c <isr_tx+0xa8>)
   3fcde:	f240 4387 	movw	r3, #1159	; 0x487
   3fce2:	f009 f9cf 	bl	49084 <assert_print>
   3fce6:	4040      	eors	r0, r0
   3fce8:	f380 8811 	msr	BASEPRI, r0
   3fcec:	f04f 0003 	mov.w	r0, #3
   3fcf0:	df02      	svc	2
   3fcf2:	e7d8      	b.n	3fca6 <isr_tx+0x32>
	LL_ASSERT(node_rx);
   3fcf4:	4a07      	ldr	r2, [pc, #28]	; (3fd14 <isr_tx+0xa0>)
   3fcf6:	490a      	ldr	r1, [pc, #40]	; (3fd20 <isr_tx+0xac>)
   3fcf8:	4808      	ldr	r0, [pc, #32]	; (3fd1c <isr_tx+0xa8>)
   3fcfa:	f240 4383 	movw	r3, #1155	; 0x483
   3fcfe:	f009 f9c1 	bl	49084 <assert_print>
   3fd02:	4040      	eors	r0, r0
   3fd04:	f380 8811 	msr	BASEPRI, r0
   3fd08:	f04f 0003 	mov.w	r0, #3
   3fd0c:	df02      	svc	2
   3fd0e:	e7c3      	b.n	3fc98 <isr_tx+0x24>
   3fd10:	000403c5 	.word	0x000403c5
   3fd14:	00052b48 	.word	0x00052b48
   3fd18:	00052b9c 	.word	0x00052b9c
   3fd1c:	0005214c 	.word	0x0005214c
   3fd20:	00052b94 	.word	0x00052b94

0003fd24 <is_abort_cb>:
	if (next != curr) {
   3fd24:	4281      	cmp	r1, r0
{
   3fd26:	b508      	push	{r3, lr}
	if (next != curr) {
   3fd28:	d00e      	beq.n	3fd48 <is_abort_cb+0x24>
		} else if (lll->is_hdcd) {
   3fd2a:	7a0b      	ldrb	r3, [r1, #8]
   3fd2c:	07db      	lsls	r3, r3, #31
   3fd2e:	d402      	bmi.n	3fd36 <is_abort_cb+0x12>
			return -ECANCELED;
   3fd30:	f06f 008b 	mvn.w	r0, #139	; 0x8b
}
   3fd34:	bd08      	pop	{r3, pc}
			*resume_cb = resume_prepare_cb;
   3fd36:	4b12      	ldr	r3, [pc, #72]	; (3fd80 <is_abort_cb+0x5c>)
   3fd38:	6013      	str	r3, [r2, #0]
			err = lll_hfclock_on();
   3fd3a:	f7ff ff51 	bl	3fbe0 <lll_hfclock_on>
			LL_ASSERT(err >= 0);
   3fd3e:	2800      	cmp	r0, #0
   3fd40:	db0f      	blt.n	3fd62 <is_abort_cb+0x3e>
{
   3fd42:	f06f 000a 	mvn.w	r0, #10
}
   3fd46:	bd08      	pop	{r3, pc}
	return (void *)lll->adv_data.pdu[lll->adv_data.first];
   3fd48:	7b0b      	ldrb	r3, [r1, #12]
   3fd4a:	eb01 0183 	add.w	r1, r1, r3, lsl #2
	if (pdu->type == PDU_ADV_TYPE_DIRECT_IND) {
   3fd4e:	690b      	ldr	r3, [r1, #16]
   3fd50:	781b      	ldrb	r3, [r3, #0]
   3fd52:	f003 030f 	and.w	r3, r3, #15
		return 0;
   3fd56:	2b01      	cmp	r3, #1
   3fd58:	bf14      	ite	ne
   3fd5a:	f06f 008b 	mvnne.w	r0, #139	; 0x8b
   3fd5e:	2000      	moveq	r0, #0
}
   3fd60:	bd08      	pop	{r3, pc}
			LL_ASSERT(err >= 0);
   3fd62:	4a08      	ldr	r2, [pc, #32]	; (3fd84 <is_abort_cb+0x60>)
   3fd64:	4908      	ldr	r1, [pc, #32]	; (3fd88 <is_abort_cb+0x64>)
   3fd66:	4809      	ldr	r0, [pc, #36]	; (3fd8c <is_abort_cb+0x68>)
   3fd68:	f240 433c 	movw	r3, #1084	; 0x43c
   3fd6c:	f009 f98a 	bl	49084 <assert_print>
   3fd70:	4040      	eors	r0, r0
   3fd72:	f380 8811 	msr	BASEPRI, r0
   3fd76:	f04f 0003 	mov.w	r0, #3
   3fd7a:	df02      	svc	2
   3fd7c:	e7e1      	b.n	3fd42 <is_abort_cb+0x1e>
   3fd7e:	bf00      	nop
   3fd80:	000402b1 	.word	0x000402b1
   3fd84:	00052b48 	.word	0x00052b48
   3fd88:	00052af8 	.word	0x00052af8
   3fd8c:	0005214c 	.word	0x0005214c

0003fd90 <isr_abort_all>:

#if defined(CONFIG_BT_PERIPHERAL)
static void isr_abort_all(void *param)
{
   3fd90:	b510      	push	{r4, lr}
   3fd92:	4604      	mov	r4, r0
	static memq_link_t link;
	static struct mayfly mfy = {0, 0, &link, NULL, lll_disable};
	uint32_t ret;

	/* Clear radio status and events */
	lll_isr_status_reset();
   3fd94:	f7ff fd80 	bl	3f898 <lll_isr_status_reset>

	/* Disable any filter that was setup */
	radio_filter_disable();
   3fd98:	f002 f8cc 	bl	41f34 <radio_filter_disable>

	/* Current LLL radio event is done*/
	lll_isr_cleanup(param);
   3fd9c:	4620      	mov	r0, r4
   3fd9e:	f7ff fd87 	bl	3f8b0 <lll_isr_cleanup>

	/* Abort any LLL prepare/resume enqueued in pipeline */
	mfy.param = param;
   3fda2:	4b0b      	ldr	r3, [pc, #44]	; (3fdd0 <isr_abort_all+0x40>)
	ret = mayfly_enqueue(TICKER_USER_ID_LLL, TICKER_USER_ID_LLL, 1U, &mfy);
   3fda4:	2100      	movs	r1, #0
   3fda6:	2201      	movs	r2, #1
   3fda8:	4608      	mov	r0, r1
	mfy.param = param;
   3fdaa:	609c      	str	r4, [r3, #8]
	ret = mayfly_enqueue(TICKER_USER_ID_LLL, TICKER_USER_ID_LLL, 1U, &mfy);
   3fdac:	f7f4 fc60 	bl	34670 <mayfly_enqueue>
	LL_ASSERT(!ret);
   3fdb0:	b900      	cbnz	r0, 3fdb4 <isr_abort_all+0x24>
}
   3fdb2:	bd10      	pop	{r4, pc}
	LL_ASSERT(!ret);
   3fdb4:	4a07      	ldr	r2, [pc, #28]	; (3fdd4 <isr_abort_all+0x44>)
   3fdb6:	4908      	ldr	r1, [pc, #32]	; (3fdd8 <isr_abort_all+0x48>)
   3fdb8:	4808      	ldr	r0, [pc, #32]	; (3fddc <isr_abort_all+0x4c>)
   3fdba:	f240 5391 	movw	r3, #1425	; 0x591
   3fdbe:	f009 f961 	bl	49084 <assert_print>
   3fdc2:	4040      	eors	r0, r0
   3fdc4:	f380 8811 	msr	BASEPRI, r0
   3fdc8:	f04f 0003 	mov.w	r0, #3
   3fdcc:	df02      	svc	2
}
   3fdce:	bd10      	pop	{r4, pc}
   3fdd0:	20000c94 	.word	0x20000c94
   3fdd4:	00052b48 	.word	0x00052b48
   3fdd8:	00052430 	.word	0x00052430
   3fddc:	0005214c 	.word	0x0005214c

0003fde0 <abort_cb>:
{
   3fde0:	b510      	push	{r4, lr}
	if (!prepare_param) {
   3fde2:	b1d8      	cbz	r0, 3fe1c <abort_cb+0x3c>
	err = lll_hfclock_off();
   3fde4:	460c      	mov	r4, r1
   3fde6:	f7ff ff13 	bl	3fc10 <lll_hfclock_off>
	LL_ASSERT(err >= 0);
   3fdea:	2800      	cmp	r0, #0
   3fdec:	db04      	blt.n	3fdf8 <abort_cb+0x18>
	lll_done(param);
   3fdee:	4620      	mov	r0, r4
}
   3fdf0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lll_done(param);
   3fdf4:	f7ff bc76 	b.w	3f6e4 <lll_done>
	LL_ASSERT(err >= 0);
   3fdf8:	4a0c      	ldr	r2, [pc, #48]	; (3fe2c <abort_cb+0x4c>)
   3fdfa:	490d      	ldr	r1, [pc, #52]	; (3fe30 <abort_cb+0x50>)
   3fdfc:	480d      	ldr	r0, [pc, #52]	; (3fe34 <abort_cb+0x54>)
   3fdfe:	f240 4362 	movw	r3, #1122	; 0x462
   3fe02:	f009 f93f 	bl	49084 <assert_print>
   3fe06:	4040      	eors	r0, r0
   3fe08:	f380 8811 	msr	BASEPRI, r0
   3fe0c:	f04f 0003 	mov.w	r0, #3
   3fe10:	df02      	svc	2
	lll_done(param);
   3fe12:	4620      	mov	r0, r4
}
   3fe14:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lll_done(param);
   3fe18:	f7ff bc64 	b.w	3f6e4 <lll_done>
		radio_isr_set(isr_abort, param);
   3fe1c:	4806      	ldr	r0, [pc, #24]	; (3fe38 <abort_cb+0x58>)
   3fe1e:	f001 fe61 	bl	41ae4 <radio_isr_set>
}
   3fe22:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		radio_disable();
   3fe26:	f001 bf4f 	b.w	41cc8 <radio_disable>
   3fe2a:	bf00      	nop
   3fe2c:	00052b48 	.word	0x00052b48
   3fe30:	00052af8 	.word	0x00052af8
   3fe34:	0005214c 	.word	0x0005214c
   3fe38:	0003fc5d 	.word	0x0003fc5d

0003fe3c <lll_adv_init>:
	mem_init(mem_pdu.pool, PDU_MEM_SIZE,
   3fe3c:	4b08      	ldr	r3, [pc, #32]	; (3fe60 <lll_adv_init+0x24>)
   3fe3e:	2204      	movs	r2, #4
{
   3fe40:	b510      	push	{r4, lr}
	mem_init(mem_pdu.pool, PDU_MEM_SIZE,
   3fe42:	1898      	adds	r0, r3, r2
   3fe44:	2128      	movs	r1, #40	; 0x28
   3fe46:	f7f4 fb07 	bl	34458 <mem_init>
	MFIFO_INIT(pdu_free);
   3fe4a:	4b06      	ldr	r3, [pc, #24]	; (3fe64 <lll_adv_init+0x28>)
   3fe4c:	2400      	movs	r4, #0
   3fe4e:	809c      	strh	r4, [r3, #4]
	return z_impl_k_sem_init(sem, initial_count, limit);
   3fe50:	2202      	movs	r2, #2
   3fe52:	4621      	mov	r1, r4
   3fe54:	4804      	ldr	r0, [pc, #16]	; (3fe68 <lll_adv_init+0x2c>)
   3fe56:	f010 f80f 	bl	4fe78 <z_impl_k_sem_init>
}
   3fe5a:	4620      	mov	r0, r4
   3fe5c:	bd10      	pop	{r4, pc}
   3fe5e:	bf00      	nop
   3fe60:	20005970 	.word	0x20005970
   3fe64:	20000ca4 	.word	0x20000ca4
   3fe68:	20005958 	.word	0x20005958

0003fe6c <lll_adv_reset>:
int lll_adv_reset(void)
   3fe6c:	4b08      	ldr	r3, [pc, #32]	; (3fe90 <lll_adv_reset+0x24>)
   3fe6e:	2204      	movs	r2, #4
   3fe70:	b510      	push	{r4, lr}
   3fe72:	1898      	adds	r0, r3, r2
   3fe74:	2128      	movs	r1, #40	; 0x28
   3fe76:	f7f4 faef 	bl	34458 <mem_init>
   3fe7a:	4b06      	ldr	r3, [pc, #24]	; (3fe94 <lll_adv_reset+0x28>)
   3fe7c:	2400      	movs	r4, #0
   3fe7e:	809c      	strh	r4, [r3, #4]
   3fe80:	2202      	movs	r2, #2
   3fe82:	4621      	mov	r1, r4
   3fe84:	4804      	ldr	r0, [pc, #16]	; (3fe98 <lll_adv_reset+0x2c>)
   3fe86:	f00f fff7 	bl	4fe78 <z_impl_k_sem_init>
   3fe8a:	4620      	mov	r0, r4
   3fe8c:	bd10      	pop	{r4, pc}
   3fe8e:	bf00      	nop
   3fe90:	20005970 	.word	0x20005970
   3fe94:	20000ca4 	.word	0x20000ca4
   3fe98:	20005958 	.word	0x20005958

0003fe9c <lll_adv_data_init>:
{
   3fe9c:	b510      	push	{r4, lr}
   3fe9e:	4604      	mov	r4, r0
	p = mem_acquire(&mem_pdu.free);
   3fea0:	4805      	ldr	r0, [pc, #20]	; (3feb8 <lll_adv_data_init+0x1c>)
   3fea2:	f7f4 fb09 	bl	344b8 <mem_acquire>
	if (!p) {
   3fea6:	b120      	cbz	r0, 3feb2 <lll_adv_data_init+0x16>
   3fea8:	4603      	mov	r3, r0
	p->len = 0U;
   3feaa:	2000      	movs	r0, #0
   3feac:	7058      	strb	r0, [r3, #1]
	pdu->pdu[0] = (void *)p;
   3feae:	6063      	str	r3, [r4, #4]
}
   3feb0:	bd10      	pop	{r4, pc}
		return -ENOMEM;
   3feb2:	f06f 000b 	mvn.w	r0, #11
}
   3feb6:	bd10      	pop	{r4, pc}
   3feb8:	20005970 	.word	0x20005970

0003febc <lll_adv_data_reset>:
{
   3febc:	4603      	mov	r3, r0
	pdu->first = 0U;
   3febe:	2000      	movs	r0, #0
   3fec0:	7018      	strb	r0, [r3, #0]
	pdu->last = 0U;
   3fec2:	7058      	strb	r0, [r3, #1]
	pdu->pdu[1] = NULL;
   3fec4:	6098      	str	r0, [r3, #8]
}
   3fec6:	4770      	bx	lr

0003fec8 <lll_adv_pdu_alloc_pdu_adv>:
{
   3fec8:	b538      	push	{r3, r4, r5, lr}
	p = MFIFO_DEQUEUE_PEEK(pdu_free);
   3feca:	4c2d      	ldr	r4, [pc, #180]	; (3ff80 <lll_adv_pdu_alloc_pdu_adv+0xb8>)
   3fecc:	7923      	ldrb	r3, [r4, #4]
	if (first == last) {
   3fece:	7962      	ldrb	r2, [r4, #5]
   3fed0:	7821      	ldrb	r1, [r4, #0]
   3fed2:	429a      	cmp	r2, r3
   3fed4:	d003      	beq.n	3fede <lll_adv_pdu_alloc_pdu_adv+0x16>
	return *((void **)(fifo + first * size));
   3fed6:	fb01 4303 	mla	r3, r1, r3, r4
   3feda:	689d      	ldr	r5, [r3, #8]
	if (p) {
   3fedc:	b935      	cbnz	r5, 3feec <lll_adv_pdu_alloc_pdu_adv+0x24>
	p = mem_acquire(&mem_pdu.free);
   3fede:	4829      	ldr	r0, [pc, #164]	; (3ff84 <lll_adv_pdu_alloc_pdu_adv+0xbc>)
   3fee0:	f7f4 faea 	bl	344b8 <mem_acquire>
	if (p) {
   3fee4:	4605      	mov	r5, r0
   3fee6:	b188      	cbz	r0, 3ff0c <lll_adv_pdu_alloc_pdu_adv+0x44>
}
   3fee8:	4628      	mov	r0, r5
   3feea:	bd38      	pop	{r3, r4, r5, pc}
	z_impl_k_sem_reset(sem);
   3feec:	4826      	ldr	r0, [pc, #152]	; (3ff88 <lll_adv_pdu_alloc_pdu_adv+0xc0>)
   3feee:	f007 f991 	bl	47214 <z_impl_k_sem_reset>
	uint8_t _first = *first; /* Copy read-index */
   3fef2:	7923      	ldrb	r3, [r4, #4]
	if (_first == last) {
   3fef4:	7962      	ldrb	r2, [r4, #5]
		MFIFO_DEQUEUE(pdu_free);
   3fef6:	78a1      	ldrb	r1, [r4, #2]
   3fef8:	429a      	cmp	r2, r3
   3fefa:	d0f5      	beq.n	3fee8 <lll_adv_pdu_alloc_pdu_adv+0x20>
	_first += 1U;
   3fefc:	3301      	adds	r3, #1
   3fefe:	b2db      	uxtb	r3, r3
		_first = 0U;
   3ff00:	4299      	cmp	r1, r3
   3ff02:	bf08      	it	eq
   3ff04:	2300      	moveq	r3, #0
	*first = _first; /* Write back read-index */
   3ff06:	7123      	strb	r3, [r4, #4]
}
   3ff08:	4628      	mov	r0, r5
   3ff0a:	bd38      	pop	{r3, r4, r5, pc}
	return z_impl_k_sem_take(sem, timeout);
   3ff0c:	481e      	ldr	r0, [pc, #120]	; (3ff88 <lll_adv_pdu_alloc_pdu_adv+0xc0>)
   3ff0e:	f44f 3220 	mov.w	r2, #163840	; 0x28000
   3ff12:	2300      	movs	r3, #0
   3ff14:	f007 f956 	bl	471c4 <z_impl_k_sem_take>
	LL_ASSERT(!err);
   3ff18:	b9b0      	cbnz	r0, 3ff48 <lll_adv_pdu_alloc_pdu_adv+0x80>
	z_impl_k_sem_reset(sem);
   3ff1a:	481b      	ldr	r0, [pc, #108]	; (3ff88 <lll_adv_pdu_alloc_pdu_adv+0xc0>)
   3ff1c:	f007 f97a 	bl	47214 <z_impl_k_sem_reset>
	uint8_t _first = *first; /* Copy read-index */
   3ff20:	7923      	ldrb	r3, [r4, #4]
	if (_first == last) {
   3ff22:	7961      	ldrb	r1, [r4, #5]
	p = MFIFO_DEQUEUE(pdu_free);
   3ff24:	7822      	ldrb	r2, [r4, #0]
   3ff26:	78a0      	ldrb	r0, [r4, #2]
   3ff28:	4299      	cmp	r1, r3
   3ff2a:	d01b      	beq.n	3ff64 <lll_adv_pdu_alloc_pdu_adv+0x9c>
	mem = *((void **)(fifo + _first * size));
   3ff2c:	fb13 f202 	smulbb	r2, r3, r2
   3ff30:	4916      	ldr	r1, [pc, #88]	; (3ff8c <lll_adv_pdu_alloc_pdu_adv+0xc4>)
	_first += 1U;
   3ff32:	3301      	adds	r3, #1
	mem = *((void **)(fifo + _first * size));
   3ff34:	588a      	ldr	r2, [r1, r2]
	_first += 1U;
   3ff36:	b2db      	uxtb	r3, r3
		_first = 0U;
   3ff38:	4298      	cmp	r0, r3
   3ff3a:	bf08      	it	eq
   3ff3c:	2300      	moveq	r3, #0
	*first = _first; /* Write back read-index */
   3ff3e:	7123      	strb	r3, [r4, #4]
	LL_ASSERT(p);
   3ff40:	b182      	cbz	r2, 3ff64 <lll_adv_pdu_alloc_pdu_adv+0x9c>
   3ff42:	4615      	mov	r5, r2
}
   3ff44:	4628      	mov	r0, r5
   3ff46:	bd38      	pop	{r3, r4, r5, pc}
	LL_ASSERT(!err);
   3ff48:	4a11      	ldr	r2, [pc, #68]	; (3ff90 <lll_adv_pdu_alloc_pdu_adv+0xc8>)
   3ff4a:	4912      	ldr	r1, [pc, #72]	; (3ff94 <lll_adv_pdu_alloc_pdu_adv+0xcc>)
   3ff4c:	4812      	ldr	r0, [pc, #72]	; (3ff98 <lll_adv_pdu_alloc_pdu_adv+0xd0>)
   3ff4e:	f44f 73d9 	mov.w	r3, #434	; 0x1b2
   3ff52:	f009 f897 	bl	49084 <assert_print>
   3ff56:	4040      	eors	r0, r0
   3ff58:	f380 8811 	msr	BASEPRI, r0
   3ff5c:	f04f 0003 	mov.w	r0, #3
   3ff60:	df02      	svc	2
   3ff62:	e7da      	b.n	3ff1a <lll_adv_pdu_alloc_pdu_adv+0x52>
	LL_ASSERT(p);
   3ff64:	4a0a      	ldr	r2, [pc, #40]	; (3ff90 <lll_adv_pdu_alloc_pdu_adv+0xc8>)
   3ff66:	490d      	ldr	r1, [pc, #52]	; (3ff9c <lll_adv_pdu_alloc_pdu_adv+0xd4>)
   3ff68:	480b      	ldr	r0, [pc, #44]	; (3ff98 <lll_adv_pdu_alloc_pdu_adv+0xd0>)
   3ff6a:	f240 13b7 	movw	r3, #439	; 0x1b7
   3ff6e:	f009 f889 	bl	49084 <assert_print>
   3ff72:	4040      	eors	r0, r0
   3ff74:	f380 8811 	msr	BASEPRI, r0
   3ff78:	f04f 0003 	mov.w	r0, #3
   3ff7c:	df02      	svc	2
   3ff7e:	e7b3      	b.n	3fee8 <lll_adv_pdu_alloc_pdu_adv+0x20>
   3ff80:	20000ca4 	.word	0x20000ca4
   3ff84:	20005970 	.word	0x20005970
   3ff88:	20005958 	.word	0x20005958
   3ff8c:	20000cac 	.word	0x20000cac
   3ff90:	00052b48 	.word	0x00052b48
   3ff94:	00052330 	.word	0x00052330
   3ff98:	0005214c 	.word	0x0005214c
   3ff9c:	00052bb0 	.word	0x00052bb0

0003ffa0 <lll_adv_pdu_alloc>:
{
   3ffa0:	b510      	push	{r4, lr}
	first = pdu->first;
   3ffa2:	7802      	ldrb	r2, [r0, #0]
	last = pdu->last;
   3ffa4:	7843      	ldrb	r3, [r0, #1]
	if (first == last) {
   3ffa6:	429a      	cmp	r2, r3
   3ffa8:	d014      	beq.n	3ffd4 <lll_adv_pdu_alloc+0x34>
		pdu->last = first;
   3ffaa:	b2d4      	uxtb	r4, r2
   3ffac:	7044      	strb	r4, [r0, #1]
		first_latest = pdu->first;
   3ffae:	7802      	ldrb	r2, [r0, #0]
		if (first_latest != first) {
   3ffb0:	4294      	cmp	r4, r2
   3ffb2:	d004      	beq.n	3ffbe <lll_adv_pdu_alloc+0x1e>
			last++;
   3ffb4:	1c5a      	adds	r2, r3, #1
			pdu->last = last;
   3ffb6:	7043      	strb	r3, [r0, #1]
			last++;
   3ffb8:	b2d3      	uxtb	r3, r2
			if (last == DOUBLE_BUFFER_SIZE) {
   3ffba:	2b02      	cmp	r3, #2
   3ffbc:	d00e      	beq.n	3ffdc <lll_adv_pdu_alloc+0x3c>
	p = (void *)pdu->pdu[last];
   3ffbe:	461a      	mov	r2, r3
	*idx = last;
   3ffc0:	eb00 0482 	add.w	r4, r0, r2, lsl #2
   3ffc4:	700b      	strb	r3, [r1, #0]
	p = (void *)pdu->pdu[last];
   3ffc6:	6860      	ldr	r0, [r4, #4]
	if (p) {
   3ffc8:	b100      	cbz	r0, 3ffcc <lll_adv_pdu_alloc+0x2c>
}
   3ffca:	bd10      	pop	{r4, pc}
	p = lll_adv_pdu_alloc_pdu_adv();
   3ffcc:	f7ff ff7c 	bl	3fec8 <lll_adv_pdu_alloc_pdu_adv>
	pdu->pdu[last] = (void *)p;
   3ffd0:	6060      	str	r0, [r4, #4]
}
   3ffd2:	bd10      	pop	{r4, pc}
		last++;
   3ffd4:	3301      	adds	r3, #1
   3ffd6:	b2db      	uxtb	r3, r3
		if (last == DOUBLE_BUFFER_SIZE) {
   3ffd8:	2b02      	cmp	r3, #2
   3ffda:	d1f0      	bne.n	3ffbe <lll_adv_pdu_alloc+0x1e>
{
   3ffdc:	2200      	movs	r2, #0
			last = 0U;
   3ffde:	4613      	mov	r3, r2
   3ffe0:	e7ee      	b.n	3ffc0 <lll_adv_pdu_alloc+0x20>
   3ffe2:	bf00      	nop

0003ffe4 <lll_adv_pdu_latest_get>:
{
   3ffe4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	first = pdu->first;
   3ffe6:	7802      	ldrb	r2, [r0, #0]
	if (first != pdu->last) {
   3ffe8:	7843      	ldrb	r3, [r0, #1]
   3ffea:	4293      	cmp	r3, r2
{
   3ffec:	4604      	mov	r4, r0
	if (first != pdu->last) {
   3ffee:	d02c      	beq.n	4004a <lll_adv_pdu_latest_get+0x66>
		pdu_idx = first;
   3fff0:	b2d5      	uxtb	r5, r2
			if (!MFIFO_ENQUEUE_IDX_GET(pdu_free, &free_idx)) {
   3fff2:	4a18      	ldr	r2, [pc, #96]	; (40054 <lll_adv_pdu_latest_get+0x70>)
   3fff4:	f892 e005 	ldrb.w	lr, [r2, #5]
   3fff8:	eb00 0785 	add.w	r7, r0, r5, lsl #2
	last = last + 1;
   3fffc:	f10e 0301 	add.w	r3, lr, #1
	if (last == count) {
   40000:	7890      	ldrb	r0, [r2, #2]
	last = last + 1;
   40002:	b2db      	uxtb	r3, r3
		last = 0U;
   40004:	4298      	cmp	r0, r3
   40006:	bf08      	it	eq
   40008:	2300      	moveq	r3, #0
   4000a:	7910      	ldrb	r0, [r2, #4]
	if (last == first) {
   4000c:	4298      	cmp	r0, r3
   4000e:	460e      	mov	r6, r1
		p = pdu->pdu[pdu_idx];
   40010:	6879      	ldr	r1, [r7, #4]
   40012:	d00b      	beq.n	4002c <lll_adv_pdu_latest_get+0x48>
			MFIFO_BY_IDX_ENQUEUE(pdu_free, free_idx, p);
   40014:	4694      	mov	ip, r2
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
   40016:	f81c 0b08 	ldrb.w	r0, [ip], #8
   4001a:	fb10 f00e 	smulbb	r0, r0, lr
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
   4001e:	f84c 1000 	str.w	r1, [ip, r0]
	*last = idx; /* Commit: Update write index */
   40022:	7153      	strb	r3, [r2, #5]
	z_impl_k_sem_give(sem);
   40024:	480c      	ldr	r0, [pc, #48]	; (40058 <lll_adv_pdu_latest_get+0x74>)
   40026:	f007 f8a7 	bl	47178 <z_impl_k_sem_give>
			p = next;
   4002a:	2100      	movs	r1, #0
		first += 1U;
   4002c:	1c6b      	adds	r3, r5, #1
   4002e:	b2db      	uxtb	r3, r3
		if (first == DOUBLE_BUFFER_SIZE) {
   40030:	2b02      	cmp	r3, #2
   40032:	bf0a      	itet	eq
   40034:	2200      	moveq	r2, #0
	return (void *)pdu->pdu[first];
   40036:	461a      	movne	r2, r3
			first = 0U;
   40038:	4613      	moveq	r3, r2
		pdu->pdu[pdu_idx] = p;
   4003a:	6079      	str	r1, [r7, #4]
		pdu->first = first;
   4003c:	7023      	strb	r3, [r4, #0]
		*is_modified = 1U;
   4003e:	2101      	movs	r1, #1
	return (void *)pdu->pdu[first];
   40040:	eb04 0482 	add.w	r4, r4, r2, lsl #2
		*is_modified = 1U;
   40044:	7031      	strb	r1, [r6, #0]
}
   40046:	6860      	ldr	r0, [r4, #4]
   40048:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		p = pdu->pdu[pdu_idx];
   4004a:	461a      	mov	r2, r3
	return (void *)pdu->pdu[first];
   4004c:	eb04 0482 	add.w	r4, r4, r2, lsl #2
}
   40050:	6860      	ldr	r0, [r4, #4]
   40052:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   40054:	20000ca4 	.word	0x20000ca4
   40058:	20005958 	.word	0x20005958

0004005c <chan_prepare.isra.0>:
#endif /* CONFIG_BT_PERIPHERAL */

static struct pdu_adv *chan_prepare(struct lll_adv *lll)
   4005c:	b530      	push	{r4, r5, lr}
{
	struct pdu_adv *pdu;
	uint8_t chan;
	uint8_t upd;

	chan = find_lsb_set(lll->chan_map_curr);
   4005e:	7a03      	ldrb	r3, [r0, #8]
   40060:	f3c3 1302 	ubfx	r3, r3, #4, #3
static struct pdu_adv *chan_prepare(struct lll_adv *lll)
   40064:	4604      	mov	r4, r0
   40066:	2b00      	cmp	r3, #0
   40068:	fa93 f0a3 	rbit	r0, r3
   4006c:	fab0 f080 	clz	r0, r0
   40070:	bf08      	it	eq
   40072:	f04f 30ff 	moveq.w	r0, #4294967295	; 0xffffffff
   40076:	b083      	sub	sp, #12
   40078:	f100 0501 	add.w	r5, r0, #1
	LL_ASSERT(chan);
   4007c:	d03b      	beq.n	400f6 <chan_prepare.isra.0+0x9a>

	lll->chan_map_curr &= (lll->chan_map_curr - 1);
   4007e:	7a21      	ldrb	r1, [r4, #8]
   40080:	1e5a      	subs	r2, r3, #1
   40082:	4013      	ands	r3, r2
   40084:	f363 1106 	bfi	r1, r3, #4, #3

	lll_chan_set(36 + chan);
   40088:	f105 0024 	add.w	r0, r5, #36	; 0x24
	lll->chan_map_curr &= (lll->chan_map_curr - 1);
   4008c:	7221      	strb	r1, [r4, #8]
	lll_chan_set(36 + chan);
   4008e:	f7ff fbab 	bl	3f7e8 <lll_chan_set>

	/* FIXME: get latest only when primary PDU without Aux PDUs */
	upd = 0U;
   40092:	2300      	movs	r3, #0
#endif /* CONFIG_BT_CTLR_ADV_EXT_PDU_EXTRA_DATA_MEMORY */

static inline struct pdu_adv *lll_adv_data_latest_get(struct lll_adv *lll,
						      uint8_t *is_modified)
{
	return lll_adv_pdu_latest_get(&lll->adv_data, is_modified);
   40094:	f10d 0107 	add.w	r1, sp, #7
   40098:	f104 000c 	add.w	r0, r4, #12
   4009c:	f88d 3007 	strb.w	r3, [sp, #7]
   400a0:	f7ff ffa0 	bl	3ffe4 <lll_adv_pdu_latest_get>
	pdu = lll_adv_data_latest_get(lll, &upd);
	LL_ASSERT(pdu);
   400a4:	4605      	mov	r5, r0
   400a6:	2800      	cmp	r0, #0
   400a8:	d036      	beq.n	40118 <chan_prepare.isra.0+0xbc>

	radio_pkt_tx_set(pdu);
   400aa:	4628      	mov	r0, r5
   400ac:	f001 fdea 	bl	41c84 <radio_pkt_tx_set>

	if ((pdu->type != PDU_ADV_TYPE_NONCONN_IND) &&
   400b0:	782b      	ldrb	r3, [r5, #0]
   400b2:	f003 030f 	and.w	r3, r3, #15
   400b6:	2b02      	cmp	r3, #2
   400b8:	d014      	beq.n	400e4 <chan_prepare.isra.0+0x88>
}

static inline struct pdu_adv *lll_adv_scan_rsp_latest_get(struct lll_adv *lll,
							  uint8_t *is_modified)
{
	return lll_adv_pdu_latest_get(&lll->scan_rsp, is_modified);
   400ba:	f10d 0107 	add.w	r1, sp, #7
   400be:	f104 0018 	add.w	r0, r4, #24
   400c2:	f7ff ff8f 	bl	3ffe4 <lll_adv_pdu_latest_get>
	    (!IS_ENABLED(CONFIG_BT_CTLR_ADV_EXT) ||
	     (pdu->type != PDU_ADV_TYPE_EXT_IND))) {
		struct pdu_adv *scan_pdu;

		scan_pdu = lll_adv_scan_rsp_latest_get(lll, &upd);
		LL_ASSERT(scan_pdu);
   400c6:	2800      	cmp	r0, #0
   400c8:	d034      	beq.n	40134 <chan_prepare.isra.0+0xd8>
#else
		ARG_UNUSED(scan_pdu);
		ARG_UNUSED(upd);
#endif /* !CONFIG_BT_CTLR_PRIVACY */

		radio_isr_set(isr_tx, lll);
   400ca:	4621      	mov	r1, r4
   400cc:	4820      	ldr	r0, [pc, #128]	; (40150 <chan_prepare.isra.0+0xf4>)
   400ce:	f001 fd09 	bl	41ae4 <radio_isr_set>
		radio_tmr_tifs_set(EVENT_IFS_US);
   400d2:	2096      	movs	r0, #150	; 0x96
   400d4:	f001 ff60 	bl	41f98 <radio_tmr_tifs_set>
		radio_switch_complete_and_rx(0);
   400d8:	2000      	movs	r0, #0
		radio_isr_set(isr_done, lll);
		radio_switch_complete_and_disable();
	}

	return pdu;
}
   400da:	b003      	add	sp, #12
   400dc:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		radio_switch_complete_and_rx(0);
   400e0:	f001 be4e 	b.w	41d80 <radio_switch_complete_and_rx>
		radio_isr_set(isr_done, lll);
   400e4:	481b      	ldr	r0, [pc, #108]	; (40154 <chan_prepare.isra.0+0xf8>)
   400e6:	4621      	mov	r1, r4
   400e8:	f001 fcfc 	bl	41ae4 <radio_isr_set>
}
   400ec:	b003      	add	sp, #12
   400ee:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		radio_switch_complete_and_disable();
   400f2:	f001 beed 	b.w	41ed0 <radio_switch_complete_and_disable>
	LL_ASSERT(chan);
   400f6:	4a18      	ldr	r2, [pc, #96]	; (40158 <chan_prepare.isra.0+0xfc>)
   400f8:	4918      	ldr	r1, [pc, #96]	; (4015c <chan_prepare.isra.0+0x100>)
   400fa:	4819      	ldr	r0, [pc, #100]	; (40160 <chan_prepare.isra.0+0x104>)
   400fc:	f240 539c 	movw	r3, #1436	; 0x59c
   40100:	f008 ffc0 	bl	49084 <assert_print>
   40104:	4040      	eors	r0, r0
   40106:	f380 8811 	msr	BASEPRI, r0
   4010a:	f04f 0003 	mov.w	r0, #3
   4010e:	df02      	svc	2
	lll->chan_map_curr &= (lll->chan_map_curr - 1);
   40110:	7a23      	ldrb	r3, [r4, #8]
   40112:	f3c3 1302 	ubfx	r3, r3, #4, #3
   40116:	e7b2      	b.n	4007e <chan_prepare.isra.0+0x22>
	LL_ASSERT(pdu);
   40118:	4a0f      	ldr	r2, [pc, #60]	; (40158 <chan_prepare.isra.0+0xfc>)
   4011a:	4912      	ldr	r1, [pc, #72]	; (40164 <chan_prepare.isra.0+0x108>)
   4011c:	4810      	ldr	r0, [pc, #64]	; (40160 <chan_prepare.isra.0+0x104>)
   4011e:	f240 53a5 	movw	r3, #1445	; 0x5a5
   40122:	f008 ffaf 	bl	49084 <assert_print>
   40126:	4040      	eors	r0, r0
   40128:	f380 8811 	msr	BASEPRI, r0
   4012c:	f04f 0003 	mov.w	r0, #3
   40130:	df02      	svc	2
   40132:	e7ba      	b.n	400aa <chan_prepare.isra.0+0x4e>
		LL_ASSERT(scan_pdu);
   40134:	4a08      	ldr	r2, [pc, #32]	; (40158 <chan_prepare.isra.0+0xfc>)
   40136:	490c      	ldr	r1, [pc, #48]	; (40168 <chan_prepare.isra.0+0x10c>)
   40138:	4809      	ldr	r0, [pc, #36]	; (40160 <chan_prepare.isra.0+0x104>)
   4013a:	f240 53af 	movw	r3, #1455	; 0x5af
   4013e:	f008 ffa1 	bl	49084 <assert_print>
   40142:	4040      	eors	r0, r0
   40144:	f380 8811 	msr	BASEPRI, r0
   40148:	f04f 0003 	mov.w	r0, #3
   4014c:	df02      	svc	2
   4014e:	e7bc      	b.n	400ca <chan_prepare.isra.0+0x6e>
   40150:	0003fc75 	.word	0x0003fc75
   40154:	0004016d 	.word	0x0004016d
   40158:	00052b48 	.word	0x00052b48
   4015c:	00052bb4 	.word	0x00052bb4
   40160:	0005214c 	.word	0x0005214c
   40164:	00052bbc 	.word	0x00052bbc
   40168:	00052bc0 	.word	0x00052bc0

0004016c <isr_done>:
{
   4016c:	b510      	push	{r4, lr}
   4016e:	4604      	mov	r4, r0
	lll_isr_status_reset();
   40170:	f7ff fb92 	bl	3f898 <lll_isr_status_reset>
	if (!IS_ENABLED(CONFIG_BT_CTLR_LOW_LAT) && lll->is_hdcd &&
   40174:	7a23      	ldrb	r3, [r4, #8]
   40176:	f003 0271 	and.w	r2, r3, #113	; 0x71
   4017a:	2a01      	cmp	r2, #1
   4017c:	d105      	bne.n	4018a <isr_done+0x1e>
		lll->chan_map_curr = lll->chan_map;
   4017e:	f3c3 0242 	ubfx	r2, r3, #1, #3
   40182:	f362 1306 	bfi	r3, r2, #4, #3
   40186:	7223      	strb	r3, [r4, #8]
	if (lll->chan_map_curr &&
   40188:	b2db      	uxtb	r3, r3
   4018a:	f013 0f70 	tst.w	r3, #112	; 0x70
   4018e:	d005      	beq.n	4019c <isr_done+0x30>
	    (!lll->conn || !lll->conn->periph.cancelled) &&
   40190:	6863      	ldr	r3, [r4, #4]
   40192:	b153      	cbz	r3, 401aa <isr_done+0x3e>
   40194:	f893 3020 	ldrb.w	r3, [r3, #32]
   40198:	079b      	lsls	r3, r3, #30
   4019a:	d506      	bpl.n	401aa <isr_done+0x3e>
	radio_filter_disable();
   4019c:	f001 feca 	bl	41f34 <radio_filter_disable>
	lll_isr_cleanup(param);
   401a0:	4620      	mov	r0, r4
}
   401a2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lll_isr_cleanup(param);
   401a6:	f7ff bb83 	b.w	3f8b0 <lll_isr_cleanup>
		pdu = chan_prepare(lll);
   401aa:	4620      	mov	r0, r4
   401ac:	f7ff ff56 	bl	4005c <chan_prepare.isra.0>
		radio_tx_enable();
   401b0:	f001 fd84 	bl	41cbc <radio_tx_enable>
}
   401b4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		radio_tmr_end_capture();
   401b8:	f001 bffa 	b.w	421b0 <radio_tmr_end_capture>

000401bc <prepare_cb>:
{
   401bc:	b5f0      	push	{r4, r5, r6, r7, lr}
	lll = p->param;
   401be:	68c4      	ldr	r4, [r0, #12]
	if (unlikely(lll->conn &&
   401c0:	6863      	ldr	r3, [r4, #4]
{
   401c2:	b083      	sub	sp, #12
   401c4:	4605      	mov	r5, r0
	if (unlikely(lll->conn &&
   401c6:	2b00      	cmp	r3, #0
   401c8:	d158      	bne.n	4027c <prepare_cb+0xc0>
	radio_reset();
   401ca:	f001 fccd 	bl	41b68 <radio_reset>
	radio_tx_power_set(RADIO_TXP_DEFAULT);
   401ce:	2000      	movs	r0, #0
   401d0:	f001 fcf6 	bl	41bc0 <radio_tx_power_set>
	radio_phy_set(0, 0);
   401d4:	2100      	movs	r1, #0
   401d6:	4608      	mov	r0, r1
   401d8:	f001 fce2 	bl	41ba0 <radio_phy_set>
	radio_pkt_configure(RADIO_PKT_CONF_LENGTH_8BIT, PDU_AC_LEG_PAYLOAD_SIZE_MAX,
   401dc:	2200      	movs	r2, #0
   401de:	2125      	movs	r1, #37	; 0x25
   401e0:	2008      	movs	r0, #8
   401e2:	f001 fd23 	bl	41c2c <radio_pkt_configure>
	aa = sys_cpu_to_le32(PDU_AC_ACCESS_ADDR);
   401e6:	4b2b      	ldr	r3, [pc, #172]	; (40294 <prepare_cb+0xd8>)
   401e8:	9301      	str	r3, [sp, #4]
	radio_aa_set((uint8_t *)&aa);
   401ea:	a801      	add	r0, sp, #4
   401ec:	f001 fd06 	bl	41bfc <radio_aa_set>
	radio_crc_configure(PDU_CRC_POLYNOMIAL,
   401f0:	4929      	ldr	r1, [pc, #164]	; (40298 <prepare_cb+0xdc>)
   401f2:	f240 605b 	movw	r0, #1627	; 0x65b
   401f6:	f001 fda5 	bl	41d44 <radio_crc_configure>
	lll->chan_map_curr = lll->chan_map;
   401fa:	7a23      	ldrb	r3, [r4, #8]
   401fc:	f3c3 0242 	ubfx	r2, r3, #1, #3
   40200:	f362 1306 	bfi	r3, r2, #4, #3
   40204:	7223      	strb	r3, [r4, #8]
	pdu = chan_prepare(lll);
   40206:	4620      	mov	r0, r4
   40208:	f7ff ff28 	bl	4005c <chan_prepare.isra.0>
	ull = HDR_LLL2ULL(lll);
   4020c:	6827      	ldr	r7, [r4, #0]
	ticks_at_event = p->ticks_at_expire;
   4020e:	682e      	ldr	r6, [r5, #0]
	ticks_at_event += lll_event_offset_get(ull);
   40210:	4638      	mov	r0, r7
   40212:	f7ff facb 	bl	3f7ac <lll_event_offset_get>
   40216:	4406      	add	r6, r0
	start_us = radio_tmr_start(1, ticks_at_start, remainder);
   40218:	686a      	ldr	r2, [r5, #4]
   4021a:	f106 0118 	add.w	r1, r6, #24
   4021e:	2001      	movs	r0, #1
   40220:	f001 fec6 	bl	41fb0 <radio_tmr_start>
	radio_tmr_end_capture();
   40224:	f001 ffc4 	bl	421b0 <radio_tmr_end_capture>
				   ull_adv_lll_handle_get(lll)),
   40228:	4620      	mov	r0, r4
   4022a:	f7f8 fec7 	bl	38fbc <ull_adv_lll_handle_get>
	if (lll_preempt_calc(ull, (TICKER_ID_ADV_BASE +
   4022e:	1c81      	adds	r1, r0, #2
   40230:	4632      	mov	r2, r6
   40232:	b2c9      	uxtb	r1, r1
   40234:	4638      	mov	r0, r7
   40236:	f7ff fac7 	bl	3f7c8 <lll_preempt_calc>
   4023a:	b930      	cbnz	r0, 4024a <prepare_cb+0x8e>
		ret = lll_prepare_done(lll);
   4023c:	4620      	mov	r0, r4
   4023e:	f7ff fa4f 	bl	3f6e0 <lll_prepare_done>
		LL_ASSERT(!ret);
   40242:	b958      	cbnz	r0, 4025c <prepare_cb+0xa0>
}
   40244:	2000      	movs	r0, #0
   40246:	b003      	add	sp, #12
   40248:	bdf0      	pop	{r4, r5, r6, r7, pc}
		radio_isr_set(isr_abort, lll);
   4024a:	4814      	ldr	r0, [pc, #80]	; (4029c <prepare_cb+0xe0>)
   4024c:	4621      	mov	r1, r4
   4024e:	f001 fc49 	bl	41ae4 <radio_isr_set>
		radio_disable();
   40252:	f001 fd39 	bl	41cc8 <radio_disable>
}
   40256:	2000      	movs	r0, #0
   40258:	b003      	add	sp, #12
   4025a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		LL_ASSERT(!ret);
   4025c:	4a10      	ldr	r2, [pc, #64]	; (402a0 <prepare_cb+0xe4>)
   4025e:	4911      	ldr	r1, [pc, #68]	; (402a4 <prepare_cb+0xe8>)
   40260:	4811      	ldr	r0, [pc, #68]	; (402a8 <prepare_cb+0xec>)
   40262:	f240 4313 	movw	r3, #1043	; 0x413
   40266:	f008 ff0d 	bl	49084 <assert_print>
   4026a:	4040      	eors	r0, r0
   4026c:	f380 8811 	msr	BASEPRI, r0
   40270:	f04f 0003 	mov.w	r0, #3
   40274:	df02      	svc	2
}
   40276:	2000      	movs	r0, #0
   40278:	b003      	add	sp, #12
   4027a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (unlikely(lll->conn &&
   4027c:	f893 3020 	ldrb.w	r3, [r3, #32]
   40280:	079b      	lsls	r3, r3, #30
   40282:	d0a2      	beq.n	401ca <prepare_cb+0xe>
		radio_isr_set(lll_isr_early_abort, lll);
   40284:	4809      	ldr	r0, [pc, #36]	; (402ac <prepare_cb+0xf0>)
   40286:	4621      	mov	r1, r4
   40288:	f001 fc2c 	bl	41ae4 <radio_isr_set>
		radio_disable();
   4028c:	f001 fd1c 	bl	41cc8 <radio_disable>
		return 0;
   40290:	e7d8      	b.n	40244 <prepare_cb+0x88>
   40292:	bf00      	nop
   40294:	8e89bed6 	.word	0x8e89bed6
   40298:	00555555 	.word	0x00555555
   4029c:	0003fc5d 	.word	0x0003fc5d
   402a0:	00052b48 	.word	0x00052b48
   402a4:	00052430 	.word	0x00052430
   402a8:	0005214c 	.word	0x0005214c
   402ac:	0003f945 	.word	0x0003f945

000402b0 <resume_prepare_cb>:
{
   402b0:	b570      	push	{r4, r5, r6, lr}
	ull = HDR_LLL2ULL(p->param);
   402b2:	68c3      	ldr	r3, [r0, #12]
{
   402b4:	4604      	mov	r4, r0
	ull = HDR_LLL2ULL(p->param);
   402b6:	681e      	ldr	r6, [r3, #0]
	p->ticks_at_expire = ticker_ticks_now_get() - lll_event_offset_get(ull);
   402b8:	f7f5 fca0 	bl	35bfc <ticker_ticks_now_get>
   402bc:	4605      	mov	r5, r0
   402be:	4630      	mov	r0, r6
   402c0:	f7ff fa74 	bl	3f7ac <lll_event_offset_get>
	p->remainder = 0;
   402c4:	2300      	movs	r3, #0
	p->ticks_at_expire = ticker_ticks_now_get() - lll_event_offset_get(ull);
   402c6:	1a2d      	subs	r5, r5, r0
	p->remainder = 0;
   402c8:	e9c4 5300 	strd	r5, r3, [r4]
	p->lazy = 0;
   402cc:	8123      	strh	r3, [r4, #8]
	return prepare_cb(p);
   402ce:	4620      	mov	r0, r4
}
   402d0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return prepare_cb(p);
   402d4:	f7ff bf72 	b.w	401bc <prepare_cb>

000402d8 <lll_adv_prepare>:
{
   402d8:	b510      	push	{r4, lr}
   402da:	b082      	sub	sp, #8
   402dc:	4604      	mov	r4, r0
	err = lll_hfclock_on();
   402de:	f7ff fc7f 	bl	3fbe0 <lll_hfclock_on>
	LL_ASSERT(err >= 0);
   402e2:	2800      	cmp	r0, #0
   402e4:	db1a      	blt.n	4031c <lll_adv_prepare+0x44>
	err = lll_prepare(is_abort_cb, abort_cb, prepare_cb, 0, param);
   402e6:	4a14      	ldr	r2, [pc, #80]	; (40338 <lll_adv_prepare+0x60>)
   402e8:	4914      	ldr	r1, [pc, #80]	; (4033c <lll_adv_prepare+0x64>)
   402ea:	4815      	ldr	r0, [pc, #84]	; (40340 <lll_adv_prepare+0x68>)
   402ec:	9400      	str	r4, [sp, #0]
   402ee:	2300      	movs	r3, #0
   402f0:	f7f8 fa20 	bl	38734 <lll_prepare>
	LL_ASSERT(!err || err == -EINPROGRESS);
   402f4:	b108      	cbz	r0, 402fa <lll_adv_prepare+0x22>
   402f6:	3077      	adds	r0, #119	; 0x77
   402f8:	d101      	bne.n	402fe <lll_adv_prepare+0x26>
}
   402fa:	b002      	add	sp, #8
   402fc:	bd10      	pop	{r4, pc}
	LL_ASSERT(!err || err == -EINPROGRESS);
   402fe:	4a11      	ldr	r2, [pc, #68]	; (40344 <lll_adv_prepare+0x6c>)
   40300:	4911      	ldr	r1, [pc, #68]	; (40348 <lll_adv_prepare+0x70>)
   40302:	4812      	ldr	r0, [pc, #72]	; (4034c <lll_adv_prepare+0x74>)
   40304:	f240 23ab 	movw	r3, #683	; 0x2ab
   40308:	f008 febc 	bl	49084 <assert_print>
   4030c:	4040      	eors	r0, r0
   4030e:	f380 8811 	msr	BASEPRI, r0
   40312:	f04f 0003 	mov.w	r0, #3
   40316:	df02      	svc	2
}
   40318:	b002      	add	sp, #8
   4031a:	bd10      	pop	{r4, pc}
	LL_ASSERT(err >= 0);
   4031c:	4a09      	ldr	r2, [pc, #36]	; (40344 <lll_adv_prepare+0x6c>)
   4031e:	490c      	ldr	r1, [pc, #48]	; (40350 <lll_adv_prepare+0x78>)
   40320:	480a      	ldr	r0, [pc, #40]	; (4034c <lll_adv_prepare+0x74>)
   40322:	f44f 732a 	mov.w	r3, #680	; 0x2a8
   40326:	f008 fead 	bl	49084 <assert_print>
   4032a:	4040      	eors	r0, r0
   4032c:	f380 8811 	msr	BASEPRI, r0
   40330:	f04f 0003 	mov.w	r0, #3
   40334:	df02      	svc	2
   40336:	e7d6      	b.n	402e6 <lll_adv_prepare+0xe>
   40338:	000401bd 	.word	0x000401bd
   4033c:	0003fde1 	.word	0x0003fde1
   40340:	0003fd25 	.word	0x0003fd25
   40344:	00052b48 	.word	0x00052b48
   40348:	00052bcc 	.word	0x00052bcc
   4034c:	0005214c 	.word	0x0005214c
   40350:	00052af8 	.word	0x00052af8

00040354 <lll_adv_connect_ind_check>:
{
   40354:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   40356:	9e07      	ldr	r6, [sp, #28]
   40358:	f89d 7018 	ldrb.w	r7, [sp, #24]
   4035c:	f89d 4020 	ldrb.w	r4, [sp, #32]
   40360:	460d      	mov	r5, r1
	if (tgt_addr) {
   40362:	b95e      	cbnz	r6, 4037c <lll_adv_connect_ind_check+0x28>
	return (((lll->filter_policy & BT_LE_ADV_FP_FILTER_CONN_IND) == 0) ||
   40364:	7a41      	ldrb	r1, [r0, #9]
		(devmatch_ok)) &&
   40366:	f001 0103 	and.w	r1, r1, #3
   4036a:	2901      	cmp	r1, #1
   4036c:	d900      	bls.n	40370 <lll_adv_connect_ind_check+0x1c>
	return (((lll->filter_policy & BT_LE_ADV_FP_FILTER_CONN_IND) == 0) ||
   4036e:	b11c      	cbz	r4, 40378 <lll_adv_connect_ind_check+0x24>
}

static bool isr_rx_sr_adva_check(uint8_t tx_addr, uint8_t *addr,
				 struct pdu_adv *sr)
{
	return (tx_addr == sr->rx_addr) &&
   40370:	7829      	ldrb	r1, [r5, #0]
   40372:	ebb2 1fd1 	cmp.w	r2, r1, lsr #7
   40376:	d01b      	beq.n	403b0 <lll_adv_connect_ind_check+0x5c>
   40378:	2000      	movs	r0, #0
}
   4037a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (tx_addr == sr->rx_addr) &&
   4037c:	7809      	ldrb	r1, [r1, #0]
   4037e:	ebb2 1fd1 	cmp.w	r2, r1, lsr #7
   40382:	d1f9      	bne.n	40378 <lll_adv_connect_ind_check+0x24>
		!memcmp(addr, sr->scan_req.adv_addr, BDADDR_SIZE);
   40384:	2206      	movs	r2, #6
   40386:	4618      	mov	r0, r3
   40388:	f105 0108 	add.w	r1, r5, #8
   4038c:	f00a fd65 	bl	4ae5a <memcmp>
	return (tx_addr == sr->rx_addr) &&
   40390:	2800      	cmp	r0, #0
   40392:	d1f1      	bne.n	40378 <lll_adv_connect_ind_check+0x24>
#if defined(CONFIG_BT_CTLR_PRIVACY)
	if (rl_idx != FILTER_IDX_NONE && lll->rl_idx != FILTER_IDX_NONE) {
		return rl_idx == lll->rl_idx;
	}
#endif /* CONFIG_BT_CTLR_PRIVACY */
	return (rx_addr == ci->tx_addr) &&
   40394:	782b      	ldrb	r3, [r5, #0]
   40396:	f3c3 1380 	ubfx	r3, r3, #6, #1
   4039a:	42bb      	cmp	r3, r7
   4039c:	d1ec      	bne.n	40378 <lll_adv_connect_ind_check+0x24>
	       !memcmp(tgt_addr, ci->connect_ind.init_addr, BDADDR_SIZE);
   4039e:	2206      	movs	r2, #6
   403a0:	1ca9      	adds	r1, r5, #2
   403a2:	4630      	mov	r0, r6
   403a4:	f00a fd59 	bl	4ae5a <memcmp>
	return (rx_addr == ci->tx_addr) &&
   403a8:	fab0 f080 	clz	r0, r0
   403ac:	0940      	lsrs	r0, r0, #5
}
   403ae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		!memcmp(addr, sr->scan_req.adv_addr, BDADDR_SIZE);
   403b0:	2206      	movs	r2, #6
   403b2:	f105 0108 	add.w	r1, r5, #8
   403b6:	4618      	mov	r0, r3
   403b8:	f00a fd4f 	bl	4ae5a <memcmp>
	return (tx_addr == sr->rx_addr) &&
   403bc:	fab0 f080 	clz	r0, r0
   403c0:	0940      	lsrs	r0, r0, #5
}
   403c2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000403c4 <isr_rx>:
{
   403c4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   403c8:	b088      	sub	sp, #32
   403ca:	4604      	mov	r4, r0
	trx_done = radio_is_done();
   403cc:	f001 fca6 	bl	41d1c <radio_is_done>
	if (trx_done) {
   403d0:	b2c0      	uxtb	r0, r0
   403d2:	b950      	cbnz	r0, 403ea <isr_rx+0x26>
	lll_isr_status_reset();
   403d4:	f7ff fa60 	bl	3f898 <lll_isr_status_reset>
	radio_isr_set(isr_done, param);
   403d8:	4874      	ldr	r0, [pc, #464]	; (405ac <isr_rx+0x1e8>)
   403da:	4621      	mov	r1, r4
   403dc:	f001 fb82 	bl	41ae4 <radio_isr_set>
}
   403e0:	b008      	add	sp, #32
   403e2:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	radio_disable();
   403e6:	f001 bc6f 	b.w	41cc8 <radio_disable>
		crc_ok = radio_crc_is_valid();
   403ea:	f001 fcb7 	bl	41d5c <radio_crc_is_valid>
   403ee:	4605      	mov	r5, r0
		devmatch_ok = radio_filter_has_match();
   403f0:	f001 fdb2 	bl	41f58 <radio_filter_has_match>
	if (crc_ok) {
   403f4:	b2ed      	uxtb	r5, r5
		devmatch_ok = radio_filter_has_match();
   403f6:	4606      	mov	r6, r0
		devmatch_id = radio_filter_match_get();
   403f8:	f001 fdb8 	bl	41f6c <radio_filter_match_get>
		rssi_ready = radio_rssi_is_ready();
   403fc:	f001 fd90 	bl	41f20 <radio_rssi_is_ready>
	lll_isr_status_reset();
   40400:	f7ff fa4a 	bl	3f898 <lll_isr_status_reset>
	if (crc_ok) {
   40404:	2d00      	cmp	r5, #0
   40406:	d0e7      	beq.n	403d8 <isr_rx+0x14>
	uint8_t rl_idx = FILTER_IDX_NONE;
   40408:	23ff      	movs	r3, #255	; 0xff
	node_rx = ull_pdu_rx_alloc_peek(1);
   4040a:	2001      	movs	r0, #1
	uint8_t rl_idx = FILTER_IDX_NONE;
   4040c:	f88d 301f 	strb.w	r3, [sp, #31]
	node_rx = ull_pdu_rx_alloc_peek(1);
   40410:	f7f7 fe3c 	bl	3808c <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
   40414:	4605      	mov	r5, r0
   40416:	2800      	cmp	r0, #0
   40418:	f000 8099 	beq.w	4054e <isr_rx+0x18a>
   4041c:	7b23      	ldrb	r3, [r4, #12]
   4041e:	eb04 0383 	add.w	r3, r4, r3, lsl #2
	pdu_rx = (void *)node_rx->pdu;
   40422:	f105 091c 	add.w	r9, r5, #28
   40426:	6919      	ldr	r1, [r3, #16]
	addr = pdu_adv->adv_ind.addr;
   40428:	460b      	mov	r3, r1
		devmatch_ok = radio_filter_has_match();
   4042a:	b2f6      	uxtb	r6, r6
	tx_addr = pdu_adv->tx_addr;
   4042c:	f813 2b02 	ldrb.w	r2, [r3], #2
	if (pdu_adv->type == PDU_ADV_TYPE_DIRECT_IND) {
   40430:	f002 000f 	and.w	r0, r2, #15
   40434:	2801      	cmp	r0, #1
		tgt_addr = pdu_adv->direct_ind.tgt_addr;
   40436:	bf08      	it	eq
   40438:	f101 0808 	addeq.w	r8, r1, #8
	if ((pdu_rx->type == PDU_ADV_TYPE_SCAN_REQ) &&
   4043c:	7f29      	ldrb	r1, [r5, #28]
	tx_addr = pdu_adv->tx_addr;
   4043e:	f3c2 1a80 	ubfx	sl, r2, #6, #1
	rx_addr = pdu_adv->rx_addr;
   40442:	ea4f 17d2 	mov.w	r7, r2, lsr #7
	if ((pdu_rx->type == PDU_ADV_TYPE_SCAN_REQ) &&
   40446:	f001 020f 	and.w	r2, r1, #15
		tgt_addr = NULL;
   4044a:	bf18      	it	ne
   4044c:	f04f 0800 	movne.w	r8, #0
	if ((pdu_rx->type == PDU_ADV_TYPE_SCAN_REQ) &&
   40450:	2a03      	cmp	r2, #3
   40452:	d04f      	beq.n	404f4 <isr_rx+0x130>
	} else if ((pdu_rx->type == PDU_ADV_TYPE_CONNECT_IND) &&
   40454:	2a05      	cmp	r2, #5
   40456:	d1bf      	bne.n	403d8 <isr_rx+0x14>
   40458:	7f6a      	ldrb	r2, [r5, #29]
   4045a:	2a22      	cmp	r2, #34	; 0x22
   4045c:	d1bc      	bne.n	403d8 <isr_rx+0x14>
		   lll->conn && !lll->conn->periph.cancelled &&
   4045e:	6862      	ldr	r2, [r4, #4]
		   (pdu_rx->len == sizeof(struct pdu_adv_connect_ind)) &&
   40460:	2a00      	cmp	r2, #0
   40462:	d0b9      	beq.n	403d8 <isr_rx+0x14>
		   lll->conn && !lll->conn->periph.cancelled &&
   40464:	f892 2020 	ldrb.w	r2, [r2, #32]
   40468:	0792      	lsls	r2, r2, #30
   4046a:	d4b5      	bmi.n	403d8 <isr_rx+0x14>
		   lll_adv_connect_ind_check(lll, pdu_rx, tx_addr, addr,
   4046c:	f10d 051f 	add.w	r5, sp, #31
   40470:	e9cd 8601 	strd	r8, r6, [sp, #4]
   40474:	9700      	str	r7, [sp, #0]
   40476:	4652      	mov	r2, sl
   40478:	4649      	mov	r1, r9
   4047a:	4620      	mov	r0, r4
   4047c:	9503      	str	r5, [sp, #12]
   4047e:	f7ff ff69 	bl	40354 <lll_adv_connect_ind_check>
		   lll->conn && !lll->conn->periph.cancelled &&
   40482:	2800      	cmp	r0, #0
   40484:	d0a8      	beq.n	403d8 <isr_rx+0x14>
			rx = ull_pdu_rx_alloc_peek(4);
   40486:	2004      	movs	r0, #4
   40488:	f7f7 fe00 	bl	3808c <ull_pdu_rx_alloc_peek>
		if (!rx) {
   4048c:	2800      	cmp	r0, #0
   4048e:	d0a3      	beq.n	403d8 <isr_rx+0x14>
		radio_isr_set(isr_abort_all, lll);
   40490:	4847      	ldr	r0, [pc, #284]	; (405b0 <isr_rx+0x1ec>)
   40492:	4621      	mov	r1, r4
   40494:	f001 fb26 	bl	41ae4 <radio_isr_set>
		radio_disable();
   40498:	f001 fc16 	bl	41cc8 <radio_disable>
		LL_ASSERT(!radio_is_ready());
   4049c:	f001 fc34 	bl	41d08 <radio_is_ready>
   404a0:	2800      	cmp	r0, #0
   404a2:	d146      	bne.n	40532 <isr_rx+0x16e>
		lll->conn->periph.initiated = 1;
   404a4:	6862      	ldr	r2, [r4, #4]
   404a6:	f892 3020 	ldrb.w	r3, [r2, #32]
   404aa:	f043 0301 	orr.w	r3, r3, #1
   404ae:	f882 3020 	strb.w	r3, [r2, #32]
		rx = ull_pdu_rx_alloc();
   404b2:	f7f7 fe0d 	bl	380d0 <ull_pdu_rx_alloc>
		rx->hdr.type = NODE_RX_TYPE_CONNECTION;
   404b6:	2217      	movs	r2, #23
		rx->hdr.handle = 0xffff;
   404b8:	f64f 73ff 	movw	r3, #65535	; 0xffff
		rx->hdr.type = NODE_RX_TYPE_CONNECTION;
   404bc:	7102      	strb	r2, [r0, #4]
		rx->hdr.handle = 0xffff;
   404be:	80c3      	strh	r3, [r0, #6]
		ftr->param = lll;
   404c0:	6084      	str	r4, [r0, #8]
		rx = ull_pdu_rx_alloc();
   404c2:	4605      	mov	r5, r0
		ftr->ticks_anchor = radio_tmr_start_get();
   404c4:	f001 fe28 	bl	42118 <radio_tmr_start_get>
   404c8:	6128      	str	r0, [r5, #16]
		ftr->radio_end_us = radio_tmr_end_get() -
   404ca:	f001 fe79 	bl	421c0 <radio_tmr_end_get>
				    radio_rx_chain_delay_get(0, 0);
   404ce:	2100      	movs	r1, #0
		ftr->radio_end_us = radio_tmr_end_get() -
   404d0:	4604      	mov	r4, r0
				    radio_rx_chain_delay_get(0, 0);
   404d2:	4608      	mov	r0, r1
   404d4:	f001 fbe6 	bl	41ca4 <radio_rx_chain_delay_get>
		ftr->radio_end_us = radio_tmr_end_get() -
   404d8:	1a24      	subs	r4, r4, r0
   404da:	616c      	str	r4, [r5, #20]
			ftr->extra = ull_pdu_rx_alloc();
   404dc:	f7f7 fdf8 	bl	380d0 <ull_pdu_rx_alloc>
		ull_rx_put(rx->hdr.link, rx);
   404e0:	4629      	mov	r1, r5
			ftr->extra = ull_pdu_rx_alloc();
   404e2:	60e8      	str	r0, [r5, #12]
		ull_rx_put(rx->hdr.link, rx);
   404e4:	6828      	ldr	r0, [r5, #0]
   404e6:	f7f7 fe09 	bl	380fc <ull_rx_put>
}
   404ea:	b008      	add	sp, #32
   404ec:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		ull_rx_sched();
   404f0:	f7f7 be14 	b.w	3811c <ull_rx_sched>
	if ((pdu_rx->type == PDU_ADV_TYPE_SCAN_REQ) &&
   404f4:	7f6a      	ldrb	r2, [r5, #29]
   404f6:	2a0c      	cmp	r2, #12
   404f8:	f47f af6e 	bne.w	403d8 <isr_rx+0x14>
	    (pdu_rx->len == sizeof(struct pdu_adv_scan_req)) &&
   404fc:	f1b8 0f00 	cmp.w	r8, #0
   40500:	f47f af6a 	bne.w	403d8 <isr_rx+0x14>
	return (((lll->filter_policy & BT_LE_ADV_FP_FILTER_SCAN_REQ) == 0U) ||
   40504:	7a62      	ldrb	r2, [r4, #9]
		 devmatch_ok) &&
   40506:	07d0      	lsls	r0, r2, #31
   40508:	d502      	bpl.n	40510 <isr_rx+0x14c>
	return (((lll->filter_policy & BT_LE_ADV_FP_FILTER_SCAN_REQ) == 0U) ||
   4050a:	2e00      	cmp	r6, #0
   4050c:	f43f af64 	beq.w	403d8 <isr_rx+0x14>
	return (tx_addr == sr->rx_addr) &&
   40510:	ebba 1fd1 	cmp.w	sl, r1, lsr #7
   40514:	f47f af60 	bne.w	403d8 <isr_rx+0x14>
		!memcmp(addr, sr->scan_req.adv_addr, BDADDR_SIZE);
   40518:	2206      	movs	r2, #6
   4051a:	f105 0124 	add.w	r1, r5, #36	; 0x24
   4051e:	4618      	mov	r0, r3
   40520:	9305      	str	r3, [sp, #20]
   40522:	f00a fc9a 	bl	4ae5a <memcmp>
	return (tx_addr == sr->rx_addr) &&
   40526:	b300      	cbz	r0, 4056a <isr_rx+0x1a6>
	} else if ((pdu_rx->type == PDU_ADV_TYPE_CONNECT_IND) &&
   40528:	7f2a      	ldrb	r2, [r5, #28]
   4052a:	9b05      	ldr	r3, [sp, #20]
   4052c:	f002 020f 	and.w	r2, r2, #15
   40530:	e790      	b.n	40454 <isr_rx+0x90>
		LL_ASSERT(!radio_is_ready());
   40532:	4a20      	ldr	r2, [pc, #128]	; (405b4 <isr_rx+0x1f0>)
   40534:	4920      	ldr	r1, [pc, #128]	; (405b8 <isr_rx+0x1f4>)
   40536:	4821      	ldr	r0, [pc, #132]	; (405bc <isr_rx+0x1f8>)
   40538:	f240 633f 	movw	r3, #1599	; 0x63f
   4053c:	f008 fda2 	bl	49084 <assert_print>
   40540:	4040      	eors	r0, r0
   40542:	f380 8811 	msr	BASEPRI, r0
   40546:	f04f 0003 	mov.w	r0, #3
   4054a:	df02      	svc	2
   4054c:	e7aa      	b.n	404a4 <isr_rx+0xe0>
	LL_ASSERT(node_rx);
   4054e:	4a19      	ldr	r2, [pc, #100]	; (405b4 <isr_rx+0x1f0>)
   40550:	491b      	ldr	r1, [pc, #108]	; (405c0 <isr_rx+0x1fc>)
   40552:	481a      	ldr	r0, [pc, #104]	; (405bc <isr_rx+0x1f8>)
   40554:	f240 53df 	movw	r3, #1503	; 0x5df
   40558:	f008 fd94 	bl	49084 <assert_print>
   4055c:	4040      	eors	r0, r0
   4055e:	f380 8811 	msr	BASEPRI, r0
   40562:	f04f 0003 	mov.w	r0, #3
   40566:	df02      	svc	2
   40568:	e758      	b.n	4041c <isr_rx+0x58>
		radio_isr_set(isr_done, lll);
   4056a:	4810      	ldr	r0, [pc, #64]	; (405ac <isr_rx+0x1e8>)
   4056c:	4621      	mov	r1, r4
   4056e:	f001 fab9 	bl	41ae4 <radio_isr_set>
		radio_switch_complete_and_disable();
   40572:	f001 fcad 	bl	41ed0 <radio_switch_complete_and_disable>
}

static inline struct pdu_adv *lll_adv_scan_rsp_curr_get(struct lll_adv *lll)
{
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.first];
   40576:	7e23      	ldrb	r3, [r4, #24]
   40578:	eb04 0383 	add.w	r3, r4, r3, lsl #2
		radio_pkt_tx_set(lll_adv_scan_rsp_curr_get(lll));
   4057c:	69d8      	ldr	r0, [r3, #28]
   4057e:	f001 fb81 	bl	41c84 <radio_pkt_tx_set>
		LL_ASSERT(!radio_is_ready());
   40582:	f001 fbc1 	bl	41d08 <radio_is_ready>
   40586:	b910      	cbnz	r0, 4058e <isr_rx+0x1ca>
}
   40588:	b008      	add	sp, #32
   4058a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		LL_ASSERT(!radio_is_ready());
   4058e:	4a09      	ldr	r2, [pc, #36]	; (405b4 <isr_rx+0x1f0>)
   40590:	4909      	ldr	r1, [pc, #36]	; (405b8 <isr_rx+0x1f4>)
   40592:	480a      	ldr	r0, [pc, #40]	; (405bc <isr_rx+0x1f8>)
   40594:	f44f 63bf 	mov.w	r3, #1528	; 0x5f8
   40598:	f008 fd74 	bl	49084 <assert_print>
   4059c:	4040      	eors	r0, r0
   4059e:	f380 8811 	msr	BASEPRI, r0
   405a2:	f04f 0003 	mov.w	r0, #3
   405a6:	df02      	svc	2
		if (!err) {
   405a8:	e7ee      	b.n	40588 <isr_rx+0x1c4>
   405aa:	bf00      	nop
   405ac:	0004016d 	.word	0x0004016d
   405b0:	0003fd91 	.word	0x0003fd91
   405b4:	00052b48 	.word	0x00052b48
   405b8:	00052b9c 	.word	0x00052b9c
   405bc:	0005214c 	.word	0x0005214c
   405c0:	00052b94 	.word	0x00052b94

000405c4 <common_prepare_cb>:
{
   405c4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	lll = p->param;
   405c8:	68c4      	ldr	r4, [r0, #12]
	if (unlikely(lll->is_stop ||
   405ca:	f994 3016 	ldrsb.w	r3, [r4, #22]
   405ce:	2b00      	cmp	r3, #0
{
   405d0:	b08c      	sub	sp, #48	; 0x30
	if (unlikely(lll->is_stop ||
   405d2:	f2c0 80e4 	blt.w	4079e <common_prepare_cb+0x1da>
   405d6:	6863      	ldr	r3, [r4, #4]
   405d8:	4605      	mov	r5, r0
   405da:	460f      	mov	r7, r1
   405dc:	2b00      	cmp	r3, #0
   405de:	f040 80d3 	bne.w	40788 <common_prepare_cb+0x1c4>
	lll->state = 0U;
   405e2:	7da3      	ldrb	r3, [r4, #22]
   405e4:	f36f 0300 	bfc	r3, #0, #1
   405e8:	75a3      	strb	r3, [r4, #22]
	radio_reset();
   405ea:	f001 fabd 	bl	41b68 <radio_reset>
	radio_tx_power_set(RADIO_TXP_DEFAULT);
   405ee:	2000      	movs	r0, #0
   405f0:	f001 fae6 	bl	41bc0 <radio_tx_power_set>
	radio_phy_set(0, 0);
   405f4:	2100      	movs	r1, #0
   405f6:	4608      	mov	r0, r1
   405f8:	f001 fad2 	bl	41ba0 <radio_phy_set>
	radio_pkt_configure(RADIO_PKT_CONF_LENGTH_8BIT, PDU_AC_LEG_PAYLOAD_SIZE_MAX,
   405fc:	2200      	movs	r2, #0
   405fe:	2125      	movs	r1, #37	; 0x25
   40600:	2008      	movs	r0, #8
   40602:	f001 fb13 	bl	41c2c <radio_pkt_configure>
	node_rx = ull_pdu_rx_alloc_peek(1);
   40606:	2001      	movs	r0, #1
   40608:	f7f7 fd40 	bl	3808c <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
   4060c:	4606      	mov	r6, r0
   4060e:	2800      	cmp	r0, #0
   40610:	f000 80ac 	beq.w	4076c <common_prepare_cb+0x1a8>
	radio_pkt_rx_set(node_rx->pdu);
   40614:	f106 001c 	add.w	r0, r6, #28
   40618:	f001 fb2e 	bl	41c78 <radio_pkt_rx_set>
	aa = sys_cpu_to_le32(PDU_AC_ACCESS_ADDR);
   4061c:	4b65      	ldr	r3, [pc, #404]	; (407b4 <common_prepare_cb+0x1f0>)
   4061e:	930b      	str	r3, [sp, #44]	; 0x2c
	radio_aa_set((uint8_t *)&aa);
   40620:	a80b      	add	r0, sp, #44	; 0x2c
   40622:	f001 faeb 	bl	41bfc <radio_aa_set>
	radio_crc_configure(PDU_CRC_POLYNOMIAL,
   40626:	4964      	ldr	r1, [pc, #400]	; (407b8 <common_prepare_cb+0x1f4>)
   40628:	f240 605b 	movw	r0, #1627	; 0x65b
   4062c:	f001 fb8a 	bl	41d44 <radio_crc_configure>
	lll_chan_set(37 + lll->chan);
   40630:	7da0      	ldrb	r0, [r4, #22]
   40632:	f3c0 0041 	ubfx	r0, r0, #1, #2
   40636:	3025      	adds	r0, #37	; 0x25
   40638:	f7ff f8d6 	bl	3f7e8 <lll_chan_set>
	radio_isr_set(isr_rx, lll);
   4063c:	485f      	ldr	r0, [pc, #380]	; (407bc <common_prepare_cb+0x1f8>)
   4063e:	4621      	mov	r1, r4
   40640:	f001 fa50 	bl	41ae4 <radio_isr_set>
	} else if (lll->type ||
   40644:	7da3      	ldrb	r3, [r4, #22]
   40646:	069b      	lsls	r3, r3, #26
   40648:	d402      	bmi.n	40650 <common_prepare_cb+0x8c>
		   lll->conn) {
   4064a:	6863      	ldr	r3, [r4, #4]
	} else if (lll->type ||
   4064c:	2b00      	cmp	r3, #0
   4064e:	d067      	beq.n	40720 <common_prepare_cb+0x15c>
		radio_tmr_tifs_set(EVENT_IFS_US);
   40650:	2096      	movs	r0, #150	; 0x96
   40652:	f001 fca1 	bl	41f98 <radio_tmr_tifs_set>
		radio_switch_complete_and_tx(0, 0, 0, 0);
   40656:	2300      	movs	r3, #0
   40658:	461a      	mov	r2, r3
   4065a:	4619      	mov	r1, r3
   4065c:	4618      	mov	r0, r3
   4065e:	f001 fbd7 	bl	41e10 <radio_switch_complete_and_tx>
	ull = HDR_LLL2ULL(lll);
   40662:	f8d4 8000 	ldr.w	r8, [r4]
	ticks_at_event = p->ticks_at_expire;
   40666:	682e      	ldr	r6, [r5, #0]
	ticks_at_event += lll_event_offset_get(ull);
   40668:	4640      	mov	r0, r8
   4066a:	f7ff f89f 	bl	3f7ac <lll_event_offset_get>
   4066e:	4406      	add	r6, r0
	remainder_us = radio_tmr_start(0, ticks_at_start, remainder);
   40670:	686a      	ldr	r2, [r5, #4]
   40672:	f106 0118 	add.w	r1, r6, #24
   40676:	2000      	movs	r0, #0
   40678:	f001 fc9a 	bl	41fb0 <radio_tmr_start>
	radio_tmr_end_capture();
   4067c:	f001 fd98 	bl	421b0 <radio_tmr_end_capture>
	radio_rssi_measure();
   40680:	f001 fc36 	bl	41ef0 <radio_rssi_measure>
				   ull_scan_lll_handle_get(lll)),
   40684:	4620      	mov	r0, r4
   40686:	f7f8 fe3b 	bl	39300 <ull_scan_lll_handle_get>
	if (lll_preempt_calc(ull, (TICKER_ID_SCAN_BASE +
   4068a:	1d01      	adds	r1, r0, #4
   4068c:	b2c9      	uxtb	r1, r1
   4068e:	4640      	mov	r0, r8
   40690:	4632      	mov	r2, r6
   40692:	f7ff f899 	bl	3f7c8 <lll_preempt_calc>
   40696:	b9a8      	cbnz	r0, 406c4 <common_prepare_cb+0x100>
		if (!is_resume && lll->ticks_window) {
   40698:	b917      	cbnz	r7, 406a0 <common_prepare_cb+0xdc>
   4069a:	6a23      	ldr	r3, [r4, #32]
   4069c:	2b00      	cmp	r3, #0
   4069e:	d142      	bne.n	40726 <common_prepare_cb+0x162>
		if (lll->conn) {
   406a0:	6863      	ldr	r3, [r4, #4]
   406a2:	b13b      	cbz	r3, 406b4 <common_prepare_cb+0xf0>
			mfy_after_cen_offset_get.param = p;
   406a4:	4b46      	ldr	r3, [pc, #280]	; (407c0 <common_prepare_cb+0x1fc>)
			retval = mayfly_enqueue(TICKER_USER_ID_LLL,
   406a6:	2201      	movs	r2, #1
   406a8:	2102      	movs	r1, #2
   406aa:	2000      	movs	r0, #0
			mfy_after_cen_offset_get.param = p;
   406ac:	609d      	str	r5, [r3, #8]
			retval = mayfly_enqueue(TICKER_USER_ID_LLL,
   406ae:	f7f3 ffdf 	bl	34670 <mayfly_enqueue>
			LL_ASSERT(!retval);
   406b2:	bb10      	cbnz	r0, 406fa <common_prepare_cb+0x136>
		ret = lll_prepare_done(lll);
   406b4:	4620      	mov	r0, r4
   406b6:	f7ff f813 	bl	3f6e0 <lll_prepare_done>
		LL_ASSERT(!ret);
   406ba:	b968      	cbnz	r0, 406d8 <common_prepare_cb+0x114>
}
   406bc:	2000      	movs	r0, #0
   406be:	b00c      	add	sp, #48	; 0x30
   406c0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		radio_isr_set(isr_abort, lll);
   406c4:	483f      	ldr	r0, [pc, #252]	; (407c4 <common_prepare_cb+0x200>)
   406c6:	4621      	mov	r1, r4
   406c8:	f001 fa0c 	bl	41ae4 <radio_isr_set>
		radio_disable();
   406cc:	f001 fafc 	bl	41cc8 <radio_disable>
}
   406d0:	2000      	movs	r0, #0
   406d2:	b00c      	add	sp, #48	; 0x30
   406d4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		LL_ASSERT(!ret);
   406d8:	4a3b      	ldr	r2, [pc, #236]	; (407c8 <common_prepare_cb+0x204>)
   406da:	493c      	ldr	r1, [pc, #240]	; (407cc <common_prepare_cb+0x208>)
   406dc:	483c      	ldr	r0, [pc, #240]	; (407d0 <common_prepare_cb+0x20c>)
   406de:	f240 2315 	movw	r3, #533	; 0x215
   406e2:	f008 fccf 	bl	49084 <assert_print>
   406e6:	4040      	eors	r0, r0
   406e8:	f380 8811 	msr	BASEPRI, r0
   406ec:	f04f 0003 	mov.w	r0, #3
   406f0:	df02      	svc	2
}
   406f2:	2000      	movs	r0, #0
   406f4:	b00c      	add	sp, #48	; 0x30
   406f6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			LL_ASSERT(!retval);
   406fa:	4a33      	ldr	r2, [pc, #204]	; (407c8 <common_prepare_cb+0x204>)
   406fc:	4935      	ldr	r1, [pc, #212]	; (407d4 <common_prepare_cb+0x210>)
   406fe:	4834      	ldr	r0, [pc, #208]	; (407d0 <common_prepare_cb+0x20c>)
   40700:	f44f 7304 	mov.w	r3, #528	; 0x210
   40704:	f008 fcbe 	bl	49084 <assert_print>
   40708:	4040      	eors	r0, r0
   4070a:	f380 8811 	msr	BASEPRI, r0
   4070e:	f04f 0003 	mov.w	r0, #3
   40712:	df02      	svc	2
		ret = lll_prepare_done(lll);
   40714:	4620      	mov	r0, r4
   40716:	f7fe ffe3 	bl	3f6e0 <lll_prepare_done>
		LL_ASSERT(!ret);
   4071a:	2800      	cmp	r0, #0
   4071c:	d0ce      	beq.n	406bc <common_prepare_cb+0xf8>
   4071e:	e7db      	b.n	406d8 <common_prepare_cb+0x114>
		radio_switch_complete_and_disable();
   40720:	f001 fbd6 	bl	41ed0 <radio_switch_complete_and_disable>
   40724:	e79d      	b.n	40662 <common_prepare_cb+0x9e>
			ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
   40726:	4a2c      	ldr	r2, [pc, #176]	; (407d8 <common_prepare_cb+0x214>)
   40728:	9207      	str	r2, [sp, #28]
   4072a:	4a2c      	ldr	r2, [pc, #176]	; (407dc <common_prepare_cb+0x218>)
   4072c:	9205      	str	r2, [sp, #20]
   4072e:	f240 12fb 	movw	r2, #507	; 0x1fb
   40732:	9300      	str	r3, [sp, #0]
   40734:	9208      	str	r2, [sp, #32]
   40736:	4633      	mov	r3, r6
   40738:	e9cd 7703 	strd	r7, r7, [sp, #12]
   4073c:	e9cd 7701 	strd	r7, r7, [sp, #4]
   40740:	9406      	str	r4, [sp, #24]
   40742:	4639      	mov	r1, r7
   40744:	2203      	movs	r2, #3
   40746:	f7f5 f92d 	bl	359a4 <ticker_start>
			LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
   4074a:	f030 0302 	bics.w	r3, r0, #2
   4074e:	d0a7      	beq.n	406a0 <common_prepare_cb+0xdc>
   40750:	4a1d      	ldr	r2, [pc, #116]	; (407c8 <common_prepare_cb+0x204>)
   40752:	4923      	ldr	r1, [pc, #140]	; (407e0 <common_prepare_cb+0x21c>)
   40754:	481e      	ldr	r0, [pc, #120]	; (407d0 <common_prepare_cb+0x20c>)
   40756:	f44f 73fe 	mov.w	r3, #508	; 0x1fc
   4075a:	f008 fc93 	bl	49084 <assert_print>
   4075e:	4040      	eors	r0, r0
   40760:	f380 8811 	msr	BASEPRI, r0
   40764:	f04f 0003 	mov.w	r0, #3
   40768:	df02      	svc	2
   4076a:	e799      	b.n	406a0 <common_prepare_cb+0xdc>
	LL_ASSERT(node_rx);
   4076c:	4a16      	ldr	r2, [pc, #88]	; (407c8 <common_prepare_cb+0x204>)
   4076e:	491d      	ldr	r1, [pc, #116]	; (407e4 <common_prepare_cb+0x220>)
   40770:	4817      	ldr	r0, [pc, #92]	; (407d0 <common_prepare_cb+0x20c>)
   40772:	f44f 73c7 	mov.w	r3, #398	; 0x18e
   40776:	f008 fc85 	bl	49084 <assert_print>
   4077a:	4040      	eors	r0, r0
   4077c:	f380 8811 	msr	BASEPRI, r0
   40780:	f04f 0003 	mov.w	r0, #3
   40784:	df02      	svc	2
   40786:	e745      	b.n	40614 <common_prepare_cb+0x50>
	if (unlikely(lll->is_stop ||
   40788:	6863      	ldr	r3, [r4, #4]
   4078a:	f893 3020 	ldrb.w	r3, [r3, #32]
   4078e:	07d9      	lsls	r1, r3, #31
   40790:	d405      	bmi.n	4079e <common_prepare_cb+0x1da>
   40792:	6863      	ldr	r3, [r4, #4]
   40794:	f893 3020 	ldrb.w	r3, [r3, #32]
   40798:	079a      	lsls	r2, r3, #30
   4079a:	f57f af22 	bpl.w	405e2 <common_prepare_cb+0x1e>
		radio_isr_set(lll_isr_early_abort, lll);
   4079e:	4812      	ldr	r0, [pc, #72]	; (407e8 <common_prepare_cb+0x224>)
   407a0:	4621      	mov	r1, r4
   407a2:	f001 f99f 	bl	41ae4 <radio_isr_set>
		radio_disable();
   407a6:	f001 fa8f 	bl	41cc8 <radio_disable>
}
   407aa:	2000      	movs	r0, #0
   407ac:	b00c      	add	sp, #48	; 0x30
   407ae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   407b2:	bf00      	nop
   407b4:	8e89bed6 	.word	0x8e89bed6
   407b8:	00555555 	.word	0x00555555
   407bc:	00028529 	.word	0x00028529
   407c0:	20000cc8 	.word	0x20000cc8
   407c4:	00040875 	.word	0x00040875
   407c8:	00052be0 	.word	0x00052be0
   407cc:	00052430 	.word	0x00052430
   407d0:	0005214c 	.word	0x0005214c
   407d4:	00052458 	.word	0x00052458
   407d8:	00040971 	.word	0x00040971
   407dc:	00040a11 	.word	0x00040a11
   407e0:	00052504 	.word	0x00052504
   407e4:	00052b94 	.word	0x00052b94
   407e8:	0003f945 	.word	0x0003f945

000407ec <prepare_cb>:
	return common_prepare_cb(p, false);
   407ec:	2100      	movs	r1, #0
   407ee:	f7ff bee9 	b.w	405c4 <common_prepare_cb>
   407f2:	bf00      	nop

000407f4 <isr_common_done>:
{
   407f4:	b538      	push	{r3, r4, r5, lr}
   407f6:	4604      	mov	r4, r0
	lll_isr_status_reset();
   407f8:	f7ff f84e 	bl	3f898 <lll_isr_status_reset>
	lll->state = 0U;
   407fc:	7da3      	ldrb	r3, [r4, #22]
   407fe:	f36f 0300 	bfc	r3, #0, #1
   40802:	75a3      	strb	r3, [r4, #22]
	} else if (lll->type ||
   40804:	069b      	lsls	r3, r3, #26
   40806:	d401      	bmi.n	4080c <isr_common_done+0x18>
		   lll->conn) {
   40808:	6863      	ldr	r3, [r4, #4]
	} else if (lll->type ||
   4080a:	b33b      	cbz	r3, 4085c <isr_common_done+0x68>
		radio_tmr_tifs_set(EVENT_IFS_US);
   4080c:	2096      	movs	r0, #150	; 0x96
   4080e:	f001 fbc3 	bl	41f98 <radio_tmr_tifs_set>
		radio_switch_complete_and_tx(0, 0, 0, 0);
   40812:	2300      	movs	r3, #0
   40814:	461a      	mov	r2, r3
   40816:	4619      	mov	r1, r3
   40818:	4618      	mov	r0, r3
   4081a:	f001 faf9 	bl	41e10 <radio_switch_complete_and_tx>
	node_rx = ull_pdu_rx_alloc_peek(1);
   4081e:	2001      	movs	r0, #1
   40820:	f7f7 fc34 	bl	3808c <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
   40824:	4605      	mov	r5, r0
   40826:	b158      	cbz	r0, 40840 <isr_common_done+0x4c>
	radio_pkt_rx_set(node_rx->pdu);
   40828:	f105 001c 	add.w	r0, r5, #28
   4082c:	f001 fa24 	bl	41c78 <radio_pkt_rx_set>
	radio_rssi_measure();
   40830:	f001 fb5e 	bl	41ef0 <radio_rssi_measure>
	radio_isr_set(isr_rx, param);
   40834:	4621      	mov	r1, r4
   40836:	480b      	ldr	r0, [pc, #44]	; (40864 <isr_common_done+0x70>)
}
   40838:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	radio_isr_set(isr_rx, param);
   4083c:	f001 b952 	b.w	41ae4 <radio_isr_set>
	LL_ASSERT(node_rx);
   40840:	4a09      	ldr	r2, [pc, #36]	; (40868 <isr_common_done+0x74>)
   40842:	490a      	ldr	r1, [pc, #40]	; (4086c <isr_common_done+0x78>)
   40844:	480a      	ldr	r0, [pc, #40]	; (40870 <isr_common_done+0x7c>)
   40846:	f240 3363 	movw	r3, #867	; 0x363
   4084a:	f008 fc1b 	bl	49084 <assert_print>
   4084e:	4040      	eors	r0, r0
   40850:	f380 8811 	msr	BASEPRI, r0
   40854:	f04f 0003 	mov.w	r0, #3
   40858:	df02      	svc	2
   4085a:	e7e5      	b.n	40828 <isr_common_done+0x34>
		radio_switch_complete_and_disable();
   4085c:	f001 fb38 	bl	41ed0 <radio_switch_complete_and_disable>
   40860:	e7dd      	b.n	4081e <isr_common_done+0x2a>
   40862:	bf00      	nop
   40864:	00028529 	.word	0x00028529
   40868:	00052be0 	.word	0x00052be0
   4086c:	00052b94 	.word	0x00052b94
   40870:	0005214c 	.word	0x0005214c

00040874 <isr_abort>:
{
   40874:	b510      	push	{r4, lr}
   40876:	4604      	mov	r4, r0
	lll_isr_status_reset();
   40878:	f7ff f80e 	bl	3f898 <lll_isr_status_reset>
	radio_filter_disable();
   4087c:	f001 fb5a 	bl	41f34 <radio_filter_disable>
	lll_isr_cleanup(param);
   40880:	4620      	mov	r0, r4
}
   40882:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lll_isr_cleanup(param);
   40886:	f7ff b813 	b.w	3f8b0 <lll_isr_cleanup>
   4088a:	bf00      	nop

0004088c <isr_done>:
{
   4088c:	b508      	push	{r3, lr}
	isr_common_done(param);
   4088e:	f7ff ffb1 	bl	407f4 <isr_common_done>
	radio_rx_enable();
   40892:	f001 fa0d 	bl	41cb0 <radio_rx_enable>
}
   40896:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	radio_tmr_end_capture();
   4089a:	f001 bc89 	b.w	421b0 <radio_tmr_end_capture>
   4089e:	bf00      	nop

000408a0 <isr_tx>:
{
   408a0:	b570      	push	{r4, r5, r6, lr}
   408a2:	4605      	mov	r5, r0
	lll_isr_tx_status_reset();
   408a4:	f7fe ffe6 	bl	3f874 <lll_isr_tx_status_reset>
	radio_switch_complete_and_disable();
   408a8:	f001 fb12 	bl	41ed0 <radio_switch_complete_and_disable>
	node_rx = ull_pdu_rx_alloc_peek(1);
   408ac:	2001      	movs	r0, #1
   408ae:	f7f7 fbed 	bl	3808c <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
   408b2:	4604      	mov	r4, r0
   408b4:	b368      	cbz	r0, 40912 <isr_tx+0x72>
	radio_pkt_rx_set(node_rx->pdu);
   408b6:	f104 001c 	add.w	r0, r4, #28
   408ba:	f001 f9dd 	bl	41c78 <radio_pkt_rx_set>
	LL_ASSERT(!radio_is_ready());
   408be:	f001 fa23 	bl	41d08 <radio_is_ready>
   408c2:	b9c0      	cbnz	r0, 408f6 <isr_tx+0x56>
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 + 1;
   408c4:	f001 fc82 	bl	421cc <radio_tmr_tifs_base_get>
	hcto += radio_rx_chain_delay_get(0, 0);
   408c8:	2100      	movs	r1, #0
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 + 1;
   408ca:	4604      	mov	r4, r0
	hcto += radio_rx_chain_delay_get(0, 0);
   408cc:	4608      	mov	r0, r1
   408ce:	f001 f9e9 	bl	41ca4 <radio_rx_chain_delay_get>
	hcto -= radio_tx_chain_delay_get(0, 0);
   408d2:	2100      	movs	r1, #0
	hcto += radio_rx_chain_delay_get(0, 0);
   408d4:	4606      	mov	r6, r0
	hcto -= radio_tx_chain_delay_get(0, 0);
   408d6:	4608      	mov	r0, r1
   408d8:	f001 f9e0 	bl	41c9c <radio_tx_chain_delay_get>
   408dc:	4434      	add	r4, r6
   408de:	34c3      	adds	r4, #195	; 0xc3
	radio_tmr_hcto_configure(hcto);
   408e0:	1a20      	subs	r0, r4, r0
   408e2:	f001 fc2b 	bl	4213c <radio_tmr_hcto_configure>
	radio_rssi_measure();
   408e6:	f001 fb03 	bl	41ef0 <radio_rssi_measure>
	radio_isr_set(isr_rx, param);
   408ea:	4629      	mov	r1, r5
   408ec:	4810      	ldr	r0, [pc, #64]	; (40930 <isr_tx+0x90>)
}
   408ee:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	radio_isr_set(isr_rx, param);
   408f2:	f001 b8f7 	b.w	41ae4 <radio_isr_set>
	LL_ASSERT(!radio_is_ready());
   408f6:	4a0f      	ldr	r2, [pc, #60]	; (40934 <isr_tx+0x94>)
   408f8:	490f      	ldr	r1, [pc, #60]	; (40938 <isr_tx+0x98>)
   408fa:	4810      	ldr	r0, [pc, #64]	; (4093c <isr_tx+0x9c>)
   408fc:	f44f 7348 	mov.w	r3, #800	; 0x320
   40900:	f008 fbc0 	bl	49084 <assert_print>
   40904:	4040      	eors	r0, r0
   40906:	f380 8811 	msr	BASEPRI, r0
   4090a:	f04f 0003 	mov.w	r0, #3
   4090e:	df02      	svc	2
   40910:	e7d8      	b.n	408c4 <isr_tx+0x24>
	LL_ASSERT(node_rx);
   40912:	4a08      	ldr	r2, [pc, #32]	; (40934 <isr_tx+0x94>)
   40914:	490a      	ldr	r1, [pc, #40]	; (40940 <isr_tx+0xa0>)
   40916:	4809      	ldr	r0, [pc, #36]	; (4093c <isr_tx+0x9c>)
   40918:	f44f 7347 	mov.w	r3, #796	; 0x31c
   4091c:	f008 fbb2 	bl	49084 <assert_print>
   40920:	4040      	eors	r0, r0
   40922:	f380 8811 	msr	BASEPRI, r0
   40926:	f04f 0003 	mov.w	r0, #3
   4092a:	df02      	svc	2
   4092c:	e7c3      	b.n	408b6 <isr_tx+0x16>
   4092e:	bf00      	nop
   40930:	00028529 	.word	0x00028529
   40934:	00052be0 	.word	0x00052be0
   40938:	00052b9c 	.word	0x00052b9c
   4093c:	0005214c 	.word	0x0005214c
   40940:	00052b94 	.word	0x00052b94

00040944 <resume_prepare_cb>:
{
   40944:	b570      	push	{r4, r5, r6, lr}
	ull = HDR_LLL2ULL(p->param);
   40946:	68c3      	ldr	r3, [r0, #12]
{
   40948:	4604      	mov	r4, r0
	ull = HDR_LLL2ULL(p->param);
   4094a:	681e      	ldr	r6, [r3, #0]
	p->ticks_at_expire = ticker_ticks_now_get() - lll_event_offset_get(ull);
   4094c:	f7f5 f956 	bl	35bfc <ticker_ticks_now_get>
   40950:	4605      	mov	r5, r0
   40952:	4630      	mov	r0, r6
   40954:	f7fe ff2a 	bl	3f7ac <lll_event_offset_get>
	p->remainder = 0;
   40958:	2300      	movs	r3, #0
	p->ticks_at_expire = ticker_ticks_now_get() - lll_event_offset_get(ull);
   4095a:	1a2d      	subs	r5, r5, r0
	p->remainder = 0;
   4095c:	e9c4 5300 	strd	r5, r3, [r4]
	p->lazy = 0;
   40960:	8123      	strh	r3, [r4, #8]
	return common_prepare_cb(p, true);
   40962:	4620      	mov	r0, r4
   40964:	2101      	movs	r1, #1
}
   40966:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return common_prepare_cb(p, true);
   4096a:	f7ff be2b 	b.w	405c4 <common_prepare_cb>
   4096e:	bf00      	nop

00040970 <ticker_op_start_cb>:
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
   40970:	b900      	cbnz	r0, 40974 <ticker_op_start_cb+0x4>
   40972:	4770      	bx	lr
{
   40974:	b508      	push	{r3, lr}
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
   40976:	4a07      	ldr	r2, [pc, #28]	; (40994 <ticker_op_start_cb+0x24>)
   40978:	4907      	ldr	r1, [pc, #28]	; (40998 <ticker_op_start_cb+0x28>)
   4097a:	4808      	ldr	r0, [pc, #32]	; (4099c <ticker_op_start_cb+0x2c>)
   4097c:	f240 239a 	movw	r3, #666	; 0x29a
   40980:	f008 fb80 	bl	49084 <assert_print>
   40984:	4040      	eors	r0, r0
   40986:	f380 8811 	msr	BASEPRI, r0
   4098a:	f04f 0003 	mov.w	r0, #3
   4098e:	df02      	svc	2
}
   40990:	bd08      	pop	{r3, pc}
   40992:	bf00      	nop
   40994:	00052be0 	.word	0x00052be0
   40998:	000526fc 	.word	0x000526fc
   4099c:	0005214c 	.word	0x0005214c

000409a0 <is_abort_cb>:
{
   409a0:	b508      	push	{r3, lr}
	if (lll->conn && lll->conn->central.initiated) {
   409a2:	684b      	ldr	r3, [r1, #4]
   409a4:	b123      	cbz	r3, 409b0 <is_abort_cb+0x10>
   409a6:	684b      	ldr	r3, [r1, #4]
   409a8:	f893 3020 	ldrb.w	r3, [r3, #32]
   409ac:	07db      	lsls	r3, r3, #31
   409ae:	d414      	bmi.n	409da <is_abort_cb+0x3a>
	if (next != curr) {
   409b0:	4281      	cmp	r1, r0
   409b2:	d00d      	beq.n	409d0 <is_abort_cb+0x30>
			if (!lll->ticks_window) {
   409b4:	6a0b      	ldr	r3, [r1, #32]
   409b6:	b113      	cbz	r3, 409be <is_abort_cb+0x1e>
			return -ECANCELED;
   409b8:	f06f 008b 	mvn.w	r0, #139	; 0x8b
}
   409bc:	bd08      	pop	{r3, pc}
				*resume_cb = resume_prepare_cb;
   409be:	4b0f      	ldr	r3, [pc, #60]	; (409fc <is_abort_cb+0x5c>)
   409c0:	6013      	str	r3, [r2, #0]
				err = lll_hfclock_on();
   409c2:	f7ff f90d 	bl	3fbe0 <lll_hfclock_on>
				LL_ASSERT(err >= 0);
   409c6:	2800      	cmp	r0, #0
   409c8:	db09      	blt.n	409de <is_abort_cb+0x3e>
		return 0;
   409ca:	f06f 000a 	mvn.w	r0, #10
}
   409ce:	bd08      	pop	{r3, pc}
		radio_isr_set(isr_window, lll);
   409d0:	480b      	ldr	r0, [pc, #44]	; (40a00 <is_abort_cb+0x60>)
   409d2:	f001 f887 	bl	41ae4 <radio_isr_set>
	radio_disable();
   409d6:	f001 f977 	bl	41cc8 <radio_disable>
		return 0;
   409da:	2000      	movs	r0, #0
}
   409dc:	bd08      	pop	{r3, pc}
				LL_ASSERT(err >= 0);
   409de:	4a09      	ldr	r2, [pc, #36]	; (40a04 <is_abort_cb+0x64>)
   409e0:	4909      	ldr	r1, [pc, #36]	; (40a08 <is_abort_cb+0x68>)
   409e2:	480a      	ldr	r0, [pc, #40]	; (40a0c <is_abort_cb+0x6c>)
   409e4:	f240 233f 	movw	r3, #575	; 0x23f
   409e8:	f008 fb4c 	bl	49084 <assert_print>
   409ec:	4040      	eors	r0, r0
   409ee:	f380 8811 	msr	BASEPRI, r0
   409f2:	f04f 0003 	mov.w	r0, #3
   409f6:	df02      	svc	2
   409f8:	e7e7      	b.n	409ca <is_abort_cb+0x2a>
   409fa:	bf00      	nop
   409fc:	00040945 	.word	0x00040945
   40a00:	00028489 	.word	0x00028489
   40a04:	00052be0 	.word	0x00052be0
   40a08:	00052af8 	.word	0x00052af8
   40a0c:	0005214c 	.word	0x0005214c

00040a10 <ticker_stop_cb>:
{
   40a10:	b508      	push	{r3, lr}
	mfy.param = param;
   40a12:	4b0c      	ldr	r3, [pc, #48]	; (40a44 <ticker_stop_cb+0x34>)
{
   40a14:	9803      	ldr	r0, [sp, #12]
	mfy.param = param;
   40a16:	6098      	str	r0, [r3, #8]
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL, 0,
   40a18:	2200      	movs	r2, #0
   40a1a:	4611      	mov	r1, r2
   40a1c:	2001      	movs	r0, #1
   40a1e:	f7f3 fe27 	bl	34670 <mayfly_enqueue>
	LL_ASSERT(!ret);
   40a22:	b900      	cbnz	r0, 40a26 <ticker_stop_cb+0x16>
}
   40a24:	bd08      	pop	{r3, pc}
	LL_ASSERT(!ret);
   40a26:	4a08      	ldr	r2, [pc, #32]	; (40a48 <ticker_stop_cb+0x38>)
   40a28:	4908      	ldr	r1, [pc, #32]	; (40a4c <ticker_stop_cb+0x3c>)
   40a2a:	4809      	ldr	r0, [pc, #36]	; (40a50 <ticker_stop_cb+0x40>)
   40a2c:	f240 2393 	movw	r3, #659	; 0x293
   40a30:	f008 fb28 	bl	49084 <assert_print>
   40a34:	4040      	eors	r0, r0
   40a36:	f380 8811 	msr	BASEPRI, r0
   40a3a:	f04f 0003 	mov.w	r0, #3
   40a3e:	df02      	svc	2
}
   40a40:	bd08      	pop	{r3, pc}
   40a42:	bf00      	nop
   40a44:	20000cb8 	.word	0x20000cb8
   40a48:	00052be0 	.word	0x00052be0
   40a4c:	00052430 	.word	0x00052430
   40a50:	0005214c 	.word	0x0005214c

00040a54 <isr_done_cleanup>:
{
   40a54:	b530      	push	{r4, r5, lr}
   40a56:	4604      	mov	r4, r0
   40a58:	b085      	sub	sp, #20
	lll_isr_status_reset();
   40a5a:	f7fe ff1d 	bl	3f898 <lll_isr_status_reset>
	if (lll_is_done(param, &is_resume)) {
   40a5e:	f10d 010f 	add.w	r1, sp, #15
   40a62:	4620      	mov	r0, r4
   40a64:	f7fe fe90 	bl	3f788 <lll_is_done>
   40a68:	b9c0      	cbnz	r0, 40a9c <isr_done_cleanup+0x48>
	radio_filter_disable();
   40a6a:	4605      	mov	r5, r0
   40a6c:	f001 fa62 	bl	41f34 <radio_filter_disable>
	if (++lll->chan == ADV_CHAN_MAX) {
   40a70:	7da2      	ldrb	r2, [r4, #22]
	ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_LLL,
   40a72:	9500      	str	r5, [sp, #0]
	if (++lll->chan == ADV_CHAN_MAX) {
   40a74:	f3c2 0341 	ubfx	r3, r2, #1, #2
   40a78:	3301      	adds	r3, #1
   40a7a:	f003 0303 	and.w	r3, r3, #3
		lll->chan = 0U;
   40a7e:	2b03      	cmp	r3, #3
   40a80:	bf08      	it	eq
   40a82:	2300      	moveq	r3, #0
   40a84:	f363 0242 	bfi	r2, r3, #1, #2
   40a88:	75a2      	strb	r2, [r4, #22]
	ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_LLL,
   40a8a:	462b      	mov	r3, r5
   40a8c:	2203      	movs	r2, #3
   40a8e:	4629      	mov	r1, r5
   40a90:	4628      	mov	r0, r5
   40a92:	f7f5 f813 	bl	35abc <ticker_stop>
	lll_isr_cleanup(param);
   40a96:	4620      	mov	r0, r4
   40a98:	f7fe ff0a 	bl	3f8b0 <lll_isr_cleanup>
}
   40a9c:	b005      	add	sp, #20
   40a9e:	bd30      	pop	{r4, r5, pc}

00040aa0 <abort_cb>:
{
   40aa0:	b510      	push	{r4, lr}
	if (!prepare_param) {
   40aa2:	b1d8      	cbz	r0, 40adc <abort_cb+0x3c>
	err = lll_hfclock_off();
   40aa4:	460c      	mov	r4, r1
   40aa6:	f7ff f8b3 	bl	3fc10 <lll_hfclock_off>
	LL_ASSERT(err >= 0);
   40aaa:	2800      	cmp	r0, #0
   40aac:	db04      	blt.n	40ab8 <abort_cb+0x18>
	lll_done(param);
   40aae:	4620      	mov	r0, r4
}
   40ab0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lll_done(param);
   40ab4:	f7fe be16 	b.w	3f6e4 <lll_done>
	LL_ASSERT(err >= 0);
   40ab8:	4a0c      	ldr	r2, [pc, #48]	; (40aec <abort_cb+0x4c>)
   40aba:	490d      	ldr	r1, [pc, #52]	; (40af0 <abort_cb+0x50>)
   40abc:	480d      	ldr	r0, [pc, #52]	; (40af4 <abort_cb+0x54>)
   40abe:	f240 2383 	movw	r3, #643	; 0x283
   40ac2:	f008 fadf 	bl	49084 <assert_print>
   40ac6:	4040      	eors	r0, r0
   40ac8:	f380 8811 	msr	BASEPRI, r0
   40acc:	f04f 0003 	mov.w	r0, #3
   40ad0:	df02      	svc	2
	lll_done(param);
   40ad2:	4620      	mov	r0, r4
}
   40ad4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lll_done(param);
   40ad8:	f7fe be04 	b.w	3f6e4 <lll_done>
			radio_isr_set(isr_done_cleanup, param);
   40adc:	4806      	ldr	r0, [pc, #24]	; (40af8 <abort_cb+0x58>)
   40ade:	f001 f801 	bl	41ae4 <radio_isr_set>
}
   40ae2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			radio_disable();
   40ae6:	f001 b8ef 	b.w	41cc8 <radio_disable>
   40aea:	bf00      	nop
   40aec:	00052be0 	.word	0x00052be0
   40af0:	00052af8 	.word	0x00052af8
   40af4:	0005214c 	.word	0x0005214c
   40af8:	00040a55 	.word	0x00040a55

00040afc <lll_scan_init>:
}
   40afc:	2000      	movs	r0, #0
   40afe:	4770      	bx	lr

00040b00 <lll_scan_reset>:
int lll_scan_reset(void)
   40b00:	2000      	movs	r0, #0
   40b02:	4770      	bx	lr

00040b04 <lll_scan_prepare>:
{
   40b04:	b510      	push	{r4, lr}
   40b06:	b082      	sub	sp, #8
   40b08:	4604      	mov	r4, r0
	err = lll_hfclock_on();
   40b0a:	f7ff f869 	bl	3fbe0 <lll_hfclock_on>
	LL_ASSERT(err >= 0);
   40b0e:	2800      	cmp	r0, #0
   40b10:	db19      	blt.n	40b46 <lll_scan_prepare+0x42>
	err = lll_prepare(is_abort_cb, abort_cb, prepare_cb, 0, param);
   40b12:	4a13      	ldr	r2, [pc, #76]	; (40b60 <lll_scan_prepare+0x5c>)
   40b14:	4913      	ldr	r1, [pc, #76]	; (40b64 <lll_scan_prepare+0x60>)
   40b16:	4814      	ldr	r0, [pc, #80]	; (40b68 <lll_scan_prepare+0x64>)
   40b18:	9400      	str	r4, [sp, #0]
   40b1a:	2300      	movs	r3, #0
   40b1c:	f7f7 fe0a 	bl	38734 <lll_prepare>
	LL_ASSERT(!err || err == -EINPROGRESS);
   40b20:	b108      	cbz	r0, 40b26 <lll_scan_prepare+0x22>
   40b22:	3077      	adds	r0, #119	; 0x77
   40b24:	d101      	bne.n	40b2a <lll_scan_prepare+0x26>
}
   40b26:	b002      	add	sp, #8
   40b28:	bd10      	pop	{r4, pc}
	LL_ASSERT(!err || err == -EINPROGRESS);
   40b2a:	4a10      	ldr	r2, [pc, #64]	; (40b6c <lll_scan_prepare+0x68>)
   40b2c:	4910      	ldr	r1, [pc, #64]	; (40b70 <lll_scan_prepare+0x6c>)
   40b2e:	4811      	ldr	r0, [pc, #68]	; (40b74 <lll_scan_prepare+0x70>)
   40b30:	238c      	movs	r3, #140	; 0x8c
   40b32:	f008 faa7 	bl	49084 <assert_print>
   40b36:	4040      	eors	r0, r0
   40b38:	f380 8811 	msr	BASEPRI, r0
   40b3c:	f04f 0003 	mov.w	r0, #3
   40b40:	df02      	svc	2
}
   40b42:	b002      	add	sp, #8
   40b44:	bd10      	pop	{r4, pc}
	LL_ASSERT(err >= 0);
   40b46:	4a09      	ldr	r2, [pc, #36]	; (40b6c <lll_scan_prepare+0x68>)
   40b48:	490b      	ldr	r1, [pc, #44]	; (40b78 <lll_scan_prepare+0x74>)
   40b4a:	480a      	ldr	r0, [pc, #40]	; (40b74 <lll_scan_prepare+0x70>)
   40b4c:	2389      	movs	r3, #137	; 0x89
   40b4e:	f008 fa99 	bl	49084 <assert_print>
   40b52:	4040      	eors	r0, r0
   40b54:	f380 8811 	msr	BASEPRI, r0
   40b58:	f04f 0003 	mov.w	r0, #3
   40b5c:	df02      	svc	2
   40b5e:	e7d8      	b.n	40b12 <lll_scan_prepare+0xe>
   40b60:	000407ed 	.word	0x000407ed
   40b64:	00040aa1 	.word	0x00040aa1
   40b68:	000409a1 	.word	0x000409a1
   40b6c:	00052be0 	.word	0x00052be0
   40b70:	00052bcc 	.word	0x00052bcc
   40b74:	0005214c 	.word	0x0005214c
   40b78:	00052af8 	.word	0x00052af8

00040b7c <lll_scan_prepare_connect_req>:
{
   40b7c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   40b80:	f89d 501c 	ldrb.w	r5, [sp, #28]
	pdu_tx->type = PDU_ADV_TYPE_CONNECT_IND;
   40b84:	01ad      	lsls	r5, r5, #6
   40b86:	f005 0540 	and.w	r5, r5, #64	; 0x40
   40b8a:	f045 0525 	orr.w	r5, r5, #37	; 0x25
   40b8e:	ea45 15c3 	orr.w	r5, r5, r3, lsl #7
   40b92:	780b      	ldrb	r3, [r1, #0]
{
   40b94:	460c      	mov	r4, r1
	pdu_tx->type = PDU_ADV_TYPE_CONNECT_IND;
   40b96:	f003 0310 	and.w	r3, r3, #16
   40b9a:	432b      	orrs	r3, r5
	pdu_tx->len = sizeof(struct pdu_adv_connect_ind);
   40b9c:	2122      	movs	r1, #34	; 0x22
	lll_conn = lll->conn;
   40b9e:	6845      	ldr	r5, [r0, #4]
	pdu_tx->type = PDU_ADV_TYPE_CONNECT_IND;
   40ba0:	7023      	strb	r3, [r4, #0]
{
   40ba2:	4690      	mov	r8, r2
	pdu_tx->len = sizeof(struct pdu_adv_connect_ind);
   40ba4:	7061      	strb	r1, [r4, #1]
	memcpy(&pdu_tx->connect_ind.init_addr[0], init_addr, BDADDR_SIZE);
   40ba6:	2206      	movs	r2, #6
   40ba8:	9908      	ldr	r1, [sp, #32]
{
   40baa:	4606      	mov	r6, r0
	memcpy(&pdu_tx->connect_ind.init_addr[0], init_addr, BDADDR_SIZE);
   40bac:	1ca0      	adds	r0, r4, #2
   40bae:	f00a f964 	bl	4ae7a <memcpy>
	memcpy(&pdu_tx->connect_ind.adv_addr[0], adv_addr, BDADDR_SIZE);
   40bb2:	9906      	ldr	r1, [sp, #24]
   40bb4:	2206      	movs	r2, #6
   40bb6:	f104 0008 	add.w	r0, r4, #8
   40bba:	f00a f95e 	bl	4ae7a <memcpy>
	memcpy(&pdu_tx->connect_ind.access_addr[0],
   40bbe:	2204      	movs	r2, #4
   40bc0:	18a9      	adds	r1, r5, r2
   40bc2:	f104 000e 	add.w	r0, r4, #14
   40bc6:	f00a f958 	bl	4ae7a <memcpy>
	memcpy(&pdu_tx->connect_ind.crc_init[0], &lll_conn->crc_init[0], 3);
   40bca:	2203      	movs	r2, #3
   40bcc:	f105 0108 	add.w	r1, r5, #8
   40bd0:	f104 0012 	add.w	r0, r4, #18
   40bd4:	f00a f951 	bl	4ae7a <memcpy>
	pdu_tx->connect_ind.win_size = 1;
   40bd8:	2301      	movs	r3, #1
   40bda:	7563      	strb	r3, [r4, #21]
	conn_interval_us = (uint32_t)lll_conn->interval * CONN_INT_UNIT_US;
   40bdc:	89ef      	ldrh	r7, [r5, #14]
	conn_offset_us = radio_tmr_end_get() + EVENT_IFS_US +
   40bde:	f001 faef 	bl	421c0 <radio_tmr_end_get>
			 PDU_AC_MAX_US(sizeof(struct pdu_adv_connect_ind),
   40be2:	f1b8 0f00 	cmp.w	r8, #0
   40be6:	d044      	beq.n	40c72 <lll_scan_prepare_connect_req+0xf6>
   40be8:	f008 0303 	and.w	r3, r8, #3
   40bec:	332b      	adds	r3, #43	; 0x2b
   40bee:	00db      	lsls	r3, r3, #3
   40bf0:	f3c8 0840 	ubfx	r8, r8, #1, #1
   40bf4:	fa23 f308 	lsr.w	r3, r3, r8
		conn_offset_us += WIN_DELAY_LEGACY;
   40bf8:	f500 62af 	add.w	r2, r0, #1400	; 0x578
   40bfc:	441a      	add	r2, r3
	    lll->conn_win_offset_us == 0U) {
   40bfe:	6933      	ldr	r3, [r6, #16]
	if (!IS_ENABLED(CONFIG_BT_CTLR_SCHED_ADVANCED) ||
   40c00:	b393      	cbz	r3, 40c68 <lll_scan_prepare_connect_req+0xec>
	conn_interval_us = (uint32_t)lll_conn->interval * CONN_INT_UNIT_US;
   40c02:	f240 41e2 	movw	r1, #1250	; 0x4e2
   40c06:	fb01 f707 	mul.w	r7, r1, r7
		while ((win_offset_us & ((uint32_t)1 << 31)) ||
   40c0a:	2b00      	cmp	r3, #0
   40c0c:	db01      	blt.n	40c12 <lll_scan_prepare_connect_req+0x96>
   40c0e:	4293      	cmp	r3, r2
   40c10:	d201      	bcs.n	40c16 <lll_scan_prepare_connect_req+0x9a>
			win_offset_us += conn_interval_us;
   40c12:	443b      	add	r3, r7
   40c14:	e7f9      	b.n	40c0a <lll_scan_prepare_connect_req+0x8e>
		*conn_space_us = win_offset_us;
   40c16:	9909      	ldr	r1, [sp, #36]	; 0x24
   40c18:	600b      	str	r3, [r1, #0]
			sys_cpu_to_le16((win_offset_us - conn_offset_us) /
   40c1a:	1a9b      	subs	r3, r3, r2
   40c1c:	4a16      	ldr	r2, [pc, #88]	; (40c78 <lll_scan_prepare_connect_req+0xfc>)
   40c1e:	fba2 2303 	umull	r2, r3, r2, r3
		pdu_tx->connect_ind.win_size++;
   40c22:	7d62      	ldrb	r2, [r4, #21]
			sys_cpu_to_le16((win_offset_us - conn_offset_us) /
   40c24:	0a9b      	lsrs	r3, r3, #10
		pdu_tx->connect_ind.win_size++;
   40c26:	3201      	adds	r2, #1
		pdu_tx->connect_ind.win_offset =
   40c28:	82e3      	strh	r3, [r4, #22]
		pdu_tx->connect_ind.win_size++;
   40c2a:	7562      	strb	r2, [r4, #21]
	pdu_tx->connect_ind.interval = sys_cpu_to_le16(lll_conn->interval);
   40c2c:	89eb      	ldrh	r3, [r5, #14]
   40c2e:	8323      	strh	r3, [r4, #24]
	pdu_tx->connect_ind.latency = sys_cpu_to_le16(lll_conn->latency);
   40c30:	8a2b      	ldrh	r3, [r5, #16]
   40c32:	8363      	strh	r3, [r4, #26]
	pdu_tx->connect_ind.timeout = sys_cpu_to_le16(lll->conn_timeout);
   40c34:	8ab3      	ldrh	r3, [r6, #20]
   40c36:	83a3      	strh	r3, [r4, #28]
	memcpy(&pdu_tx->connect_ind.chan_map[0], &lll_conn->data_chan_map[0],
   40c38:	2205      	movs	r2, #5
   40c3a:	f105 0118 	add.w	r1, r5, #24
   40c3e:	f104 001e 	add.w	r0, r4, #30
   40c42:	f00a f91a 	bl	4ae7a <memcpy>
	pdu_tx->connect_ind.hop = lll_conn->data_chan_hop;
   40c46:	f894 3023 	ldrb.w	r3, [r4, #35]	; 0x23
   40c4a:	7faa      	ldrb	r2, [r5, #30]
   40c4c:	f362 0304 	bfi	r3, r2, #0, #5
   40c50:	f884 3023 	strb.w	r3, [r4, #35]	; 0x23
	pdu_tx->connect_ind.sca = lll_clock_sca_local_get();
   40c54:	f7fe fff8 	bl	3fc48 <lll_clock_sca_local_get>
   40c58:	f894 3023 	ldrb.w	r3, [r4, #35]	; 0x23
   40c5c:	f360 1347 	bfi	r3, r0, #5, #3
   40c60:	f884 3023 	strb.w	r3, [r4, #35]	; 0x23
}
   40c64:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		*conn_space_us = conn_offset_us;
   40c68:	9909      	ldr	r1, [sp, #36]	; 0x24
   40c6a:	600a      	str	r2, [r1, #0]
		pdu_tx->connect_ind.win_offset = sys_cpu_to_le16(0);
   40c6c:	75a3      	strb	r3, [r4, #22]
   40c6e:	75e3      	strb	r3, [r4, #23]
   40c70:	e7dc      	b.n	40c2c <lll_scan_prepare_connect_req+0xb0>
   40c72:	f44f 73b0 	mov.w	r3, #352	; 0x160
   40c76:	e7bf      	b.n	40bf8 <lll_scan_prepare_connect_req+0x7c>
   40c78:	d1b71759 	.word	0xd1b71759

00040c7c <isr_done>:
{
	return 0;
}

static void isr_done(void *param)
{
   40c7c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   40c7e:	4605      	mov	r5, r0
	struct event_done_extra *e;

	lll_isr_status_reset();
   40c80:	f7fe fe0a 	bl	3f898 <lll_isr_status_reset>

	e = ull_event_done_extra_get();
   40c84:	f7f7 fb16 	bl	382b4 <ull_event_done_extra_get>
	LL_ASSERT(e);
   40c88:	4604      	mov	r4, r0
   40c8a:	2800      	cmp	r0, #0
   40c8c:	d036      	beq.n	40cfc <isr_done+0x80>

	e->type = EVENT_DONE_EXTRA_TYPE_CONN;
	e->trx_cnt = trx_cnt;
	e->crc_valid = crc_valid;
   40c8e:	4922      	ldr	r1, [pc, #136]	; (40d18 <isr_done+0x9c>)
   40c90:	79a2      	ldrb	r2, [r4, #6]
   40c92:	7808      	ldrb	r0, [r1, #0]
	e->trx_cnt = trx_cnt;
   40c94:	4b21      	ldr	r3, [pc, #132]	; (40d1c <isr_done+0xa0>)
	e->crc_valid = crc_valid;
   40c96:	f360 0200 	bfi	r2, r0, #0, #1
   40c9a:	71a2      	strb	r2, [r4, #6]

#if defined(CONFIG_BT_CTLR_LE_ENC)
	e->mic_state = mic_state;
   40c9c:	4a20      	ldr	r2, [pc, #128]	; (40d20 <isr_done+0xa4>)
	e->trx_cnt = trx_cnt;
   40c9e:	881b      	ldrh	r3, [r3, #0]
	e->mic_state = mic_state;
   40ca0:	7812      	ldrb	r2, [r2, #0]
	e->trx_cnt = trx_cnt;
   40ca2:	80a3      	strh	r3, [r4, #4]
	e->type = EVENT_DONE_EXTRA_TYPE_CONN;
   40ca4:	2101      	movs	r1, #1
   40ca6:	7021      	strb	r1, [r4, #0]
	e->mic_state = mic_state;
   40ca8:	71e2      	strb	r2, [r4, #7]
#endif /* CONFIG_BT_CTLR_LE_ENC */

#if defined(CONFIG_BT_PERIPHERAL)
	if (trx_cnt) {
   40caa:	b11b      	cbz	r3, 40cb4 <isr_done+0x38>
		struct lll_conn *lll = param;

		if (lll->role) {
   40cac:	f995 301d 	ldrsb.w	r3, [r5, #29]
   40cb0:	2b00      	cmp	r3, #0
   40cb2:	db04      	blt.n	40cbe <isr_done+0x42>
			lll->periph.window_size_event_us = 0;
		}
	}
#endif /* CONFIG_BT_PERIPHERAL */

	lll_isr_cleanup(param);
   40cb4:	4628      	mov	r0, r5
}
   40cb6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	lll_isr_cleanup(param);
   40cba:	f7fe bdf9 	b.w	3f8b0 <lll_isr_cleanup>
				addr_us_get(lll->phy_rx);
   40cbe:	f895 3045 	ldrb.w	r3, [r5, #69]	; 0x45
   40cc2:	f003 0307 	and.w	r3, r3, #7
 */
#define HCTO_START_DELAY_US 1U

static inline uint32_t addr_us_get(uint8_t phy)
{
	switch (phy) {
   40cc6:	2b02      	cmp	r3, #2
   40cc8:	d016      	beq.n	40cf8 <isr_done+0x7c>
	default:
	case BIT(0):
		return 40;
   40cca:	2b04      	cmp	r3, #4
   40ccc:	bf0c      	ite	eq
   40cce:	f44f 77bc 	moveq.w	r7, #376	; 0x178
   40cd2:	2728      	movne	r7, #40	; 0x28
				radio_tmr_aa_restore() - radio_tmr_ready_get();
   40cd4:	f001 fa60 	bl	42198 <radio_tmr_aa_restore>
   40cd8:	4606      	mov	r6, r0
   40cda:	f001 fa63 	bl	421a4 <radio_tmr_ready_get>
   40cde:	1a36      	subs	r6, r6, r0
			e->drift.start_to_address_actual_us =
   40ce0:	60a6      	str	r6, [r4, #8]
				lll->periph.window_widening_event_us;
   40ce2:	6b2a      	ldr	r2, [r5, #48]	; 0x30
			e->drift.preamble_to_addr_us = preamble_to_addr_us;
   40ce4:	e9c4 2703 	strd	r2, r7, [r4, #12]
			lll->periph.window_widening_event_us = 0;
   40ce8:	2300      	movs	r3, #0
   40cea:	632b      	str	r3, [r5, #48]	; 0x30
			lll->periph.window_size_event_us = 0;
   40cec:	63ab      	str	r3, [r5, #56]	; 0x38
	lll_isr_cleanup(param);
   40cee:	4628      	mov	r0, r5
}
   40cf0:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	lll_isr_cleanup(param);
   40cf4:	f7fe bddc 	b.w	3f8b0 <lll_isr_cleanup>
	switch (phy) {
   40cf8:	2718      	movs	r7, #24
   40cfa:	e7eb      	b.n	40cd4 <isr_done+0x58>
	LL_ASSERT(e);
   40cfc:	4a09      	ldr	r2, [pc, #36]	; (40d24 <isr_done+0xa8>)
   40cfe:	490a      	ldr	r1, [pc, #40]	; (40d28 <isr_done+0xac>)
   40d00:	480a      	ldr	r0, [pc, #40]	; (40d2c <isr_done+0xb0>)
   40d02:	f240 3345 	movw	r3, #837	; 0x345
   40d06:	f008 f9bd 	bl	49084 <assert_print>
   40d0a:	4040      	eors	r0, r0
   40d0c:	f380 8811 	msr	BASEPRI, r0
   40d10:	f04f 0003 	mov.w	r0, #3
   40d14:	df02      	svc	2
   40d16:	e7ba      	b.n	40c8e <isr_done+0x12>
   40d18:	20006bb5 	.word	0x20006bb5
   40d1c:	20006a34 	.word	0x20006a34
   40d20:	20006bb4 	.word	0x20006bb4
   40d24:	00052c2c 	.word	0x00052c2c
   40d28:	00052530 	.word	0x00052530
   40d2c:	0005214c 	.word	0x0005214c

00040d30 <lll_conn_init>:
{
   40d30:	b508      	push	{r3, lr}

static void empty_tx_init(void)
{
	struct pdu_data *p;

	p = (void *)radio_pkt_empty_get();
   40d32:	f001 f81d 	bl	41d70 <radio_pkt_empty_get>
	p->ll_id = PDU_DATA_LLID_DATA_CONTINUE;
   40d36:	7802      	ldrb	r2, [r0, #0]
	p = (void *)radio_pkt_empty_get();
   40d38:	4603      	mov	r3, r0
	p->ll_id = PDU_DATA_LLID_DATA_CONTINUE;
   40d3a:	2101      	movs	r1, #1
   40d3c:	f361 0201 	bfi	r2, r1, #0, #2
   40d40:	701a      	strb	r2, [r3, #0]
}
   40d42:	2000      	movs	r0, #0
   40d44:	bd08      	pop	{r3, pc}
   40d46:	bf00      	nop

00040d48 <lll_conn_reset>:
}
   40d48:	2000      	movs	r0, #0
   40d4a:	4770      	bx	lr

00040d4c <lll_conn_flush>:
}
   40d4c:	4770      	bx	lr
   40d4e:	bf00      	nop

00040d50 <lll_conn_prepare_reset>:
{
   40d50:	b410      	push	{r4}
	crc_valid = 0U;
   40d52:	4805      	ldr	r0, [pc, #20]	; (40d68 <lll_conn_prepare_reset+0x18>)
	trx_cnt = 0U;
   40d54:	4c05      	ldr	r4, [pc, #20]	; (40d6c <lll_conn_prepare_reset+0x1c>)
	crc_expire = 0U;
   40d56:	4906      	ldr	r1, [pc, #24]	; (40d70 <lll_conn_prepare_reset+0x20>)
	mic_state = LLL_CONN_MIC_NONE;
   40d58:	4a06      	ldr	r2, [pc, #24]	; (40d74 <lll_conn_prepare_reset+0x24>)
	trx_cnt = 0U;
   40d5a:	2300      	movs	r3, #0
   40d5c:	8023      	strh	r3, [r4, #0]
	crc_valid = 0U;
   40d5e:	7003      	strb	r3, [r0, #0]
	crc_expire = 0U;
   40d60:	700b      	strb	r3, [r1, #0]
	mic_state = LLL_CONN_MIC_NONE;
   40d62:	7013      	strb	r3, [r2, #0]
}
   40d64:	bc10      	pop	{r4}
   40d66:	4770      	bx	lr
   40d68:	20006bb5 	.word	0x20006bb5
   40d6c:	20006a34 	.word	0x20006a34
   40d70:	20006bb6 	.word	0x20006bb6
   40d74:	20006bb4 	.word	0x20006bb4

00040d78 <lll_conn_abort_cb>:
{
   40d78:	b538      	push	{r3, r4, r5, lr}
	if (!prepare_param) {
   40d7a:	b338      	cbz	r0, 40dcc <lll_conn_abort_cb+0x54>
	err = lll_hfclock_off();
   40d7c:	460d      	mov	r5, r1
   40d7e:	4604      	mov	r4, r0
   40d80:	f7fe ff46 	bl	3fc10 <lll_hfclock_off>
	LL_ASSERT(err >= 0);
   40d84:	2800      	cmp	r0, #0
   40d86:	db14      	blt.n	40db2 <lll_conn_abort_cb+0x3a>
	lll = prepare_param->param;
   40d88:	68e2      	ldr	r2, [r4, #12]
	lll->latency_prepare += (prepare_param->lazy + 1);
   40d8a:	8923      	ldrh	r3, [r4, #8]
   40d8c:	8a51      	ldrh	r1, [r2, #18]
   40d8e:	3301      	adds	r3, #1
   40d90:	440b      	add	r3, r1
   40d92:	8253      	strh	r3, [r2, #18]
	e = ull_event_done_extra_get();
   40d94:	f7f7 fa8e 	bl	382b4 <ull_event_done_extra_get>
	LL_ASSERT(e);
   40d98:	4604      	mov	r4, r0
   40d9a:	b1f0      	cbz	r0, 40dda <lll_conn_abort_cb+0x62>
	e->trx_cnt = 0U;
   40d9c:	6863      	ldr	r3, [r4, #4]
	e->type = EVENT_DONE_EXTRA_TYPE_CONN;
   40d9e:	2201      	movs	r2, #1
	e->trx_cnt = 0U;
   40da0:	f403 037e 	and.w	r3, r3, #16646144	; 0xfe0000
	e->type = EVENT_DONE_EXTRA_TYPE_CONN;
   40da4:	7022      	strb	r2, [r4, #0]
	e->trx_cnt = 0U;
   40da6:	6063      	str	r3, [r4, #4]
	lll_done(param);
   40da8:	4628      	mov	r0, r5
}
   40daa:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	lll_done(param);
   40dae:	f7fe bc99 	b.w	3f6e4 <lll_done>
	LL_ASSERT(err >= 0);
   40db2:	4a10      	ldr	r2, [pc, #64]	; (40df4 <lll_conn_abort_cb+0x7c>)
   40db4:	4910      	ldr	r1, [pc, #64]	; (40df8 <lll_conn_abort_cb+0x80>)
   40db6:	4811      	ldr	r0, [pc, #68]	; (40dfc <lll_conn_abort_cb+0x84>)
   40db8:	23ab      	movs	r3, #171	; 0xab
   40dba:	f008 f963 	bl	49084 <assert_print>
   40dbe:	4040      	eors	r0, r0
   40dc0:	f380 8811 	msr	BASEPRI, r0
   40dc4:	f04f 0003 	mov.w	r0, #3
   40dc8:	df02      	svc	2
   40dca:	e7dd      	b.n	40d88 <lll_conn_abort_cb+0x10>
		radio_isr_set(isr_done, param);
   40dcc:	480c      	ldr	r0, [pc, #48]	; (40e00 <lll_conn_abort_cb+0x88>)
   40dce:	f000 fe89 	bl	41ae4 <radio_isr_set>
}
   40dd2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		radio_disable();
   40dd6:	f000 bf77 	b.w	41cc8 <radio_disable>
	LL_ASSERT(e);
   40dda:	4a06      	ldr	r2, [pc, #24]	; (40df4 <lll_conn_abort_cb+0x7c>)
   40ddc:	4909      	ldr	r1, [pc, #36]	; (40e04 <lll_conn_abort_cb+0x8c>)
   40dde:	4807      	ldr	r0, [pc, #28]	; (40dfc <lll_conn_abort_cb+0x84>)
   40de0:	23b3      	movs	r3, #179	; 0xb3
   40de2:	f008 f94f 	bl	49084 <assert_print>
   40de6:	4040      	eors	r0, r0
   40de8:	f380 8811 	msr	BASEPRI, r0
   40dec:	f04f 0003 	mov.w	r0, #3
   40df0:	df02      	svc	2
   40df2:	e7d3      	b.n	40d9c <lll_conn_abort_cb+0x24>
   40df4:	00052c2c 	.word	0x00052c2c
   40df8:	00052af8 	.word	0x00052af8
   40dfc:	0005214c 	.word	0x0005214c
   40e00:	00040c7d 	.word	0x00040c7d
   40e04:	00052530 	.word	0x00052530

00040e08 <lll_conn_rx_pkt_set>:
{
   40e08:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   40e0a:	4605      	mov	r5, r0
	node_rx = ull_pdu_rx_alloc_peek(1);
   40e0c:	2001      	movs	r0, #1
   40e0e:	f7f7 f93d 	bl	3808c <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
   40e12:	4604      	mov	r4, r0
   40e14:	b348      	cbz	r0, 40e6a <lll_conn_rx_pkt_set+0x62>
	phy = lll->phy_rx;
   40e16:	f895 6045 	ldrb.w	r6, [r5, #69]	; 0x45
	max_rx_octets = lll->max_rx_octets;
   40e1a:	8fef      	ldrh	r7, [r5, #62]	; 0x3e
	phy = lll->phy_rx;
   40e1c:	f006 0607 	and.w	r6, r6, #7
	radio_phy_set(phy, 0);
   40e20:	2100      	movs	r1, #0
   40e22:	4630      	mov	r0, r6
   40e24:	f000 febc 	bl	41ba0 <radio_phy_set>
	} else if (lll->enc_rx) {
   40e28:	f895 305e 	ldrb.w	r3, [r5, #94]	; 0x5e
				    RADIO_PKT_CONF_FLAGS(RADIO_PKT_CONF_PDU_TYPE_DC, phy,
   40e2c:	0072      	lsls	r2, r6, #1
	} else if (lll->enc_rx) {
   40e2e:	071b      	lsls	r3, r3, #28
		radio_pkt_configure(RADIO_PKT_CONF_LENGTH_8BIT, (max_rx_octets + PDU_MIC_SIZE),
   40e30:	b2f9      	uxtb	r1, r7
   40e32:	f042 0201 	orr.w	r2, r2, #1
						      node_rx->pdu));
   40e36:	f104 041c 	add.w	r4, r4, #28
	} else if (lll->enc_rx) {
   40e3a:	d50e      	bpl.n	40e5a <lll_conn_rx_pkt_set+0x52>
		radio_pkt_configure(RADIO_PKT_CONF_LENGTH_8BIT, (max_rx_octets + PDU_MIC_SIZE),
   40e3c:	3104      	adds	r1, #4
   40e3e:	b2c9      	uxtb	r1, r1
   40e40:	2008      	movs	r0, #8
   40e42:	f000 fef3 	bl	41c2c <radio_pkt_configure>
		radio_pkt_rx_set(radio_ccm_rx_pkt_set(&lll->ccm_rx, phy,
   40e46:	4622      	mov	r2, r4
   40e48:	4631      	mov	r1, r6
   40e4a:	f105 005f 	add.w	r0, r5, #95	; 0x5f
   40e4e:	f001 f9c3 	bl	421d8 <radio_ccm_rx_pkt_set>
}
   40e52:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		radio_pkt_rx_set(radio_ccm_rx_pkt_set(&lll->ccm_rx, phy,
   40e56:	f000 bf0f 	b.w	41c78 <radio_pkt_rx_set>
		radio_pkt_configure(RADIO_PKT_CONF_LENGTH_8BIT, max_rx_octets,
   40e5a:	2008      	movs	r0, #8
   40e5c:	f000 fee6 	bl	41c2c <radio_pkt_configure>
		radio_pkt_rx_set(node_rx->pdu);
   40e60:	4620      	mov	r0, r4
}
   40e62:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		radio_pkt_rx_set(node_rx->pdu);
   40e66:	f000 bf07 	b.w	41c78 <radio_pkt_rx_set>
	LL_ASSERT(node_rx);
   40e6a:	4a07      	ldr	r2, [pc, #28]	; (40e88 <lll_conn_rx_pkt_set+0x80>)
   40e6c:	4907      	ldr	r1, [pc, #28]	; (40e8c <lll_conn_rx_pkt_set+0x84>)
   40e6e:	4808      	ldr	r0, [pc, #32]	; (40e90 <lll_conn_rx_pkt_set+0x88>)
   40e70:	f44f 7322 	mov.w	r3, #648	; 0x288
   40e74:	f008 f906 	bl	49084 <assert_print>
   40e78:	4040      	eors	r0, r0
   40e7a:	f380 8811 	msr	BASEPRI, r0
   40e7e:	f04f 0003 	mov.w	r0, #3
   40e82:	df02      	svc	2
   40e84:	e7c7      	b.n	40e16 <lll_conn_rx_pkt_set+0xe>
   40e86:	bf00      	nop
   40e88:	00052c2c 	.word	0x00052c2c
   40e8c:	00052b94 	.word	0x00052b94
   40e90:	0005214c 	.word	0x0005214c

00040e94 <lll_conn_isr_tx>:
{
   40e94:	b538      	push	{r3, r4, r5, lr}
   40e96:	4604      	mov	r4, r0
	lll_isr_tx_status_reset();
   40e98:	f7fe fcec 	bl	3f874 <lll_isr_tx_status_reset>
	radio_tmr_tifs_set(EVENT_IFS_US);
   40e9c:	2096      	movs	r0, #150	; 0x96
   40e9e:	f001 f87b 	bl	41f98 <radio_tmr_tifs_set>
	radio_switch_complete_and_tx(lll->phy_rx, 0, lll->phy_tx, lll->phy_flags);
   40ea2:	f894 2044 	ldrb.w	r2, [r4, #68]	; 0x44
   40ea6:	f894 0045 	ldrb.w	r0, [r4, #69]	; 0x45
   40eaa:	f3c2 03c0 	ubfx	r3, r2, #3, #1
   40eae:	f000 0007 	and.w	r0, r0, #7
   40eb2:	f002 0207 	and.w	r2, r2, #7
   40eb6:	2100      	movs	r1, #0
   40eb8:	f000 ffaa 	bl	41e10 <radio_switch_complete_and_tx>
	lll_conn_rx_pkt_set(lll);
   40ebc:	4620      	mov	r0, r4
   40ebe:	f7ff ffa3 	bl	40e08 <lll_conn_rx_pkt_set>
	LL_ASSERT(!radio_is_ready());
   40ec2:	f000 ff21 	bl	41d08 <radio_is_ready>
   40ec6:	bb58      	cbnz	r0, 40f20 <lll_conn_isr_tx+0x8c>
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + (EVENT_CLOCK_JITTER_US << 1) +
   40ec8:	f001 f980 	bl	421cc <radio_tmr_tifs_base_get>
   40ecc:	4605      	mov	r5, r0
	hcto += radio_rx_chain_delay_get(lll->phy_rx, 1);
   40ece:	f894 0045 	ldrb.w	r0, [r4, #69]	; 0x45
   40ed2:	2101      	movs	r1, #1
   40ed4:	f000 0007 	and.w	r0, r0, #7
   40ed8:	f000 fee4 	bl	41ca4 <radio_rx_chain_delay_get>
	hcto += addr_us_get(lll->phy_rx);
   40edc:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
   40ee0:	f003 0307 	and.w	r3, r3, #7
	hcto += radio_rx_chain_delay_get(lll->phy_rx, 1);
   40ee4:	4405      	add	r5, r0
   40ee6:	2b02      	cmp	r3, #2
   40ee8:	f105 05a3 	add.w	r5, r5, #163	; 0xa3
   40eec:	d016      	beq.n	40f1c <lll_conn_isr_tx+0x88>
		return 40;
   40eee:	2b04      	cmp	r3, #4
   40ef0:	bf0c      	ite	eq
   40ef2:	f44f 73bc 	moveq.w	r3, #376	; 0x178
   40ef6:	2328      	movne	r3, #40	; 0x28
	hcto -= radio_tx_chain_delay_get(lll->phy_tx, lll->phy_flags);
   40ef8:	f894 0044 	ldrb.w	r0, [r4, #68]	; 0x44
   40efc:	f3c0 01c0 	ubfx	r1, r0, #3, #1
   40f00:	f000 0007 	and.w	r0, r0, #7
	hcto += addr_us_get(lll->phy_rx);
   40f04:	441d      	add	r5, r3
	hcto -= radio_tx_chain_delay_get(lll->phy_tx, lll->phy_flags);
   40f06:	f000 fec9 	bl	41c9c <radio_tx_chain_delay_get>
	radio_tmr_hcto_configure(hcto);
   40f0a:	1a28      	subs	r0, r5, r0
   40f0c:	f001 f916 	bl	4213c <radio_tmr_hcto_configure>
	radio_isr_set(lll_conn_isr_rx, param);
   40f10:	4621      	mov	r1, r4
   40f12:	480a      	ldr	r0, [pc, #40]	; (40f3c <lll_conn_isr_tx+0xa8>)
}
   40f14:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	radio_isr_set(lll_conn_isr_rx, param);
   40f18:	f000 bde4 	b.w	41ae4 <radio_isr_set>
	switch (phy) {
   40f1c:	2318      	movs	r3, #24
   40f1e:	e7eb      	b.n	40ef8 <lll_conn_isr_tx+0x64>
	LL_ASSERT(!radio_is_ready());
   40f20:	4a07      	ldr	r2, [pc, #28]	; (40f40 <lll_conn_isr_tx+0xac>)
   40f22:	4908      	ldr	r1, [pc, #32]	; (40f44 <lll_conn_isr_tx+0xb0>)
   40f24:	4808      	ldr	r0, [pc, #32]	; (40f48 <lll_conn_isr_tx+0xb4>)
   40f26:	f240 233d 	movw	r3, #573	; 0x23d
   40f2a:	f008 f8ab 	bl	49084 <assert_print>
   40f2e:	4040      	eors	r0, r0
   40f30:	f380 8811 	msr	BASEPRI, r0
   40f34:	f04f 0003 	mov.w	r0, #3
   40f38:	df02      	svc	2
   40f3a:	e7c5      	b.n	40ec8 <lll_conn_isr_tx+0x34>
   40f3c:	00041061 	.word	0x00041061
   40f40:	00052c2c 	.word	0x00052c2c
   40f44:	00052b9c 	.word	0x00052b9c
   40f48:	0005214c 	.word	0x0005214c

00040f4c <lll_conn_tx_pkt_set>:
{
   40f4c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   40f4e:	460f      	mov	r7, r1
	phy = lll->phy_tx;
   40f50:	f890 1044 	ldrb.w	r1, [r0, #68]	; 0x44
	max_tx_octets = lll->max_tx_octets;
   40f54:	8f86      	ldrh	r6, [r0, #60]	; 0x3c
	phy = lll->phy_tx;
   40f56:	f001 0407 	and.w	r4, r1, #7
{
   40f5a:	4605      	mov	r5, r0
	radio_phy_set(phy, flags);
   40f5c:	f3c1 01c0 	ubfx	r1, r1, #3, #1
   40f60:	4620      	mov	r0, r4
   40f62:	f000 fe1d 	bl	41ba0 <radio_phy_set>
	} else if (lll->enc_tx) {
   40f66:	f895 305e 	ldrb.w	r3, [r5, #94]	; 0x5e
		pkt_flags = RADIO_PKT_CONF_FLAGS(RADIO_PKT_CONF_PDU_TYPE_DC, phy,
   40f6a:	0062      	lsls	r2, r4, #1
	} else if (lll->enc_tx) {
   40f6c:	06db      	lsls	r3, r3, #27
		pkt_flags = RADIO_PKT_CONF_FLAGS(RADIO_PKT_CONF_PDU_TYPE_DC, phy,
   40f6e:	f042 0201 	orr.w	r2, r2, #1
		radio_pkt_configure(RADIO_PKT_CONF_LENGTH_8BIT, (max_tx_octets + PDU_MIC_SIZE),
   40f72:	b2f1      	uxtb	r1, r6
	} else if (lll->enc_tx) {
   40f74:	d50d      	bpl.n	40f92 <lll_conn_tx_pkt_set+0x46>
		radio_pkt_configure(RADIO_PKT_CONF_LENGTH_8BIT, (max_tx_octets + PDU_MIC_SIZE),
   40f76:	3104      	adds	r1, #4
   40f78:	b2c9      	uxtb	r1, r1
   40f7a:	2008      	movs	r0, #8
   40f7c:	f000 fe56 	bl	41c2c <radio_pkt_configure>
		radio_pkt_tx_set(radio_ccm_tx_pkt_set(&lll->ccm_tx, pdu_data_tx));
   40f80:	4639      	mov	r1, r7
   40f82:	f105 0080 	add.w	r0, r5, #128	; 0x80
   40f86:	f001 f96f 	bl	42268 <radio_ccm_tx_pkt_set>
}
   40f8a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		radio_pkt_tx_set(radio_ccm_tx_pkt_set(&lll->ccm_tx, pdu_data_tx));
   40f8e:	f000 be79 	b.w	41c84 <radio_pkt_tx_set>
		radio_pkt_configure(RADIO_PKT_CONF_LENGTH_8BIT, max_tx_octets, pkt_flags);
   40f92:	2008      	movs	r0, #8
   40f94:	f000 fe4a 	bl	41c2c <radio_pkt_configure>
		radio_pkt_tx_set(pdu_data_tx);
   40f98:	4638      	mov	r0, r7
}
   40f9a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		radio_pkt_tx_set(pdu_data_tx);
   40f9e:	f000 be71 	b.w	41c84 <radio_pkt_tx_set>
   40fa2:	bf00      	nop

00040fa4 <lll_conn_pdu_tx_prep>:
{
   40fa4:	b5f0      	push	{r4, r5, r6, r7, lr}
   40fa6:	4605      	mov	r5, r0
   40fa8:	b083      	sub	sp, #12
	link = memq_peek(lll->memq_tx.head, lll->memq_tx.tail, (void **)&tx);
   40faa:	aa01      	add	r2, sp, #4
   40fac:	6c80      	ldr	r0, [r0, #72]	; 0x48
{
   40fae:	460f      	mov	r7, r1
	link = memq_peek(lll->memq_tx.head, lll->memq_tx.tail, (void **)&tx);
   40fb0:	6ce9      	ldr	r1, [r5, #76]	; 0x4c
   40fb2:	f7f3 faf1 	bl	34598 <memq_peek>
	if (lll->empty || !link) {
   40fb6:	f895 305e 	ldrb.w	r3, [r5, #94]	; 0x5e
   40fba:	075a      	lsls	r2, r3, #29
	link = memq_peek(lll->memq_tx.head, lll->memq_tx.tail, (void **)&tx);
   40fbc:	4606      	mov	r6, r0
	if (lll->empty || !link) {
   40fbe:	d438      	bmi.n	41032 <lll_conn_pdu_tx_prep+0x8e>
   40fc0:	b348      	cbz	r0, 41016 <lll_conn_pdu_tx_prep+0x72>
		p = (void *)(tx->pdu + lll->packet_tx_head_offset);
   40fc2:	9c01      	ldr	r4, [sp, #4]
   40fc4:	f895 305d 	ldrb.w	r3, [r5, #93]	; 0x5d
		if (!lll->packet_tx_head_len) {
   40fc8:	f895 205c 	ldrb.w	r2, [r5, #92]	; 0x5c
		p = (void *)(tx->pdu + lll->packet_tx_head_offset);
   40fcc:	3404      	adds	r4, #4
   40fce:	441c      	add	r4, r3
		if (!lll->packet_tx_head_len) {
   40fd0:	b912      	cbnz	r2, 40fd8 <lll_conn_pdu_tx_prep+0x34>
			lll->packet_tx_head_len = p->len;
   40fd2:	7862      	ldrb	r2, [r4, #1]
   40fd4:	f885 205c 	strb.w	r2, [r5, #92]	; 0x5c
		if (lll->packet_tx_head_offset) {
   40fd8:	b133      	cbz	r3, 40fe8 <lll_conn_pdu_tx_prep+0x44>
			p->ll_id = PDU_DATA_LLID_DATA_CONTINUE;
   40fda:	7823      	ldrb	r3, [r4, #0]
   40fdc:	2201      	movs	r2, #1
   40fde:	f362 0301 	bfi	r3, r2, #0, #2
   40fe2:	7023      	strb	r3, [r4, #0]
		p->len = lll->packet_tx_head_len - lll->packet_tx_head_offset;
   40fe4:	f895 305d 	ldrb.w	r3, [r5, #93]	; 0x5d
   40fe8:	f895 205c 	ldrb.w	r2, [r5, #92]	; 0x5c
   40fec:	1ad3      	subs	r3, r2, r3
   40fee:	7063      	strb	r3, [r4, #1]
		max_tx_octets = ull_conn_lll_max_tx_octets_get(lll);
   40ff0:	4628      	mov	r0, r5
   40ff2:	f7fd fa05 	bl	3e400 <ull_conn_lll_max_tx_octets_get>
		if (p->len > max_tx_octets) {
   40ff6:	7863      	ldrb	r3, [r4, #1]
   40ff8:	4283      	cmp	r3, r0
   40ffa:	d92a      	bls.n	41052 <lll_conn_pdu_tx_prep+0xae>
			p->len = max_tx_octets;
   40ffc:	7060      	strb	r0, [r4, #1]
{
   40ffe:	2101      	movs	r1, #1
			p->md = 1U;
   41000:	7823      	ldrb	r3, [r4, #0]
   41002:	f003 030f 	and.w	r3, r3, #15
		p->resv = 0U;
   41006:	2200      	movs	r2, #0
			p->md = 1U;
   41008:	ea43 1301 	orr.w	r3, r3, r1, lsl #4
   4100c:	7023      	strb	r3, [r4, #0]
		p->resv = 0U;
   4100e:	70a2      	strb	r2, [r4, #2]
	*pdu_data_tx = p;
   41010:	603c      	str	r4, [r7, #0]
}
   41012:	b003      	add	sp, #12
   41014:	bdf0      	pop	{r4, r5, r6, r7, pc}
		lll->empty = 1U;
   41016:	f043 0304 	orr.w	r3, r3, #4
   4101a:	f885 305e 	strb.w	r3, [r5, #94]	; 0x5e
		p = (void *)radio_pkt_empty_get();
   4101e:	f000 fea7 	bl	41d70 <radio_pkt_empty_get>
   41022:	4604      	mov	r4, r0
			p->md = 0U;
   41024:	7823      	ldrb	r3, [r4, #0]
   41026:	f36f 1304 	bfc	r3, #4, #1
   4102a:	7023      	strb	r3, [r4, #0]
	*pdu_data_tx = p;
   4102c:	603c      	str	r4, [r7, #0]
}
   4102e:	b003      	add	sp, #12
   41030:	bdf0      	pop	{r4, r5, r6, r7, pc}
		lll->empty = 1U;
   41032:	f043 0304 	orr.w	r3, r3, #4
   41036:	f885 305e 	strb.w	r3, [r5, #94]	; 0x5e
		p = (void *)radio_pkt_empty_get();
   4103a:	f000 fe99 	bl	41d70 <radio_pkt_empty_get>
   4103e:	4604      	mov	r4, r0
		if (link || FORCE_MD_CNT_GET()) {
   41040:	2e00      	cmp	r6, #0
   41042:	d0ef      	beq.n	41024 <lll_conn_pdu_tx_prep+0x80>
			p->md = 1U;
   41044:	7803      	ldrb	r3, [r0, #0]
   41046:	f043 0310 	orr.w	r3, r3, #16
   4104a:	7003      	strb	r3, [r0, #0]
	*pdu_data_tx = p;
   4104c:	603c      	str	r4, [r7, #0]
}
   4104e:	b003      	add	sp, #12
   41050:	bdf0      	pop	{r4, r5, r6, r7, pc}
		} else if ((link->next != lll->memq_tx.tail) ||
   41052:	6832      	ldr	r2, [r6, #0]
   41054:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
   41056:	429a      	cmp	r2, r3
   41058:	d1d1      	bne.n	40ffe <lll_conn_pdu_tx_prep+0x5a>
   4105a:	2100      	movs	r1, #0
   4105c:	e7d0      	b.n	41000 <lll_conn_pdu_tx_prep+0x5c>
   4105e:	bf00      	nop

00041060 <lll_conn_isr_rx>:
{
   41060:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   41064:	b083      	sub	sp, #12
   41066:	4604      	mov	r4, r0
	trx_done = radio_is_done();
   41068:	f000 fe58 	bl	41d1c <radio_is_done>
	if (trx_done) {
   4106c:	b2c0      	uxtb	r0, r0
   4106e:	b950      	cbnz	r0, 41086 <lll_conn_isr_rx+0x26>
	lll_isr_rx_status_reset();
   41070:	f7fe fc08 	bl	3f884 <lll_isr_rx_status_reset>
		radio_isr_set(isr_done, param);
   41074:	48b8      	ldr	r0, [pc, #736]	; (41358 <lll_conn_isr_rx+0x2f8>)
   41076:	4621      	mov	r1, r4
   41078:	f000 fd34 	bl	41ae4 <radio_isr_set>
}
   4107c:	b003      	add	sp, #12
   4107e:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
		radio_disable();
   41082:	f000 be21 	b.w	41cc8 <radio_disable>
		crc_ok = radio_crc_is_valid();
   41086:	f000 fe69 	bl	41d5c <radio_crc_is_valid>
   4108a:	b2c5      	uxtb	r5, r0
		rssi_ready = radio_rssi_is_ready();
   4108c:	f000 ff48 	bl	41f20 <radio_rssi_is_ready>
	lll_isr_rx_status_reset();
   41090:	f7fe fbf8 	bl	3f884 <lll_isr_rx_status_reset>
	trx_cnt++;
   41094:	4ab1      	ldr	r2, [pc, #708]	; (4135c <lll_conn_isr_rx+0x2fc>)
   41096:	8813      	ldrh	r3, [r2, #0]
	node_rx = ull_pdu_rx_alloc_peek(1);
   41098:	2001      	movs	r0, #1
	trx_cnt++;
   4109a:	4403      	add	r3, r0
   4109c:	8013      	strh	r3, [r2, #0]
	node_rx = ull_pdu_rx_alloc_peek(1);
   4109e:	f7f6 fff5 	bl	3808c <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
   410a2:	4607      	mov	r7, r0
   410a4:	2800      	cmp	r0, #0
   410a6:	f000 8101 	beq.w	412ac <lll_conn_isr_rx+0x24c>
	if (crc_ok) {
   410aa:	2d00      	cmp	r5, #0
   410ac:	d14d      	bne.n	4114a <lll_conn_isr_rx+0xea>
		if (crc_expire == 0U) {
   410ae:	4aac      	ldr	r2, [pc, #688]	; (41360 <lll_conn_isr_rx+0x300>)
   410b0:	7813      	ldrb	r3, [r2, #0]
   410b2:	2b00      	cmp	r3, #0
   410b4:	f040 80bf 	bne.w	41236 <lll_conn_isr_rx+0x1d6>
		crc_expire--;
   410b8:	2301      	movs	r3, #1
	lll_conn_pdu_tx_prep(lll, &pdu_data_tx);
   410ba:	a901      	add	r1, sp, #4
   410bc:	4620      	mov	r0, r4
		crc_expire--;
   410be:	7013      	strb	r3, [r2, #0]
	lll_conn_pdu_tx_prep(lll, &pdu_data_tx);
   410c0:	f7ff ff70 	bl	40fa4 <lll_conn_pdu_tx_prep>
	is_rx_enqueue = 0U;
   410c4:	f04f 0800 	mov.w	r8, #0
	pdu_data_tx->sn = lll->sn;
   410c8:	9e01      	ldr	r6, [sp, #4]
	tx_release = NULL;
   410ca:	4645      	mov	r5, r8
		radio_tmr_tifs_set(EVENT_IFS_US);
   410cc:	2096      	movs	r0, #150	; 0x96
   410ce:	f000 ff63 	bl	41f98 <radio_tmr_tifs_set>
		radio_switch_complete_and_rx(lll->phy_rx);
   410d2:	f894 0045 	ldrb.w	r0, [r4, #69]	; 0x45
   410d6:	f000 0007 	and.w	r0, r0, #7
   410da:	f000 fe51 	bl	41d80 <radio_switch_complete_and_rx>
		radio_isr_set(lll_conn_isr_tx, param);
   410de:	48a1      	ldr	r0, [pc, #644]	; (41364 <lll_conn_isr_rx+0x304>)
   410e0:	4621      	mov	r1, r4
   410e2:	f000 fcff 	bl	41ae4 <radio_isr_set>
		radio_tmr_end_capture();
   410e6:	f001 f863 	bl	421b0 <radio_tmr_end_capture>
	pdu_data_tx->sn = lll->sn;
   410ea:	f894 205e 	ldrb.w	r2, [r4, #94]	; 0x5e
   410ee:	7833      	ldrb	r3, [r6, #0]
   410f0:	f362 03c3 	bfi	r3, r2, #3, #1
   410f4:	7033      	strb	r3, [r6, #0]
	pdu_data_tx->nesn = lll->nesn;
   410f6:	f894 305e 	ldrb.w	r3, [r4, #94]	; 0x5e
   410fa:	7832      	ldrb	r2, [r6, #0]
   410fc:	f3c3 0340 	ubfx	r3, r3, #1, #1
   41100:	f363 0282 	bfi	r2, r3, #2, #1
   41104:	7032      	strb	r2, [r6, #0]
	lll_conn_tx_pkt_set(lll, pdu_data_tx);
   41106:	4631      	mov	r1, r6
   41108:	4620      	mov	r0, r4
   4110a:	f7ff ff1f 	bl	40f4c <lll_conn_tx_pkt_set>
	LL_ASSERT(!radio_is_ready());
   4110e:	f000 fdfb 	bl	41d08 <radio_is_ready>
   41112:	2800      	cmp	r0, #0
   41114:	f040 8100 	bne.w	41318 <lll_conn_isr_rx+0x2b8>
	if (!radio_tmr_aa_restore()) {
   41118:	f001 f83e 	bl	42198 <radio_tmr_aa_restore>
   4111c:	2800      	cmp	r0, #0
   4111e:	d07d      	beq.n	4121c <lll_conn_isr_rx+0x1bc>
	if (tx_release) {
   41120:	2d00      	cmp	r5, #0
   41122:	f000 8082 	beq.w	4122a <lll_conn_isr_rx+0x1ca>
		LL_ASSERT(lll->handle != 0xFFFF);
   41126:	89a0      	ldrh	r0, [r4, #12]
   41128:	f64f 73ff 	movw	r3, #65535	; 0xffff
   4112c:	4298      	cmp	r0, r3
   4112e:	f000 8103 	beq.w	41338 <lll_conn_isr_rx+0x2d8>
		ull_conn_lll_ack_enqueue(lll->handle, tx_release);
   41132:	4629      	mov	r1, r5
   41134:	f7fc fed0 	bl	3ded8 <ull_conn_lll_ack_enqueue>
	if (is_rx_enqueue) {
   41138:	f1b8 0f00 	cmp.w	r8, #0
   4113c:	f040 8099 	bne.w	41272 <lll_conn_isr_rx+0x212>
}
   41140:	b003      	add	sp, #12
   41142:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
		ull_rx_sched();
   41146:	f7f6 bfe9 	b.w	3811c <ull_rx_sched>
	if (pdu_data_rx->nesn != lll->sn) {
   4114a:	f894 305e 	ldrb.w	r3, [r4, #94]	; 0x5e
   4114e:	7f3a      	ldrb	r2, [r7, #28]
   41150:	f003 0101 	and.w	r1, r3, #1
   41154:	f3c2 0080 	ubfx	r0, r2, #2, #1
   41158:	4288      	cmp	r0, r1
   4115a:	f000 80b7 	beq.w	412cc <lll_conn_isr_rx+0x26c>
		if (lll->role) {
   4115e:	f994 201d 	ldrsb.w	r2, [r4, #29]
		lll->sn++;
   41162:	f081 0101 	eor.w	r1, r1, #1
   41166:	f361 0300 	bfi	r3, r1, #0, #1
		if (lll->role) {
   4116a:	2a00      	cmp	r2, #0
		lll->sn++;
   4116c:	f884 305e 	strb.w	r3, [r4, #94]	; 0x5e
		if (lll->role) {
   41170:	da05      	bge.n	4117e <lll_conn_isr_rx+0x11e>
			lll->periph.latency_enabled = 1;
   41172:	f894 3020 	ldrb.w	r3, [r4, #32]
   41176:	f043 0304 	orr.w	r3, r3, #4
   4117a:	f884 3020 	strb.w	r3, [r4, #32]
		if (!lll->empty) {
   4117e:	f894 305e 	ldrb.w	r3, [r4, #94]	; 0x5e
   41182:	f013 0604 	ands.w	r6, r3, #4
   41186:	f040 80fd 	bne.w	41384 <lll_conn_isr_rx+0x324>
			link = memq_peek(lll->memq_tx.head, lll->memq_tx.tail,
   4118a:	e9d4 0112 	ldrd	r0, r1, [r4, #72]	; 0x48
   4118e:	aa01      	add	r2, sp, #4
   41190:	f7f3 fa02 	bl	34598 <memq_peek>
		if (link) {
   41194:	4605      	mov	r5, r0
   41196:	2800      	cmp	r0, #0
   41198:	f000 810a 	beq.w	413b0 <lll_conn_isr_rx+0x350>
			pdu_data_tx = (void *)(tx->pdu +
   4119c:	9b01      	ldr	r3, [sp, #4]
					       lll->packet_tx_head_offset);
   4119e:	f894 905d 	ldrb.w	r9, [r4, #93]	; 0x5d
			pdu_data_tx = (void *)(tx->pdu +
   411a2:	f103 0804 	add.w	r8, r3, #4
   411a6:	eb08 0309 	add.w	r3, r8, r9
			pdu_data_tx_len = pdu_data_tx->len;
   411aa:	785a      	ldrb	r2, [r3, #1]
			if (pdu_data_tx_len != 0U) {
   411ac:	b172      	cbz	r2, 411cc <lll_conn_isr_rx+0x16c>
				if (lll->enc_tx) {
   411ae:	f894 305e 	ldrb.w	r3, [r4, #94]	; 0x5e
   411b2:	06db      	lsls	r3, r3, #27
   411b4:	d50a      	bpl.n	411cc <lll_conn_isr_rx+0x16c>
					lll->ccm_tx.counter++;
   411b6:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
   411ba:	3301      	adds	r3, #1
   411bc:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
   411c0:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
   411c4:	f143 0300 	adc.w	r3, r3, #0
   411c8:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
			if (offset < lll->packet_tx_head_len) {
   411cc:	f894 305c 	ldrb.w	r3, [r4, #92]	; 0x5c
			offset = lll->packet_tx_head_offset + pdu_data_tx_len;
   411d0:	444a      	add	r2, r9
   411d2:	b2d2      	uxtb	r2, r2
			if (offset < lll->packet_tx_head_len) {
   411d4:	429a      	cmp	r2, r3
   411d6:	f0c0 80f1 	bcc.w	413bc <lll_conn_isr_rx+0x35c>
			} else if (offset == lll->packet_tx_head_len) {
   411da:	f000 811b 	beq.w	41414 <lll_conn_isr_rx+0x3b4>
				LL_ASSERT(0);
   411de:	4a62      	ldr	r2, [pc, #392]	; (41368 <lll_conn_isr_rx+0x308>)
   411e0:	4962      	ldr	r1, [pc, #392]	; (4136c <lll_conn_isr_rx+0x30c>)
   411e2:	4863      	ldr	r0, [pc, #396]	; (41370 <lll_conn_isr_rx+0x310>)
   411e4:	f240 33d1 	movw	r3, #977	; 0x3d1
   411e8:	f007 ff4c 	bl	49084 <assert_print>
   411ec:	4040      	eors	r0, r0
   411ee:	f380 8811 	msr	BASEPRI, r0
   411f2:	f04f 0003 	mov.w	r0, #3
   411f6:	df02      	svc	2
	tx_release = NULL;
   411f8:	2500      	movs	r5, #0
			if (IS_ENABLED(CONFIG_BT_CENTRAL) && !lll->role &&
   411fa:	f994 301d 	ldrsb.w	r3, [r4, #29]
   411fe:	2b00      	cmp	r3, #0
   41200:	f2c0 80fd 	blt.w	413fe <lll_conn_isr_rx+0x39e>
			    !pdu_data_rx->md) {
   41204:	7f3a      	ldrb	r2, [r7, #28]
   41206:	f894 305e 	ldrb.w	r3, [r4, #94]	; 0x5e
			if (IS_ENABLED(CONFIG_BT_CENTRAL) && !lll->role &&
   4120a:	06d0      	lsls	r0, r2, #27
				*is_done = !pdu_data_tx->md;
   4120c:	bf5e      	ittt	pl
   4120e:	f818 6009 	ldrbpl.w	r6, [r8, r9]
   41212:	f086 0610 	eorpl.w	r6, r6, #16
   41216:	f3c6 1600 	ubfxpl	r6, r6, #4, #1
   4121a:	e059      	b.n	412d0 <lll_conn_isr_rx+0x270>
		radio_tmr_aa_save(radio_tmr_aa_get());
   4121c:	f000 ffb0 	bl	42180 <radio_tmr_aa_get>
   41220:	f000 ffb4 	bl	4218c <radio_tmr_aa_save>
	if (tx_release) {
   41224:	2d00      	cmp	r5, #0
   41226:	f47f af7e 	bne.w	41126 <lll_conn_isr_rx+0xc6>
	if (is_rx_enqueue) {
   4122a:	f1b8 0f00 	cmp.w	r8, #0
   4122e:	d120      	bne.n	41272 <lll_conn_isr_rx+0x212>
}
   41230:	b003      	add	sp, #12
   41232:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		crc_expire--;
   41236:	f103 38ff 	add.w	r8, r3, #4294967295	; 0xffffffff
	is_empty_pdu_tx_retry = lll->empty;
   4123a:	f894 305e 	ldrb.w	r3, [r4, #94]	; 0x5e
		crc_expire--;
   4123e:	fa5f f888 	uxtb.w	r8, r8
	lll_conn_pdu_tx_prep(lll, &pdu_data_tx);
   41242:	a901      	add	r1, sp, #4
   41244:	4620      	mov	r0, r4
		crc_expire--;
   41246:	f882 8000 	strb.w	r8, [r2]
	is_empty_pdu_tx_retry = lll->empty;
   4124a:	f3c3 0980 	ubfx	r9, r3, #2, #1
	lll_conn_pdu_tx_prep(lll, &pdu_data_tx);
   4124e:	f7ff fea9 	bl	40fa4 <lll_conn_pdu_tx_prep>
	is_done = is_done || ((crc_ok) && (pdu_data_rx->md == 0) &&
   41252:	f1b8 0f00 	cmp.w	r8, #0
   41256:	f47f af35 	bne.w	410c4 <lll_conn_isr_rx+0x64>
		radio_isr_set(isr_done, param);
   4125a:	483f      	ldr	r0, [pc, #252]	; (41358 <lll_conn_isr_rx+0x2f8>)
   4125c:	4621      	mov	r1, r4
   4125e:	f000 fc41 	bl	41ae4 <radio_isr_set>
		} else if (!lll->role) {
   41262:	f994 301d 	ldrsb.w	r3, [r4, #29]
   41266:	2b00      	cmp	r3, #0
   41268:	da12      	bge.n	41290 <lll_conn_isr_rx+0x230>
			radio_switch_complete_and_disable();
   4126a:	f000 fe31 	bl	41ed0 <radio_switch_complete_and_disable>
	pdu_data_tx->sn = lll->sn;
   4126e:	9e01      	ldr	r6, [sp, #4]
   41270:	e73b      	b.n	410ea <lll_conn_isr_rx+0x8a>
		ull_pdu_rx_alloc();
   41272:	f7f6 ff2d 	bl	380d0 <ull_pdu_rx_alloc>
		node_rx->hdr.type = NODE_RX_TYPE_DC_PDU;
   41276:	2303      	movs	r3, #3
   41278:	713b      	strb	r3, [r7, #4]
		node_rx->hdr.handle = lll->handle;
   4127a:	89a3      	ldrh	r3, [r4, #12]
		ull_rx_put(node_rx->hdr.link, node_rx);
   4127c:	6838      	ldr	r0, [r7, #0]
		node_rx->hdr.handle = lll->handle;
   4127e:	80fb      	strh	r3, [r7, #6]
		ull_rx_put(node_rx->hdr.link, node_rx);
   41280:	4639      	mov	r1, r7
   41282:	f7f6 ff3b 	bl	380fc <ull_rx_put>
}
   41286:	b003      	add	sp, #12
   41288:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
		ull_rx_sched();
   4128c:	f7f6 bf46 	b.w	3811c <ull_rx_sched>
			radio_disable();
   41290:	f000 fd1a 	bl	41cc8 <radio_disable>
			LL_ASSERT(!radio_is_ready());
   41294:	f000 fd38 	bl	41d08 <radio_is_ready>
   41298:	2800      	cmp	r0, #0
   4129a:	f040 80a2 	bne.w	413e2 <lll_conn_isr_rx+0x382>
			lll->empty = is_empty_pdu_tx_retry;
   4129e:	f894 305e 	ldrb.w	r3, [r4, #94]	; 0x5e
   412a2:	f369 0382 	bfi	r3, r9, #2, #1
   412a6:	f884 305e 	strb.w	r3, [r4, #94]	; 0x5e
			goto lll_conn_isr_rx_exit;
   412aa:	e735      	b.n	41118 <lll_conn_isr_rx+0xb8>
	LL_ASSERT(node_rx);
   412ac:	4a2e      	ldr	r2, [pc, #184]	; (41368 <lll_conn_isr_rx+0x308>)
   412ae:	4931      	ldr	r1, [pc, #196]	; (41374 <lll_conn_isr_rx+0x314>)
   412b0:	482f      	ldr	r0, [pc, #188]	; (41370 <lll_conn_isr_rx+0x310>)
   412b2:	23fe      	movs	r3, #254	; 0xfe
   412b4:	f007 fee6 	bl	49084 <assert_print>
   412b8:	4040      	eors	r0, r0
   412ba:	f380 8811 	msr	BASEPRI, r0
   412be:	f04f 0003 	mov.w	r0, #3
   412c2:	df02      	svc	2
	if (crc_ok) {
   412c4:	2d00      	cmp	r5, #0
   412c6:	f43f aef2 	beq.w	410ae <lll_conn_isr_rx+0x4e>
   412ca:	e73e      	b.n	4114a <lll_conn_isr_rx+0xea>
	is_done = 0U;
   412cc:	2600      	movs	r6, #0
	tx_release = NULL;
   412ce:	4635      	mov	r5, r6
	if ((pdu_data_rx->sn == lll->nesn) &&
   412d0:	f3c2 02c0 	ubfx	r2, r2, #3, #1
   412d4:	f3c3 0140 	ubfx	r1, r3, #1, #1
   412d8:	428a      	cmp	r2, r1
   412da:	d072      	beq.n	413c2 <lll_conn_isr_rx+0x362>
	is_rx_enqueue = 0U;
   412dc:	f04f 0800 	mov.w	r8, #0
		crc_expire = 0U;
   412e0:	4a1f      	ldr	r2, [pc, #124]	; (41360 <lll_conn_isr_rx+0x300>)
   412e2:	2100      	movs	r1, #0
	is_empty_pdu_tx_retry = lll->empty;
   412e4:	f3c3 0980 	ubfx	r9, r3, #2, #1
		crc_valid = 1U;
   412e8:	4b23      	ldr	r3, [pc, #140]	; (41378 <lll_conn_isr_rx+0x318>)
		crc_expire = 0U;
   412ea:	7011      	strb	r1, [r2, #0]
	lll_conn_pdu_tx_prep(lll, &pdu_data_tx);
   412ec:	4620      	mov	r0, r4
		crc_valid = 1U;
   412ee:	2201      	movs	r2, #1
	lll_conn_pdu_tx_prep(lll, &pdu_data_tx);
   412f0:	a901      	add	r1, sp, #4
		crc_valid = 1U;
   412f2:	701a      	strb	r2, [r3, #0]
	lll_conn_pdu_tx_prep(lll, &pdu_data_tx);
   412f4:	f7ff fe56 	bl	40fa4 <lll_conn_pdu_tx_prep>
	is_done = is_done || ((crc_ok) && (pdu_data_rx->md == 0) &&
   412f8:	2e00      	cmp	r6, #0
   412fa:	d1ae      	bne.n	4125a <lll_conn_isr_rx+0x1fa>
   412fc:	7f3b      	ldrb	r3, [r7, #28]
			      (pdu_data_tx->md == 0) &&
   412fe:	9e01      	ldr	r6, [sp, #4]
	is_done = is_done || ((crc_ok) && (pdu_data_rx->md == 0) &&
   41300:	06da      	lsls	r2, r3, #27
   41302:	f53f aee3 	bmi.w	410cc <lll_conn_isr_rx+0x6c>
			      (pdu_data_tx->md == 0) &&
   41306:	7833      	ldrb	r3, [r6, #0]
	is_done = is_done || ((crc_ok) && (pdu_data_rx->md == 0) &&
   41308:	06db      	lsls	r3, r3, #27
   4130a:	f53f aedf 	bmi.w	410cc <lll_conn_isr_rx+0x6c>
			      (pdu_data_tx->md == 0) &&
   4130e:	7873      	ldrb	r3, [r6, #1]
   41310:	2b00      	cmp	r3, #0
   41312:	f47f aedb 	bne.w	410cc <lll_conn_isr_rx+0x6c>
   41316:	e7a0      	b.n	4125a <lll_conn_isr_rx+0x1fa>
	LL_ASSERT(!radio_is_ready());
   41318:	4a13      	ldr	r2, [pc, #76]	; (41368 <lll_conn_isr_rx+0x308>)
   4131a:	4918      	ldr	r1, [pc, #96]	; (4137c <lll_conn_isr_rx+0x31c>)
   4131c:	4814      	ldr	r0, [pc, #80]	; (41370 <lll_conn_isr_rx+0x310>)
   4131e:	f44f 73c6 	mov.w	r3, #396	; 0x18c
   41322:	f007 feaf 	bl	49084 <assert_print>
   41326:	4040      	eors	r0, r0
   41328:	f380 8811 	msr	BASEPRI, r0
   4132c:	f04f 0003 	mov.w	r0, #3
   41330:	df02      	svc	2
   41332:	e6f1      	b.n	41118 <lll_conn_isr_rx+0xb8>
	tx_release = NULL;
   41334:	f04f 0800 	mov.w	r8, #0
		LL_ASSERT(lll->handle != 0xFFFF);
   41338:	4a0b      	ldr	r2, [pc, #44]	; (41368 <lll_conn_isr_rx+0x308>)
   4133a:	4911      	ldr	r1, [pc, #68]	; (41380 <lll_conn_isr_rx+0x320>)
   4133c:	480c      	ldr	r0, [pc, #48]	; (41370 <lll_conn_isr_rx+0x310>)
   4133e:	f44f 73d1 	mov.w	r3, #418	; 0x1a2
   41342:	f007 fe9f 	bl	49084 <assert_print>
   41346:	4040      	eors	r0, r0
   41348:	f380 8811 	msr	BASEPRI, r0
   4134c:	f04f 0003 	mov.w	r0, #3
   41350:	df02      	svc	2
		ull_conn_lll_ack_enqueue(lll->handle, tx_release);
   41352:	89a0      	ldrh	r0, [r4, #12]
   41354:	e6ed      	b.n	41132 <lll_conn_isr_rx+0xd2>
   41356:	bf00      	nop
   41358:	00040c7d 	.word	0x00040c7d
   4135c:	20006a34 	.word	0x20006a34
   41360:	20006bb6 	.word	0x20006bb6
   41364:	00040e95 	.word	0x00040e95
   41368:	00052c2c 	.word	0x00052c2c
   4136c:	000521ac 	.word	0x000521ac
   41370:	0005214c 	.word	0x0005214c
   41374:	00052b94 	.word	0x00052b94
   41378:	20006bb5 	.word	0x20006bb5
   4137c:	00052b9c 	.word	0x00052b9c
   41380:	00052c80 	.word	0x00052c80
			lll->empty = 0;
   41384:	f36f 0382 	bfc	r3, #2, #1
   41388:	f884 305e 	strb.w	r3, [r4, #94]	; 0x5e
			pdu_data_tx = (void *)radio_pkt_empty_get();
   4138c:	f000 fcf0 	bl	41d70 <radio_pkt_empty_get>
			if (IS_ENABLED(CONFIG_BT_CENTRAL) && !lll->role &&
   41390:	f994 301d 	ldrsb.w	r3, [r4, #29]
   41394:	2b00      	cmp	r3, #0
   41396:	db0b      	blt.n	413b0 <lll_conn_isr_rx+0x350>
			    !pdu_data_rx->md) {
   41398:	7f3a      	ldrb	r2, [r7, #28]
			if (IS_ENABLED(CONFIG_BT_CENTRAL) && !lll->role &&
   4139a:	f012 0510 	ands.w	r5, r2, #16
   4139e:	d108      	bne.n	413b2 <lll_conn_isr_rx+0x352>
				*is_done = !pdu_data_tx->md;
   413a0:	7806      	ldrb	r6, [r0, #0]
   413a2:	f894 305e 	ldrb.w	r3, [r4, #94]	; 0x5e
   413a6:	f086 0610 	eor.w	r6, r6, #16
   413aa:	f3c6 1600 	ubfx	r6, r6, #4, #1
   413ae:	e78f      	b.n	412d0 <lll_conn_isr_rx+0x270>
   413b0:	7f3a      	ldrb	r2, [r7, #28]
   413b2:	f894 305e 	ldrb.w	r3, [r4, #94]	; 0x5e
	is_done = 0U;
   413b6:	2600      	movs	r6, #0
	tx_release = NULL;
   413b8:	4635      	mov	r5, r6
   413ba:	e789      	b.n	412d0 <lll_conn_isr_rx+0x270>
				lll->packet_tx_head_offset = offset;
   413bc:	f884 205d 	strb.w	r2, [r4, #93]	; 0x5d
   413c0:	e71a      	b.n	411f8 <lll_conn_isr_rx+0x198>
	    (ull_pdu_rx_alloc_peek(3) != 0)) {
   413c2:	2003      	movs	r0, #3
   413c4:	f7f6 fe62 	bl	3808c <ull_pdu_rx_alloc_peek>
		lll->nesn++;
   413c8:	f894 305e 	ldrb.w	r3, [r4, #94]	; 0x5e
	if ((pdu_data_rx->sn == lll->nesn) &&
   413cc:	2800      	cmp	r0, #0
   413ce:	d085      	beq.n	412dc <lll_conn_isr_rx+0x27c>
		lll->nesn++;
   413d0:	f083 0302 	eor.w	r3, r3, #2
   413d4:	f884 305e 	strb.w	r3, [r4, #94]	; 0x5e
		if (pdu_data_rx->len != 0) {
   413d8:	7f7b      	ldrb	r3, [r7, #29]
   413da:	b9a3      	cbnz	r3, 41406 <lll_conn_isr_rx+0x3a6>
   413dc:	f894 305e 	ldrb.w	r3, [r4, #94]	; 0x5e
   413e0:	e77c      	b.n	412dc <lll_conn_isr_rx+0x27c>
			LL_ASSERT(!radio_is_ready());
   413e2:	4a51      	ldr	r2, [pc, #324]	; (41528 <lll_conn_isr_rx+0x4c8>)
   413e4:	4951      	ldr	r1, [pc, #324]	; (4152c <lll_conn_isr_rx+0x4cc>)
   413e6:	4852      	ldr	r0, [pc, #328]	; (41530 <lll_conn_isr_rx+0x4d0>)
   413e8:	f240 1353 	movw	r3, #339	; 0x153
   413ec:	f007 fe4a 	bl	49084 <assert_print>
   413f0:	4040      	eors	r0, r0
   413f2:	f380 8811 	msr	BASEPRI, r0
   413f6:	f04f 0003 	mov.w	r0, #3
   413fa:	df02      	svc	2
   413fc:	e74f      	b.n	4129e <lll_conn_isr_rx+0x23e>
   413fe:	f894 305e 	ldrb.w	r3, [r4, #94]	; 0x5e
   41402:	7f3a      	ldrb	r2, [r7, #28]
   41404:	e764      	b.n	412d0 <lll_conn_isr_rx+0x270>
			if (lll->enc_rx) {
   41406:	f894 305e 	ldrb.w	r3, [r4, #94]	; 0x5e
   4140a:	0719      	lsls	r1, r3, #28
   4140c:	d411      	bmi.n	41432 <lll_conn_isr_rx+0x3d2>
			*is_rx_enqueue = 1U;
   4140e:	f04f 0801 	mov.w	r8, #1
   41412:	e765      	b.n	412e0 <lll_conn_isr_rx+0x280>
				lll->packet_tx_head_len = 0;
   41414:	2200      	movs	r2, #0
				memq_dequeue(lll->memq_tx.tail,
   41416:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
				lll->packet_tx_head_len = 0;
   41418:	f8a4 205c 	strh.w	r2, [r4, #92]	; 0x5c
				memq_dequeue(lll->memq_tx.tail,
   4141c:	f104 0148 	add.w	r1, r4, #72	; 0x48
   41420:	f7f3 f8c2 	bl	345a8 <memq_dequeue>
				link->next = tx->next; /* Indicates ctrl or data
   41424:	9b01      	ldr	r3, [sp, #4]
   41426:	681b      	ldr	r3, [r3, #0]
   41428:	602b      	str	r3, [r5, #0]
				tx->next = link;
   4142a:	9b01      	ldr	r3, [sp, #4]
   4142c:	601d      	str	r5, [r3, #0]
				*tx_release = tx;
   4142e:	9d01      	ldr	r5, [sp, #4]
				FORCE_MD_CNT_SET();
   41430:	e6e3      	b.n	411fa <lll_conn_isr_rx+0x19a>
				done = radio_ccm_is_done();
   41432:	f000 ff43 	bl	422bc <radio_ccm_is_done>
				LL_ASSERT(done);
   41436:	2800      	cmp	r0, #0
   41438:	d068      	beq.n	4150c <lll_conn_isr_rx+0x4ac>
				bool mic_failure = !radio_ccm_mic_is_valid();
   4143a:	f000 ff61 	bl	42300 <radio_ccm_mic_is_valid>
				if (mic_failure &&
   4143e:	2800      	cmp	r0, #0
   41440:	d152      	bne.n	414e8 <lll_conn_isr_rx+0x488>
				    lll->ccm_rx.counter == 0 &&
   41442:	f8d4 306f 	ldr.w	r3, [r4, #111]	; 0x6f
   41446:	f8d4 2073 	ldr.w	r2, [r4, #115]	; 0x73
				if (mic_failure &&
   4144a:	4313      	orrs	r3, r2
   4144c:	d104      	bne.n	41458 <lll_conn_isr_rx+0x3f8>
				    (pdu_data_rx->ll_id ==
   4144e:	7f3b      	ldrb	r3, [r7, #28]
				    lll->ccm_rx.counter == 0 &&
   41450:	f003 0303 	and.w	r3, r3, #3
   41454:	2b03      	cmp	r3, #3
   41456:	d030      	beq.n	414ba <lll_conn_isr_rx+0x45a>
					mic_state = LLL_CONN_MIC_FAIL;
   41458:	4b36      	ldr	r3, [pc, #216]	; (41534 <lll_conn_isr_rx+0x4d4>)
			radio_isr_set(isr_done, param);
   4145a:	4837      	ldr	r0, [pc, #220]	; (41538 <lll_conn_isr_rx+0x4d8>)
					mic_state = LLL_CONN_MIC_FAIL;
   4145c:	2202      	movs	r2, #2
			radio_isr_set(isr_done, param);
   4145e:	4621      	mov	r1, r4
					mic_state = LLL_CONN_MIC_FAIL;
   41460:	701a      	strb	r2, [r3, #0]
			radio_isr_set(isr_done, param);
   41462:	f000 fb3f 	bl	41ae4 <radio_isr_set>
			radio_disable();
   41466:	f000 fc2f 	bl	41cc8 <radio_disable>
			LL_ASSERT(!radio_is_ready());
   4146a:	f000 fc4d 	bl	41d08 <radio_is_ready>
   4146e:	b978      	cbnz	r0, 41490 <lll_conn_isr_rx+0x430>
	if (!radio_tmr_aa_restore()) {
   41470:	f000 fe92 	bl	42198 <radio_tmr_aa_restore>
   41474:	b1d0      	cbz	r0, 414ac <lll_conn_isr_rx+0x44c>
	if (tx_release) {
   41476:	2d00      	cmp	r5, #0
   41478:	f43f aeda 	beq.w	41230 <lll_conn_isr_rx+0x1d0>
		LL_ASSERT(lll->handle != 0xFFFF);
   4147c:	89a0      	ldrh	r0, [r4, #12]
   4147e:	f64f 73ff 	movw	r3, #65535	; 0xffff
   41482:	4298      	cmp	r0, r3
   41484:	f43f af56 	beq.w	41334 <lll_conn_isr_rx+0x2d4>
		ull_conn_lll_ack_enqueue(lll->handle, tx_release);
   41488:	4629      	mov	r1, r5
   4148a:	f7fc fd25 	bl	3ded8 <ull_conn_lll_ack_enqueue>
	if (is_rx_enqueue) {
   4148e:	e657      	b.n	41140 <lll_conn_isr_rx+0xe0>
			LL_ASSERT(!radio_is_ready());
   41490:	4a25      	ldr	r2, [pc, #148]	; (41528 <lll_conn_isr_rx+0x4c8>)
   41492:	4926      	ldr	r1, [pc, #152]	; (4152c <lll_conn_isr_rx+0x4cc>)
   41494:	4826      	ldr	r0, [pc, #152]	; (41530 <lll_conn_isr_rx+0x4d0>)
   41496:	f240 130f 	movw	r3, #271	; 0x10f
   4149a:	f007 fdf3 	bl	49084 <assert_print>
   4149e:	4040      	eors	r0, r0
   414a0:	f380 8811 	msr	BASEPRI, r0
   414a4:	f04f 0003 	mov.w	r0, #3
   414a8:	df02      	svc	2
   414aa:	e7e1      	b.n	41470 <lll_conn_isr_rx+0x410>
		radio_tmr_aa_save(radio_tmr_aa_get());
   414ac:	f000 fe68 	bl	42180 <radio_tmr_aa_get>
   414b0:	f000 fe6c 	bl	4218c <radio_tmr_aa_save>
	if (tx_release) {
   414b4:	2d00      	cmp	r5, #0
   414b6:	d1e1      	bne.n	4147c <lll_conn_isr_rx+0x41c>
   414b8:	e6ba      	b.n	41230 <lll_conn_isr_rx+0x1d0>
						radio_pkt_scratch_get();
   414ba:	f000 fc5d 	bl	41d78 <radio_pkt_scratch_get>
					if (ctrl_pdu_len_check(
   414be:	7843      	ldrb	r3, [r0, #1]
   414c0:	2b27      	cmp	r3, #39	; 0x27
						radio_pkt_scratch_get();
   414c2:	4601      	mov	r1, r0
					if (ctrl_pdu_len_check(
   414c4:	d8c8      	bhi.n	41458 <lll_conn_isr_rx+0x3f8>
						memcpy(pdu_data_rx,
   414c6:	3303      	adds	r3, #3
   414c8:	b2da      	uxtb	r2, r3
   414ca:	f107 001c 	add.w	r0, r7, #28
   414ce:	f009 fcd4 	bl	4ae7a <memcpy>
						lll->ccm_rx.counter--;
   414d2:	f8d4 306f 	ldr.w	r3, [r4, #111]	; 0x6f
   414d6:	3b01      	subs	r3, #1
   414d8:	f8c4 306f 	str.w	r3, [r4, #111]	; 0x6f
   414dc:	f8d4 3073 	ldr.w	r3, [r4, #115]	; 0x73
   414e0:	f143 33ff 	adc.w	r3, r3, #4294967295	; 0xffffffff
   414e4:	f8c4 3073 	str.w	r3, [r4, #115]	; 0x73
				lll->ccm_rx.counter++;
   414e8:	f8d4 306f 	ldr.w	r3, [r4, #111]	; 0x6f
   414ec:	3301      	adds	r3, #1
   414ee:	f8c4 306f 	str.w	r3, [r4, #111]	; 0x6f
   414f2:	f8d4 3073 	ldr.w	r3, [r4, #115]	; 0x73
						lll->ccm_rx.counter--;
   414f6:	f104 026f 	add.w	r2, r4, #111	; 0x6f
				lll->ccm_rx.counter++;
   414fa:	f143 0300 	adc.w	r3, r3, #0
   414fe:	6053      	str	r3, [r2, #4]
				mic_state = LLL_CONN_MIC_PASS;
   41500:	4b0c      	ldr	r3, [pc, #48]	; (41534 <lll_conn_isr_rx+0x4d4>)
   41502:	2201      	movs	r2, #1
   41504:	701a      	strb	r2, [r3, #0]
		if (err) {
   41506:	f894 305e 	ldrb.w	r3, [r4, #94]	; 0x5e
   4150a:	e780      	b.n	4140e <lll_conn_isr_rx+0x3ae>
				LL_ASSERT(done);
   4150c:	4a06      	ldr	r2, [pc, #24]	; (41528 <lll_conn_isr_rx+0x4c8>)
   4150e:	490b      	ldr	r1, [pc, #44]	; (4153c <lll_conn_isr_rx+0x4dc>)
   41510:	4807      	ldr	r0, [pc, #28]	; (41530 <lll_conn_isr_rx+0x4d0>)
   41512:	f44f 737b 	mov.w	r3, #1004	; 0x3ec
   41516:	f007 fdb5 	bl	49084 <assert_print>
   4151a:	4040      	eors	r0, r0
   4151c:	f380 8811 	msr	BASEPRI, r0
   41520:	f04f 0003 	mov.w	r0, #3
   41524:	df02      	svc	2
   41526:	e788      	b.n	4143a <lll_conn_isr_rx+0x3da>
   41528:	00052c2c 	.word	0x00052c2c
   4152c:	00052b9c 	.word	0x00052b9c
   41530:	0005214c 	.word	0x0005214c
   41534:	20006bb4 	.word	0x20006bb4
   41538:	00040c7d 	.word	0x00040c7d
   4153c:	00052c78 	.word	0x00052c78

00041540 <prepare_cb>:
{
	return 0;
}

static int prepare_cb(struct lll_prepare_param *p)
{
   41540:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint32_t remainder;
	uint32_t hcto;

	DEBUG_RADIO_START_S(1);

	lll = p->param;
   41544:	68c4      	ldr	r4, [r0, #12]

	/* Check if stopped (on disconnection between prepare and pre-empt)
	 */
	if (unlikely(lll->handle == 0xFFFF)) {
   41546:	89a2      	ldrh	r2, [r4, #12]
   41548:	f64f 73ff 	movw	r3, #65535	; 0xffff
   4154c:	429a      	cmp	r2, r3
{
   4154e:	b082      	sub	sp, #8
	if (unlikely(lll->handle == 0xFFFF)) {
   41550:	f000 80d2 	beq.w	416f8 <prepare_cb+0x1b8>

		return 0;
	}

	/* Reset connection event global variables */
	lll_conn_prepare_reset();
   41554:	4605      	mov	r5, r0
   41556:	f7ff fbfb 	bl	40d50 <lll_conn_prepare_reset>

	/* Calculate the current event latency */
	lll->latency_event = lll->latency_prepare + p->lazy;
   4155a:	892b      	ldrh	r3, [r5, #8]
   4155c:	8a62      	ldrh	r2, [r4, #18]

	/* Calculate the current event counter value */
	event_counter = lll->event_counter + lll->latency_event;
   4155e:	8ae0      	ldrh	r0, [r4, #22]
	lll->latency_event = lll->latency_prepare + p->lazy;
   41560:	441a      	add	r2, r3
   41562:	b292      	uxth	r2, r2
	event_counter = lll->event_counter + lll->latency_event;
   41564:	4410      	add	r0, r2
	lll->event_counter = (event_counter + 1);

	/* Reset accumulated latencies */
	lll->latency_prepare = 0;

	if (lll->data_chan_sel) {
   41566:	7f63      	ldrb	r3, [r4, #29]
	lll->latency_event = lll->latency_prepare + p->lazy;
   41568:	82a2      	strh	r2, [r4, #20]
	event_counter = lll->event_counter + lll->latency_event;
   4156a:	b280      	uxth	r0, r0
	lll->event_counter = (event_counter + 1);
   4156c:	1c41      	adds	r1, r0, #1
   4156e:	82e1      	strh	r1, [r4, #22]
	if (lll->data_chan_sel) {
   41570:	065e      	lsls	r6, r3, #25
	lll->latency_prepare = 0;
   41572:	f04f 0100 	mov.w	r1, #0
   41576:	8261      	strh	r1, [r4, #18]
#if defined(CONFIG_BT_CTLR_CHAN_SEL_2)
		data_chan_use = lll_chan_sel_2(event_counter, lll->data_chan_id,
   41578:	f104 0118 	add.w	r1, r4, #24
	if (lll->data_chan_sel) {
   4157c:	f100 808e 	bmi.w	4169c <prepare_cb+0x15c>
#else /* !CONFIG_BT_CTLR_CHAN_SEL_2 */
		data_chan_use = 0;
		LL_ASSERT(0);
#endif /* !CONFIG_BT_CTLR_CHAN_SEL_2 */
	} else {
		data_chan_use = lll_chan_sel_1(&lll->data_chan_use,
   41580:	f003 003f 	and.w	r0, r3, #63	; 0x3f
   41584:	460b      	mov	r3, r1
   41586:	7fa1      	ldrb	r1, [r4, #30]
   41588:	9000      	str	r0, [sp, #0]
   4158a:	f104 001f 	add.w	r0, r4, #31
   4158e:	f7fd fcd9 	bl	3ef44 <lll_chan_sel_1>
   41592:	4606      	mov	r6, r0
					       &lll->data_chan_map[0],
					       lll->data_chan_count);
	}

	/* current window widening */
	lll->periph.window_widening_event_us +=
   41594:	e9d4 230b 	ldrd	r2, r3, [r4, #44]	; 0x2c
   41598:	4413      	add	r3, r2
		lll->periph.window_widening_event_us =
			lll->periph.window_widening_max_us;
	}

	/* current window size */
	lll->periph.window_size_event_us +=
   4159a:	e9d4 020d 	ldrd	r0, r2, [r4, #52]	; 0x34
	lll->periph.window_widening_prepare_us = 0;
   4159e:	2100      	movs	r1, #0
	lll->periph.window_size_event_us +=
   415a0:	4402      	add	r2, r0
	lll->periph.window_widening_prepare_us = 0;
   415a2:	62e1      	str	r1, [r4, #44]	; 0x2c
		lll->periph.window_size_prepare_us;
	lll->periph.window_size_prepare_us = 0;
   415a4:	6361      	str	r1, [r4, #52]	; 0x34
   415a6:	6aa1      	ldr	r1, [r4, #40]	; 0x28
	lll->periph.window_size_event_us +=
   415a8:	63a2      	str	r2, [r4, #56]	; 0x38
	/* Ensure that empty flag reflects the state of the Tx queue, as a
	 * peripheral if this is the first connection event and as no prior PDU
	 * is transmitted, an incorrect acknowledgment by peer should not
	 * dequeue a PDU that has not been transmitted on air.
	 */
	if (!lll->empty) {
   415aa:	f894 205e 	ldrb.w	r2, [r4, #94]	; 0x5e
   415ae:	428b      	cmp	r3, r1
   415b0:	bf28      	it	cs
   415b2:	460b      	movcs	r3, r1
   415b4:	f012 0204 	ands.w	r2, r2, #4
   415b8:	6323      	str	r3, [r4, #48]	; 0x30
   415ba:	f000 808f 	beq.w	416dc <prepare_cb+0x19c>
			lll->empty = 1U;
		}
	}

	/* Start setting up Radio h/w */
	radio_reset();
   415be:	f000 fad3 	bl	41b68 <radio_reset>
#if defined(CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL)
	radio_tx_power_set(lll->tx_pwr_lvl);
#else
	radio_tx_power_set(RADIO_TXP_DEFAULT);
   415c2:	2000      	movs	r0, #0
   415c4:	f000 fafc 	bl	41bc0 <radio_tx_power_set>
#endif /* CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL */

	radio_aa_set(lll->access_addr);
   415c8:	1d20      	adds	r0, r4, #4
   415ca:	f000 fb17 	bl	41bfc <radio_aa_set>
	return ((uint32_t)src[2] << 16) | sys_get_le16(&src[0]);
   415ce:	8923      	ldrh	r3, [r4, #8]
   415d0:	7aa1      	ldrb	r1, [r4, #10]
	radio_crc_configure(PDU_CRC_POLYNOMIAL,
   415d2:	f240 605b 	movw	r0, #1627	; 0x65b
   415d6:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
   415da:	f000 fbb3 	bl	41d44 <radio_crc_configure>
				sys_get_le24(lll->crc_init));

	lll_chan_set(data_chan_use);
   415de:	4630      	mov	r0, r6
   415e0:	f7fe f902 	bl	3f7e8 <lll_chan_set>

	radio_isr_set(lll_conn_isr_rx, lll);
   415e4:	4621      	mov	r1, r4
   415e6:	4849      	ldr	r0, [pc, #292]	; (4170c <prepare_cb+0x1cc>)
   415e8:	f000 fa7c 	bl	41ae4 <radio_isr_set>

	radio_tmr_tifs_set(EVENT_IFS_US);
   415ec:	2096      	movs	r0, #150	; 0x96
   415ee:	f000 fcd3 	bl	41f98 <radio_tmr_tifs_set>
	 * - CTE RX is not enabled,
	 * - SOC does not require compensation for PHYEND event delay.
	 */
	if (!IS_ENABLED(CONFIG_BT_CTLR_DF_PHYEND_OFFSET_COMPENSATION_ENABLE)) {
#if defined(CONFIG_BT_CTLR_PHY)
		radio_switch_complete_and_tx(lll->phy_rx, 0, lll->phy_tx, lll->phy_flags);
   415f2:	f894 2044 	ldrb.w	r2, [r4, #68]	; 0x44
   415f6:	f894 0045 	ldrb.w	r0, [r4, #69]	; 0x45
   415fa:	f3c2 03c0 	ubfx	r3, r2, #3, #1
   415fe:	2100      	movs	r1, #0
   41600:	f002 0207 	and.w	r2, r2, #7
   41604:	f000 0007 	and.w	r0, r0, #7
   41608:	f000 fc02 	bl	41e10 <radio_switch_complete_and_tx>
	}

	/* The call can use Radio interface that alternates NRF_RADIO->SHORTS. The register is
	 * set by radio_switch_complete_XXX functions, hence any changes done before are cleared.
	 */
	lll_conn_rx_pkt_set(lll);
   4160c:	4620      	mov	r0, r4
   4160e:	f7ff fbfb 	bl	40e08 <lll_conn_rx_pkt_set>

	ticks_at_event = p->ticks_at_expire;
	ull = HDR_LLL2ULL(lll);
   41612:	6827      	ldr	r7, [r4, #0]
	ticks_at_event = p->ticks_at_expire;
   41614:	682e      	ldr	r6, [r5, #0]
	ticks_at_event += lll_event_offset_get(ull);
   41616:	4638      	mov	r0, r7
   41618:	f7fe f8c8 	bl	3f7ac <lll_event_offset_get>
   4161c:	4406      	add	r6, r0

	ticks_at_start = ticks_at_event;
	ticks_at_start += HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US);

	remainder = p->remainder;
	remainder_us = radio_tmr_start(0, ticks_at_start, remainder);
   4161e:	686a      	ldr	r2, [r5, #4]
   41620:	f106 0118 	add.w	r1, r6, #24
   41624:	2000      	movs	r0, #0
   41626:	f000 fcc3 	bl	41fb0 <radio_tmr_start>
   4162a:	4680      	mov	r8, r0

	radio_tmr_aa_capture();
   4162c:	f000 fd94 	bl	42158 <radio_tmr_aa_capture>
	radio_tmr_aa_save(0);
   41630:	2000      	movs	r0, #0
   41632:	f000 fdab 	bl	4218c <radio_tmr_aa_save>

	hcto = remainder_us +
	       ((EVENT_JITTER_US + EVENT_TICKER_RES_MARGIN_US +
   41636:	6b23      	ldr	r3, [r4, #48]	; 0x30
		 lll->periph.window_widening_event_us) << 1) +
	       lll->periph.window_size_event_us;

#if defined(CONFIG_BT_CTLR_PHY)
	hcto += radio_rx_ready_delay_get(lll->phy_rx, 1);
   41638:	f894 0045 	ldrb.w	r0, [r4, #69]	; 0x45
	       ((EVENT_JITTER_US + EVENT_TICKER_RES_MARGIN_US +
   4163c:	f103 0230 	add.w	r2, r3, #48	; 0x30
	hcto = remainder_us +
   41640:	6ba3      	ldr	r3, [r4, #56]	; 0x38
	hcto += radio_rx_ready_delay_get(lll->phy_rx, 1);
   41642:	f000 0007 	and.w	r0, r0, #7
   41646:	2101      	movs	r1, #1
	hcto = remainder_us +
   41648:	eb03 0542 	add.w	r5, r3, r2, lsl #1
	hcto += radio_rx_ready_delay_get(lll->phy_rx, 1);
   4164c:	f000 fb28 	bl	41ca0 <radio_rx_ready_delay_get>
	hcto = remainder_us +
   41650:	4445      	add	r5, r8
	hcto += radio_rx_ready_delay_get(lll->phy_rx, 1);
   41652:	4405      	add	r5, r0
	hcto += addr_us_get(lll->phy_rx);
   41654:	f894 0045 	ldrb.w	r0, [r4, #69]	; 0x45
   41658:	f000 0007 	and.w	r0, r0, #7
   4165c:	2802      	cmp	r0, #2
   4165e:	d03b      	beq.n	416d8 <prepare_cb+0x198>
		return 40;
   41660:	2804      	cmp	r0, #4
   41662:	bf0c      	ite	eq
   41664:	f44f 73bc 	moveq.w	r3, #376	; 0x178
   41668:	2328      	movne	r3, #40	; 0x28
	hcto += radio_rx_chain_delay_get(lll->phy_rx, 1);
   4166a:	2101      	movs	r1, #1
	hcto += addr_us_get(lll->phy_rx);
   4166c:	441d      	add	r5, r3
	hcto += radio_rx_chain_delay_get(lll->phy_rx, 1);
   4166e:	f000 fb19 	bl	41ca4 <radio_rx_chain_delay_get>
	hcto += radio_rx_ready_delay_get(0, 0);
	hcto += addr_us_get(0);
	hcto += radio_rx_chain_delay_get(0, 0);
#endif /* !CONFIG_BT_CTLR_PHY */

	radio_tmr_hcto_configure(hcto);
   41672:	4428      	add	r0, r5
   41674:	f000 fd62 	bl	4213c <radio_tmr_hcto_configure>
#endif /* CONFIG_BT_CTLR_CONN_RSSI */

#if defined(CONFIG_BT_CTLR_XTAL_ADVANCED) && \
	(EVENT_OVERHEAD_PREEMPT_US <= EVENT_OVERHEAD_PREEMPT_MIN_US)
	/* check if preempt to start has changed */
	if (lll_preempt_calc(ull, (TICKER_ID_CONN_BASE + lll->handle),
   41678:	89a1      	ldrh	r1, [r4, #12]
   4167a:	3105      	adds	r1, #5
   4167c:	4632      	mov	r2, r6
   4167e:	b2c9      	uxtb	r1, r1
   41680:	4638      	mov	r0, r7
   41682:	f7fe f8a1 	bl	3f7c8 <lll_preempt_calc>
   41686:	b188      	cbz	r0, 416ac <prepare_cb+0x16c>
			     ticks_at_event)) {
		radio_isr_set(lll_isr_abort, lll);
   41688:	4821      	ldr	r0, [pc, #132]	; (41710 <prepare_cb+0x1d0>)
   4168a:	4621      	mov	r1, r4
   4168c:	f000 fa2a 	bl	41ae4 <radio_isr_set>
		radio_disable();
   41690:	f000 fb1a 	bl	41cc8 <radio_disable>
	}

	DEBUG_RADIO_START_S(1);

	return 0;
}
   41694:	2000      	movs	r0, #0
   41696:	b002      	add	sp, #8
   41698:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		data_chan_use = lll_chan_sel_2(event_counter, lll->data_chan_id,
   4169c:	460a      	mov	r2, r1
   4169e:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   416a2:	8be1      	ldrh	r1, [r4, #30]
   416a4:	f7fd fc9a 	bl	3efdc <lll_chan_sel_2>
   416a8:	4606      	mov	r6, r0
   416aa:	e773      	b.n	41594 <prepare_cb+0x54>
		ret = lll_prepare_done(lll);
   416ac:	4620      	mov	r0, r4
   416ae:	f7fe f817 	bl	3f6e0 <lll_prepare_done>
		LL_ASSERT(!ret);
   416b2:	2800      	cmp	r0, #0
   416b4:	d0ee      	beq.n	41694 <prepare_cb+0x154>
   416b6:	4a17      	ldr	r2, [pc, #92]	; (41714 <prepare_cb+0x1d4>)
   416b8:	4917      	ldr	r1, [pc, #92]	; (41718 <prepare_cb+0x1d8>)
   416ba:	4818      	ldr	r0, [pc, #96]	; (4171c <prepare_cb+0x1dc>)
   416bc:	f240 1351 	movw	r3, #337	; 0x151
   416c0:	f007 fce0 	bl	49084 <assert_print>
   416c4:	4040      	eors	r0, r0
   416c6:	f380 8811 	msr	BASEPRI, r0
   416ca:	f04f 0003 	mov.w	r0, #3
   416ce:	df02      	svc	2
}
   416d0:	2000      	movs	r0, #0
   416d2:	b002      	add	sp, #8
   416d4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	switch (phy) {
   416d8:	2318      	movs	r3, #24
   416da:	e7c6      	b.n	4166a <prepare_cb+0x12a>
		link = memq_peek(lll->memq_tx.head, lll->memq_tx.tail, NULL);
   416dc:	e9d4 0112 	ldrd	r0, r1, [r4, #72]	; 0x48
   416e0:	f7f2 ff5a 	bl	34598 <memq_peek>
		if (!link) {
   416e4:	2800      	cmp	r0, #0
   416e6:	f47f af6a 	bne.w	415be <prepare_cb+0x7e>
			lll->empty = 1U;
   416ea:	f894 305e 	ldrb.w	r3, [r4, #94]	; 0x5e
   416ee:	f043 0304 	orr.w	r3, r3, #4
   416f2:	f884 305e 	strb.w	r3, [r4, #94]	; 0x5e
   416f6:	e762      	b.n	415be <prepare_cb+0x7e>
		radio_isr_set(lll_isr_early_abort, lll);
   416f8:	4809      	ldr	r0, [pc, #36]	; (41720 <prepare_cb+0x1e0>)
   416fa:	4621      	mov	r1, r4
   416fc:	f000 f9f2 	bl	41ae4 <radio_isr_set>
		radio_disable();
   41700:	f000 fae2 	bl	41cc8 <radio_disable>
}
   41704:	2000      	movs	r0, #0
   41706:	b002      	add	sp, #8
   41708:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   4170c:	00041061 	.word	0x00041061
   41710:	0003f925 	.word	0x0003f925
   41714:	00052c98 	.word	0x00052c98
   41718:	00052430 	.word	0x00052430
   4171c:	0005214c 	.word	0x0005214c
   41720:	0003f945 	.word	0x0003f945

00041724 <lll_periph_prepare>:
{
   41724:	b510      	push	{r4, lr}
   41726:	b082      	sub	sp, #8
   41728:	4604      	mov	r4, r0
	err = lll_hfclock_on();
   4172a:	f7fe fa59 	bl	3fbe0 <lll_hfclock_on>
	LL_ASSERT(err >= 0);
   4172e:	2800      	cmp	r0, #0
   41730:	db25      	blt.n	4177e <lll_periph_prepare+0x5a>
	lll = p->param;
   41732:	68e1      	ldr	r1, [r4, #12]
	    lll->periph.window_widening_periodic_us * (p->lazy + 1);
   41734:	8920      	ldrh	r0, [r4, #8]
   41736:	6a4b      	ldr	r3, [r1, #36]	; 0x24
	lll->periph.window_widening_prepare_us +=
   41738:	6aca      	ldr	r2, [r1, #44]	; 0x2c
	    lll->periph.window_widening_periodic_us * (p->lazy + 1);
   4173a:	fb00 3303 	mla	r3, r0, r3, r3
   4173e:	6a88      	ldr	r0, [r1, #40]	; 0x28
	lll->periph.window_widening_prepare_us +=
   41740:	4413      	add	r3, r2
   41742:	4283      	cmp	r3, r0
   41744:	bf28      	it	cs
   41746:	4603      	movcs	r3, r0
   41748:	62cb      	str	r3, [r1, #44]	; 0x2c
	err = lll_prepare(lll_is_abort_cb, lll_conn_abort_cb, prepare_cb, 0, p);
   4174a:	4a13      	ldr	r2, [pc, #76]	; (41798 <lll_periph_prepare+0x74>)
   4174c:	4913      	ldr	r1, [pc, #76]	; (4179c <lll_periph_prepare+0x78>)
   4174e:	4814      	ldr	r0, [pc, #80]	; (417a0 <lll_periph_prepare+0x7c>)
   41750:	9400      	str	r4, [sp, #0]
   41752:	2300      	movs	r3, #0
   41754:	f7f6 ffee 	bl	38734 <lll_prepare>
	LL_ASSERT(!err || err == -EINPROGRESS);
   41758:	b108      	cbz	r0, 4175e <lll_periph_prepare+0x3a>
   4175a:	3077      	adds	r0, #119	; 0x77
   4175c:	d101      	bne.n	41762 <lll_periph_prepare+0x3e>
}
   4175e:	b002      	add	sp, #8
   41760:	bd10      	pop	{r4, pc}
	LL_ASSERT(!err || err == -EINPROGRESS);
   41762:	4a10      	ldr	r2, [pc, #64]	; (417a4 <lll_periph_prepare+0x80>)
   41764:	4910      	ldr	r1, [pc, #64]	; (417a8 <lll_periph_prepare+0x84>)
   41766:	4811      	ldr	r0, [pc, #68]	; (417ac <lll_periph_prepare+0x88>)
   41768:	235e      	movs	r3, #94	; 0x5e
   4176a:	f007 fc8b 	bl	49084 <assert_print>
   4176e:	4040      	eors	r0, r0
   41770:	f380 8811 	msr	BASEPRI, r0
   41774:	f04f 0003 	mov.w	r0, #3
   41778:	df02      	svc	2
}
   4177a:	b002      	add	sp, #8
   4177c:	bd10      	pop	{r4, pc}
	LL_ASSERT(err >= 0);
   4177e:	4a09      	ldr	r2, [pc, #36]	; (417a4 <lll_periph_prepare+0x80>)
   41780:	490b      	ldr	r1, [pc, #44]	; (417b0 <lll_periph_prepare+0x8c>)
   41782:	480a      	ldr	r0, [pc, #40]	; (417ac <lll_periph_prepare+0x88>)
   41784:	234d      	movs	r3, #77	; 0x4d
   41786:	f007 fc7d 	bl	49084 <assert_print>
   4178a:	4040      	eors	r0, r0
   4178c:	f380 8811 	msr	BASEPRI, r0
   41790:	f04f 0003 	mov.w	r0, #3
   41794:	df02      	svc	2
   41796:	e7cc      	b.n	41732 <lll_periph_prepare+0xe>
   41798:	00041541 	.word	0x00041541
   4179c:	00040d79 	.word	0x00040d79
   417a0:	0003f7a5 	.word	0x0003f7a5
   417a4:	00052c98 	.word	0x00052c98
   417a8:	00052bcc 	.word	0x00052bcc
   417ac:	0005214c 	.word	0x0005214c
   417b0:	00052af8 	.word	0x00052af8

000417b4 <prepare_cb>:
{
	return 0;
}

static int prepare_cb(struct lll_prepare_param *p)
{
   417b4:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint32_t remainder;
	uint8_t cte_len;

	DEBUG_RADIO_START_M(1);

	lll = p->param;
   417b6:	68c4      	ldr	r4, [r0, #12]

	/* Check if stopped (on disconnection between prepare and pre-empt)
	 */
	if (unlikely(lll->handle == 0xFFFF)) {
   417b8:	89a2      	ldrh	r2, [r4, #12]
   417ba:	f64f 73ff 	movw	r3, #65535	; 0xffff
   417be:	429a      	cmp	r2, r3
{
   417c0:	b085      	sub	sp, #20
	if (unlikely(lll->handle == 0xFFFF)) {
   417c2:	f000 8092 	beq.w	418ea <prepare_cb+0x136>

		return 0;
	}

	/* Reset connection event global variables */
	lll_conn_prepare_reset();
   417c6:	4605      	mov	r5, r0
   417c8:	f7ff fac2 	bl	40d50 <lll_conn_prepare_reset>

	/* Calculate the current event latency */
	lll->latency_event = lll->latency_prepare + p->lazy;
   417cc:	892b      	ldrh	r3, [r5, #8]
   417ce:	8a62      	ldrh	r2, [r4, #18]

	/* Calculate the current event counter value */
	event_counter = lll->event_counter + lll->latency_event;
   417d0:	8ae0      	ldrh	r0, [r4, #22]
	lll->latency_event = lll->latency_prepare + p->lazy;
   417d2:	441a      	add	r2, r3
   417d4:	b292      	uxth	r2, r2
	event_counter = lll->event_counter + lll->latency_event;
   417d6:	4410      	add	r0, r2
	lll->event_counter = (event_counter + 1);

	/* Reset accumulated latencies */
	lll->latency_prepare = 0;

	if (lll->data_chan_sel) {
   417d8:	7f63      	ldrb	r3, [r4, #29]
	lll->latency_event = lll->latency_prepare + p->lazy;
   417da:	82a2      	strh	r2, [r4, #20]
	event_counter = lll->event_counter + lll->latency_event;
   417dc:	b280      	uxth	r0, r0
	lll->event_counter = (event_counter + 1);
   417de:	1c41      	adds	r1, r0, #1
   417e0:	82e1      	strh	r1, [r4, #22]
	if (lll->data_chan_sel) {
   417e2:	065e      	lsls	r6, r3, #25
	lll->latency_prepare = 0;
   417e4:	f04f 0100 	mov.w	r1, #0
   417e8:	8261      	strh	r1, [r4, #18]
#if defined(CONFIG_BT_CTLR_CHAN_SEL_2)
		data_chan_use = lll_chan_sel_2(event_counter, lll->data_chan_id,
   417ea:	f104 0118 	add.w	r1, r4, #24
	if (lll->data_chan_sel) {
   417ee:	d460      	bmi.n	418b2 <prepare_cb+0xfe>
#else /* !CONFIG_BT_CTLR_CHAN_SEL_2 */
		data_chan_use = 0;
		LL_ASSERT(0);
#endif /* !CONFIG_BT_CTLR_CHAN_SEL_2 */
	} else {
		data_chan_use = lll_chan_sel_1(&lll->data_chan_use,
   417f0:	f003 003f 	and.w	r0, r3, #63	; 0x3f
   417f4:	460b      	mov	r3, r1
   417f6:	7fa1      	ldrb	r1, [r4, #30]
   417f8:	9000      	str	r0, [sp, #0]
   417fa:	f104 001f 	add.w	r0, r4, #31
   417fe:	f7fd fba1 	bl	3ef44 <lll_chan_sel_1>
   41802:	4606      	mov	r6, r0
					       &lll->data_chan_map[0],
					       lll->data_chan_count);
	}

	/* Prepare the Tx PDU */
	lll_conn_pdu_tx_prep(lll, &pdu_data_tx);
   41804:	4620      	mov	r0, r4
   41806:	a903      	add	r1, sp, #12
   41808:	f7ff fbcc 	bl	40fa4 <lll_conn_pdu_tx_prep>
	pdu_data_tx->sn = lll->sn;
   4180c:	9b03      	ldr	r3, [sp, #12]
   4180e:	f894 105e 	ldrb.w	r1, [r4, #94]	; 0x5e
   41812:	781a      	ldrb	r2, [r3, #0]
   41814:	f361 02c3 	bfi	r2, r1, #3, #1
   41818:	701a      	strb	r2, [r3, #0]
	pdu_data_tx->nesn = lll->nesn;
   4181a:	9a03      	ldr	r2, [sp, #12]
   4181c:	f894 305e 	ldrb.w	r3, [r4, #94]	; 0x5e
   41820:	7811      	ldrb	r1, [r2, #0]
   41822:	f3c3 0340 	ubfx	r3, r3, #1, #1
   41826:	f363 0182 	bfi	r1, r3, #2, #1
   4182a:	7011      	strb	r1, [r2, #0]

	/* Start setting up of Radio h/w */
	radio_reset();
   4182c:	f000 f99c 	bl	41b68 <radio_reset>
	}

#if defined(CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL)
	radio_tx_power_set(lll->tx_pwr_lvl);
#else
	radio_tx_power_set(RADIO_TXP_DEFAULT);
   41830:	2000      	movs	r0, #0
   41832:	f000 f9c5 	bl	41bc0 <radio_tx_power_set>
#endif

	radio_aa_set(lll->access_addr);
   41836:	1d20      	adds	r0, r4, #4
   41838:	f000 f9e0 	bl	41bfc <radio_aa_set>
   4183c:	8923      	ldrh	r3, [r4, #8]
   4183e:	7aa1      	ldrb	r1, [r4, #10]
	radio_crc_configure(PDU_CRC_POLYNOMIAL,
   41840:	f240 605b 	movw	r0, #1627	; 0x65b
   41844:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
   41848:	f000 fa7c 	bl	41d44 <radio_crc_configure>
					sys_get_le24(lll->crc_init));
	lll_chan_set(data_chan_use);
   4184c:	4630      	mov	r0, r6
   4184e:	f7fd ffcb 	bl	3f7e8 <lll_chan_set>

	lll_conn_tx_pkt_set(lll, pdu_data_tx);
   41852:	9903      	ldr	r1, [sp, #12]
   41854:	4620      	mov	r0, r4
   41856:	f7ff fb79 	bl	40f4c <lll_conn_tx_pkt_set>

	radio_isr_set(lll_conn_isr_tx, lll);
   4185a:	4621      	mov	r1, r4
   4185c:	4827      	ldr	r0, [pc, #156]	; (418fc <prepare_cb+0x148>)
   4185e:	f000 f941 	bl	41ae4 <radio_isr_set>

	radio_tmr_tifs_set(EVENT_IFS_US);
   41862:	2096      	movs	r0, #150	; 0x96
   41864:	f000 fb98 	bl	41f98 <radio_tmr_tifs_set>
		}
	}
#endif /* CONFIG_BT_CTLR_DF_CONN_CTE_RX */

#if defined(CONFIG_BT_CTLR_PHY)
	radio_switch_complete_and_rx(lll->phy_rx);
   41868:	f894 0045 	ldrb.w	r0, [r4, #69]	; 0x45
   4186c:	f000 0007 	and.w	r0, r0, #7
   41870:	f000 fa86 	bl	41d80 <radio_switch_complete_and_rx>
#else /* !CONFIG_BT_CTLR_PHY */
	radio_switch_complete_and_rx(0);
#endif /* !CONFIG_BT_CTLR_PHY */

	ticks_at_event = p->ticks_at_expire;
	ull = HDR_LLL2ULL(lll);
   41874:	6827      	ldr	r7, [r4, #0]
	ticks_at_event = p->ticks_at_expire;
   41876:	682e      	ldr	r6, [r5, #0]
	ticks_at_event += lll_event_offset_get(ull);
   41878:	4638      	mov	r0, r7
   4187a:	f7fd ff97 	bl	3f7ac <lll_event_offset_get>
   4187e:	4406      	add	r6, r0

	ticks_at_start = ticks_at_event;
	ticks_at_start += HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US);

	remainder = p->remainder;
	remainder_us = radio_tmr_start(1, ticks_at_start, remainder);
   41880:	686a      	ldr	r2, [r5, #4]
   41882:	f106 0118 	add.w	r1, r6, #24
   41886:	2001      	movs	r0, #1
   41888:	f000 fb92 	bl	41fb0 <radio_tmr_start>

	/* capture end of Tx-ed PDU, used to calculate HCTO. */
	radio_tmr_end_capture();
   4188c:	f000 fc90 	bl	421b0 <radio_tmr_end_capture>
#endif /* !HAL_RADIO_GPIO_HAVE_PA_PIN */

#if defined(CONFIG_BT_CTLR_XTAL_ADVANCED) && \
	(EVENT_OVERHEAD_PREEMPT_US <= EVENT_OVERHEAD_PREEMPT_MIN_US)
	/* check if preempt to start has changed */
	if (lll_preempt_calc(ull, (TICKER_ID_CONN_BASE + lll->handle),
   41890:	89a1      	ldrh	r1, [r4, #12]
   41892:	3105      	adds	r1, #5
   41894:	4632      	mov	r2, r6
   41896:	b2c9      	uxtb	r1, r1
   41898:	4638      	mov	r0, r7
   4189a:	f7fd ff95 	bl	3f7c8 <lll_preempt_calc>
   4189e:	b180      	cbz	r0, 418c2 <prepare_cb+0x10e>
			     ticks_at_event)) {
		radio_isr_set(lll_isr_abort, lll);
   418a0:	4817      	ldr	r0, [pc, #92]	; (41900 <prepare_cb+0x14c>)
   418a2:	4621      	mov	r1, r4
   418a4:	f000 f91e 	bl	41ae4 <radio_isr_set>
		radio_disable();
   418a8:	f000 fa0e 	bl	41cc8 <radio_disable>
	}

	DEBUG_RADIO_START_M(1);

	return 0;
}
   418ac:	2000      	movs	r0, #0
   418ae:	b005      	add	sp, #20
   418b0:	bdf0      	pop	{r4, r5, r6, r7, pc}
		data_chan_use = lll_chan_sel_2(event_counter, lll->data_chan_id,
   418b2:	460a      	mov	r2, r1
   418b4:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   418b8:	8be1      	ldrh	r1, [r4, #30]
   418ba:	f7fd fb8f 	bl	3efdc <lll_chan_sel_2>
   418be:	4606      	mov	r6, r0
   418c0:	e7a0      	b.n	41804 <prepare_cb+0x50>
		ret = lll_prepare_done(lll);
   418c2:	4620      	mov	r0, r4
   418c4:	f7fd ff0c 	bl	3f6e0 <lll_prepare_done>
		LL_ASSERT(!ret);
   418c8:	2800      	cmp	r0, #0
   418ca:	d0ef      	beq.n	418ac <prepare_cb+0xf8>
   418cc:	4a0d      	ldr	r2, [pc, #52]	; (41904 <prepare_cb+0x150>)
   418ce:	490e      	ldr	r1, [pc, #56]	; (41908 <prepare_cb+0x154>)
   418d0:	480e      	ldr	r0, [pc, #56]	; (4190c <prepare_cb+0x158>)
   418d2:	23fd      	movs	r3, #253	; 0xfd
   418d4:	f007 fbd6 	bl	49084 <assert_print>
   418d8:	4040      	eors	r0, r0
   418da:	f380 8811 	msr	BASEPRI, r0
   418de:	f04f 0003 	mov.w	r0, #3
   418e2:	df02      	svc	2
}
   418e4:	2000      	movs	r0, #0
   418e6:	b005      	add	sp, #20
   418e8:	bdf0      	pop	{r4, r5, r6, r7, pc}
		radio_isr_set(lll_isr_early_abort, lll);
   418ea:	4809      	ldr	r0, [pc, #36]	; (41910 <prepare_cb+0x15c>)
   418ec:	4621      	mov	r1, r4
   418ee:	f000 f8f9 	bl	41ae4 <radio_isr_set>
		radio_disable();
   418f2:	f000 f9e9 	bl	41cc8 <radio_disable>
}
   418f6:	2000      	movs	r0, #0
   418f8:	b005      	add	sp, #20
   418fa:	bdf0      	pop	{r4, r5, r6, r7, pc}
   418fc:	00040e95 	.word	0x00040e95
   41900:	0003f925 	.word	0x0003f925
   41904:	00052cec 	.word	0x00052cec
   41908:	00052430 	.word	0x00052430
   4190c:	0005214c 	.word	0x0005214c
   41910:	0003f945 	.word	0x0003f945

00041914 <lll_central_prepare>:
{
   41914:	b510      	push	{r4, lr}
   41916:	b082      	sub	sp, #8
   41918:	4604      	mov	r4, r0
	err = lll_hfclock_on();
   4191a:	f7fe f961 	bl	3fbe0 <lll_hfclock_on>
	LL_ASSERT(err >= 0);
   4191e:	2800      	cmp	r0, #0
   41920:	db19      	blt.n	41956 <lll_central_prepare+0x42>
	err = lll_prepare(lll_is_abort_cb, lll_conn_abort_cb, prepare_cb, 0,
   41922:	4a13      	ldr	r2, [pc, #76]	; (41970 <lll_central_prepare+0x5c>)
   41924:	4913      	ldr	r1, [pc, #76]	; (41974 <lll_central_prepare+0x60>)
   41926:	4814      	ldr	r0, [pc, #80]	; (41978 <lll_central_prepare+0x64>)
   41928:	9400      	str	r4, [sp, #0]
   4192a:	2300      	movs	r3, #0
   4192c:	f7f6 ff02 	bl	38734 <lll_prepare>
	LL_ASSERT(!err || err == -EINPROGRESS);
   41930:	b108      	cbz	r0, 41936 <lll_central_prepare+0x22>
   41932:	3077      	adds	r0, #119	; 0x77
   41934:	d101      	bne.n	4193a <lll_central_prepare+0x26>
}
   41936:	b002      	add	sp, #8
   41938:	bd10      	pop	{r4, pc}
	LL_ASSERT(!err || err == -EINPROGRESS);
   4193a:	4a10      	ldr	r2, [pc, #64]	; (4197c <lll_central_prepare+0x68>)
   4193c:	4910      	ldr	r1, [pc, #64]	; (41980 <lll_central_prepare+0x6c>)
   4193e:	4811      	ldr	r0, [pc, #68]	; (41984 <lll_central_prepare+0x70>)
   41940:	2351      	movs	r3, #81	; 0x51
   41942:	f007 fb9f 	bl	49084 <assert_print>
   41946:	4040      	eors	r0, r0
   41948:	f380 8811 	msr	BASEPRI, r0
   4194c:	f04f 0003 	mov.w	r0, #3
   41950:	df02      	svc	2
}
   41952:	b002      	add	sp, #8
   41954:	bd10      	pop	{r4, pc}
	LL_ASSERT(err >= 0);
   41956:	4a09      	ldr	r2, [pc, #36]	; (4197c <lll_central_prepare+0x68>)
   41958:	490b      	ldr	r1, [pc, #44]	; (41988 <lll_central_prepare+0x74>)
   4195a:	480a      	ldr	r0, [pc, #40]	; (41984 <lll_central_prepare+0x70>)
   4195c:	234c      	movs	r3, #76	; 0x4c
   4195e:	f007 fb91 	bl	49084 <assert_print>
   41962:	4040      	eors	r0, r0
   41964:	f380 8811 	msr	BASEPRI, r0
   41968:	f04f 0003 	mov.w	r0, #3
   4196c:	df02      	svc	2
   4196e:	e7d8      	b.n	41922 <lll_central_prepare+0xe>
   41970:	000417b5 	.word	0x000417b5
   41974:	00040d79 	.word	0x00040d79
   41978:	0003f7a5 	.word	0x0003f7a5
   4197c:	00052cec 	.word	0x00052cec
   41980:	00052bcc 	.word	0x00052bcc
   41984:	0005214c 	.word	0x0005214c
   41988:	00052af8 	.word	0x00052af8

0004198c <cntr_init>:

static uint8_t _refcount;

void cntr_init(void)
{
	NRF_RTC->PRESCALER = 0;
   4198c:	4b05      	ldr	r3, [pc, #20]	; (419a4 <cntr_init+0x18>)
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
}

NRF_STATIC_INLINE void nrf_rtc_event_enable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENSET = mask;
   4198e:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   41992:	2100      	movs	r1, #0
   41994:	f8c3 1508 	str.w	r1, [r3, #1288]	; 0x508
   41998:	f8c3 2344 	str.w	r2, [r3, #836]	; 0x344
    p_reg->INTENSET = mask;
   4199c:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
	nrf_rtc_event_enable(NRF_RTC, RTC_EVTENSET_COMPARE0_Msk);
	nrf_rtc_int_enable(NRF_RTC, RTC_INTENSET_COMPARE0_Msk);
}
   419a0:	4770      	bx	lr
   419a2:	bf00      	nop
   419a4:	4000b000 	.word	0x4000b000

000419a8 <cntr_start>:

uint32_t cntr_start(void)
{
	if (_refcount++) {
   419a8:	4b05      	ldr	r3, [pc, #20]	; (419c0 <cntr_start+0x18>)
   419aa:	7818      	ldrb	r0, [r3, #0]
   419ac:	1c42      	adds	r2, r0, #1
   419ae:	701a      	strb	r2, [r3, #0]
   419b0:	b918      	cbnz	r0, 419ba <cntr_start+0x12>
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
   419b2:	4b04      	ldr	r3, [pc, #16]	; (419c4 <cntr_start+0x1c>)
   419b4:	2201      	movs	r2, #1
   419b6:	601a      	str	r2, [r3, #0]
		return 1;
	}

	nrf_rtc_task_trigger(NRF_RTC, NRF_RTC_TASK_START);

	return 0;
   419b8:	4770      	bx	lr
		return 1;
   419ba:	2001      	movs	r0, #1
}
   419bc:	4770      	bx	lr
   419be:	bf00      	nop
   419c0:	20006bb7 	.word	0x20006bb7
   419c4:	4000b000 	.word	0x4000b000

000419c8 <cntr_stop>:

uint32_t cntr_stop(void)
{
   419c8:	b510      	push	{r4, lr}
	LL_ASSERT(_refcount);
   419ca:	4c0d      	ldr	r4, [pc, #52]	; (41a00 <cntr_stop+0x38>)
   419cc:	7820      	ldrb	r0, [r4, #0]
   419ce:	b148      	cbz	r0, 419e4 <cntr_stop+0x1c>

	if (--_refcount) {
   419d0:	3801      	subs	r0, #1
   419d2:	b2c0      	uxtb	r0, r0
   419d4:	7020      	strb	r0, [r4, #0]
   419d6:	b918      	cbnz	r0, 419e0 <cntr_stop+0x18>
   419d8:	4b0a      	ldr	r3, [pc, #40]	; (41a04 <cntr_stop+0x3c>)
   419da:	2201      	movs	r2, #1
   419dc:	605a      	str	r2, [r3, #4]
	}

	nrf_rtc_task_trigger(NRF_RTC, NRF_RTC_TASK_STOP);

	return 0;
}
   419de:	bd10      	pop	{r4, pc}
		return 1;
   419e0:	2001      	movs	r0, #1
}
   419e2:	bd10      	pop	{r4, pc}
	LL_ASSERT(_refcount);
   419e4:	4a08      	ldr	r2, [pc, #32]	; (41a08 <cntr_stop+0x40>)
   419e6:	4909      	ldr	r1, [pc, #36]	; (41a0c <cntr_stop+0x44>)
   419e8:	4809      	ldr	r0, [pc, #36]	; (41a10 <cntr_stop+0x48>)
   419ea:	232d      	movs	r3, #45	; 0x2d
   419ec:	f007 fb4a 	bl	49084 <assert_print>
   419f0:	4040      	eors	r0, r0
   419f2:	f380 8811 	msr	BASEPRI, r0
   419f6:	f04f 0003 	mov.w	r0, #3
   419fa:	df02      	svc	2
	if (--_refcount) {
   419fc:	7820      	ldrb	r0, [r4, #0]
   419fe:	e7e7      	b.n	419d0 <cntr_stop+0x8>
   41a00:	20006bb7 	.word	0x20006bb7
   41a04:	4000b000 	.word	0x4000b000
   41a08:	00052d3c 	.word	0x00052d3c
   41a0c:	00052d88 	.word	0x00052d88
   41a10:	0005214c 	.word	0x0005214c

00041a14 <cntr_cnt_get>:
     return p_reg->COUNTER;
   41a14:	4b01      	ldr	r3, [pc, #4]	; (41a1c <cntr_cnt_get+0x8>)
   41a16:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504

uint32_t cntr_cnt_get(void)
{
	return nrf_rtc_counter_get(NRF_RTC);
}
   41a1a:	4770      	bx	lr
   41a1c:	4000b000 	.word	0x4000b000

00041a20 <cntr_cmp_set>:
    p_reg->CC[ch] = cc_val;
   41a20:	4b02      	ldr	r3, [pc, #8]	; (41a2c <cntr_cmp_set+0xc>)
   41a22:	f500 70a8 	add.w	r0, r0, #336	; 0x150
   41a26:	f843 1020 	str.w	r1, [r3, r0, lsl #2]

void cntr_cmp_set(uint8_t cmp, uint32_t value)
{
	nrf_rtc_cc_set(NRF_RTC, cmp, value);
}
   41a2a:	4770      	bx	lr
   41a2c:	4000b000 	.word	0x4000b000

00041a30 <do_ecb>:

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_ecb_task_trigger(NRF_ECB_Type * p_reg, nrf_ecb_task_t task)
{
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   41a30:	4b12      	ldr	r3, [pc, #72]	; (41a7c <do_ecb+0x4c>)
	uint8_t clear_text[16];
	uint8_t cipher_text[16];
} __packed;

static void do_ecb(struct ecb_param *ecb)
{
   41a32:	b430      	push	{r4, r5}
   41a34:	2101      	movs	r1, #1
   41a36:	4604      	mov	r4, r0
	do {
		nrf_ecb_task_trigger(NRF_ECB, NRF_ECB_TASK_STOPECB);
		NRF_ECB->ECBDATAPTR = (uint32_t)ecb;
		NRF_ECB->EVENTS_ENDECB = 0;
   41a38:	2000      	movs	r0, #0
   41a3a:	6059      	str	r1, [r3, #4]
		NRF_ECB->ECBDATAPTR = (uint32_t)ecb;
   41a3c:	f8c3 4504 	str.w	r4, [r3, #1284]	; 0x504
		NRF_ECB->EVENTS_ENDECB = 0;
   41a40:	f8c3 0100 	str.w	r0, [r3, #256]	; 0x100
		NRF_ECB->EVENTS_ERRORECB = 0;
   41a44:	f8c3 0104 	str.w	r0, [r3, #260]	; 0x104
   41a48:	6019      	str	r1, [r3, #0]
}
   41a4a:	e005      	b.n	41a58 <do_ecb+0x28>
		nrf_ecb_task_trigger(NRF_ECB, NRF_ECB_TASK_STARTECB);
		while ((NRF_ECB->EVENTS_ENDECB == 0) &&
		       (NRF_ECB->EVENTS_ERRORECB == 0) &&
   41a4c:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
		while ((NRF_ECB->EVENTS_ENDECB == 0) &&
   41a50:	b932      	cbnz	r2, 41a60 <do_ecb+0x30>
		       (NRF_ECB->ECBDATAPTR != 0)) {
   41a52:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
		       (NRF_ECB->EVENTS_ERRORECB == 0) &&
   41a56:	b11a      	cbz	r2, 41a60 <do_ecb+0x30>
		while ((NRF_ECB->EVENTS_ENDECB == 0) &&
   41a58:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
		       (NRF_ECB->EVENTS_ERRORECB == 0) &&
   41a5c:	2a00      	cmp	r2, #0
   41a5e:	d0f5      	beq.n	41a4c <do_ecb+0x1c>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   41a60:	6059      	str	r1, [r3, #4]
#else
			/*__WFE();*/
#endif
		}
		nrf_ecb_task_trigger(NRF_ECB, NRF_ECB_TASK_STOPECB);
	} while ((NRF_ECB->EVENTS_ERRORECB != 0) || (NRF_ECB->ECBDATAPTR == 0));
   41a62:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
   41a66:	2a00      	cmp	r2, #0
   41a68:	d1e7      	bne.n	41a3a <do_ecb+0xa>
   41a6a:	f8d3 5504 	ldr.w	r5, [r3, #1284]	; 0x504
   41a6e:	2d00      	cmp	r5, #0
   41a70:	d0e3      	beq.n	41a3a <do_ecb+0xa>

	NRF_ECB->ECBDATAPTR = 0;
   41a72:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
}
   41a76:	bc30      	pop	{r4, r5}
   41a78:	4770      	bx	lr
   41a7a:	bf00      	nop
   41a7c:	4000e000 	.word	0x4000e000

00041a80 <ecb_encrypt>:
	memcpy(cipher_text_be, &ecb.cipher_text[0], sizeof(ecb.cipher_text));
}

void ecb_encrypt(uint8_t const *const key_le, uint8_t const *const clear_text_le,
		 uint8_t * const cipher_text_le, uint8_t * const cipher_text_be)
{
   41a80:	b570      	push	{r4, r5, r6, lr}
   41a82:	b08c      	sub	sp, #48	; 0x30
   41a84:	460e      	mov	r6, r1
   41a86:	4615      	mov	r5, r2
	struct ecb_param ecb;

	mem_rcopy(&ecb.key[0], key_le, sizeof(ecb.key));
   41a88:	4601      	mov	r1, r0
   41a8a:	2210      	movs	r2, #16
   41a8c:	4668      	mov	r0, sp
{
   41a8e:	461c      	mov	r4, r3
	mem_rcopy(&ecb.key[0], key_le, sizeof(ecb.key));
   41a90:	f7f2 fd50 	bl	34534 <mem_rcopy>
	mem_rcopy(&ecb.clear_text[0], clear_text_le, sizeof(ecb.clear_text));
   41a94:	2210      	movs	r2, #16
   41a96:	eb0d 0002 	add.w	r0, sp, r2
   41a9a:	4631      	mov	r1, r6
   41a9c:	f7f2 fd4a 	bl	34534 <mem_rcopy>

	do_ecb(&ecb);
   41aa0:	4668      	mov	r0, sp
   41aa2:	f7ff ffc5 	bl	41a30 <do_ecb>

	if (cipher_text_le) {
   41aa6:	b125      	cbz	r5, 41ab2 <ecb_encrypt+0x32>
		mem_rcopy(cipher_text_le, &ecb.cipher_text[0],
   41aa8:	2210      	movs	r2, #16
   41aaa:	a908      	add	r1, sp, #32
   41aac:	4628      	mov	r0, r5
   41aae:	f7f2 fd41 	bl	34534 <mem_rcopy>
			  sizeof(ecb.cipher_text));
	}

	if (cipher_text_be) {
   41ab2:	b124      	cbz	r4, 41abe <ecb_encrypt+0x3e>
		memcpy(cipher_text_be, &ecb.cipher_text[0],
   41ab4:	2210      	movs	r2, #16
   41ab6:	a908      	add	r1, sp, #32
   41ab8:	4620      	mov	r0, r4
   41aba:	f009 f9de 	bl	4ae7a <memcpy>
			 sizeof(ecb.cipher_text));
	}
}
   41abe:	b00c      	add	sp, #48	; 0x30
   41ac0:	bd70      	pop	{r4, r5, r6, pc}
   41ac2:	bf00      	nop

00041ac4 <isr_radio>:
}
#endif /* !CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */

uint32_t radio_has_disabled(void)
{
	return (NRF_RADIO->EVENTS_DISABLED != 0);
   41ac4:	4b04      	ldr	r3, [pc, #16]	; (41ad8 <isr_radio+0x14>)
   41ac6:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
	if (radio_has_disabled()) {
   41aca:	b123      	cbz	r3, 41ad6 <isr_radio+0x12>
		isr_cb(isr_cb_param);
   41acc:	4a03      	ldr	r2, [pc, #12]	; (41adc <isr_radio+0x18>)
   41ace:	4b04      	ldr	r3, [pc, #16]	; (41ae0 <isr_radio+0x1c>)
   41ad0:	6810      	ldr	r0, [r2, #0]
   41ad2:	681b      	ldr	r3, [r3, #0]
   41ad4:	4718      	bx	r3
}
   41ad6:	4770      	bx	lr
   41ad8:	40001000 	.word	0x40001000
   41adc:	20005c3c 	.word	0x20005c3c
   41ae0:	20005c40 	.word	0x20005c40

00041ae4 <radio_isr_set>:
{
   41ae4:	b538      	push	{r3, r4, r5, lr}
   41ae6:	4604      	mov	r4, r0
	irq_disable(RADIO_IRQn);
   41ae8:	2001      	movs	r0, #1
{
   41aea:	460d      	mov	r5, r1
	irq_disable(RADIO_IRQn);
   41aec:	f7eb f970 	bl	2cdd0 <arch_irq_disable>
	isr_cb = cb;
   41af0:	4b08      	ldr	r3, [pc, #32]	; (41b14 <radio_isr_set+0x30>)
	isr_cb_param = param;
   41af2:	4a09      	ldr	r2, [pc, #36]	; (41b18 <radio_isr_set+0x34>)
	isr_cb = cb;
   41af4:	601c      	str	r4, [r3, #0]
    return p_reg->SHORTS;
}

NRF_STATIC_INLINE void nrf_radio_int_enable(NRF_RADIO_Type * p_reg, uint32_t mask)
{
    p_reg->INTENSET = mask;
   41af6:	4909      	ldr	r1, [pc, #36]	; (41b1c <radio_isr_set+0x38>)
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   41af8:	4b09      	ldr	r3, [pc, #36]	; (41b20 <radio_isr_set+0x3c>)
	isr_cb_param = param;
   41afa:	6015      	str	r5, [r2, #0]
   41afc:	2010      	movs	r0, #16
   41afe:	2202      	movs	r2, #2
   41b00:	f8c1 0304 	str.w	r0, [r1, #772]	; 0x304
   41b04:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
}
   41b08:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	irq_enable(RADIO_IRQn);
   41b0c:	2001      	movs	r0, #1
   41b0e:	f7eb b951 	b.w	2cdb4 <arch_irq_enable>
   41b12:	bf00      	nop
   41b14:	20005c40 	.word	0x20005c40
   41b18:	20005c3c 	.word	0x20005c3c
   41b1c:	40001000 	.word	0x40001000
   41b20:	e000e100 	.word	0xe000e100

00041b24 <radio_setup>:
			uint32_t volatile PDM;
			uint32_t volatile PWM;
		} RAMPRI;
	} volatile *NRF_AMLI = (void volatile *)0x40000000UL;

	NRF_AMLI->RAMPRI.CPU0    = 0xFFFFFFFFUL;
   41b24:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   41b28:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
	NRF_AMLI->RAMPRI.SPIS1   = 0xFFFFFFFFUL;
	NRF_AMLI->RAMPRI.RADIO   = 0x00000000UL;
   41b2c:	2100      	movs	r1, #0
	NRF_AMLI->RAMPRI.CPU0    = 0xFFFFFFFFUL;
   41b2e:	f8c3 2e00 	str.w	r2, [r3, #3584]	; 0xe00
	NRF_AMLI->RAMPRI.SPIS1   = 0xFFFFFFFFUL;
   41b32:	f8c3 2e04 	str.w	r2, [r3, #3588]	; 0xe04
	NRF_AMLI->RAMPRI.RADIO   = 0x00000000UL;
   41b36:	f8c3 1e08 	str.w	r1, [r3, #3592]	; 0xe08
	NRF_AMLI->RAMPRI.ECB     = 0xFFFFFFFFUL;
   41b3a:	f8c3 2e0c 	str.w	r2, [r3, #3596]	; 0xe0c
	NRF_AMLI->RAMPRI.CCM     = 0x00000000UL;
   41b3e:	f8c3 1e10 	str.w	r1, [r3, #3600]	; 0xe10
	NRF_AMLI->RAMPRI.AAR     = 0xFFFFFFFFUL;
   41b42:	f8c3 2e14 	str.w	r2, [r3, #3604]	; 0xe14
	NRF_AMLI->RAMPRI.SAADC   = 0xFFFFFFFFUL;
   41b46:	f8c3 2e18 	str.w	r2, [r3, #3608]	; 0xe18
	NRF_AMLI->RAMPRI.UARTE   = 0xFFFFFFFFUL;
   41b4a:	f8c3 2e1c 	str.w	r2, [r3, #3612]	; 0xe1c
	NRF_AMLI->RAMPRI.SERIAL0 = 0xFFFFFFFFUL;
   41b4e:	f8c3 2e20 	str.w	r2, [r3, #3616]	; 0xe20
	NRF_AMLI->RAMPRI.SERIAL2 = 0xFFFFFFFFUL;
   41b52:	f8c3 2e24 	str.w	r2, [r3, #3620]	; 0xe24
	NRF_AMLI->RAMPRI.NFCT    = 0xFFFFFFFFUL;
   41b56:	f8c3 2e28 	str.w	r2, [r3, #3624]	; 0xe28
	NRF_AMLI->RAMPRI.I2S     = 0xFFFFFFFFUL;
   41b5a:	f8c3 2e2c 	str.w	r2, [r3, #3628]	; 0xe2c
	NRF_AMLI->RAMPRI.PDM     = 0xFFFFFFFFUL;
   41b5e:	f8c3 2e30 	str.w	r2, [r3, #3632]	; 0xe30
	NRF_AMLI->RAMPRI.PWM     = 0xFFFFFFFFUL;
   41b62:	f8c3 2e34 	str.w	r2, [r3, #3636]	; 0xe34
}
   41b66:	4770      	bx	lr

00041b68 <radio_reset>:
{
   41b68:	b510      	push	{r4, lr}
	irq_disable(RADIO_IRQn);
   41b6a:	2001      	movs	r0, #1
   41b6c:	f7eb f930 	bl	2cdd0 <arch_irq_disable>
}
#endif

NRF_STATIC_INLINE void nrf_radio_power_set(NRF_RADIO_Type * p_reg, bool radio_power)
{
    p_reg->POWER = (radio_power ? RADIO_POWER_POWER_Enabled : RADIO_POWER_POWER_Disabled)
   41b70:	4a08      	ldr	r2, [pc, #32]	; (41b94 <radio_reset+0x2c>)
static inline void hal_radio_sw_switch_ppi_group_setup(void)
{
	/* Include the appropriate PPI channels in the two PPI Groups. */
#if !defined(CONFIG_BT_CTLR_PHY_CODED) || \
	!defined(CONFIG_HAS_HW_NRF_RADIO_BLE_CODED)
	NRF_PPI->CHG[SW_SWITCH_TIMER_TASK_GROUP(0)] =
   41b72:	4b09      	ldr	r3, [pc, #36]	; (41b98 <radio_reset+0x30>)
   41b74:	2400      	movs	r4, #0
   41b76:	2001      	movs	r0, #1
   41b78:	f8c2 4ffc 	str.w	r4, [r2, #4092]	; 0xffc
   41b7c:	f44f 5190 	mov.w	r1, #4608	; 0x1200
   41b80:	f8c2 0ffc 	str.w	r0, [r2, #4092]	; 0xffc
		BIT(HAL_SW_SWITCH_GROUP_TASK_DISABLE_PPI(0)) |
#if defined(CONFIG_BT_CTLR_DF_PHYEND_OFFSET_COMPENSATION_ENABLE)
		BIT(HAL_SW_SWITCH_RADIO_ENABLE_PHYEND_DELAY_COMPENSATION_PPI(0)) |
#endif /* CONFIG_BT_CTLR_DF_PHYEND_OFFSET_COMPENSATION_ENABLE */
		BIT(HAL_SW_SWITCH_RADIO_ENABLE_PPI(0));
	NRF_PPI->CHG[SW_SWITCH_TIMER_TASK_GROUP(1)] =
   41b84:	f44f 5210 	mov.w	r2, #9216	; 0x2400
	NRF_PPI->CHG[SW_SWITCH_TIMER_TASK_GROUP(0)] =
   41b88:	f8c3 1800 	str.w	r1, [r3, #2048]	; 0x800
	NRF_PPI->CHG[SW_SWITCH_TIMER_TASK_GROUP(1)] =
   41b8c:	f8c3 2804 	str.w	r2, [r3, #2052]	; 0x804
}
   41b90:	bd10      	pop	{r4, pc}
   41b92:	bf00      	nop
   41b94:	40001000 	.word	0x40001000
   41b98:	4001f000 	.word	0x4001f000

00041b9c <radio_stop>:
}
   41b9c:	4770      	bx	lr
   41b9e:	bf00      	nop

00041ba0 <radio_phy_set>:
	NRF_RADIO->MODE = (mode << RADIO_MODE_MODE_Pos) & RADIO_MODE_MODE_Msk;
   41ba0:	4b06      	ldr	r3, [pc, #24]	; (41bbc <radio_phy_set+0x1c>)
	uint32_t mode;

	switch (phy) {
	case BIT(0):
	default:
		mode = RADIO_MODE_MODE_Ble_1Mbit;
   41ba2:	2802      	cmp	r0, #2
   41ba4:	bf0c      	ite	eq
   41ba6:	2204      	moveq	r2, #4
   41ba8:	2203      	movne	r2, #3
   41baa:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
	NRF_RADIO->MODECNF0 |= (RADIO_MODECNF0_RU_Fast <<
   41bae:	f8d3 2650 	ldr.w	r2, [r3, #1616]	; 0x650
   41bb2:	f042 0201 	orr.w	r2, r2, #1
   41bb6:	f8c3 2650 	str.w	r2, [r3, #1616]	; 0x650
}
   41bba:	4770      	bx	lr
   41bbc:	40001000 	.word	0x40001000

00041bc0 <radio_tx_power_set>:
	NRF_RADIO->TXPOWER = (uint32_t)power;
   41bc0:	4b01      	ldr	r3, [pc, #4]	; (41bc8 <radio_tx_power_set+0x8>)
   41bc2:	f8c3 050c 	str.w	r0, [r3, #1292]	; 0x50c
}
   41bc6:	4770      	bx	lr
   41bc8:	40001000 	.word	0x40001000

00041bcc <radio_freq_chan_set>:
	NRF_RADIO->FREQUENCY = chan;
   41bcc:	4b01      	ldr	r3, [pc, #4]	; (41bd4 <radio_freq_chan_set+0x8>)
   41bce:	f8c3 0508 	str.w	r0, [r3, #1288]	; 0x508
}
   41bd2:	4770      	bx	lr
   41bd4:	40001000 	.word	0x40001000

00041bd8 <radio_whiten_iv_set>:
	NRF_RADIO->DATAWHITEIV = iv;
   41bd8:	4b07      	ldr	r3, [pc, #28]	; (41bf8 <radio_whiten_iv_set+0x20>)
   41bda:	f8c3 0554 	str.w	r0, [r3, #1364]	; 0x554
	NRF_RADIO->PCNF1 &= ~RADIO_PCNF1_WHITEEN_Msk;
   41bde:	f8d3 2518 	ldr.w	r2, [r3, #1304]	; 0x518
   41be2:	f022 7200 	bic.w	r2, r2, #33554432	; 0x2000000
   41be6:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
	NRF_RADIO->PCNF1 |= ((1UL) << RADIO_PCNF1_WHITEEN_Pos) &
   41bea:	f8d3 2518 	ldr.w	r2, [r3, #1304]	; 0x518
   41bee:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
   41bf2:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
}
   41bf6:	4770      	bx	lr
   41bf8:	40001000 	.word	0x40001000

00041bfc <radio_aa_set>:
	NRF_RADIO->TXADDRESS =
   41bfc:	4a0a      	ldr	r2, [pc, #40]	; (41c28 <radio_aa_set+0x2c>)
   41bfe:	2100      	movs	r1, #0
	NRF_RADIO->RXADDRESSES =
   41c00:	2301      	movs	r3, #1
	NRF_RADIO->TXADDRESS =
   41c02:	f8c2 152c 	str.w	r1, [r2, #1324]	; 0x52c
	NRF_RADIO->RXADDRESSES =
   41c06:	f8c2 3530 	str.w	r3, [r2, #1328]	; 0x530
	NRF_RADIO->PREFIX0 = aa[3];
   41c0a:	78c3      	ldrb	r3, [r0, #3]
   41c0c:	f8c2 3524 	str.w	r3, [r2, #1316]	; 0x524
	NRF_RADIO->BASE0 = (aa[2] << 24) | (aa[1] << 16) | (aa[0] << 8);
   41c10:	7843      	ldrb	r3, [r0, #1]
   41c12:	f890 c002 	ldrb.w	ip, [r0, #2]
   41c16:	7801      	ldrb	r1, [r0, #0]
   41c18:	041b      	lsls	r3, r3, #16
   41c1a:	ea43 630c 	orr.w	r3, r3, ip, lsl #24
   41c1e:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
   41c22:	f8c2 351c 	str.w	r3, [r2, #1308]	; 0x51c
}
   41c26:	4770      	bx	lr
   41c28:	40001000 	.word	0x40001000

00041c2c <radio_pkt_configure>:
	switch (phy) {
   41c2c:	f3c2 0342 	ubfx	r3, r2, #1, #3
   41c30:	f1a3 0302 	sub.w	r3, r3, #2
   41c34:	fab3 f383 	clz	r3, r3
   41c38:	095b      	lsrs	r3, r3, #5
   41c3a:	061b      	lsls	r3, r3, #24
	if (pdu_type == RADIO_PKT_CONF_PDU_TYPE_DC) {
   41c3c:	07d2      	lsls	r2, r2, #31
		extra |= (RADIO_PCNF0_S1INCL_Include <<
   41c3e:	bf48      	it	mi
   41c40:	f443 1380 	orrmi.w	r3, r3, #1048576	; 0x100000
		((((uint32_t)bits_len) << RADIO_PCNF0_LFLEN_Pos) & RADIO_PCNF0_LFLEN_Msk) |
   41c44:	f000 000f 	and.w	r0, r0, #15
	NRF_RADIO->PCNF0 =
   41c48:	4a09      	ldr	r2, [pc, #36]	; (41c70 <radio_pkt_configure+0x44>)
		((((uint32_t)bits_s1) << RADIO_PCNF0_S1LEN_Pos) & RADIO_PCNF0_S1LEN_Msk) | extra;
   41c4a:	4318      	orrs	r0, r3
   41c4c:	f440 7080 	orr.w	r0, r0, #256	; 0x100
	NRF_RADIO->PCNF0 =
   41c50:	f8c2 0514 	str.w	r0, [r2, #1300]	; 0x514
	NRF_RADIO->PCNF1 &= ~(RADIO_PCNF1_MAXLEN_Msk | RADIO_PCNF1_STATLEN_Msk |
   41c54:	f8d2 0518 	ldr.w	r0, [r2, #1304]	; 0x518
   41c58:	4b06      	ldr	r3, [pc, #24]	; (41c74 <radio_pkt_configure+0x48>)
   41c5a:	4003      	ands	r3, r0
   41c5c:	f8c2 3518 	str.w	r3, [r2, #1304]	; 0x518
	NRF_RADIO->PCNF1 |=
   41c60:	f8d2 3518 	ldr.w	r3, [r2, #1304]	; 0x518
   41c64:	4319      	orrs	r1, r3
   41c66:	f441 3140 	orr.w	r1, r1, #196608	; 0x30000
   41c6a:	f8c2 1518 	str.w	r1, [r2, #1304]	; 0x518
}
   41c6e:	4770      	bx	lr
   41c70:	40001000 	.word	0x40001000
   41c74:	fef80000 	.word	0xfef80000

00041c78 <radio_pkt_rx_set>:
	NRF_RADIO->PACKETPTR = (uint32_t)rx_packet;
   41c78:	4b01      	ldr	r3, [pc, #4]	; (41c80 <radio_pkt_rx_set+0x8>)
   41c7a:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
}
   41c7e:	4770      	bx	lr
   41c80:	40001000 	.word	0x40001000

00041c84 <radio_pkt_tx_set>:
void radio_pkt_tx_set(void *tx_packet)
   41c84:	4b01      	ldr	r3, [pc, #4]	; (41c8c <radio_pkt_tx_set+0x8>)
   41c86:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
   41c8a:	4770      	bx	lr
   41c8c:	40001000 	.word	0x40001000

00041c90 <radio_tx_ready_delay_get>:
static inline uint32_t hal_radio_tx_ready_delay_us_get(uint8_t phy, uint8_t flags)
{
	switch (phy) {
	default:
	case BIT(0):
		return HAL_RADIO_NRF52840_TXEN_TXIDLE_TX_1M_US;
   41c90:	2802      	cmp	r0, #2
}
   41c92:	bf0c      	ite	eq
   41c94:	2028      	moveq	r0, #40	; 0x28
   41c96:	2029      	movne	r0, #41	; 0x29
   41c98:	4770      	bx	lr
   41c9a:	bf00      	nop

00041c9c <radio_tx_chain_delay_get>:
}
   41c9c:	2001      	movs	r0, #1
   41c9e:	4770      	bx	lr

00041ca0 <radio_rx_ready_delay_get>:
}
   41ca0:	2029      	movs	r0, #41	; 0x29
   41ca2:	4770      	bx	lr

00041ca4 <radio_rx_chain_delay_get>:
static inline uint32_t hal_radio_rx_chain_delay_us_get(uint8_t phy, uint8_t flags)
{
	switch (phy) {
	default:
	case BIT(0):
		return HAL_RADIO_NRF52840_RX_CHAIN_DELAY_1M_US;
   41ca4:	2802      	cmp	r0, #2
}
   41ca6:	bf0c      	ite	eq
   41ca8:	2005      	moveq	r0, #5
   41caa:	200a      	movne	r0, #10
   41cac:	4770      	bx	lr
   41cae:	bf00      	nop

00041cb0 <radio_rx_enable>:
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   41cb0:	4b01      	ldr	r3, [pc, #4]	; (41cb8 <radio_rx_enable+0x8>)
   41cb2:	2201      	movs	r2, #1
   41cb4:	605a      	str	r2, [r3, #4]
}
   41cb6:	4770      	bx	lr
   41cb8:	40001000 	.word	0x40001000

00041cbc <radio_tx_enable>:
   41cbc:	4b01      	ldr	r3, [pc, #4]	; (41cc4 <radio_tx_enable+0x8>)
   41cbe:	2201      	movs	r2, #1
   41cc0:	601a      	str	r2, [r3, #0]
}
   41cc2:	4770      	bx	lr
   41cc4:	40001000 	.word	0x40001000

00041cc8 <radio_disable>:
    p_reg->CHENSET = mask;
}

NRF_STATIC_INLINE void nrf_ppi_channels_disable(NRF_PPI_Type * p_reg, uint32_t mask)
{
    p_reg->CHENCLR = mask;
   41cc8:	4a07      	ldr	r2, [pc, #28]	; (41ce8 <radio_disable+0x20>)
	NRF_RADIO->SHORTS = 0;
   41cca:	4908      	ldr	r1, [pc, #32]	; (41cec <radio_disable+0x24>)
{
   41ccc:	b410      	push	{r4}
    p_reg->TASKS_CHG[(uint32_t) group].EN = 1UL;
}

NRF_STATIC_INLINE void nrf_ppi_group_disable(NRF_PPI_Type * p_reg, nrf_ppi_channel_group_t group)
{
    p_reg->TASKS_CHG[(uint32_t) group].DIS = 1UL;
   41cce:	2301      	movs	r3, #1
    p_reg->CHENCLR = mask;
   41cd0:	f44f 6410 	mov.w	r4, #2304	; 0x900
	NRF_RADIO->SHORTS = 0;
   41cd4:	2000      	movs	r0, #0
   41cd6:	f8c2 4508 	str.w	r4, [r2, #1288]	; 0x508
    p_reg->TASKS_CHG[(uint32_t) group].DIS = 1UL;
   41cda:	6053      	str	r3, [r2, #4]
   41cdc:	60d3      	str	r3, [r2, #12]
   41cde:	f8c1 0200 	str.w	r0, [r1, #512]	; 0x200
   41ce2:	610b      	str	r3, [r1, #16]
}
   41ce4:	bc10      	pop	{r4}
   41ce6:	4770      	bx	lr
   41ce8:	4001f000 	.word	0x4001f000
   41cec:	40001000 	.word	0x40001000

00041cf0 <radio_status_reset>:
	NRF_RADIO->EVENTS_READY = 0;
   41cf0:	4b04      	ldr	r3, [pc, #16]	; (41d04 <radio_status_reset+0x14>)
   41cf2:	2200      	movs	r2, #0
   41cf4:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
	NRF_RADIO->EVENTS_END = 0;
   41cf8:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
	NRF_RADIO->EVENTS_DISABLED = 0;
   41cfc:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
}
   41d00:	4770      	bx	lr
   41d02:	bf00      	nop
   41d04:	40001000 	.word	0x40001000

00041d08 <radio_is_ready>:
	return (NRF_RADIO->EVENTS_READY != 0);
   41d08:	4b03      	ldr	r3, [pc, #12]	; (41d18 <radio_is_ready+0x10>)
   41d0a:	f8d3 0100 	ldr.w	r0, [r3, #256]	; 0x100
}
   41d0e:	3800      	subs	r0, #0
   41d10:	bf18      	it	ne
   41d12:	2001      	movne	r0, #1
   41d14:	4770      	bx	lr
   41d16:	bf00      	nop
   41d18:	40001000 	.word	0x40001000

00041d1c <radio_is_done>:
	return (NRF_RADIO->NRF_RADIO_TXRX_END_EVENT != 0);
   41d1c:	4b03      	ldr	r3, [pc, #12]	; (41d2c <radio_is_done+0x10>)
   41d1e:	f8d3 010c 	ldr.w	r0, [r3, #268]	; 0x10c
}
   41d22:	3800      	subs	r0, #0
   41d24:	bf18      	it	ne
   41d26:	2001      	movne	r0, #1
   41d28:	4770      	bx	lr
   41d2a:	bf00      	nop
   41d2c:	40001000 	.word	0x40001000

00041d30 <radio_is_idle>:
}

uint32_t radio_is_idle(void)
{
	return (NRF_RADIO->STATE == 0);
   41d30:	4b03      	ldr	r3, [pc, #12]	; (41d40 <radio_is_idle+0x10>)
   41d32:	f8d3 0550 	ldr.w	r0, [r3, #1360]	; 0x550
}
   41d36:	fab0 f080 	clz	r0, r0
   41d3a:	0940      	lsrs	r0, r0, #5
   41d3c:	4770      	bx	lr
   41d3e:	bf00      	nop
   41d40:	40001000 	.word	0x40001000

00041d44 <radio_crc_configure>:

void radio_crc_configure(uint32_t polynomial, uint32_t iv)
{
	NRF_RADIO->CRCCNF =
   41d44:	4b04      	ldr	r3, [pc, #16]	; (41d58 <radio_crc_configure+0x14>)
   41d46:	f240 1203 	movw	r2, #259	; 0x103
   41d4a:	f8c3 2534 	str.w	r2, [r3, #1332]	; 0x534
	    (((RADIO_CRCCNF_SKIPADDR_Skip) << RADIO_CRCCNF_SKIPADDR_Pos) &
	     RADIO_CRCCNF_SKIPADDR_Msk) |
	    (((RADIO_CRCCNF_LEN_Three) << RADIO_CRCCNF_LEN_Pos) &
	       RADIO_CRCCNF_LEN_Msk);
	NRF_RADIO->CRCPOLY = polynomial;
   41d4e:	f8c3 0538 	str.w	r0, [r3, #1336]	; 0x538
	NRF_RADIO->CRCINIT = iv;
   41d52:	f8c3 153c 	str.w	r1, [r3, #1340]	; 0x53c
}
   41d56:	4770      	bx	lr
   41d58:	40001000 	.word	0x40001000

00041d5c <radio_crc_is_valid>:

uint32_t radio_crc_is_valid(void)
{
	return (NRF_RADIO->CRCSTATUS != 0);
   41d5c:	4b03      	ldr	r3, [pc, #12]	; (41d6c <radio_crc_is_valid+0x10>)
   41d5e:	f8d3 0400 	ldr.w	r0, [r3, #1024]	; 0x400
}
   41d62:	3800      	subs	r0, #0
   41d64:	bf18      	it	ne
   41d66:	2001      	movne	r0, #1
   41d68:	4770      	bx	lr
   41d6a:	bf00      	nop
   41d6c:	40001000 	.word	0x40001000

00041d70 <radio_pkt_empty_get>:
				       PDU_AC_LL_SIZE_MAX)];

void *radio_pkt_empty_get(void)
{
	return _pkt_empty;
}
   41d70:	4800      	ldr	r0, [pc, #0]	; (41d74 <radio_pkt_empty_get+0x4>)
   41d72:	4770      	bx	lr
   41d74:	20005c38 	.word	0x20005c38

00041d78 <radio_pkt_scratch_get>:

void *radio_pkt_scratch_get(void)
{
	return _pkt_scratch;
}
   41d78:	4800      	ldr	r0, [pc, #0]	; (41d7c <radio_pkt_scratch_get+0x4>)
   41d7a:	4770      	bx	lr
   41d7c:	20005b34 	.word	0x20005b34

00041d80 <radio_switch_complete_and_rx>:
	sw_tifs_toggle &= 1U;
}
#endif /* CONFIG_BT_CTLR_TIFS_HW */

void radio_switch_complete_and_rx(uint8_t phy_rx)
{
   41d80:	b4f0      	push	{r4, r5, r6, r7}
#if defined(CONFIG_BT_CTLR_TIFS_HW)
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
			    RADIO_SHORTS_END_DISABLE_Msk |
			    RADIO_SHORTS_DISABLED_RXEN_Msk;
#else /* !CONFIG_BT_CTLR_TIFS_HW */
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk | NRF_RADIO_SHORTS_PDU_END_DISABLE;
   41d82:	4b1d      	ldr	r3, [pc, #116]	; (41df8 <radio_switch_complete_and_rx+0x78>)
	uint8_t ppi = HAL_SW_SWITCH_RADIO_ENABLE_PPI(sw_tifs_toggle);
   41d84:	4d1d      	ldr	r5, [pc, #116]	; (41dfc <radio_switch_complete_and_rx+0x7c>)
    p_reg->CH[(uint32_t) channel].EEP = eep;
   41d86:	4e1e      	ldr	r6, [pc, #120]	; (41e00 <radio_switch_complete_and_rx+0x80>)
		HAL_SW_SWITCH_RADIO_ENABLE_PPI_EVT(compare_reg));
   41d88:	4c1e      	ldr	r4, [pc, #120]	; (41e04 <radio_switch_complete_and_rx+0x84>)
   41d8a:	4f1f      	ldr	r7, [pc, #124]	; (41e08 <radio_switch_complete_and_rx+0x88>)
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk | NRF_RADIO_SHORTS_PDU_END_DISABLE;
   41d8c:	2203      	movs	r2, #3
   41d8e:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
	uint8_t ppi = HAL_SW_SWITCH_RADIO_ENABLE_PPI(sw_tifs_toggle);
   41d92:	782a      	ldrb	r2, [r5, #0]
   41d94:	f8c6 7568 	str.w	r7, [r6, #1384]	; 0x568
   41d98:	f102 030c 	add.w	r3, r2, #12
   41d9c:	b2db      	uxtb	r3, r3
		HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_TASK(ppi_group_index));
   41d9e:	00d0      	lsls	r0, r2, #3
   41da0:	00db      	lsls	r3, r3, #3
		HAL_SW_SWITCH_RADIO_ENABLE_PPI_EVT(compare_reg));
   41da2:	0091      	lsls	r1, r2, #2
   41da4:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
		HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_TASK(ppi_group_index));
   41da8:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
   41dac:	f503 33f8 	add.w	r3, r3, #126976	; 0x1f000
   41db0:	f500 30f8 	add.w	r0, r0, #126976	; 0x1f000
    p_reg->CH[(uint32_t) channel].TEP = tep;
   41db4:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
   41db8:	f8c6 056c 	str.w	r0, [r6, #1388]	; 0x56c
	nrf_ppi_event_endpoint_setup(
   41dbc:	f501 4110 	add.w	r1, r1, #36864	; 0x9000
		HAL_SW_SWITCH_RADIO_ENABLE_PPI_EVT(compare_reg));
   41dc0:	eb04 0482 	add.w	r4, r4, r2, lsl #2
    p_reg->CH[(uint32_t) channel].TEP = tep;
   41dc4:	4811      	ldr	r0, [pc, #68]	; (41e0c <radio_switch_complete_and_rx+0x8c>)
    p_reg->CH[(uint32_t) channel].EEP = eep;
   41dc6:	f8c3 4510 	str.w	r4, [r3, #1296]	; 0x510
    p_reg->CH[(uint32_t) channel].TEP = tep;
   41dca:	f8c3 0514 	str.w	r0, [r3, #1300]	; 0x514
	if (delay < SW_SWITCH_TIMER->CC[cc]) {
   41dce:	f8d1 3540 	ldr.w	r3, [r1, #1344]	; 0x540
   41dd2:	2b2d      	cmp	r3, #45	; 0x2d
				 (SW_SWITCH_TIMER->CC[cc] - delay));
   41dd4:	bf8a      	itet	hi
   41dd6:	f8d1 3540 	ldrhi.w	r3, [r1, #1344]	; 0x540

NRF_STATIC_INLINE void nrf_timer_cc_set(NRF_TIMER_Type *       p_reg,
                                        nrf_timer_cc_channel_t cc_channel,
                                        uint32_t               cc_value)
{
    p_reg->CC[cc_channel] = cc_value;
   41dda:	2301      	movls	r3, #1
		nrf_timer_cc_set(SW_SWITCH_TIMER, cc,
   41ddc:	3b2d      	subhi	r3, #45	; 0x2d
   41dde:	f8c1 3540 	str.w	r3, [r1, #1344]	; 0x540
	sw_tifs_toggle += 1U;
   41de2:	3201      	adds	r2, #1
    p_reg->CHENSET = mask;
   41de4:	4b06      	ldr	r3, [pc, #24]	; (41e00 <radio_switch_complete_and_rx+0x80>)
   41de6:	f44f 6110 	mov.w	r1, #2304	; 0x900
	sw_tifs_toggle &= 1U;
   41dea:	f002 0201 	and.w	r2, r2, #1
   41dee:	f8c3 1504 	str.w	r1, [r3, #1284]	; 0x504
   41df2:	702a      	strb	r2, [r5, #0]
	 *       calculations.
	 */
	sw_switch(SW_SWITCH_TX, SW_SWITCH_RX, SW_SWITCH_PHY_1M, SW_SWITCH_FLAGS_DONTCARE, phy_rx,
		  SW_SWITCH_FLAGS_DONTCARE, END_EVT_DELAY_DISABLED);
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
   41df4:	bcf0      	pop	{r4, r5, r6, r7}
   41df6:	4770      	bx	lr
   41df8:	40001000 	.word	0x40001000
   41dfc:	20006bb8 	.word	0x20006bb8
   41e00:	4001f000 	.word	0x4001f000
   41e04:	40009140 	.word	0x40009140
   41e08:	4000110c 	.word	0x4000110c
   41e0c:	40001004 	.word	0x40001004

00041e10 <radio_switch_complete_and_tx>:

void radio_switch_complete_and_tx(uint8_t phy_rx, uint8_t flags_rx,
				  uint8_t phy_tx, uint8_t flags_tx)
{
   41e10:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
#if defined(CONFIG_BT_CTLR_TIFS_HW)
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
			    RADIO_SHORTS_END_DISABLE_Msk |
			    RADIO_SHORTS_DISABLED_TXEN_Msk;
#else /* !CONFIG_BT_CTLR_TIFS_HW */
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk | NRF_RADIO_SHORTS_PDU_END_DISABLE;
   41e14:	4e28      	ldr	r6, [pc, #160]	; (41eb8 <radio_switch_complete_and_tx+0xa8>)
	uint8_t ppi = HAL_SW_SWITCH_RADIO_ENABLE_PPI(sw_tifs_toggle);
   41e16:	4c29      	ldr	r4, [pc, #164]	; (41ebc <radio_switch_complete_and_tx+0xac>)
   41e18:	4f29      	ldr	r7, [pc, #164]	; (41ec0 <radio_switch_complete_and_tx+0xb0>)
    p_reg->CH[(uint32_t) channel].EEP = eep;
   41e1a:	f8df e0a8 	ldr.w	lr, [pc, #168]	; 41ec4 <radio_switch_complete_and_tx+0xb4>
   41e1e:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 41ec8 <radio_switch_complete_and_tx+0xb8>
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk | NRF_RADIO_SHORTS_PDU_END_DISABLE;
   41e22:	2303      	movs	r3, #3
   41e24:	f8c6 3200 	str.w	r3, [r6, #512]	; 0x200
	uint8_t ppi = HAL_SW_SWITCH_RADIO_ENABLE_PPI(sw_tifs_toggle);
   41e28:	7821      	ldrb	r1, [r4, #0]
   41e2a:	f8ce 8568 	str.w	r8, [lr, #1384]	; 0x568
   41e2e:	f101 030c 	add.w	r3, r1, #12
   41e32:	b2db      	uxtb	r3, r3
   41e34:	00db      	lsls	r3, r3, #3
		HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_TASK(ppi_group_index));
   41e36:	00cd      	lsls	r5, r1, #3
   41e38:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   41e3c:	f503 33f8 	add.w	r3, r3, #126976	; 0x1f000
   41e40:	f105 4580 	add.w	r5, r5, #1073741824	; 0x40000000
		HAL_SW_SWITCH_RADIO_ENABLE_PPI_EVT(compare_reg));
   41e44:	eb07 0781 	add.w	r7, r7, r1, lsl #2
		HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_TASK(ppi_group_index));
   41e48:	f505 35f8 	add.w	r5, r5, #126976	; 0x1f000
    p_reg->CH[(uint32_t) channel].TEP = tep;
   41e4c:	f8ce 556c 	str.w	r5, [lr, #1388]	; 0x56c
		HAL_SW_SWITCH_RADIO_ENABLE_PPI_EVT(compare_reg));
   41e50:	ea4f 0c81 	mov.w	ip, r1, lsl #2
    p_reg->CH[(uint32_t) channel].EEP = eep;
   41e54:	f8c3 7510 	str.w	r7, [r3, #1296]	; 0x510
	}
}

static inline uint32_t hal_radio_tx_ready_delay_ns_get(uint8_t phy, uint8_t flags)
{
	switch (phy) {
   41e58:	f649 6534 	movw	r5, #40500	; 0x9e34
    p_reg->CH[(uint32_t) channel].TEP = tep;
   41e5c:	f8c3 6514 	str.w	r6, [r3, #1300]	; 0x514
   41e60:	f24a 13b8 	movw	r3, #41400	; 0xa1b8
   41e64:	2a02      	cmp	r2, #2
   41e66:	bf18      	it	ne
   41e68:	461d      	movne	r5, r3
	}
}

static inline uint32_t hal_radio_rx_chain_delay_ns_get(uint8_t phy, uint8_t flags)
{
	switch (phy) {
   41e6a:	f10c 4c80 	add.w	ip, ip, #1073741824	; 0x40000000
	default:
	case BIT(0):
		return HAL_RADIO_NRF52840_RX_CHAIN_DELAY_1M_NS;
   41e6e:	f242 42b8 	movw	r2, #9400	; 0x24b8
   41e72:	f241 3388 	movw	r3, #5000	; 0x1388
   41e76:	2802      	cmp	r0, #2
   41e78:	bf18      	it	ne
   41e7a:	4613      	movne	r3, r2
   41e7c:	f50c 4c10 	add.w	ip, ip, #36864	; 0x9000
			delay = HAL_RADIO_NS2US_ROUND(
   41e80:	4a12      	ldr	r2, [pc, #72]	; (41ecc <radio_switch_complete_and_tx+0xbc>)
   41e82:	442b      	add	r3, r5
   41e84:	fba2 2303 	umull	r2, r3, r2, r3
	if (delay < SW_SWITCH_TIMER->CC[cc]) {
   41e88:	f8dc 2540 	ldr.w	r2, [ip, #1344]	; 0x540
   41e8c:	ebb2 1f93 	cmp.w	r2, r3, lsr #6
   41e90:	bf85      	ittet	hi
   41e92:	0998      	lsrhi	r0, r3, #6
				 (SW_SWITCH_TIMER->CC[cc] - delay));
   41e94:	f8dc 3540 	ldrhi.w	r3, [ip, #1344]	; 0x540
   41e98:	2301      	movls	r3, #1
		nrf_timer_cc_set(SW_SWITCH_TIMER, cc,
   41e9a:	1a1b      	subhi	r3, r3, r0
   41e9c:	f8cc 3540 	str.w	r3, [ip, #1344]	; 0x540
	sw_tifs_toggle += 1U;
   41ea0:	3101      	adds	r1, #1
    p_reg->CHENSET = mask;
   41ea2:	4b08      	ldr	r3, [pc, #32]	; (41ec4 <radio_switch_complete_and_tx+0xb4>)
   41ea4:	f44f 6210 	mov.w	r2, #2304	; 0x900
	sw_tifs_toggle &= 1U;
   41ea8:	f001 0101 	and.w	r1, r1, #1
   41eac:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
   41eb0:	7021      	strb	r1, [r4, #0]

	sw_switch(SW_SWITCH_RX, SW_SWITCH_TX, phy_rx, flags_rx, phy_tx, flags_tx,
		  END_EVT_DELAY_DISABLED);
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
   41eb2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   41eb6:	bf00      	nop
   41eb8:	40001000 	.word	0x40001000
   41ebc:	20006bb8 	.word	0x20006bb8
   41ec0:	40009140 	.word	0x40009140
   41ec4:	4001f000 	.word	0x4001f000
   41ec8:	4000110c 	.word	0x4000110c
   41ecc:	10624dd3 	.word	0x10624dd3

00041ed0 <radio_switch_complete_and_disable>:
void radio_switch_complete_and_disable(void)
{
#if defined(CONFIG_BT_CTLR_TIFS_HW)
	NRF_RADIO->SHORTS = (RADIO_SHORTS_READY_START_Msk | RADIO_SHORTS_END_DISABLE_Msk);
#else /* CONFIG_BT_CTLR_TIFS_HW */
	NRF_RADIO->SHORTS = (RADIO_SHORTS_READY_START_Msk | NRF_RADIO_SHORTS_PDU_END_DISABLE);
   41ed0:	4904      	ldr	r1, [pc, #16]	; (41ee4 <radio_switch_complete_and_disable+0x14>)
    p_reg->CHENCLR = mask;
   41ed2:	4b05      	ldr	r3, [pc, #20]	; (41ee8 <radio_switch_complete_and_disable+0x18>)
   41ed4:	2003      	movs	r0, #3
   41ed6:	f44f 6210 	mov.w	r2, #2304	; 0x900
   41eda:	f8c1 0200 	str.w	r0, [r1, #512]	; 0x200
   41ede:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
	hal_radio_sw_switch_disable();
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
   41ee2:	4770      	bx	lr
   41ee4:	40001000 	.word	0x40001000
   41ee8:	4001f000 	.word	0x4001f000

00041eec <radio_phy_flags_rx_get>:
	return 0;
#endif /* !CONFIG_HAS_HW_NRF_RADIO_BLE_CODED */
#else /* !CONFIG_BT_CTLR_PHY_CODED */
	return 0;
#endif /* !CONFIG_BT_CTLR_PHY_CODED */
}
   41eec:	2000      	movs	r0, #0
   41eee:	4770      	bx	lr

00041ef0 <radio_rssi_measure>:

void radio_rssi_measure(void)
{
	NRF_RADIO->SHORTS |=
   41ef0:	4a03      	ldr	r2, [pc, #12]	; (41f00 <radio_rssi_measure+0x10>)
   41ef2:	f8d2 3200 	ldr.w	r3, [r2, #512]	; 0x200
   41ef6:	f443 7388 	orr.w	r3, r3, #272	; 0x110
   41efa:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
	    (RADIO_SHORTS_ADDRESS_RSSISTART_Msk |
	     RADIO_SHORTS_DISABLED_RSSISTOP_Msk);
}
   41efe:	4770      	bx	lr
   41f00:	40001000 	.word	0x40001000

00041f04 <radio_rssi_get>:

uint32_t radio_rssi_get(void)
{
	return NRF_RADIO->RSSISAMPLE;
   41f04:	4b01      	ldr	r3, [pc, #4]	; (41f0c <radio_rssi_get+0x8>)
   41f06:	f8d3 0548 	ldr.w	r0, [r3, #1352]	; 0x548
}
   41f0a:	4770      	bx	lr
   41f0c:	40001000 	.word	0x40001000

00041f10 <radio_rssi_status_reset>:

void radio_rssi_status_reset(void)
{
	NRF_RADIO->EVENTS_RSSIEND = 0;
   41f10:	4b02      	ldr	r3, [pc, #8]	; (41f1c <radio_rssi_status_reset+0xc>)
   41f12:	2200      	movs	r2, #0
   41f14:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
}
   41f18:	4770      	bx	lr
   41f1a:	bf00      	nop
   41f1c:	40001000 	.word	0x40001000

00041f20 <radio_rssi_is_ready>:

uint32_t radio_rssi_is_ready(void)
{
	return (NRF_RADIO->EVENTS_RSSIEND != 0);
   41f20:	4b03      	ldr	r3, [pc, #12]	; (41f30 <radio_rssi_is_ready+0x10>)
   41f22:	f8d3 011c 	ldr.w	r0, [r3, #284]	; 0x11c
}
   41f26:	3800      	subs	r0, #0
   41f28:	bf18      	it	ne
   41f2a:	2001      	movne	r0, #1
   41f2c:	4770      	bx	lr
   41f2e:	bf00      	nop
   41f30:	40001000 	.word	0x40001000

00041f34 <radio_filter_disable>:
	NRF_RADIO->DACNF = ((uint32_t)bitmask_addr_type << 8) | bitmask_enable;
}

void radio_filter_disable(void)
{
	NRF_RADIO->DACNF &= ~(0x000000FF);
   41f34:	4a03      	ldr	r2, [pc, #12]	; (41f44 <radio_filter_disable+0x10>)
   41f36:	f8d2 3640 	ldr.w	r3, [r2, #1600]	; 0x640
   41f3a:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   41f3e:	f8c2 3640 	str.w	r3, [r2, #1600]	; 0x640
}
   41f42:	4770      	bx	lr
   41f44:	40001000 	.word	0x40001000

00041f48 <radio_filter_status_reset>:

void radio_filter_status_reset(void)
{
	NRF_RADIO->EVENTS_DEVMATCH = 0;
   41f48:	4b02      	ldr	r3, [pc, #8]	; (41f54 <radio_filter_status_reset+0xc>)
   41f4a:	2200      	movs	r2, #0
   41f4c:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
}
   41f50:	4770      	bx	lr
   41f52:	bf00      	nop
   41f54:	40001000 	.word	0x40001000

00041f58 <radio_filter_has_match>:

uint32_t radio_filter_has_match(void)
{
	return (NRF_RADIO->EVENTS_DEVMATCH != 0);
   41f58:	4b03      	ldr	r3, [pc, #12]	; (41f68 <radio_filter_has_match+0x10>)
   41f5a:	f8d3 0114 	ldr.w	r0, [r3, #276]	; 0x114
}
   41f5e:	3800      	subs	r0, #0
   41f60:	bf18      	it	ne
   41f62:	2001      	movne	r0, #1
   41f64:	4770      	bx	lr
   41f66:	bf00      	nop
   41f68:	40001000 	.word	0x40001000

00041f6c <radio_filter_match_get>:

uint32_t radio_filter_match_get(void)
{
	return NRF_RADIO->DAI;
   41f6c:	4b01      	ldr	r3, [pc, #4]	; (41f74 <radio_filter_match_get+0x8>)
   41f6e:	f8d3 0410 	ldr.w	r0, [r3, #1040]	; 0x410
}
   41f72:	4770      	bx	lr
   41f74:	40001000 	.word	0x40001000

00041f78 <radio_tmr_status_reset>:
}

NRF_STATIC_INLINE void nrf_rtc_event_disable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENCLR = mask;
   41f78:	4904      	ldr	r1, [pc, #16]	; (41f8c <radio_tmr_status_reset+0x14>)
   41f7a:	4b05      	ldr	r3, [pc, #20]	; (41f90 <radio_tmr_status_reset+0x18>)
   41f7c:	4a05      	ldr	r2, [pc, #20]	; (41f94 <radio_tmr_status_reset+0x1c>)
   41f7e:	f44f 2080 	mov.w	r0, #262144	; 0x40000
   41f82:	f8c1 0348 	str.w	r0, [r1, #840]	; 0x348
   41f86:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
#endif /* CONFIG_BT_CTLR_DF_PHYEND_OFFSET_COMPENSATION_ENABLE */
#if defined(CONFIG_BT_CTLR_DF_CONN_CTE_RX)
			BIT(HAL_TRIGGER_CRYPT_DELAY_PPI) |
#endif /* CONFIG_BT_CTLR_DF_CONN_CTE_RX */
			BIT(HAL_TRIGGER_CRYPT_PPI));
}
   41f8a:	4770      	bx	lr
   41f8c:	4000b000 	.word	0x4000b000
   41f90:	4001f000 	.word	0x4001f000
   41f94:	0e7000c0 	.word	0x0e7000c0

00041f98 <radio_tmr_tifs_set>:
void radio_tmr_tifs_set(uint32_t tifs)
{
#if defined(CONFIG_BT_CTLR_TIFS_HW)
	NRF_RADIO->TIFS = tifs;
#else /* !CONFIG_BT_CTLR_TIFS_HW */
	nrf_timer_cc_set(SW_SWITCH_TIMER,
   41f98:	4b03      	ldr	r3, [pc, #12]	; (41fa8 <radio_tmr_tifs_set+0x10>)
   41f9a:	4a04      	ldr	r2, [pc, #16]	; (41fac <radio_tmr_tifs_set+0x14>)
   41f9c:	781b      	ldrb	r3, [r3, #0]
   41f9e:	f503 73a8 	add.w	r3, r3, #336	; 0x150
   41fa2:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
			 SW_SWITCH_TIMER_EVTS_COMP(sw_tifs_toggle), tifs);
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
   41fa6:	4770      	bx	lr
   41fa8:	20006bb8 	.word	0x20006bb8
   41fac:	40009000 	.word	0x40009000

00041fb0 <radio_tmr_start>:

uint32_t radio_tmr_start(uint8_t trx, uint32_t ticks_start, uint32_t remainder)
{
   41fb0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
/* Remove ticks and return positive remainder value in microseconds */
static inline void hal_ticker_remove_jitter(uint32_t *ticks,
					    uint32_t *remainder)
{
	/* Is remainder less than 1 us */
	if ((*remainder & BIT(31)) || !(*remainder / 1000000UL)) {
   41fb4:	f5a2 2374 	sub.w	r3, r2, #999424	; 0xf4000
   41fb8:	4d31      	ldr	r5, [pc, #196]	; (42080 <radio_tmr_start+0xd0>)
   41fba:	f5a3 7310 	sub.w	r3, r3, #576	; 0x240
   41fbe:	42ab      	cmp	r3, r5
   41fc0:	4604      	mov	r4, r0
   41fc2:	d906      	bls.n	41fd2 <radio_tmr_start+0x22>
		*ticks -= 1U;
		*remainder += HAL_TICKER_CNTR_CLK_UNIT_FS / 1000UL;
   41fc4:	f102 72e8 	add.w	r2, r2, #30408704	; 0x1d00000
   41fc8:	f502 32d4 	add.w	r2, r2, #108544	; 0x1a800
		*ticks -= 1U;
   41fcc:	3901      	subs	r1, #1
		*remainder += HAL_TICKER_CNTR_CLK_UNIT_FS / 1000UL;
   41fce:	f502 72a5 	add.w	r2, r2, #330	; 0x14a
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   41fd2:	4b2c      	ldr	r3, [pc, #176]	; (42084 <radio_tmr_start+0xd4>)
	}

	/* pico seconds to micro seconds unit */
	*remainder /= 1000000UL;
   41fd4:	482c      	ldr	r0, [pc, #176]	; (42088 <radio_tmr_start+0xd8>)
    p_reg->CC[ch] = cc_val;
   41fd6:	4d2d      	ldr	r5, [pc, #180]	; (4208c <radio_tmr_start+0xdc>)
    p_reg->CH[(uint32_t) channel].EEP = eep;
   41fd8:	4e2d      	ldr	r6, [pc, #180]	; (42090 <radio_tmr_start+0xe0>)
   41fda:	2701      	movs	r7, #1
   41fdc:	60df      	str	r7, [r3, #12]
	hal_ticker_remove_jitter(&ticks_start, &remainder);

	nrf_timer_task_trigger(EVENT_TIMER, NRF_TIMER_TASK_CLEAR);
	EVENT_TIMER->MODE = 0;
   41fde:	2700      	movs	r7, #0
   41fe0:	f8c3 7504 	str.w	r7, [r3, #1284]	; 0x504
   41fe4:	fba0 0202 	umull	r0, r2, r0, r2
	EVENT_TIMER->PRESCALER = 4;
   41fe8:	2704      	movs	r7, #4
   41fea:	f8c3 7510 	str.w	r7, [r3, #1296]	; 0x510
   41fee:	0c90      	lsrs	r0, r2, #18
	EVENT_TIMER->BITMODE = 2;	/* 24 - bit */
   41ff0:	2702      	movs	r7, #2
   41ff2:	f8c3 7508 	str.w	r7, [r3, #1288]	; 0x508
   41ff6:	4a27      	ldr	r2, [pc, #156]	; (42094 <radio_tmr_start+0xe4>)
    p_reg->CC[cc_channel] = cc_value;
   41ff8:	f8c3 0540 	str.w	r0, [r3, #1344]	; 0x540
   41ffc:	f8c5 1548 	str.w	r1, [r5, #1352]	; 0x548
    p_reg->EVTENSET = mask;
   42000:	f44f 2180 	mov.w	r1, #262144	; 0x40000
   42004:	f8c5 1344 	str.w	r1, [r5, #836]	; 0x344
    p_reg->CHENSET = mask;
   42008:	2140      	movs	r1, #64	; 0x40
    p_reg->CH[(uint32_t) channel].EEP = eep;
   4200a:	f8c2 6540 	str.w	r6, [r2, #1344]	; 0x540
    p_reg->CH[(uint32_t) channel].TEP = tep;
   4200e:	f8c2 3544 	str.w	r3, [r2, #1348]	; 0x544
    p_reg->CHENSET = mask;
   42012:	f8c2 1504 	str.w	r1, [r2, #1284]	; 0x504
	nrf_ppi_channels_disable(
   42016:	b364      	cbz	r4, 42072 <radio_tmr_start+0xc2>
    p_reg->CHENCLR = mask;
   42018:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
   4201c:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
	nrf_ppi_channels_enable(
   42020:	f44f 1480 	mov.w	r4, #1048576	; 0x100000
    p_reg->CHENSET = mask;
   42024:	4b1b      	ldr	r3, [pc, #108]	; (42094 <radio_tmr_start+0xe4>)
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   42026:	4a1c      	ldr	r2, [pc, #112]	; (42098 <radio_tmr_start+0xe8>)
   42028:	f8c3 4504 	str.w	r4, [r3, #1284]	; 0x504
   4202c:	2101      	movs	r1, #1
#if defined(CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER)
	last_pdu_end_us = 0U;

#else /* !CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */
	nrf_timer_task_trigger(SW_SWITCH_TIMER, NRF_TIMER_TASK_CLEAR);
	SW_SWITCH_TIMER->MODE = 0;
   4202e:	2400      	movs	r4, #0
    p_reg->CH[(uint32_t) channel].EEP = eep;
   42030:	f8df 8068 	ldr.w	r8, [pc, #104]	; 4209c <radio_tmr_start+0xec>
    p_reg->CH[(uint32_t) channel].TEP = tep;
   42034:	f8df e068 	ldr.w	lr, [pc, #104]	; 420a0 <radio_tmr_start+0xf0>
    p_reg->CH[(uint32_t) channel].EEP = eep;
   42038:	f8df c068 	ldr.w	ip, [pc, #104]	; 420a4 <radio_tmr_start+0xf4>
    p_reg->CH[(uint32_t) channel].TEP = tep;
   4203c:	4f1a      	ldr	r7, [pc, #104]	; (420a8 <radio_tmr_start+0xf8>)
    p_reg->CH[(uint32_t) channel].EEP = eep;
   4203e:	4e1b      	ldr	r6, [pc, #108]	; (420ac <radio_tmr_start+0xfc>)
    p_reg->CH[(uint32_t) channel].TEP = tep;
   42040:	4d1b      	ldr	r5, [pc, #108]	; (420b0 <radio_tmr_start+0x100>)
   42042:	60d1      	str	r1, [r2, #12]
	SW_SWITCH_TIMER->PRESCALER = 4;
   42044:	f04f 0904 	mov.w	r9, #4
	SW_SWITCH_TIMER->MODE = 0;
   42048:	f8c2 4504 	str.w	r4, [r2, #1284]	; 0x504
	SW_SWITCH_TIMER->PRESCALER = 4;
   4204c:	f8c2 9510 	str.w	r9, [r2, #1296]	; 0x510
	SW_SWITCH_TIMER->BITMODE = 0; /* 16 bit */
   42050:	f8c2 4508 	str.w	r4, [r2, #1288]	; 0x508
   42054:	6011      	str	r1, [r2, #0]
    p_reg->CH[(uint32_t) channel].EEP = eep;
   42056:	f8c3 8550 	str.w	r8, [r3, #1360]	; 0x550
    p_reg->CH[(uint32_t) channel].TEP = tep;
   4205a:	f8c3 e554 	str.w	lr, [r3, #1364]	; 0x554
    p_reg->CH[(uint32_t) channel].EEP = eep;
   4205e:	f8c3 c558 	str.w	ip, [r3, #1368]	; 0x558
    p_reg->CH[(uint32_t) channel].TEP = tep;
   42062:	f8c3 755c 	str.w	r7, [r3, #1372]	; 0x55c
    p_reg->CH[(uint32_t) channel].EEP = eep;
   42066:	f8c3 6560 	str.w	r6, [r3, #1376]	; 0x560
    p_reg->CH[(uint32_t) channel].TEP = tep;
   4206a:	f8c3 5564 	str.w	r5, [r3, #1380]	; 0x564
	 */
#endif /* CONFIG_BT_CTLR_PHY_CODED && CONFIG_HAS_HW_NRF_RADIO_BLE_CODED */
#endif /* !CONFIG_BT_CTLR_TIFS_HW */

	return remainder;
}
   4206e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    p_reg->CHENCLR = mask;
   42072:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
   42076:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
   4207a:	f44f 1400 	mov.w	r4, #2097152	; 0x200000
   4207e:	e7d1      	b.n	42024 <radio_tmr_start+0x74>
   42080:	7ff0bdbf 	.word	0x7ff0bdbf
   42084:	40008000 	.word	0x40008000
   42088:	431bde83 	.word	0x431bde83
   4208c:	4000b000 	.word	0x4000b000
   42090:	4000b148 	.word	0x4000b148
   42094:	4001f000 	.word	0x4001f000
   42098:	40009000 	.word	0x40009000
   4209c:	4000110c 	.word	0x4000110c
   420a0:	4000900c 	.word	0x4000900c
   420a4:	40009140 	.word	0x40009140
   420a8:	4001f004 	.word	0x4001f004
   420ac:	40009144 	.word	0x40009144
   420b0:	4001f00c 	.word	0x4001f00c

000420b4 <radio_tmr_start_tick>:
   420b4:	4a15      	ldr	r2, [pc, #84]	; (4210c <radio_tmr_start_tick+0x58>)

uint32_t radio_tmr_start_tick(uint8_t trx, uint32_t tick)
{
   420b6:	b430      	push	{r4, r5}
   420b8:	2301      	movs	r3, #1
    p_reg->CC[ch] = cc_val;
   420ba:	4c15      	ldr	r4, [pc, #84]	; (42110 <radio_tmr_start_tick+0x5c>)
   420bc:	6053      	str	r3, [r2, #4]
    p_reg->EVTENSET = mask;
   420be:	f44f 2580 	mov.w	r5, #262144	; 0x40000
   420c2:	60d3      	str	r3, [r2, #12]
    p_reg->CC[cc_channel] = cc_value;
   420c4:	f8c2 3540 	str.w	r3, [r2, #1344]	; 0x540
    p_reg->CH[(uint32_t) channel].EEP = eep;
   420c8:	4b12      	ldr	r3, [pc, #72]	; (42114 <radio_tmr_start_tick+0x60>)
    p_reg->CC[ch] = cc_val;
   420ca:	f8c4 1548 	str.w	r1, [r4, #1352]	; 0x548
    p_reg->EVTENSET = mask;
   420ce:	f8c4 5344 	str.w	r5, [r4, #836]	; 0x344
    p_reg->CHENSET = mask;
   420d2:	2140      	movs	r1, #64	; 0x40
    p_reg->CH[(uint32_t) channel].EEP = eep;
   420d4:	f504 74a4 	add.w	r4, r4, #328	; 0x148
   420d8:	f8c3 4540 	str.w	r4, [r3, #1344]	; 0x540
    p_reg->CH[(uint32_t) channel].TEP = tep;
   420dc:	f8c3 2544 	str.w	r2, [r3, #1348]	; 0x544
    p_reg->CHENSET = mask;
   420e0:	f8c3 1504 	str.w	r1, [r3, #1284]	; 0x504
	nrf_ppi_channels_disable(
   420e4:	b158      	cbz	r0, 420fe <radio_tmr_start_tick+0x4a>
    p_reg->CHENCLR = mask;
   420e6:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
   420ea:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
	nrf_ppi_channels_enable(
   420ee:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
    p_reg->CHENSET = mask;
   420f2:	4b08      	ldr	r3, [pc, #32]	; (42114 <radio_tmr_start_tick+0x60>)
   420f4:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
	hal_sw_switch_timer_clear_ppi_config();
#endif /* CONFIG_SOC_SERIES_NRF53X */
#endif /* !CONFIG_BT_CTLR_TIFS_HW */

	return remainder_us;
}
   420f8:	2001      	movs	r0, #1
   420fa:	bc30      	pop	{r4, r5}
   420fc:	4770      	bx	lr
    p_reg->CHENCLR = mask;
   420fe:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
   42102:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
   42106:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
   4210a:	e7f2      	b.n	420f2 <radio_tmr_start_tick+0x3e>
   4210c:	40008000 	.word	0x40008000
   42110:	4000b000 	.word	0x4000b000
   42114:	4001f000 	.word	0x4001f000

00042118 <radio_tmr_start_get>:
    return p_reg->CC[ch];
   42118:	4b01      	ldr	r3, [pc, #4]	; (42120 <radio_tmr_start_get+0x8>)
   4211a:	f8d3 0548 	ldr.w	r0, [r3, #1352]	; 0x548
}

uint32_t radio_tmr_start_get(void)
{
	return nrf_rtc_cc_get(NRF_RTC0, 2);
}
   4211e:	4770      	bx	lr
   42120:	4000b000 	.word	0x4000b000

00042124 <radio_tmr_stop>:
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   42124:	4903      	ldr	r1, [pc, #12]	; (42134 <radio_tmr_stop+0x10>)
   42126:	4a04      	ldr	r2, [pc, #16]	; (42138 <radio_tmr_stop+0x14>)
   42128:	2301      	movs	r3, #1
   4212a:	604b      	str	r3, [r1, #4]
   4212c:	610b      	str	r3, [r1, #16]
   4212e:	6053      	str	r3, [r2, #4]
   42130:	6113      	str	r3, [r2, #16]

#if !defined(CONFIG_BT_CTLR_TIFS_HW)
	nrf_timer_task_trigger(SW_SWITCH_TIMER, NRF_TIMER_TASK_STOP);
	nrf_timer_task_trigger(SW_SWITCH_TIMER, NRF_TIMER_TASK_SHUTDOWN);
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
   42132:	4770      	bx	lr
   42134:	40008000 	.word	0x40008000
   42138:	40009000 	.word	0x40009000

0004213c <radio_tmr_hcto_configure>:
    p_reg->CC[cc_channel] = cc_value;
   4213c:	4904      	ldr	r1, [pc, #16]	; (42150 <radio_tmr_hcto_configure+0x14>)
    p_reg->CHENSET = mask;
   4213e:	4b05      	ldr	r3, [pc, #20]	; (42154 <radio_tmr_hcto_configure+0x18>)
   42140:	f8c1 0544 	str.w	r0, [r1, #1348]	; 0x544
   42144:	f04f 6288 	mov.w	r2, #71303168	; 0x4400000
   42148:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
	hal_radio_recv_timeout_cancel_ppi_config();
	hal_radio_disable_on_hcto_ppi_config();
	hal_radio_nrf_ppi_channels_enable(
		BIT(HAL_RADIO_RECV_TIMEOUT_CANCEL_PPI) |
		BIT(HAL_RADIO_DISABLE_ON_HCTO_PPI));
}
   4214c:	4770      	bx	lr
   4214e:	bf00      	nop
   42150:	40008000 	.word	0x40008000
   42154:	4001f000 	.word	0x4001f000

00042158 <radio_tmr_aa_capture>:
    p_reg->CH[(uint32_t) channel].EEP = eep;
   42158:	4b05      	ldr	r3, [pc, #20]	; (42170 <radio_tmr_aa_capture+0x18>)
   4215a:	4806      	ldr	r0, [pc, #24]	; (42174 <radio_tmr_aa_capture+0x1c>)
    p_reg->CH[(uint32_t) channel].TEP = tep;
   4215c:	4906      	ldr	r1, [pc, #24]	; (42178 <radio_tmr_aa_capture+0x20>)
    p_reg->CHENSET = mask;
   4215e:	4a07      	ldr	r2, [pc, #28]	; (4217c <radio_tmr_aa_capture+0x24>)
    p_reg->CH[(uint32_t) channel].EEP = eep;
   42160:	f8c3 0548 	str.w	r0, [r3, #1352]	; 0x548
    p_reg->CH[(uint32_t) channel].TEP = tep;
   42164:	f8c3 154c 	str.w	r1, [r3, #1356]	; 0x54c
    p_reg->CHENSET = mask;
   42168:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
	hal_radio_ready_time_capture_ppi_config();
	hal_radio_recv_timeout_cancel_ppi_config();
	hal_radio_nrf_ppi_channels_enable(
		BIT(HAL_RADIO_READY_TIME_CAPTURE_PPI) |
		BIT(HAL_RADIO_RECV_TIMEOUT_CANCEL_PPI));
}
   4216c:	4770      	bx	lr
   4216e:	bf00      	nop
   42170:	4001f000 	.word	0x4001f000
   42174:	40001100 	.word	0x40001100
   42178:	40008040 	.word	0x40008040
   4217c:	04000080 	.word	0x04000080

00042180 <radio_tmr_aa_get>:

uint32_t radio_tmr_aa_get(void)
{
	return EVENT_TIMER->CC[1];
   42180:	4b01      	ldr	r3, [pc, #4]	; (42188 <radio_tmr_aa_get+0x8>)
   42182:	f8d3 0544 	ldr.w	r0, [r3, #1348]	; 0x544
}
   42186:	4770      	bx	lr
   42188:	40008000 	.word	0x40008000

0004218c <radio_tmr_aa_save>:

static uint32_t radio_tmr_aa;

void radio_tmr_aa_save(uint32_t aa)
{
	radio_tmr_aa = aa;
   4218c:	4b01      	ldr	r3, [pc, #4]	; (42194 <radio_tmr_aa_save+0x8>)
   4218e:	6018      	str	r0, [r3, #0]
}
   42190:	4770      	bx	lr
   42192:	bf00      	nop
   42194:	20005b30 	.word	0x20005b30

00042198 <radio_tmr_aa_restore>:

uint32_t radio_tmr_aa_restore(void)
{
	/* NOTE: we dont need to restore for now, but return the saved value. */
	return radio_tmr_aa;
   42198:	4b01      	ldr	r3, [pc, #4]	; (421a0 <radio_tmr_aa_restore+0x8>)
}
   4219a:	6818      	ldr	r0, [r3, #0]
   4219c:	4770      	bx	lr
   4219e:	bf00      	nop
   421a0:	20005b30 	.word	0x20005b30

000421a4 <radio_tmr_ready_get>:

uint32_t radio_tmr_ready_get(void)
{
	return EVENT_TIMER->CC[0];
   421a4:	4b01      	ldr	r3, [pc, #4]	; (421ac <radio_tmr_ready_get+0x8>)
   421a6:	f8d3 0540 	ldr.w	r0, [r3, #1344]	; 0x540
}
   421aa:	4770      	bx	lr
   421ac:	40008000 	.word	0x40008000

000421b0 <radio_tmr_end_capture>:
   421b0:	4b02      	ldr	r3, [pc, #8]	; (421bc <radio_tmr_end_capture+0xc>)
   421b2:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
   421b6:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
	hal_radio_end_time_capture_ppi_config();
	hal_radio_nrf_ppi_channels_enable(BIT(HAL_RADIO_END_TIME_CAPTURE_PPI));
#endif /* !CONFIG_SOC_SERIES_NRF53X ||
	* (CONFIG_SOC_SERIES_NRF53X && !CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER)
	*/
}
   421ba:	4770      	bx	lr
   421bc:	4001f000 	.word	0x4001f000

000421c0 <radio_tmr_end_get>:
uint32_t radio_tmr_end_get(void)
{
#if defined(CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER)
	return last_pdu_end_us;
#else /* !CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */
	return EVENT_TIMER->CC[2];
   421c0:	4b01      	ldr	r3, [pc, #4]	; (421c8 <radio_tmr_end_get+0x8>)
   421c2:	f8d3 0548 	ldr.w	r0, [r3, #1352]	; 0x548
#endif /* !CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */
}
   421c6:	4770      	bx	lr
   421c8:	40008000 	.word	0x40008000

000421cc <radio_tmr_tifs_base_get>:

uint32_t radio_tmr_tifs_base_get(void)
   421cc:	4b01      	ldr	r3, [pc, #4]	; (421d4 <radio_tmr_tifs_base_get+0x8>)
   421ce:	f8d3 0548 	ldr.w	r0, [r3, #1352]	; 0x548
   421d2:	4770      	bx	lr
   421d4:	40008000 	.word	0x40008000

000421d8 <radio_ccm_rx_pkt_set>:

void *radio_ccm_rx_pkt_set(struct ccm *ccm, uint8_t phy, void *pkt)
{
	uint32_t mode;

	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Disabled;
   421d8:	4b1c      	ldr	r3, [pc, #112]	; (4224c <radio_ccm_rx_pkt_set+0x74>)
{
   421da:	b430      	push	{r4, r5}
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Disabled;
   421dc:	2400      	movs	r4, #0
   421de:	f8c3 4500 	str.w	r4, [r3, #1280]	; 0x500
	/* Enable CCM support for 8-bit length field PDUs. */
	mode |= (CCM_MODE_LENGTH_Extended << CCM_MODE_LENGTH_Pos) &
		CCM_MODE_LENGTH_Msk;

	/* Select CCM data rate based on current PHY in use. */
	switch (phy) {
   421e2:	2902      	cmp	r1, #2
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Enabled;
   421e4:	f04f 0402 	mov.w	r4, #2
   421e8:	f8c3 4500 	str.w	r4, [r3, #1280]	; 0x500
{
   421ec:	4604      	mov	r4, r0
	switch (phy) {
   421ee:	d026      	beq.n	4223e <radio_ccm_rx_pkt_set+0x66>
   421f0:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
   421f4:	f04f 7100 	mov.w	r1, #33554432	; 0x2000000
	default:
	case PHY_1M:
		mode |= (CCM_MODE_DATARATE_1Mbit <<
   421f8:	4d15      	ldr	r5, [pc, #84]	; (42250 <radio_ccm_rx_pkt_set+0x78>)
   421fa:	f8c3 1504 	str.w	r1, [r3, #1284]	; 0x504
	}

#if !defined(CONFIG_SOC_COMPATIBLE_NRF52832) && \
	(!defined(CONFIG_BT_CTLR_DATA_LENGTH_MAX) || \
	 (CONFIG_BT_CTLR_DATA_LENGTH_MAX < ((HAL_RADIO_PDU_LEN_MAX) - 4)))
	uint8_t max_len = (NRF_RADIO->PCNF1 & RADIO_PCNF1_MAXLEN_Msk) >>
   421fe:	4915      	ldr	r1, [pc, #84]	; (42254 <radio_ccm_rx_pkt_set+0x7c>)
			RADIO_PCNF1_MAXLEN_Pos;

	NRF_CCM->MAXPACKETSIZE = max_len;
   42200:	4b12      	ldr	r3, [pc, #72]	; (4224c <radio_ccm_rx_pkt_set+0x74>)
	uint8_t max_len = (NRF_RADIO->PCNF1 & RADIO_PCNF1_MAXLEN_Msk) >>
   42202:	f8d1 1518 	ldr.w	r1, [r1, #1304]	; 0x518
#endif
#endif /* !CONFIG_SOC_SERIES_NRF51X */

	NRF_CCM->MODE = mode;
	NRF_CCM->CNFPTR = (uint32_t)ccm;
	NRF_CCM->INPTR = (uint32_t)_pkt_scratch;
   42206:	4814      	ldr	r0, [pc, #80]	; (42258 <radio_ccm_rx_pkt_set+0x80>)
   42208:	b2c9      	uxtb	r1, r1
	NRF_CCM->MAXPACKETSIZE = max_len;
   4220a:	f8c3 1518 	str.w	r1, [r3, #1304]	; 0x518
	NRF_CCM->MODE = mode;
   4220e:	f8c3 5504 	str.w	r5, [r3, #1284]	; 0x504
	NRF_CCM->OUTPTR = (uint32_t)pkt;
	NRF_CCM->SCRATCHPTR = (uint32_t)_ccm_scratch;
	NRF_CCM->SHORTS = 0;
   42212:	2100      	movs	r1, #0
	NRF_CCM->CNFPTR = (uint32_t)ccm;
   42214:	f8c3 4508 	str.w	r4, [r3, #1288]	; 0x508
	NRF_CCM->INPTR = (uint32_t)_pkt_scratch;
   42218:	f8c3 050c 	str.w	r0, [r3, #1292]	; 0x50c
	NRF_CCM->SCRATCHPTR = (uint32_t)_ccm_scratch;
   4221c:	4c0f      	ldr	r4, [pc, #60]	; (4225c <radio_ccm_rx_pkt_set+0x84>)
	NRF_CCM->OUTPTR = (uint32_t)pkt;
   4221e:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_ccm_task_trigger(NRF_CCM_Type * p_reg,
                                            nrf_ccm_task_t task)
{
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   42222:	2201      	movs	r2, #1
	NRF_CCM->SCRATCHPTR = (uint32_t)_ccm_scratch;
   42224:	f8c3 4514 	str.w	r4, [r3, #1300]	; 0x514
	NRF_CCM->SHORTS = 0;
   42228:	f8c3 1200 	str.w	r1, [r3, #512]	; 0x200
	NRF_CCM->EVENTS_ENDKSGEN = 0;
   4222c:	f8c3 1100 	str.w	r1, [r3, #256]	; 0x100
	NRF_CCM->EVENTS_ENDCRYPT = 0;
   42230:	f8c3 1104 	str.w	r1, [r3, #260]	; 0x104
	NRF_CCM->EVENTS_ERROR = 0;
   42234:	f8c3 1108 	str.w	r1, [r3, #264]	; 0x108
   42238:	601a      	str	r2, [r3, #0]

	nrf_ccm_task_trigger(NRF_CCM, NRF_CCM_TASK_KSGEN);

	return _pkt_scratch;
}
   4223a:	bc30      	pop	{r4, r5}
   4223c:	4770      	bx	lr
   4223e:	4b08      	ldr	r3, [pc, #32]	; (42260 <radio_ccm_rx_pkt_set+0x88>)
		mode |= (CCM_MODE_DATARATE_2Mbit <<
   42240:	4d08      	ldr	r5, [pc, #32]	; (42264 <radio_ccm_rx_pkt_set+0x8c>)
   42242:	f04f 7100 	mov.w	r1, #33554432	; 0x2000000
   42246:	f8c3 1504 	str.w	r1, [r3, #1284]	; 0x504
}
   4224a:	e7d8      	b.n	421fe <radio_ccm_rx_pkt_set+0x26>
   4224c:	4000f000 	.word	0x4000f000
   42250:	01000001 	.word	0x01000001
   42254:	40001000 	.word	0x40001000
   42258:	20005b34 	.word	0x20005b34
   4225c:	20005a24 	.word	0x20005a24
   42260:	4001f000 	.word	0x4001f000
   42264:	01010001 	.word	0x01010001

00042268 <radio_ccm_tx_pkt_set>:

void *radio_ccm_tx_pkt_set(struct ccm *ccm, void *pkt)
{
	uint32_t mode;

	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Disabled;
   42268:	4b10      	ldr	r3, [pc, #64]	; (422ac <radio_ccm_tx_pkt_set+0x44>)
{
   4226a:	b410      	push	{r4}
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Disabled;
   4226c:	2200      	movs	r2, #0
{
   4226e:	4604      	mov	r4, r0
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Enabled;
   42270:	2002      	movs	r0, #2
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Disabled;
   42272:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Enabled;
   42276:	f8c3 0500 	str.w	r0, [r3, #1280]	; 0x500
	 * radio Tx on any PHY.
	 */
	mode |= (CCM_MODE_DATARATE_2Mbit << CCM_MODE_DATARATE_Pos) &
		CCM_MODE_DATARATE_Msk;
#endif
	NRF_CCM->MODE = mode;
   4227a:	480d      	ldr	r0, [pc, #52]	; (422b0 <radio_ccm_tx_pkt_set+0x48>)
   4227c:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
	NRF_CCM->CNFPTR = (uint32_t)ccm;
   42280:	f8c3 4508 	str.w	r4, [r3, #1288]	; 0x508
	NRF_CCM->INPTR = (uint32_t)pkt;
	NRF_CCM->OUTPTR = (uint32_t)_pkt_scratch;
   42284:	480b      	ldr	r0, [pc, #44]	; (422b4 <radio_ccm_tx_pkt_set+0x4c>)
	NRF_CCM->INPTR = (uint32_t)pkt;
   42286:	f8c3 150c 	str.w	r1, [r3, #1292]	; 0x50c
	NRF_CCM->SCRATCHPTR = (uint32_t)_ccm_scratch;
   4228a:	4c0b      	ldr	r4, [pc, #44]	; (422b8 <radio_ccm_tx_pkt_set+0x50>)
	NRF_CCM->OUTPTR = (uint32_t)_pkt_scratch;
   4228c:	f8c3 0510 	str.w	r0, [r3, #1296]	; 0x510
	NRF_CCM->SHORTS = CCM_SHORTS_ENDKSGEN_CRYPT_Msk;
   42290:	2101      	movs	r1, #1
	NRF_CCM->SCRATCHPTR = (uint32_t)_ccm_scratch;
   42292:	f8c3 4514 	str.w	r4, [r3, #1300]	; 0x514
	NRF_CCM->SHORTS = CCM_SHORTS_ENDKSGEN_CRYPT_Msk;
   42296:	f8c3 1200 	str.w	r1, [r3, #512]	; 0x200
	NRF_CCM->EVENTS_ENDKSGEN = 0;
   4229a:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
	NRF_CCM->EVENTS_ENDCRYPT = 0;
   4229e:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
	NRF_CCM->EVENTS_ERROR = 0;
   422a2:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
   422a6:	6019      	str	r1, [r3, #0]

	nrf_ccm_task_trigger(NRF_CCM, NRF_CCM_TASK_KSGEN);

	return _pkt_scratch;
}
   422a8:	bc10      	pop	{r4}
   422aa:	4770      	bx	lr
   422ac:	4000f000 	.word	0x4000f000
   422b0:	01010000 	.word	0x01010000
   422b4:	20005b34 	.word	0x20005b34
   422b8:	20005a24 	.word	0x20005a24

000422bc <radio_ccm_is_done>:
    p_reg->SHORTS = mask;
}

NRF_STATIC_INLINE void nrf_ccm_int_enable(NRF_CCM_Type * p_reg, uint32_t mask)
{
    p_reg->INTENSET = mask;
   422bc:	4a0e      	ldr	r2, [pc, #56]	; (422f8 <radio_ccm_is_done+0x3c>)
   422be:	2302      	movs	r3, #2
   422c0:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304

uint32_t radio_ccm_is_done(void)
{
	nrf_ccm_int_enable(NRF_CCM, CCM_INTENSET_ENDCRYPT_Msk);
	while (NRF_CCM->EVENTS_ENDCRYPT == 0) {
   422c4:	f8d2 3104 	ldr.w	r3, [r2, #260]	; 0x104
   422c8:	b933      	cbnz	r3, 422d8 <radio_ccm_is_done+0x1c>
		__WFE();
   422ca:	bf20      	wfe
		__SEV();
   422cc:	bf40      	sev
		__WFE();
   422ce:	bf20      	wfe
	while (NRF_CCM->EVENTS_ENDCRYPT == 0) {
   422d0:	f8d2 3104 	ldr.w	r3, [r2, #260]	; 0x104
   422d4:	2b00      	cmp	r3, #0
   422d6:	d0f8      	beq.n	422ca <radio_ccm_is_done+0xe>
}

NRF_STATIC_INLINE void nrf_ccm_int_disable(NRF_CCM_Type * p_reg, uint32_t mask)
{
    p_reg->INTENCLR = mask;
   422d8:	4b07      	ldr	r3, [pc, #28]	; (422f8 <radio_ccm_is_done+0x3c>)
   422da:	4a08      	ldr	r2, [pc, #32]	; (422fc <radio_ccm_is_done+0x40>)
   422dc:	2002      	movs	r0, #2
   422de:	f44f 4100 	mov.w	r1, #32768	; 0x8000
   422e2:	f8c3 0308 	str.w	r0, [r3, #776]	; 0x308
   422e6:	f8c2 1180 	str.w	r1, [r2, #384]	; 0x180
	}
	nrf_ccm_int_disable(NRF_CCM, CCM_INTENCLR_ENDCRYPT_Msk);
	NVIC_ClearPendingIRQ(nrfx_get_irq_number(NRF_CCM));

	return (NRF_CCM->EVENTS_ERROR == 0);
   422ea:	f8d3 0108 	ldr.w	r0, [r3, #264]	; 0x108
}
   422ee:	fab0 f080 	clz	r0, r0
   422f2:	0940      	lsrs	r0, r0, #5
   422f4:	4770      	bx	lr
   422f6:	bf00      	nop
   422f8:	4000f000 	.word	0x4000f000
   422fc:	e000e100 	.word	0xe000e100

00042300 <radio_ccm_mic_is_valid>:

uint32_t radio_ccm_mic_is_valid(void)
{
	return (NRF_CCM->MICSTATUS != 0);
   42300:	4b03      	ldr	r3, [pc, #12]	; (42310 <radio_ccm_mic_is_valid+0x10>)
   42302:	f8d3 0400 	ldr.w	r0, [r3, #1024]	; 0x400
}
   42306:	3800      	subs	r0, #0
   42308:	bf18      	it	ne
   4230a:	2001      	movne	r0, #1
   4230c:	4770      	bx	lr
   4230e:	bf00      	nop
   42310:	4000f000 	.word	0x4000f000

00042314 <mayfly_enable_cb>:

void mayfly_enable_cb(uint8_t caller_id, uint8_t callee_id, uint8_t enable)
{
	(void)caller_id;

	LL_ASSERT(callee_id == MAYFLY_CALL_ID_JOB);
   42314:	2902      	cmp	r1, #2
{
   42316:	b510      	push	{r4, lr}
   42318:	4614      	mov	r4, r2
	LL_ASSERT(callee_id == MAYFLY_CALL_ID_JOB);
   4231a:	d00b      	beq.n	42334 <mayfly_enable_cb+0x20>
   4231c:	4a0a      	ldr	r2, [pc, #40]	; (42348 <mayfly_enable_cb+0x34>)
   4231e:	490b      	ldr	r1, [pc, #44]	; (4234c <mayfly_enable_cb+0x38>)
   42320:	480b      	ldr	r0, [pc, #44]	; (42350 <mayfly_enable_cb+0x3c>)
   42322:	231e      	movs	r3, #30
   42324:	f006 feae 	bl	49084 <assert_print>
   42328:	4040      	eors	r0, r0
   4232a:	f380 8811 	msr	BASEPRI, r0
   4232e:	f04f 0003 	mov.w	r0, #3
   42332:	df02      	svc	2

	if (enable) {
		irq_enable(HAL_SWI_JOB_IRQ);
   42334:	200b      	movs	r0, #11
	if (enable) {
   42336:	b11c      	cbz	r4, 42340 <mayfly_enable_cb+0x2c>
	} else {
		irq_disable(HAL_SWI_JOB_IRQ);
	}
}
   42338:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		irq_enable(HAL_SWI_JOB_IRQ);
   4233c:	f7ea bd3a 	b.w	2cdb4 <arch_irq_enable>
}
   42340:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		irq_disable(HAL_SWI_JOB_IRQ);
   42344:	f7ea bd44 	b.w	2cdd0 <arch_irq_disable>
   42348:	00052d94 	.word	0x00052d94
   4234c:	00052de4 	.word	0x00052de4
   42350:	0005214c 	.word	0x0005214c

00042354 <mayfly_is_enabled>:

uint32_t mayfly_is_enabled(uint8_t caller_id, uint8_t callee_id)
{
	(void)caller_id;

	switch (callee_id) {
   42354:	b129      	cbz	r1, 42362 <mayfly_is_enabled+0xe>
   42356:	3901      	subs	r1, #1
   42358:	2901      	cmp	r1, #1
   4235a:	d805      	bhi.n	42368 <mayfly_is_enabled+0x14>
	case MAYFLY_CALL_ID_LLL:
		return irq_is_enabled(HAL_SWI_RADIO_IRQ);

	case MAYFLY_CALL_ID_WORKER:
		return irq_is_enabled(HAL_SWI_WORKER_IRQ);
   4235c:	200b      	movs	r0, #11
   4235e:	f7ea bd4b 	b.w	2cdf8 <arch_irq_is_enabled>
		return irq_is_enabled(HAL_SWI_RADIO_IRQ);
   42362:	2018      	movs	r0, #24
   42364:	f7ea bd48 	b.w	2cdf8 <arch_irq_is_enabled>
{
   42368:	b508      	push	{r3, lr}

	case MAYFLY_CALL_ID_JOB:
		return irq_is_enabled(HAL_SWI_JOB_IRQ);

	default:
		LL_ASSERT(0);
   4236a:	4a07      	ldr	r2, [pc, #28]	; (42388 <mayfly_is_enabled+0x34>)
   4236c:	4907      	ldr	r1, [pc, #28]	; (4238c <mayfly_is_enabled+0x38>)
   4236e:	4808      	ldr	r0, [pc, #32]	; (42390 <mayfly_is_enabled+0x3c>)
   42370:	2336      	movs	r3, #54	; 0x36
   42372:	f006 fe87 	bl	49084 <assert_print>
   42376:	4040      	eors	r0, r0
   42378:	f380 8811 	msr	BASEPRI, r0
   4237c:	f04f 0003 	mov.w	r0, #3
   42380:	df02      	svc	2
		break;
	}

	return 0;
}
   42382:	2000      	movs	r0, #0
   42384:	bd08      	pop	{r3, pc}
   42386:	bf00      	nop
   42388:	00052d94 	.word	0x00052d94
   4238c:	000521ac 	.word	0x000521ac
   42390:	0005214c 	.word	0x0005214c

00042394 <mayfly_prio_is_equal>:
#endif
#if (CONFIG_BT_CTLR_ULL_HIGH_PRIO == CONFIG_BT_CTLR_ULL_LOW_PRIO)
	       ((caller_id == MAYFLY_CALL_ID_WORKER) &&
		(callee_id == MAYFLY_CALL_ID_JOB)) ||
	       ((caller_id == MAYFLY_CALL_ID_JOB) &&
		(callee_id == MAYFLY_CALL_ID_WORKER)) ||
   42394:	4288      	cmp	r0, r1
   42396:	d00f      	beq.n	423b8 <mayfly_prio_is_equal+0x24>
	return (caller_id == callee_id) ||
   42398:	2801      	cmp	r0, #1
   4239a:	d007      	beq.n	423ac <mayfly_prio_is_equal+0x18>
		(callee_id == MAYFLY_CALL_ID_WORKER)) ||
   4239c:	2802      	cmp	r0, #2
   4239e:	d10d      	bne.n	423bc <mayfly_prio_is_equal+0x28>
	       ((caller_id == MAYFLY_CALL_ID_JOB) &&
   423a0:	f1a1 0001 	sub.w	r0, r1, #1
   423a4:	fab0 f080 	clz	r0, r0
   423a8:	0940      	lsrs	r0, r0, #5
   423aa:	4770      	bx	lr
	       ((caller_id == MAYFLY_CALL_ID_WORKER) &&
   423ac:	f1a1 0002 	sub.w	r0, r1, #2
   423b0:	fab0 f080 	clz	r0, r0
   423b4:	0940      	lsrs	r0, r0, #5
   423b6:	4770      	bx	lr
   423b8:	2001      	movs	r0, #1
   423ba:	4770      	bx	lr
   423bc:	2000      	movs	r0, #0
#endif
	       0;
}
   423be:	4770      	bx	lr

000423c0 <mayfly_pend>:

void mayfly_pend(uint8_t caller_id, uint8_t callee_id)
{
	(void)caller_id;

	switch (callee_id) {
   423c0:	2901      	cmp	r1, #1
{
   423c2:	b508      	push	{r3, lr}
	switch (callee_id) {
   423c4:	d00f      	beq.n	423e6 <mayfly_pend+0x26>
   423c6:	2902      	cmp	r1, #2
   423c8:	d00d      	beq.n	423e6 <mayfly_pend+0x26>
   423ca:	b191      	cbz	r1, 423f2 <mayfly_pend+0x32>
	case MAYFLY_CALL_ID_JOB:
		hal_swi_job_pend();
		break;

	default:
		LL_ASSERT(0);
   423cc:	4a0c      	ldr	r2, [pc, #48]	; (42400 <mayfly_pend+0x40>)
   423ce:	490d      	ldr	r1, [pc, #52]	; (42404 <mayfly_pend+0x44>)
   423d0:	480d      	ldr	r0, [pc, #52]	; (42408 <mayfly_pend+0x48>)
   423d2:	2367      	movs	r3, #103	; 0x67
   423d4:	f006 fe56 	bl	49084 <assert_print>
   423d8:	4040      	eors	r0, r0
   423da:	f380 8811 	msr	BASEPRI, r0
   423de:	f04f 0003 	mov.w	r0, #3
   423e2:	df02      	svc	2
		break;
	}
}
   423e4:	bd08      	pop	{r3, pc}
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   423e6:	4b09      	ldr	r3, [pc, #36]	; (4240c <mayfly_pend+0x4c>)
   423e8:	f44f 6200 	mov.w	r2, #2048	; 0x800
   423ec:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
   423f0:	bd08      	pop	{r3, pc}
   423f2:	4b06      	ldr	r3, [pc, #24]	; (4240c <mayfly_pend+0x4c>)
   423f4:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
   423f8:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
   423fc:	bd08      	pop	{r3, pc}
   423fe:	bf00      	nop
   42400:	00052d94 	.word	0x00052d94
   42404:	000521ac 	.word	0x000521ac
   42408:	0005214c 	.word	0x0005214c
   4240c:	e000e100 	.word	0xe000e100

00042410 <hal_ticker_instance0_caller_id_get>:

uint8_t hal_ticker_instance0_caller_id_get(uint8_t user_id)
{
	uint8_t caller_id;

	LL_ASSERT(user_id < sizeof(caller_id_lut));
   42410:	2803      	cmp	r0, #3
{
   42412:	b510      	push	{r4, lr}
   42414:	4604      	mov	r4, r0
	LL_ASSERT(user_id < sizeof(caller_id_lut));
   42416:	d804      	bhi.n	42422 <hal_ticker_instance0_caller_id_get+0x12>

	caller_id = caller_id_lut[user_id];
   42418:	4b11      	ldr	r3, [pc, #68]	; (42460 <hal_ticker_instance0_caller_id_get+0x50>)
   4241a:	5d1c      	ldrb	r4, [r3, r4]
	LL_ASSERT(caller_id != TICKER_CALL_ID_NONE);
   4241c:	b18c      	cbz	r4, 42442 <hal_ticker_instance0_caller_id_get+0x32>

	return caller_id;
}
   4241e:	4620      	mov	r0, r4
   42420:	bd10      	pop	{r4, pc}
	LL_ASSERT(user_id < sizeof(caller_id_lut));
   42422:	4a10      	ldr	r2, [pc, #64]	; (42464 <hal_ticker_instance0_caller_id_get+0x54>)
   42424:	4910      	ldr	r1, [pc, #64]	; (42468 <hal_ticker_instance0_caller_id_get+0x58>)
   42426:	4811      	ldr	r0, [pc, #68]	; (4246c <hal_ticker_instance0_caller_id_get+0x5c>)
   42428:	232b      	movs	r3, #43	; 0x2b
   4242a:	f006 fe2b 	bl	49084 <assert_print>
   4242e:	4040      	eors	r0, r0
   42430:	f380 8811 	msr	BASEPRI, r0
   42434:	f04f 0003 	mov.w	r0, #3
   42438:	df02      	svc	2
	caller_id = caller_id_lut[user_id];
   4243a:	4b09      	ldr	r3, [pc, #36]	; (42460 <hal_ticker_instance0_caller_id_get+0x50>)
   4243c:	5d1c      	ldrb	r4, [r3, r4]
	LL_ASSERT(caller_id != TICKER_CALL_ID_NONE);
   4243e:	2c00      	cmp	r4, #0
   42440:	d1ed      	bne.n	4241e <hal_ticker_instance0_caller_id_get+0xe>
   42442:	4a08      	ldr	r2, [pc, #32]	; (42464 <hal_ticker_instance0_caller_id_get+0x54>)
   42444:	490a      	ldr	r1, [pc, #40]	; (42470 <hal_ticker_instance0_caller_id_get+0x60>)
   42446:	4809      	ldr	r0, [pc, #36]	; (4246c <hal_ticker_instance0_caller_id_get+0x5c>)
   42448:	232e      	movs	r3, #46	; 0x2e
   4244a:	f006 fe1b 	bl	49084 <assert_print>
   4244e:	4040      	eors	r0, r0
   42450:	f380 8811 	msr	BASEPRI, r0
   42454:	f04f 0003 	mov.w	r0, #3
   42458:	df02      	svc	2
}
   4245a:	4620      	mov	r0, r4
   4245c:	bd10      	pop	{r4, pc}
   4245e:	bf00      	nop
   42460:	00052e74 	.word	0x00052e74
   42464:	00052df4 	.word	0x00052df4
   42468:	00052e44 	.word	0x00052e44
   4246c:	0005214c 	.word	0x0005214c
   42470:	00052e64 	.word	0x00052e64

00042474 <hal_ticker_instance0_sched>:
{
	/* return value not checked as we allow multiple calls to schedule
	 * before being actually needing the work to complete before new
	 * schedule.
	 */
	switch (caller_id) {
   42474:	3801      	subs	r0, #1
{
   42476:	b510      	push	{r4, lr}
   42478:	461c      	mov	r4, r3
	switch (caller_id) {
   4247a:	2804      	cmp	r0, #4
   4247c:	f200 8082 	bhi.w	42584 <hal_ticker_instance0_sched+0x110>
   42480:	e8df f000 	tbb	[pc, r0]
   42484:	3f302112 	.word	0x3f302112
   42488:	03          	.byte	0x03
   42489:	00          	.byte	0x00
			break;
		}
		break;

	case TICKER_CALL_ID_PROGRAM:
		switch (callee_id) {
   4248a:	2904      	cmp	r1, #4
   4248c:	d04a      	beq.n	42524 <hal_ticker_instance0_sched+0xb0>
				       &m);
		}
		break;

		default:
			LL_ASSERT(0);
   4248e:	4a44      	ldr	r2, [pc, #272]	; (425a0 <hal_ticker_instance0_sched+0x12c>)
   42490:	4944      	ldr	r1, [pc, #272]	; (425a4 <hal_ticker_instance0_sched+0x130>)
   42492:	4845      	ldr	r0, [pc, #276]	; (425a8 <hal_ticker_instance0_sched+0x134>)
   42494:	23ba      	movs	r3, #186	; 0xba
   42496:	f006 fdf5 	bl	49084 <assert_print>
   4249a:	4040      	eors	r0, r0
   4249c:	f380 8811 	msr	BASEPRI, r0
   424a0:	f04f 0003 	mov.w	r0, #3
   424a4:	df02      	svc	2

	default:
		LL_ASSERT(0);
		break;
	}
}
   424a6:	bd10      	pop	{r4, pc}
		switch (callee_id) {
   424a8:	2904      	cmp	r1, #4
   424aa:	d043      	beq.n	42534 <hal_ticker_instance0_sched+0xc0>
			LL_ASSERT(0);
   424ac:	4a3c      	ldr	r2, [pc, #240]	; (425a0 <hal_ticker_instance0_sched+0x12c>)
   424ae:	493d      	ldr	r1, [pc, #244]	; (425a4 <hal_ticker_instance0_sched+0x130>)
   424b0:	483d      	ldr	r0, [pc, #244]	; (425a8 <hal_ticker_instance0_sched+0x134>)
   424b2:	234e      	movs	r3, #78	; 0x4e
   424b4:	f006 fde6 	bl	49084 <assert_print>
   424b8:	4040      	eors	r0, r0
   424ba:	f380 8811 	msr	BASEPRI, r0
   424be:	f04f 0003 	mov.w	r0, #3
   424c2:	df02      	svc	2
}
   424c4:	bd10      	pop	{r4, pc}
		switch (callee_id) {
   424c6:	2903      	cmp	r1, #3
   424c8:	d03c      	beq.n	42544 <hal_ticker_instance0_sched+0xd0>
			LL_ASSERT(0);
   424ca:	4a35      	ldr	r2, [pc, #212]	; (425a0 <hal_ticker_instance0_sched+0x12c>)
   424cc:	4935      	ldr	r1, [pc, #212]	; (425a4 <hal_ticker_instance0_sched+0x130>)
   424ce:	4836      	ldr	r0, [pc, #216]	; (425a8 <hal_ticker_instance0_sched+0x134>)
   424d0:	2365      	movs	r3, #101	; 0x65
   424d2:	f006 fdd7 	bl	49084 <assert_print>
   424d6:	4040      	eors	r0, r0
   424d8:	f380 8811 	msr	BASEPRI, r0
   424dc:	f04f 0003 	mov.w	r0, #3
   424e0:	df02      	svc	2
}
   424e2:	bd10      	pop	{r4, pc}
		switch (callee_id) {
   424e4:	2904      	cmp	r1, #4
   424e6:	d035      	beq.n	42554 <hal_ticker_instance0_sched+0xe0>
			LL_ASSERT(0);
   424e8:	4a2d      	ldr	r2, [pc, #180]	; (425a0 <hal_ticker_instance0_sched+0x12c>)
   424ea:	492e      	ldr	r1, [pc, #184]	; (425a4 <hal_ticker_instance0_sched+0x130>)
   424ec:	482e      	ldr	r0, [pc, #184]	; (425a8 <hal_ticker_instance0_sched+0x134>)
   424ee:	237c      	movs	r3, #124	; 0x7c
   424f0:	f006 fdc8 	bl	49084 <assert_print>
   424f4:	4040      	eors	r0, r0
   424f6:	f380 8811 	msr	BASEPRI, r0
   424fa:	f04f 0003 	mov.w	r0, #3
   424fe:	df02      	svc	2
}
   42500:	bd10      	pop	{r4, pc}
		switch (callee_id) {
   42502:	2903      	cmp	r1, #3
   42504:	d036      	beq.n	42574 <hal_ticker_instance0_sched+0x100>
   42506:	2904      	cmp	r1, #4
   42508:	d02c      	beq.n	42564 <hal_ticker_instance0_sched+0xf0>
			LL_ASSERT(0);
   4250a:	4a25      	ldr	r2, [pc, #148]	; (425a0 <hal_ticker_instance0_sched+0x12c>)
   4250c:	4925      	ldr	r1, [pc, #148]	; (425a4 <hal_ticker_instance0_sched+0x130>)
   4250e:	4826      	ldr	r0, [pc, #152]	; (425a8 <hal_ticker_instance0_sched+0x134>)
   42510:	23a2      	movs	r3, #162	; 0xa2
   42512:	f006 fdb7 	bl	49084 <assert_print>
   42516:	4040      	eors	r0, r0
   42518:	f380 8811 	msr	BASEPRI, r0
   4251c:	f04f 0003 	mov.w	r0, #3
   42520:	df02      	svc	2
}
   42522:	bd10      	pop	{r4, pc}
			m.param = instance;
   42524:	4b21      	ldr	r3, [pc, #132]	; (425ac <hal_ticker_instance0_sched+0x138>)
   42526:	609c      	str	r4, [r3, #8]
}
   42528:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_PROGRAM,
   4252c:	2102      	movs	r1, #2
   4252e:	2003      	movs	r0, #3
   42530:	f7f2 b89e 	b.w	34670 <mayfly_enqueue>
			m.param = instance;
   42534:	4b1e      	ldr	r3, [pc, #120]	; (425b0 <hal_ticker_instance0_sched+0x13c>)
   42536:	609c      	str	r4, [r3, #8]
}
   42538:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_ISR,
   4253c:	2102      	movs	r1, #2
   4253e:	2000      	movs	r0, #0
   42540:	f7f2 b896 	b.w	34670 <mayfly_enqueue>
			m.param = instance;
   42544:	4b1b      	ldr	r3, [pc, #108]	; (425b4 <hal_ticker_instance0_sched+0x140>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_TRIGGER,
   42546:	2101      	movs	r1, #1
			m.param = instance;
   42548:	609c      	str	r4, [r3, #8]
}
   4254a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_TRIGGER,
   4254e:	4608      	mov	r0, r1
   42550:	f7f2 b88e 	b.w	34670 <mayfly_enqueue>
			m.param = instance;
   42554:	4b18      	ldr	r3, [pc, #96]	; (425b8 <hal_ticker_instance0_sched+0x144>)
   42556:	609c      	str	r4, [r3, #8]
}
   42558:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_WORKER,
   4255c:	2102      	movs	r1, #2
   4255e:	2001      	movs	r0, #1
   42560:	f7f2 b886 	b.w	34670 <mayfly_enqueue>
			m.param = instance;
   42564:	4b15      	ldr	r3, [pc, #84]	; (425bc <hal_ticker_instance0_sched+0x148>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
   42566:	2102      	movs	r1, #2
			m.param = instance;
   42568:	609c      	str	r4, [r3, #8]
}
   4256a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
   4256e:	4608      	mov	r0, r1
   42570:	f7f2 b87e 	b.w	34670 <mayfly_enqueue>
			m.param = instance;
   42574:	4b12      	ldr	r3, [pc, #72]	; (425c0 <hal_ticker_instance0_sched+0x14c>)
   42576:	609c      	str	r4, [r3, #8]
}
   42578:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
   4257c:	2101      	movs	r1, #1
   4257e:	2002      	movs	r0, #2
   42580:	f7f2 b876 	b.w	34670 <mayfly_enqueue>
		LL_ASSERT(0);
   42584:	4a06      	ldr	r2, [pc, #24]	; (425a0 <hal_ticker_instance0_sched+0x12c>)
   42586:	4907      	ldr	r1, [pc, #28]	; (425a4 <hal_ticker_instance0_sched+0x130>)
   42588:	4807      	ldr	r0, [pc, #28]	; (425a8 <hal_ticker_instance0_sched+0x134>)
   4258a:	23c0      	movs	r3, #192	; 0xc0
   4258c:	f006 fd7a 	bl	49084 <assert_print>
   42590:	4040      	eors	r0, r0
   42592:	f380 8811 	msr	BASEPRI, r0
   42596:	f04f 0003 	mov.w	r0, #3
   4259a:	df02      	svc	2
}
   4259c:	bd10      	pop	{r4, pc}
   4259e:	bf00      	nop
   425a0:	00052df4 	.word	0x00052df4
   425a4:	000521ac 	.word	0x000521ac
   425a8:	0005214c 	.word	0x0005214c
   425ac:	20000cd8 	.word	0x20000cd8
   425b0:	20000d28 	.word	0x20000d28
   425b4:	20000d18 	.word	0x20000d18
   425b8:	20000d08 	.word	0x20000d08
   425bc:	20000ce8 	.word	0x20000ce8
   425c0:	20000cf8 	.word	0x20000cf8

000425c4 <hal_ticker_instance0_trigger_set>:

void hal_ticker_instance0_trigger_set(uint32_t value)
{
   425c4:	4601      	mov	r1, r0
	cntr_cmp_set(0, value);
   425c6:	2000      	movs	r0, #0
   425c8:	f7ff ba2a 	b.w	41a20 <cntr_cmp_set>

000425cc <hci_vendor_read_static_addr>:

#include <soc.h>

uint8_t hci_vendor_read_static_addr(struct bt_hci_vs_static_addr addrs[],
				 uint8_t size)
{
   425cc:	b508      	push	{r3, lr}
	/* only one supported */
	ARG_UNUSED(size);

	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
   425ce:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
{
   425d2:	4684      	mov	ip, r0
	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
   425d4:	f8d3 20a4 	ldr.w	r2, [r3, #164]	; 0xa4
   425d8:	3201      	adds	r2, #1
   425da:	d03e      	beq.n	4265a <hci_vendor_read_static_addr+0x8e>
	    ((NRF_FICR->DEVICEADDR[1] & UINT16_MAX) != UINT16_MAX)) &&
	     (NRF_FICR->DEVICEADDRTYPE & 0x01)) {
   425dc:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   425e0:	f8d2 00a0 	ldr.w	r0, [r2, #160]	; 0xa0
	    ((NRF_FICR->DEVICEADDR[1] & UINT16_MAX) != UINT16_MAX)) &&
   425e4:	f010 0001 	ands.w	r0, r0, #1
   425e8:	d100      	bne.n	425ec <hci_vendor_read_static_addr+0x20>

		return 1;
	}

	return 0;
}
   425ea:	bd08      	pop	{r3, pc}
		sys_put_le32(NRF_FICR->DEVICEADDR[0], &addrs[0].bdaddr.val[0]);
   425ec:	f8d2 30a4 	ldr.w	r3, [r2, #164]	; 0xa4
	dst[0] = val;
   425f0:	f8cc 3000 	str.w	r3, [ip]
		sys_put_le16(NRF_FICR->DEVICEADDR[1], &addrs[0].bdaddr.val[4]);
   425f4:	f8d2 30a8 	ldr.w	r3, [r2, #168]	; 0xa8
   425f8:	f88c 3004 	strb.w	r3, [ip, #4]
	dst[1] = val >> 8;
   425fc:	f3c3 2307 	ubfx	r3, r3, #8, #8
		BT_ADDR_SET_STATIC(&addrs[0].bdaddr);
   42600:	f063 033f 	orn	r3, r3, #63	; 0x3f
   42604:	f88c 3005 	strb.w	r3, [ip, #5]
		if ((NRF_FICR->IR[0] != UINT32_MAX) &&
   42608:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
   4260c:	3301      	adds	r3, #1
   4260e:	d01c      	beq.n	4264a <hci_vendor_read_static_addr+0x7e>
		    (NRF_FICR->IR[1] != UINT32_MAX) &&
   42610:	f8d2 3094 	ldr.w	r3, [r2, #148]	; 0x94
		if ((NRF_FICR->IR[0] != UINT32_MAX) &&
   42614:	3301      	adds	r3, #1
   42616:	d018      	beq.n	4264a <hci_vendor_read_static_addr+0x7e>
		    (NRF_FICR->IR[2] != UINT32_MAX) &&
   42618:	f8d2 3098 	ldr.w	r3, [r2, #152]	; 0x98
		    (NRF_FICR->IR[1] != UINT32_MAX) &&
   4261c:	3301      	adds	r3, #1
   4261e:	d014      	beq.n	4264a <hci_vendor_read_static_addr+0x7e>
		    (NRF_FICR->IR[3] != UINT32_MAX)) {
   42620:	f8d2 309c 	ldr.w	r3, [r2, #156]	; 0x9c
		    (NRF_FICR->IR[2] != UINT32_MAX) &&
   42624:	3301      	adds	r3, #1
   42626:	d010      	beq.n	4264a <hci_vendor_read_static_addr+0x7e>
			sys_put_le32(NRF_FICR->IR[0], &addrs[0].ir[0]);
   42628:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
	dst[0] = val;
   4262c:	f8cc 3006 	str.w	r3, [ip, #6]
			sys_put_le32(NRF_FICR->IR[1], &addrs[0].ir[4]);
   42630:	f8d2 3094 	ldr.w	r3, [r2, #148]	; 0x94
   42634:	f8cc 300a 	str.w	r3, [ip, #10]
			sys_put_le32(NRF_FICR->IR[2], &addrs[0].ir[8]);
   42638:	f8d2 3098 	ldr.w	r3, [r2, #152]	; 0x98
   4263c:	f8cc 300e 	str.w	r3, [ip, #14]
			sys_put_le32(NRF_FICR->IR[3], &addrs[0].ir[12]);
   42640:	f8d2 309c 	ldr.w	r3, [r2, #156]	; 0x9c
   42644:	f8cc 3012 	str.w	r3, [ip, #18]
}
   42648:	e005      	b.n	42656 <hci_vendor_read_static_addr+0x8a>
			(void)memset(addrs[0].ir, 0x00, sizeof(addrs[0].ir));
   4264a:	2210      	movs	r2, #16
   4264c:	2100      	movs	r1, #0
   4264e:	f10c 0006 	add.w	r0, ip, #6
   42652:	f008 fc1d 	bl	4ae90 <memset>
		return 1;
   42656:	2001      	movs	r0, #1
}
   42658:	bd08      	pop	{r3, pc}
	    ((NRF_FICR->DEVICEADDR[1] & UINT16_MAX) != UINT16_MAX)) &&
   4265a:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
   4265e:	f64f 72ff 	movw	r2, #65535	; 0xffff
   42662:	b29b      	uxth	r3, r3
	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
   42664:	4293      	cmp	r3, r2
   42666:	d1b9      	bne.n	425dc <hci_vendor_read_static_addr+0x10>
	return 0;
   42668:	2000      	movs	r0, #0
}
   4266a:	bd08      	pop	{r3, pc}

0004266c <hci_vendor_read_key_hierarchy_roots>:

void hci_vendor_read_key_hierarchy_roots(uint8_t ir[16], uint8_t er[16])
{
   4266c:	b510      	push	{r4, lr}
	/* Mark IR as invalid.
	 * No public address is available, and static address IR should be read
	 * using Read Static Addresses command.
	 */
	(void)memset(ir, 0x00, 16);
   4266e:	2210      	movs	r2, #16
{
   42670:	460c      	mov	r4, r1
	(void)memset(ir, 0x00, 16);
   42672:	2100      	movs	r1, #0
   42674:	f008 fc0c 	bl	4ae90 <memset>

	/* Fill in ER if present */
	if ((NRF_FICR->ER[0] != UINT32_MAX) &&
   42678:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   4267c:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
   42680:	3201      	adds	r2, #1
   42682:	d018      	beq.n	426b6 <hci_vendor_read_key_hierarchy_roots+0x4a>
	    (NRF_FICR->ER[1] != UINT32_MAX) &&
   42684:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
	if ((NRF_FICR->ER[0] != UINT32_MAX) &&
   42688:	3201      	adds	r2, #1
   4268a:	d014      	beq.n	426b6 <hci_vendor_read_key_hierarchy_roots+0x4a>
	    (NRF_FICR->ER[2] != UINT32_MAX) &&
   4268c:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
	    (NRF_FICR->ER[1] != UINT32_MAX) &&
   42690:	3201      	adds	r2, #1
   42692:	d010      	beq.n	426b6 <hci_vendor_read_key_hierarchy_roots+0x4a>
	    (NRF_FICR->ER[3] != UINT32_MAX)) {
   42694:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
	    (NRF_FICR->ER[2] != UINT32_MAX) &&
   42698:	3201      	adds	r2, #1
   4269a:	d00c      	beq.n	426b6 <hci_vendor_read_key_hierarchy_roots+0x4a>
		sys_put_le32(NRF_FICR->ER[0], &er[0]);
   4269c:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
	dst[0] = val;
   426a0:	6022      	str	r2, [r4, #0]
		sys_put_le32(NRF_FICR->ER[1], &er[4]);
   426a2:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
   426a6:	6062      	str	r2, [r4, #4]
		sys_put_le32(NRF_FICR->ER[2], &er[8]);
   426a8:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
   426ac:	60a2      	str	r2, [r4, #8]
		sys_put_le32(NRF_FICR->ER[3], &er[12]);
   426ae:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
   426b2:	60e3      	str	r3, [r4, #12]
	} else {
		/* Mark ER as invalid */
		(void)memset(er, 0x00, 16);
	}
}
   426b4:	bd10      	pop	{r4, pc}
		(void)memset(er, 0x00, 16);
   426b6:	4620      	mov	r0, r4
   426b8:	2210      	movs	r2, #16
}
   426ba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		(void)memset(er, 0x00, 16);
   426be:	2100      	movs	r1, #0
   426c0:	f008 bbe6 	b.w	4ae90 <memset>

000426c4 <net_buf_pool_get>:
extern struct net_buf_pool _net_buf_pool_list[];

struct net_buf_pool *net_buf_pool_get(int id)
{
	return &_net_buf_pool_list[id];
}
   426c4:	4b02      	ldr	r3, [pc, #8]	; (426d0 <net_buf_pool_get+0xc>)
   426c6:	222c      	movs	r2, #44	; 0x2c
   426c8:	fb02 3000 	mla	r0, r2, r0, r3
   426cc:	4770      	bx	lr
   426ce:	bf00      	nop
   426d0:	200012e4 	.word	0x200012e4

000426d4 <net_buf_id>:
	return pool - _net_buf_pool_list;
}

int net_buf_id(struct net_buf *buf)
{
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
   426d4:	7982      	ldrb	r2, [r0, #6]
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
				__alignof__(struct net_buf));
	ptrdiff_t offset = (uint8_t *)buf - (uint8_t *)pool->__bufs;
   426d6:	4b06      	ldr	r3, [pc, #24]	; (426f0 <net_buf_id+0x1c>)
   426d8:	212c      	movs	r1, #44	; 0x2c
   426da:	fb01 3302 	mla	r3, r1, r2, r3
   426de:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
   426e0:	7f1b      	ldrb	r3, [r3, #28]
   426e2:	3317      	adds	r3, #23
	ptrdiff_t offset = (uint8_t *)buf - (uint8_t *)pool->__bufs;
   426e4:	1a80      	subs	r0, r0, r2
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
   426e6:	f023 0303 	bic.w	r3, r3, #3

	return offset / struct_size;
}
   426ea:	fbb0 f0f3 	udiv	r0, r0, r3
   426ee:	4770      	bx	lr
   426f0:	200012e4 	.word	0x200012e4

000426f4 <fixed_data_alloc>:
	.unref = mem_pool_data_unref,
};

static uint8_t *fixed_data_alloc(struct net_buf *buf, size_t *size,
			      k_timeout_t timeout)
{
   426f4:	b538      	push	{r3, r4, r5, lr}
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
   426f6:	4b0a      	ldr	r3, [pc, #40]	; (42720 <fixed_data_alloc+0x2c>)
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
   426f8:	7982      	ldrb	r2, [r0, #6]
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
   426fa:	242c      	movs	r4, #44	; 0x2c
   426fc:	fb04 3302 	mla	r3, r4, r2, r3

	*size = MIN(fixed->data_size, *size);
   42700:	680c      	ldr	r4, [r1, #0]
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
   42702:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   42704:	685b      	ldr	r3, [r3, #4]
	*size = MIN(fixed->data_size, *size);
   42706:	681a      	ldr	r2, [r3, #0]
   42708:	4294      	cmp	r4, r2
   4270a:	bf94      	ite	ls
   4270c:	600c      	strls	r4, [r1, #0]
   4270e:	600a      	strhi	r2, [r1, #0]

	return fixed->data_pool + fixed->data_size * net_buf_id(buf);
   42710:	e9d3 5400 	ldrd	r5, r4, [r3]
   42714:	f7ff ffde 	bl	426d4 <net_buf_id>
}
   42718:	fb05 4000 	mla	r0, r5, r0, r4
   4271c:	bd38      	pop	{r3, r4, r5, pc}
   4271e:	bf00      	nop
   42720:	200012e4 	.word	0x200012e4

00042724 <net_buf_alloc_len>:
					int line)
#else
struct net_buf *net_buf_alloc_len(struct net_buf_pool *pool, size_t size,
				  k_timeout_t timeout)
#endif
{
   42724:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   42728:	4605      	mov	r5, r0
   4272a:	9101      	str	r1, [sp, #4]
	uint64_t end = sys_clock_timeout_end_calc(timeout);
   4272c:	4610      	mov	r0, r2
   4272e:	4619      	mov	r1, r3
{
   42730:	4691      	mov	r9, r2
   42732:	4698      	mov	r8, r3
   42734:	4617      	mov	r7, r2
   42736:	461e      	mov	r6, r3
	uint64_t end = sys_clock_timeout_end_calc(timeout);
   42738:	f00d fe18 	bl	5036c <sys_clock_timeout_end_calc>
   4273c:	4682      	mov	sl, r0
   4273e:	468b      	mov	fp, r1
	__asm__ volatile(
   42740:	f04f 0320 	mov.w	r3, #32
   42744:	f3ef 8111 	mrs	r1, BASEPRI
   42748:	f383 8812 	msr	BASEPRI_MAX, r3
   4274c:	f3bf 8f6f 	isb	sy
	key = k_spin_lock(&pool->lock);

	/* If there are uninitialized buffers we're guaranteed to succeed
	 * with the allocation one way or another.
	 */
	if (pool->uninit_count) {
   42750:	8b6b      	ldrh	r3, [r5, #26]
   42752:	2b00      	cmp	r3, #0
   42754:	d058      	beq.n	42808 <net_buf_alloc_len+0xe4>

		/* If this is not the first access to the pool, we can
		 * be opportunistic and try to fetch a previously used
		 * buffer from the LIFO with K_NO_WAIT.
		 */
		if (pool->uninit_count < pool->buf_count) {
   42756:	8b2a      	ldrh	r2, [r5, #24]
   42758:	429a      	cmp	r2, r3
   4275a:	d93c      	bls.n	427d6 <net_buf_alloc_len+0xb2>
   4275c:	9100      	str	r1, [sp, #0]
	return z_impl_k_queue_get(queue, timeout);
   4275e:	2200      	movs	r2, #0
   42760:	2300      	movs	r3, #0
   42762:	4628      	mov	r0, r5
   42764:	f004 fcd4 	bl	47110 <z_impl_k_queue_get>
			buf = k_lifo_get(&pool->free, K_NO_WAIT);
			if (buf) {
   42768:	9900      	ldr	r1, [sp, #0]
   4276a:	4604      	mov	r4, r0
   4276c:	2800      	cmp	r0, #0
   4276e:	d032      	beq.n	427d6 <net_buf_alloc_len+0xb2>
	__asm__ volatile(
   42770:	f381 8811 	msr	BASEPRI, r1
   42774:	f3bf 8f6f 	isb	sy
	}

success:
	NET_BUF_DBG("allocated buf %p", buf);

	if (size) {
   42778:	9b01      	ldr	r3, [sp, #4]
   4277a:	2b00      	cmp	r3, #0
   4277c:	d055      	beq.n	4282a <net_buf_alloc_len+0x106>
#if __ASSERT_ON
		size_t req_size = size;
#endif
		if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
   4277e:	ea58 0309 	orrs.w	r3, r8, r9
   42782:	d00f      	beq.n	427a4 <net_buf_alloc_len+0x80>
   42784:	f1b8 3fff 	cmp.w	r8, #4294967295	; 0xffffffff
   42788:	bf08      	it	eq
   4278a:	f1b9 3fff 	cmpeq.w	r9, #4294967295	; 0xffffffff
   4278e:	d009      	beq.n	427a4 <net_buf_alloc_len+0x80>
		    !K_TIMEOUT_EQ(timeout, K_FOREVER)) {
			int64_t remaining = end - sys_clock_tick_get();
   42790:	f005 fbd0 	bl	47f34 <sys_clock_tick_get>
   42794:	ebba 0700 	subs.w	r7, sl, r0
   42798:	eb6b 0601 	sbc.w	r6, fp, r1

			if (remaining <= 0) {
   4279c:	2e00      	cmp	r6, #0
   4279e:	bfbc      	itt	lt
   427a0:	2700      	movlt	r7, #0
   427a2:	463e      	movlt	r6, r7
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
   427a4:	79a3      	ldrb	r3, [r4, #6]
	return pool->alloc->cb->alloc(buf, size, timeout);
   427a6:	4d26      	ldr	r5, [pc, #152]	; (42840 <net_buf_alloc_len+0x11c>)
   427a8:	f04f 082c 	mov.w	r8, #44	; 0x2c
   427ac:	fb08 5303 	mla	r3, r8, r3, r5
   427b0:	463a      	mov	r2, r7
   427b2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   427b4:	681b      	ldr	r3, [r3, #0]
   427b6:	a901      	add	r1, sp, #4
   427b8:	f8d3 9000 	ldr.w	r9, [r3]
   427bc:	4620      	mov	r0, r4
   427be:	4633      	mov	r3, r6
   427c0:	47c8      	blx	r9
			} else {
				timeout = Z_TIMEOUT_TICKS(remaining);
			}
		}

		buf->__buf = data_alloc(buf, &size, timeout);
   427c2:	6120      	str	r0, [r4, #16]
		if (!buf->__buf) {
   427c4:	2800      	cmp	r0, #0
   427c6:	d131      	bne.n	4282c <net_buf_alloc_len+0x108>
	k_lifo_put(&pool->free, buf);
   427c8:	79a0      	ldrb	r0, [r4, #6]
   427ca:	4621      	mov	r1, r4
   427cc:	fb00 5008 	mla	r0, r0, r8, r5
   427d0:	f00d fb09 	bl	4fde6 <k_queue_prepend>
}
   427d4:	e024      	b.n	42820 <net_buf_alloc_len+0xfc>
		uninit_count = pool->uninit_count--;
   427d6:	8b68      	ldrh	r0, [r5, #26]
   427d8:	1e43      	subs	r3, r0, #1
   427da:	836b      	strh	r3, [r5, #26]
   427dc:	f381 8811 	msr	BASEPRI, r1
   427e0:	f3bf 8f6f 	isb	sy
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
   427e4:	7f2b      	ldrb	r3, [r5, #28]
	size_t byte_offset = (pool->buf_count - uninit_count) * struct_size;
   427e6:	8b2a      	ldrh	r2, [r5, #24]
	buf = (struct net_buf *)(((uint8_t *)pool->__bufs) + byte_offset);
   427e8:	6aac      	ldr	r4, [r5, #40]	; 0x28
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
   427ea:	3317      	adds	r3, #23
   427ec:	f023 0303 	bic.w	r3, r3, #3
	size_t byte_offset = (pool->buf_count - uninit_count) * struct_size;
   427f0:	1a12      	subs	r2, r2, r0
	buf = (struct net_buf *)(((uint8_t *)pool->__bufs) + byte_offset);
   427f2:	fb02 4403 	mla	r4, r2, r3, r4
	return pool - _net_buf_pool_list;
   427f6:	4b12      	ldr	r3, [pc, #72]	; (42840 <net_buf_alloc_len+0x11c>)
   427f8:	4a12      	ldr	r2, [pc, #72]	; (42844 <net_buf_alloc_len+0x120>)
   427fa:	1aeb      	subs	r3, r5, r3
   427fc:	109b      	asrs	r3, r3, #2
   427fe:	4353      	muls	r3, r2
	buf->pool_id = pool_id(pool);
   42800:	71a3      	strb	r3, [r4, #6]
	buf->user_data_size = pool->user_data_size;
   42802:	7f2b      	ldrb	r3, [r5, #28]
   42804:	71e3      	strb	r3, [r4, #7]
		goto success;
   42806:	e7b7      	b.n	42778 <net_buf_alloc_len+0x54>
   42808:	f381 8811 	msr	BASEPRI, r1
   4280c:	f3bf 8f6f 	isb	sy
   42810:	464a      	mov	r2, r9
   42812:	4643      	mov	r3, r8
   42814:	4628      	mov	r0, r5
   42816:	f004 fc7b 	bl	47110 <z_impl_k_queue_get>
	if (!buf) {
   4281a:	4604      	mov	r4, r0
   4281c:	2800      	cmp	r0, #0
   4281e:	d1ab      	bne.n	42778 <net_buf_alloc_len+0x54>
		return NULL;
   42820:	2400      	movs	r4, #0
#if defined(CONFIG_NET_BUF_POOL_USAGE)
	atomic_dec(&pool->avail_count);
	__ASSERT_NO_MSG(atomic_get(&pool->avail_count) >= 0);
#endif
	return buf;
}
   42822:	4620      	mov	r0, r4
   42824:	b003      	add	sp, #12
   42826:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		buf->__buf = NULL;
   4282a:	6123      	str	r3, [r4, #16]
	buf->frags = NULL;
   4282c:	2300      	movs	r3, #0
   4282e:	6023      	str	r3, [r4, #0]
	buf->ref   = 1U;
   42830:	2201      	movs	r2, #1
   42832:	80a2      	strh	r2, [r4, #4]
	buf->len  = 0U;
   42834:	81a3      	strh	r3, [r4, #12]
	buf->size  = size;
   42836:	9a01      	ldr	r2, [sp, #4]
	buf->data = buf->__buf;
   42838:	6923      	ldr	r3, [r4, #16]
   4283a:	81e2      	strh	r2, [r4, #14]
   4283c:	60a3      	str	r3, [r4, #8]
	return buf;
   4283e:	e7f0      	b.n	42822 <net_buf_alloc_len+0xfe>
   42840:	200012e4 	.word	0x200012e4
   42844:	ba2e8ba3 	.word	0xba2e8ba3

00042848 <net_buf_unref>:
#if defined(CONFIG_NET_BUF_LOG)
void net_buf_unref_debug(struct net_buf *buf, const char *func, int line)
#else
void net_buf_unref(struct net_buf *buf)
#endif
{
   42848:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4284c:	4d16      	ldr	r5, [pc, #88]	; (428a8 <net_buf_unref+0x60>)
   4284e:	4604      	mov	r4, r0
			return;
		}

		if (buf->__buf) {
			data_unref(buf, buf->__buf);
			buf->__buf = NULL;
   42850:	2600      	movs	r6, #0
	pool->alloc->cb->unref(buf, data);
   42852:	272c      	movs	r7, #44	; 0x2c
	while (buf) {
   42854:	b90c      	cbnz	r4, 4285a <net_buf_unref+0x12>
			net_buf_destroy(buf);
		}

		buf = frags;
	}
}
   42856:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (--buf->ref > 0) {
   4285a:	7923      	ldrb	r3, [r4, #4]
		struct net_buf *frags = buf->frags;
   4285c:	f8d4 8000 	ldr.w	r8, [r4]
		if (--buf->ref > 0) {
   42860:	3b01      	subs	r3, #1
   42862:	b2db      	uxtb	r3, r3
   42864:	7123      	strb	r3, [r4, #4]
   42866:	2b00      	cmp	r3, #0
   42868:	d1f5      	bne.n	42856 <net_buf_unref+0xe>
		if (buf->__buf) {
   4286a:	6921      	ldr	r1, [r4, #16]
   4286c:	b159      	cbz	r1, 42886 <net_buf_unref+0x3e>
	if (buf->flags & NET_BUF_EXTERNAL_DATA) {
   4286e:	7963      	ldrb	r3, [r4, #5]
   42870:	079b      	lsls	r3, r3, #30
   42872:	d407      	bmi.n	42884 <net_buf_unref+0x3c>
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
   42874:	79a3      	ldrb	r3, [r4, #6]
	pool->alloc->cb->unref(buf, data);
   42876:	fb07 5303 	mla	r3, r7, r3, r5
   4287a:	4620      	mov	r0, r4
   4287c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   4287e:	681b      	ldr	r3, [r3, #0]
   42880:	689b      	ldr	r3, [r3, #8]
   42882:	4798      	blx	r3
			buf->__buf = NULL;
   42884:	6126      	str	r6, [r4, #16]
		pool = net_buf_pool_get(buf->pool_id);
   42886:	79a0      	ldrb	r0, [r4, #6]
		buf->data = NULL;
   42888:	60a6      	str	r6, [r4, #8]
		if (pool->destroy) {
   4288a:	fb07 5300 	mla	r3, r7, r0, r5
		buf->frags = NULL;
   4288e:	6026      	str	r6, [r4, #0]
		if (pool->destroy) {
   42890:	6a1b      	ldr	r3, [r3, #32]
   42892:	b11b      	cbz	r3, 4289c <net_buf_unref+0x54>
			pool->destroy(buf);
   42894:	4620      	mov	r0, r4
   42896:	4798      	blx	r3
{
   42898:	4644      	mov	r4, r8
   4289a:	e7db      	b.n	42854 <net_buf_unref+0xc>
	k_lifo_put(&pool->free, buf);
   4289c:	4621      	mov	r1, r4
   4289e:	fb00 5007 	mla	r0, r0, r7, r5
   428a2:	f00d faa0 	bl	4fde6 <k_queue_prepend>
}
   428a6:	e7f7      	b.n	42898 <net_buf_unref+0x50>
   428a8:	200012e4 	.word	0x200012e4

000428ac <net_buf_append_bytes>:
 * the buffer. It assumes that the buffer has at least one fragment.
 */
size_t net_buf_append_bytes(struct net_buf *buf, size_t len,
			    const void *value, k_timeout_t timeout,
			    net_buf_allocator_cb allocate_cb, void *user_data)
{
   428ac:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   428b0:	4606      	mov	r6, r0
   428b2:	460d      	mov	r5, r1
   428b4:	4617      	mov	r7, r2
	while (buf->frags) {
   428b6:	4604      	mov	r4, r0
   428b8:	4621      	mov	r1, r4
   428ba:	6824      	ldr	r4, [r4, #0]
   428bc:	2c00      	cmp	r4, #0
   428be:	d1fb      	bne.n	428b8 <net_buf_append_bytes+0xc>
	return &_net_buf_pool_list[id];
   428c0:	f8df a060 	ldr.w	sl, [pc, #96]	; 42924 <net_buf_append_bytes+0x78>
   428c4:	f04f 092c 	mov.w	r9, #44	; 0x2c
	return net_buf_simple_tailroom(&buf->b);
   428c8:	f101 0b08 	add.w	fp, r1, #8
   428cc:	4658      	mov	r0, fp
   428ce:	f00c fabe 	bl	4ee4e <net_buf_simple_tailroom>
	struct net_buf *frag = net_buf_frag_last(buf);
	size_t added_len = 0;
	const uint8_t *value8 = value;

	do {
		uint16_t count = MIN(len, net_buf_tailroom(frag));
   428d2:	4285      	cmp	r5, r0
   428d4:	bf2c      	ite	cs
   428d6:	fa1f f880 	uxthcs.w	r8, r0
   428da:	fa1f f885 	uxthcc.w	r8, r5
	return net_buf_simple_add_mem(&buf->b, mem, len);
   428de:	4639      	mov	r1, r7
   428e0:	4642      	mov	r2, r8
   428e2:	4658      	mov	r0, fp
   428e4:	f00c fa6c 	bl	4edc0 <net_buf_simple_add_mem>
		net_buf_add_mem(frag, value8, count);
		len -= count;
		added_len += count;
		value8 += count;

		if (len == 0) {
   428e8:	ebb5 0508 	subs.w	r5, r5, r8
		added_len += count;
   428ec:	4444      	add	r4, r8
		value8 += count;
   428ee:	4447      	add	r7, r8
		if (len == 0) {
   428f0:	d014      	beq.n	4291c <net_buf_append_bytes+0x70>
			return added_len;
		}

		if (allocate_cb) {
   428f2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   428f4:	b14b      	cbz	r3, 4290a <net_buf_append_bytes+0x5e>
			frag = allocate_cb(timeout, user_data);
   428f6:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
   428fa:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   428fc:	4798      	blx	r3

			/* Allocate from the original pool if no callback has
			 * been provided.
			 */
			pool = net_buf_pool_get(buf->pool_id);
			frag = net_buf_alloc_len(pool, len, timeout);
   428fe:	4601      	mov	r1, r0
		}

		if (!frag) {
   42900:	b160      	cbz	r0, 4291c <net_buf_append_bytes+0x70>
			return added_len;
		}

		net_buf_frag_add(buf, frag);
   42902:	4630      	mov	r0, r6
   42904:	f00c fa39 	bl	4ed7a <net_buf_frag_add>
	do {
   42908:	e7de      	b.n	428c8 <net_buf_append_bytes+0x1c>
	return &_net_buf_pool_list[id];
   4290a:	79b0      	ldrb	r0, [r6, #6]
			frag = net_buf_alloc_len(pool, len, timeout);
   4290c:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
   42910:	4629      	mov	r1, r5
   42912:	fb00 a009 	mla	r0, r0, r9, sl
   42916:	f7ff ff05 	bl	42724 <net_buf_alloc_len>
   4291a:	e7f0      	b.n	428fe <net_buf_append_bytes+0x52>
	} while (1);

	/* Unreachable */
	return 0;
}
   4291c:	4620      	mov	r0, r4
   4291e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   42922:	bf00      	nop
   42924:	200012e4 	.word	0x200012e4

00042928 <hid_int_in>:

	return -EINVAL;
}

static void hid_int_in(uint8_t ep, enum usb_dc_ep_cb_status_code ep_status)
{
   42928:	b510      	push	{r4, lr}
   4292a:	460c      	mov	r4, r1
	struct hid_device_info *dev_data;
	struct usb_dev_data *common;

	common = usb_get_dev_data_by_ep(&usb_hid_devlist, ep);
   4292c:	4601      	mov	r1, r0
   4292e:	4808      	ldr	r0, [pc, #32]	; (42950 <hid_int_in+0x28>)
   42930:	f006 feb6 	bl	496a0 <usb_get_dev_data_by_ep>
	if (common == NULL) {
   42934:	b150      	cbz	r0, 4294c <hid_int_in+0x24>
		return;
	}

	dev_data = CONTAINER_OF(common, struct hid_device_info, common);

	if (ep_status != USB_DC_EP_DATA_IN || dev_data->ops == NULL ||
   42936:	2c02      	cmp	r4, #2
   42938:	d108      	bne.n	4294c <hid_int_in+0x24>
   4293a:	f850 3c08 	ldr.w	r3, [r0, #-8]
   4293e:	b12b      	cbz	r3, 4294c <hid_int_in+0x24>
	    dev_data->ops->int_in_ready == NULL) {
   42940:	691b      	ldr	r3, [r3, #16]
	if (ep_status != USB_DC_EP_DATA_IN || dev_data->ops == NULL ||
   42942:	b11b      	cbz	r3, 4294c <hid_int_in+0x24>
		return;
	}

	dev_data->ops->int_in_ready(common->dev);
}
   42944:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	dev_data->ops->int_in_ready(common->dev);
   42948:	6800      	ldr	r0, [r0, #0]
   4294a:	4718      	bx	r3
}
   4294c:	bd10      	pop	{r4, pc}
   4294e:	bf00      	nop
   42950:	20005c8c 	.word	0x20005c8c

00042954 <hid_custom_handle_req>:
{
   42954:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (usb_reqtype_is_to_host(setup) &&
   42956:	f990 3000 	ldrsb.w	r3, [r0]
   4295a:	2b00      	cmp	r3, #0
{
   4295c:	4604      	mov	r4, r0
   4295e:	460d      	mov	r5, r1
   42960:	4617      	mov	r7, r2
	if (usb_reqtype_is_to_host(setup) &&
   42962:	db02      	blt.n	4296a <hid_custom_handle_req+0x16>
			return -EINVAL;
   42964:	f06f 0015 	mvn.w	r0, #21
}
   42968:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	    setup->RequestType.recipient == USB_REQTYPE_RECIPIENT_INTERFACE &&
   4296a:	8803      	ldrh	r3, [r0, #0]
   4296c:	f023 03e0 	bic.w	r3, r3, #224	; 0xe0
   42970:	b29b      	uxth	r3, r3
   42972:	f240 6201 	movw	r2, #1537	; 0x601
   42976:	4293      	cmp	r3, r2
   42978:	d1f4      	bne.n	42964 <hid_custom_handle_req+0x10>
		uint8_t value = (uint8_t)(setup->wValue >> 8);
   4297a:	8846      	ldrh	r6, [r0, #2]
		common = usb_get_dev_data_by_iface(&usb_hid_devlist, iface_num);
   4297c:	7901      	ldrb	r1, [r0, #4]
   4297e:	4812      	ldr	r0, [pc, #72]	; (429c8 <hid_custom_handle_req+0x74>)
		uint8_t value = (uint8_t)(setup->wValue >> 8);
   42980:	0a36      	lsrs	r6, r6, #8
		common = usb_get_dev_data_by_iface(&usb_hid_devlist, iface_num);
   42982:	f006 fe7f 	bl	49684 <usb_get_dev_data_by_iface>
		if (common == NULL) {
   42986:	2800      	cmp	r0, #0
   42988:	d0ec      	beq.n	42964 <hid_custom_handle_req+0x10>
		switch (value) {
   4298a:	2e21      	cmp	r6, #33	; 0x21
   4298c:	d004      	beq.n	42998 <hid_custom_handle_req+0x44>
   4298e:	2e22      	cmp	r6, #34	; 0x22
   42990:	d00f      	beq.n	429b2 <hid_custom_handle_req+0x5e>
   42992:	f06f 0085 	mvn.w	r0, #133	; 0x85
   42996:	e7e7      	b.n	42968 <hid_custom_handle_req+0x14>
			cfg = common->dev->config;
   42998:	6803      	ldr	r3, [r0, #0]
			*len = MIN(setup->wLength, hid_desc->if0_hid.bLength);
   4299a:	88e1      	ldrh	r1, [r4, #6]
			hid_desc = cfg->interface_descriptor;
   4299c:	685b      	ldr	r3, [r3, #4]
			*len = MIN(setup->wLength, hid_desc->if0_hid.bLength);
   4299e:	685b      	ldr	r3, [r3, #4]
   429a0:	f813 2f09 	ldrb.w	r2, [r3, #9]!
   429a4:	4291      	cmp	r1, r2
   429a6:	bf94      	ite	ls
   429a8:	6029      	strls	r1, [r5, #0]
   429aa:	602a      	strhi	r2, [r5, #0]
			*data = (uint8_t *)dev_data->report_desc;
   429ac:	603b      	str	r3, [r7, #0]
		return 0;
   429ae:	2000      	movs	r0, #0
   429b0:	e7da      	b.n	42968 <hid_custom_handle_req+0x14>
			*len = MIN(setup->wLength, dev_data->report_size);
   429b2:	88e3      	ldrh	r3, [r4, #6]
   429b4:	f850 2c0c 	ldr.w	r2, [r0, #-12]
   429b8:	429a      	cmp	r2, r3
   429ba:	bf94      	ite	ls
   429bc:	602a      	strls	r2, [r5, #0]
   429be:	602b      	strhi	r3, [r5, #0]
			*data = (uint8_t *)dev_data->report_desc;
   429c0:	f850 3c10 	ldr.w	r3, [r0, #-16]
			break;
   429c4:	e7f2      	b.n	429ac <hid_custom_handle_req+0x58>
   429c6:	bf00      	nop
   429c8:	20005c8c 	.word	0x20005c8c

000429cc <hid_class_handle_req>:
{
   429cc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   429d0:	4604      	mov	r4, r0
   429d2:	460e      	mov	r6, r1
	common = usb_get_dev_data_by_iface(&usb_hid_devlist,
   429d4:	7901      	ldrb	r1, [r0, #4]
   429d6:	4814      	ldr	r0, [pc, #80]	; (42a28 <hid_class_handle_req+0x5c>)
{
   429d8:	4617      	mov	r7, r2
	common = usb_get_dev_data_by_iface(&usb_hid_devlist,
   429da:	f006 fe53 	bl	49684 <usb_get_dev_data_by_iface>
	if (common == NULL) {
   429de:	4605      	mov	r5, r0
   429e0:	b1d0      	cbz	r0, 42a18 <hid_class_handle_req+0x4c>
	if (usb_reqtype_is_to_host(setup)) {
   429e2:	f994 2000 	ldrsb.w	r2, [r4]
	dev = common->dev;
   429e6:	6800      	ldr	r0, [r0, #0]
		switch (setup->bRequest) {
   429e8:	7863      	ldrb	r3, [r4, #1]
	if (usb_reqtype_is_to_host(setup)) {
   429ea:	2a00      	cmp	r2, #0
   429ec:	da0d      	bge.n	42a0a <hid_class_handle_req+0x3e>
		switch (setup->bRequest) {
   429ee:	2b01      	cmp	r3, #1
   429f0:	d116      	bne.n	42a20 <hid_class_handle_req+0x54>
			if (dev_data->ops && dev_data->ops->get_report) {
   429f2:	f855 3c08 	ldr.w	r3, [r5, #-8]
   429f6:	b19b      	cbz	r3, 42a20 <hid_class_handle_req+0x54>
   429f8:	681d      	ldr	r5, [r3, #0]
			if (dev_data->ops && dev_data->ops->set_report) {
   429fa:	b18d      	cbz	r5, 42a20 <hid_class_handle_req+0x54>
				return dev_data->ops->set_report(dev, setup,
   429fc:	463b      	mov	r3, r7
   429fe:	4632      	mov	r2, r6
   42a00:	4621      	mov	r1, r4
   42a02:	46ac      	mov	ip, r5
}
   42a04:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
				return dev_data->ops->set_report(dev, setup,
   42a08:	4760      	bx	ip
		switch (setup->bRequest) {
   42a0a:	2b09      	cmp	r3, #9
   42a0c:	d108      	bne.n	42a20 <hid_class_handle_req+0x54>
			if (dev_data->ops && dev_data->ops->set_report) {
   42a0e:	f855 3c08 	ldr.w	r3, [r5, #-8]
   42a12:	b12b      	cbz	r3, 42a20 <hid_class_handle_req+0x54>
   42a14:	685d      	ldr	r5, [r3, #4]
   42a16:	e7f0      	b.n	429fa <hid_class_handle_req+0x2e>
		return -ENODEV;
   42a18:	f06f 0012 	mvn.w	r0, #18
}
   42a1c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			return hid_on_get_idle(dev_data, setup, len, data);
   42a20:	f06f 0085 	mvn.w	r0, #133	; 0x85
   42a24:	e7fa      	b.n	42a1c <hid_class_handle_req+0x50>
   42a26:	bf00      	nop
   42a28:	20005c8c 	.word	0x20005c8c

00042a2c <hid_status_cb>:
{
   42a2c:	b510      	push	{r4, lr}
   42a2e:	460c      	mov	r4, r1
	common = usb_get_dev_data_by_cfg(&usb_hid_devlist, cfg);
   42a30:	4601      	mov	r1, r0
   42a32:	480f      	ldr	r0, [pc, #60]	; (42a70 <hid_status_cb+0x44>)
   42a34:	f006 fe1a 	bl	4966c <usb_get_dev_data_by_cfg>
	if (common == NULL) {
   42a38:	b150      	cbz	r0, 42a50 <hid_status_cb+0x24>
	switch (status) {
   42a3a:	1e61      	subs	r1, r4, #1
   42a3c:	2905      	cmp	r1, #5
   42a3e:	d807      	bhi.n	42a50 <hid_status_cb+0x24>
   42a40:	e8df f001 	tbb	[pc, r1]
   42a44:	07030607 	.word	0x07030607
   42a48:	0f0d      	.short	0x0f0d
		dev_data->configured = true;
   42a4a:	2301      	movs	r3, #1
   42a4c:	f800 3c04 	strb.w	r3, [r0, #-4]
}
   42a50:	bd10      	pop	{r4, pc}
		dev_data->configured = false;
   42a52:	2300      	movs	r3, #0
   42a54:	f800 3c04 	strb.w	r3, [r0, #-4]
			dev_data->suspended = false;
   42a58:	f800 3c03 	strb.w	r3, [r0, #-3]
   42a5c:	e7f8      	b.n	42a50 <hid_status_cb+0x24>
		dev_data->suspended = true;
   42a5e:	2301      	movs	r3, #1
   42a60:	e7fa      	b.n	42a58 <hid_status_cb+0x2c>
		if (dev_data->suspended) {
   42a62:	f810 3c03 	ldrb.w	r3, [r0, #-3]
   42a66:	2b00      	cmp	r3, #0
   42a68:	d0f2      	beq.n	42a50 <hid_status_cb+0x24>
			dev_data->suspended = false;
   42a6a:	2300      	movs	r3, #0
   42a6c:	e7f4      	b.n	42a58 <hid_status_cb+0x2c>
   42a6e:	bf00      	nop
   42a70:	20005c8c 	.word	0x20005c8c

00042a74 <usb_hid_register_device>:
	return 0;
}

void usb_hid_register_device(const struct device *dev, const uint8_t *desc,
			     size_t size, const struct hid_ops *ops)
{
   42a74:	b510      	push	{r4, lr}
	struct hid_device_info *dev_data = dev->data;
   42a76:	6904      	ldr	r4, [r0, #16]

	dev_data->report_desc = desc;
	dev_data->report_size = size;
   42a78:	e9c4 1200 	strd	r1, r2, [r4]

	dev_data->ops = ops;
   42a7c:	60a3      	str	r3, [r4, #8]
	parent->next = child;
   42a7e:	2300      	movs	r3, #0
   42a80:	6163      	str	r3, [r4, #20]
	return list->tail;
   42a82:	4b06      	ldr	r3, [pc, #24]	; (42a9c <usb_hid_register_device+0x28>)
	dev_data->common.dev = dev;
   42a84:	6120      	str	r0, [r4, #16]
   42a86:	6859      	ldr	r1, [r3, #4]

	sys_slist_append(&usb_hid_devlist, &dev_data->common.node);
   42a88:	f104 0214 	add.w	r2, r4, #20
Z_GENLIST_APPEND(slist, snode)
   42a8c:	b911      	cbnz	r1, 42a94 <usb_hid_register_device+0x20>
	list->head = node;
   42a8e:	e9c3 2200 	strd	r2, r2, [r3]

	LOG_DBG("Added dev_data %p dev %p to devlist %p", dev_data, dev,
		&usb_hid_devlist);
}
   42a92:	bd10      	pop	{r4, pc}
	parent->next = child;
   42a94:	600a      	str	r2, [r1, #0]
	list->tail = node;
   42a96:	605a      	str	r2, [r3, #4]
   42a98:	e7fb      	b.n	42a92 <usb_hid_register_device+0x1e>
   42a9a:	bf00      	nop
   42a9c:	20005c8c 	.word	0x20005c8c

00042aa0 <xoshiro128_initialize>:
{
	return (x << k) | (x >> (32 - k));
}

static int xoshiro128_initialize(const struct device *dev)
{
   42aa0:	b508      	push	{r3, lr}
   42aa2:	4804      	ldr	r0, [pc, #16]	; (42ab4 <xoshiro128_initialize+0x14>)
   42aa4:	f00c ffef 	bl	4fa86 <z_device_is_ready>
	if (!device_is_ready(entropy_driver)) {
		return -ENODEV;
	}
	return 0;
   42aa8:	2800      	cmp	r0, #0
}
   42aaa:	bf0c      	ite	eq
   42aac:	f06f 0012 	mvneq.w	r0, #18
   42ab0:	2000      	movne	r0, #0
   42ab2:	bd08      	pop	{r3, pc}
   42ab4:	00050874 	.word	0x00050874

00042ab8 <endpoint_ctx>:

static inline bool ep_is_valid(const uint8_t ep)
{
	uint8_t ep_num = USB_EP_GET_IDX(ep);

	if (NRF_USBD_EPIN_CHECK(ep)) {
   42ab8:	0602      	lsls	r2, r0, #24
	uint8_t ep_num = USB_EP_GET_IDX(ep);
   42aba:	f000 037f 	and.w	r3, r0, #127	; 0x7f
	if (NRF_USBD_EPIN_CHECK(ep)) {
   42abe:	d512      	bpl.n	42ae6 <endpoint_ctx+0x2e>
		if (unlikely(ep_num == NRF_USBD_EPISO_FIRST)) {
   42ac0:	2b08      	cmp	r3, #8
   42ac2:	d105      	bne.n	42ad0 <endpoint_ctx+0x18>

	ctx = get_usbd_ctx();
	ep_num = NRF_USBD_EP_NR_GET(ep);

	if (NRF_USBD_EPIN_CHECK(ep)) {
		if (unlikely(NRF_USBD_EPISO_CHECK(ep))) {
   42ac4:	0701      	lsls	r1, r0, #28
	ep_num = NRF_USBD_EP_NR_GET(ep);
   42ac6:	f000 030f 	and.w	r3, r0, #15
		if (unlikely(NRF_USBD_EPISO_CHECK(ep))) {
   42aca:	d506      	bpl.n	42ada <endpoint_ctx+0x22>
			return &ctx->ep_ctx[EP_ISOIN_INDEX];
   42acc:	480e      	ldr	r0, [pc, #56]	; (42b08 <endpoint_ctx+0x50>)
   42ace:	4770      	bx	lr
			if (ep_num >= CFG_EPIN_CNT) {
   42ad0:	f010 0f78 	tst.w	r0, #120	; 0x78
   42ad4:	d112      	bne.n	42afc <endpoint_ctx+0x44>
	ep_num = NRF_USBD_EP_NR_GET(ep);
   42ad6:	f000 030f 	and.w	r3, r0, #15
		} else {
			return &ctx->ep_ctx[ep_num];
   42ada:	204c      	movs	r0, #76	; 0x4c
   42adc:	eb00 1043 	add.w	r0, r0, r3, lsl #5
   42ae0:	4b0a      	ldr	r3, [pc, #40]	; (42b0c <endpoint_ctx+0x54>)
   42ae2:	4418      	add	r0, r3
   42ae4:	4770      	bx	lr
		if (unlikely(ep_num == NRF_USBD_EPISO_FIRST)) {
   42ae6:	2b08      	cmp	r3, #8
   42ae8:	d105      	bne.n	42af6 <endpoint_ctx+0x3e>
		}
	} else {
		if (unlikely(NRF_USBD_EPISO_CHECK(ep))) {
   42aea:	0702      	lsls	r2, r0, #28
	ep_num = NRF_USBD_EP_NR_GET(ep);
   42aec:	f000 030f 	and.w	r3, r0, #15
		if (unlikely(NRF_USBD_EPISO_CHECK(ep))) {
   42af0:	d506      	bpl.n	42b00 <endpoint_ctx+0x48>
			return &ctx->ep_ctx[EP_ISOOUT_INDEX];
   42af2:	4807      	ldr	r0, [pc, #28]	; (42b10 <endpoint_ctx+0x58>)
   42af4:	4770      	bx	lr
			if (ep_num >= CFG_EPOUT_CNT) {
   42af6:	f010 0f78 	tst.w	r0, #120	; 0x78
   42afa:	d0f6      	beq.n	42aea <endpoint_ctx+0x32>
		return NULL;
   42afc:	2000      	movs	r0, #0
					    ep_num];
		}
	}

	return NULL;
}
   42afe:	4770      	bx	lr
			return &ctx->ep_ctx[CFG_EPIN_CNT +
   42b00:	4804      	ldr	r0, [pc, #16]	; (42b14 <endpoint_ctx+0x5c>)
   42b02:	eb00 1043 	add.w	r0, r0, r3, lsl #5
   42b06:	4770      	bx	lr
   42b08:	20005de0 	.word	0x20005de0
   42b0c:	20005c94 	.word	0x20005c94
   42b10:	20005f00 	.word	0x20005f00
   42b14:	20005e00 	.word	0x20005e00

00042b18 <usbd_evt_put>:
 * @brief Enqueue USBD event.
 *
 * @param Pointer to the previously allocated and filled event structure.
 */
static inline void usbd_evt_put(struct usbd_event *ev)
{
   42b18:	4601      	mov	r1, r0
	k_fifo_put(&usbd_evt_fifo, ev);
   42b1a:	4801      	ldr	r0, [pc, #4]	; (42b20 <usbd_evt_put+0x8>)
   42b1c:	f00d b958 	b.w	4fdd0 <k_queue_append>
   42b20:	200012cc 	.word	0x200012cc

00042b24 <usbd_work_schedule>:
	k_work_submit_to_queue(&usbd_work_queue, &get_usbd_ctx()->usb_work);
   42b24:	4901      	ldr	r1, [pc, #4]	; (42b2c <usbd_work_schedule+0x8>)
   42b26:	4802      	ldr	r0, [pc, #8]	; (42b30 <usbd_work_schedule+0xc>)
   42b28:	f00d ba55 	b.w	4ffd6 <k_work_submit_to_queue>
   42b2c:	20005cbc 	.word	0x20005cbc
   42b30:	200034b8 	.word	0x200034b8

00042b34 <usb_init>:
	}
	return 0;
}

static int usb_init(const struct device *arg)
{
   42b34:	b513      	push	{r0, r1, r4, lr}
	};

	/* Ignore the return value, as NRFX_ERROR_ALREADY_INITIALIZED is not
	 * a problem here.
	 */
	(void)nrfx_power_init(&power_config);
   42b36:	480b      	ldr	r0, [pc, #44]	; (42b64 <usb_init+0x30>)
   42b38:	f002 fdf4 	bl	45724 <nrfx_power_init>
	nrfx_power_usbevt_init(&usbevt_config);

	k_work_queue_start(&usbd_work_queue,
   42b3c:	2400      	movs	r4, #0
	nrfx_power_usbevt_init(&usbevt_config);
   42b3e:	480a      	ldr	r0, [pc, #40]	; (42b68 <usb_init+0x34>)
   42b40:	f002 fe36 	bl	457b0 <nrfx_power_usbevt_init>
	k_work_queue_start(&usbd_work_queue,
   42b44:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   42b48:	f44f 6280 	mov.w	r2, #1024	; 0x400
   42b4c:	4907      	ldr	r1, [pc, #28]	; (42b6c <usb_init+0x38>)
   42b4e:	4808      	ldr	r0, [pc, #32]	; (42b70 <usb_init+0x3c>)
   42b50:	9400      	str	r4, [sp, #0]
   42b52:	f004 fcb5 	bl	474c0 <k_work_queue_start>
			   usbd_work_queue_stack,
			   K_KERNEL_STACK_SIZEOF(usbd_work_queue_stack),
			   CONFIG_SYSTEM_WORKQUEUE_PRIORITY, NULL);

	k_work_init(&ctx->usb_work, usbd_work_handler);
   42b56:	4907      	ldr	r1, [pc, #28]	; (42b74 <usb_init+0x40>)
   42b58:	4807      	ldr	r0, [pc, #28]	; (42b78 <usb_init+0x44>)
   42b5a:	f00d fa0f 	bl	4ff7c <k_work_init>

	return 0;
}
   42b5e:	4620      	mov	r0, r4
   42b60:	b002      	add	sp, #8
   42b62:	bd10      	pop	{r4, pc}
   42b64:	000537f0 	.word	0x000537f0
   42b68:	00052e88 	.word	0x00052e88
   42b6c:	20008ca8 	.word	0x20008ca8
   42b70:	200034b8 	.word	0x200034b8
   42b74:	00042e8d 	.word	0x00042e8d
   42b78:	20005cbc 	.word	0x20005cbc

00042b7c <usbd_evt_get>:
   42b7c:	4802      	ldr	r0, [pc, #8]	; (42b88 <usbd_evt_get+0xc>)
   42b7e:	2200      	movs	r2, #0
   42b80:	2300      	movs	r3, #0
   42b82:	f004 bac5 	b.w	47110 <z_impl_k_queue_get>
   42b86:	bf00      	nop
   42b88:	200012cc 	.word	0x200012cc

00042b8c <usbd_evt_flush>:
{
   42b8c:	b510      	push	{r4, lr}
	k_mem_slab_free(&fifo_elem_slab, (void **)&ev->block.data);
   42b8e:	4c05      	ldr	r4, [pc, #20]	; (42ba4 <usbd_evt_flush+0x18>)
		ev = usbd_evt_get();
   42b90:	f7ff fff4 	bl	42b7c <usbd_evt_get>
		if (ev) {
   42b94:	b120      	cbz	r0, 42ba0 <usbd_evt_flush+0x14>
	k_mem_slab_free(&fifo_elem_slab, (void **)&ev->block.data);
   42b96:	1d01      	adds	r1, r0, #4
   42b98:	4620      	mov	r0, r4
   42b9a:	f00d f831 	bl	4fc00 <k_mem_slab_free>
	} while (ev != NULL);
   42b9e:	e7f7      	b.n	42b90 <usbd_evt_flush+0x4>
}
   42ba0:	bd10      	pop	{r4, pc}
   42ba2:	bf00      	nop
   42ba4:	200010a8 	.word	0x200010a8

00042ba8 <usbd_evt_alloc>:
{
   42ba8:	b507      	push	{r0, r1, r2, lr}
	if (k_mem_slab_alloc(&fifo_elem_slab,
   42baa:	2300      	movs	r3, #0
   42bac:	480e      	ldr	r0, [pc, #56]	; (42be8 <usbd_evt_alloc+0x40>)
   42bae:	2200      	movs	r2, #0
   42bb0:	a901      	add	r1, sp, #4
   42bb2:	f004 f845 	bl	46c40 <k_mem_slab_alloc>
   42bb6:	b190      	cbz	r0, 42bde <usbd_evt_alloc+0x36>
		usbd_evt_flush();
   42bb8:	f7ff ffe8 	bl	42b8c <usbd_evt_flush>
		if (k_mem_slab_alloc(&fifo_elem_slab, (void **)&block.data, K_NO_WAIT)) {
   42bbc:	480a      	ldr	r0, [pc, #40]	; (42be8 <usbd_evt_alloc+0x40>)
   42bbe:	2200      	movs	r2, #0
   42bc0:	2300      	movs	r3, #0
   42bc2:	a901      	add	r1, sp, #4
   42bc4:	f004 f83c 	bl	46c40 <k_mem_slab_alloc>
   42bc8:	b938      	cbnz	r0, 42bda <usbd_evt_alloc+0x32>
		ev = (struct usbd_event *)block.data;
   42bca:	9801      	ldr	r0, [sp, #4]
		ev->evt_type = USBD_EVT_REINIT;
   42bcc:	2304      	movs	r3, #4
		ev->block = block;
   42bce:	6040      	str	r0, [r0, #4]
		ev->evt_type = USBD_EVT_REINIT;
   42bd0:	7403      	strb	r3, [r0, #16]
		usbd_evt_put(ev);
   42bd2:	f7ff ffa1 	bl	42b18 <usbd_evt_put>
		usbd_work_schedule();
   42bd6:	f7ff ffa5 	bl	42b24 <usbd_work_schedule>
		return NULL;
   42bda:	2000      	movs	r0, #0
   42bdc:	e001      	b.n	42be2 <usbd_evt_alloc+0x3a>
	ev = (struct usbd_event *)block.data;
   42bde:	9801      	ldr	r0, [sp, #4]
	ev->block = block;
   42be0:	6040      	str	r0, [r0, #4]
}
   42be2:	b003      	add	sp, #12
   42be4:	f85d fb04 	ldr.w	pc, [sp], #4
   42be8:	200010a8 	.word	0x200010a8

00042bec <usbd_event_transfer_data>:
{
   42bec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		endpoint_ctx(p_event->data.eptransfer.ep);
   42bee:	7887      	ldrb	r7, [r0, #2]
{
   42bf0:	4606      	mov	r6, r0
		endpoint_ctx(p_event->data.eptransfer.ep);
   42bf2:	4638      	mov	r0, r7
   42bf4:	f7ff ff60 	bl	42ab8 <endpoint_ctx>
	if (NRF_USBD_EPIN_CHECK(p_event->data.eptransfer.ep)) {
   42bf8:	063b      	lsls	r3, r7, #24
		switch (p_event->data.eptransfer.status) {
   42bfa:	78f5      	ldrb	r5, [r6, #3]
		endpoint_ctx(p_event->data.eptransfer.ep);
   42bfc:	4604      	mov	r4, r0
	if (NRF_USBD_EPIN_CHECK(p_event->data.eptransfer.ep)) {
   42bfe:	d512      	bpl.n	42c26 <usbd_event_transfer_data+0x3a>
		switch (p_event->data.eptransfer.status) {
   42c00:	2d00      	cmp	r5, #0
   42c02:	d143      	bne.n	42c8c <usbd_event_transfer_data+0xa0>
			struct usbd_event *ev = usbd_evt_alloc();
   42c04:	f7ff ffd0 	bl	42ba8 <usbd_evt_alloc>
			if (!ev) {
   42c08:	4603      	mov	r3, r0
   42c0a:	2800      	cmp	r0, #0
   42c0c:	d03e      	beq.n	42c8c <usbd_event_transfer_data+0xa0>
			ev->evt_type = USBD_EVT_EP;
   42c0e:	2201      	movs	r2, #1
			ep_ctx->write_in_progress = false;
   42c10:	77a5      	strb	r5, [r4, #30]
			ev->evt_type = USBD_EVT_EP;
   42c12:	7402      	strb	r2, [r0, #16]
			ev->evt.ep_evt.evt_type = EP_EVT_WRITE_COMPLETE;
   42c14:	2203      	movs	r2, #3
   42c16:	7302      	strb	r2, [r0, #12]
			ev->evt.ep_evt.ep = ep_ctx;
   42c18:	609c      	str	r4, [r3, #8]
			usbd_evt_put(ev);
   42c1a:	f7ff ff7d 	bl	42b18 <usbd_evt_put>
}
   42c1e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			usbd_work_schedule();
   42c22:	f7ff bf7f 	b.w	42b24 <usbd_work_schedule>
		switch (p_event->data.eptransfer.status) {
   42c26:	b14d      	cbz	r5, 42c3c <usbd_event_transfer_data+0x50>
   42c28:	2d01      	cmp	r5, #1
   42c2a:	d12f      	bne.n	42c8c <usbd_event_transfer_data+0xa0>
			struct usbd_event *ev = usbd_evt_alloc();
   42c2c:	f7ff ffbc 	bl	42ba8 <usbd_evt_alloc>
			if (!ev) {
   42c30:	4603      	mov	r3, r0
   42c32:	b358      	cbz	r0, 42c8c <usbd_event_transfer_data+0xa0>
			ep_ctx->read_pending = true;
   42c34:	7765      	strb	r5, [r4, #29]
			ev->evt_type = USBD_EVT_EP;
   42c36:	7405      	strb	r5, [r0, #16]
			ev->evt.ep_evt.evt_type = EP_EVT_RECV_REQ;
   42c38:	7305      	strb	r5, [r0, #12]
   42c3a:	e7ed      	b.n	42c18 <usbd_event_transfer_data+0x2c>
			struct usbd_event *ev = usbd_evt_alloc();
   42c3c:	f7ff ffb4 	bl	42ba8 <usbd_evt_alloc>
			if (!ev) {
   42c40:	b320      	cbz	r0, 42c8c <usbd_event_transfer_data+0xa0>
				p_event->data.eptransfer.ep);
   42c42:	78b2      	ldrb	r2, [r6, #2]

NRF_STATIC_INLINE uint32_t nrf_usbd_ep_amount_get(NRF_USBD_Type const * p_reg, uint8_t ep)
{
    uint32_t ret;

    if (NRF_USBD_EPIN_CHECK(ep))
   42c44:	4b12      	ldr	r3, [pc, #72]	; (42c90 <usbd_event_transfer_data+0xa4>)
   42c46:	f012 0f80 	tst.w	r2, #128	; 0x80
   42c4a:	f002 0108 	and.w	r1, r2, #8
   42c4e:	d011      	beq.n	42c74 <usbd_event_transfer_data+0x88>
    {
        if (NRF_USBD_EPISO_CHECK(ep))
   42c50:	b141      	cbz	r1, 42c64 <usbd_event_transfer_data+0x78>
        {
            ret = p_reg->ISOIN.AMOUNT;
   42c52:	f8d3 36a8 	ldr.w	r3, [r3, #1704]	; 0x6a8
			ep_ctx->buf.len = nrf_usbd_ep_amount_get(NRF_USBD,
   42c56:	60e3      	str	r3, [r4, #12]
			ev->evt_type = USBD_EVT_EP;
   42c58:	2301      	movs	r3, #1
   42c5a:	7403      	strb	r3, [r0, #16]
			ev->evt.ep_evt.evt_type = EP_EVT_RECV_COMPLETE;
   42c5c:	2302      	movs	r3, #2
   42c5e:	7303      	strb	r3, [r0, #12]
			ev->evt.ep_evt.ep = ep_ctx;
   42c60:	6084      	str	r4, [r0, #8]
   42c62:	e7da      	b.n	42c1a <usbd_event_transfer_data+0x2e>
        }
        else
        {
            uint8_t epnr = NRF_USBD_EP_NR_GET(ep);
            ret = p_reg->EPIN[epnr].AMOUNT;
   42c64:	f002 020f 	and.w	r2, r2, #15
   42c68:	2114      	movs	r1, #20
   42c6a:	fb01 3302 	mla	r3, r1, r2, r3
   42c6e:	f8d3 3608 	ldr.w	r3, [r3, #1544]	; 0x608
   42c72:	e7f0      	b.n	42c56 <usbd_event_transfer_data+0x6a>
        }
    }
    else
    {
        if (NRF_USBD_EPISO_CHECK(ep))
   42c74:	b111      	cbz	r1, 42c7c <usbd_event_transfer_data+0x90>
        {
            ret = p_reg->ISOOUT.AMOUNT;
   42c76:	f8d3 37a8 	ldr.w	r3, [r3, #1960]	; 0x7a8
   42c7a:	e7ec      	b.n	42c56 <usbd_event_transfer_data+0x6a>
        }
        else
        {
            uint8_t epnr = NRF_USBD_EP_NR_GET(ep);
            ret = p_reg->EPOUT[epnr].AMOUNT;
   42c7c:	f002 020f 	and.w	r2, r2, #15
   42c80:	2114      	movs	r1, #20
   42c82:	fb01 3302 	mla	r3, r1, r2, r3
   42c86:	f8d3 3708 	ldr.w	r3, [r3, #1800]	; 0x708
   42c8a:	e7e4      	b.n	42c56 <usbd_event_transfer_data+0x6a>
}
   42c8c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   42c8e:	bf00      	nop
   42c90:	40027000 	.word	0x40027000

00042c94 <usb_dc_power_event_handler>:
	switch (event) {
   42c94:	2802      	cmp	r0, #2
{
   42c96:	b510      	push	{r4, lr}
   42c98:	d811      	bhi.n	42cbe <usb_dc_power_event_handler+0x2a>
   42c9a:	4b09      	ldr	r3, [pc, #36]	; (42cc0 <usb_dc_power_event_handler+0x2c>)
   42c9c:	5c1c      	ldrb	r4, [r3, r0]
	struct usbd_event *ev = usbd_evt_alloc();
   42c9e:	f7ff ff83 	bl	42ba8 <usbd_evt_alloc>
	if (!ev) {
   42ca2:	b160      	cbz	r0, 42cbe <usb_dc_power_event_handler+0x2a>
	ev->evt_type = USBD_EVT_POWER;
   42ca4:	2200      	movs	r2, #0
   42ca6:	7402      	strb	r2, [r0, #16]
	ev->evt.pwr_evt.state = state;
   42ca8:	7204      	strb	r4, [r0, #8]
	usbd_evt_put(ev);
   42caa:	f7ff ff35 	bl	42b18 <usbd_evt_put>
	if (usbd_ctx.attached) {
   42cae:	4b05      	ldr	r3, [pc, #20]	; (42cc4 <usb_dc_power_event_handler+0x30>)
   42cb0:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
   42cb4:	b11b      	cbz	r3, 42cbe <usb_dc_power_event_handler+0x2a>
}
   42cb6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		usbd_work_schedule();
   42cba:	f7ff bf33 	b.w	42b24 <usbd_work_schedule>
}
   42cbe:	bd10      	pop	{r4, pc}
   42cc0:	000537ed 	.word	0x000537ed
   42cc4:	20005c94 	.word	0x20005c94

00042cc8 <hfxo_stop.constprop.0.isra.0>:
static int hfxo_stop(struct nrf_usbd_ctx *ctx)
   42cc8:	b510      	push	{r4, lr}
	return __atomic_compare_exchange_n(target, &old_value, new_value,
   42cca:	490e      	ldr	r1, [pc, #56]	; (42d04 <hfxo_stop.constprop.0.isra.0+0x3c>)
   42ccc:	f3bf 8f5b 	dmb	ish
   42cd0:	2300      	movs	r3, #0
   42cd2:	e851 2f00 	ldrex	r2, [r1]
   42cd6:	2a01      	cmp	r2, #1
   42cd8:	d103      	bne.n	42ce2 <hfxo_stop.constprop.0.isra.0+0x1a>
   42cda:	e841 3000 	strex	r0, r3, [r1]
   42cde:	2800      	cmp	r0, #0
   42ce0:	d1f7      	bne.n	42cd2 <hfxo_stop.constprop.0.isra.0+0xa>
   42ce2:	f3bf 8f5b 	dmb	ish
	if (atomic_cas(&ctx->clk_requested, 1, 0)) {
   42ce6:	d10c      	bne.n	42d02 <hfxo_stop.constprop.0.isra.0+0x3a>
		return onoff_cancel_or_release(ctx->hfxo_mgr, &ctx->hfxo_cli);
   42ce8:	f851 4c04 	ldr.w	r4, [r1, #-4]
 * @retval negative other errors produced by onoff_release().
 */
static inline int onoff_cancel_or_release(struct onoff_manager *mgr,
					  struct onoff_client *cli)
{
	int rv = onoff_cancel(mgr, cli);
   42cec:	3914      	subs	r1, #20
   42cee:	4620      	mov	r0, r4
   42cf0:	f005 ffdd 	bl	48cae <onoff_cancel>

	if (rv == -EALREADY) {
   42cf4:	3078      	adds	r0, #120	; 0x78
   42cf6:	d104      	bne.n	42d02 <hfxo_stop.constprop.0.isra.0+0x3a>
		rv = onoff_release(mgr);
   42cf8:	4620      	mov	r0, r4
}
   42cfa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   42cfe:	f005 bfb1 	b.w	48c64 <onoff_release>
   42d02:	bd10      	pop	{r4, pc}
   42d04:	20005cb4 	.word	0x20005cb4

00042d08 <usbd_event_handler>:
{
   42d08:	b5f0      	push	{r4, r5, r6, r7, lr}
   42d0a:	4606      	mov	r6, r0
   42d0c:	b089      	sub	sp, #36	; 0x24
	struct usbd_event evt = {0};
   42d0e:	2214      	movs	r2, #20
   42d10:	2100      	movs	r1, #0
   42d12:	a803      	add	r0, sp, #12
   42d14:	f008 f8bc 	bl	4ae90 <memset>
	switch (p_event->type) {
   42d18:	7833      	ldrb	r3, [r6, #0]
   42d1a:	3b01      	subs	r3, #1
   42d1c:	2b05      	cmp	r3, #5
   42d1e:	d821      	bhi.n	42d64 <usbd_event_handler+0x5c>
   42d20:	e8df f003 	tbb	[pc, r3]
   42d24:	1414037a 	.word	0x1414037a
   42d28:	166a      	.short	0x166a
   42d2a:	2303      	movs	r3, #3
		evt.evt.pwr_evt.state = USBD_SUSPENDED;
   42d2c:	f88d 3014 	strb.w	r3, [sp, #20]
		evt.evt_type = USBD_EVT_POWER;
   42d30:	2400      	movs	r4, #0
		ev = usbd_evt_alloc();
   42d32:	f7ff ff39 	bl	42ba8 <usbd_evt_alloc>
		if (!ev) {
   42d36:	4603      	mov	r3, r0
   42d38:	b1a0      	cbz	r0, 42d64 <usbd_event_handler+0x5c>
		ev->evt_type = evt.evt_type;
   42d3a:	7404      	strb	r4, [r0, #16]
		ev->evt = evt.evt;
   42d3c:	f100 0208 	add.w	r2, r0, #8
   42d40:	e9dd 0105 	ldrd	r0, r1, [sp, #20]
   42d44:	e882 0003 	stmia.w	r2, {r0, r1}
		usbd_evt_put(ev);
   42d48:	4618      	mov	r0, r3
   42d4a:	e01d      	b.n	42d88 <usbd_event_handler+0x80>
	switch (p_event->type) {
   42d4c:	2304      	movs	r3, #4
   42d4e:	e7ed      	b.n	42d2c <usbd_event_handler+0x24>
		ep_ctx = endpoint_ctx(p_event->data.eptransfer.ep);
   42d50:	78b7      	ldrb	r7, [r6, #2]
   42d52:	4638      	mov	r0, r7
   42d54:	f7ff feb0 	bl	42ab8 <endpoint_ctx>
		switch (ep_ctx->cfg.type) {
   42d58:	7a83      	ldrb	r3, [r0, #10]
		ep_ctx = endpoint_ctx(p_event->data.eptransfer.ep);
   42d5a:	4604      	mov	r4, r0
		switch (ep_ctx->cfg.type) {
   42d5c:	b123      	cbz	r3, 42d68 <usbd_event_handler+0x60>
   42d5e:	3b01      	subs	r3, #1
   42d60:	2b02      	cmp	r3, #2
   42d62:	d943      	bls.n	42dec <usbd_event_handler+0xe4>
}
   42d64:	b009      	add	sp, #36	; 0x24
   42d66:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (NRF_USBD_EPIN_CHECK(p_event->data.eptransfer.ep)) {
   42d68:	063b      	lsls	r3, r7, #24
		switch (p_event->data.eptransfer.status) {
   42d6a:	78f5      	ldrb	r5, [r6, #3]
	if (NRF_USBD_EPIN_CHECK(p_event->data.eptransfer.ep)) {
   42d6c:	d513      	bpl.n	42d96 <usbd_event_handler+0x8e>
		switch (p_event->data.eptransfer.status) {
   42d6e:	2d00      	cmp	r5, #0
   42d70:	d1f8      	bne.n	42d64 <usbd_event_handler+0x5c>
			struct usbd_event *ev = usbd_evt_alloc();
   42d72:	f7ff ff19 	bl	42ba8 <usbd_evt_alloc>
			if (!ev) {
   42d76:	4603      	mov	r3, r0
   42d78:	2800      	cmp	r0, #0
   42d7a:	d0f3      	beq.n	42d64 <usbd_event_handler+0x5c>
			ev->evt_type = USBD_EVT_EP;
   42d7c:	2201      	movs	r2, #1
			ep_ctx->write_in_progress = false;
   42d7e:	77a5      	strb	r5, [r4, #30]
			ev->evt_type = USBD_EVT_EP;
   42d80:	7402      	strb	r2, [r0, #16]
			ev->evt.ep_evt.evt_type = EP_EVT_WRITE_COMPLETE;
   42d82:	2203      	movs	r2, #3
   42d84:	7302      	strb	r2, [r0, #12]
			ev->evt.ep_evt.ep = ep_ctx;
   42d86:	609c      	str	r4, [r3, #8]
		usbd_evt_put(ev);
   42d88:	f7ff fec6 	bl	42b18 <usbd_evt_put>
}
   42d8c:	b009      	add	sp, #36	; 0x24
   42d8e:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		usbd_work_schedule();
   42d92:	f7ff bec7 	b.w	42b24 <usbd_work_schedule>
		switch (p_event->data.eptransfer.status) {
   42d96:	b155      	cbz	r5, 42dae <usbd_event_handler+0xa6>
   42d98:	2d01      	cmp	r5, #1
   42d9a:	d1e3      	bne.n	42d64 <usbd_event_handler+0x5c>
			struct usbd_event *ev = usbd_evt_alloc();
   42d9c:	f7ff ff04 	bl	42ba8 <usbd_evt_alloc>
			if (!ev) {
   42da0:	4603      	mov	r3, r0
   42da2:	2800      	cmp	r0, #0
   42da4:	d0de      	beq.n	42d64 <usbd_event_handler+0x5c>
			ep_ctx->read_pending = true;
   42da6:	7765      	strb	r5, [r4, #29]
			ev->evt_type = USBD_EVT_EP;
   42da8:	7405      	strb	r5, [r0, #16]
			ev->evt.ep_evt.evt_type = EP_EVT_RECV_REQ;
   42daa:	7305      	strb	r5, [r0, #12]
   42dac:	e7eb      	b.n	42d86 <usbd_event_handler+0x7e>
			struct usbd_event *ev = usbd_evt_alloc();
   42dae:	f7ff fefb 	bl	42ba8 <usbd_evt_alloc>
			if (!ev) {
   42db2:	4607      	mov	r7, r0
   42db4:	2800      	cmp	r0, #0
   42db6:	d0d5      	beq.n	42d64 <usbd_event_handler+0x5c>
			ev->evt_type = USBD_EVT_EP;
   42db8:	2301      	movs	r3, #1
   42dba:	7403      	strb	r3, [r0, #16]
			ev->evt.ep_evt.evt_type = EP_EVT_RECV_COMPLETE;
   42dbc:	2302      	movs	r3, #2
   42dbe:	7303      	strb	r3, [r0, #12]
			ev->evt.ep_evt.ep = ep_ctx;
   42dc0:	6084      	str	r4, [r0, #8]
			err_code = nrfx_usbd_ep_status_get(
   42dc2:	f104 010c 	add.w	r1, r4, #12
   42dc6:	78b0      	ldrb	r0, [r6, #2]
   42dc8:	f00c fb9e 	bl	4f508 <nrfx_usbd_ep_status_get>
			if (ctx->ctrl_read_len > ep_ctx->buf.len) {
   42dcc:	4a13      	ldr	r2, [pc, #76]	; (42e1c <usbd_event_handler+0x114>)
   42dce:	68e1      	ldr	r1, [r4, #12]
   42dd0:	f8b2 328c 	ldrh.w	r3, [r2, #652]	; 0x28c
   42dd4:	428b      	cmp	r3, r1
   42dd6:	d906      	bls.n	42de6 <usbd_event_handler+0xde>
				ctx->ctrl_read_len -= ep_ctx->buf.len;
   42dd8:	1a5b      	subs	r3, r3, r1
   42dda:	f8a2 328c 	strh.w	r3, [r2, #652]	; 0x28c
				nrfx_usbd_setup_data_clear();
   42dde:	f003 fa71 	bl	462c4 <nrfx_usbd_setup_data_clear>
			usbd_evt_put(ev);
   42de2:	4638      	mov	r0, r7
   42de4:	e7d0      	b.n	42d88 <usbd_event_handler+0x80>
				ctx->ctrl_read_len = 0U;
   42de6:	f8a2 528c 	strh.w	r5, [r2, #652]	; 0x28c
   42dea:	e7fa      	b.n	42de2 <usbd_event_handler+0xda>
			usbd_event_transfer_data(p_event);
   42dec:	4630      	mov	r0, r6
}
   42dee:	b009      	add	sp, #36	; 0x24
   42df0:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
			usbd_event_transfer_data(p_event);
   42df4:	f7ff befa 	b.w	42bec <usbd_event_transfer_data>
		nrfx_usbd_setup_get(&drv_setup);
   42df8:	a801      	add	r0, sp, #4
   42dfa:	f003 fa3d 	bl	46278 <nrfx_usbd_setup_get>
		if ((drv_setup.bRequest != USB_SREQ_SET_ADDRESS)
   42dfe:	f89d 3005 	ldrb.w	r3, [sp, #5]
   42e02:	2b05      	cmp	r3, #5
   42e04:	d104      	bne.n	42e10 <usbd_event_handler+0x108>
		    || (USB_REQTYPE_GET_TYPE(drv_setup.bmRequestType)
   42e06:	f89d 3004 	ldrb.w	r3, [sp, #4]
   42e0a:	f013 0f60 	tst.w	r3, #96	; 0x60
   42e0e:	d0a9      	beq.n	42d64 <usbd_event_handler+0x5c>
			evt.evt.ep_evt.ep = ep_ctx;
   42e10:	4b03      	ldr	r3, [pc, #12]	; (42e20 <usbd_event_handler+0x118>)
   42e12:	9305      	str	r3, [sp, #20]
			evt.evt_type = USBD_EVT_EP;
   42e14:	2401      	movs	r4, #1
   42e16:	e78c      	b.n	42d32 <usbd_event_handler+0x2a>
	switch (p_event->type) {
   42e18:	2402      	movs	r4, #2
   42e1a:	e78a      	b.n	42d32 <usbd_event_handler+0x2a>
   42e1c:	20005c94 	.word	0x20005c94
   42e20:	20005e00 	.word	0x20005e00

00042e24 <eps_ctx_init>:
{
   42e24:	b538      	push	{r3, r4, r5, lr}
	for (i = 0U; i < CFG_EPIN_CNT; i++) {
   42e26:	2400      	movs	r4, #0
	return endpoint_ctx(NRF_USBD_EPIN(ep));
   42e28:	f064 007f 	orn	r0, r4, #127	; 0x7f
   42e2c:	b2c0      	uxtb	r0, r0
   42e2e:	f7ff fe43 	bl	42ab8 <endpoint_ctx>
	for (i = 0U; i < CFG_EPIN_CNT; i++) {
   42e32:	3401      	adds	r4, #1
		ep_ctx_reset(ep_ctx);
   42e34:	f00c f831 	bl	4ee9a <ep_ctx_reset>
	for (i = 0U; i < CFG_EPIN_CNT; i++) {
   42e38:	2c08      	cmp	r4, #8
   42e3a:	d1f5      	bne.n	42e28 <eps_ctx_init+0x4>
   42e3c:	4d0e      	ldr	r5, [pc, #56]	; (42e78 <eps_ctx_init+0x54>)
	for (i = 0U; i < CFG_EPOUT_CNT; i++) {
   42e3e:	2400      	movs	r4, #0
	return endpoint_ctx(NRF_USBD_EPOUT(ep));
   42e40:	b2e0      	uxtb	r0, r4
   42e42:	f7ff fe39 	bl	42ab8 <endpoint_ctx>
		if (!ep_ctx->buf.block.data) {
   42e46:	6903      	ldr	r3, [r0, #16]
   42e48:	b903      	cbnz	r3, 42e4c <eps_ctx_init+0x28>
			ep_ctx->buf.block.data = ep_out_bufs[i];
   42e4a:	6105      	str	r5, [r0, #16]
	for (i = 0U; i < CFG_EPOUT_CNT; i++) {
   42e4c:	3401      	adds	r4, #1
		ep_ctx_reset(ep_ctx);
   42e4e:	f00c f824 	bl	4ee9a <ep_ctx_reset>
	for (i = 0U; i < CFG_EPOUT_CNT; i++) {
   42e52:	2c08      	cmp	r4, #8
   42e54:	f105 0540 	add.w	r5, r5, #64	; 0x40
   42e58:	d1f2      	bne.n	42e40 <eps_ctx_init+0x1c>
		ep_ctx_reset(ep_ctx);
   42e5a:	4808      	ldr	r0, [pc, #32]	; (42e7c <eps_ctx_init+0x58>)
   42e5c:	f00c f81d 	bl	4ee9a <ep_ctx_reset>
		if (!ep_ctx->buf.block.data) {
   42e60:	4b07      	ldr	r3, [pc, #28]	; (42e80 <eps_ctx_init+0x5c>)
   42e62:	f8d3 227c 	ldr.w	r2, [r3, #636]	; 0x27c
   42e66:	b912      	cbnz	r2, 42e6e <eps_ctx_init+0x4a>
			ep_ctx->buf.block.data = ep_isoout_bufs[0];
   42e68:	4a06      	ldr	r2, [pc, #24]	; (42e84 <eps_ctx_init+0x60>)
   42e6a:	f8c3 227c 	str.w	r2, [r3, #636]	; 0x27c
		ep_ctx_reset(ep_ctx);
   42e6e:	4806      	ldr	r0, [pc, #24]	; (42e88 <eps_ctx_init+0x64>)
   42e70:	f00c f813 	bl	4ee9a <ep_ctx_reset>
}
   42e74:	2000      	movs	r0, #0
   42e76:	bd38      	pop	{r3, r4, r5, pc}
   42e78:	20006324 	.word	0x20006324
   42e7c:	20005de0 	.word	0x20005de0
   42e80:	20005c94 	.word	0x20005c94
   42e84:	20005f24 	.word	0x20005f24
   42e88:	20005f00 	.word	0x20005f00

00042e8c <usbd_work_handler>:
{
   42e8c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	return get_usbd_ctx()->ready;
   42e90:	4ca7      	ldr	r4, [pc, #668]	; (43130 <usbd_work_handler+0x2a4>)
	k_mem_slab_free(&fifo_elem_slab, (void **)&ev->block.data);
   42e92:	f8df 82a0 	ldr.w	r8, [pc, #672]	; 43134 <usbd_work_handler+0x2a8>
{
   42e96:	b085      	sub	sp, #20
   42e98:	4607      	mov	r7, r0
	while ((ev = usbd_evt_get()) != NULL) {
   42e9a:	f7ff fe6f 	bl	42b7c <usbd_evt_get>
   42e9e:	b910      	cbnz	r0, 42ea6 <usbd_work_handler+0x1a>
}
   42ea0:	b005      	add	sp, #20
   42ea2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	return get_usbd_ctx()->ready;
   42ea6:	f894 3025 	ldrb.w	r3, [r4, #37]	; 0x25
		if (!dev_ready() && ev->evt_type != USBD_EVT_POWER) {
   42eaa:	7c02      	ldrb	r2, [r0, #16]
	k_mem_slab_free(&fifo_elem_slab, (void **)&ev->block.data);
   42eac:	f100 0904 	add.w	r9, r0, #4
		if (!dev_ready() && ev->evt_type != USBD_EVT_POWER) {
   42eb0:	b93b      	cbnz	r3, 42ec2 <usbd_work_handler+0x36>
   42eb2:	2a00      	cmp	r2, #0
   42eb4:	f000 8088 	beq.w	42fc8 <usbd_work_handler+0x13c>
	k_mem_slab_free(&fifo_elem_slab, (void **)&ev->block.data);
   42eb8:	489e      	ldr	r0, [pc, #632]	; (43134 <usbd_work_handler+0x2a8>)
   42eba:	4649      	mov	r1, r9
   42ebc:	f00c fea0 	bl	4fc00 <k_mem_slab_free>
}
   42ec0:	e7eb      	b.n	42e9a <usbd_work_handler+0xe>
		switch (ev->evt_type) {
   42ec2:	2a04      	cmp	r2, #4
   42ec4:	d844      	bhi.n	42f50 <usbd_work_handler+0xc4>
   42ec6:	e8df f012 	tbh	[pc, r2, lsl #1]
   42eca:	007f      	.short	0x007f
   42ecc:	01020005 	.word	0x01020005
   42ed0:	01410118 	.word	0x01410118
	switch (ep_evt->evt_type) {
   42ed4:	7b03      	ldrb	r3, [r0, #12]
	struct nrf_usbd_ep_ctx *ep_ctx = ep_evt->ep;
   42ed6:	6885      	ldr	r5, [r0, #8]
	switch (ep_evt->evt_type) {
   42ed8:	2b03      	cmp	r3, #3
   42eda:	d839      	bhi.n	42f50 <usbd_work_handler+0xc4>
   42edc:	e8df f003 	tbb	[pc, r3]
   42ee0:	615c3f02 	.word	0x615c3f02
	usbd_setup = (struct usb_setup_packet *)ep_ctx->buf.data;
   42ee4:	696e      	ldr	r6, [r5, #20]
	memset(usbd_setup, 0, sizeof(struct usb_setup_packet));
   42ee6:	2208      	movs	r2, #8
   42ee8:	2100      	movs	r1, #0
   42eea:	4630      	mov	r0, r6
   42eec:	f007 ffd0 	bl	4ae90 <memset>
    return (uint8_t)(p_reg->BMREQUESTTYPE);
   42ef0:	4b91      	ldr	r3, [pc, #580]	; (43138 <usbd_work_handler+0x2ac>)
	memcpy(&usbd_ctx.setup, usbd_setup, sizeof(struct usb_setup_packet));
   42ef2:	4892      	ldr	r0, [pc, #584]	; (4313c <usbd_work_handler+0x2b0>)
   42ef4:	f8d3 2480 	ldr.w	r2, [r3, #1152]	; 0x480
   42ef8:	7032      	strb	r2, [r6, #0]
    return (uint8_t)(p_reg->BREQUEST);
   42efa:	f8d3 2484 	ldr.w	r2, [r3, #1156]	; 0x484
   42efe:	7072      	strb	r2, [r6, #1]
    const uint16_t val = p_reg->WVALUEL;
   42f00:	f8d3 2488 	ldr.w	r2, [r3, #1160]	; 0x488
    return (uint16_t)(val | ((p_reg->WVALUEH) << 8));
   42f04:	f8d3 148c 	ldr.w	r1, [r3, #1164]	; 0x48c
   42f08:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
	usbd_setup->wValue = nrf_usbd_setup_wvalue_get(NRF_USBD);
   42f0c:	8072      	strh	r2, [r6, #2]
    const uint16_t val = p_reg->WINDEXL;
   42f0e:	f8d3 2490 	ldr.w	r2, [r3, #1168]	; 0x490
    return (uint16_t)(val | ((p_reg->WINDEXH) << 8));
   42f12:	f8d3 1494 	ldr.w	r1, [r3, #1172]	; 0x494
   42f16:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
	usbd_setup->wIndex = nrf_usbd_setup_windex_get(NRF_USBD);
   42f1a:	80b2      	strh	r2, [r6, #4]
    const uint16_t val = p_reg->WLENGTHL;
   42f1c:	f8d3 2498 	ldr.w	r2, [r3, #1176]	; 0x498
    return (uint16_t)(val | ((p_reg->WLENGTHH) << 8));
   42f20:	f8d3 349c 	ldr.w	r3, [r3, #1180]	; 0x49c
   42f24:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
	ep_ctx->buf.len = sizeof(struct usb_setup_packet);
   42f28:	2208      	movs	r2, #8
	usbd_setup->wLength = nrf_usbd_setup_wlength_get(NRF_USBD);
   42f2a:	80f3      	strh	r3, [r6, #6]
	memcpy(&usbd_ctx.setup, usbd_setup, sizeof(struct usb_setup_packet));
   42f2c:	4631      	mov	r1, r6
	ep_ctx->buf.len = sizeof(struct usb_setup_packet);
   42f2e:	60ea      	str	r2, [r5, #12]
	memcpy(&usbd_ctx.setup, usbd_setup, sizeof(struct usb_setup_packet));
   42f30:	f007 ffa3 	bl	4ae7a <memcpy>
	ep_ctx->cfg.cb(ep_ctx->cfg.addr, USB_DC_EP_SETUP);
   42f34:	682b      	ldr	r3, [r5, #0]
   42f36:	7a68      	ldrb	r0, [r5, #9]
   42f38:	2100      	movs	r1, #0
   42f3a:	4798      	blx	r3
	if (usb_reqtype_is_to_device(usbd_setup) && usbd_setup->wLength) {
   42f3c:	f996 3000 	ldrsb.w	r3, [r6]
   42f40:	2b00      	cmp	r3, #0
   42f42:	db08      	blt.n	42f56 <usbd_work_handler+0xca>
   42f44:	88f3      	ldrh	r3, [r6, #6]
   42f46:	b133      	cbz	r3, 42f56 <usbd_work_handler+0xca>
		ctx->ctrl_read_len = usbd_setup->wLength;
   42f48:	f8a4 328c 	strh.w	r3, [r4, #652]	; 0x28c
		nrfx_usbd_setup_data_clear();
   42f4c:	f003 f9ba 	bl	462c4 <nrfx_usbd_setup_data_clear>
	k_mem_slab_free(&fifo_elem_slab, (void **)&ev->block.data);
   42f50:	4649      	mov	r1, r9
   42f52:	4640      	mov	r0, r8
   42f54:	e7b2      	b.n	42ebc <usbd_work_handler+0x30>
		ctx->ctrl_read_len = 0U;
   42f56:	2300      	movs	r3, #0
   42f58:	f8a4 328c 	strh.w	r3, [r4, #652]	; 0x28c
   42f5c:	e7f8      	b.n	42f50 <usbd_work_handler+0xc4>
	if (!ep_ctx->read_pending) {
   42f5e:	7f6b      	ldrb	r3, [r5, #29]
   42f60:	2b00      	cmp	r3, #0
   42f62:	d0f5      	beq.n	42f50 <usbd_work_handler+0xc4>
	if (!ep_ctx->read_complete) {
   42f64:	7f2b      	ldrb	r3, [r5, #28]
   42f66:	2b00      	cmp	r3, #0
   42f68:	d0f2      	beq.n	42f50 <usbd_work_handler+0xc4>
	ep_ctx->read_pending = false;
   42f6a:	2600      	movs	r6, #0
   42f6c:	776e      	strb	r6, [r5, #29]
	k_mutex_lock(&ctx->drv_lock, K_FOREVER);
   42f6e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   42f72:	4873      	ldr	r0, [pc, #460]	; (43140 <usbd_work_handler+0x2b4>)
	ep_ctx->read_complete = false;
   42f74:	772e      	strb	r6, [r5, #28]
	k_mutex_lock(&ctx->drv_lock, K_FOREVER);
   42f76:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   42f7a:	f00b ffa1 	bl	4eec0 <k_mutex_lock.constprop.0.isra.0>
	NRFX_USBD_TRANSFER_OUT(transfer, ep_ctx->buf.data,
   42f7e:	696b      	ldr	r3, [r5, #20]
   42f80:	9301      	str	r3, [sp, #4]
   42f82:	686b      	ldr	r3, [r5, #4]
   42f84:	e9cd 3602 	strd	r3, r6, [sp, #8]
	nrfx_err_t err = nrfx_usbd_ep_transfer(
   42f88:	a901      	add	r1, sp, #4
   42f8a:	7a68      	ldrb	r0, [r5, #9]
   42f8c:	f002 ffa0 	bl	45ed0 <nrfx_usbd_ep_transfer>
	k_mutex_unlock(&ctx->drv_lock);
   42f90:	486b      	ldr	r0, [pc, #428]	; (43140 <usbd_work_handler+0x2b4>)
   42f92:	f00b ff97 	bl	4eec4 <k_mutex_unlock.isra.0>
   42f96:	e7db      	b.n	42f50 <usbd_work_handler+0xc4>
		ep_ctx->cfg.cb(ep_ctx->cfg.addr,
   42f98:	682b      	ldr	r3, [r5, #0]
   42f9a:	2101      	movs	r1, #1
		ep_ctx->cfg.cb(ep_ctx->cfg.addr,
   42f9c:	7a68      	ldrb	r0, [r5, #9]
   42f9e:	4798      	blx	r3
		break;
   42fa0:	e7d6      	b.n	42f50 <usbd_work_handler+0xc4>
		if (ep_ctx->cfg.type == USB_DC_EP_CONTROL &&
   42fa2:	7aab      	ldrb	r3, [r5, #10]
   42fa4:	b96b      	cbnz	r3, 42fc2 <usbd_work_handler+0x136>
   42fa6:	7feb      	ldrb	r3, [r5, #31]
   42fa8:	b95b      	cbnz	r3, 42fc2 <usbd_work_handler+0x136>
			k_mutex_lock(&ctx->drv_lock, K_FOREVER);
   42faa:	4865      	ldr	r0, [pc, #404]	; (43140 <usbd_work_handler+0x2b4>)
   42fac:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   42fb0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   42fb4:	f00b ff84 	bl	4eec0 <k_mutex_lock.constprop.0.isra.0>
			nrfx_usbd_setup_clear();
   42fb8:	f003 f9b4 	bl	46324 <nrfx_usbd_setup_clear>
			k_mutex_unlock(&ctx->drv_lock);
   42fbc:	4860      	ldr	r0, [pc, #384]	; (43140 <usbd_work_handler+0x2b4>)
   42fbe:	f00b ff81 	bl	4eec4 <k_mutex_unlock.isra.0>
		ep_ctx->cfg.cb(ep_ctx->cfg.addr,
   42fc2:	682b      	ldr	r3, [r5, #0]
   42fc4:	2102      	movs	r1, #2
   42fc6:	e7e9      	b.n	42f9c <usbd_work_handler+0x110>
	switch (pwr_evt->state) {
   42fc8:	7a02      	ldrb	r2, [r0, #8]
   42fca:	2a04      	cmp	r2, #4
   42fcc:	d8c0      	bhi.n	42f50 <usbd_work_handler+0xc4>
   42fce:	e8df f002 	tbb	[pc, r2]
   42fd2:	0359      	.short	0x0359
   42fd4:	6723      	.short	0x6723
   42fd6:	73          	.byte	0x73
   42fd7:	00          	.byte	0x00
		if (!nrfx_usbd_is_enabled()) {
   42fd8:	f002 fef4 	bl	45dc4 <nrfx_usbd_is_enabled>
   42fdc:	4605      	mov	r5, r0
   42fde:	2800      	cmp	r0, #0
   42fe0:	d1b6      	bne.n	42f50 <usbd_work_handler+0xc4>
			nrfx_usbd_enable();
   42fe2:	f002 fe2b 	bl	45c3c <nrfx_usbd_enable>
   42fe6:	f3bf 8f5b 	dmb	ish
   42fea:	4956      	ldr	r1, [pc, #344]	; (43144 <usbd_work_handler+0x2b8>)
   42fec:	2301      	movs	r3, #1
   42fee:	e851 2f00 	ldrex	r2, [r1]
   42ff2:	2a00      	cmp	r2, #0
   42ff4:	d103      	bne.n	42ffe <usbd_work_handler+0x172>
   42ff6:	e841 3000 	strex	r0, r3, [r1]
   42ffa:	2800      	cmp	r0, #0
   42ffc:	d1f7      	bne.n	42fee <usbd_work_handler+0x162>
   42ffe:	f3bf 8f5b 	dmb	ish
	if (atomic_cas(&ctx->clk_requested, 0, 1)) {
   43002:	d1a5      	bne.n	42f50 <usbd_work_handler+0xc4>
   43004:	f841 5c08 	str.w	r5, [r1, #-8]
   43008:	f841 5c10 	str.w	r5, [r1, #-16]
		return onoff_request(ctx->hfxo_mgr, &ctx->hfxo_cli);
   4300c:	69e0      	ldr	r0, [r4, #28]
   4300e:	6163      	str	r3, [r4, #20]
   43010:	3914      	subs	r1, #20
   43012:	f005 fdcf 	bl	48bb4 <onoff_request>
   43016:	e79b      	b.n	42f50 <usbd_work_handler+0xc4>
	switch (pwr_evt->state) {
   43018:	2500      	movs	r5, #0
	return endpoint_ctx(NRF_USBD_EPIN(ep));
   4301a:	f065 007f 	orn	r0, r5, #127	; 0x7f
   4301e:	b2c0      	uxtb	r0, r0
   43020:	f7ff fd4a 	bl	42ab8 <endpoint_ctx>
		if (ep_ctx->cfg.en) {
   43024:	7a03      	ldrb	r3, [r0, #8]
   43026:	b113      	cbz	r3, 4302e <usbd_work_handler+0x1a2>
			nrfx_usbd_ep_enable(ep_addr_to_nrfx(ep_ctx->cfg.addr));
   43028:	7a40      	ldrb	r0, [r0, #9]
   4302a:	f003 fb5f 	bl	466ec <nrfx_usbd_ep_enable>
	for (i = 0; i < CFG_EPIN_CNT; i++) {
   4302e:	3501      	adds	r5, #1
   43030:	2d08      	cmp	r5, #8
   43032:	d1f2      	bne.n	4301a <usbd_work_handler+0x18e>
		if (ep_ctx->cfg.en) {
   43034:	f894 3154 	ldrb.w	r3, [r4, #340]	; 0x154
   43038:	b11b      	cbz	r3, 43042 <usbd_work_handler+0x1b6>
			nrfx_usbd_ep_enable(ep_addr_to_nrfx(ep_ctx->cfg.addr));
   4303a:	f894 0155 	ldrb.w	r0, [r4, #341]	; 0x155
   4303e:	f003 fb55 	bl	466ec <nrfx_usbd_ep_enable>
	switch (pwr_evt->state) {
   43042:	2500      	movs	r5, #0
	return endpoint_ctx(NRF_USBD_EPOUT(ep));
   43044:	b2e8      	uxtb	r0, r5
   43046:	f7ff fd37 	bl	42ab8 <endpoint_ctx>
		if (ep_ctx->cfg.en) {
   4304a:	7a03      	ldrb	r3, [r0, #8]
   4304c:	b113      	cbz	r3, 43054 <usbd_work_handler+0x1c8>
			nrfx_usbd_ep_enable(ep_addr_to_nrfx(ep_ctx->cfg.addr));
   4304e:	7a40      	ldrb	r0, [r0, #9]
   43050:	f003 fb4c 	bl	466ec <nrfx_usbd_ep_enable>
	for (i = 0; i < CFG_EPOUT_CNT; i++) {
   43054:	3501      	adds	r5, #1
   43056:	2d08      	cmp	r5, #8
   43058:	d1f4      	bne.n	43044 <usbd_work_handler+0x1b8>
		if (ep_ctx->cfg.en) {
   4305a:	f894 3274 	ldrb.w	r3, [r4, #628]	; 0x274
   4305e:	b11b      	cbz	r3, 43068 <usbd_work_handler+0x1dc>
			nrfx_usbd_ep_enable(ep_addr_to_nrfx(ep_ctx->cfg.addr));
   43060:	f894 0275 	ldrb.w	r0, [r4, #629]	; 0x275
   43064:	f003 fb42 	bl	466ec <nrfx_usbd_ep_enable>
		nrfx_usbd_start(true);
   43068:	2001      	movs	r0, #1
   4306a:	f002 fe8d 	bl	45d88 <nrfx_usbd_start>
		ctx->ready = true;
   4306e:	2301      	movs	r3, #1
   43070:	f884 3025 	strb.w	r3, [r4, #37]	; 0x25
		if (ctx->status_cb) {
   43074:	6823      	ldr	r3, [r4, #0]
   43076:	2b00      	cmp	r3, #0
   43078:	f43f af6a 	beq.w	42f50 <usbd_work_handler+0xc4>
			ctx->status_cb(USB_DC_CONNECTED, NULL);
   4307c:	2100      	movs	r1, #0
   4307e:	2002      	movs	r0, #2
				ctx->status_cb(USB_DC_SOF, NULL);
   43080:	4798      	blx	r3
   43082:	e765      	b.n	42f50 <usbd_work_handler+0xc4>
		ctx->ready = false;
   43084:	2500      	movs	r5, #0
   43086:	f884 5025 	strb.w	r5, [r4, #37]	; 0x25
		nrfx_usbd_disable();
   4308a:	f003 fabd 	bl	46608 <nrfx_usbd_disable>
		err = hfxo_stop(ctx);
   4308e:	f7ff fe1b 	bl	42cc8 <hfxo_stop.constprop.0.isra.0>
		if (ctx->status_cb) {
   43092:	6823      	ldr	r3, [r4, #0]
   43094:	2b00      	cmp	r3, #0
   43096:	f43f af5b 	beq.w	42f50 <usbd_work_handler+0xc4>
			ctx->status_cb(USB_DC_DISCONNECTED, NULL);
   4309a:	4629      	mov	r1, r5
   4309c:	2004      	movs	r0, #4
   4309e:	e7ef      	b.n	43080 <usbd_work_handler+0x1f4>
		if (dev_ready()) {
   430a0:	2b00      	cmp	r3, #0
   430a2:	f43f af55 	beq.w	42f50 <usbd_work_handler+0xc4>
			nrfx_usbd_suspend();
   430a6:	f003 fac7 	bl	46638 <nrfx_usbd_suspend>
			if (ctx->status_cb) {
   430aa:	6823      	ldr	r3, [r4, #0]
   430ac:	2b00      	cmp	r3, #0
   430ae:	f43f af4f 	beq.w	42f50 <usbd_work_handler+0xc4>
				ctx->status_cb(USB_DC_SUSPEND, NULL);
   430b2:	2100      	movs	r1, #0
   430b4:	2005      	movs	r0, #5
   430b6:	e7e3      	b.n	43080 <usbd_work_handler+0x1f4>
		if (ctx->status_cb && dev_ready()) {
   430b8:	6822      	ldr	r2, [r4, #0]
   430ba:	2a00      	cmp	r2, #0
   430bc:	f43f af48 	beq.w	42f50 <usbd_work_handler+0xc4>
   430c0:	2b00      	cmp	r3, #0
   430c2:	f43f af45 	beq.w	42f50 <usbd_work_handler+0xc4>
			ctx->status_cb(USB_DC_RESUME, NULL);
   430c6:	2100      	movs	r1, #0
   430c8:	2006      	movs	r0, #6
   430ca:	4790      	blx	r2
   430cc:	e740      	b.n	42f50 <usbd_work_handler+0xc4>
			k_mutex_lock(&ctx->drv_lock, K_FOREVER);
   430ce:	f107 0510 	add.w	r5, r7, #16
   430d2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   430d6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   430da:	4628      	mov	r0, r5
   430dc:	f00b fef0 	bl	4eec0 <k_mutex_lock.constprop.0.isra.0>
			eps_ctx_init();
   430e0:	f7ff fea0 	bl	42e24 <eps_ctx_init>
			k_mutex_unlock(&ctx->drv_lock);
   430e4:	4628      	mov	r0, r5
   430e6:	f00b feed 	bl	4eec4 <k_mutex_unlock.isra.0>
			if (ctx->status_cb) {
   430ea:	f857 3c28 	ldr.w	r3, [r7, #-40]
   430ee:	2b00      	cmp	r3, #0
   430f0:	f43f af2e 	beq.w	42f50 <usbd_work_handler+0xc4>
				ctx->status_cb(USB_DC_RESET, NULL);
   430f4:	2100      	movs	r1, #0
   430f6:	2001      	movs	r0, #1
   430f8:	e7c2      	b.n	43080 <usbd_work_handler+0x1f4>
	if (ep_ctx->cfg.en) {
   430fa:	f894 3274 	ldrb.w	r3, [r4, #628]	; 0x274
   430fe:	b17b      	cbz	r3, 43120 <usbd_work_handler+0x294>
		ep_ctx->read_pending = true;
   43100:	2501      	movs	r5, #1
   43102:	f884 5289 	strb.w	r5, [r4, #649]	; 0x289
		ep_ctx->read_complete = true;
   43106:	f884 5288 	strb.w	r5, [r4, #648]	; 0x288
		ev = usbd_evt_alloc();
   4310a:	f7ff fd4d 	bl	42ba8 <usbd_evt_alloc>
		if (!ev) {
   4310e:	b138      	cbz	r0, 43120 <usbd_work_handler+0x294>
		ev->evt.ep_evt.ep = ep_ctx;
   43110:	4a0d      	ldr	r2, [pc, #52]	; (43148 <usbd_work_handler+0x2bc>)
		ev->evt_type = USBD_EVT_EP;
   43112:	7405      	strb	r5, [r0, #16]
		ev->evt.ep_evt.evt_type = EP_EVT_RECV_REQ;
   43114:	7305      	strb	r5, [r0, #12]
		ev->evt.ep_evt.ep = ep_ctx;
   43116:	6082      	str	r2, [r0, #8]
		usbd_evt_put(ev);
   43118:	f7ff fcfe 	bl	42b18 <usbd_evt_put>
		usbd_work_schedule();
   4311c:	f7ff fd02 	bl	42b24 <usbd_work_schedule>
			if (ctx->status_cb) {
   43120:	f857 3c28 	ldr.w	r3, [r7, #-40]
   43124:	2b00      	cmp	r3, #0
   43126:	f43f af13 	beq.w	42f50 <usbd_work_handler+0xc4>
				ctx->status_cb(USB_DC_SOF, NULL);
   4312a:	2100      	movs	r1, #0
   4312c:	200a      	movs	r0, #10
   4312e:	e7a7      	b.n	43080 <usbd_work_handler+0x1f4>
   43130:	20005c94 	.word	0x20005c94
   43134:	200010a8 	.word	0x200010a8
   43138:	40027000 	.word	0x40027000
   4313c:	20005c98 	.word	0x20005c98
   43140:	20005ccc 	.word	0x20005ccc
   43144:	20005cb4 	.word	0x20005cb4
   43148:	20005f00 	.word	0x20005f00
	nrfx_power_usbevt_disable();
   4314c:	f00c f953 	bl	4f3f6 <nrfx_power_usbevt_disable>
	nrfx_usbd_disable();
   43150:	f003 fa5a 	bl	46608 <nrfx_usbd_disable>
	nrfx_usbd_uninit();
   43154:	f002 fd68 	bl	45c28 <nrfx_usbd_uninit>
	usbd_evt_flush();
   43158:	f7ff fd18 	bl	42b8c <usbd_evt_flush>
	ret = eps_ctx_init();
   4315c:	f7ff fe62 	bl	42e24 <eps_ctx_init>
	nrfx_power_usbevt_enable();
   43160:	f00c f942 	bl	4f3e8 <nrfx_power_usbevt_enable>
	err = nrfx_usbd_init(usbd_event_handler);
   43164:	4801      	ldr	r0, [pc, #4]	; (4316c <usbd_work_handler+0x2e0>)
   43166:	f002 fe71 	bl	45e4c <nrfx_usbd_init>
}
   4316a:	e6f1      	b.n	42f50 <usbd_work_handler+0xc4>
   4316c:	00042d09 	.word	0x00042d09

00043170 <usb_dc_attach>:
{
   43170:	b538      	push	{r3, r4, r5, lr}
	if (ctx->attached) {
   43172:	4d1a      	ldr	r5, [pc, #104]	; (431dc <usb_dc_attach+0x6c>)
   43174:	f895 4024 	ldrb.w	r4, [r5, #36]	; 0x24
   43178:	bb5c      	cbnz	r4, 431d2 <usb_dc_attach+0x62>
	return z_impl_k_mutex_init(mutex);
   4317a:	f105 0038 	add.w	r0, r5, #56	; 0x38
   4317e:	f00c fd82 	bl	4fc86 <z_impl_k_mutex_init>
		z_nrf_clock_control_get_onoff(
   43182:	4620      	mov	r0, r4
   43184:	f000 fd1c 	bl	43bc0 <z_nrf_clock_control_get_onoff>
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
   43188:	4622      	mov	r2, r4
	ctx->hfxo_mgr =
   4318a:	61e8      	str	r0, [r5, #28]
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
   4318c:	2101      	movs	r1, #1
   4318e:	2027      	movs	r0, #39	; 0x27
   43190:	f7e9 fe40 	bl	2ce14 <z_arm_irq_priority_set>
	err = nrfx_usbd_init(usbd_event_handler);
   43194:	4812      	ldr	r0, [pc, #72]	; (431e0 <usb_dc_attach+0x70>)
   43196:	f002 fe59 	bl	45e4c <nrfx_usbd_init>
	if (err != NRFX_SUCCESS) {
   4319a:	4b12      	ldr	r3, [pc, #72]	; (431e4 <usb_dc_attach+0x74>)
   4319c:	4298      	cmp	r0, r3
   4319e:	d11a      	bne.n	431d6 <usb_dc_attach+0x66>
	nrfx_power_usbevt_enable();
   431a0:	f00c f922 	bl	4f3e8 <nrfx_power_usbevt_enable>
	ret = eps_ctx_init();
   431a4:	f7ff fe3e 	bl	42e24 <eps_ctx_init>
	if (ret == 0) {
   431a8:	4604      	mov	r4, r0
   431aa:	b910      	cbnz	r0, 431b2 <usb_dc_attach+0x42>
		ctx->attached = true;
   431ac:	2301      	movs	r3, #1
   431ae:	f885 3024 	strb.w	r3, [r5, #36]	; 0x24
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_sfnode_t *sys_sflist_peek_head(sys_sflist_t *list)
{
	return list->head;
   431b2:	4b0d      	ldr	r3, [pc, #52]	; (431e8 <usb_dc_attach+0x78>)
	if (!k_fifo_is_empty(&usbd_evt_fifo)) {
   431b4:	681b      	ldr	r3, [r3, #0]
   431b6:	b10b      	cbz	r3, 431bc <usb_dc_attach+0x4c>
		usbd_work_schedule();
   431b8:	f7ff fcb4 	bl	42b24 <usbd_work_schedule>
#endif // NRF_POWER_HAS_MAINREGSTATUS

#if NRF_POWER_HAS_USBREG
NRF_STATIC_INLINE uint32_t nrf_power_usbregstatus_get(NRF_POWER_Type const * p_reg)
{
    return p_reg->USBREGSTATUS;
   431bc:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   431c0:	f8d3 3438 	ldr.w	r3, [r3, #1080]	; 0x438
#ifndef NRFX_DECLARE_ONLY
#if NRF_POWER_HAS_USBREG
NRFX_STATIC_INLINE nrfx_power_usb_state_t nrfx_power_usbstatus_get(void)
{
    uint32_t status = nrf_power_usbregstatus_get(NRF_POWER);
    if(0 == (status & NRF_POWER_USBREGSTATUS_VBUSDETECT_MASK))
   431c4:	07db      	lsls	r3, r3, #31
   431c6:	d502      	bpl.n	431ce <usb_dc_attach+0x5e>
		usb_dc_power_event_handler(NRFX_POWER_USB_EVT_DETECTED);
   431c8:	2000      	movs	r0, #0
   431ca:	f7ff fd63 	bl	42c94 <usb_dc_power_event_handler>
}
   431ce:	4620      	mov	r0, r4
   431d0:	bd38      	pop	{r3, r4, r5, pc}
		return 0;
   431d2:	2400      	movs	r4, #0
   431d4:	e7fb      	b.n	431ce <usb_dc_attach+0x5e>
		return -EIO;
   431d6:	f06f 0404 	mvn.w	r4, #4
   431da:	e7f8      	b.n	431ce <usb_dc_attach+0x5e>
   431dc:	20005c94 	.word	0x20005c94
   431e0:	00042d09 	.word	0x00042d09
   431e4:	0bad0000 	.word	0x0bad0000
   431e8:	200012cc 	.word	0x200012cc

000431ec <usb_dc_set_address>:
	return get_usbd_ctx()->attached;
   431ec:	4b07      	ldr	r3, [pc, #28]	; (4320c <usb_dc_set_address+0x20>)
	if (!dev_attached() || !dev_ready()) {
   431ee:	f893 2024 	ldrb.w	r2, [r3, #36]	; 0x24
   431f2:	b13a      	cbz	r2, 43204 <usb_dc_set_address+0x18>
   431f4:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
		return -ENODEV;
   431f8:	2b00      	cmp	r3, #0
   431fa:	bf14      	ite	ne
   431fc:	2000      	movne	r0, #0
   431fe:	f06f 0012 	mvneq.w	r0, #18
   43202:	4770      	bx	lr
   43204:	f06f 0012 	mvn.w	r0, #18
}
   43208:	4770      	bx	lr
   4320a:	bf00      	nop
   4320c:	20005c94 	.word	0x20005c94

00043210 <usb_dc_ep_configure>:
{
   43210:	b538      	push	{r3, r4, r5, lr}
	return get_usbd_ctx()->attached;
   43212:	4b10      	ldr	r3, [pc, #64]	; (43254 <usb_dc_ep_configure+0x44>)
	if (!dev_attached()) {
   43214:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
{
   43218:	4604      	mov	r4, r0
	if (!dev_attached()) {
   4321a:	b1c3      	cbz	r3, 4324e <usb_dc_ep_configure+0x3e>
	ep_ctx = endpoint_ctx(ep_cfg->ep_addr);
   4321c:	7805      	ldrb	r5, [r0, #0]
   4321e:	4628      	mov	r0, r5
   43220:	f7ff fc4a 	bl	42ab8 <endpoint_ctx>
	if (!ep_ctx) {
   43224:	b910      	cbnz	r0, 4322c <usb_dc_ep_configure+0x1c>
		return -EINVAL;
   43226:	f06f 0015 	mvn.w	r0, #21
}
   4322a:	bd38      	pop	{r3, r4, r5, pc}
	ep_ctx->cfg.addr = ep_cfg->ep_addr;
   4322c:	7245      	strb	r5, [r0, #9]
	ep_ctx->cfg.type = ep_cfg->ep_type;
   4322e:	7923      	ldrb	r3, [r4, #4]
   43230:	7283      	strb	r3, [r0, #10]
	ep_ctx->cfg.max_sz = ep_cfg->ep_mps;
   43232:	8863      	ldrh	r3, [r4, #2]
   43234:	6043      	str	r3, [r0, #4]
	if (!NRF_USBD_EPISO_CHECK(ep_cfg->ep_addr)) {
   43236:	7820      	ldrb	r0, [r4, #0]
   43238:	8861      	ldrh	r1, [r4, #2]
   4323a:	f010 0f08 	tst.w	r0, #8
   4323e:	d102      	bne.n	43246 <usb_dc_ep_configure+0x36>
		if ((ep_cfg->ep_mps & (ep_cfg->ep_mps - 1)) != 0U) {
   43240:	1e4b      	subs	r3, r1, #1
   43242:	420b      	tst	r3, r1
   43244:	d1ef      	bne.n	43226 <usb_dc_ep_configure+0x16>
	nrfx_usbd_ep_max_packet_size_set(ep_addr_to_nrfx(ep_cfg->ep_addr),
   43246:	f00c f95a 	bl	4f4fe <nrfx_usbd_ep_max_packet_size_set>
	return 0;
   4324a:	2000      	movs	r0, #0
   4324c:	e7ed      	b.n	4322a <usb_dc_ep_configure+0x1a>
		return -ENODEV;
   4324e:	f06f 0012 	mvn.w	r0, #18
   43252:	e7ea      	b.n	4322a <usb_dc_ep_configure+0x1a>
   43254:	20005c94 	.word	0x20005c94

00043258 <usb_dc_ep_set_stall>:
{
   43258:	b538      	push	{r3, r4, r5, lr}
	return get_usbd_ctx()->attached;
   4325a:	4b12      	ldr	r3, [pc, #72]	; (432a4 <usb_dc_ep_set_stall+0x4c>)
	if (!dev_attached() || !dev_ready()) {
   4325c:	f893 2024 	ldrb.w	r2, [r3, #36]	; 0x24
{
   43260:	4605      	mov	r5, r0
	if (!dev_attached() || !dev_ready()) {
   43262:	b1ca      	cbz	r2, 43298 <usb_dc_ep_set_stall+0x40>
   43264:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
   43268:	b1b3      	cbz	r3, 43298 <usb_dc_ep_set_stall+0x40>
	ep_ctx = endpoint_ctx(ep);
   4326a:	f7ff fc25 	bl	42ab8 <endpoint_ctx>
	if (!ep_ctx) {
   4326e:	4604      	mov	r4, r0
   43270:	b1a8      	cbz	r0, 4329e <usb_dc_ep_set_stall+0x46>
	switch (ep_ctx->cfg.type) {
   43272:	7a83      	ldrb	r3, [r0, #10]
   43274:	2b01      	cmp	r3, #1
   43276:	d012      	beq.n	4329e <usb_dc_ep_set_stall+0x46>
   43278:	d907      	bls.n	4328a <usb_dc_ep_set_stall+0x32>
   4327a:	3b02      	subs	r3, #2
   4327c:	2b01      	cmp	r3, #1
   4327e:	d907      	bls.n	43290 <usb_dc_ep_set_stall+0x38>
	ep_ctx->buf.curr = ep_ctx->buf.data;
   43280:	6963      	ldr	r3, [r4, #20]
   43282:	61a3      	str	r3, [r4, #24]
	ep_ctx->buf.len = 0U;
   43284:	2000      	movs	r0, #0
   43286:	60e0      	str	r0, [r4, #12]
}
   43288:	bd38      	pop	{r3, r4, r5, pc}
		nrfx_usbd_setup_stall();
   4328a:	f003 f853 	bl	46334 <nrfx_usbd_setup_stall>
		break;
   4328e:	e7f7      	b.n	43280 <usb_dc_ep_set_stall+0x28>
		nrfx_usbd_ep_stall(ep_addr_to_nrfx(ep));
   43290:	4628      	mov	r0, r5
   43292:	f002 ffc3 	bl	4621c <nrfx_usbd_ep_stall>
		break;
   43296:	e7f3      	b.n	43280 <usb_dc_ep_set_stall+0x28>
		return -ENODEV;
   43298:	f06f 0012 	mvn.w	r0, #18
   4329c:	e7f4      	b.n	43288 <usb_dc_ep_set_stall+0x30>
	switch (ep_ctx->cfg.type) {
   4329e:	f06f 0015 	mvn.w	r0, #21
   432a2:	e7f1      	b.n	43288 <usb_dc_ep_set_stall+0x30>
   432a4:	20005c94 	.word	0x20005c94

000432a8 <usb_dc_ep_clear_stall>:
{
   432a8:	b538      	push	{r3, r4, r5, lr}
	return get_usbd_ctx()->attached;
   432aa:	4b0e      	ldr	r3, [pc, #56]	; (432e4 <usb_dc_ep_clear_stall+0x3c>)
	if (!dev_attached() || !dev_ready()) {
   432ac:	f893 2024 	ldrb.w	r2, [r3, #36]	; 0x24
{
   432b0:	4605      	mov	r5, r0
	if (!dev_attached() || !dev_ready()) {
   432b2:	b182      	cbz	r2, 432d6 <usb_dc_ep_clear_stall+0x2e>
   432b4:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
   432b8:	b16b      	cbz	r3, 432d6 <usb_dc_ep_clear_stall+0x2e>
	ep_ctx = endpoint_ctx(ep);
   432ba:	f7ff fbfd 	bl	42ab8 <endpoint_ctx>
	if (!ep_ctx) {
   432be:	b168      	cbz	r0, 432dc <usb_dc_ep_clear_stall+0x34>
	if (NRF_USBD_EPISO_CHECK(ep)) {
   432c0:	f015 0408 	ands.w	r4, r5, #8
   432c4:	d10a      	bne.n	432dc <usb_dc_ep_clear_stall+0x34>
	nrfx_usbd_ep_dtoggle_clear(ep_addr_to_nrfx(ep));
   432c6:	4628      	mov	r0, r5
   432c8:	f002 ffca 	bl	46260 <nrfx_usbd_ep_dtoggle_clear>
	nrfx_usbd_ep_stall_clear(ep_addr_to_nrfx(ep));
   432cc:	4628      	mov	r0, r5
   432ce:	f003 fa61 	bl	46794 <nrfx_usbd_ep_stall_clear>
	return 0;
   432d2:	4620      	mov	r0, r4
}
   432d4:	bd38      	pop	{r3, r4, r5, pc}
		return -ENODEV;
   432d6:	f06f 0012 	mvn.w	r0, #18
   432da:	e7fb      	b.n	432d4 <usb_dc_ep_clear_stall+0x2c>
		return -EINVAL;
   432dc:	f06f 0015 	mvn.w	r0, #21
   432e0:	e7f8      	b.n	432d4 <usb_dc_ep_clear_stall+0x2c>
   432e2:	bf00      	nop
   432e4:	20005c94 	.word	0x20005c94

000432e8 <usb_dc_ep_is_stalled>:
{
   432e8:	b538      	push	{r3, r4, r5, lr}
	return get_usbd_ctx()->attached;
   432ea:	4b0c      	ldr	r3, [pc, #48]	; (4331c <usb_dc_ep_is_stalled+0x34>)
	if (!dev_attached() || !dev_ready()) {
   432ec:	f893 2024 	ldrb.w	r2, [r3, #36]	; 0x24
{
   432f0:	4605      	mov	r5, r0
   432f2:	460c      	mov	r4, r1
	if (!dev_attached() || !dev_ready()) {
   432f4:	b162      	cbz	r2, 43310 <usb_dc_ep_is_stalled+0x28>
   432f6:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
   432fa:	b14b      	cbz	r3, 43310 <usb_dc_ep_is_stalled+0x28>
	ep_ctx = endpoint_ctx(ep);
   432fc:	f7ff fbdc 	bl	42ab8 <endpoint_ctx>
	if (!ep_ctx) {
   43300:	b148      	cbz	r0, 43316 <usb_dc_ep_is_stalled+0x2e>
	if (!stalled) {
   43302:	b144      	cbz	r4, 43316 <usb_dc_ep_is_stalled+0x2e>
	*stalled = (uint8_t) nrfx_usbd_ep_stall_check(ep_addr_to_nrfx(ep));
   43304:	4628      	mov	r0, r5
   43306:	f002 ff91 	bl	4622c <nrfx_usbd_ep_stall_check>
   4330a:	7020      	strb	r0, [r4, #0]
	return 0;
   4330c:	2000      	movs	r0, #0
}
   4330e:	bd38      	pop	{r3, r4, r5, pc}
		return -ENODEV;
   43310:	f06f 0012 	mvn.w	r0, #18
   43314:	e7fb      	b.n	4330e <usb_dc_ep_is_stalled+0x26>
		return -EINVAL;
   43316:	f06f 0015 	mvn.w	r0, #21
   4331a:	e7f8      	b.n	4330e <usb_dc_ep_is_stalled+0x26>
   4331c:	20005c94 	.word	0x20005c94

00043320 <usb_dc_ep_enable>:
{
   43320:	b570      	push	{r4, r5, r6, lr}
	return get_usbd_ctx()->attached;
   43322:	4e13      	ldr	r6, [pc, #76]	; (43370 <usb_dc_ep_enable+0x50>)
	if (!dev_attached()) {
   43324:	f896 3024 	ldrb.w	r3, [r6, #36]	; 0x24
{
   43328:	4604      	mov	r4, r0
	if (!dev_attached()) {
   4332a:	b1c3      	cbz	r3, 4335e <usb_dc_ep_enable+0x3e>
	ep_ctx = endpoint_ctx(ep);
   4332c:	f7ff fbc4 	bl	42ab8 <endpoint_ctx>
	if (!ep_ctx) {
   43330:	4605      	mov	r5, r0
   43332:	b1b8      	cbz	r0, 43364 <usb_dc_ep_enable+0x44>
	if (!NRF_USBD_EPISO_CHECK(ep)) {
   43334:	0723      	lsls	r3, r4, #28
   43336:	d405      	bmi.n	43344 <usb_dc_ep_enable+0x24>
		nrfx_usbd_ep_dtoggle_clear(ep_addr_to_nrfx(ep));
   43338:	4620      	mov	r0, r4
   4333a:	f002 ff91 	bl	46260 <nrfx_usbd_ep_dtoggle_clear>
		nrfx_usbd_ep_stall_clear(ep_addr_to_nrfx(ep));
   4333e:	4620      	mov	r0, r4
   43340:	f003 fa28 	bl	46794 <nrfx_usbd_ep_stall_clear>
	if (ep_ctx->cfg.en) {
   43344:	7a2b      	ldrb	r3, [r5, #8]
   43346:	b983      	cbnz	r3, 4336a <usb_dc_ep_enable+0x4a>
	ep_ctx->cfg.en = true;
   43348:	2301      	movs	r3, #1
   4334a:	722b      	strb	r3, [r5, #8]
	if (dev_ready()) {
   4334c:	f896 3025 	ldrb.w	r3, [r6, #37]	; 0x25
   43350:	b90b      	cbnz	r3, 43356 <usb_dc_ep_enable+0x36>
	return 0;
   43352:	2000      	movs	r0, #0
}
   43354:	bd70      	pop	{r4, r5, r6, pc}
		nrfx_usbd_ep_enable(ep_addr_to_nrfx(ep));
   43356:	4620      	mov	r0, r4
   43358:	f003 f9c8 	bl	466ec <nrfx_usbd_ep_enable>
   4335c:	e7f9      	b.n	43352 <usb_dc_ep_enable+0x32>
		return -ENODEV;
   4335e:	f06f 0012 	mvn.w	r0, #18
   43362:	e7f7      	b.n	43354 <usb_dc_ep_enable+0x34>
		return -EINVAL;
   43364:	f06f 0015 	mvn.w	r0, #21
   43368:	e7f4      	b.n	43354 <usb_dc_ep_enable+0x34>
		return -EALREADY;
   4336a:	f06f 0077 	mvn.w	r0, #119	; 0x77
   4336e:	e7f1      	b.n	43354 <usb_dc_ep_enable+0x34>
   43370:	20005c94 	.word	0x20005c94

00043374 <usb_dc_ep_disable>:
{
   43374:	b538      	push	{r3, r4, r5, lr}
	return get_usbd_ctx()->attached;
   43376:	4b11      	ldr	r3, [pc, #68]	; (433bc <usb_dc_ep_disable+0x48>)
	if (!dev_attached() || !dev_ready()) {
   43378:	f893 2024 	ldrb.w	r2, [r3, #36]	; 0x24
{
   4337c:	4604      	mov	r4, r0
	if (!dev_attached() || !dev_ready()) {
   4337e:	b19a      	cbz	r2, 433a8 <usb_dc_ep_disable+0x34>
   43380:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
   43384:	b183      	cbz	r3, 433a8 <usb_dc_ep_disable+0x34>
	ep_ctx = endpoint_ctx(ep);
   43386:	f7ff fb97 	bl	42ab8 <endpoint_ctx>
	if (!ep_ctx) {
   4338a:	4605      	mov	r5, r0
   4338c:	b178      	cbz	r0, 433ae <usb_dc_ep_disable+0x3a>
	if (!ep_ctx->cfg.en) {
   4338e:	7a03      	ldrb	r3, [r0, #8]
   43390:	b183      	cbz	r3, 433b4 <usb_dc_ep_disable+0x40>
	nrfx_usbd_ep_disable(ep_addr_to_nrfx(ep));
   43392:	4620      	mov	r0, r4
	ep_ctx->write_in_progress = false;
   43394:	2400      	movs	r4, #0
	nrfx_usbd_ep_disable(ep_addr_to_nrfx(ep));
   43396:	f003 f97d 	bl	46694 <nrfx_usbd_ep_disable>
	ep_ctx_reset(ep_ctx);
   4339a:	4628      	mov	r0, r5
	ep_ctx->write_in_progress = false;
   4339c:	77ac      	strb	r4, [r5, #30]
	ep_ctx_reset(ep_ctx);
   4339e:	f00b fd7c 	bl	4ee9a <ep_ctx_reset>
	ep_ctx->cfg.en = false;
   433a2:	722c      	strb	r4, [r5, #8]
	return 0;
   433a4:	4620      	mov	r0, r4
}
   433a6:	bd38      	pop	{r3, r4, r5, pc}
		return -ENODEV;
   433a8:	f06f 0012 	mvn.w	r0, #18
   433ac:	e7fb      	b.n	433a6 <usb_dc_ep_disable+0x32>
		return -EINVAL;
   433ae:	f06f 0015 	mvn.w	r0, #21
   433b2:	e7f8      	b.n	433a6 <usb_dc_ep_disable+0x32>
		return -EALREADY;
   433b4:	f06f 0077 	mvn.w	r0, #119	; 0x77
   433b8:	e7f5      	b.n	433a6 <usb_dc_ep_disable+0x32>
   433ba:	bf00      	nop
   433bc:	20005c94 	.word	0x20005c94

000433c0 <usb_dc_ep_write>:
{
   433c0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	return get_usbd_ctx()->attached;
   433c4:	f8df 80e4 	ldr.w	r8, [pc, #228]	; 434ac <usb_dc_ep_write+0xec>
{
   433c8:	461e      	mov	r6, r3
	if (!dev_attached() || !dev_ready()) {
   433ca:	f898 3024 	ldrb.w	r3, [r8, #36]	; 0x24
{
   433ce:	b085      	sub	sp, #20
   433d0:	4607      	mov	r7, r0
   433d2:	4689      	mov	r9, r1
   433d4:	4615      	mov	r5, r2
	if (!dev_attached() || !dev_ready()) {
   433d6:	2b00      	cmp	r3, #0
   433d8:	d061      	beq.n	4349e <usb_dc_ep_write+0xde>
   433da:	f898 3025 	ldrb.w	r3, [r8, #37]	; 0x25
   433de:	2b00      	cmp	r3, #0
   433e0:	d05d      	beq.n	4349e <usb_dc_ep_write+0xde>
	if (NRF_USBD_EPOUT_CHECK(ep)) {
   433e2:	0603      	lsls	r3, r0, #24
   433e4:	d55e      	bpl.n	434a4 <usb_dc_ep_write+0xe4>
	ep_ctx = endpoint_ctx(ep);
   433e6:	f7ff fb67 	bl	42ab8 <endpoint_ctx>
	if (!ep_ctx) {
   433ea:	4604      	mov	r4, r0
   433ec:	2800      	cmp	r0, #0
   433ee:	d059      	beq.n	434a4 <usb_dc_ep_write+0xe4>
	if (!ep_ctx->cfg.en) {
   433f0:	7a03      	ldrb	r3, [r0, #8]
   433f2:	2b00      	cmp	r3, #0
   433f4:	d056      	beq.n	434a4 <usb_dc_ep_write+0xe4>
	k_mutex_lock(&ctx->drv_lock, K_FOREVER);
   433f6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   433fa:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   433fe:	f108 0038 	add.w	r0, r8, #56	; 0x38
   43402:	f00b fd5d 	bl	4eec0 <k_mutex_lock.constprop.0.isra.0>
	if (ep_ctx->write_in_progress) {
   43406:	7fa3      	ldrb	r3, [r4, #30]
   43408:	b14b      	cbz	r3, 4341e <usb_dc_ep_write+0x5e>
		k_mutex_unlock(&ctx->drv_lock);
   4340a:	f108 0038 	add.w	r0, r8, #56	; 0x38
   4340e:	f00b fd59 	bl	4eec4 <k_mutex_unlock.isra.0>
		return -EAGAIN;
   43412:	f06f 040a 	mvn.w	r4, #10
}
   43416:	4620      	mov	r0, r4
   43418:	b005      	add	sp, #20
   4341a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (ep_ctx->cfg.type == USB_DC_EP_CONTROL) {
   4341e:	7aa3      	ldrb	r3, [r4, #10]
	if (!data_len && ep_ctx->trans_zlp) {
   43420:	b1c5      	cbz	r5, 43454 <usb_dc_ep_write+0x94>
	if (ep_ctx->cfg.type == USB_DC_EP_CONTROL) {
   43422:	b33b      	cbz	r3, 43474 <usb_dc_ep_write+0xb4>
	ep_ctx->write_in_progress = true;
   43424:	2301      	movs	r3, #1
   43426:	77a3      	strb	r3, [r4, #30]
	NRFX_USBD_TRANSFER_IN(transfer, data, data_len, 0);
   43428:	f04f 0800 	mov.w	r8, #0
	nrfx_err_t err = nrfx_usbd_ep_transfer(ep_addr_to_nrfx(ep), &transfer);
   4342c:	a901      	add	r1, sp, #4
   4342e:	4638      	mov	r0, r7
	NRFX_USBD_TRANSFER_IN(transfer, data, data_len, 0);
   43430:	e9cd 9501 	strd	r9, r5, [sp, #4]
   43434:	f8cd 800c 	str.w	r8, [sp, #12]
	nrfx_err_t err = nrfx_usbd_ep_transfer(ep_addr_to_nrfx(ep), &transfer);
   43438:	f002 fd4a 	bl	45ed0 <nrfx_usbd_ep_transfer>
	if (err != NRFX_SUCCESS) {
   4343c:	4b1c      	ldr	r3, [pc, #112]	; (434b0 <usb_dc_ep_write+0xf0>)
   4343e:	4298      	cmp	r0, r3
   43440:	d029      	beq.n	43496 <usb_dc_ep_write+0xd6>
		ep_ctx->write_in_progress = false;
   43442:	f884 801e 	strb.w	r8, [r4, #30]
		if (ret_bytes) {
   43446:	bb1e      	cbnz	r6, 43490 <usb_dc_ep_write+0xd0>
		result = -EIO;
   43448:	f06f 0404 	mvn.w	r4, #4
	k_mutex_unlock(&ctx->drv_lock);
   4344c:	4819      	ldr	r0, [pc, #100]	; (434b4 <usb_dc_ep_write+0xf4>)
   4344e:	f00b fd39 	bl	4eec4 <k_mutex_unlock.isra.0>
	return result;
   43452:	e7e0      	b.n	43416 <usb_dc_ep_write+0x56>
	if (!data_len && ep_ctx->trans_zlp) {
   43454:	7fe2      	ldrb	r2, [r4, #31]
   43456:	b102      	cbz	r2, 4345a <usb_dc_ep_write+0x9a>
		ep_ctx->trans_zlp = false;
   43458:	77e5      	strb	r5, [r4, #31]
	if (ep_ctx->cfg.type == USB_DC_EP_CONTROL) {
   4345a:	2b00      	cmp	r3, #0
   4345c:	d1e2      	bne.n	43424 <usb_dc_ep_write+0x64>
	    && (nrfx_usbd_last_setup_dir_get() != ep)) {
   4345e:	f002 ff71 	bl	46344 <nrfx_usbd_last_setup_dir_get>
   43462:	42b8      	cmp	r0, r7
   43464:	d0de      	beq.n	43424 <usb_dc_ep_write+0x64>
		nrfx_usbd_setup_clear();
   43466:	f002 ff5d 	bl	46324 <nrfx_usbd_setup_clear>
		k_mutex_unlock(&ctx->drv_lock);
   4346a:	4812      	ldr	r0, [pc, #72]	; (434b4 <usb_dc_ep_write+0xf4>)
   4346c:	f00b fd2a 	bl	4eec4 <k_mutex_unlock.isra.0>
		return 0;
   43470:	2400      	movs	r4, #0
   43472:	e7d0      	b.n	43416 <usb_dc_ep_write+0x56>
		if (data_len && usbd_ctx.setup.wLength > data_len &&
   43474:	f8b8 300a 	ldrh.w	r3, [r8, #10]
   43478:	42ab      	cmp	r3, r5
   4347a:	d9f0      	bls.n	4345e <usb_dc_ep_write+0x9e>
		    !(data_len % ep_ctx->cfg.max_sz)) {
   4347c:	6862      	ldr	r2, [r4, #4]
   4347e:	fbb5 f3f2 	udiv	r3, r5, r2
   43482:	fb02 5313 	mls	r3, r2, r3, r5
		if (data_len && usbd_ctx.setup.wLength > data_len &&
   43486:	2b00      	cmp	r3, #0
   43488:	d1e9      	bne.n	4345e <usb_dc_ep_write+0x9e>
			ep_ctx->trans_zlp = true;
   4348a:	2301      	movs	r3, #1
   4348c:	77e3      	strb	r3, [r4, #31]
	if ((ep_ctx->cfg.type == USB_DC_EP_CONTROL)
   4348e:	e7e6      	b.n	4345e <usb_dc_ep_write+0x9e>
			*ret_bytes = 0;
   43490:	f8c6 8000 	str.w	r8, [r6]
   43494:	e7d8      	b.n	43448 <usb_dc_ep_write+0x88>
		if (ret_bytes) {
   43496:	b106      	cbz	r6, 4349a <usb_dc_ep_write+0xda>
			*ret_bytes = data_len;
   43498:	6035      	str	r5, [r6, #0]
	int result = 0;
   4349a:	2400      	movs	r4, #0
   4349c:	e7d6      	b.n	4344c <usb_dc_ep_write+0x8c>
		return -ENODEV;
   4349e:	f06f 0412 	mvn.w	r4, #18
   434a2:	e7b8      	b.n	43416 <usb_dc_ep_write+0x56>
		return -EINVAL;
   434a4:	f06f 0415 	mvn.w	r4, #21
   434a8:	e7b5      	b.n	43416 <usb_dc_ep_write+0x56>
   434aa:	bf00      	nop
   434ac:	20005c94 	.word	0x20005c94
   434b0:	0bad0000 	.word	0x0bad0000
   434b4:	20005ccc 	.word	0x20005ccc

000434b8 <usb_dc_ep_read_wait>:
{
   434b8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   434bc:	461d      	mov	r5, r3
	return get_usbd_ctx()->attached;
   434be:	4b20      	ldr	r3, [pc, #128]	; (43540 <usb_dc_ep_read_wait+0x88>)
{
   434c0:	4617      	mov	r7, r2
	if (!dev_attached() || !dev_ready()) {
   434c2:	f893 2024 	ldrb.w	r2, [r3, #36]	; 0x24
{
   434c6:	460e      	mov	r6, r1
	if (!dev_attached() || !dev_ready()) {
   434c8:	2a00      	cmp	r2, #0
   434ca:	d033      	beq.n	43534 <usb_dc_ep_read_wait+0x7c>
   434cc:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
   434d0:	b383      	cbz	r3, 43534 <usb_dc_ep_read_wait+0x7c>
	if (NRF_USBD_EPIN_CHECK(ep)) {
   434d2:	0603      	lsls	r3, r0, #24
   434d4:	d431      	bmi.n	4353a <usb_dc_ep_read_wait+0x82>
	if (!data && max_data_len) {
   434d6:	b901      	cbnz	r1, 434da <usb_dc_ep_read_wait+0x22>
   434d8:	bb7f      	cbnz	r7, 4353a <usb_dc_ep_read_wait+0x82>
	ep_ctx = endpoint_ctx(ep);
   434da:	f7ff faed 	bl	42ab8 <endpoint_ctx>
	if (!ep_ctx) {
   434de:	4604      	mov	r4, r0
   434e0:	b358      	cbz	r0, 4353a <usb_dc_ep_read_wait+0x82>
	if (!ep_ctx->cfg.en) {
   434e2:	7a03      	ldrb	r3, [r0, #8]
   434e4:	b34b      	cbz	r3, 4353a <usb_dc_ep_read_wait+0x82>
	k_mutex_lock(&ctx->drv_lock, K_FOREVER);
   434e6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   434ea:	4816      	ldr	r0, [pc, #88]	; (43544 <usb_dc_ep_read_wait+0x8c>)
   434ec:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   434f0:	f00b fce6 	bl	4eec0 <k_mutex_lock.constprop.0.isra.0>
	bytes_to_copy = MIN(max_data_len, ep_ctx->buf.len);
   434f4:	68e3      	ldr	r3, [r4, #12]
   434f6:	429f      	cmp	r7, r3
   434f8:	46b8      	mov	r8, r7
   434fa:	bf28      	it	cs
   434fc:	4698      	movcs	r8, r3
	if (!data && !max_data_len) {
   434fe:	b946      	cbnz	r6, 43512 <usb_dc_ep_read_wait+0x5a>
   43500:	b93f      	cbnz	r7, 43512 <usb_dc_ep_read_wait+0x5a>
		if (read_bytes) {
   43502:	b105      	cbz	r5, 43506 <usb_dc_ep_read_wait+0x4e>
			*read_bytes = ep_ctx->buf.len;
   43504:	602b      	str	r3, [r5, #0]
		k_mutex_unlock(&ctx->drv_lock);
   43506:	480f      	ldr	r0, [pc, #60]	; (43544 <usb_dc_ep_read_wait+0x8c>)
   43508:	f00b fcdc 	bl	4eec4 <k_mutex_unlock.isra.0>
		return 0;
   4350c:	2000      	movs	r0, #0
}
   4350e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	memcpy(data, ep_ctx->buf.curr, bytes_to_copy);
   43512:	69a1      	ldr	r1, [r4, #24]
   43514:	4642      	mov	r2, r8
   43516:	4630      	mov	r0, r6
   43518:	f007 fcaf 	bl	4ae7a <memcpy>
	ep_ctx->buf.curr += bytes_to_copy;
   4351c:	69a3      	ldr	r3, [r4, #24]
   4351e:	4443      	add	r3, r8
   43520:	61a3      	str	r3, [r4, #24]
	ep_ctx->buf.len -= bytes_to_copy;
   43522:	68e3      	ldr	r3, [r4, #12]
   43524:	eba3 0308 	sub.w	r3, r3, r8
   43528:	60e3      	str	r3, [r4, #12]
	if (read_bytes) {
   4352a:	2d00      	cmp	r5, #0
   4352c:	d0eb      	beq.n	43506 <usb_dc_ep_read_wait+0x4e>
		*read_bytes = bytes_to_copy;
   4352e:	f8c5 8000 	str.w	r8, [r5]
   43532:	e7e8      	b.n	43506 <usb_dc_ep_read_wait+0x4e>
		return -ENODEV;
   43534:	f06f 0012 	mvn.w	r0, #18
   43538:	e7e9      	b.n	4350e <usb_dc_ep_read_wait+0x56>
		return -EINVAL;
   4353a:	f06f 0015 	mvn.w	r0, #21
   4353e:	e7e6      	b.n	4350e <usb_dc_ep_read_wait+0x56>
   43540:	20005c94 	.word	0x20005c94
   43544:	20005ccc 	.word	0x20005ccc

00043548 <usb_dc_ep_read_continue>:
{
   43548:	b570      	push	{r4, r5, r6, lr}
	return get_usbd_ctx()->attached;
   4354a:	4d1e      	ldr	r5, [pc, #120]	; (435c4 <usb_dc_ep_read_continue+0x7c>)
	if (!dev_attached() || !dev_ready()) {
   4354c:	f895 2024 	ldrb.w	r2, [r5, #36]	; 0x24
{
   43550:	4603      	mov	r3, r0
	if (!dev_attached() || !dev_ready()) {
   43552:	b382      	cbz	r2, 435b6 <usb_dc_ep_read_continue+0x6e>
   43554:	f895 2025 	ldrb.w	r2, [r5, #37]	; 0x25
   43558:	b36a      	cbz	r2, 435b6 <usb_dc_ep_read_continue+0x6e>
	if (NRF_USBD_EPIN_CHECK(ep)) {
   4355a:	061b      	lsls	r3, r3, #24
   4355c:	d42e      	bmi.n	435bc <usb_dc_ep_read_continue+0x74>
	ep_ctx = endpoint_ctx(ep);
   4355e:	f7ff faab 	bl	42ab8 <endpoint_ctx>
	if (!ep_ctx) {
   43562:	4604      	mov	r4, r0
   43564:	b350      	cbz	r0, 435bc <usb_dc_ep_read_continue+0x74>
	if (!ep_ctx->cfg.en) {
   43566:	7a03      	ldrb	r3, [r0, #8]
   43568:	b343      	cbz	r3, 435bc <usb_dc_ep_read_continue+0x74>
	k_mutex_lock(&ctx->drv_lock, K_FOREVER);
   4356a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   4356e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   43572:	f105 0038 	add.w	r0, r5, #56	; 0x38
   43576:	f00b fca3 	bl	4eec0 <k_mutex_lock.constprop.0.isra.0>
	if (!ep_ctx->buf.len) {
   4357a:	68e3      	ldr	r3, [r4, #12]
   4357c:	b9b3      	cbnz	r3, 435ac <usb_dc_ep_read_continue+0x64>
		ep_ctx->read_complete = true;
   4357e:	2601      	movs	r6, #1
		ep_ctx->buf.curr = ep_ctx->buf.data;
   43580:	6963      	ldr	r3, [r4, #20]
		ep_ctx->read_complete = true;
   43582:	7726      	strb	r6, [r4, #28]
		ep_ctx->buf.curr = ep_ctx->buf.data;
   43584:	61a3      	str	r3, [r4, #24]
		if (ep_ctx->read_pending) {
   43586:	7f63      	ldrb	r3, [r4, #29]
   43588:	b183      	cbz	r3, 435ac <usb_dc_ep_read_continue+0x64>
			struct usbd_event *ev = usbd_evt_alloc();
   4358a:	f7ff fb0d 	bl	42ba8 <usbd_evt_alloc>
			if (!ev) {
   4358e:	b930      	cbnz	r0, 4359e <usb_dc_ep_read_continue+0x56>
				k_mutex_unlock(&ctx->drv_lock);
   43590:	f105 0038 	add.w	r0, r5, #56	; 0x38
   43594:	f00b fc96 	bl	4eec4 <k_mutex_unlock.isra.0>
				return -ENOMEM;
   43598:	f06f 000b 	mvn.w	r0, #11
}
   4359c:	bd70      	pop	{r4, r5, r6, pc}
			ev->evt_type = USBD_EVT_EP;
   4359e:	7406      	strb	r6, [r0, #16]
			ev->evt.ep_evt.ep = ep_ctx;
   435a0:	6084      	str	r4, [r0, #8]
			ev->evt.ep_evt.evt_type = EP_EVT_RECV_REQ;
   435a2:	7306      	strb	r6, [r0, #12]
			usbd_evt_put(ev);
   435a4:	f7ff fab8 	bl	42b18 <usbd_evt_put>
			usbd_work_schedule();
   435a8:	f7ff fabc 	bl	42b24 <usbd_work_schedule>
	k_mutex_unlock(&ctx->drv_lock);
   435ac:	4806      	ldr	r0, [pc, #24]	; (435c8 <usb_dc_ep_read_continue+0x80>)
   435ae:	f00b fc89 	bl	4eec4 <k_mutex_unlock.isra.0>
	return 0;
   435b2:	2000      	movs	r0, #0
   435b4:	e7f2      	b.n	4359c <usb_dc_ep_read_continue+0x54>
		return -ENODEV;
   435b6:	f06f 0012 	mvn.w	r0, #18
   435ba:	e7ef      	b.n	4359c <usb_dc_ep_read_continue+0x54>
		return -EINVAL;
   435bc:	f06f 0015 	mvn.w	r0, #21
   435c0:	e7ec      	b.n	4359c <usb_dc_ep_read_continue+0x54>
   435c2:	bf00      	nop
   435c4:	20005c94 	.word	0x20005c94
   435c8:	20005ccc 	.word	0x20005ccc

000435cc <usb_dc_ep_set_callback>:
{
   435cc:	b510      	push	{r4, lr}
	return get_usbd_ctx()->attached;
   435ce:	4b08      	ldr	r3, [pc, #32]	; (435f0 <usb_dc_ep_set_callback+0x24>)
	if (!dev_attached()) {
   435d0:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
{
   435d4:	460c      	mov	r4, r1
	if (!dev_attached()) {
   435d6:	b12b      	cbz	r3, 435e4 <usb_dc_ep_set_callback+0x18>
	ep_ctx = endpoint_ctx(ep);
   435d8:	f7ff fa6e 	bl	42ab8 <endpoint_ctx>
	if (!ep_ctx) {
   435dc:	b128      	cbz	r0, 435ea <usb_dc_ep_set_callback+0x1e>
	ep_ctx->cfg.cb = cb;
   435de:	6004      	str	r4, [r0, #0]
	return 0;
   435e0:	2000      	movs	r0, #0
}
   435e2:	bd10      	pop	{r4, pc}
		return -ENODEV;
   435e4:	f06f 0012 	mvn.w	r0, #18
   435e8:	e7fb      	b.n	435e2 <usb_dc_ep_set_callback+0x16>
		return -EINVAL;
   435ea:	f06f 0015 	mvn.w	r0, #21
   435ee:	e7f8      	b.n	435e2 <usb_dc_ep_set_callback+0x16>
   435f0:	20005c94 	.word	0x20005c94

000435f4 <usb_dc_set_status_callback>:
	get_usbd_ctx()->status_cb = cb;
   435f4:	4b01      	ldr	r3, [pc, #4]	; (435fc <usb_dc_set_status_callback+0x8>)
   435f6:	6018      	str	r0, [r3, #0]
}
   435f8:	4770      	bx	lr
   435fa:	bf00      	nop
   435fc:	20005c94 	.word	0x20005c94

00043600 <usb_dc_ep_mps>:
{
   43600:	b508      	push	{r3, lr}
	return get_usbd_ctx()->attached;
   43602:	4b07      	ldr	r3, [pc, #28]	; (43620 <usb_dc_ep_mps+0x20>)
	if (!dev_attached()) {
   43604:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
   43608:	b123      	cbz	r3, 43614 <usb_dc_ep_mps+0x14>
	ep_ctx = endpoint_ctx(ep);
   4360a:	f7ff fa55 	bl	42ab8 <endpoint_ctx>
	if (!ep_ctx) {
   4360e:	b120      	cbz	r0, 4361a <usb_dc_ep_mps+0x1a>
	return ep_ctx->cfg.max_sz;
   43610:	6840      	ldr	r0, [r0, #4]
}
   43612:	bd08      	pop	{r3, pc}
		return -ENODEV;
   43614:	f06f 0012 	mvn.w	r0, #18
   43618:	e7fb      	b.n	43612 <usb_dc_ep_mps+0x12>
		return -EINVAL;
   4361a:	f06f 0015 	mvn.w	r0, #21
   4361e:	e7f8      	b.n	43612 <usb_dc_ep_mps+0x12>
   43620:	20005c94 	.word	0x20005c94

00043624 <adc_gain_invert>:
		[ADC_GAIN_64] = {.mul = 1, .div = 64},
		[ADC_GAIN_128] = {.mul = 1, .div = 128},
	};
	int rv = -EINVAL;

	if ((uint8_t)gain < ARRAY_SIZE(gains)) {
   43624:	2813      	cmp	r0, #19
   43626:	d80e      	bhi.n	43646 <adc_gain_invert+0x22>
		const struct gain_desc *gdp = &gains[gain];

		if ((gdp->mul != 0) && (gdp->div != 0)) {
   43628:	4a08      	ldr	r2, [pc, #32]	; (4364c <adc_gain_invert+0x28>)
   4362a:	f812 3010 	ldrb.w	r3, [r2, r0, lsl #1]
   4362e:	b153      	cbz	r3, 43646 <adc_gain_invert+0x22>
   43630:	eb02 0240 	add.w	r2, r2, r0, lsl #1
   43634:	7852      	ldrb	r2, [r2, #1]
   43636:	b132      	cbz	r2, 43646 <adc_gain_invert+0x22>
			*value = (gdp->mul * *value) / gdp->div;
   43638:	6808      	ldr	r0, [r1, #0]
   4363a:	4343      	muls	r3, r0
			rv = 0;
   4363c:	2000      	movs	r0, #0
			*value = (gdp->mul * *value) / gdp->div;
   4363e:	fb93 f3f2 	sdiv	r3, r3, r2
   43642:	600b      	str	r3, [r1, #0]
			rv = 0;
   43644:	4770      	bx	lr
	int rv = -EINVAL;
   43646:	f06f 0015 	mvn.w	r0, #21
		}
	}

	return rv;
}
   4364a:	4770      	bx	lr
   4364c:	000537f1 	.word	0x000537f1

00043650 <adc_context_start_sampling>:
    return (p_reg->STATUS == (SAADC_STATUS_STATUS_Busy << SAADC_STATUS_STATUS_Pos));
}

NRF_STATIC_INLINE void nrf_saadc_enable(NRF_SAADC_Type * p_reg)
{
    p_reg->ENABLE = (SAADC_ENABLE_ENABLE_Enabled << SAADC_ENABLE_ENABLE_Pos);
   43650:	4b05      	ldr	r3, [pc, #20]	; (43668 <adc_context_start_sampling+0x18>)
   43652:	2201      	movs	r2, #1
   43654:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500

static void adc_context_start_sampling(struct adc_context *ctx)
{
	nrf_saadc_enable(NRF_SAADC);

	if (ctx->sequence.calibrate) {
   43658:	f890 1086 	ldrb.w	r1, [r0, #134]	; 0x86
   4365c:	b109      	cbz	r1, 43662 <adc_context_start_sampling+0x12>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   4365e:	60da      	str	r2, [r3, #12]
}
   43660:	4770      	bx	lr
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   43662:	601a      	str	r2, [r3, #0]
   43664:	605a      	str	r2, [r3, #4]
				       NRF_SAADC_TASK_CALIBRATEOFFSET);
	} else {
		nrf_saadc_task_trigger(NRF_SAADC, NRF_SAADC_TASK_START);
		nrf_saadc_task_trigger(NRF_SAADC, NRF_SAADC_TASK_SAMPLE);
	}
}
   43666:	4770      	bx	lr
   43668:	40007000 	.word	0x40007000

0004366c <adc_nrfx_channel_setup>:
	uint8_t channel_id = channel_cfg->channel_id;
   4366c:	7908      	ldrb	r0, [r1, #4]
{
   4366e:	b570      	push	{r4, r5, r6, lr}
	uint8_t channel_id = channel_cfg->channel_id;
   43670:	f000 041f 	and.w	r4, r0, #31
	if (channel_id >= SAADC_CH_NUM) {
   43674:	2c07      	cmp	r4, #7
   43676:	d820      	bhi.n	436ba <adc_nrfx_channel_setup+0x4e>
	switch (channel_cfg->gain) {
   43678:	780b      	ldrb	r3, [r1, #0]
   4367a:	2b0b      	cmp	r3, #11
   4367c:	d81d      	bhi.n	436ba <adc_nrfx_channel_setup+0x4e>
   4367e:	e8df f003 	tbb	[pc, r3]
   43682:	0707      	.short	0x0707
   43684:	061c0707 	.word	0x061c0707
   43688:	211f1c1c 	.word	0x211f1c1c
   4368c:	231c      	.short	0x231c
		config.gain = NRF_SAADC_GAIN1_2;
   4368e:	2304      	movs	r3, #4
	switch (channel_cfg->reference) {
   43690:	784a      	ldrb	r2, [r1, #1]
   43692:	2a03      	cmp	r2, #3
   43694:	d01a      	beq.n	436cc <adc_nrfx_channel_setup+0x60>
   43696:	2a04      	cmp	r2, #4
   43698:	d10f      	bne.n	436ba <adc_nrfx_channel_setup+0x4e>
	nrf_saadc_channel_config_t config = {
   4369a:	2500      	movs	r5, #0
	switch (channel_cfg->acquisition_time) {
   4369c:	884a      	ldrh	r2, [r1, #2]
   4369e:	f244 060a 	movw	r6, #16394	; 0x400a
   436a2:	42b2      	cmp	r2, r6
   436a4:	d046      	beq.n	43734 <adc_nrfx_channel_setup+0xc8>
   436a6:	d813      	bhi.n	436d0 <adc_nrfx_channel_setup+0x64>
   436a8:	f244 0603 	movw	r6, #16387	; 0x4003
   436ac:	42b2      	cmp	r2, r6
   436ae:	d03d      	beq.n	4372c <adc_nrfx_channel_setup+0xc0>
   436b0:	f244 0605 	movw	r6, #16389	; 0x4005
   436b4:	42b2      	cmp	r2, r6
   436b6:	d03b      	beq.n	43730 <adc_nrfx_channel_setup+0xc4>
   436b8:	b3e2      	cbz	r2, 43734 <adc_nrfx_channel_setup+0xc8>
   436ba:	f06f 0015 	mvn.w	r0, #21
   436be:	e034      	b.n	4372a <adc_nrfx_channel_setup+0xbe>
		config.gain = NRF_SAADC_GAIN1;
   436c0:	2305      	movs	r3, #5
		break;
   436c2:	e7e5      	b.n	43690 <adc_nrfx_channel_setup+0x24>
		config.gain = NRF_SAADC_GAIN2;
   436c4:	2306      	movs	r3, #6
		break;
   436c6:	e7e3      	b.n	43690 <adc_nrfx_channel_setup+0x24>
		config.gain = NRF_SAADC_GAIN4;
   436c8:	2307      	movs	r3, #7
		break;
   436ca:	e7e1      	b.n	43690 <adc_nrfx_channel_setup+0x24>
	switch (channel_cfg->reference) {
   436cc:	2501      	movs	r5, #1
   436ce:	e7e5      	b.n	4369c <adc_nrfx_channel_setup+0x30>
	switch (channel_cfg->acquisition_time) {
   436d0:	f244 0614 	movw	r6, #16404	; 0x4014
   436d4:	42b2      	cmp	r2, r6
   436d6:	d02f      	beq.n	43738 <adc_nrfx_channel_setup+0xcc>
   436d8:	f244 0628 	movw	r6, #16424	; 0x4028
   436dc:	42b2      	cmp	r2, r6
   436de:	d02d      	beq.n	4373c <adc_nrfx_channel_setup+0xd0>
   436e0:	f244 060f 	movw	r6, #16399	; 0x400f
   436e4:	42b2      	cmp	r2, r6
   436e6:	d1e8      	bne.n	436ba <adc_nrfx_channel_setup+0x4e>
		config.acq_time = NRF_SAADC_ACQTIME_15US;
   436e8:	2203      	movs	r2, #3
            ((config->resistor_p   << SAADC_CH_CONFIG_RESP_Pos)   & SAADC_CH_CONFIG_RESP_Msk)
            | ((config->resistor_n << SAADC_CH_CONFIG_RESN_Pos)   & SAADC_CH_CONFIG_RESN_Msk)
            | ((config->gain       << SAADC_CH_CONFIG_GAIN_Pos)   & SAADC_CH_CONFIG_GAIN_Msk)
            | ((config->reference  << SAADC_CH_CONFIG_REFSEL_Pos) & SAADC_CH_CONFIG_REFSEL_Msk)
            | ((config->acq_time   << SAADC_CH_CONFIG_TACQ_Pos)   & SAADC_CH_CONFIG_TACQ_Msk)
            | ((config->mode       << SAADC_CH_CONFIG_MODE_Pos)   & SAADC_CH_CONFIG_MODE_Msk)
   436ea:	f3c0 1040 	ubfx	r0, r0, #5, #1
            | ((config->gain       << SAADC_CH_CONFIG_GAIN_Pos)   & SAADC_CH_CONFIG_GAIN_Msk)
   436ee:	021b      	lsls	r3, r3, #8
            | ((config->mode       << SAADC_CH_CONFIG_MODE_Pos)   & SAADC_CH_CONFIG_MODE_Msk)
   436f0:	ea43 5300 	orr.w	r3, r3, r0, lsl #20
   436f4:	ea43 3305 	orr.w	r3, r3, r5, lsl #12
   436f8:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
    p_reg->CH[channel].CONFIG =
   436fc:	0122      	lsls	r2, r4, #4
   436fe:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
   43702:	f502 42e0 	add.w	r2, r2, #28672	; 0x7000
    p_reg->CH[channel].PSELP = pselp;
   43706:	2000      	movs	r0, #0
    p_reg->CH[channel].CONFIG =
   43708:	f8c2 3518 	str.w	r3, [r2, #1304]	; 0x518
    p_reg->CH[channel].PSELN = pseln;
   4370c:	0123      	lsls	r3, r4, #4
   4370e:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   43712:	f503 43e0 	add.w	r3, r3, #28672	; 0x7000
   43716:	798a      	ldrb	r2, [r1, #6]
   43718:	f8c3 2514 	str.w	r2, [r3, #1300]	; 0x514
    p_reg->CH[channel].PSELP = pselp;
   4371c:	f8c3 0510 	str.w	r0, [r3, #1296]	; 0x510
	m_data.positive_inputs[channel_id] = channel_cfg->input_positive;
   43720:	4b07      	ldr	r3, [pc, #28]	; (43740 <adc_nrfx_channel_setup+0xd4>)
   43722:	794a      	ldrb	r2, [r1, #5]
   43724:	4423      	add	r3, r4
   43726:	f883 20a0 	strb.w	r2, [r3, #160]	; 0xa0
}
   4372a:	bd70      	pop	{r4, r5, r6, pc}
	nrf_saadc_channel_config_t config = {
   4372c:	2200      	movs	r2, #0
   4372e:	e7dc      	b.n	436ea <adc_nrfx_channel_setup+0x7e>
	switch (channel_cfg->acquisition_time) {
   43730:	2201      	movs	r2, #1
   43732:	e7da      	b.n	436ea <adc_nrfx_channel_setup+0x7e>
		config.acq_time = NRF_SAADC_ACQTIME_10US;
   43734:	2202      	movs	r2, #2
   43736:	e7d8      	b.n	436ea <adc_nrfx_channel_setup+0x7e>
		config.acq_time = NRF_SAADC_ACQTIME_20US;
   43738:	2204      	movs	r2, #4
   4373a:	e7d6      	b.n	436ea <adc_nrfx_channel_setup+0x7e>
		config.acq_time = NRF_SAADC_ACQTIME_40US;
   4373c:	2205      	movs	r2, #5
   4373e:	e7d4      	b.n	436ea <adc_nrfx_channel_setup+0x7e>
   43740:	20000198 	.word	0x20000198

00043744 <adc_nrfx_read>:
}

/* Implementation of the ADC driver API function: adc_read. */
static int adc_nrfx_read(const struct device *dev,
			 const struct adc_sequence *sequence)
{
   43744:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   43746:	460c      	mov	r4, r1
	return z_impl_k_sem_take(sem, timeout);
   43748:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   4374c:	4856      	ldr	r0, [pc, #344]	; (438a8 <adc_nrfx_read+0x164>)
   4374e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   43752:	f003 fd37 	bl	471c4 <z_impl_k_sem_take>
	uint32_t selected_channels = sequence->channels;
   43756:	6866      	ldr	r6, [r4, #4]
	if (!selected_channels ||
   43758:	1e73      	subs	r3, r6, #1
   4375a:	2bfe      	cmp	r3, #254	; 0xfe
   4375c:	d83c      	bhi.n	437d8 <adc_nrfx_read+0x94>
   4375e:	2300      	movs	r3, #0
    p_reg->CH[channel].PSELP = pselp;
   43760:	4852      	ldr	r0, [pc, #328]	; (438ac <adc_nrfx_read+0x168>)
			if (m_data.positive_inputs[channel_id] == 0U) {
   43762:	4f53      	ldr	r7, [pc, #332]	; (438b0 <adc_nrfx_read+0x16c>)
	active_channels = 0U;
   43764:	461a      	mov	r2, r3
		if (selected_channels & BIT(channel_id)) {
   43766:	fa26 f103 	lsr.w	r1, r6, r3
   4376a:	f011 0101 	ands.w	r1, r1, #1
   4376e:	d026      	beq.n	437be <adc_nrfx_read+0x7a>
			if (m_data.positive_inputs[channel_id] == 0U) {
   43770:	f817 c003 	ldrb.w	ip, [r7, r3]
   43774:	f1bc 0f00 	cmp.w	ip, #0
   43778:	d02e      	beq.n	437d8 <adc_nrfx_read+0x94>

NRF_STATIC_INLINE void nrf_saadc_burst_set(NRF_SAADC_Type *  p_reg,
                                           uint8_t           channel,
                                           nrf_saadc_burst_t burst)
{
    p_reg->CH[channel].CONFIG = (p_reg->CH[channel].CONFIG & ~SAADC_CH_CONFIG_BURST_Msk) |
   4377a:	eb00 1e03 	add.w	lr, r0, r3, lsl #4
			nrf_saadc_burst_set(NRF_SAADC, channel_id,
   4377e:	7c65      	ldrb	r5, [r4, #17]
   43780:	f8de 1518 	ldr.w	r1, [lr, #1304]	; 0x518
   43784:	3d00      	subs	r5, #0
   43786:	bf18      	it	ne
   43788:	2501      	movne	r5, #1
   4378a:	f021 7180 	bic.w	r1, r1, #16777216	; 0x1000000
   4378e:	ea41 6105 	orr.w	r1, r1, r5, lsl #24
   43792:	f8ce 1518 	str.w	r1, [lr, #1304]	; 0x518
    p_reg->CH[channel].PSELP = pselp;
   43796:	f103 0151 	add.w	r1, r3, #81	; 0x51
   4379a:	0109      	lsls	r1, r1, #4
			++active_channels;
   4379c:	3201      	adds	r2, #1
   4379e:	f840 c001 	str.w	ip, [r0, r1]
   437a2:	b2d2      	uxtb	r2, r2
	} while (++channel_id < SAADC_CH_NUM);
   437a4:	3301      	adds	r3, #1
   437a6:	2b08      	cmp	r3, #8
   437a8:	d1dd      	bne.n	43766 <adc_nrfx_read+0x22>
	switch (sequence->resolution) {
   437aa:	7c23      	ldrb	r3, [r4, #16]
   437ac:	3b08      	subs	r3, #8
   437ae:	2b06      	cmp	r3, #6
   437b0:	d812      	bhi.n	437d8 <adc_nrfx_read+0x94>
   437b2:	e8df f003 	tbb	[pc, r3]
   437b6:	1109      	.short	0x1109
   437b8:	1119111d 	.word	0x1119111d
   437bc:	1b          	.byte	0x1b
   437bd:	00          	.byte	0x00
   437be:	f103 0551 	add.w	r5, r3, #81	; 0x51
   437c2:	012d      	lsls	r5, r5, #4
   437c4:	5141      	str	r1, [r0, r5]
}
   437c6:	e7ed      	b.n	437a4 <adc_nrfx_read+0x60>
		nrf_resolution = NRF_SAADC_RESOLUTION_8BIT;
   437c8:	2300      	movs	r3, #0
    p_reg->RESOLUTION = resolution;
   437ca:	4938      	ldr	r1, [pc, #224]	; (438ac <adc_nrfx_read+0x168>)
	if ((active_channels > 1) && (sequence->oversampling > 0)) {
   437cc:	2a01      	cmp	r2, #1
   437ce:	f8c1 35f0 	str.w	r3, [r1, #1520]	; 0x5f0
	error = set_oversampling(sequence, active_channels);
   437d2:	7c63      	ldrb	r3, [r4, #17]
	if ((active_channels > 1) && (sequence->oversampling > 0)) {
   437d4:	d90e      	bls.n	437f4 <adc_nrfx_read+0xb0>
   437d6:	b17b      	cbz	r3, 437f8 <adc_nrfx_read+0xb4>
		return -EINVAL;
   437d8:	f06f 0415 	mvn.w	r4, #21
	z_impl_k_sem_give(sem);
   437dc:	4832      	ldr	r0, [pc, #200]	; (438a8 <adc_nrfx_read+0x164>)
   437de:	f003 fccb 	bl	47178 <z_impl_k_sem_give>
	adc_context_lock(&m_data.ctx, false, NULL);
	error = start_read(dev, sequence);
	adc_context_release(&m_data.ctx, error);

	return error;
}
   437e2:	4620      	mov	r0, r4
   437e4:	b003      	add	sp, #12
   437e6:	bdf0      	pop	{r4, r5, r6, r7, pc}
		nrf_resolution = NRF_SAADC_RESOLUTION_12BIT;
   437e8:	2302      	movs	r3, #2
		break;
   437ea:	e7ee      	b.n	437ca <adc_nrfx_read+0x86>
		nrf_resolution = NRF_SAADC_RESOLUTION_14BIT;
   437ec:	2303      	movs	r3, #3
		break;
   437ee:	e7ec      	b.n	437ca <adc_nrfx_read+0x86>
	switch (sequence->resolution) {
   437f0:	2301      	movs	r3, #1
   437f2:	e7ea      	b.n	437ca <adc_nrfx_read+0x86>
	switch (sequence->oversampling) {
   437f4:	2b08      	cmp	r3, #8
   437f6:	d8ef      	bhi.n	437d8 <adc_nrfx_read+0x94>
    p_reg->OVERSAMPLE = oversample;
   437f8:	f8c1 35f4 	str.w	r3, [r1, #1524]	; 0x5f4
	if (sequence->options) {
   437fc:	6821      	ldr	r1, [r4, #0]
	needed_buffer_size = active_channels * sizeof(nrf_saadc_value_t);
   437fe:	0053      	lsls	r3, r2, #1
	if (sequence->options) {
   43800:	b111      	cbz	r1, 43808 <adc_nrfx_read+0xc4>
		needed_buffer_size *= (1 + sequence->options->extra_samplings);
   43802:	8989      	ldrh	r1, [r1, #12]
   43804:	fb01 3303 	mla	r3, r1, r3, r3
	if (sequence->buffer_size < needed_buffer_size) {
   43808:	68e1      	ldr	r1, [r4, #12]
   4380a:	4299      	cmp	r1, r3
   4380c:	d348      	bcc.n	438a0 <adc_nrfx_read+0x15c>
    p_reg->RESULT.PTR = (uint32_t)p_buffer;
   4380e:	4b27      	ldr	r3, [pc, #156]	; (438ac <adc_nrfx_read+0x168>)
   43810:	68a1      	ldr	r1, [r4, #8]
   43812:	f8c3 162c 	str.w	r1, [r3, #1580]	; 0x62c
}

static inline void adc_context_start_read(struct adc_context *ctx,
					  const struct adc_sequence *sequence)
{
	ctx->sequence = *sequence;
   43816:	4627      	mov	r7, r4
    p_reg->RESULT.MAXCNT = size;
   43818:	f8c3 2630 	str.w	r2, [r3, #1584]	; 0x630
   4381c:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
   4381e:	4d25      	ldr	r5, [pc, #148]	; (438b4 <adc_nrfx_read+0x170>)
   43820:	f105 0674 	add.w	r6, r5, #116	; 0x74
   43824:	c60f      	stmia	r6!, {r0, r1, r2, r3}
   43826:	683b      	ldr	r3, [r7, #0]
   43828:	6033      	str	r3, [r6, #0]
	ctx->status = 0;
   4382a:	2600      	movs	r6, #0
   4382c:	672e      	str	r6, [r5, #112]	; 0x70

	if (sequence->options) {
   4382e:	6823      	ldr	r3, [r4, #0]
   43830:	462f      	mov	r7, r5
   43832:	b38b      	cbz	r3, 43898 <adc_nrfx_read+0x154>
		ctx->options = *sequence->options;
   43834:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
   43836:	f105 0488 	add.w	r4, r5, #136	; 0x88
   4383a:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
		ctx->sequence.options = &ctx->options;
   4383e:	676c      	str	r4, [r5, #116]	; 0x74
		ctx->sampling_index = 0U;
   43840:	f8a5 6098 	strh.w	r6, [r5, #152]	; 0x98

		if (ctx->options.interval_us != 0U) {
   43844:	b340      	cbz	r0, 43898 <adc_nrfx_read+0x154>
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   43846:	f3bf 8f5b 	dmb	ish
   4384a:	e857 3f00 	ldrex	r3, [r7]
   4384e:	e847 6200 	strex	r2, r6, [r7]
   43852:	2a00      	cmp	r2, #0
   43854:	d1f9      	bne.n	4384a <adc_nrfx_read+0x106>
   43856:	f3bf 8f5b 	dmb	ish
   4385a:	4917      	ldr	r1, [pc, #92]	; (438b8 <adc_nrfx_read+0x174>)
   4385c:	f8d5 4088 	ldr.w	r4, [r5, #136]	; 0x88
   43860:	4a16      	ldr	r2, [pc, #88]	; (438bc <adc_nrfx_read+0x178>)
   43862:	f44f 4000 	mov.w	r0, #32768	; 0x8000
   43866:	460f      	mov	r7, r1
   43868:	4631      	mov	r1, r6
   4386a:	fbe4 7100 	umlal	r7, r1, r4, r0
   4386e:	2300      	movs	r3, #0
   43870:	4638      	mov	r0, r7
   43872:	f7e2 fc45 	bl	26100 <__aeabi_uldivmod>
	z_impl_k_timer_start(timer, duration, period);
   43876:	2200      	movs	r2, #0
   43878:	e9cd 0100 	strd	r0, r1, [sp]
   4387c:	2300      	movs	r3, #0
   4387e:	f105 0008 	add.w	r0, r5, #8
   43882:	f004 fbdb 	bl	4803c <z_impl_k_timer_start>
	return z_impl_k_sem_take(sem, timeout);
   43886:	480e      	ldr	r0, [pc, #56]	; (438c0 <adc_nrfx_read+0x17c>)
   43888:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   4388c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   43890:	f003 fc98 	bl	471c4 <z_impl_k_sem_take>
	return ctx->status;
   43894:	6f2c      	ldr	r4, [r5, #112]	; 0x70
	return error;
   43896:	e7a1      	b.n	437dc <adc_nrfx_read+0x98>
			adc_context_enable_timer(ctx);
			return;
		}
	}

	adc_context_start_sampling(ctx);
   43898:	4806      	ldr	r0, [pc, #24]	; (438b4 <adc_nrfx_read+0x170>)
   4389a:	f7ff fed9 	bl	43650 <adc_context_start_sampling>
   4389e:	e7f2      	b.n	43886 <adc_nrfx_read+0x142>
		return -ENOMEM;
   438a0:	f06f 040b 	mvn.w	r4, #11
   438a4:	e79a      	b.n	437dc <adc_nrfx_read+0x98>
   438a6:	bf00      	nop
   438a8:	200001d8 	.word	0x200001d8
   438ac:	40007000 	.word	0x40007000
   438b0:	20000238 	.word	0x20000238
   438b4:	20000198 	.word	0x20000198
   438b8:	000f423f 	.word	0x000f423f
   438bc:	000f4240 	.word	0x000f4240
   438c0:	200001f0 	.word	0x200001f0

000438c4 <init_saadc>:
		nrf_saadc_task_trigger(NRF_SAADC, NRF_SAADC_TASK_SAMPLE);
	}
}

static int init_saadc(const struct device *dev)
{
   438c4:	b510      	push	{r4, lr}
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   438c6:	4b0e      	ldr	r3, [pc, #56]	; (43900 <init_saadc+0x3c>)
   438c8:	2400      	movs	r4, #0
   438ca:	f8c3 4104 	str.w	r4, [r3, #260]	; 0x104
#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_event_readback(void * p_event_reg)
{
#if NRFX_CHECK(NRFX_EVENT_READBACK_ENABLED) && !defined(NRF51)
    (void)*((volatile uint32_t *)(p_event_reg));
   438ce:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
   438d2:	f8c3 4110 	str.w	r4, [r3, #272]	; 0x110
   438d6:	f8d3 2110 	ldr.w	r2, [r3, #272]	; 0x110
    p_reg->INTENSET = mask;
   438da:	2212      	movs	r2, #18
   438dc:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
	nrf_saadc_event_clear(NRF_SAADC, NRF_SAADC_EVENT_END);
	nrf_saadc_event_clear(NRF_SAADC, NRF_SAADC_EVENT_CALIBRATEDONE);
	nrf_saadc_int_enable(NRF_SAADC,
			     NRF_SAADC_INT_END | NRF_SAADC_INT_CALIBRATEDONE);
	NRFX_IRQ_ENABLE(DT_INST_IRQN(0));
   438e0:	2007      	movs	r0, #7
   438e2:	f7e9 fa67 	bl	2cdb4 <arch_irq_enable>

	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
   438e6:	4622      	mov	r2, r4
   438e8:	2101      	movs	r1, #1
   438ea:	2007      	movs	r0, #7
   438ec:	f7e9 fa92 	bl	2ce14 <z_arm_irq_priority_set>
	return sem->count;
   438f0:	4804      	ldr	r0, [pc, #16]	; (43904 <init_saadc+0x40>)
	if (!k_sem_count_get(&ctx->lock)) {
   438f2:	6c83      	ldr	r3, [r0, #72]	; 0x48
   438f4:	b913      	cbnz	r3, 438fc <init_saadc+0x38>
	z_impl_k_sem_give(sem);
   438f6:	3040      	adds	r0, #64	; 0x40
   438f8:	f003 fc3e 	bl	47178 <z_impl_k_sem_give>
		    saadc_irq_handler, DEVICE_DT_INST_GET(0), 0);

	adc_context_unlock_unconditionally(&m_data.ctx);

	return 0;
}
   438fc:	2000      	movs	r0, #0
   438fe:	bd10      	pop	{r4, pc}
   43900:	40007000 	.word	0x40007000
   43904:	20000198 	.word	0x20000198

00043908 <saadc_irq_handler>:
{
   43908:	b538      	push	{r3, r4, r5, lr}
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   4390a:	4b2f      	ldr	r3, [pc, #188]	; (439c8 <saadc_irq_handler+0xc0>)
   4390c:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
	if (nrf_saadc_event_check(NRF_SAADC, NRF_SAADC_EVENT_END)) {
   43910:	2a00      	cmp	r2, #0
   43912:	d04c      	beq.n	439ae <saadc_irq_handler+0xa6>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   43914:	2200      	movs	r2, #0
   43916:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
   4391a:	f8d3 1104 	ldr.w	r1, [r3, #260]	; 0x104
 * function if required and takes further actions accordingly.
 */
static inline void adc_context_on_sampling_done(struct adc_context *ctx,
						const struct device *dev)
{
	if (ctx->sequence.options) {
   4391e:	4c2b      	ldr	r4, [pc, #172]	; (439cc <saadc_irq_handler+0xc4>)
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   43920:	2101      	movs	r1, #1
   43922:	6099      	str	r1, [r3, #8]
    p_reg->ENABLE = (SAADC_ENABLE_ENABLE_Disabled << SAADC_ENABLE_ENABLE_Pos);
   43924:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
   43928:	6f63      	ldr	r3, [r4, #116]	; 0x74
   4392a:	4625      	mov	r5, r4
   4392c:	b3d3      	cbz	r3, 439a4 <saadc_irq_handler+0x9c>
		adc_sequence_callback callback = ctx->options.callback;
   4392e:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
		enum adc_action action;
		bool finish = false;
		bool repeat = false;

		if (callback) {
			action = callback(dev,
   43932:	f8b4 2098 	ldrh.w	r2, [r4, #152]	; 0x98
		if (callback) {
   43936:	b133      	cbz	r3, 43946 <saadc_irq_handler+0x3e>
			action = callback(dev,
   43938:	f104 0174 	add.w	r1, r4, #116	; 0x74
   4393c:	4798      	blx	r3
					  ctx->sampling_index);
		} else {
			action = ADC_ACTION_CONTINUE;
		}

		switch (action) {
   4393e:	2801      	cmp	r0, #1
   43940:	d014      	beq.n	4396c <saadc_irq_handler+0x64>
   43942:	2802      	cmp	r0, #2
   43944:	d028      	beq.n	43998 <saadc_irq_handler+0x90>
			break;
		case ADC_ACTION_FINISH:
			finish = true;
			break;
		default: /* ADC_ACTION_CONTINUE */
			if (ctx->sampling_index <
   43946:	f8b4 3098 	ldrh.w	r3, [r4, #152]	; 0x98
   4394a:	f8b4 2094 	ldrh.w	r2, [r4, #148]	; 0x94
   4394e:	429a      	cmp	r2, r3
   43950:	d922      	bls.n	43998 <saadc_irq_handler+0x90>
			    ctx->options.extra_samplings) {
				++ctx->sampling_index;
   43952:	3301      	adds	r3, #1
   43954:	f8a4 3098 	strh.w	r3, [r4, #152]	; 0x98
    return (nrf_saadc_value_t *)p_reg->RESULT.PTR;
   43958:	4b1b      	ldr	r3, [pc, #108]	; (439c8 <saadc_irq_handler+0xc0>)
   4395a:	f8d3 262c 	ldr.w	r2, [r3, #1580]	; 0x62c
    return p_reg->RESULT.AMOUNT;
   4395e:	f8d3 1634 	ldr.w	r1, [r3, #1588]	; 0x634
			nrf_saadc_buffer_pointer_get(NRF_SAADC) +
   43962:	b289      	uxth	r1, r1
		nrf_saadc_buffer_pointer_set(
   43964:	eb02 0241 	add.w	r2, r2, r1, lsl #1
    p_reg->RESULT.PTR = (uint32_t)p_buffer;
   43968:	f8c3 262c 	str.w	r2, [r3, #1580]	; 0x62c
			/*
			 * Immediately start the next sampling if working with
			 * a zero interval or if the timer expired again while
			 * the current sampling was in progress.
			 */
			if (ctx->options.interval_us == 0U) {
   4396c:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
   43970:	b923      	cbnz	r3, 4397c <saadc_irq_handler+0x74>
}
   43972:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
				adc_context_start_sampling(ctx);
   43976:	4815      	ldr	r0, [pc, #84]	; (439cc <saadc_irq_handler+0xc4>)
   43978:	f7ff be6a 	b.w	43650 <adc_context_start_sampling>
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
   4397c:	f3bf 8f5b 	dmb	ish
   43980:	e855 3f00 	ldrex	r3, [r5]
   43984:	1e5a      	subs	r2, r3, #1
   43986:	e845 2100 	strex	r1, r2, [r5]
   4398a:	2900      	cmp	r1, #0
   4398c:	d1f8      	bne.n	43980 <saadc_irq_handler+0x78>
   4398e:	f3bf 8f5b 	dmb	ish
			} else if (atomic_dec(&ctx->sampling_requested) > 1) {
   43992:	2b01      	cmp	r3, #1
   43994:	dced      	bgt.n	43972 <saadc_irq_handler+0x6a>
   43996:	bd38      	pop	{r3, r4, r5, pc}
			}

			return;
		}

		if (ctx->options.interval_us != 0U) {
   43998:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
   4399c:	b113      	cbz	r3, 439a4 <saadc_irq_handler+0x9c>
	z_impl_k_timer_stop(timer);
   4399e:	480c      	ldr	r0, [pc, #48]	; (439d0 <saadc_irq_handler+0xc8>)
   439a0:	f00c fd06 	bl	503b0 <z_impl_k_timer_stop>
	z_impl_k_sem_give(sem);
   439a4:	480b      	ldr	r0, [pc, #44]	; (439d4 <saadc_irq_handler+0xcc>)
   439a6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   439aa:	f003 bbe5 	b.w	47178 <z_impl_k_sem_give>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   439ae:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
	} else if (nrf_saadc_event_check(NRF_SAADC,
   439b2:	2900      	cmp	r1, #0
   439b4:	d0ef      	beq.n	43996 <saadc_irq_handler+0x8e>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   439b6:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
   439ba:	f8d3 2110 	ldr.w	r2, [r3, #272]	; 0x110
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   439be:	2201      	movs	r2, #1
   439c0:	609a      	str	r2, [r3, #8]
   439c2:	601a      	str	r2, [r3, #0]
   439c4:	605a      	str	r2, [r3, #4]
}
   439c6:	e7e6      	b.n	43996 <saadc_irq_handler+0x8e>
   439c8:	40007000 	.word	0x40007000
   439cc:	20000198 	.word	0x20000198
   439d0:	200001a0 	.word	0x200001a0
   439d4:	200001f0 	.word	0x200001f0

000439d8 <onoff_stop>:
}

static clock_control_subsys_t get_subsys(struct onoff_manager *mgr)
{
	struct nrf_clock_control_data *data = CLOCK_DEVICE->data;
	size_t offset = (size_t)(mgr - data->mgr);
   439d8:	4b08      	ldr	r3, [pc, #32]	; (439fc <onoff_stop+0x24>)
	return (clock_control_subsys_t)offset;
}

static void onoff_stop(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
   439da:	b570      	push	{r4, r5, r6, lr}
	size_t offset = (size_t)(mgr - data->mgr);
   439dc:	1ac3      	subs	r3, r0, r3
{
   439de:	460d      	mov	r5, r1
	int res;

	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
   439e0:	4907      	ldr	r1, [pc, #28]	; (43a00 <onoff_stop+0x28>)
	size_t offset = (size_t)(mgr - data->mgr);
   439e2:	109b      	asrs	r3, r3, #2
{
   439e4:	4604      	mov	r4, r0
	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
   439e6:	4359      	muls	r1, r3
   439e8:	4806      	ldr	r0, [pc, #24]	; (43a04 <onoff_stop+0x2c>)
   439ea:	2240      	movs	r2, #64	; 0x40
   439ec:	f00b facf 	bl	4ef8e <stop>
	notify(mgr, res);
   439f0:	462b      	mov	r3, r5
	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
   439f2:	4601      	mov	r1, r0
	notify(mgr, res);
   439f4:	4620      	mov	r0, r4
}
   439f6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	notify(mgr, res);
   439fa:	4718      	bx	r3
   439fc:	20006538 	.word	0x20006538
   43a00:	b6db6db7 	.word	0xb6db6db7
   43a04:	0005082c 	.word	0x0005082c

00043a08 <onoff_start>:
	notify(mgr, 0);
}

static void onoff_start(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
   43a08:	b573      	push	{r0, r1, r4, r5, r6, lr}
	size_t offset = (size_t)(mgr - data->mgr);
   43a0a:	4c0c      	ldr	r4, [pc, #48]	; (43a3c <onoff_start+0x34>)
	int err;

	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
   43a0c:	4a0c      	ldr	r2, [pc, #48]	; (43a40 <onoff_start+0x38>)
   43a0e:	2340      	movs	r3, #64	; 0x40
	size_t offset = (size_t)(mgr - data->mgr);
   43a10:	1b04      	subs	r4, r0, r4
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
   43a12:	9300      	str	r3, [sp, #0]
{
   43a14:	460d      	mov	r5, r1
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
   43a16:	460b      	mov	r3, r1
   43a18:	490a      	ldr	r1, [pc, #40]	; (43a44 <onoff_start+0x3c>)
	size_t offset = (size_t)(mgr - data->mgr);
   43a1a:	10a4      	asrs	r4, r4, #2
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
   43a1c:	4361      	muls	r1, r4
{
   43a1e:	4606      	mov	r6, r0
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
   43a20:	4809      	ldr	r0, [pc, #36]	; (43a48 <onoff_start+0x40>)
   43a22:	f00b fae1 	bl	4efe8 <async_start>
			  onoff_started_callback, notify, CTX_ONOFF);
	if (err < 0) {
   43a26:	1e01      	subs	r1, r0, #0
   43a28:	da05      	bge.n	43a36 <onoff_start+0x2e>
		notify(mgr, err);
   43a2a:	4630      	mov	r0, r6
   43a2c:	462b      	mov	r3, r5
	}
}
   43a2e:	b002      	add	sp, #8
   43a30:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		notify(mgr, err);
   43a34:	4718      	bx	r3
}
   43a36:	b002      	add	sp, #8
   43a38:	bd70      	pop	{r4, r5, r6, pc}
   43a3a:	bf00      	nop
   43a3c:	20006538 	.word	0x20006538
   43a40:	0004f055 	.word	0x0004f055
   43a44:	b6db6db7 	.word	0xb6db6db7
   43a48:	0005082c 	.word	0x0005082c

00043a4c <clk_init>:
	static const struct onoff_transitions transitions = {
		.start = onoff_start,
		.stop = onoff_stop
	};

	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
   43a4c:	2200      	movs	r2, #0
{
   43a4e:	b570      	push	{r4, r5, r6, lr}
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
   43a50:	2101      	movs	r1, #1
{
   43a52:	4604      	mov	r4, r0
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
   43a54:	4610      	mov	r0, r2
   43a56:	f7e9 f9dd 	bl	2ce14 <z_arm_irq_priority_set>
		    nrfx_isr, nrfx_power_clock_irq_handler, 0);

	nrfx_err = nrfx_clock_init(clock_event_handler);
   43a5a:	480f      	ldr	r0, [pc, #60]	; (43a98 <clk_init+0x4c>)
   43a5c:	f001 fa6a 	bl	44f34 <nrfx_clock_init>
	if (nrfx_err != NRFX_SUCCESS) {
   43a60:	4b0e      	ldr	r3, [pc, #56]	; (43a9c <clk_init+0x50>)
   43a62:	4298      	cmp	r0, r3
   43a64:	d115      	bne.n	43a92 <clk_init+0x46>
		struct nrf_clock_control_data *data = dev->data;

		z_nrf_clock_calibration_init(data->mgr);
	}

	nrfx_clock_enable();
   43a66:	f001 fa75 	bl	44f54 <nrfx_clock_enable>
	struct nrf_clock_control_data *data = dev->data;
   43a6a:	6926      	ldr	r6, [r4, #16]
	for (enum clock_control_nrf_type i = 0;
		i < CLOCK_CONTROL_NRF_TYPE_COUNT; i++) {
		struct nrf_clock_control_sub_data *subdata =
						get_sub_data(dev, i);

		err = onoff_manager_init(get_onoff_manager(dev, i),
   43a6c:	490c      	ldr	r1, [pc, #48]	; (43aa0 <clk_init+0x54>)
   43a6e:	4630      	mov	r0, r6
   43a70:	f005 f88d 	bl	48b8e <onoff_manager_init>
					 &transitions);
		if (err < 0) {
   43a74:	2800      	cmp	r0, #0
   43a76:	db0b      	blt.n	43a90 <clk_init+0x44>
			return err;
		}

		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
   43a78:	2501      	movs	r5, #1
   43a7a:	6435      	str	r5, [r6, #64]	; 0x40
	struct nrf_clock_control_data *data = dev->data;
   43a7c:	6924      	ldr	r4, [r4, #16]
		err = onoff_manager_init(get_onoff_manager(dev, i),
   43a7e:	4908      	ldr	r1, [pc, #32]	; (43aa0 <clk_init+0x54>)
   43a80:	f104 001c 	add.w	r0, r4, #28
   43a84:	f005 f883 	bl	48b8e <onoff_manager_init>
		if (err < 0) {
   43a88:	2800      	cmp	r0, #0
   43a8a:	db01      	blt.n	43a90 <clk_init+0x44>
		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
   43a8c:	64e5      	str	r5, [r4, #76]	; 0x4c
	}

	return 0;
   43a8e:	2000      	movs	r0, #0
}
   43a90:	bd70      	pop	{r4, r5, r6, pc}
		return -EIO;
   43a92:	f06f 0004 	mvn.w	r0, #4
   43a96:	e7fb      	b.n	43a90 <clk_init+0x44>
   43a98:	00043ad9 	.word	0x00043ad9
   43a9c:	0bad0000 	.word	0x0bad0000
   43aa0:	00052e98 	.word	0x00052e98

00043aa4 <clkstarted_handle.constprop.0>:
static void clkstarted_handle(const struct device *dev,
   43aa4:	b570      	push	{r4, r5, r6, lr}
   43aa6:	4601      	mov	r1, r0
	clock_control_cb_t callback = sub_data->cb;
   43aa8:	230c      	movs	r3, #12
   43aaa:	4809      	ldr	r0, [pc, #36]	; (43ad0 <clkstarted_handle.constprop.0+0x2c>)
   43aac:	434b      	muls	r3, r1
   43aae:	18c4      	adds	r4, r0, r3
	void *user_data = sub_data->user_data;
   43ab0:	e9d4 560e 	ldrd	r5, r6, [r4, #56]	; 0x38
	sub_data->cb = NULL;
   43ab4:	2200      	movs	r2, #0
	set_on_state(&sub_data->flags);
   43ab6:	3340      	adds	r3, #64	; 0x40
	sub_data->cb = NULL;
   43ab8:	63a2      	str	r2, [r4, #56]	; 0x38
	set_on_state(&sub_data->flags);
   43aba:	4418      	add	r0, r3
   43abc:	f00b fa54 	bl	4ef68 <set_on_state>
	if (callback) {
   43ac0:	b12d      	cbz	r5, 43ace <clkstarted_handle.constprop.0+0x2a>
		callback(dev, (clock_control_subsys_t)type, user_data);
   43ac2:	4632      	mov	r2, r6
   43ac4:	462b      	mov	r3, r5
   43ac6:	4803      	ldr	r0, [pc, #12]	; (43ad4 <clkstarted_handle.constprop.0+0x30>)
}
   43ac8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		callback(dev, (clock_control_subsys_t)type, user_data);
   43acc:	4718      	bx	r3
}
   43ace:	bd70      	pop	{r4, r5, r6, pc}
   43ad0:	20006538 	.word	0x20006538
   43ad4:	0005082c 	.word	0x0005082c

00043ad8 <clock_event_handler>:
	switch (event) {
   43ad8:	b110      	cbz	r0, 43ae0 <clock_event_handler+0x8>
   43ada:	2801      	cmp	r0, #1
   43adc:	d004      	beq.n	43ae8 <clock_event_handler+0x10>
   43ade:	4770      	bx	lr
		if (GET_STATUS(data->flags) == CLOCK_CONTROL_STATUS_STARTING) {
   43ae0:	4b03      	ldr	r3, [pc, #12]	; (43af0 <clock_event_handler+0x18>)
   43ae2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   43ae4:	075b      	lsls	r3, r3, #29
   43ae6:	d101      	bne.n	43aec <clock_event_handler+0x14>
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
   43ae8:	f7ff bfdc 	b.w	43aa4 <clkstarted_handle.constprop.0>
}
   43aec:	4770      	bx	lr
   43aee:	bf00      	nop
   43af0:	20006538 	.word	0x20006538

00043af4 <generic_hfclk_start>:
{
   43af4:	b508      	push	{r3, lr}
	__asm__ volatile(
   43af6:	f04f 0320 	mov.w	r3, #32
   43afa:	f3ef 8111 	mrs	r1, BASEPRI
   43afe:	f383 8812 	msr	BASEPRI_MAX, r3
   43b02:	f3bf 8f6f 	isb	sy
	hfclk_users |= HF_USER_GENERIC;
   43b06:	4a12      	ldr	r2, [pc, #72]	; (43b50 <generic_hfclk_start+0x5c>)
   43b08:	6813      	ldr	r3, [r2, #0]
   43b0a:	f043 0002 	orr.w	r0, r3, #2
   43b0e:	6010      	str	r0, [r2, #0]
	if (hfclk_users & HF_USER_BT) {
   43b10:	07da      	lsls	r2, r3, #31
   43b12:	d408      	bmi.n	43b26 <generic_hfclk_start+0x32>
	__asm__ volatile(
   43b14:	f381 8811 	msr	BASEPRI, r1
   43b18:	f3bf 8f6f 	isb	sy
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_start(void)
{
    nrfx_clock_start(NRF_CLOCK_DOMAIN_HFCLK);
   43b1c:	2001      	movs	r0, #1
}
   43b1e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   43b22:	f00b bbb1 	b.w	4f288 <nrfx_clock_start>
            break;
        case NRF_CLOCK_DOMAIN_HFCLK:
            if (p_clk_src != NULL)
            {
                (*(nrf_clock_hfclk_t *)p_clk_src) =
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
   43b26:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   43b2a:	f8d3 240c 	ldr.w	r2, [r3, #1036]	; 0x40c
                                        >> CLOCK_HFCLKSTAT_SRC_Pos);
            }
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
   43b2e:	f8d3 340c 	ldr.w	r3, [r3, #1036]	; 0x40c
		if (type == NRF_CLOCK_HFCLK_HIGH_ACCURACY) {
   43b32:	07d3      	lsls	r3, r2, #31
   43b34:	d5ee      	bpl.n	43b14 <generic_hfclk_start+0x20>
			set_on_state(get_hf_flags());
   43b36:	4807      	ldr	r0, [pc, #28]	; (43b54 <generic_hfclk_start+0x60>)
   43b38:	f00b fa16 	bl	4ef68 <set_on_state>
   43b3c:	f381 8811 	msr	BASEPRI, r1
   43b40:	f3bf 8f6f 	isb	sy
		clkstarted_handle(CLOCK_DEVICE,
   43b44:	2000      	movs	r0, #0
}
   43b46:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		clkstarted_handle(CLOCK_DEVICE,
   43b4a:	f7ff bfab 	b.w	43aa4 <clkstarted_handle.constprop.0>
   43b4e:	bf00      	nop
   43b50:	20006588 	.word	0x20006588
   43b54:	20006578 	.word	0x20006578

00043b58 <api_blocking_start>:
{
   43b58:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	struct k_sem sem = Z_SEM_INITIALIZER(sem, 0, 1);
   43b5a:	2200      	movs	r2, #0
   43b5c:	2301      	movs	r3, #1
   43b5e:	e9cd 2302 	strd	r2, r3, [sp, #8]
   43b62:	ab04      	add	r3, sp, #16
   43b64:	e9cd 3304 	strd	r3, r3, [sp, #16]
	err = api_start(dev, subsys, blocking_start_callback, &sem);
   43b68:	4a09      	ldr	r2, [pc, #36]	; (43b90 <api_blocking_start+0x38>)
	struct k_sem sem = Z_SEM_INITIALIZER(sem, 0, 1);
   43b6a:	f8cd d000 	str.w	sp, [sp]
	err = api_start(dev, subsys, blocking_start_callback, &sem);
   43b6e:	466b      	mov	r3, sp
	struct k_sem sem = Z_SEM_INITIALIZER(sem, 0, 1);
   43b70:	f8cd d004 	str.w	sp, [sp, #4]
	err = api_start(dev, subsys, blocking_start_callback, &sem);
   43b74:	f00b fa67 	bl	4f046 <api_start>
	if (err < 0) {
   43b78:	2800      	cmp	r0, #0
   43b7a:	db05      	blt.n	43b88 <api_blocking_start+0x30>
	return z_impl_k_sem_take(sem, timeout);
   43b7c:	f44f 4280 	mov.w	r2, #16384	; 0x4000
   43b80:	2300      	movs	r3, #0
   43b82:	4668      	mov	r0, sp
   43b84:	f003 fb1e 	bl	471c4 <z_impl_k_sem_take>
}
   43b88:	b007      	add	sp, #28
   43b8a:	f85d fb04 	ldr.w	pc, [sp], #4
   43b8e:	bf00      	nop
   43b90:	0004f073 	.word	0x0004f073

00043b94 <generic_hfclk_stop>:
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   43b94:	4b09      	ldr	r3, [pc, #36]	; (43bbc <generic_hfclk_stop+0x28>)
   43b96:	f3bf 8f5b 	dmb	ish
   43b9a:	e853 2f00 	ldrex	r2, [r3]
   43b9e:	f022 0102 	bic.w	r1, r2, #2
   43ba2:	e843 1000 	strex	r0, r1, [r3]
   43ba6:	2800      	cmp	r0, #0
   43ba8:	d1f7      	bne.n	43b9a <generic_hfclk_stop+0x6>
   43baa:	f3bf 8f5b 	dmb	ish
	if (atomic_and(&hfclk_users, ~HF_USER_GENERIC) & HF_USER_BT) {
   43bae:	07d3      	lsls	r3, r2, #31
   43bb0:	d402      	bmi.n	43bb8 <generic_hfclk_stop+0x24>
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_stop(void)
{
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_HFCLK);
   43bb2:	2001      	movs	r0, #1
   43bb4:	f00b bba4 	b.w	4f300 <nrfx_clock_stop>
}
   43bb8:	4770      	bx	lr
   43bba:	bf00      	nop
   43bbc:	20006588 	.word	0x20006588

00043bc0 <z_nrf_clock_control_get_onoff>:
}
   43bc0:	4a02      	ldr	r2, [pc, #8]	; (43bcc <z_nrf_clock_control_get_onoff+0xc>)
	return &data->mgr[type];
   43bc2:	b2c3      	uxtb	r3, r0
}
   43bc4:	201c      	movs	r0, #28
   43bc6:	fb03 2000 	mla	r0, r3, r0, r2
   43bca:	4770      	bx	lr
   43bcc:	20006538 	.word	0x20006538

00043bd0 <z_nrf_clock_bt_ctlr_hf_request>:
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   43bd0:	4b09      	ldr	r3, [pc, #36]	; (43bf8 <z_nrf_clock_bt_ctlr_hf_request+0x28>)
   43bd2:	f3bf 8f5b 	dmb	ish
   43bd6:	e853 2f00 	ldrex	r2, [r3]
   43bda:	f042 0101 	orr.w	r1, r2, #1
   43bde:	e843 1000 	strex	r0, r1, [r3]
   43be2:	2800      	cmp	r0, #0
   43be4:	d1f7      	bne.n	43bd6 <z_nrf_clock_bt_ctlr_hf_request+0x6>
   43be6:	f3bf 8f5b 	dmb	ish
	if (atomic_or(&hfclk_users, HF_USER_BT) & HF_USER_GENERIC) {
   43bea:	0793      	lsls	r3, r2, #30
   43bec:	d402      	bmi.n	43bf4 <z_nrf_clock_bt_ctlr_hf_request+0x24>
    nrfx_clock_start(NRF_CLOCK_DOMAIN_HFCLK);
   43bee:	2001      	movs	r0, #1
   43bf0:	f00b bb4a 	b.w	4f288 <nrfx_clock_start>
}
   43bf4:	4770      	bx	lr
   43bf6:	bf00      	nop
   43bf8:	20006588 	.word	0x20006588

00043bfc <z_nrf_clock_bt_ctlr_hf_release>:
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   43bfc:	4b09      	ldr	r3, [pc, #36]	; (43c24 <z_nrf_clock_bt_ctlr_hf_release+0x28>)
   43bfe:	f3bf 8f5b 	dmb	ish
   43c02:	e853 2f00 	ldrex	r2, [r3]
   43c06:	f022 0101 	bic.w	r1, r2, #1
   43c0a:	e843 1000 	strex	r0, r1, [r3]
   43c0e:	2800      	cmp	r0, #0
   43c10:	d1f7      	bne.n	43c02 <z_nrf_clock_bt_ctlr_hf_release+0x6>
   43c12:	f3bf 8f5b 	dmb	ish
	if (atomic_and(&hfclk_users, ~HF_USER_BT) & HF_USER_GENERIC) {
   43c16:	0793      	lsls	r3, r2, #30
   43c18:	d402      	bmi.n	43c20 <z_nrf_clock_bt_ctlr_hf_release+0x24>
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_HFCLK);
   43c1a:	2001      	movs	r0, #1
   43c1c:	f00b bb70 	b.w	4f300 <nrfx_clock_stop>
}
   43c20:	4770      	bx	lr
   43c22:	bf00      	nop
   43c24:	20006588 	.word	0x20006588

00043c28 <z_nrf_clock_control_lf_on>:
{
   43c28:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   43c2c:	4938      	ldr	r1, [pc, #224]	; (43d10 <z_nrf_clock_control_lf_on+0xe8>)
   43c2e:	f3bf 8f5b 	dmb	ish
   43c32:	4607      	mov	r7, r0
   43c34:	2201      	movs	r2, #1
   43c36:	e851 3f00 	ldrex	r3, [r1]
   43c3a:	e841 2000 	strex	r0, r2, [r1]
   43c3e:	2800      	cmp	r0, #0
   43c40:	d1f9      	bne.n	43c36 <z_nrf_clock_control_lf_on+0xe>
   43c42:	f3bf 8f5b 	dmb	ish
	if (atomic_set(&on, 1) == 0) {
   43c46:	b933      	cbnz	r3, 43c56 <z_nrf_clock_control_lf_on+0x2e>
   43c48:	4932      	ldr	r1, [pc, #200]	; (43d14 <z_nrf_clock_control_lf_on+0xec>)
		err = onoff_request(mgr, &cli);
   43c4a:	4833      	ldr	r0, [pc, #204]	; (43d18 <z_nrf_clock_control_lf_on+0xf0>)
   43c4c:	604b      	str	r3, [r1, #4]
   43c4e:	60cb      	str	r3, [r1, #12]
   43c50:	608a      	str	r2, [r1, #8]
   43c52:	f004 ffaf 	bl	48bb4 <onoff_request>
	switch (start_mode) {
   43c56:	1e7b      	subs	r3, r7, #1
   43c58:	2b01      	cmp	r3, #1
   43c5a:	d82b      	bhi.n	43cb4 <z_nrf_clock_control_lf_on+0x8c>
	if ((mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE) &&
   43c5c:	2f01      	cmp	r7, #1
   43c5e:	d107      	bne.n	43c70 <z_nrf_clock_control_lf_on+0x48>
    return clk_src;
}

NRF_STATIC_INLINE nrf_clock_lfclk_t nrf_clock_lf_srccopy_get(NRF_CLOCK_Type const * p_reg)
{
    return (nrf_clock_lfclk_t)((p_reg->LFCLKSRCCOPY & CLOCK_LFCLKSRCCOPY_SRC_Msk)
   43c60:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   43c64:	f8d3 341c 	ldr.w	r3, [r3, #1052]	; 0x41c
   43c68:	f003 0303 	and.w	r3, r3, #3
	    (target_type == NRF_CLOCK_LFCLK_Xtal) &&
   43c6c:	2b01      	cmp	r3, #1
   43c6e:	d021      	beq.n	43cb4 <z_nrf_clock_control_lf_on+0x8c>
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
   43c70:	f00b ffef 	bl	4fc52 <k_is_in_isr>
   43c74:	4605      	mov	r5, r0
   43c76:	b9f8      	cbnz	r0, 43cb8 <z_nrf_clock_control_lf_on+0x90>
	return !z_sys_post_kernel;
   43c78:	4b28      	ldr	r3, [pc, #160]	; (43d1c <z_nrf_clock_control_lf_on+0xf4>)
   43c7a:	781b      	ldrb	r3, [r3, #0]
   43c7c:	b1e3      	cbz	r3, 43cb8 <z_nrf_clock_control_lf_on+0x90>
    p_reg->INTENCLR = mask;
   43c7e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   43c82:	2202      	movs	r2, #2
   43c84:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
	int key = isr_mode ? irq_lock() : 0;
   43c88:	4606      	mov	r6, r0
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   43c8a:	f8df 8094 	ldr.w	r8, [pc, #148]	; 43d20 <z_nrf_clock_control_lf_on+0xf8>
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   43c8e:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
   43c92:	f8d4 3418 	ldr.w	r3, [r4, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   43c96:	f8d4 2418 	ldr.w	r2, [r4, #1048]	; 0x418
   43c9a:	03d2      	lsls	r2, r2, #15
   43c9c:	d516      	bpl.n	43ccc <z_nrf_clock_control_lf_on+0xa4>
                                        >> CLOCK_LFCLKSTAT_SRC_Pos);
   43c9e:	f003 0303 	and.w	r3, r3, #3
	while (!(nrfx_clock_is_running(d, (void *)&type)
   43ca2:	2b01      	cmp	r3, #1
   43ca4:	d001      	beq.n	43caa <z_nrf_clock_control_lf_on+0x82>
		     || (mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE)))) {
   43ca6:	2f01      	cmp	r7, #1
   43ca8:	d110      	bne.n	43ccc <z_nrf_clock_control_lf_on+0xa4>
	if (isr_mode) {
   43caa:	b35d      	cbz	r5, 43d04 <z_nrf_clock_control_lf_on+0xdc>
   43cac:	f386 8811 	msr	BASEPRI, r6
   43cb0:	f3bf 8f6f 	isb	sy
}
   43cb4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	__asm__ volatile(
   43cb8:	f04f 0320 	mov.w	r3, #32
   43cbc:	f3ef 8611 	mrs	r6, BASEPRI
   43cc0:	f383 8812 	msr	BASEPRI_MAX, r3
   43cc4:	f3bf 8f6f 	isb	sy
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
   43cc8:	2501      	movs	r5, #1
   43cca:	e7de      	b.n	43c8a <z_nrf_clock_control_lf_on+0x62>
			if (isr_mode || !IS_ENABLED(CONFIG_MULTITHREADING)) {
   43ccc:	b1ad      	cbz	r5, 43cfa <z_nrf_clock_control_lf_on+0xd2>
 *
 * @param key Interrupt locking key obtained from irq_lock().
 */
static inline void k_cpu_atomic_idle(unsigned int key)
{
	arch_cpu_atomic_idle(key);
   43cce:	4630      	mov	r0, r6
   43cd0:	f7e9 f866 	bl	2cda0 <arch_cpu_atomic_idle>
    return (nrf_clock_lfclk_t)(p_reg->LFCLKSRC);
   43cd4:	f8d4 3518 	ldr.w	r3, [r4, #1304]	; 0x518
		if ((target_type ==  NRF_CLOCK_LFCLK_Xtal)
   43cd8:	2b00      	cmp	r3, #0
   43cda:	d1da      	bne.n	43c92 <z_nrf_clock_control_lf_on+0x6a>
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   43cdc:	f8d4 2104 	ldr.w	r2, [r4, #260]	; 0x104
		    && nrf_clock_event_check(NRF_CLOCK,
   43ce0:	2a00      	cmp	r2, #0
   43ce2:	d0d6      	beq.n	43c92 <z_nrf_clock_control_lf_on+0x6a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   43ce4:	f8c4 3104 	str.w	r3, [r4, #260]	; 0x104
   43ce8:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
    p_reg->LFCLKSRC = (uint32_t)(source);
   43cec:	2301      	movs	r3, #1
   43cee:	f8c4 3518 	str.w	r3, [r4, #1304]	; 0x518
   43cf2:	f8c8 3180 	str.w	r3, [r8, #384]	; 0x180
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   43cf6:	60a3      	str	r3, [r4, #8]
}
   43cf8:	e7cb      	b.n	43c92 <z_nrf_clock_control_lf_on+0x6a>
	return z_impl_k_sleep(timeout);
   43cfa:	2100      	movs	r1, #0
   43cfc:	2021      	movs	r0, #33	; 0x21
   43cfe:	f003 ff47 	bl	47b90 <z_impl_k_sleep>
	return k_sleep(Z_TIMEOUT_MS(ms));
   43d02:	e7e7      	b.n	43cd4 <z_nrf_clock_control_lf_on+0xac>
    p_reg->INTENSET = mask;
   43d04:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   43d08:	2202      	movs	r2, #2
   43d0a:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
   43d0e:	e7d1      	b.n	43cb4 <z_nrf_clock_control_lf_on+0x8c>
   43d10:	20006534 	.word	0x20006534
   43d14:	20006524 	.word	0x20006524
   43d18:	20006554 	.word	0x20006554
   43d1c:	20006bc4 	.word	0x20006bc4
   43d20:	e000e100 	.word	0xe000e100

00043d24 <gpio_nrfx_pin_interrupt_configure>:

static int gpio_nrfx_pin_interrupt_configure(const struct device *port,
					     gpio_pin_t pin,
					     enum gpio_int_mode mode,
					     enum gpio_int_trig trig)
{
   43d24:	b530      	push	{r4, r5, lr}
	return port->config;
   43d26:	6840      	ldr	r0, [r0, #4]
	uint32_t abs_pin = NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin);
   43d28:	7b05      	ldrb	r5, [r0, #12]
   43d2a:	f001 041f 	and.w	r4, r1, #31
	nrfx_err_t err;
	uint8_t ch;

	if (mode == GPIO_INT_MODE_DISABLED) {
   43d2e:	f5b2 1f00 	cmp.w	r2, #2097152	; 0x200000
{
   43d32:	b085      	sub	sp, #20
	uint32_t abs_pin = NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin);
   43d34:	ea44 1445 	orr.w	r4, r4, r5, lsl #5
	if (mode == GPIO_INT_MODE_DISABLED) {
   43d38:	d105      	bne.n	43d46 <gpio_nrfx_pin_interrupt_configure+0x22>
		nrfx_gpiote_trigger_disable(abs_pin);
   43d3a:	4620      	mov	r0, r4
   43d3c:	f001 fb8e 	bl	4545c <nrfx_gpiote_trigger_disable>

		return 0;
   43d40:	2000      	movs	r0, #0
	}

	nrfx_gpiote_trigger_enable(abs_pin, true);

	return 0;
}
   43d42:	b005      	add	sp, #20
   43d44:	bd30      	pop	{r4, r5, pc}
	nrfx_gpiote_trigger_config_t trigger_config = {
   43d46:	2500      	movs	r5, #0
	if (mode == GPIO_INT_MODE_LEVEL) {
   43d48:	f5b2 0f80 	cmp.w	r2, #4194304	; 0x400000
	nrfx_gpiote_trigger_config_t trigger_config = {
   43d4c:	e9cd 5502 	strd	r5, r5, [sp, #8]
	if (mode == GPIO_INT_MODE_LEVEL) {
   43d50:	d114      	bne.n	43d7c <gpio_nrfx_pin_interrupt_configure+0x58>
		return trig == GPIO_INT_TRIG_LOW ? NRFX_GPIOTE_TRIGGER_LOW :
   43d52:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
	nrfx_gpiote_trigger_config_t trigger_config = {
   43d56:	bf0c      	ite	eq
   43d58:	2304      	moveq	r3, #4
   43d5a:	2305      	movne	r3, #5
   43d5c:	f88d 3008 	strb.w	r3, [sp, #8]
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
   43d60:	2300      	movs	r3, #0
   43d62:	4619      	mov	r1, r3
   43d64:	aa02      	add	r2, sp, #8
   43d66:	4620      	mov	r0, r4
   43d68:	f001 f9b6 	bl	450d8 <nrfx_gpiote_input_configure>
	if (err != NRFX_SUCCESS) {
   43d6c:	4b1f      	ldr	r3, [pc, #124]	; (43dec <gpio_nrfx_pin_interrupt_configure+0xc8>)
   43d6e:	4298      	cmp	r0, r3
   43d70:	d139      	bne.n	43de6 <gpio_nrfx_pin_interrupt_configure+0xc2>
	nrfx_gpiote_trigger_enable(abs_pin, true);
   43d72:	2101      	movs	r1, #1
   43d74:	4620      	mov	r0, r4
   43d76:	f001 fb29 	bl	453cc <nrfx_gpiote_trigger_enable>
	return 0;
   43d7a:	e7e1      	b.n	43d40 <gpio_nrfx_pin_interrupt_configure+0x1c>
	return trig == GPIO_INT_TRIG_BOTH ? NRFX_GPIOTE_TRIGGER_TOGGLE :
   43d7c:	f1b3 6fc0 	cmp.w	r3, #100663296	; 0x6000000
   43d80:	d026      	beq.n	43dd0 <gpio_nrfx_pin_interrupt_configure+0xac>
   43d82:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
   43d86:	bf14      	ite	ne
   43d88:	2301      	movne	r3, #1
   43d8a:	2302      	moveq	r3, #2
	nrfx_gpiote_trigger_config_t trigger_config = {
   43d8c:	f88d 3008 	strb.w	r3, [sp, #8]
	if (!(BIT(pin) & get_port_cfg(port)->edge_sense) &&
   43d90:	6883      	ldr	r3, [r0, #8]
   43d92:	40cb      	lsrs	r3, r1
   43d94:	07d9      	lsls	r1, r3, #31
   43d96:	d4e3      	bmi.n	43d60 <gpio_nrfx_pin_interrupt_configure+0x3c>
   43d98:	f1b2 7fa0 	cmp.w	r2, #20971520	; 0x1400000
   43d9c:	d1e0      	bne.n	43d60 <gpio_nrfx_pin_interrupt_configure+0x3c>
NRF_STATIC_INLINE uint32_t nrf_gpio_pin_port_number_extract(uint32_t * p_pin)
{
    uint32_t pin_number = *p_pin;
    *p_pin = pin_number & 0x1F;

    return pin_number >> 5;
   43d9e:	0962      	lsrs	r2, r4, #5
        case 1: return NRF_P1;
   43da0:	2a01      	cmp	r2, #1
    *p_pin = pin_number & 0x1F;
   43da2:	f004 031f 	and.w	r3, r4, #31
        case 1: return NRF_P1;
   43da6:	4a12      	ldr	r2, [pc, #72]	; (43df0 <gpio_nrfx_pin_interrupt_configure+0xcc>)
    return (nrf_gpio_pin_dir_t)((reg->PIN_CNF[pin_number] &
   43da8:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
        case 1: return NRF_P1;
   43dac:	bf18      	it	ne
   43dae:	f04f 42a0 	movne.w	r2, #1342177280	; 0x50000000
    return (nrf_gpio_pin_dir_t)((reg->PIN_CNF[pin_number] &
   43db2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
	    (mode == GPIO_INT_MODE_EDGE) &&
   43db6:	07db      	lsls	r3, r3, #31
   43db8:	d4d2      	bmi.n	43d60 <gpio_nrfx_pin_interrupt_configure+0x3c>
		err = nrfx_gpiote_channel_get(abs_pin, &ch);
   43dba:	f10d 0507 	add.w	r5, sp, #7
   43dbe:	4629      	mov	r1, r5
   43dc0:	4620      	mov	r0, r4
   43dc2:	f001 faaf 	bl	45324 <nrfx_gpiote_channel_get>
		if (err == NRFX_ERROR_INVALID_PARAM) {
   43dc6:	4b0b      	ldr	r3, [pc, #44]	; (43df4 <gpio_nrfx_pin_interrupt_configure+0xd0>)
   43dc8:	4298      	cmp	r0, r3
   43dca:	d003      	beq.n	43dd4 <gpio_nrfx_pin_interrupt_configure+0xb0>
		trigger_config.p_in_channel = &ch;
   43dcc:	9503      	str	r5, [sp, #12]
   43dce:	e7c7      	b.n	43d60 <gpio_nrfx_pin_interrupt_configure+0x3c>
	return trig == GPIO_INT_TRIG_BOTH ? NRFX_GPIOTE_TRIGGER_TOGGLE :
   43dd0:	2303      	movs	r3, #3
   43dd2:	e7db      	b.n	43d8c <gpio_nrfx_pin_interrupt_configure+0x68>
			err = nrfx_gpiote_channel_alloc(&ch);
   43dd4:	4628      	mov	r0, r5
   43dd6:	f001 faf3 	bl	453c0 <nrfx_gpiote_channel_alloc>
			if (err != NRFX_SUCCESS) {
   43dda:	4b04      	ldr	r3, [pc, #16]	; (43dec <gpio_nrfx_pin_interrupt_configure+0xc8>)
   43ddc:	4298      	cmp	r0, r3
   43dde:	d0f5      	beq.n	43dcc <gpio_nrfx_pin_interrupt_configure+0xa8>
				return -ENOMEM;
   43de0:	f06f 000b 	mvn.w	r0, #11
   43de4:	e7ad      	b.n	43d42 <gpio_nrfx_pin_interrupt_configure+0x1e>
		return -EINVAL;
   43de6:	f06f 0015 	mvn.w	r0, #21
   43dea:	e7aa      	b.n	43d42 <gpio_nrfx_pin_interrupt_configure+0x1e>
   43dec:	0bad0000 	.word	0x0bad0000
   43df0:	50000300 	.word	0x50000300
   43df4:	0bad0004 	.word	0x0bad0004

00043df8 <gpio_nrfx_init>:
}

#define GPIOTE_NODE DT_INST(0, nordic_nrf_gpiote)

static int gpio_nrfx_init(const struct device *port)
{
   43df8:	b510      	push	{r4, lr}
	nrfx_err_t err;

	if (nrfx_gpiote_is_init()) {
   43dfa:	f001 fad1 	bl	453a0 <nrfx_gpiote_is_init>
   43dfe:	4604      	mov	r4, r0
   43e00:	b968      	cbnz	r0, 43e1e <gpio_nrfx_init+0x26>
		return 0;
	}

	err = nrfx_gpiote_init(0/*not used*/);
   43e02:	f001 faa5 	bl	45350 <nrfx_gpiote_init>
	if (err != NRFX_SUCCESS) {
   43e06:	4b08      	ldr	r3, [pc, #32]	; (43e28 <gpio_nrfx_init+0x30>)
   43e08:	4298      	cmp	r0, r3
   43e0a:	d10a      	bne.n	43e22 <gpio_nrfx_init+0x2a>
		return -EIO;
	}

	nrfx_gpiote_global_callback_set(nrfx_gpio_handler, NULL);
   43e0c:	4807      	ldr	r0, [pc, #28]	; (43e2c <gpio_nrfx_init+0x34>)
   43e0e:	4621      	mov	r1, r4
   43e10:	f001 fa82 	bl	45318 <nrfx_gpiote_global_callback_set>

	IRQ_CONNECT(DT_IRQN(GPIOTE_NODE), DT_IRQ(GPIOTE_NODE, priority),
   43e14:	4622      	mov	r2, r4
   43e16:	2105      	movs	r1, #5
   43e18:	2006      	movs	r0, #6
   43e1a:	f7e8 fffb 	bl	2ce14 <z_arm_irq_priority_set>
		return 0;
   43e1e:	2000      	movs	r0, #0
		    nrfx_isr, nrfx_gpiote_irq_handler, 0);

	return 0;
}
   43e20:	bd10      	pop	{r4, pc}
		return -EIO;
   43e22:	f06f 0004 	mvn.w	r0, #4
   43e26:	e7fb      	b.n	43e20 <gpio_nrfx_init+0x28>
   43e28:	0bad0000 	.word	0x0bad0000
   43e2c:	00043e31 	.word	0x00043e31

00043e30 <nrfx_gpio_handler>:
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
   43e30:	0942      	lsrs	r2, r0, #5
{
   43e32:	b570      	push	{r4, r5, r6, lr}
   43e34:	4603      	mov	r3, r0
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
   43e36:	d002      	beq.n	43e3e <nrfx_gpio_handler+0xe>
   43e38:	2a01      	cmp	r2, #1
   43e3a:	d017      	beq.n	43e6c <nrfx_gpio_handler+0x3c>
}
   43e3c:	bd70      	pop	{r4, r5, r6, pc}
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
   43e3e:	4e0d      	ldr	r6, [pc, #52]	; (43e74 <nrfx_gpio_handler+0x44>)
	gpio_fire_callbacks(list, port, BIT(pin));
   43e40:	6932      	ldr	r2, [r6, #16]
   43e42:	6851      	ldr	r1, [r2, #4]
					const struct device *port,
					uint32_t pins)
{
	struct gpio_callback *cb, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   43e44:	2900      	cmp	r1, #0
   43e46:	d0f9      	beq.n	43e3c <nrfx_gpio_handler+0xc>
    *p_pin = pin_number & 0x1F;
   43e48:	f003 031f 	and.w	r3, r3, #31
   43e4c:	2501      	movs	r5, #1
	return node->next;
   43e4e:	680c      	ldr	r4, [r1, #0]
   43e50:	409d      	lsls	r5, r3
   43e52:	2900      	cmp	r1, #0
   43e54:	d0f2      	beq.n	43e3c <nrfx_gpio_handler+0xc>
		if (cb->pin_mask & pins) {
   43e56:	688a      	ldr	r2, [r1, #8]
   43e58:	402a      	ands	r2, r5
   43e5a:	d002      	beq.n	43e62 <nrfx_gpio_handler+0x32>
			__ASSERT(cb->handler, "No callback handler!");
			cb->handler(port, cb, cb->pin_mask & pins);
   43e5c:	684b      	ldr	r3, [r1, #4]
   43e5e:	4630      	mov	r0, r6
   43e60:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   43e62:	b12c      	cbz	r4, 43e70 <nrfx_gpio_handler+0x40>
   43e64:	6823      	ldr	r3, [r4, #0]
   43e66:	4621      	mov	r1, r4
   43e68:	461c      	mov	r4, r3
   43e6a:	e7f2      	b.n	43e52 <nrfx_gpio_handler+0x22>
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
   43e6c:	4e02      	ldr	r6, [pc, #8]	; (43e78 <nrfx_gpio_handler+0x48>)
   43e6e:	e7e7      	b.n	43e40 <nrfx_gpio_handler+0x10>
   43e70:	4623      	mov	r3, r4
   43e72:	e7f8      	b.n	43e66 <nrfx_gpio_handler+0x36>
   43e74:	0005085c 	.word	0x0005085c
   43e78:	00050844 	.word	0x00050844

00043e7c <gpio_nrfx_pin_configure>:
{
   43e7c:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	return port->config;
   43e80:	6847      	ldr	r7, [r0, #4]
	nrfx_gpiote_pin_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   43e82:	7b3b      	ldrb	r3, [r7, #12]
   43e84:	f001 051f 	and.w	r5, r1, #31
   43e88:	ea45 1543 	orr.w	r5, r5, r3, lsl #5
{
   43e8c:	460e      	mov	r6, r1
	err = nrfx_gpiote_channel_get(abs_pin, &ch);
   43e8e:	4628      	mov	r0, r5
   43e90:	f10d 0103 	add.w	r1, sp, #3
{
   43e94:	4614      	mov	r4, r2
	err = nrfx_gpiote_channel_get(abs_pin, &ch);
   43e96:	f001 fa45 	bl	45324 <nrfx_gpiote_channel_get>
	if ((flags & (GPIO_INPUT | GPIO_OUTPUT)) == GPIO_DISCONNECTED) {
   43e9a:	f414 3f40 	tst.w	r4, #196608	; 0x30000
	err = nrfx_gpiote_channel_get(abs_pin, &ch);
   43e9e:	4680      	mov	r8, r0
	if ((flags & (GPIO_INPUT | GPIO_OUTPUT)) == GPIO_DISCONNECTED) {
   43ea0:	d10b      	bne.n	43eba <gpio_nrfx_pin_configure+0x3e>
		(void)nrfx_gpiote_pin_uninit(abs_pin);
   43ea2:	4628      	mov	r0, r5
   43ea4:	f001 fb02 	bl	454ac <nrfx_gpiote_pin_uninit>
		if (free_ch) {
   43ea8:	4b3d      	ldr	r3, [pc, #244]	; (43fa0 <gpio_nrfx_pin_configure+0x124>)
   43eaa:	4598      	cmp	r8, r3
   43eac:	d103      	bne.n	43eb6 <gpio_nrfx_pin_configure+0x3a>
			err = nrfx_gpiote_channel_free(ch);
   43eae:	f89d 0003 	ldrb.w	r0, [sp, #3]
   43eb2:	f001 fa7f 	bl	453b4 <nrfx_gpiote_channel_free>
		return 0;
   43eb6:	2000      	movs	r0, #0
   43eb8:	e00c      	b.n	43ed4 <gpio_nrfx_pin_configure+0x58>
	nrfx_gpiote_trigger_config_t trigger_config = {
   43eba:	2300      	movs	r3, #0
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
   43ebc:	4619      	mov	r1, r3
   43ebe:	aa02      	add	r2, sp, #8
   43ec0:	4628      	mov	r0, r5
	nrfx_gpiote_trigger_config_t trigger_config = {
   43ec2:	e9cd 3302 	strd	r3, r3, [sp, #8]
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
   43ec6:	f001 f907 	bl	450d8 <nrfx_gpiote_input_configure>
	if (err != NRFX_SUCCESS) {
   43eca:	4b35      	ldr	r3, [pc, #212]	; (43fa0 <gpio_nrfx_pin_configure+0x124>)
   43ecc:	4298      	cmp	r0, r3
   43ece:	d004      	beq.n	43eda <gpio_nrfx_pin_configure+0x5e>
		return NRF_GPIO_PIN_PULLUP;
   43ed0:	f06f 0015 	mvn.w	r0, #21
}
   43ed4:	b004      	add	sp, #16
   43ed6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (free_ch) {
   43eda:	4580      	cmp	r8, r0
   43edc:	d103      	bne.n	43ee6 <gpio_nrfx_pin_configure+0x6a>
		err = nrfx_gpiote_channel_free(ch);
   43ede:	f89d 0003 	ldrb.w	r0, [sp, #3]
   43ee2:	f001 fa67 	bl	453b4 <nrfx_gpiote_channel_free>
	if (flags & GPIO_OUTPUT) {
   43ee6:	03a3      	lsls	r3, r4, #14
   43ee8:	d54b      	bpl.n	43f82 <gpio_nrfx_pin_configure+0x106>
	switch (flags & (NRF_GPIO_DRIVE_MSK | GPIO_OPEN_DRAIN)) {
   43eea:	f240 3306 	movw	r3, #774	; 0x306
   43eee:	4023      	ands	r3, r4
   43ef0:	f5b3 7f83 	cmp.w	r3, #262	; 0x106
   43ef4:	d019      	beq.n	43f2a <gpio_nrfx_pin_configure+0xae>
   43ef6:	d80c      	bhi.n	43f12 <gpio_nrfx_pin_configure+0x96>
   43ef8:	2b06      	cmp	r3, #6
   43efa:	d017      	beq.n	43f2c <gpio_nrfx_pin_configure+0xb0>
   43efc:	d804      	bhi.n	43f08 <gpio_nrfx_pin_configure+0x8c>
   43efe:	b1ab      	cbz	r3, 43f2c <gpio_nrfx_pin_configure+0xb0>
   43f00:	2b02      	cmp	r3, #2
   43f02:	d1e5      	bne.n	43ed0 <gpio_nrfx_pin_configure+0x54>
		*drive = NRF_GPIO_PIN_D0S1;
   43f04:	2304      	movs	r3, #4
   43f06:	e011      	b.n	43f2c <gpio_nrfx_pin_configure+0xb0>
	switch (flags & (NRF_GPIO_DRIVE_MSK | GPIO_OPEN_DRAIN)) {
   43f08:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
   43f0c:	d1e0      	bne.n	43ed0 <gpio_nrfx_pin_configure+0x54>
		*drive = NRF_GPIO_PIN_H0S1;
   43f0e:	2301      	movs	r3, #1
   43f10:	e00c      	b.n	43f2c <gpio_nrfx_pin_configure+0xb0>
	switch (flags & (NRF_GPIO_DRIVE_MSK | GPIO_OPEN_DRAIN)) {
   43f12:	f240 2202 	movw	r2, #514	; 0x202
   43f16:	4293      	cmp	r3, r2
   43f18:	d027      	beq.n	43f6a <gpio_nrfx_pin_configure+0xee>
   43f1a:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
   43f1e:	d026      	beq.n	43f6e <gpio_nrfx_pin_configure+0xf2>
   43f20:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   43f24:	d1d4      	bne.n	43ed0 <gpio_nrfx_pin_configure+0x54>
		*drive = NRF_GPIO_PIN_S0H1;
   43f26:	2302      	movs	r3, #2
   43f28:	e000      	b.n	43f2c <gpio_nrfx_pin_configure+0xb0>
		*drive = NRF_GPIO_PIN_H0D1;
   43f2a:	2307      	movs	r3, #7
		nrfx_gpiote_output_config_t output_config = {
   43f2c:	f88d 3004 	strb.w	r3, [sp, #4]
				NRF_GPIO_PIN_INPUT_CONNECT :
   43f30:	f484 3380 	eor.w	r3, r4, #65536	; 0x10000
   43f34:	f3c3 4300 	ubfx	r3, r3, #16, #1
	if (flags & GPIO_PULL_UP) {
   43f38:	06e0      	lsls	r0, r4, #27
		nrfx_gpiote_output_config_t output_config = {
   43f3a:	f88d 3005 	strb.w	r3, [sp, #5]
	} else if (flags & GPIO_PULL_DOWN) {
   43f3e:	bf54      	ite	pl
   43f40:	f3c4 1340 	ubfxpl	r3, r4, #5, #1
		return NRF_GPIO_PIN_PULLUP;
   43f44:	2303      	movmi	r3, #3
		if (flags & GPIO_OUTPUT_INIT_HIGH) {
   43f46:	0321      	lsls	r1, r4, #12
		nrfx_gpiote_output_config_t output_config = {
   43f48:	f88d 3006 	strb.w	r3, [sp, #6]
		if (flags & GPIO_OUTPUT_INIT_HIGH) {
   43f4c:	d511      	bpl.n	43f72 <gpio_nrfx_pin_configure+0xf6>
			nrf_gpio_port_out_set(cfg->port, BIT(pin));
   43f4e:	687a      	ldr	r2, [r7, #4]
   43f50:	2301      	movs	r3, #1
   43f52:	40b3      	lsls	r3, r6
    p_reg->OUTSET = set_mask;
   43f54:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
		err = nrfx_gpiote_output_configure(abs_pin, &output_config, NULL);
   43f58:	2200      	movs	r2, #0
   43f5a:	a901      	add	r1, sp, #4
   43f5c:	4628      	mov	r0, r5
   43f5e:	f001 f969 	bl	45234 <nrfx_gpiote_output_configure>
	return (err != NRFX_SUCCESS) ? -EINVAL : 0;
   43f62:	4b0f      	ldr	r3, [pc, #60]	; (43fa0 <gpio_nrfx_pin_configure+0x124>)
   43f64:	4298      	cmp	r0, r3
   43f66:	d0a6      	beq.n	43eb6 <gpio_nrfx_pin_configure+0x3a>
   43f68:	e7b2      	b.n	43ed0 <gpio_nrfx_pin_configure+0x54>
		*drive = NRF_GPIO_PIN_D0H1;
   43f6a:	2305      	movs	r3, #5
   43f6c:	e7de      	b.n	43f2c <gpio_nrfx_pin_configure+0xb0>
	switch (flags & (NRF_GPIO_DRIVE_MSK | GPIO_OPEN_DRAIN)) {
   43f6e:	2303      	movs	r3, #3
   43f70:	e7dc      	b.n	43f2c <gpio_nrfx_pin_configure+0xb0>
		} else if (flags & GPIO_OUTPUT_INIT_LOW) {
   43f72:	0362      	lsls	r2, r4, #13
			nrf_gpio_port_out_clear(cfg->port, BIT(pin));
   43f74:	bf41      	itttt	mi
   43f76:	2301      	movmi	r3, #1
   43f78:	687a      	ldrmi	r2, [r7, #4]
   43f7a:	40b3      	lslmi	r3, r6
    p_reg->OUTCLR = clr_mask;
   43f7c:	f8c2 350c 	strmi.w	r3, [r2, #1292]	; 0x50c
}
   43f80:	e7ea      	b.n	43f58 <gpio_nrfx_pin_configure+0xdc>
	if (flags & GPIO_PULL_UP) {
   43f82:	06e3      	lsls	r3, r4, #27
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
   43f84:	f04f 0300 	mov.w	r3, #0
	} else if (flags & GPIO_PULL_DOWN) {
   43f88:	bf54      	ite	pl
   43f8a:	f3c4 1440 	ubfxpl	r4, r4, #5, #1
		return NRF_GPIO_PIN_PULLUP;
   43f8e:	2403      	movmi	r4, #3
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
   43f90:	461a      	mov	r2, r3
   43f92:	a901      	add	r1, sp, #4
   43f94:	4628      	mov	r0, r5
	nrfx_gpiote_input_config_t input_config = {
   43f96:	f88d 4004 	strb.w	r4, [sp, #4]
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
   43f9a:	f001 f89d 	bl	450d8 <nrfx_gpiote_input_configure>
   43f9e:	e7e0      	b.n	43f62 <gpio_nrfx_pin_configure+0xe6>
   43fa0:	0bad0000 	.word	0x0bad0000

00043fa4 <hfclk_on_callback>:
    return (uint32_t)((uint8_t *)p_reg + (uint32_t)task);
}

NRF_STATIC_INLINE void nrf_temp_task_trigger(NRF_TEMP_Type * p_reg, nrf_temp_task_t task)
{
    *(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task) = 1;
   43fa4:	4b01      	ldr	r3, [pc, #4]	; (43fac <hfclk_on_callback+0x8>)
   43fa6:	2201      	movs	r2, #1
   43fa8:	601a      	str	r2, [r3, #0]
			      struct onoff_client *cli,
			      uint32_t state,
			      int res)
{
	nrf_temp_task_trigger(NRF_TEMP, NRF_TEMP_TASK_START);
}
   43faa:	4770      	bx	lr
   43fac:	4000c000 	.word	0x4000c000

00043fb0 <temp_nrf5_channel_get>:
{
	struct temp_nrf5_data *data = dev->data;
	int32_t uval;


	if (chan != SENSOR_CHAN_DIE_TEMP) {
   43fb0:	290c      	cmp	r1, #12
	struct temp_nrf5_data *data = dev->data;
   43fb2:	6903      	ldr	r3, [r0, #16]
	if (chan != SENSOR_CHAN_DIE_TEMP) {
   43fb4:	d10b      	bne.n	43fce <temp_nrf5_channel_get+0x1e>
		return -ENOTSUP;
	}

	uval = data->sample * TEMP_NRF5_TEMP_SCALE;
   43fb6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   43fb8:	4906      	ldr	r1, [pc, #24]	; (43fd4 <temp_nrf5_channel_get+0x24>)
	val->val1 = uval / 1000000;
   43fba:	4807      	ldr	r0, [pc, #28]	; (43fd8 <temp_nrf5_channel_get+0x28>)
	uval = data->sample * TEMP_NRF5_TEMP_SCALE;
   43fbc:	434b      	muls	r3, r1
	val->val1 = uval / 1000000;
   43fbe:	fb93 f1f0 	sdiv	r1, r3, r0
	val->val2 = uval % 1000000;
   43fc2:	fb00 3311 	mls	r3, r0, r1, r3
	val->val1 = uval / 1000000;
   43fc6:	6011      	str	r1, [r2, #0]
	val->val2 = uval % 1000000;
   43fc8:	6053      	str	r3, [r2, #4]

	LOG_DBG("Temperature:%d,%d", val->val1, val->val2);

	return 0;
   43fca:	2000      	movs	r0, #0
   43fcc:	4770      	bx	lr
		return -ENOTSUP;
   43fce:	f06f 0085 	mvn.w	r0, #133	; 0x85
}
   43fd2:	4770      	bx	lr
   43fd4:	0003d090 	.word	0x0003d090
   43fd8:	000f4240 	.word	0x000f4240

00043fdc <temp_nrf5_isr>:
    return (uint32_t)((uint8_t *)p_reg + (uint32_t)event);
}

NRF_STATIC_INLINE void nrf_temp_event_clear(NRF_TEMP_Type * p_reg, nrf_temp_event_t event)
{
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   43fdc:	4b04      	ldr	r3, [pc, #16]	; (43ff0 <temp_nrf5_isr+0x14>)

static void temp_nrf5_isr(void *arg)
{
	const struct device *dev = (const struct device *)arg;
	struct temp_nrf5_data *data = dev->data;
   43fde:	6900      	ldr	r0, [r0, #16]
   43fe0:	2200      	movs	r2, #0
   43fe2:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
   43fe6:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
	z_impl_k_sem_give(sem);
   43fea:	f003 b8c5 	b.w	47178 <z_impl_k_sem_give>
   43fee:	bf00      	nop
   43ff0:	4000c000 	.word	0x4000c000

00043ff4 <temp_nrf5_sample_fetch>:
{
   43ff4:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	struct temp_nrf5_data *data = dev->data;
   43ff6:	6905      	ldr	r5, [r0, #16]
	if (data->clk_mgr == NULL) {
   43ff8:	6b2b      	ldr	r3, [r5, #48]	; 0x30
   43ffa:	b363      	cbz	r3, 44056 <temp_nrf5_sample_fetch+0x62>
	if (chan != SENSOR_CHAN_ALL && chan != SENSOR_CHAN_DIE_TEMP) {
   43ffc:	2939      	cmp	r1, #57	; 0x39
   43ffe:	d001      	beq.n	44004 <temp_nrf5_sample_fetch+0x10>
   44000:	290c      	cmp	r1, #12
   44002:	d12b      	bne.n	4405c <temp_nrf5_sample_fetch+0x68>
	k_mutex_lock(&data->mutex, K_FOREVER);
   44004:	f105 0618 	add.w	r6, r5, #24
	return z_impl_k_mutex_lock(mutex, timeout);
   44008:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   4400c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   44010:	4630      	mov	r0, r6
   44012:	f002 ffc7 	bl	46fa4 <z_impl_k_mutex_lock>
	*notify = (struct sys_notify){
   44016:	4b13      	ldr	r3, [pc, #76]	; (44064 <temp_nrf5_sample_fetch+0x70>)
   44018:	9301      	str	r3, [sp, #4]
	r = onoff_request(data->clk_mgr, &cli);
   4401a:	6b28      	ldr	r0, [r5, #48]	; 0x30
   4401c:	2303      	movs	r3, #3
   4401e:	2400      	movs	r4, #0
   44020:	4669      	mov	r1, sp
   44022:	9403      	str	r4, [sp, #12]
   44024:	9302      	str	r3, [sp, #8]
   44026:	f004 fdc5 	bl	48bb4 <onoff_request>
	return z_impl_k_sem_take(sem, timeout);
   4402a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   4402e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   44032:	4628      	mov	r0, r5
   44034:	f003 f8c6 	bl	471c4 <z_impl_k_sem_take>
	r = onoff_release(data->clk_mgr);
   44038:	6b28      	ldr	r0, [r5, #48]	; 0x30
   4403a:	f004 fe13 	bl	48c64 <onoff_release>
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
}

NRF_STATIC_INLINE int32_t nrf_temp_result_get(NRF_TEMP_Type const * p_reg)
{
    int32_t raw_measurement = p_reg->TEMP;
   4403e:	4b0a      	ldr	r3, [pc, #40]	; (44068 <temp_nrf5_sample_fetch+0x74>)
   44040:	f8d3 2508 	ldr.w	r2, [r3, #1288]	; 0x508
	data->sample = nrf_temp_result_get(NRF_TEMP);
   44044:	62ea      	str	r2, [r5, #44]	; 0x2c
    *(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task) = 1;
   44046:	2201      	movs	r2, #1
   44048:	605a      	str	r2, [r3, #4]
	return z_impl_k_mutex_unlock(mutex);
   4404a:	4630      	mov	r0, r6
   4404c:	f003 f824 	bl	47098 <z_impl_k_mutex_unlock>
	return 0;
   44050:	4620      	mov	r0, r4
}
   44052:	b004      	add	sp, #16
   44054:	bd70      	pop	{r4, r5, r6, pc}
		return -EAGAIN;
   44056:	f06f 000a 	mvn.w	r0, #10
   4405a:	e7fa      	b.n	44052 <temp_nrf5_sample_fetch+0x5e>
		return -ENOTSUP;
   4405c:	f06f 0085 	mvn.w	r0, #133	; 0x85
   44060:	e7f7      	b.n	44052 <temp_nrf5_sample_fetch+0x5e>
   44062:	bf00      	nop
   44064:	00043fa5 	.word	0x00043fa5
   44068:	4000c000 	.word	0x4000c000

0004406c <temp_nrf5_init>:
	.sample_fetch = temp_nrf5_sample_fetch,
	.channel_get = temp_nrf5_channel_get,
};

static int temp_nrf5_init(const struct device *dev)
{
   4406c:	b510      	push	{r4, lr}
	struct temp_nrf5_data *data = dev->data;
   4406e:	6904      	ldr	r4, [r0, #16]

	/* A null clk_mgr indicates sensor has not been initialized */
	data->clk_mgr =
		z_nrf_clock_control_get_onoff(CLOCK_CONTROL_NRF_SUBSYS_HF);
   44070:	2000      	movs	r0, #0
   44072:	f7ff fda5 	bl	43bc0 <z_nrf_clock_control_get_onoff>
	data->clk_mgr =
   44076:	6320      	str	r0, [r4, #48]	; 0x30
	return z_impl_k_sem_init(sem, initial_count, limit);
   44078:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   4407c:	2100      	movs	r1, #0
   4407e:	4620      	mov	r0, r4
   44080:	f00b fefa 	bl	4fe78 <z_impl_k_sem_init>
	return z_impl_k_mutex_init(mutex);
   44084:	f104 0018 	add.w	r0, r4, #24
   44088:	f00b fdfd 	bl	4fc86 <z_impl_k_mutex_init>
	__ASSERT_NO_MSG(data->clk_mgr);

	k_sem_init(&data->device_sync_sem, 0, K_SEM_MAX_LIMIT);
	k_mutex_init(&data->mutex);

	IRQ_CONNECT(
   4408c:	2200      	movs	r2, #0
   4408e:	2101      	movs	r1, #1
   44090:	200c      	movs	r0, #12
   44092:	f7e8 febf 	bl	2ce14 <z_arm_irq_priority_set>
		DT_INST_IRQN(0),
		DT_INST_IRQ(0, priority),
		temp_nrf5_isr,
		DEVICE_DT_INST_GET(0),
		0);
	irq_enable(DT_INST_IRQN(0));
   44096:	200c      	movs	r0, #12
   44098:	f7e8 fe8c 	bl	2cdb4 <arch_irq_enable>
    p_reg->INTENSET = mask;
   4409c:	4b02      	ldr	r3, [pc, #8]	; (440a8 <temp_nrf5_init+0x3c>)
   4409e:	2201      	movs	r2, #1
   440a0:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304

	nrf_temp_int_enable(NRF_TEMP, NRF_TEMP_INT_DATARDY_MASK);

	return 0;
}
   440a4:	2000      	movs	r0, #0
   440a6:	bd10      	pop	{r4, pc}
   440a8:	4000c000 	.word	0x4000c000

000440ac <flash_nrf_pages_layout>:

static void flash_nrf_pages_layout(const struct device *dev,
				     const struct flash_pages_layout **layout,
				     size_t *layout_size)
{
	*layout = &dev_layout;
   440ac:	4b02      	ldr	r3, [pc, #8]	; (440b8 <flash_nrf_pages_layout+0xc>)
   440ae:	600b      	str	r3, [r1, #0]
	*layout_size = 1;
   440b0:	2301      	movs	r3, #1
   440b2:	6013      	str	r3, [r2, #0]
}
   440b4:	4770      	bx	lr
   440b6:	bf00      	nop
   440b8:	200065d8 	.word	0x200065d8

000440bc <flash_nrf_get_parameters>:
flash_nrf_get_parameters(const struct device *dev)
{
	ARG_UNUSED(dev);

	return &flash_nrf_parameters;
}
   440bc:	4800      	ldr	r0, [pc, #0]	; (440c0 <flash_nrf_get_parameters+0x4>)
   440be:	4770      	bx	lr
   440c0:	00052f3c 	.word	0x00052f3c

000440c4 <nrf_flash_init>:
	.page_layout = flash_nrf_pages_layout,
#endif
};

static int nrf_flash_init(const struct device *dev)
{
   440c4:	b510      	push	{r4, lr}
	return z_impl_k_sem_init(sem, initial_count, limit);
   440c6:	2201      	movs	r2, #1
   440c8:	4611      	mov	r1, r2
   440ca:	4807      	ldr	r0, [pc, #28]	; (440e8 <nrf_flash_init+0x24>)
#ifndef CONFIG_SOC_FLASH_NRF_RADIO_SYNC_NONE
	nrf_flash_sync_init();
#endif /* !CONFIG_SOC_FLASH_NRF_RADIO_SYNC_NONE */

#if defined(CONFIG_FLASH_PAGE_LAYOUT)
	dev_layout.pages_count = nrfx_nvmc_flash_page_count_get();
   440cc:	4c07      	ldr	r4, [pc, #28]	; (440ec <nrf_flash_init+0x28>)
   440ce:	f00b fed3 	bl	4fe78 <z_impl_k_sem_init>
	nrf_flash_sync_init();
   440d2:	f000 f9d9 	bl	44488 <nrf_flash_sync_init>
	dev_layout.pages_count = nrfx_nvmc_flash_page_count_get();
   440d6:	f00b f977 	bl	4f3c8 <nrfx_nvmc_flash_page_count_get>
   440da:	6020      	str	r0, [r4, #0]
	dev_layout.pages_size = nrfx_nvmc_flash_page_size_get();
   440dc:	f00b f970 	bl	4f3c0 <nrfx_nvmc_flash_page_size_get>
   440e0:	6060      	str	r0, [r4, #4]
#endif

	return 0;
}
   440e2:	2000      	movs	r0, #0
   440e4:	bd10      	pop	{r4, pc}
   440e6:	bf00      	nop
   440e8:	200065e0 	.word	0x200065e0
   440ec:	200065d8 	.word	0x200065d8

000440f0 <restore_pofwarn.part.0>:
    uint32_t pofcon = p_reg->POFCON;
   440f0:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
   440f4:	f8d2 1510 	ldr.w	r1, [r2, #1296]	; 0x510
    uint32_t pofcon = p_reg->POFCON;
   440f8:	f8d2 3510 	ldr.w	r3, [r2, #1296]	; 0x510
        (((uint32_t)thr) << POWER_POFCON_THRESHOLD_Pos) |
   440fc:	f001 011e 	and.w	r1, r1, #30
    pofcon &= ~(POWER_POFCON_THRESHOLD_Msk | POWER_POFCON_POF_Msk);
   44100:	f023 031f 	bic.w	r3, r3, #31
   44104:	430b      	orrs	r3, r1
    pofcon |=
   44106:	f043 0301 	orr.w	r3, r3, #1
    p_reg->POFCON = pofcon;
   4410a:	f8c2 3510 	str.w	r3, [r2, #1296]	; 0x510

	if (pofcon_enabled) {
		pof_thr = nrf_power_pofcon_get(NRF_POWER, NULL);

		nrf_power_pofcon_set(NRF_POWER, true, pof_thr);
		pofcon_enabled = false;
   4410e:	4b02      	ldr	r3, [pc, #8]	; (44118 <restore_pofwarn.part.0+0x28>)
   44110:	2200      	movs	r2, #0
   44112:	701a      	strb	r2, [r3, #0]
	}
}
   44114:	4770      	bx	lr
   44116:	bf00      	nop
   44118:	20006bb9 	.word	0x20006bb9

0004411c <suspend_pofwarn>:
    #else
        #if defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)\
         || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)\
         || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)\
         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
            uint32_t var1 = *(uint32_t *)0x10000130ul;
   4411c:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
            uint32_t var2 = *(uint32_t *)0x10000134ul;
        #endif
        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
            if (var1 == 0x08)
   44120:	f8d3 3130 	ldr.w	r3, [r3, #304]	; 0x130
   44124:	2b08      	cmp	r3, #8
   44126:	d120      	bne.n	4416a <suspend_pofwarn+0x4e>
    uint32_t pofcon = p_reg->POFCON;
   44128:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
   4412c:	f8d2 1510 	ldr.w	r1, [r2, #1296]	; 0x510
	if (enabled) {
   44130:	07cb      	lsls	r3, r1, #31
   44132:	d51a      	bpl.n	4416a <suspend_pofwarn+0x4e>
    uint32_t pofcon = p_reg->POFCON;
   44134:	f8d2 3510 	ldr.w	r3, [r2, #1296]	; 0x510
        (((uint32_t)thr) << POWER_POFCON_THRESHOLD_Pos) |
   44138:	f001 011e 	and.w	r1, r1, #30
    pofcon &= ~(POWER_POFCON_THRESHOLD_Msk | POWER_POFCON_POF_Msk);
   4413c:	f023 031f 	bic.w	r3, r3, #31
    pofcon |=
   44140:	430b      	orrs	r3, r1
    p_reg->POFCON = pofcon;
   44142:	f8c2 3510 	str.w	r3, [r2, #1296]	; 0x510
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   44146:	f8d2 3108 	ldr.w	r3, [r2, #264]	; 0x108
		if (nrf_power_event_check(NRF_POWER, NRF_POWER_EVENT_POFWARN)) {
   4414a:	b15b      	cbz	r3, 44164 <suspend_pofwarn+0x48>
    uint32_t pofcon = p_reg->POFCON;
   4414c:	f8d2 3510 	ldr.w	r3, [r2, #1296]	; 0x510
    pofcon &= ~(POWER_POFCON_THRESHOLD_Msk | POWER_POFCON_POF_Msk);
   44150:	f023 031f 	bic.w	r3, r3, #31
   44154:	430b      	orrs	r3, r1
    pofcon |=
   44156:	f043 0301 	orr.w	r3, r3, #1
    p_reg->POFCON = pofcon;
   4415a:	f8c2 3510 	str.w	r3, [r2, #1296]	; 0x510
			return -ECANCELED;
   4415e:	f06f 008b 	mvn.w	r0, #139	; 0x8b
}
   44162:	4770      	bx	lr
		pofcon_enabled = enabled;
   44164:	4b02      	ldr	r3, [pc, #8]	; (44170 <suspend_pofwarn+0x54>)
   44166:	2201      	movs	r2, #1
   44168:	701a      	strb	r2, [r3, #0]
		return 0;
   4416a:	2000      	movs	r0, #0
}
   4416c:	4770      	bx	lr
   4416e:	bf00      	nop
   44170:	20006bb9 	.word	0x20006bb9

00044174 <erase_op>:
{
   44174:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   44176:	4604      	mov	r4, r0
	uint32_t pg_size = nrfx_nvmc_flash_page_size_get();
   44178:	f00b f922 	bl	4f3c0 <nrfx_nvmc_flash_page_size_get>
	if (e_ctx->enable_time_limit) {
   4417c:	7b23      	ldrb	r3, [r4, #12]
	uint32_t pg_size = nrfx_nvmc_flash_page_size_get();
   4417e:	4605      	mov	r5, r0
	if (e_ctx->enable_time_limit) {
   44180:	b10b      	cbz	r3, 44186 <erase_op+0x12>
		nrf_flash_sync_get_timestamp_begin();
   44182:	f000 f993 	bl	444ac <nrf_flash_sync_get_timestamp_begin>
	if (pofcon_enabled) {
   44186:	4f13      	ldr	r7, [pc, #76]	; (441d4 <erase_op+0x60>)
{
   44188:	2600      	movs	r6, #0
		if (SUSPEND_POFWARN()) {
   4418a:	f7ff ffc7 	bl	4411c <suspend_pofwarn>
   4418e:	b9e8      	cbnz	r0, 441cc <erase_op+0x58>
		(void)nrfx_nvmc_page_erase(e_ctx->flash_addr);
   44190:	6860      	ldr	r0, [r4, #4]
   44192:	f001 fa99 	bl	456c8 <nrfx_nvmc_page_erase>
		e_ctx->len -= pg_size;
   44196:	68a3      	ldr	r3, [r4, #8]
   44198:	1b5b      	subs	r3, r3, r5
   4419a:	60a3      	str	r3, [r4, #8]
		e_ctx->flash_addr += pg_size;
   4419c:	6863      	ldr	r3, [r4, #4]
   4419e:	442b      	add	r3, r5
   441a0:	6063      	str	r3, [r4, #4]
	if (pofcon_enabled) {
   441a2:	783b      	ldrb	r3, [r7, #0]
   441a4:	b10b      	cbz	r3, 441aa <erase_op+0x36>
   441a6:	f7ff ffa3 	bl	440f0 <restore_pofwarn.part.0>
		if (e_ctx->enable_time_limit) {
   441aa:	7b23      	ldrb	r3, [r4, #12]
		i++;
   441ac:	3601      	adds	r6, #1
		if (e_ctx->enable_time_limit) {
   441ae:	b93b      	cbnz	r3, 441c0 <erase_op+0x4c>
	} while (e_ctx->len > 0);
   441b0:	68a3      	ldr	r3, [r4, #8]
   441b2:	2b00      	cmp	r3, #0
   441b4:	d1e9      	bne.n	4418a <erase_op+0x16>
	return (e_ctx->len > 0) ? FLASH_OP_ONGOING : FLASH_OP_DONE;
   441b6:	68a0      	ldr	r0, [r4, #8]
   441b8:	3800      	subs	r0, #0
   441ba:	bf18      	it	ne
   441bc:	2001      	movne	r0, #1
}
   441be:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if (nrf_flash_sync_check_time_limit(i)) {
   441c0:	4630      	mov	r0, r6
   441c2:	f7e4 fc81 	bl	28ac8 <nrf_flash_sync_check_time_limit>
   441c6:	2800      	cmp	r0, #0
   441c8:	d0f2      	beq.n	441b0 <erase_op+0x3c>
   441ca:	e7f4      	b.n	441b6 <erase_op+0x42>
			return -ECANCELED;
   441cc:	f06f 008b 	mvn.w	r0, #139	; 0x8b
   441d0:	e7f5      	b.n	441be <erase_op+0x4a>
   441d2:	bf00      	nop
   441d4:	20006bb9 	.word	0x20006bb9

000441d8 <flash_nrf_erase>:
{
   441d8:	b5f0      	push	{r4, r5, r6, r7, lr}
   441da:	b087      	sub	sp, #28
   441dc:	460e      	mov	r6, r1
   441de:	4615      	mov	r5, r2
	uint32_t pg_size = nrfx_nvmc_flash_page_size_get();
   441e0:	f00b f8ee 	bl	4f3c0 <nrfx_nvmc_flash_page_size_get>
	if (is_regular_addr_valid(addr, size)) {
   441e4:	4629      	mov	r1, r5
	uint32_t pg_size = nrfx_nvmc_flash_page_size_get();
   441e6:	4607      	mov	r7, r0
	if (is_regular_addr_valid(addr, size)) {
   441e8:	4630      	mov	r0, r6
   441ea:	f00a ffaf 	bl	4f14c <is_regular_addr_valid>
   441ee:	b3c8      	cbz	r0, 44264 <flash_nrf_erase+0x8c>
		if (((addr % pg_size) != 0) || ((size % pg_size) != 0)) {
   441f0:	fbb6 f3f7 	udiv	r3, r6, r7
   441f4:	fb07 6313 	mls	r3, r7, r3, r6
   441f8:	bba3      	cbnz	r3, 44264 <flash_nrf_erase+0x8c>
   441fa:	fbb5 f4f7 	udiv	r4, r5, r7
   441fe:	fb07 5414 	mls	r4, r7, r4, r5
   44202:	bb7c      	cbnz	r4, 44264 <flash_nrf_erase+0x8c>
		if (!n_pages) {
   44204:	42bd      	cmp	r5, r7
   44206:	d322      	bcc.n	4424e <flash_nrf_erase+0x76>
	return z_impl_k_sem_take(sem, timeout);
   44208:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   4420c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   44210:	4816      	ldr	r0, [pc, #88]	; (4426c <flash_nrf_erase+0x94>)
   44212:	f002 ffd7 	bl	471c4 <z_impl_k_sem_take>
	if (nrf_flash_sync_is_required()) {
   44216:	f00a ffbe 	bl	4f196 <nrf_flash_sync_is_required>
   4421a:	ab02      	add	r3, sp, #8
   4421c:	4601      	mov	r1, r0
	struct flash_context context = {
   4421e:	2210      	movs	r2, #16
	if (nrf_flash_sync_is_required()) {
   44220:	b1c0      	cbz	r0, 44254 <flash_nrf_erase+0x7c>
	struct flash_context context = {
   44222:	4621      	mov	r1, r4
   44224:	4618      	mov	r0, r3
   44226:	f006 fe33 	bl	4ae90 <memset>
   4422a:	2201      	movs	r2, #1
   4422c:	f88d 2014 	strb.w	r2, [sp, #20]
	struct flash_op_desc flash_op_desc = {
   44230:	4a0f      	ldr	r2, [pc, #60]	; (44270 <flash_nrf_erase+0x98>)
   44232:	e9cd 2000 	strd	r2, r0, [sp]
	nrf_flash_sync_set_context(FLASH_SLOT_ERASE);
   44236:	480f      	ldr	r0, [pc, #60]	; (44274 <flash_nrf_erase+0x9c>)
	struct flash_context context = {
   44238:	e9cd 6503 	strd	r6, r5, [sp, #12]
	nrf_flash_sync_set_context(FLASH_SLOT_ERASE);
   4423c:	f000 f92e 	bl	4449c <nrf_flash_sync_set_context>
	return nrf_flash_sync_exe(&flash_op_desc);
   44240:	4668      	mov	r0, sp
   44242:	f7e4 fbc5 	bl	289d0 <nrf_flash_sync_exe>
	return	erase_op(&context);
   44246:	4604      	mov	r4, r0
	z_impl_k_sem_give(sem);
   44248:	4808      	ldr	r0, [pc, #32]	; (4426c <flash_nrf_erase+0x94>)
   4424a:	f002 ff95 	bl	47178 <z_impl_k_sem_give>
}
   4424e:	4620      	mov	r0, r4
   44250:	b007      	add	sp, #28
   44252:	bdf0      	pop	{r4, r5, r6, r7, pc}
	struct flash_context context = {
   44254:	4618      	mov	r0, r3
   44256:	f006 fe1b 	bl	4ae90 <memset>
   4425a:	e9cd 6503 	strd	r6, r5, [sp, #12]
	return	erase_op(&context);
   4425e:	f7ff ff89 	bl	44174 <erase_op>
   44262:	e7f0      	b.n	44246 <flash_nrf_erase+0x6e>
			return -EINVAL;
   44264:	f06f 0415 	mvn.w	r4, #21
   44268:	e7f1      	b.n	4424e <flash_nrf_erase+0x76>
   4426a:	bf00      	nop
   4426c:	200065e0 	.word	0x200065e0
   44270:	00044175 	.word	0x00044175
   44274:	00015e64 	.word	0x00015e64

00044278 <write_op>:
{
   44278:	b570      	push	{r4, r5, r6, lr}
	if (w_ctx->enable_time_limit) {
   4427a:	7b03      	ldrb	r3, [r0, #12]
{
   4427c:	4604      	mov	r4, r0
	if (w_ctx->enable_time_limit) {
   4427e:	b10b      	cbz	r3, 44284 <write_op+0xc>
		nrf_flash_sync_get_timestamp_begin();
   44280:	f000 f914 	bl	444ac <nrf_flash_sync_get_timestamp_begin>
	if (pofcon_enabled) {
   44284:	4e19      	ldr	r6, [pc, #100]	; (442ec <write_op+0x74>)
{
   44286:	2501      	movs	r5, #1
	while (w_ctx->len >= sizeof(uint32_t)) {
   44288:	68a3      	ldr	r3, [r4, #8]
   4428a:	2b03      	cmp	r3, #3
   4428c:	d806      	bhi.n	4429c <write_op+0x24>

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE bool nrf_nvmc_ready_check(NRF_NVMC_Type const * p_reg)
{
    return (bool)(p_reg->READY & NVMC_READY_READY_Msk);
   4428e:	4a18      	ldr	r2, [pc, #96]	; (442f0 <write_op+0x78>)
   44290:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
	while (!nrfx_nvmc_write_done_check()) {
   44294:	07db      	lsls	r3, r3, #31
   44296:	d5fb      	bpl.n	44290 <write_op+0x18>
	return FLASH_OP_DONE;
   44298:	2000      	movs	r0, #0
}
   4429a:	bd70      	pop	{r4, r5, r6, pc}
		if (SUSPEND_POFWARN()) {
   4429c:	f7ff ff3e 	bl	4411c <suspend_pofwarn>
   442a0:	bb08      	cbnz	r0, 442e6 <write_op+0x6e>
				     UNALIGNED_GET((uint32_t *)w_ctx->data_addr));
   442a2:	6823      	ldr	r3, [r4, #0]
		nrfx_nvmc_word_write(w_ctx->flash_addr,
   442a4:	6860      	ldr	r0, [r4, #4]
   442a6:	6819      	ldr	r1, [r3, #0]
   442a8:	f001 fa2e 	bl	45708 <nrfx_nvmc_word_write>
	if (pofcon_enabled) {
   442ac:	7833      	ldrb	r3, [r6, #0]
   442ae:	b10b      	cbz	r3, 442b4 <write_op+0x3c>
   442b0:	f7ff ff1e 	bl	440f0 <restore_pofwarn.part.0>
	w_ctx->flash_addr += shift;
   442b4:	6863      	ldr	r3, [r4, #4]
   442b6:	3304      	adds	r3, #4
   442b8:	6063      	str	r3, [r4, #4]
	w_ctx->data_addr += shift;
   442ba:	6823      	ldr	r3, [r4, #0]
   442bc:	3304      	adds	r3, #4
   442be:	6023      	str	r3, [r4, #0]
	w_ctx->len -= shift;
   442c0:	68a3      	ldr	r3, [r4, #8]
   442c2:	3b04      	subs	r3, #4
   442c4:	60a3      	str	r3, [r4, #8]
		if (w_ctx->enable_time_limit) {
   442c6:	7b23      	ldrb	r3, [r4, #12]
		i++;
   442c8:	3501      	adds	r5, #1
		if (w_ctx->enable_time_limit) {
   442ca:	2b00      	cmp	r3, #0
   442cc:	d0dc      	beq.n	44288 <write_op+0x10>
			if (nrf_flash_sync_check_time_limit(i)) {
   442ce:	4628      	mov	r0, r5
   442d0:	f7e4 fbfa 	bl	28ac8 <nrf_flash_sync_check_time_limit>
   442d4:	2800      	cmp	r0, #0
   442d6:	d0d7      	beq.n	44288 <write_op+0x10>
   442d8:	4a05      	ldr	r2, [pc, #20]	; (442f0 <write_op+0x78>)
   442da:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
	while (!nrfx_nvmc_write_done_check()) {
   442de:	07d9      	lsls	r1, r3, #31
   442e0:	d5fb      	bpl.n	442da <write_op+0x62>
				return FLASH_OP_ONGOING;
   442e2:	2001      	movs	r0, #1
   442e4:	e7d9      	b.n	4429a <write_op+0x22>
			return -ECANCELED;
   442e6:	f06f 008b 	mvn.w	r0, #139	; 0x8b
   442ea:	e7d6      	b.n	4429a <write_op+0x22>
   442ec:	20006bb9 	.word	0x20006bb9
   442f0:	4001e000 	.word	0x4001e000

000442f4 <flash_nrf_write>:
{
   442f4:	b570      	push	{r4, r5, r6, lr}
   442f6:	460d      	mov	r5, r1
   442f8:	b086      	sub	sp, #24
	if (is_regular_addr_valid(addr, len)) {
   442fa:	4619      	mov	r1, r3
   442fc:	4628      	mov	r0, r5
{
   442fe:	4616      	mov	r6, r2
   44300:	461c      	mov	r4, r3
	if (is_regular_addr_valid(addr, len)) {
   44302:	f00a ff23 	bl	4f14c <is_regular_addr_valid>
   44306:	b360      	cbz	r0, 44362 <flash_nrf_write+0x6e>
	if (!is_aligned_32(addr) || (len % sizeof(uint32_t))) {
   44308:	ea45 0304 	orr.w	r3, r5, r4
   4430c:	079b      	lsls	r3, r3, #30
   4430e:	d128      	bne.n	44362 <flash_nrf_write+0x6e>
	if (!len) {
   44310:	b1fc      	cbz	r4, 44352 <flash_nrf_write+0x5e>
	return z_impl_k_sem_take(sem, timeout);
   44312:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   44316:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   4431a:	4813      	ldr	r0, [pc, #76]	; (44368 <flash_nrf_write+0x74>)
   4431c:	f002 ff52 	bl	471c4 <z_impl_k_sem_take>
	if (nrf_flash_sync_is_required()) {
   44320:	f00a ff39 	bl	4f196 <nrf_flash_sync_is_required>
   44324:	4603      	mov	r3, r0
	struct flash_context context = {
   44326:	e9cd 6502 	strd	r6, r5, [sp, #8]
   4432a:	a802      	add	r0, sp, #8
   4432c:	9404      	str	r4, [sp, #16]
	if (nrf_flash_sync_is_required()) {
   4432e:	b19b      	cbz	r3, 44358 <flash_nrf_write+0x64>
	struct flash_context context = {
   44330:	2301      	movs	r3, #1
   44332:	f88d 3014 	strb.w	r3, [sp, #20]
	struct flash_op_desc flash_op_desc = {
   44336:	4b0d      	ldr	r3, [pc, #52]	; (4436c <flash_nrf_write+0x78>)
   44338:	e9cd 3000 	strd	r3, r0, [sp]
	nrf_flash_sync_set_context(FLASH_SLOT_WRITE);
   4433c:	f641 504c 	movw	r0, #7500	; 0x1d4c
   44340:	f000 f8ac 	bl	4449c <nrf_flash_sync_set_context>
	return nrf_flash_sync_exe(&flash_op_desc);
   44344:	4668      	mov	r0, sp
   44346:	f7e4 fb43 	bl	289d0 <nrf_flash_sync_exe>
	return write_op(&context);
   4434a:	4604      	mov	r4, r0
	z_impl_k_sem_give(sem);
   4434c:	4806      	ldr	r0, [pc, #24]	; (44368 <flash_nrf_write+0x74>)
   4434e:	f002 ff13 	bl	47178 <z_impl_k_sem_give>
}
   44352:	4620      	mov	r0, r4
   44354:	b006      	add	sp, #24
   44356:	bd70      	pop	{r4, r5, r6, pc}
	struct flash_context context = {
   44358:	f88d 3014 	strb.w	r3, [sp, #20]
	return write_op(&context);
   4435c:	f7ff ff8c 	bl	44278 <write_op>
   44360:	e7f3      	b.n	4434a <flash_nrf_write+0x56>
		return -EINVAL;
   44362:	f06f 0415 	mvn.w	r4, #21
   44366:	e7f4      	b.n	44352 <flash_nrf_write+0x5e>
   44368:	200065e0 	.word	0x200065e0
   4436c:	00044279 	.word	0x00044279

00044370 <time_slot_callback_work>:
{
   44370:	b51f      	push	{r0, r1, r2, r3, r4, lr}
   44372:	9b07      	ldr	r3, [sp, #28]
	rc = op_desc->handler(op_desc->context);
   44374:	e9d3 2000 	ldrd	r2, r0, [r3]
   44378:	4790      	blx	r2
	if (rc != FLASH_OP_ONGOING) {
   4437a:	2801      	cmp	r0, #1
	rc = op_desc->handler(op_desc->context);
   4437c:	4604      	mov	r4, r0
	if (rc != FLASH_OP_ONGOING) {
   4437e:	d011      	beq.n	443a4 <time_slot_callback_work+0x34>
		ll_timeslice_ticker_id_get(&instance_index, &ticker_id);
   44380:	f10d 010f 	add.w	r1, sp, #15
   44384:	f10d 000e 	add.w	r0, sp, #14
   44388:	f7f3 fd76 	bl	37e78 <ll_timeslice_ticker_id_get>
		ret = ticker_stop(instance_index, 1U, ticker_id,
   4438c:	2300      	movs	r3, #0
   4438e:	9300      	str	r3, [sp, #0]
   44390:	f89d 200f 	ldrb.w	r2, [sp, #15]
   44394:	4b04      	ldr	r3, [pc, #16]	; (443a8 <time_slot_callback_work+0x38>)
   44396:	f89d 000e 	ldrb.w	r0, [sp, #14]
   4439a:	2101      	movs	r1, #1
   4439c:	f7f1 fb8e 	bl	35abc <ticker_stop>
		_ticker_sync_context.result = (rc == FLASH_OP_DONE) ? 0 : rc;
   443a0:	4b02      	ldr	r3, [pc, #8]	; (443ac <time_slot_callback_work+0x3c>)
   443a2:	60dc      	str	r4, [r3, #12]
}
   443a4:	b004      	add	sp, #16
   443a6:	bd10      	pop	{r4, pc}
   443a8:	000443b1 	.word	0x000443b1
   443ac:	20006610 	.word	0x20006610

000443b0 <ticker_stop_prepare_cb>:
{
   443b0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	ll_timeslice_ticker_id_get(&instance_index, &ticker_id);
   443b2:	f10d 010f 	add.w	r1, sp, #15
   443b6:	f10d 000e 	add.w	r0, sp, #14
   443ba:	f7f3 fd5d 	bl	37e78 <ll_timeslice_ticker_id_get>
	ret = ticker_stop(instance_index, 2U, (ticker_id + 1U),
   443be:	f89d 200f 	ldrb.w	r2, [sp, #15]
   443c2:	f89d 000e 	ldrb.w	r0, [sp, #14]
   443c6:	2300      	movs	r3, #0
   443c8:	3201      	adds	r2, #1
   443ca:	9300      	str	r3, [sp, #0]
   443cc:	b2d2      	uxtb	r2, r2
   443ce:	4b03      	ldr	r3, [pc, #12]	; (443dc <ticker_stop_prepare_cb+0x2c>)
   443d0:	2102      	movs	r1, #2
   443d2:	f7f1 fb73 	bl	35abc <ticker_stop>
}
   443d6:	b005      	add	sp, #20
   443d8:	f85d fb04 	ldr.w	pc, [sp], #4
   443dc:	0004447d 	.word	0x0004447d

000443e0 <time_slot_delay>:
{
   443e0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   443e4:	b08d      	sub	sp, #52	; 0x34
   443e6:	4606      	mov	r6, r0
   443e8:	460f      	mov	r7, r1
	ll_timeslice_ticker_id_get(&instance_index, &ticker_id);
   443ea:	f10d 002e 	add.w	r0, sp, #46	; 0x2e
   443ee:	f10d 012f 	add.w	r1, sp, #47	; 0x2f
{
   443f2:	4690      	mov	r8, r2
   443f4:	4699      	mov	r9, r3
	ll_timeslice_ticker_id_get(&instance_index, &ticker_id);
   443f6:	f7f3 fd3f 	bl	37e78 <ll_timeslice_ticker_id_get>
	ret = ticker_start(instance_index, /* Radio instance ticker */
   443fa:	f89d 502f 	ldrb.w	r5, [sp, #47]	; 0x2f
   443fe:	f89d 002e 	ldrb.w	r0, [sp, #46]	; 0x2e
   44402:	9700      	str	r7, [sp, #0]
   44404:	2400      	movs	r4, #0
   44406:	3501      	adds	r5, #1
   44408:	4633      	mov	r3, r6
   4440a:	e9cd 4407 	strd	r4, r4, [sp, #28]
   4440e:	e9cd 8905 	strd	r8, r9, [sp, #20]
   44412:	e9cd 4403 	strd	r4, r4, [sp, #12]
   44416:	e9cd 4401 	strd	r4, r4, [sp, #4]
   4441a:	b2ea      	uxtb	r2, r5
   4441c:	2101      	movs	r1, #1
   4441e:	f7f1 fac1 	bl	359a4 <ticker_start>
	if (ret != TICKER_STATUS_SUCCESS && ret != TICKER_STATUS_BUSY) {
   44422:	f030 0302 	bics.w	r3, r0, #2
   44426:	d00a      	beq.n	4443e <time_slot_delay+0x5e>
		_ticker_sync_context.result = 0;
   44428:	4b06      	ldr	r3, [pc, #24]	; (44444 <time_slot_delay+0x64>)
		ret = ticker_stop(instance_index, 1U, ticker_id,
   4442a:	f89d 202f 	ldrb.w	r2, [sp, #47]	; 0x2f
		_ticker_sync_context.result = 0;
   4442e:	60dc      	str	r4, [r3, #12]
		ret = ticker_stop(instance_index, 1U, ticker_id,
   44430:	f89d 002e 	ldrb.w	r0, [sp, #46]	; 0x2e
   44434:	4b04      	ldr	r3, [pc, #16]	; (44448 <time_slot_delay+0x68>)
   44436:	9400      	str	r4, [sp, #0]
   44438:	2101      	movs	r1, #1
   4443a:	f7f1 fb3f 	bl	35abc <ticker_stop>
}
   4443e:	b00d      	add	sp, #52	; 0x34
   44440:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   44444:	20006610 	.word	0x20006610
   44448:	000443b1 	.word	0x000443b1

0004444c <time_slot_callback_prepare>:
	time_slot_delay(ticks_at_expire,
   4444c:	9b01      	ldr	r3, [sp, #4]
   4444e:	4a02      	ldr	r2, [pc, #8]	; (44458 <time_slot_callback_prepare+0xc>)
   44450:	2131      	movs	r1, #49	; 0x31
   44452:	f7ff bfc5 	b.w	443e0 <time_slot_delay>
   44456:	bf00      	nop
   44458:	0004445d 	.word	0x0004445d

0004445c <time_slot_callback_abort>:
{
   4445c:	b570      	push	{r4, r5, r6, lr}
   4445e:	9d05      	ldr	r5, [sp, #20]
   44460:	4604      	mov	r4, r0
	ll_radio_state_abort();
   44462:	f7f3 fd0f 	bl	37e84 <ll_radio_state_abort>
	time_slot_delay(ticks_at_expire,
   44466:	462b      	mov	r3, r5
   44468:	4620      	mov	r0, r4
   4446a:	4a03      	ldr	r2, [pc, #12]	; (44478 <time_slot_callback_abort+0x1c>)
}
   4446c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	time_slot_delay(ticks_at_expire,
   44470:	2106      	movs	r1, #6
   44472:	f7ff bfb5 	b.w	443e0 <time_slot_delay>
   44476:	bf00      	nop
   44478:	00044371 	.word	0x00044371

0004447c <ticker_stop_work_cb>:
   4447c:	4801      	ldr	r0, [pc, #4]	; (44484 <ticker_stop_work_cb+0x8>)
   4447e:	f002 be7b 	b.w	47178 <z_impl_k_sem_give>
   44482:	bf00      	nop
   44484:	200065f8 	.word	0x200065f8

00044488 <nrf_flash_sync_init>:
{
   44488:	b508      	push	{r3, lr}
	return z_impl_k_sem_init(sem, initial_count, limit);
   4448a:	2201      	movs	r2, #1
   4448c:	2100      	movs	r1, #0
   4448e:	4802      	ldr	r0, [pc, #8]	; (44498 <nrf_flash_sync_init+0x10>)
   44490:	f00b fcf2 	bl	4fe78 <z_impl_k_sem_init>
}
   44494:	2000      	movs	r0, #0
   44496:	bd08      	pop	{r3, pc}
   44498:	200065f8 	.word	0x200065f8

0004449c <nrf_flash_sync_set_context>:
	_ticker_sync_context.interval = duration - FLASH_SYNC_SWITCHING_TIME;
   4449c:	4b02      	ldr	r3, [pc, #8]	; (444a8 <nrf_flash_sync_set_context+0xc>)
   4449e:	f2a0 62a4 	subw	r2, r0, #1700	; 0x6a4
	_ticker_sync_context.slot = duration;
   444a2:	e9c3 2000 	strd	r2, r0, [r3]
}
   444a6:	4770      	bx	lr
   444a8:	20006610 	.word	0x20006610

000444ac <nrf_flash_sync_get_timestamp_begin>:
{
   444ac:	b508      	push	{r3, lr}
	_ticker_sync_context.ticks_begin = ticker_ticks_now_get();
   444ae:	f7f1 fba5 	bl	35bfc <ticker_ticks_now_get>
   444b2:	4b01      	ldr	r3, [pc, #4]	; (444b8 <nrf_flash_sync_get_timestamp_begin+0xc>)
   444b4:	6098      	str	r0, [r3, #8]
}
   444b6:	bd08      	pop	{r3, pc}
   444b8:	20006610 	.word	0x20006610

000444bc <random_byte_get>:
   444bc:	f04f 0320 	mov.w	r3, #32
   444c0:	f3ef 8211 	mrs	r2, BASEPRI
   444c4:	f383 8812 	msr	BASEPRI_MAX, r3
   444c8:	f3bf 8f6f 	isb	sy
    nrf_event_readback((uint8_t *)p_reg + (uint32_t)rng_event);
}

NRF_STATIC_INLINE bool nrf_rng_event_check(NRF_RNG_Type const * p_reg, nrf_rng_event_t rng_event)
{
    return (bool) * ((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event));
   444cc:	4b09      	ldr	r3, [pc, #36]	; (444f4 <random_byte_get+0x38>)
   444ce:	f8d3 1100 	ldr.w	r1, [r3, #256]	; 0x100
	int retval = -EAGAIN;
	unsigned int key;

	key = irq_lock();

	if (nrf_rng_event_check(NRF_RNG, NRF_RNG_EVENT_VALRDY)) {
   444d2:	b161      	cbz	r1, 444ee <random_byte_get+0x32>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event)) = 0x0UL;
   444d4:	2100      	movs	r1, #0
     p_reg->SHORTS &= ~mask;
}

NRF_STATIC_INLINE uint8_t nrf_rng_random_value_get(NRF_RNG_Type const * p_reg)
{
    return (uint8_t)(p_reg->VALUE & RNG_VALUE_VALUE_Msk);
   444d6:	f8d3 0508 	ldr.w	r0, [r3, #1288]	; 0x508
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event)) = 0x0UL;
   444da:	f8c3 1100 	str.w	r1, [r3, #256]	; 0x100
   444de:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
		retval = nrf_rng_random_value_get(NRF_RNG);
   444e2:	b2c0      	uxtb	r0, r0
	__asm__ volatile(
   444e4:	f382 8811 	msr	BASEPRI, r2
   444e8:	f3bf 8f6f 	isb	sy
	}

	irq_unlock(key);

	return retval;
}
   444ec:	4770      	bx	lr
	int retval = -EAGAIN;
   444ee:	f06f 000a 	mvn.w	r0, #10
   444f2:	e7f7      	b.n	444e4 <random_byte_get+0x28>
   444f4:	4000d000 	.word	0x4000d000

000444f8 <rng_pool_get>:
#pragma GCC push_options
#if defined(CONFIG_BT_CTLR_FAST_ENC)
#pragma GCC optimize ("Ofast")
#endif
static uint16_t rng_pool_get(struct rng_pool *rngp, uint8_t *buf, uint16_t len)
{
   444f8:	b5f0      	push	{r4, r5, r6, r7, lr}
   444fa:	4603      	mov	r3, r0
   444fc:	4610      	mov	r0, r2
	uint32_t last  = rngp->last;
   444fe:	789c      	ldrb	r4, [r3, #2]
	uint32_t mask  = rngp->mask;
   44500:	f893 c003 	ldrb.w	ip, [r3, #3]
	__asm__ volatile(
   44504:	f04f 0520 	mov.w	r5, #32
   44508:	f3ef 8211 	mrs	r2, BASEPRI
   4450c:	f385 8812 	msr	BASEPRI_MAX, r5
   44510:	f3bf 8f6f 	isb	sy
	uint32_t first, available;
	uint32_t other_read_in_progress;
	unsigned int key;

	key = irq_lock();
	first = rngp->first_alloc;
   44514:	781f      	ldrb	r7, [r3, #0]
	/*
	 * The other_read_in_progress is non-zero if rngp->first_read != first,
	 * which means that lower-priority code (which was interrupted by this
	 * call) already allocated area for read.
	 */
	other_read_in_progress = (rngp->first_read ^ first);
   44516:	f893 e001 	ldrb.w	lr, [r3, #1]

	available = (last - first) & mask;
   4451a:	1be4      	subs	r4, r4, r7
   4451c:	ea04 040c 	and.w	r4, r4, ip
	if (available < len) {
   44520:	42a0      	cmp	r0, r4
		len = available;
   44522:	bf88      	it	hi
   44524:	b2a0      	uxthhi	r0, r4

	/*
	 * Move alloc index forward to signal, that part of the buffer is
	 * now reserved for this call.
	 */
	rngp->first_alloc = (first + len) & mask;
   44526:	183e      	adds	r6, r7, r0
   44528:	ea0c 0606 	and.w	r6, ip, r6
	first = rngp->first_alloc;
   4452c:	463d      	mov	r5, r7
	rngp->first_alloc = (first + len) & mask;
   4452e:	701e      	strb	r6, [r3, #0]
	__asm__ volatile(
   44530:	f382 8811 	msr	BASEPRI, r2
   44534:	f3bf 8f6f 	isb	sy
   44538:	180a      	adds	r2, r1, r0
	irq_unlock(key);

	while (likely(len--)) {
   4453a:	428a      	cmp	r2, r1
   4453c:	d117      	bne.n	4456e <rng_pool_get+0x76>
	/*
	 * If this call is the last one accessing the pool, move read index
	 * to signal that all allocated regions are now read and could be
	 * overwritten.
	 */
	if (likely(!other_read_in_progress)) {
   4453e:	4577      	cmp	r7, lr
   44540:	d10d      	bne.n	4455e <rng_pool_get+0x66>
	__asm__ volatile(
   44542:	f04f 0120 	mov.w	r1, #32
   44546:	f3ef 8211 	mrs	r2, BASEPRI
   4454a:	f381 8812 	msr	BASEPRI_MAX, r1
   4454e:	f3bf 8f6f 	isb	sy
		key = irq_lock();
		rngp->first_read = rngp->first_alloc;
   44552:	7819      	ldrb	r1, [r3, #0]
   44554:	7059      	strb	r1, [r3, #1]
	__asm__ volatile(
   44556:	f382 8811 	msr	BASEPRI, r2
   4455a:	f3bf 8f6f 	isb	sy
		irq_unlock(key);
	}

	len = dst - buf;
	available = available - len;
	if (available <= rngp->threshold) {
   4455e:	791b      	ldrb	r3, [r3, #4]
	available = available - len;
   44560:	1a24      	subs	r4, r4, r0
	if (available <= rngp->threshold) {
   44562:	42a3      	cmp	r3, r4
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_task)) = 0x1UL;
   44564:	bf22      	ittt	cs
   44566:	4b06      	ldrcs	r3, [pc, #24]	; (44580 <rng_pool_get+0x88>)
   44568:	2201      	movcs	r2, #1
   4456a:	601a      	strcs	r2, [r3, #0]
		nrf_rng_task_trigger(NRF_RNG, NRF_RNG_TASK_START);
	}

	return len;
}
   4456c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		*dst++ = rngp->buffer[first];
   4456e:	195e      	adds	r6, r3, r5
		first = (first + 1) & mask;
   44570:	3501      	adds	r5, #1
		*dst++ = rngp->buffer[first];
   44572:	7976      	ldrb	r6, [r6, #5]
   44574:	f801 6b01 	strb.w	r6, [r1], #1
		first = (first + 1) & mask;
   44578:	ea05 050c 	and.w	r5, r5, ip
   4457c:	e7dd      	b.n	4453a <rng_pool_get+0x42>
   4457e:	bf00      	nop
   44580:	4000d000 	.word	0x4000d000

00044584 <entropy_nrf5_get_entropy_isr>:
	uint16_t cnt = len;

	/* Check if this API is called on correct driver instance. */
	__ASSERT_NO_MSG(&entropy_nrf5_data == dev->data);

	if (likely((flags & ENTROPY_BUSYWAIT) == 0U)) {
   44584:	43db      	mvns	r3, r3
{
   44586:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if (likely((flags & ENTROPY_BUSYWAIT) == 0U)) {
   4458a:	f013 0501 	ands.w	r5, r3, #1
{
   4458e:	460e      	mov	r6, r1
   44590:	4614      	mov	r4, r2
	if (likely((flags & ENTROPY_BUSYWAIT) == 0U)) {
   44592:	d004      	beq.n	4459e <entropy_nrf5_get_entropy_isr+0x1a>
		return rng_pool_get((struct rng_pool *)(entropy_nrf5_data.isr),
   44594:	4821      	ldr	r0, [pc, #132]	; (4461c <entropy_nrf5_get_entropy_isr+0x98>)
   44596:	f7ff ffaf 	bl	444f8 <rng_pool_get>
			irq_enable(IRQN);
		}
	}

	return cnt;
}
   4459a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (len) {
   4459e:	b3a2      	cbz	r2, 4460a <entropy_nrf5_get_entropy_isr+0x86>
	__asm__ volatile(
   445a0:	f04f 0320 	mov.w	r3, #32
   445a4:	f3ef 8811 	mrs	r8, BASEPRI
   445a8:	f383 8812 	msr	BASEPRI_MAX, r3
   445ac:	f3bf 8f6f 	isb	sy
		irq_enabled = irq_is_enabled(IRQN);
   445b0:	200d      	movs	r0, #13
   445b2:	f7e8 fc21 	bl	2cdf8 <arch_irq_is_enabled>
   445b6:	4607      	mov	r7, r0
		irq_disable(IRQN);
   445b8:	200d      	movs	r0, #13
   445ba:	f7e8 fc09 	bl	2cdd0 <arch_irq_disable>
	__asm__ volatile(
   445be:	f388 8811 	msr	BASEPRI, r8
   445c2:	f3bf 8f6f 	isb	sy
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event)) = 0x0UL;
   445c6:	f8df 8058 	ldr.w	r8, [pc, #88]	; 44620 <entropy_nrf5_get_entropy_isr+0x9c>
   445ca:	f8df 9058 	ldr.w	r9, [pc, #88]	; 44624 <entropy_nrf5_get_entropy_isr+0xa0>
   445ce:	f8c8 5100 	str.w	r5, [r8, #256]	; 0x100
   445d2:	f8d8 3100 	ldr.w	r3, [r8, #256]	; 0x100
   445d6:	f44f 5a00 	mov.w	sl, #8192	; 0x2000
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_task)) = 0x1UL;
   445da:	2301      	movs	r3, #1
   445dc:	f8c8 3000 	str.w	r3, [r8]
   445e0:	4625      	mov	r5, r4
   445e2:	f8c9 a180 	str.w	sl, [r9, #384]	; 0x180
    return (bool) * ((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event));
   445e6:	f8d8 3100 	ldr.w	r3, [r8, #256]	; 0x100
			while (!nrf_rng_event_check(NRF_RNG,
   445ea:	b183      	cbz	r3, 4460e <entropy_nrf5_get_entropy_isr+0x8a>
			byte = random_byte_get();
   445ec:	f7ff ff66 	bl	444bc <random_byte_get>
			if (byte < 0) {
   445f0:	1e03      	subs	r3, r0, #0
   445f2:	f8c9 a180 	str.w	sl, [r9, #384]	; 0x180
   445f6:	dbf6      	blt.n	445e6 <entropy_nrf5_get_entropy_isr+0x62>
			buf[--len] = byte;
   445f8:	3d01      	subs	r5, #1
   445fa:	b2ad      	uxth	r5, r5
   445fc:	5573      	strb	r3, [r6, r5]
		} while (len);
   445fe:	2d00      	cmp	r5, #0
   44600:	d1f1      	bne.n	445e6 <entropy_nrf5_get_entropy_isr+0x62>
		if (irq_enabled) {
   44602:	b117      	cbz	r7, 4460a <entropy_nrf5_get_entropy_isr+0x86>
			irq_enable(IRQN);
   44604:	200d      	movs	r0, #13
   44606:	f7e8 fbd5 	bl	2cdb4 <arch_irq_enable>
	return cnt;
   4460a:	4620      	mov	r0, r4
   4460c:	e7c5      	b.n	4459a <entropy_nrf5_get_entropy_isr+0x16>
   4460e:	f3bf 8f4f 	dsb	sy
				__WFE();
   44612:	bf20      	wfe
				__SEV();
   44614:	bf40      	sev
				__WFE();
   44616:	bf20      	wfe
   44618:	e7e5      	b.n	445e6 <entropy_nrf5_get_entropy_isr+0x62>
   4461a:	bf00      	nop
   4461c:	20006650 	.word	0x20006650
   44620:	4000d000 	.word	0x4000d000
   44624:	e000e100 	.word	0xe000e100

00044628 <entropy_nrf5_get_entropy>:
{
   44628:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	return z_impl_k_sem_take(sem, timeout);
   4462c:	4f12      	ldr	r7, [pc, #72]	; (44678 <entropy_nrf5_get_entropy+0x50>)
   4462e:	460d      	mov	r5, r1
   44630:	4614      	mov	r4, r2
		bytes = rng_pool_get((struct rng_pool *)(entropy_nrf5_data.thr),
   44632:	f107 0845 	add.w	r8, r7, #69	; 0x45
	while (len) {
   44636:	b914      	cbnz	r4, 4463e <entropy_nrf5_get_entropy+0x16>
}
   44638:	4620      	mov	r0, r4
   4463a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   4463e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   44642:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   44646:	4638      	mov	r0, r7
   44648:	f002 fdbc 	bl	471c4 <z_impl_k_sem_take>
		bytes = rng_pool_get((struct rng_pool *)(entropy_nrf5_data.thr),
   4464c:	4622      	mov	r2, r4
   4464e:	4629      	mov	r1, r5
   44650:	4640      	mov	r0, r8
   44652:	f7ff ff51 	bl	444f8 <rng_pool_get>
   44656:	4606      	mov	r6, r0
	z_impl_k_sem_give(sem);
   44658:	4638      	mov	r0, r7
   4465a:	f002 fd8d 	bl	47178 <z_impl_k_sem_give>
		if (bytes == 0U) {
   4465e:	b93e      	cbnz	r6, 44670 <entropy_nrf5_get_entropy+0x48>
	return z_impl_k_sem_take(sem, timeout);
   44660:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   44664:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   44668:	4804      	ldr	r0, [pc, #16]	; (4467c <entropy_nrf5_get_entropy+0x54>)
   4466a:	f002 fdab 	bl	471c4 <z_impl_k_sem_take>
	while (len) {
   4466e:	e7e6      	b.n	4463e <entropy_nrf5_get_entropy+0x16>
		len -= bytes;
   44670:	1ba4      	subs	r4, r4, r6
   44672:	b2a4      	uxth	r4, r4
		buf += bytes;
   44674:	4435      	add	r5, r6
   44676:	e7de      	b.n	44636 <entropy_nrf5_get_entropy+0xe>
   44678:	20006620 	.word	0x20006620
   4467c:	20006638 	.word	0x20006638

00044680 <entropy_nrf5_init>:
		    &entropy_nrf5_data, NULL,
		    PRE_KERNEL_1, CONFIG_ENTROPY_INIT_PRIORITY,
		    &entropy_nrf5_api_funcs);

static int entropy_nrf5_init(const struct device *dev)
{
   44680:	b538      	push	{r3, r4, r5, lr}
	return z_impl_k_sem_init(sem, initial_count, limit);
   44682:	4c19      	ldr	r4, [pc, #100]	; (446e8 <entropy_nrf5_init+0x68>)
   44684:	2201      	movs	r2, #1
   44686:	4611      	mov	r1, r2
   44688:	4620      	mov	r0, r4
   4468a:	f00b fbf5 	bl	4fe78 <z_impl_k_sem_init>
   4468e:	2201      	movs	r2, #1
   44690:	2100      	movs	r1, #0
   44692:	f104 0018 	add.w	r0, r4, #24
   44696:	f00b fbef 	bl	4fe78 <z_impl_k_sem_init>
	rngp->mask	  = size - 1;
   4469a:	f240 4307 	movw	r3, #1031	; 0x407
   4469e:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
	rngp->first_alloc = 0U;
   446a2:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
   446a6:	6323      	str	r3, [r4, #48]	; 0x30
	rngp->threshold	  = threshold;
   446a8:	230c      	movs	r3, #12
   446aa:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
	rngp->first_alloc = 0U;
   446ae:	2500      	movs	r5, #0
}

NRF_STATIC_INLINE void nrf_rng_error_correction_enable(NRF_RNG_Type * p_reg)
{
    p_reg->CONFIG |= RNG_CONFIG_DERCEN_Msk;
   446b0:	4b0e      	ldr	r3, [pc, #56]	; (446ec <entropy_nrf5_init+0x6c>)
   446b2:	f884 5045 	strb.w	r5, [r4, #69]	; 0x45
	rngp->first_read  = 0U;
   446b6:	f8a4 5046 	strh.w	r5, [r4, #70]	; 0x46
   446ba:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
   446be:	f042 0201 	orr.w	r2, r2, #1
   446c2:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
    p_reg->INTENSET = mask;
   446c6:	2101      	movs	r1, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event)) = 0x0UL;
   446c8:	f8c3 5100 	str.w	r5, [r3, #256]	; 0x100
   446cc:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    p_reg->INTENSET = mask;
   446d0:	f8c3 1304 	str.w	r1, [r3, #772]	; 0x304

	nrf_rng_event_clear(NRF_RNG, NRF_RNG_EVENT_VALRDY);
	nrf_rng_int_enable(NRF_RNG, NRF_RNG_INT_VALRDY_MASK);
	nrf_rng_task_trigger(NRF_RNG, NRF_RNG_TASK_START);

	IRQ_CONNECT(IRQN, IRQ_PRIO, isr, &entropy_nrf5_data, 0);
   446d4:	462a      	mov	r2, r5
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_task)) = 0x1UL;
   446d6:	6019      	str	r1, [r3, #0]
   446d8:	200d      	movs	r0, #13
   446da:	f7e8 fb9b 	bl	2ce14 <z_arm_irq_priority_set>
	irq_enable(IRQN);
   446de:	200d      	movs	r0, #13
   446e0:	f7e8 fb68 	bl	2cdb4 <arch_irq_enable>

	return 0;
}
   446e4:	4628      	mov	r0, r5
   446e6:	bd38      	pop	{r3, r4, r5, pc}
   446e8:	20006620 	.word	0x20006620
   446ec:	4000d000 	.word	0x4000d000

000446f0 <isr>:
{
   446f0:	b510      	push	{r4, lr}
	byte = random_byte_get();
   446f2:	f7ff fee3 	bl	444bc <random_byte_get>
	if (byte < 0) {
   446f6:	2800      	cmp	r0, #0
   446f8:	db20      	blt.n	4473c <isr+0x4c>
	uint8_t last  = rngp->last;
   446fa:	4b17      	ldr	r3, [pc, #92]	; (44758 <isr+0x68>)
   446fc:	f893 2032 	ldrb.w	r2, [r3, #50]	; 0x32
	if (((last - first) & mask) == mask) {
   44700:	f893 4031 	ldrb.w	r4, [r3, #49]	; 0x31
	uint8_t mask  = rngp->mask;
   44704:	f893 1033 	ldrb.w	r1, [r3, #51]	; 0x33
	if (((last - first) & mask) == mask) {
   44708:	1b14      	subs	r4, r2, r4
   4470a:	ea31 0404 	bics.w	r4, r1, r4
	ret = rng_pool_put((struct rng_pool *)(entropy_nrf5_data.isr), byte);
   4470e:	b2c0      	uxtb	r0, r0
	if (((last - first) & mask) == mask) {
   44710:	d10d      	bne.n	4472e <isr+0x3e>
	uint8_t last  = rngp->last;
   44712:	f893 2047 	ldrb.w	r2, [r3, #71]	; 0x47
	if (((last - first) & mask) == mask) {
   44716:	f893 4046 	ldrb.w	r4, [r3, #70]	; 0x46
	uint8_t mask  = rngp->mask;
   4471a:	f893 1048 	ldrb.w	r1, [r3, #72]	; 0x48
	if (((last - first) & mask) == mask) {
   4471e:	1b14      	subs	r4, r2, r4
   44720:	ea31 0404 	bics.w	r4, r1, r4
   44724:	d10b      	bne.n	4473e <isr+0x4e>
   44726:	4b0d      	ldr	r3, [pc, #52]	; (4475c <isr+0x6c>)
   44728:	2201      	movs	r2, #1
   4472a:	605a      	str	r2, [r3, #4]
}
   4472c:	e00e      	b.n	4474c <isr+0x5c>
	rngp->buffer[last] = byte;
   4472e:	189c      	adds	r4, r3, r2
	rngp->last = (last + 1) & mask;
   44730:	3201      	adds	r2, #1
   44732:	4011      	ands	r1, r2
	rngp->buffer[last] = byte;
   44734:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35
	rngp->last = (last + 1) & mask;
   44738:	f883 1032 	strb.w	r1, [r3, #50]	; 0x32
}
   4473c:	bd10      	pop	{r4, pc}
	rngp->buffer[last] = byte;
   4473e:	189c      	adds	r4, r3, r2
	rngp->last = (last + 1) & mask;
   44740:	3201      	adds	r2, #1
   44742:	4011      	ands	r1, r2
	rngp->buffer[last] = byte;
   44744:	f884 004a 	strb.w	r0, [r4, #74]	; 0x4a
	rngp->last = (last + 1) & mask;
   44748:	f883 1047 	strb.w	r1, [r3, #71]	; 0x47
	z_impl_k_sem_give(sem);
   4474c:	4804      	ldr	r0, [pc, #16]	; (44760 <isr+0x70>)
}
   4474e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   44752:	f002 bd11 	b.w	47178 <z_impl_k_sem_give>
   44756:	bf00      	nop
   44758:	20006620 	.word	0x20006620
   4475c:	4000d000 	.word	0x4000d000
   44760:	20006638 	.word	0x20006638

00044764 <compare_int_lock>:
	return 0;
#endif
}

static bool compare_int_lock(int32_t chan)
{
   44764:	b570      	push	{r4, r5, r6, lr}
	atomic_val_t prev = atomic_and(&int_mask, ~BIT(chan));
   44766:	2301      	movs	r3, #1
   44768:	4083      	lsls	r3, r0
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   4476a:	4a0e      	ldr	r2, [pc, #56]	; (447a4 <compare_int_lock+0x40>)
   4476c:	f3bf 8f5b 	dmb	ish
   44770:	43dc      	mvns	r4, r3
   44772:	e852 1f00 	ldrex	r1, [r2]
   44776:	ea01 0504 	and.w	r5, r1, r4
   4477a:	e842 5600 	strex	r6, r5, [r2]
   4477e:	2e00      	cmp	r6, #0
   44780:	d1f7      	bne.n	44772 <compare_int_lock+0xe>
   44782:	f3bf 8f5b 	dmb	ish

	nrf_rtc_int_disable(RTC, RTC_CHANNEL_INT_MASK(chan));
   44786:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   4478a:	4082      	lsls	r2, r0
    p_reg->INTENCLR = mask;
   4478c:	4806      	ldr	r0, [pc, #24]	; (447a8 <compare_int_lock+0x44>)
   4478e:	f8c0 2308 	str.w	r2, [r0, #776]	; 0x308
  __ASM volatile ("dmb 0xF":::"memory");
   44792:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("isb 0xF":::"memory");
   44796:	f3bf 8f6f 	isb	sy

	__DMB();
	__ISB();

	return prev & BIT(chan);
   4479a:	420b      	tst	r3, r1
}
   4479c:	bf14      	ite	ne
   4479e:	2001      	movne	r0, #1
   447a0:	2000      	moveq	r0, #0
   447a2:	bd70      	pop	{r4, r5, r6, pc}
   447a4:	20006678 	.word	0x20006678
   447a8:	40011000 	.word	0x40011000

000447ac <sys_clock_timeout_handler>:
}

static void sys_clock_timeout_handler(int32_t chan,
				      uint64_t expire_time,
				      void *user_data)
{
   447ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t cc_value = absolute_time_to_cc(expire_time);
	uint64_t dticks = (expire_time - last_count) / CYC_PER_TICK;
   447ae:	491b      	ldr	r1, [pc, #108]	; (4481c <sys_clock_timeout_handler+0x70>)
{
   447b0:	4604      	mov	r4, r0
	return absolute_time & COUNTER_MAX;
   447b2:	f022 457f 	bic.w	r5, r2, #4278190080	; 0xff000000
	uint64_t dticks = (expire_time - last_count) / CYC_PER_TICK;
   447b6:	6808      	ldr	r0, [r1, #0]

	last_count += dticks * CYC_PER_TICK;
   447b8:	e9c1 2300 	strd	r2, r3, [r1]
	return (cc_value >= ANCHOR_RANGE_START) && (cc_value < ANCHOR_RANGE_END);
   447bc:	f5a5 1300 	sub.w	r3, r5, #2097152	; 0x200000
	uint64_t dticks = (expire_time - last_count) / CYC_PER_TICK;
   447c0:	1a10      	subs	r0, r2, r0
	if (in_anchor_range(cc_value)) {
   447c2:	f5b3 0f40 	cmp.w	r3, #12582912	; 0xc00000
   447c6:	d30f      	bcc.n	447e8 <sys_clock_timeout_handler+0x3c>
		 */
		compare_set(chan, last_count + CYC_PER_TICK,
					  sys_clock_timeout_handler, NULL);
	}

	sys_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ?
   447c8:	f003 fb5a 	bl	47e80 <sys_clock_announce>
    return p_reg->CC[ch];
   447cc:	00a3      	lsls	r3, r4, #2
   447ce:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   447d2:	f503 3388 	add.w	r3, r3, #69632	; 0x11000
   447d6:	f8d3 2540 	ldr.w	r2, [r3, #1344]	; 0x540
			   (int32_t)dticks : (dticks > 0));

	if (cc_value == get_comparator(chan)) {
   447da:	4295      	cmp	r5, r2
   447dc:	d11d      	bne.n	4481a <sys_clock_timeout_handler+0x6e>
    p_reg->CC[ch] = cc_val;
   447de:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
   447e2:	f8c3 2540 	str.w	r2, [r3, #1344]	; 0x540
}
   447e6:	e012      	b.n	4480e <sys_clock_timeout_handler+0x62>
		anchor = (((uint64_t)overflow_cnt) << COUNTER_BIT_WIDTH) + cc_value;
   447e8:	4b0d      	ldr	r3, [pc, #52]	; (44820 <sys_clock_timeout_handler+0x74>)
   447ea:	681b      	ldr	r3, [r3, #0]
   447ec:	0a1a      	lsrs	r2, r3, #8
   447ee:	061b      	lsls	r3, r3, #24
   447f0:	195e      	adds	r6, r3, r5
   447f2:	4b0c      	ldr	r3, [pc, #48]	; (44824 <sys_clock_timeout_handler+0x78>)
   447f4:	f142 0700 	adc.w	r7, r2, #0
   447f8:	e9c3 6700 	strd	r6, r7, [r3]
	sys_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ?
   447fc:	f003 fb40 	bl	47e80 <sys_clock_announce>
    return p_reg->CC[ch];
   44800:	4a09      	ldr	r2, [pc, #36]	; (44828 <sys_clock_timeout_handler+0x7c>)
   44802:	f504 73a8 	add.w	r3, r4, #336	; 0x150
   44806:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
	if (cc_value == get_comparator(chan)) {
   4480a:	429d      	cmp	r5, r3
   4480c:	d105      	bne.n	4481a <sys_clock_timeout_handler+0x6e>
    p_reg->EVTENSET = mask;
   4480e:	4a06      	ldr	r2, [pc, #24]	; (44828 <sys_clock_timeout_handler+0x7c>)
	nrf_rtc_event_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
   44810:	f44f 3380 	mov.w	r3, #65536	; 0x10000
   44814:	40a3      	lsls	r3, r4
   44816:	f8c2 3344 	str.w	r3, [r2, #836]	; 0x344
		if (!anchor_updated) {
			set_comparator(chan, COUNTER_HALF_SPAN);
		}
		event_enable(chan);
	}
}
   4481a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   4481c:	20003568 	.word	0x20003568
   44820:	2000667c 	.word	0x2000667c
   44824:	20003570 	.word	0x20003570
   44828:	40011000 	.word	0x40011000

0004482c <compare_int_unlock>:
	if (key) {
   4482c:	b311      	cbz	r1, 44874 <compare_int_unlock+0x48>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   4482e:	f3bf 8f5b 	dmb	ish
		atomic_or(&int_mask, BIT(chan));
   44832:	2301      	movs	r3, #1
   44834:	4a10      	ldr	r2, [pc, #64]	; (44878 <compare_int_unlock+0x4c>)
   44836:	4083      	lsls	r3, r0
   44838:	e852 cf00 	ldrex	ip, [r2]
   4483c:	ea4c 0c03 	orr.w	ip, ip, r3
   44840:	e842 c100 	strex	r1, ip, [r2]
   44844:	2900      	cmp	r1, #0
   44846:	d1f7      	bne.n	44838 <compare_int_unlock+0xc>
   44848:	f3bf 8f5b 	dmb	ish
    p_reg->INTENSET = mask;
   4484c:	4a0b      	ldr	r2, [pc, #44]	; (4487c <compare_int_unlock+0x50>)
		nrf_rtc_int_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
   4484e:	f44f 3380 	mov.w	r3, #65536	; 0x10000
   44852:	4083      	lsls	r3, r0
   44854:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   44858:	4b09      	ldr	r3, [pc, #36]	; (44880 <compare_int_unlock+0x54>)
   4485a:	f3bf 8f5b 	dmb	ish
   4485e:	681b      	ldr	r3, [r3, #0]
   44860:	f3bf 8f5b 	dmb	ish
		if (atomic_get(&force_isr_mask) & BIT(chan)) {
   44864:	40c3      	lsrs	r3, r0
   44866:	07db      	lsls	r3, r3, #31
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   44868:	bf42      	ittt	mi
   4486a:	4b06      	ldrmi	r3, [pc, #24]	; (44884 <compare_int_unlock+0x58>)
   4486c:	f44f 3200 	movmi.w	r2, #131072	; 0x20000
   44870:	f8c3 2100 	strmi.w	r2, [r3, #256]	; 0x100
}
   44874:	4770      	bx	lr
   44876:	bf00      	nop
   44878:	20006678 	.word	0x20006678
   4487c:	40011000 	.word	0x40011000
   44880:	20006674 	.word	0x20006674
   44884:	e000e100 	.word	0xe000e100

00044888 <z_nrf_rtc_timer_read>:
	uint64_t val = ((uint64_t)overflow_cnt) << COUNTER_BIT_WIDTH;
   44888:	4b0d      	ldr	r3, [pc, #52]	; (448c0 <z_nrf_rtc_timer_read+0x38>)
   4488a:	6818      	ldr	r0, [r3, #0]
   4488c:	0a01      	lsrs	r1, r0, #8
   4488e:	0600      	lsls	r0, r0, #24
  __ASM volatile ("dmb 0xF":::"memory");
   44890:	f3bf 8f5f 	dmb	sy
     return p_reg->COUNTER;
   44894:	4b0b      	ldr	r3, [pc, #44]	; (448c4 <z_nrf_rtc_timer_read+0x3c>)
   44896:	f8d3 3504 	ldr.w	r3, [r3, #1284]	; 0x504
	val += cntr;
   4489a:	1818      	adds	r0, r3, r0
   4489c:	f141 0100 	adc.w	r1, r1, #0
	if (cntr < OVERFLOW_RISK_RANGE_END) {
   448a0:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
   448a4:	d20a      	bcs.n	448bc <z_nrf_rtc_timer_read+0x34>
		if (val < anchor) {
   448a6:	4b08      	ldr	r3, [pc, #32]	; (448c8 <z_nrf_rtc_timer_read+0x40>)
   448a8:	e9d3 2300 	ldrd	r2, r3, [r3]
   448ac:	4290      	cmp	r0, r2
   448ae:	eb71 0303 	sbcs.w	r3, r1, r3
   448b2:	d203      	bcs.n	448bc <z_nrf_rtc_timer_read+0x34>
			val += COUNTER_SPAN;
   448b4:	f110 7080 	adds.w	r0, r0, #16777216	; 0x1000000
   448b8:	f141 0100 	adc.w	r1, r1, #0
}
   448bc:	4770      	bx	lr
   448be:	bf00      	nop
   448c0:	2000667c 	.word	0x2000667c
   448c4:	40011000 	.word	0x40011000
   448c8:	20003570 	.word	0x20003570

000448cc <compare_set>:
{
   448cc:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   448d0:	4614      	mov	r4, r2
   448d2:	461d      	mov	r5, r3
   448d4:	4607      	mov	r7, r0
	key = compare_int_lock(chan);
   448d6:	f7ff ff45 	bl	44764 <compare_int_lock>
   448da:	9000      	str	r0, [sp, #0]
	uint64_t curr_time = z_nrf_rtc_timer_read();
   448dc:	f7ff ffd4 	bl	44888 <z_nrf_rtc_timer_read>
	if (curr_time < target_time) {
   448e0:	42a0      	cmp	r0, r4
   448e2:	eb71 0305 	sbcs.w	r3, r1, r5
   448e6:	d27a      	bcs.n	449de <compare_set+0x112>
		if (target_time - curr_time > COUNTER_SPAN) {
   448e8:	4b46      	ldr	r3, [pc, #280]	; (44a04 <compare_set+0x138>)
   448ea:	1a20      	subs	r0, r4, r0
   448ec:	eb65 0101 	sbc.w	r1, r5, r1
   448f0:	4298      	cmp	r0, r3
   448f2:	f171 0100 	sbcs.w	r1, r1, #0
   448f6:	f080 8081 	bcs.w	449fc <compare_set+0x130>
		if (target_time != cc_data[chan].target_time) {
   448fa:	4b43      	ldr	r3, [pc, #268]	; (44a08 <compare_set+0x13c>)
   448fc:	eb03 1307 	add.w	r3, r3, r7, lsl #4
   44900:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
   44904:	429d      	cmp	r5, r3
   44906:	bf08      	it	eq
   44908:	4294      	cmpeq	r4, r2
   4490a:	d053      	beq.n	449b4 <compare_set+0xe8>
   4490c:	ea4f 0a87 	mov.w	sl, r7, lsl #2
   44910:	f10a 4a80 	add.w	sl, sl, #1073741824	; 0x40000000
	nrf_rtc_event_clear(RTC, RTC_CHANNEL_EVENT_ADDR(chan));
   44914:	f107 0950 	add.w	r9, r7, #80	; 0x50
   44918:	f50a 3a88 	add.w	sl, sl, #69632	; 0x11000
   4491c:	ea4f 0989 	mov.w	r9, r9, lsl #2
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   44920:	fa1f f989 	uxth.w	r9, r9
	return absolute_time & COUNTER_MAX;
   44924:	f024 487f 	bic.w	r8, r4, #4278190080	; 0xff000000
   44928:	f109 4980 	add.w	r9, r9, #1073741824	; 0x40000000
	nrf_rtc_event_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
   4492c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    return p_reg->CC[ch];
   44930:	f8da 0540 	ldr.w	r0, [sl, #1344]	; 0x540
     return p_reg->COUNTER;
   44934:	4a35      	ldr	r2, [pc, #212]	; (44a0c <compare_set+0x140>)
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   44936:	f509 3988 	add.w	r9, r9, #69632	; 0x11000
   4493a:	40bb      	lsls	r3, r7
	uint32_t cc_val = abs_val & COUNTER_MAX;
   4493c:	4646      	mov	r6, r8
     return p_reg->COUNTER;
   4493e:	f8d2 b504 	ldr.w	fp, [r2, #1284]	; 0x504
	return (a - b) & COUNTER_MAX;
   44942:	eba0 000b 	sub.w	r0, r0, fp
   44946:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	nrf_rtc_cc_set(RTC, chan, cyc & COUNTER_MAX);
   4494a:	f02b 417f 	bic.w	r1, fp, #4278190080	; 0xff000000
		if (counter_sub(prev_cc, now) == 1) {
   4494e:	2801      	cmp	r0, #1
    p_reg->CC[ch] = cc_val;
   44950:	f8ca 1540 	str.w	r1, [sl, #1344]	; 0x540
   44954:	d105      	bne.n	44962 <compare_set+0x96>
   44956:	9301      	str	r3, [sp, #4]
	z_impl_k_busy_wait(usec_to_wait);
   44958:	2013      	movs	r0, #19
   4495a:	f00b fd03 	bl	50364 <z_impl_k_busy_wait>
   4495e:	4a2b      	ldr	r2, [pc, #172]	; (44a0c <compare_set+0x140>)
   44960:	9b01      	ldr	r3, [sp, #4]
		if (counter_sub(cc_val, now + 2) > COUNTER_HALF_SPAN) {
   44962:	f10b 0c02 	add.w	ip, fp, #2
	return (a - b) & COUNTER_MAX;
   44966:	eba6 000c 	sub.w	r0, r6, ip
   4496a:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
			cc_val = now + 2;
   4496e:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
   44972:	bf88      	it	hi
   44974:	4666      	movhi	r6, ip
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   44976:	2000      	movs	r0, #0
   44978:	f8c9 0000 	str.w	r0, [r9]
   4497c:	f8d9 0000 	ldr.w	r0, [r9]
    p_reg->EVTENSET = mask;
   44980:	f8c2 3344 	str.w	r3, [r2, #836]	; 0x344
	nrf_rtc_cc_set(RTC, chan, cyc & COUNTER_MAX);
   44984:	f026 407f 	bic.w	r0, r6, #4278190080	; 0xff000000
    p_reg->CC[ch] = cc_val;
   44988:	f8ca 0540 	str.w	r0, [sl, #1344]	; 0x540
     return p_reg->COUNTER;
   4498c:	f8d2 0504 	ldr.w	r0, [r2, #1284]	; 0x504
	} while ((now2 != now) &&
   44990:	4583      	cmp	fp, r0
   44992:	d006      	beq.n	449a2 <compare_set+0xd6>
	return (a - b) & COUNTER_MAX;
   44994:	1a30      	subs	r0, r6, r0
   44996:	3802      	subs	r0, #2
   44998:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	} while ((now2 != now) &&
   4499c:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
   449a0:	d81b      	bhi.n	449da <compare_set+0x10e>
	return (a - b) & COUNTER_MAX;
   449a2:	eba6 0608 	sub.w	r6, r6, r8
   449a6:	f026 467f 	bic.w	r6, r6, #4278190080	; 0xff000000
			target_time += counter_sub(cc_set, cc_value);
   449aa:	1936      	adds	r6, r6, r4
   449ac:	f145 0300 	adc.w	r3, r5, #0
   449b0:	4634      	mov	r4, r6
   449b2:	461d      	mov	r5, r3
	cc_data[chan].target_time = target_time;
   449b4:	4914      	ldr	r1, [pc, #80]	; (44a08 <compare_set+0x13c>)
	cc_data[chan].callback = handler;
   449b6:	980c      	ldr	r0, [sp, #48]	; 0x30
	cc_data[chan].target_time = target_time;
   449b8:	013b      	lsls	r3, r7, #4
   449ba:	eb01 1207 	add.w	r2, r1, r7, lsl #4
	cc_data[chan].callback = handler;
   449be:	50c8      	str	r0, [r1, r3]
	cc_data[chan].user_context = user_data;
   449c0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   449c2:	6053      	str	r3, [r2, #4]
	cc_data[chan].target_time = target_time;
   449c4:	e9c2 4502 	strd	r4, r5, [r2, #8]
	return ret;
   449c8:	2400      	movs	r4, #0
	compare_int_unlock(chan, key);
   449ca:	4638      	mov	r0, r7
   449cc:	9900      	ldr	r1, [sp, #0]
   449ce:	f7ff ff2d 	bl	4482c <compare_int_unlock>
}
   449d2:	4620      	mov	r0, r4
   449d4:	b003      	add	sp, #12
   449d6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   449da:	4630      	mov	r0, r6
   449dc:	e7af      	b.n	4493e <compare_set+0x72>
		atomic_or(&force_isr_mask, BIT(chan));
   449de:	2301      	movs	r3, #1
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   449e0:	4a0b      	ldr	r2, [pc, #44]	; (44a10 <compare_set+0x144>)
   449e2:	f3bf 8f5b 	dmb	ish
   449e6:	40bb      	lsls	r3, r7
   449e8:	e852 0f00 	ldrex	r0, [r2]
   449ec:	4318      	orrs	r0, r3
   449ee:	e842 0100 	strex	r1, r0, [r2]
   449f2:	2900      	cmp	r1, #0
   449f4:	d1f8      	bne.n	449e8 <compare_set+0x11c>
   449f6:	f3bf 8f5b 	dmb	ish
   449fa:	e7db      	b.n	449b4 <compare_set+0xe8>
			return -EINVAL;
   449fc:	f06f 0415 	mvn.w	r4, #21
   44a00:	e7e3      	b.n	449ca <compare_set+0xfe>
   44a02:	bf00      	nop
   44a04:	01000001 	.word	0x01000001
   44a08:	20003558 	.word	0x20003558
   44a0c:	40011000 	.word	0x40011000
   44a10:	20006674 	.word	0x20006674

00044a14 <sys_clock_driver_init>:
{
	return (uint32_t)z_nrf_rtc_timer_read();
}

static int sys_clock_driver_init(const struct device *dev)
{
   44a14:	b573      	push	{r0, r1, r4, r5, r6, lr}
			CLOCK_CONTROL_NRF_LF_START_STABLE);

	/* TODO: replace with counter driver to access RTC */
	nrf_rtc_prescaler_set(RTC, 0);
	for (int32_t chan = 0; chan < CHAN_COUNT; chan++) {
		cc_data[chan].target_time = TARGET_TIME_INVALID;
   44a16:	4b19      	ldr	r3, [pc, #100]	; (44a7c <sys_clock_driver_init+0x68>)
    p_reg->PRESCALER = val;
   44a18:	4d19      	ldr	r5, [pc, #100]	; (44a80 <sys_clock_driver_init+0x6c>)
   44a1a:	2400      	movs	r4, #0
   44a1c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   44a20:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   44a24:	f8c5 4508 	str.w	r4, [r5, #1288]	; 0x508
   44a28:	e9c3 0102 	strd	r0, r1, [r3, #8]
    p_reg->INTENSET = mask;
   44a2c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
   44a30:	f8c5 3304 	str.w	r3, [r5, #772]	; 0x304
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   44a34:	4b13      	ldr	r3, [pc, #76]	; (44a84 <sys_clock_driver_init+0x70>)
   44a36:	2602      	movs	r6, #2
   44a38:	f44f 3200 	mov.w	r2, #131072	; 0x20000

	nrf_rtc_int_enable(RTC, NRF_RTC_INT_OVERFLOW_MASK);

	NVIC_ClearPendingIRQ(RTC_IRQn);

	IRQ_CONNECT(RTC_IRQn, DT_IRQ(DT_NODELABEL(RTC_LABEL), priority),
   44a3c:	2101      	movs	r1, #1
   44a3e:	f8c5 6304 	str.w	r6, [r5, #772]	; 0x304
   44a42:	2011      	movs	r0, #17
   44a44:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
   44a48:	4622      	mov	r2, r4
   44a4a:	f7e8 f9e3 	bl	2ce14 <z_arm_irq_priority_set>
		    rtc_nrf_isr, 0, 0);
	irq_enable(RTC_IRQn);
   44a4e:	2011      	movs	r0, #17
   44a50:	f7e8 f9b0 	bl	2cdb4 <arch_irq_enable>

	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_CLEAR);
	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_START);

	int_mask = BIT_MASK(CHAN_COUNT);
   44a54:	4a0c      	ldr	r2, [pc, #48]	; (44a88 <sys_clock_driver_init+0x74>)
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
   44a56:	2301      	movs	r3, #1
   44a58:	60ab      	str	r3, [r5, #8]
   44a5a:	602b      	str	r3, [r5, #0]
   44a5c:	6013      	str	r3, [r2, #0]

	uint32_t initial_timeout = IS_ENABLED(CONFIG_TICKLESS_KERNEL) ?
		(COUNTER_HALF_SPAN - 1) :
		(counter() + CYC_PER_TICK);

	compare_set(0, initial_timeout, sys_clock_timeout_handler, NULL);
   44a5e:	4b0b      	ldr	r3, [pc, #44]	; (44a8c <sys_clock_driver_init+0x78>)
   44a60:	4a0b      	ldr	r2, [pc, #44]	; (44a90 <sys_clock_driver_init+0x7c>)
   44a62:	9300      	str	r3, [sp, #0]
   44a64:	9401      	str	r4, [sp, #4]
   44a66:	2300      	movs	r3, #0
   44a68:	4620      	mov	r0, r4
   44a6a:	f7ff ff2f 	bl	448cc <compare_set>

	z_nrf_clock_control_lf_on(mode);
   44a6e:	4630      	mov	r0, r6
   44a70:	f7ff f8da 	bl	43c28 <z_nrf_clock_control_lf_on>

	return 0;
}
   44a74:	4620      	mov	r0, r4
   44a76:	b002      	add	sp, #8
   44a78:	bd70      	pop	{r4, r5, r6, pc}
   44a7a:	bf00      	nop
   44a7c:	20003558 	.word	0x20003558
   44a80:	40011000 	.word	0x40011000
   44a84:	e000e100 	.word	0xe000e100
   44a88:	20006678 	.word	0x20006678
   44a8c:	000447ad 	.word	0x000447ad
   44a90:	007fffff 	.word	0x007fffff

00044a94 <rtc_nrf_isr>:
{
   44a94:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    return p_reg->INTENSET & mask;
   44a98:	4c33      	ldr	r4, [pc, #204]	; (44b68 <rtc_nrf_isr+0xd4>)
   44a9a:	f8d4 3304 	ldr.w	r3, [r4, #772]	; 0x304
	if (nrf_rtc_int_enable_check(RTC, NRF_RTC_INT_OVERFLOW_MASK) &&
   44a9e:	079a      	lsls	r2, r3, #30
   44aa0:	d50b      	bpl.n	44aba <rtc_nrf_isr+0x26>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   44aa2:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
   44aa6:	b143      	cbz	r3, 44aba <rtc_nrf_isr+0x26>
		overflow_cnt++;
   44aa8:	4a30      	ldr	r2, [pc, #192]	; (44b6c <rtc_nrf_isr+0xd8>)
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   44aaa:	2300      	movs	r3, #0
   44aac:	f8c4 3104 	str.w	r3, [r4, #260]	; 0x104
   44ab0:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
   44ab4:	6813      	ldr	r3, [r2, #0]
   44ab6:	3301      	adds	r3, #1
   44ab8:	6013      	str	r3, [r2, #0]
	__asm__ volatile(
   44aba:	f04f 0320 	mov.w	r3, #32
   44abe:	f3ef 8211 	mrs	r2, BASEPRI
   44ac2:	f383 8812 	msr	BASEPRI_MAX, r3
   44ac6:	f3bf 8f6f 	isb	sy
    return p_reg->INTENSET & mask;
   44aca:	f8d4 3304 	ldr.w	r3, [r4, #772]	; 0x304
	if (nrf_rtc_int_enable_check(RTC, RTC_CHANNEL_INT_MASK(chan))) {
   44ace:	03db      	lsls	r3, r3, #15
   44ad0:	d529      	bpl.n	44b26 <rtc_nrf_isr+0x92>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   44ad2:	f3bf 8f5b 	dmb	ish
   44ad6:	4b26      	ldr	r3, [pc, #152]	; (44b70 <rtc_nrf_isr+0xdc>)
   44ad8:	e853 1f00 	ldrex	r1, [r3]
   44adc:	f021 0001 	bic.w	r0, r1, #1
   44ae0:	e843 0500 	strex	r5, r0, [r3]
   44ae4:	2d00      	cmp	r5, #0
   44ae6:	d1f7      	bne.n	44ad8 <rtc_nrf_isr+0x44>
   44ae8:	f3bf 8f5b 	dmb	ish
		result = atomic_and(&force_isr_mask, ~BIT(chan)) ||
   44aec:	b911      	cbnz	r1, 44af4 <rtc_nrf_isr+0x60>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   44aee:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
   44af2:	b1c3      	cbz	r3, 44b26 <rtc_nrf_isr+0x92>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   44af4:	2500      	movs	r5, #0
   44af6:	f8c4 5140 	str.w	r5, [r4, #320]	; 0x140
   44afa:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
	__asm__ volatile(
   44afe:	f382 8811 	msr	BASEPRI, r2
   44b02:	f3bf 8f6f 	isb	sy
		curr_time = z_nrf_rtc_timer_read();
   44b06:	f7ff febf 	bl	44888 <z_nrf_rtc_timer_read>
	__asm__ volatile(
   44b0a:	f04f 0320 	mov.w	r3, #32
   44b0e:	f3ef 8211 	mrs	r2, BASEPRI
   44b12:	f383 8812 	msr	BASEPRI_MAX, r3
   44b16:	f3bf 8f6f 	isb	sy
		expire_time = cc_data[chan].target_time;
   44b1a:	4b16      	ldr	r3, [pc, #88]	; (44b74 <rtc_nrf_isr+0xe0>)
   44b1c:	e9d3 6702 	ldrd	r6, r7, [r3, #8]
		if (curr_time >= expire_time) {
   44b20:	42b0      	cmp	r0, r6
   44b22:	41b9      	sbcs	r1, r7
   44b24:	d206      	bcs.n	44b34 <rtc_nrf_isr+0xa0>
	__asm__ volatile(
   44b26:	f382 8811 	msr	BASEPRI, r2
   44b2a:	f3bf 8f6f 	isb	sy
}
   44b2e:	b003      	add	sp, #12
   44b30:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			cc_data[chan].target_time = TARGET_TIME_INVALID;
   44b34:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
   44b38:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
			user_context = cc_data[chan].user_context;
   44b3c:	e9d3 1000 	ldrd	r1, r0, [r3]
			cc_data[chan].target_time = TARGET_TIME_INVALID;
   44b40:	e9c3 8902 	strd	r8, r9, [r3, #8]
			cc_data[chan].callback = NULL;
   44b44:	601d      	str	r5, [r3, #0]
    p_reg->EVTENCLR = mask;
   44b46:	f44f 3380 	mov.w	r3, #65536	; 0x10000
   44b4a:	f8c4 3348 	str.w	r3, [r4, #840]	; 0x348
   44b4e:	f382 8811 	msr	BASEPRI, r2
   44b52:	f3bf 8f6f 	isb	sy
		if (handler) {
   44b56:	2900      	cmp	r1, #0
   44b58:	d0e9      	beq.n	44b2e <rtc_nrf_isr+0x9a>
			handler(chan, expire_time, user_context);
   44b5a:	9000      	str	r0, [sp, #0]
   44b5c:	4632      	mov	r2, r6
   44b5e:	463b      	mov	r3, r7
   44b60:	4628      	mov	r0, r5
   44b62:	4788      	blx	r1
}
   44b64:	e7e3      	b.n	44b2e <rtc_nrf_isr+0x9a>
   44b66:	bf00      	nop
   44b68:	40011000 	.word	0x40011000
   44b6c:	2000667c 	.word	0x2000667c
   44b70:	20006674 	.word	0x20006674
   44b74:	20003558 	.word	0x20003558

00044b78 <sys_clock_set_timeout>:
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
   44b78:	1c43      	adds	r3, r0, #1
{
   44b7a:	b513      	push	{r0, r1, r4, lr}
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
   44b7c:	d021      	beq.n	44bc2 <sys_clock_set_timeout+0x4a>
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
   44b7e:	2801      	cmp	r0, #1
   44b80:	dd21      	ble.n	44bc6 <sys_clock_set_timeout+0x4e>
   44b82:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
   44b86:	da20      	bge.n	44bca <sys_clock_set_timeout+0x52>
   44b88:	1e44      	subs	r4, r0, #1
	uint32_t unannounced = z_nrf_rtc_timer_read() - last_count;
   44b8a:	f7ff fe7d 	bl	44888 <z_nrf_rtc_timer_read>
   44b8e:	4b10      	ldr	r3, [pc, #64]	; (44bd0 <sys_clock_set_timeout+0x58>)
   44b90:	e9d3 1300 	ldrd	r1, r3, [r3]
   44b94:	1a42      	subs	r2, r0, r1
		ticks = 0;
   44b96:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
	if (cyc > MAX_CYCLES) {
   44b9a:	480e      	ldr	r0, [pc, #56]	; (44bd4 <sys_clock_set_timeout+0x5c>)
		ticks = 0;
   44b9c:	bf28      	it	cs
   44b9e:	2400      	movcs	r4, #0
	cyc = ticks * CYC_PER_TICK + 1 + unannounced;
   44ba0:	3201      	adds	r2, #1
   44ba2:	4422      	add	r2, r4
	if (cyc > MAX_CYCLES) {
   44ba4:	4282      	cmp	r2, r0
   44ba6:	bf28      	it	cs
   44ba8:	4602      	movcs	r2, r0
	uint64_t target_time = cyc + last_count;
   44baa:	1852      	adds	r2, r2, r1
   44bac:	f04f 0000 	mov.w	r0, #0
	compare_set(0, target_time, sys_clock_timeout_handler, NULL);
   44bb0:	4909      	ldr	r1, [pc, #36]	; (44bd8 <sys_clock_set_timeout+0x60>)
   44bb2:	9001      	str	r0, [sp, #4]
   44bb4:	9100      	str	r1, [sp, #0]
   44bb6:	f143 0300 	adc.w	r3, r3, #0
   44bba:	f7ff fe87 	bl	448cc <compare_set>
}
   44bbe:	b002      	add	sp, #8
   44bc0:	bd10      	pop	{r4, pc}
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
   44bc2:	4804      	ldr	r0, [pc, #16]	; (44bd4 <sys_clock_set_timeout+0x5c>)
   44bc4:	e7e0      	b.n	44b88 <sys_clock_set_timeout+0x10>
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
   44bc6:	2400      	movs	r4, #0
   44bc8:	e7df      	b.n	44b8a <sys_clock_set_timeout+0x12>
   44bca:	4c02      	ldr	r4, [pc, #8]	; (44bd4 <sys_clock_set_timeout+0x5c>)
   44bcc:	e7dd      	b.n	44b8a <sys_clock_set_timeout+0x12>
   44bce:	bf00      	nop
   44bd0:	20003568 	.word	0x20003568
   44bd4:	007fffff 	.word	0x007fffff
   44bd8:	000447ad 	.word	0x000447ad

00044bdc <sys_clock_elapsed>:
{
   44bdc:	b508      	push	{r3, lr}
	return (z_nrf_rtc_timer_read() - last_count) / CYC_PER_TICK;
   44bde:	f7ff fe53 	bl	44888 <z_nrf_rtc_timer_read>
   44be2:	4b02      	ldr	r3, [pc, #8]	; (44bec <sys_clock_elapsed+0x10>)
   44be4:	681b      	ldr	r3, [r3, #0]
}
   44be6:	1ac0      	subs	r0, r0, r3
   44be8:	bd08      	pop	{r3, pc}
   44bea:	bf00      	nop
   44bec:	20003568 	.word	0x20003568

00044bf0 <nrf52_errata_103>:
            uint32_t var1 = *(uint32_t *)0x10000130ul;
   44bf0:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
            if (var1 == 0x08)
   44bf4:	f8d3 2130 	ldr.w	r2, [r3, #304]	; 0x130
   44bf8:	2a08      	cmp	r2, #8
   44bfa:	d106      	bne.n	44c0a <nrf52_errata_103+0x1a>
            uint32_t var2 = *(uint32_t *)0x10000134ul;
   44bfc:	f8d3 3134 	ldr.w	r3, [r3, #308]	; 0x134
                switch(var2)
   44c00:	2b05      	cmp	r3, #5
   44c02:	d802      	bhi.n	44c0a <nrf52_errata_103+0x1a>
   44c04:	4a02      	ldr	r2, [pc, #8]	; (44c10 <nrf52_errata_103+0x20>)
   44c06:	5cd0      	ldrb	r0, [r2, r3]
   44c08:	4770      	bx	lr
                        return false;
   44c0a:	2000      	movs	r0, #0
}
   44c0c:	4770      	bx	lr
   44c0e:	bf00      	nop
   44c10:	0005389e 	.word	0x0005389e

00044c14 <nvmc_wait>:

/* -- NVMC utility functions -- */
/* Waits until NVMC is done with the current pending action */
void nvmc_wait(void)
{
    while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
   44c14:	4a02      	ldr	r2, [pc, #8]	; (44c20 <nvmc_wait+0xc>)
   44c16:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
   44c1a:	2b00      	cmp	r3, #0
   44c1c:	d0fb      	beq.n	44c16 <nvmc_wait+0x2>
}
   44c1e:	4770      	bx	lr
   44c20:	4001e000 	.word	0x4001e000

00044c24 <SystemInit>:
{
    SystemCoreClock = __SYSTEM_CLOCK_64M;
}

void SystemInit(void)
{
   44c24:	b510      	push	{r4, lr}
            uint32_t var1 = *(uint32_t *)0x10000130ul;
   44c26:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
            if (var1 == 0x08)
   44c2a:	f8d3 2130 	ldr.w	r2, [r3, #304]	; 0x130
   44c2e:	2a08      	cmp	r2, #8
   44c30:	d14e      	bne.n	44cd0 <SystemInit+0xac>

    #if NRF52_ERRATA_36_ENABLE_WORKAROUND
        /* Workaround for Errata 36 "CLOCK: Some registers are not reset when expected" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_36()){
            NRF_CLOCK->EVENTS_DONE = 0;
   44c32:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
   44c36:	2100      	movs	r1, #0
   44c38:	f8c2 110c 	str.w	r1, [r2, #268]	; 0x10c
            NRF_CLOCK->EVENTS_CTTO = 0;
   44c3c:	f8c2 1110 	str.w	r1, [r2, #272]	; 0x110
            NRF_CLOCK->CTIV = 0;
   44c40:	f8c2 1538 	str.w	r1, [r2, #1336]	; 0x538

    #if NRF52_ERRATA_66_ENABLE_WORKAROUND
        /* Workaround for Errata 66 "TEMP: Linearity specification not met with default settings" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_66()){
            NRF_TEMP->A0 = NRF_FICR->TEMP.A0;
   44c44:	f502 4240 	add.w	r2, r2, #49152	; 0xc000
   44c48:	f8d3 1404 	ldr.w	r1, [r3, #1028]	; 0x404
   44c4c:	f8c2 1520 	str.w	r1, [r2, #1312]	; 0x520
            NRF_TEMP->A1 = NRF_FICR->TEMP.A1;
   44c50:	f8d3 1408 	ldr.w	r1, [r3, #1032]	; 0x408
   44c54:	f8c2 1524 	str.w	r1, [r2, #1316]	; 0x524
            NRF_TEMP->A2 = NRF_FICR->TEMP.A2;
   44c58:	f8d3 140c 	ldr.w	r1, [r3, #1036]	; 0x40c
   44c5c:	f8c2 1528 	str.w	r1, [r2, #1320]	; 0x528
            NRF_TEMP->A3 = NRF_FICR->TEMP.A3;
   44c60:	f8d3 1410 	ldr.w	r1, [r3, #1040]	; 0x410
   44c64:	f8c2 152c 	str.w	r1, [r2, #1324]	; 0x52c
            NRF_TEMP->A4 = NRF_FICR->TEMP.A4;
   44c68:	f8d3 1414 	ldr.w	r1, [r3, #1044]	; 0x414
   44c6c:	f8c2 1530 	str.w	r1, [r2, #1328]	; 0x530
            NRF_TEMP->A5 = NRF_FICR->TEMP.A5;
   44c70:	f8d3 1418 	ldr.w	r1, [r3, #1048]	; 0x418
   44c74:	f8c2 1534 	str.w	r1, [r2, #1332]	; 0x534
            NRF_TEMP->B0 = NRF_FICR->TEMP.B0;
   44c78:	f8d3 141c 	ldr.w	r1, [r3, #1052]	; 0x41c
   44c7c:	f8c2 1540 	str.w	r1, [r2, #1344]	; 0x540
            NRF_TEMP->B1 = NRF_FICR->TEMP.B1;
   44c80:	f8d3 1420 	ldr.w	r1, [r3, #1056]	; 0x420
   44c84:	f8c2 1544 	str.w	r1, [r2, #1348]	; 0x544
            NRF_TEMP->B2 = NRF_FICR->TEMP.B2;
   44c88:	f8d3 1424 	ldr.w	r1, [r3, #1060]	; 0x424
   44c8c:	f8c2 1548 	str.w	r1, [r2, #1352]	; 0x548
            NRF_TEMP->B3 = NRF_FICR->TEMP.B3;
   44c90:	f8d3 1428 	ldr.w	r1, [r3, #1064]	; 0x428
   44c94:	f8c2 154c 	str.w	r1, [r2, #1356]	; 0x54c
            NRF_TEMP->B4 = NRF_FICR->TEMP.B4;
   44c98:	f8d3 142c 	ldr.w	r1, [r3, #1068]	; 0x42c
   44c9c:	f8c2 1550 	str.w	r1, [r2, #1360]	; 0x550
            NRF_TEMP->B5 = NRF_FICR->TEMP.B5;
   44ca0:	f8d3 1430 	ldr.w	r1, [r3, #1072]	; 0x430
   44ca4:	f8c2 1554 	str.w	r1, [r2, #1364]	; 0x554
            NRF_TEMP->T0 = NRF_FICR->TEMP.T0;
   44ca8:	f8d3 1434 	ldr.w	r1, [r3, #1076]	; 0x434
   44cac:	f8c2 1560 	str.w	r1, [r2, #1376]	; 0x560
            NRF_TEMP->T1 = NRF_FICR->TEMP.T1;
   44cb0:	f8d3 1438 	ldr.w	r1, [r3, #1080]	; 0x438
   44cb4:	f8c2 1564 	str.w	r1, [r2, #1380]	; 0x564
            NRF_TEMP->T2 = NRF_FICR->TEMP.T2;
   44cb8:	f8d3 143c 	ldr.w	r1, [r3, #1084]	; 0x43c
   44cbc:	f8c2 1568 	str.w	r1, [r2, #1384]	; 0x568
            NRF_TEMP->T3 = NRF_FICR->TEMP.T3;
   44cc0:	f8d3 1440 	ldr.w	r1, [r3, #1088]	; 0x440
   44cc4:	f8c2 156c 	str.w	r1, [r2, #1388]	; 0x56c
            NRF_TEMP->T4 = NRF_FICR->TEMP.T4;
   44cc8:	f8d3 3444 	ldr.w	r3, [r3, #1092]	; 0x444
   44ccc:	f8c2 3570 	str.w	r3, [r2, #1392]	; 0x570
    #endif

    #if NRF52_ERRATA_98_ENABLE_WORKAROUND
        /* Workaround for Errata 98 "NFCT: Not able to communicate with the peer" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_98()){
   44cd0:	f7ff ff8e 	bl	44bf0 <nrf52_errata_103>
   44cd4:	b118      	cbz	r0, 44cde <SystemInit+0xba>
            *(volatile uint32_t *)0x4000568Cul = 0x00038148ul;
   44cd6:	4b3b      	ldr	r3, [pc, #236]	; (44dc4 <SystemInit+0x1a0>)
   44cd8:	4a3b      	ldr	r2, [pc, #236]	; (44dc8 <SystemInit+0x1a4>)
   44cda:	f8c3 268c 	str.w	r2, [r3, #1676]	; 0x68c
    #endif

    #if NRF52_ERRATA_103_ENABLE_WORKAROUND && defined(CCM_MAXPACKETSIZE_MAXPACKETSIZE_Pos)
        /* Workaround for Errata 103 "CCM: Wrong reset value of CCM MAXPACKETSIZE" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_103()){
   44cde:	f7ff ff87 	bl	44bf0 <nrf52_errata_103>
   44ce2:	b118      	cbz	r0, 44cec <SystemInit+0xc8>
            NRF_CCM->MAXPACKETSIZE = 0xFBul;
   44ce4:	4b39      	ldr	r3, [pc, #228]	; (44dcc <SystemInit+0x1a8>)
   44ce6:	22fb      	movs	r2, #251	; 0xfb
   44ce8:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    #endif

    #if NRF52_ERRATA_115_ENABLE_WORKAROUND
        /* Workaround for Errata 115 "RAM: RAM content cannot be trusted upon waking up from System ON Idle or System OFF mode" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_115()){
   44cec:	f7ff ff80 	bl	44bf0 <nrf52_errata_103>
   44cf0:	b170      	cbz	r0, 44d10 <SystemInit+0xec>
            *(volatile uint32_t *)0x40000EE4 = (*(volatile uint32_t *)0x40000EE4 & 0xFFFFFFF0) | (*(uint32_t *)0x10000258 & 0x0000000F);
   44cf2:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
   44cf6:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   44cfa:	f8d1 2ee4 	ldr.w	r2, [r1, #3812]	; 0xee4
   44cfe:	f8d3 3258 	ldr.w	r3, [r3, #600]	; 0x258
   44d02:	f022 020f 	bic.w	r2, r2, #15
   44d06:	f003 030f 	and.w	r3, r3, #15
   44d0a:	4313      	orrs	r3, r2
   44d0c:	f8c1 3ee4 	str.w	r3, [r1, #3812]	; 0xee4
    #endif

    #if NRF52_ERRATA_120_ENABLE_WORKAROUND
        /* Workaround for Errata 120 "QSPI: Data read or written is corrupted" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_120()){
   44d10:	f7ff ff6e 	bl	44bf0 <nrf52_errata_103>
   44d14:	b120      	cbz	r0, 44d20 <SystemInit+0xfc>
            *(volatile uint32_t *)0x40029640ul = 0x200ul;
   44d16:	4b2e      	ldr	r3, [pc, #184]	; (44dd0 <SystemInit+0x1ac>)
   44d18:	f44f 7200 	mov.w	r2, #512	; 0x200
   44d1c:	f8c3 2640 	str.w	r2, [r3, #1600]	; 0x640
            uint32_t var1 = *(uint32_t *)0x10000130ul;
   44d20:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
            if (var1 == 0x08)
   44d24:	f8d3 3130 	ldr.w	r3, [r3, #304]	; 0x130
   44d28:	2b08      	cmp	r3, #8
   44d2a:	d11a      	bne.n	44d62 <SystemInit+0x13e>

    #if NRF52_ERRATA_136_ENABLE_WORKAROUND
        /* Workaround for Errata 136 "System: Bits in RESETREAS are set when they should not be" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_136()){
            if (NRF_POWER->RESETREAS & POWER_RESETREAS_RESETPIN_Msk){
   44d2c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   44d30:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
   44d34:	07d2      	lsls	r2, r2, #31
                NRF_POWER->RESETREAS =  ~POWER_RESETREAS_RESETPIN_Msk;
   44d36:	bf44      	itt	mi
   44d38:	f06f 0201 	mvnmi.w	r2, #1
   44d3c:	f8c3 2400 	strmi.w	r2, [r3, #1024]	; 0x400
         || defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)\
         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
            uint32_t var1 = *(uint32_t *)0x10000130ul;
            uint32_t var2 = *(uint32_t *)0x10000134ul;
   44d40:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   44d44:	f8d3 3134 	ldr.w	r3, [r3, #308]	; 0x134
            }
        #endif
        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
            if (var1 == 0x08)
            {
                switch(var2)
   44d48:	2b05      	cmp	r3, #5
   44d4a:	d802      	bhi.n	44d52 <SystemInit+0x12e>
            {
                /* Prevent processor from unlocking APPROTECT soft branch after this point. */
                NRF_APPROTECT->FORCEPROTECT = APPROTECT_FORCEPROTECT_FORCEPROTECT_Force;
            }
        #else
            if (nrf52_configuration_249())
   44d4c:	4a21      	ldr	r2, [pc, #132]	; (44dd4 <SystemInit+0x1b0>)
   44d4e:	5cd3      	ldrb	r3, [r2, r3]
   44d50:	b13b      	cbz	r3, 44d62 <SystemInit+0x13e>
            {
                /* Load APPROTECT soft branch from UICR.
                   If UICR->APPROTECT is disabled, POWER->APPROTECT will be disabled. */
                NRF_APPROTECT->DISABLE = NRF_UICR->APPROTECT;
   44d52:	f04f 2310 	mov.w	r3, #268439552	; 0x10001000
   44d56:	f8d3 2208 	ldr.w	r2, [r3, #520]	; 0x208
   44d5a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   44d5e:	f8c3 2558 	str.w	r2, [r3, #1368]	; 0x558

    /* Configure GPIO pads as pPin Reset pin if Pin Reset capabilities desired. If CONFIG_GPIO_AS_PINRESET is not
      defined, pin reset will not be available. One GPIO (see Product Specification to see which one) will then be
      reserved for PinReset and not available as normal GPIO. */
    #if defined (CONFIG_GPIO_AS_PINRESET)
        if (((NRF_UICR->PSELRESET[0] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos)) ||
   44d62:	f04f 2310 	mov.w	r3, #268439552	; 0x10001000
   44d66:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
   44d6a:	2a00      	cmp	r2, #0
   44d6c:	db03      	blt.n	44d76 <SystemInit+0x152>
            ((NRF_UICR->PSELRESET[1] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos))){
   44d6e:	f8d3 3204 	ldr.w	r3, [r3, #516]	; 0x204
        if (((NRF_UICR->PSELRESET[0] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos)) ||
   44d72:	2b00      	cmp	r3, #0
   44d74:	da22      	bge.n	44dbc <SystemInit+0x198>
    NRF_NVMC->CONFIG = mode << NVMC_CONFIG_WEN_Pos;
   44d76:	4918      	ldr	r1, [pc, #96]	; (44dd8 <SystemInit+0x1b4>)
   44d78:	2301      	movs	r3, #1
            nvmc_config(NVMC_CONFIG_WEN_Wen);
            NRF_UICR->PSELRESET[0] = RESET_PIN;
   44d7a:	f04f 2010 	mov.w	r0, #268439552	; 0x10001000
    NRF_NVMC->CONFIG = mode << NVMC_CONFIG_WEN_Pos;
   44d7e:	f8c1 3504 	str.w	r3, [r1, #1284]	; 0x504
            NRF_UICR->PSELRESET[0] = RESET_PIN;
   44d82:	2412      	movs	r4, #18
    nvmc_wait();
   44d84:	f7ff ff46 	bl	44c14 <nvmc_wait>
            NRF_UICR->PSELRESET[0] = RESET_PIN;
   44d88:	f8c0 4200 	str.w	r4, [r0, #512]	; 0x200
            nvmc_wait();
   44d8c:	f7ff ff42 	bl	44c14 <nvmc_wait>
            NRF_UICR->PSELRESET[1] = RESET_PIN;
   44d90:	f8c0 4204 	str.w	r4, [r0, #516]	; 0x204
            nvmc_wait();
   44d94:	f7ff ff3e 	bl	44c14 <nvmc_wait>
    NRF_NVMC->CONFIG = mode << NVMC_CONFIG_WEN_Pos;
   44d98:	2300      	movs	r3, #0
   44d9a:	f8c1 3504 	str.w	r3, [r1, #1284]	; 0x504
    nvmc_wait();
   44d9e:	f7ff ff39 	bl	44c14 <nvmc_wait>
  __ASM volatile ("dsb 0xF":::"memory");
   44da2:	f3bf 8f4f 	dsb	sy
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
   44da6:	490d      	ldr	r1, [pc, #52]	; (44ddc <SystemInit+0x1b8>)
   44da8:	4b0d      	ldr	r3, [pc, #52]	; (44de0 <SystemInit+0x1bc>)
   44daa:	68ca      	ldr	r2, [r1, #12]
   44dac:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
   44db0:	4313      	orrs	r3, r2
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
   44db2:	60cb      	str	r3, [r1, #12]
   44db4:	f3bf 8f4f 	dsb	sy
    __NOP();
   44db8:	bf00      	nop
  for(;;)                                                           /* wait until reset */
   44dba:	e7fd      	b.n	44db8 <SystemInit+0x194>
    SystemCoreClock = __SYSTEM_CLOCK_64M;
   44dbc:	4b09      	ldr	r3, [pc, #36]	; (44de4 <SystemInit+0x1c0>)
   44dbe:	4a0a      	ldr	r2, [pc, #40]	; (44de8 <SystemInit+0x1c4>)
   44dc0:	601a      	str	r2, [r3, #0]
            NVIC_SystemReset();
        }
    #endif

    SystemCoreClockUpdate();
}
   44dc2:	bd10      	pop	{r4, pc}
   44dc4:	40005000 	.word	0x40005000
   44dc8:	00038148 	.word	0x00038148
   44dcc:	4000f000 	.word	0x4000f000
   44dd0:	40029000 	.word	0x40029000
   44dd4:	00053898 	.word	0x00053898
   44dd8:	4001e000 	.word	0x4001e000
   44ddc:	e000ed00 	.word	0xe000ed00
   44de0:	05fa0004 	.word	0x05fa0004
   44de4:	20000d40 	.word	0x20000d40
   44de8:	03d09000 	.word	0x03d09000

00044dec <nrfx_flag32_alloc>:
{
    return (mask & NRFX_BIT(bitpos)) ? false : true;
}

nrfx_err_t nrfx_flag32_alloc(nrfx_atomic_t * p_mask, uint8_t *p_flag)
{
   44dec:	b570      	push	{r4, r5, r6, lr}
        idx = 31 - NRF_CLZ(prev_mask);
        if (idx < 0) {
            return NRFX_ERROR_NO_MEM;
        }

        new_mask = prev_mask & ~NRFX_BIT(idx);
   44dee:	2501      	movs	r5, #1
        prev_mask = *p_mask;
   44df0:	6802      	ldr	r2, [r0, #0]
	return __atomic_compare_exchange_n(target, &old_value, new_value,
   44df2:	f3bf 8f5b 	dmb	ish
        idx = 31 - NRF_CLZ(prev_mask);
   44df6:	fab2 f382 	clz	r3, r2
   44dfa:	f1c3 031f 	rsb	r3, r3, #31
   44dfe:	b2db      	uxtb	r3, r3
        new_mask = prev_mask & ~NRFX_BIT(idx);
   44e00:	fa05 f403 	lsl.w	r4, r5, r3
   44e04:	ea22 0404 	bic.w	r4, r2, r4
   44e08:	e850 6f00 	ldrex	r6, [r0]
   44e0c:	4296      	cmp	r6, r2
   44e0e:	d104      	bne.n	44e1a <nrfx_flag32_alloc+0x2e>
   44e10:	e840 4c00 	strex	ip, r4, [r0]
   44e14:	f1bc 0f00 	cmp.w	ip, #0
   44e18:	d1f6      	bne.n	44e08 <nrfx_flag32_alloc+0x1c>
   44e1a:	f3bf 8f5b 	dmb	ish
    } while (!NRFX_ATOMIC_CAS(p_mask, prev_mask, new_mask));
   44e1e:	d1e7      	bne.n	44df0 <nrfx_flag32_alloc+0x4>

    *p_flag = idx;

    return NRFX_SUCCESS;
}
   44e20:	4801      	ldr	r0, [pc, #4]	; (44e28 <nrfx_flag32_alloc+0x3c>)
    *p_flag = idx;
   44e22:	700b      	strb	r3, [r1, #0]
}
   44e24:	bd70      	pop	{r4, r5, r6, pc}
   44e26:	bf00      	nop
   44e28:	0bad0000 	.word	0x0bad0000

00044e2c <nrfx_flag32_free>:

nrfx_err_t nrfx_flag32_free(nrfx_atomic_t * p_mask, uint8_t flag)
{
   44e2c:	b510      	push	{r4, lr}
    uint32_t new_mask, prev_mask;

    if ((NRFX_BIT(flag) & *p_mask))
   44e2e:	6803      	ldr	r3, [r0, #0]
   44e30:	40cb      	lsrs	r3, r1
   44e32:	07db      	lsls	r3, r3, #31
   44e34:	d414      	bmi.n	44e60 <nrfx_flag32_free+0x34>
        return NRFX_ERROR_INVALID_PARAM;
    }

    do {
        prev_mask = *p_mask;
        new_mask = prev_mask | NRFX_BIT(flag);
   44e36:	2301      	movs	r3, #1
   44e38:	408b      	lsls	r3, r1
        prev_mask = *p_mask;
   44e3a:	6802      	ldr	r2, [r0, #0]
   44e3c:	f3bf 8f5b 	dmb	ish
        new_mask = prev_mask | NRFX_BIT(flag);
   44e40:	ea43 0102 	orr.w	r1, r3, r2
   44e44:	e850 4f00 	ldrex	r4, [r0]
   44e48:	4294      	cmp	r4, r2
   44e4a:	d104      	bne.n	44e56 <nrfx_flag32_free+0x2a>
   44e4c:	e840 1c00 	strex	ip, r1, [r0]
   44e50:	f1bc 0f00 	cmp.w	ip, #0
   44e54:	d1f6      	bne.n	44e44 <nrfx_flag32_free+0x18>
   44e56:	f3bf 8f5b 	dmb	ish
    } while (!NRFX_ATOMIC_CAS(p_mask, prev_mask, new_mask));
   44e5a:	d1ee      	bne.n	44e3a <nrfx_flag32_free+0xe>

    return NRFX_SUCCESS;
   44e5c:	4801      	ldr	r0, [pc, #4]	; (44e64 <nrfx_flag32_free+0x38>)
}
   44e5e:	bd10      	pop	{r4, pc}
        return NRFX_ERROR_INVALID_PARAM;
   44e60:	4801      	ldr	r0, [pc, #4]	; (44e68 <nrfx_flag32_free+0x3c>)
   44e62:	e7fc      	b.n	44e5e <nrfx_flag32_free+0x32>
   44e64:	0bad0000 	.word	0x0bad0000
   44e68:	0bad0004 	.word	0x0bad0004

00044e6c <clock_stop>:
    CoreDebug->DEMCR = core_debug;
}
#endif // NRFX_CHECK(USE_WORKAROUND_FOR_ANOMALY_132)

static void clock_stop(nrf_clock_domain_t domain)
{
   44e6c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    switch (domain)
   44e6e:	4604      	mov	r4, r0
   44e70:	b118      	cbz	r0, 44e7a <clock_stop+0xe>
   44e72:	2801      	cmp	r0, #1
   44e74:	d022      	beq.n	44ebc <clock_stop+0x50>
    if (domain == NRF_CLOCK_DOMAIN_HFCLK)
    {
            m_clock_cb.hfclk_started = false;
    }
#endif
}
   44e76:	b003      	add	sp, #12
   44e78:	bdf0      	pop	{r4, r5, r6, r7, pc}
    p_reg->INTENCLR = mask;
   44e7a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   44e7e:	2202      	movs	r2, #2
   44e80:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   44e84:	f8c3 0104 	str.w	r0, [r3, #260]	; 0x104
   44e88:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   44e8c:	2201      	movs	r2, #1
   44e8e:	60da      	str	r2, [r3, #12]
    nrf_clock_hfclk_t *p_clk_src = (domain == NRF_CLOCK_DOMAIN_HFCLK) ? &clk_src : NULL;
   44e90:	4607      	mov	r7, r0
    nrf_clock_hfclk_t clk_src = NRF_CLOCK_HFCLK_HIGH_ACCURACY;
   44e92:	2301      	movs	r3, #1
   44e94:	f88d 3007 	strb.w	r3, [sp, #7]
   44e98:	f242 7510 	movw	r5, #10000	; 0x2710
   44e9c:	f04f 4680 	mov.w	r6, #1073741824	; 0x40000000
    switch (domain)
   44ea0:	b1cc      	cbz	r4, 44ed6 <clock_stop+0x6a>
   44ea2:	2c01      	cmp	r4, #1
   44ea4:	d1e7      	bne.n	44e76 <clock_stop+0xa>
            if (p_clk_src != NULL)
   44ea6:	b3c7      	cbz	r7, 44f1a <clock_stop+0xae>
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
   44ea8:	f8d6 340c 	ldr.w	r3, [r6, #1036]	; 0x40c
   44eac:	f003 0301 	and.w	r3, r3, #1
                (*(nrf_clock_hfclk_t *)p_clk_src) =
   44eb0:	703b      	strb	r3, [r7, #0]
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
   44eb2:	f8d6 340c 	ldr.w	r3, [r6, #1036]	; 0x40c
   44eb6:	03da      	lsls	r2, r3, #15
   44eb8:	d521      	bpl.n	44efe <clock_stop+0x92>
   44eba:	e016      	b.n	44eea <clock_stop+0x7e>
    p_reg->INTENCLR = mask;
   44ebc:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   44ec0:	2200      	movs	r2, #0
    p_reg->INTENCLR = mask;
   44ec2:	f8c3 0308 	str.w	r0, [r3, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   44ec6:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
   44eca:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   44ece:	6058      	str	r0, [r3, #4]
    nrf_clock_hfclk_t *p_clk_src = (domain == NRF_CLOCK_DOMAIN_HFCLK) ? &clk_src : NULL;
   44ed0:	f10d 0707 	add.w	r7, sp, #7
   44ed4:	e7dd      	b.n	44e92 <clock_stop+0x26>
            if (p_clk_src != NULL)
   44ed6:	b1b7      	cbz	r7, 44f06 <clock_stop+0x9a>
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   44ed8:	f8d6 3418 	ldr.w	r3, [r6, #1048]	; 0x418
                                        >> CLOCK_LFCLKSTAT_SRC_Pos);
   44edc:	f003 0303 	and.w	r3, r3, #3
                (*(nrf_clock_lfclk_t *)p_clk_src) =
   44ee0:	603b      	str	r3, [r7, #0]
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   44ee2:	f8d6 3418 	ldr.w	r3, [r6, #1048]	; 0x418
   44ee6:	03d8      	lsls	r0, r3, #15
   44ee8:	d5c5      	bpl.n	44e76 <clock_stop+0xa>
    NRFX_WAIT_FOR((!nrfx_clock_is_running(domain, p_clk_src) ||
   44eea:	f89d 0007 	ldrb.w	r0, [sp, #7]
   44eee:	2801      	cmp	r0, #1
   44ef0:	d103      	bne.n	44efa <clock_stop+0x8e>
   44ef2:	f00a f9c7 	bl	4f284 <nrfx_busy_wait>
   44ef6:	3d01      	subs	r5, #1
   44ef8:	d1d2      	bne.n	44ea0 <clock_stop+0x34>
    if (domain == NRF_CLOCK_DOMAIN_HFCLK)
   44efa:	2c01      	cmp	r4, #1
   44efc:	d1bb      	bne.n	44e76 <clock_stop+0xa>
            m_clock_cb.hfclk_started = false;
   44efe:	4b0c      	ldr	r3, [pc, #48]	; (44f30 <clock_stop+0xc4>)
   44f00:	2200      	movs	r2, #0
   44f02:	715a      	strb	r2, [r3, #5]
   44f04:	e7b7      	b.n	44e76 <clock_stop+0xa>
   44f06:	f8d6 3418 	ldr.w	r3, [r6, #1048]	; 0x418
   44f0a:	03d9      	lsls	r1, r3, #15
   44f0c:	d5b3      	bpl.n	44e76 <clock_stop+0xa>
    NRFX_WAIT_FOR((!nrfx_clock_is_running(domain, p_clk_src) ||
   44f0e:	2001      	movs	r0, #1
   44f10:	f00a f9b8 	bl	4f284 <nrfx_busy_wait>
   44f14:	3d01      	subs	r5, #1
   44f16:	d1f6      	bne.n	44f06 <clock_stop+0x9a>
   44f18:	e7ad      	b.n	44e76 <clock_stop+0xa>
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
   44f1a:	f8d6 340c 	ldr.w	r3, [r6, #1036]	; 0x40c
   44f1e:	03db      	lsls	r3, r3, #15
   44f20:	d5ed      	bpl.n	44efe <clock_stop+0x92>
   44f22:	2001      	movs	r0, #1
   44f24:	f00a f9ae 	bl	4f284 <nrfx_busy_wait>
   44f28:	3d01      	subs	r5, #1
   44f2a:	d1f6      	bne.n	44f1a <clock_stop+0xae>
   44f2c:	e7e7      	b.n	44efe <clock_stop+0x92>
   44f2e:	bf00      	nop
   44f30:	20006680 	.word	0x20006680

00044f34 <nrfx_clock_init>:
nrfx_err_t nrfx_clock_init(nrfx_clock_event_handler_t event_handler)
{
    NRFX_ASSERT(event_handler);

    nrfx_err_t err_code = NRFX_SUCCESS;
    if (m_clock_cb.module_initialized)
   44f34:	4b04      	ldr	r3, [pc, #16]	; (44f48 <nrfx_clock_init+0x14>)
   44f36:	791a      	ldrb	r2, [r3, #4]
   44f38:	b922      	cbnz	r2, 44f44 <nrfx_clock_init+0x10>
    {
#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LF_CAL_ENABLED)
        m_clock_cb.cal_state = CAL_STATE_IDLE;
#endif
        m_clock_cb.event_handler = event_handler;
        m_clock_cb.module_initialized = true;
   44f3a:	2201      	movs	r2, #1
        m_clock_cb.event_handler = event_handler;
   44f3c:	6018      	str	r0, [r3, #0]
        m_clock_cb.module_initialized = true;
   44f3e:	809a      	strh	r2, [r3, #4]
    nrfx_err_t err_code = NRFX_SUCCESS;
   44f40:	4802      	ldr	r0, [pc, #8]	; (44f4c <nrfx_clock_init+0x18>)
   44f42:	4770      	bx	lr
        err_code = NRFX_ERROR_ALREADY_INITIALIZED;
   44f44:	4802      	ldr	r0, [pc, #8]	; (44f50 <nrfx_clock_init+0x1c>)
#endif
    }

    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
   44f46:	4770      	bx	lr
   44f48:	20006680 	.word	0x20006680
   44f4c:	0bad0000 	.word	0x0bad0000
   44f50:	0bad000c 	.word	0x0bad000c

00044f54 <nrfx_clock_enable>:

void nrfx_clock_enable(void)
{
   44f54:	b508      	push	{r3, lr}
    priority = NRFX_CLOCK_DEFAULT_CONFIG_IRQ_PRIORITY;
#else
    #error "This code is not supposed to be compiled when neither POWER nor CLOCK is enabled."
#endif

    if (!NRFX_IRQ_IS_ENABLED(nrfx_get_irq_number(NRF_CLOCK)))
   44f56:	2000      	movs	r0, #0
   44f58:	f7e7 ff4e 	bl	2cdf8 <arch_irq_is_enabled>
   44f5c:	b908      	cbnz	r0, 44f62 <nrfx_clock_enable+0xe>
    {
        NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(NRF_CLOCK), priority);
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_CLOCK));
   44f5e:	f7e7 ff29 	bl	2cdb4 <arch_irq_enable>
    p_reg->LFCLKSRC = (uint32_t)(source);
   44f62:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   44f66:	2200      	movs	r2, #0
   44f68:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
#endif
#if NRF_CLOCK_HAS_HFCLK192M
    nrf_clock_hfclk192m_src_set(NRF_CLOCK, (nrf_clock_hfclk_t)NRFX_CLOCK_CONFIG_HFCLK192M_SRC);
#endif
#if NRFX_CHECK(NRFX_POWER_ENABLED)
    nrfx_clock_irq_enabled = true;
   44f6c:	4b01      	ldr	r3, [pc, #4]	; (44f74 <nrfx_clock_enable+0x20>)
   44f6e:	2201      	movs	r2, #1
   44f70:	701a      	strb	r2, [r3, #0]
#endif

    NRFX_LOG_INFO("Module enabled.");
}
   44f72:	bd08      	pop	{r3, pc}
   44f74:	20006bba 	.word	0x20006bba

00044f78 <nrfx_clock_irq_handler>:
    }
}
#endif

void nrfx_clock_irq_handler(void)
{
   44f78:	b510      	push	{r4, lr}
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   44f7a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   44f7e:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKSTARTED))
   44f82:	b16a      	cbz	r2, 44fa0 <nrfx_clock_irq_handler+0x28>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   44f84:	2200      	movs	r2, #0
   44f86:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
   44f8a:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    p_reg->INTENCLR = mask;
   44f8e:	2201      	movs	r2, #1
   44f90:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
        nrf_clock_event_clear(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKSTARTED);
        NRFX_LOG_DEBUG("Event: NRF_CLOCK_EVENT_HFCLKSTARTED");
        nrf_clock_int_disable(NRF_CLOCK, NRF_CLOCK_INT_HF_STARTED_MASK);

#if NRFX_CHECK(USE_WORKAROUND_FOR_ANOMALY_201)
        if (!m_clock_cb.hfclk_started)
   44f94:	4b11      	ldr	r3, [pc, #68]	; (44fdc <nrfx_clock_irq_handler+0x64>)
   44f96:	7958      	ldrb	r0, [r3, #5]
   44f98:	b910      	cbnz	r0, 44fa0 <nrfx_clock_irq_handler+0x28>
        {
            m_clock_cb.hfclk_started = true;
   44f9a:	715a      	strb	r2, [r3, #5]
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
   44f9c:	681b      	ldr	r3, [r3, #0]
   44f9e:	4798      	blx	r3
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   44fa0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   44fa4:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
        }
#else
        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
#endif
    }
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_LFCLKSTARTED))
   44fa8:	b172      	cbz	r2, 44fc8 <nrfx_clock_irq_handler+0x50>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   44faa:	2200      	movs	r2, #0
   44fac:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
   44fb0:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   44fb4:	f8d3 2418 	ldr.w	r2, [r3, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   44fb8:	f8d3 1418 	ldr.w	r1, [r3, #1048]	; 0x418
        NRFX_LOG_DEBUG("Event: NRF_CLOCK_EVENT_LFCLKSTARTED");

#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LFXO_TWO_STAGE_ENABLED)
        nrf_clock_lfclk_t lfclksrc;
        (void)nrf_clock_is_running(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK, &lfclksrc);
        if (lfclksrc == NRF_CLOCK_LFCLK_RC)
   44fbc:	0792      	lsls	r2, r2, #30
   44fbe:	d104      	bne.n	44fca <nrfx_clock_irq_handler+0x52>
    p_reg->LFCLKSRC = (uint32_t)(source);
   44fc0:	2201      	movs	r2, #1
   44fc2:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   44fc6:	609a      	str	r2, [r3, #8]
        nrf_clock_int_disable(NRF_CLOCK, NRF_CLOCK_INT_HF192M_STARTED_MASK);

        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK192M_STARTED);
    }
#endif
}
   44fc8:	bd10      	pop	{r4, pc}
    p_reg->INTENCLR = mask;
   44fca:	2202      	movs	r2, #2
   44fcc:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_LFCLK_STARTED);
   44fd0:	4b02      	ldr	r3, [pc, #8]	; (44fdc <nrfx_clock_irq_handler+0x64>)
}
   44fd2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_LFCLK_STARTED);
   44fd6:	681b      	ldr	r3, [r3, #0]
   44fd8:	2001      	movs	r0, #1
   44fda:	4718      	bx	r3
   44fdc:	20006680 	.word	0x20006680

00044fe0 <nrf_gpio_pin_port_decode>:
    uint32_t pin_number = *p_pin;
   44fe0:	6803      	ldr	r3, [r0, #0]
    *p_pin = pin_number & 0x1F;
   44fe2:	f003 021f 	and.w	r2, r3, #31
    return pin_number >> 5;
   44fe6:	095b      	lsrs	r3, r3, #5
        case 0: return NRF_P0;
   44fe8:	2b01      	cmp	r3, #1
    *p_pin = pin_number & 0x1F;
   44fea:	6002      	str	r2, [r0, #0]
}
   44fec:	4802      	ldr	r0, [pc, #8]	; (44ff8 <nrf_gpio_pin_port_decode+0x18>)
   44fee:	bf18      	it	ne
   44ff0:	f04f 40a0 	movne.w	r0, #1342177280	; 0x50000000
   44ff4:	4770      	bx	lr
   44ff6:	bf00      	nop
   44ff8:	50000300 	.word	0x50000300

00044ffc <pin_in_use_by_te>:
 *
 * @return True if pin uses GPIOTE task/event.
 */
static bool pin_in_use_by_te(uint32_t pin)
{
    return m_cb.pin_flags[pin] & PIN_FLAG_TE_USED;
   44ffc:	4b03      	ldr	r3, [pc, #12]	; (4500c <pin_in_use_by_te+0x10>)
   44ffe:	3008      	adds	r0, #8
   45000:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
}
   45004:	f3c0 1040 	ubfx	r0, r0, #5, #1
   45008:	4770      	bx	lr
   4500a:	bf00      	nop
   4500c:	20000d44 	.word	0x20000d44

00045010 <call_handler>:
    nrf_gpiote_event_t event = nrfx_gpiote_in_event_get(pin);
    return nrf_gpiote_event_address_get(NRF_GPIOTE, event);
}

static void call_handler(nrfx_gpiote_pin_t pin, nrfx_gpiote_trigger_t trigger)
{
   45010:	b570      	push	{r4, r5, r6, lr}
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   45012:	f100 0308 	add.w	r3, r0, #8
   45016:	4c0c      	ldr	r4, [pc, #48]	; (45048 <call_handler+0x38>)
   45018:	f834 3013 	ldrh.w	r3, [r4, r3, lsl #1]
   4501c:	05da      	lsls	r2, r3, #23
{
   4501e:	4605      	mov	r5, r0
   45020:	460e      	mov	r6, r1
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   45022:	d507      	bpl.n	45034 <call_handler+0x24>
   45024:	f3c3 2343 	ubfx	r3, r3, #9, #4
    nrfx_gpiote_handler_config_t const * handler = channel_handler_get(pin);

    if (handler)
    {
        handler->handler(pin, trigger, handler->p_context);
   45028:	eb04 02c3 	add.w	r2, r4, r3, lsl #3
   4502c:	f854 3033 	ldr.w	r3, [r4, r3, lsl #3]
   45030:	6852      	ldr	r2, [r2, #4]
   45032:	4798      	blx	r3
    }
    if (m_cb.global_handler.handler)
   45034:	68a3      	ldr	r3, [r4, #8]
   45036:	b12b      	cbz	r3, 45044 <call_handler+0x34>
    {
        m_cb.global_handler.handler(pin, trigger, m_cb.global_handler.p_context);
   45038:	68e2      	ldr	r2, [r4, #12]
   4503a:	4631      	mov	r1, r6
   4503c:	4628      	mov	r0, r5
    }
}
   4503e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        m_cb.global_handler.handler(pin, trigger, m_cb.global_handler.p_context);
   45042:	4718      	bx	r3
}
   45044:	bd70      	pop	{r4, r5, r6, pc}
   45046:	bf00      	nop
   45048:	20000d44 	.word	0x20000d44

0004504c <release_handler>:
{
   4504c:	b410      	push	{r4}
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   4504e:	4a12      	ldr	r2, [pc, #72]	; (45098 <release_handler+0x4c>)
   45050:	3008      	adds	r0, #8
   45052:	f832 3010 	ldrh.w	r3, [r2, r0, lsl #1]
   45056:	05d9      	lsls	r1, r3, #23
   45058:	d51b      	bpl.n	45092 <release_handler+0x46>
   4505a:	f3c3 2143 	ubfx	r1, r3, #9, #4
    m_cb.pin_flags[pin] &= ~PIN_HANDLER_MASK;
   4505e:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
   45062:	f822 3010 	strh.w	r3, [r2, r0, lsl #1]
    for (uint32_t i = 0; i < MAX_PIN_NUMBER; i++)
   45066:	f102 040e 	add.w	r4, r2, #14
   4506a:	2000      	movs	r0, #0
        if (PIN_GET_HANDLER_ID(m_cb.pin_flags[i]) == handler_id)
   4506c:	f834 3f02 	ldrh.w	r3, [r4, #2]!
   45070:	f413 7f80 	tst.w	r3, #256	; 0x100
   45074:	d003      	beq.n	4507e <release_handler+0x32>
   45076:	f3c3 2343 	ubfx	r3, r3, #9, #4
   4507a:	4299      	cmp	r1, r3
   4507c:	d009      	beq.n	45092 <release_handler+0x46>
    for (uint32_t i = 0; i < MAX_PIN_NUMBER; i++)
   4507e:	3001      	adds	r0, #1
   45080:	2830      	cmp	r0, #48	; 0x30
   45082:	d1f3      	bne.n	4506c <release_handler+0x20>
        m_cb.handlers[handler_id].handler = NULL;
   45084:	2300      	movs	r3, #0
   45086:	f842 3031 	str.w	r3, [r2, r1, lsl #3]
        nrfx_err_t err = nrfx_flag32_free(&m_cb.available_evt_handlers, handler_id);
   4508a:	4804      	ldr	r0, [pc, #16]	; (4509c <release_handler+0x50>)
}
   4508c:	bc10      	pop	{r4}
        nrfx_err_t err = nrfx_flag32_free(&m_cb.available_evt_handlers, handler_id);
   4508e:	f7ff becd 	b.w	44e2c <nrfx_flag32_free>
}
   45092:	bc10      	pop	{r4}
   45094:	4770      	bx	lr
   45096:	bf00      	nop
   45098:	20000d44 	.word	0x20000d44
   4509c:	20000db8 	.word	0x20000db8

000450a0 <pin_handler_trigger_uninit>:
{
   450a0:	b538      	push	{r3, r4, r5, lr}
   450a2:	4602      	mov	r2, r0
    if (pin_in_use_by_te(pin))
   450a4:	f7ff ffaa 	bl	44ffc <pin_in_use_by_te>
   450a8:	4c09      	ldr	r4, [pc, #36]	; (450d0 <pin_handler_trigger_uninit+0x30>)
   450aa:	f102 0508 	add.w	r5, r2, #8
   450ae:	b140      	cbz	r0, 450c2 <pin_handler_trigger_uninit+0x22>
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   450b0:	f834 3015 	ldrh.w	r3, [r4, r5, lsl #1]
                         ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
}

NRF_STATIC_INLINE void nrf_gpiote_te_default(NRF_GPIOTE_Type * p_reg, uint32_t idx)
{
    p_reg->CONFIG[idx] = 0;
   450b4:	4907      	ldr	r1, [pc, #28]	; (450d4 <pin_handler_trigger_uninit+0x34>)
        nrf_gpiote_te_default(NRF_GPIOTE, pin_te_get(pin));
   450b6:	0b5b      	lsrs	r3, r3, #13
   450b8:	f503 73a2 	add.w	r3, r3, #324	; 0x144
   450bc:	2000      	movs	r0, #0
   450be:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
    release_handler(pin);
   450c2:	4610      	mov	r0, r2
   450c4:	f7ff ffc2 	bl	4504c <release_handler>
    m_cb.pin_flags[pin] = PIN_FLAG_NOT_USED;
   450c8:	2300      	movs	r3, #0
   450ca:	f824 3015 	strh.w	r3, [r4, r5, lsl #1]
}
   450ce:	bd38      	pop	{r3, r4, r5, pc}
   450d0:	20000d44 	.word	0x20000d44
   450d4:	40006000 	.word	0x40006000

000450d8 <nrfx_gpiote_input_configure>:
{
   450d8:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
   450dc:	4604      	mov	r4, r0
   450de:	4616      	mov	r6, r2
   450e0:	461d      	mov	r5, r3
    if (p_input_config)
   450e2:	b301      	cbz	r1, 45126 <nrfx_gpiote_input_configure+0x4e>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   450e4:	4f4e      	ldr	r7, [pc, #312]	; (45220 <nrfx_gpiote_input_configure+0x148>)
   450e6:	f100 0808 	add.w	r8, r0, #8
    return pin_is_output(pin) && pin_in_use_by_te(pin);
   450ea:	f837 3018 	ldrh.w	r3, [r7, r8, lsl #1]
   450ee:	079b      	lsls	r3, r3, #30
   450f0:	d502      	bpl.n	450f8 <nrfx_gpiote_input_configure+0x20>
   450f2:	f7ff ff83 	bl	44ffc <pin_in_use_by_te>
   450f6:	bb10      	cbnz	r0, 4513e <nrfx_gpiote_input_configure+0x66>
        nrf_gpio_pin_dir_t dir = NRF_GPIO_PIN_DIR_INPUT;
   450f8:	2300      	movs	r3, #0
        nrf_gpio_reconfigure(pin, &dir, &input_connect, &p_input_config->pull, NULL, NULL);
   450fa:	e9cd 3300 	strd	r3, r3, [sp]
        nrf_gpio_pin_dir_t dir = NRF_GPIO_PIN_DIR_INPUT;
   450fe:	f88d 300e 	strb.w	r3, [sp, #14]
        nrf_gpio_pin_input_t input_connect = NRF_GPIO_PIN_INPUT_CONNECT;
   45102:	f88d 300f 	strb.w	r3, [sp, #15]
        nrf_gpio_reconfigure(pin, &dir, &input_connect, &p_input_config->pull, NULL, NULL);
   45106:	f10d 020f 	add.w	r2, sp, #15
   4510a:	460b      	mov	r3, r1
   4510c:	4620      	mov	r0, r4
   4510e:	f10d 010e 	add.w	r1, sp, #14
   45112:	f00a f8f7 	bl	4f304 <nrf_gpio_reconfigure>
        m_cb.pin_flags[pin] &= ~PIN_FLAG_OUTPUT;
   45116:	f837 3018 	ldrh.w	r3, [r7, r8, lsl #1]
   4511a:	f023 0302 	bic.w	r3, r3, #2
        m_cb.pin_flags[pin] |= PIN_FLAG_IN_USE;
   4511e:	f043 0301 	orr.w	r3, r3, #1
   45122:	f827 3018 	strh.w	r3, [r7, r8, lsl #1]
    if (p_trigger_config)
   45126:	b346      	cbz	r6, 4517a <nrfx_gpiote_input_configure+0xa2>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   45128:	4b3d      	ldr	r3, [pc, #244]	; (45220 <nrfx_gpiote_input_configure+0x148>)
        nrfx_gpiote_trigger_t trigger = p_trigger_config->trigger;
   4512a:	f896 c000 	ldrb.w	ip, [r6]
        bool use_evt = p_trigger_config->p_in_channel ? true : false;
   4512e:	6872      	ldr	r2, [r6, #4]
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   45130:	f104 0708 	add.w	r7, r4, #8
   45134:	f833 1017 	ldrh.w	r1, [r3, r7, lsl #1]
        if (pin_is_output(pin))
   45138:	0788      	lsls	r0, r1, #30
   4513a:	d502      	bpl.n	45142 <nrfx_gpiote_input_configure+0x6a>
            if (use_evt)
   4513c:	b1aa      	cbz	r2, 4516a <nrfx_gpiote_input_configure+0x92>
            return NRFX_ERROR_INVALID_PARAM;
   4513e:	4839      	ldr	r0, [pc, #228]	; (45224 <nrfx_gpiote_input_configure+0x14c>)
   45140:	e01d      	b.n	4517e <nrfx_gpiote_input_configure+0xa6>
            m_cb.pin_flags[pin] &= ~(PIN_TE_ID_MASK | PIN_FLAG_TE_USED);
   45142:	f021 0120 	bic.w	r1, r1, #32
   45146:	04c9      	lsls	r1, r1, #19
   45148:	0cc9      	lsrs	r1, r1, #19
   4514a:	f823 1017 	strh.w	r1, [r3, r7, lsl #1]
            if (use_evt)
   4514e:	b162      	cbz	r2, 4516a <nrfx_gpiote_input_configure+0x92>
                if (!edge)
   45150:	f1bc 0f03 	cmp.w	ip, #3
   45154:	d8f3      	bhi.n	4513e <nrfx_gpiote_input_configure+0x66>
                uint8_t ch = *p_trigger_config->p_in_channel;
   45156:	6872      	ldr	r2, [r6, #4]
   45158:	7816      	ldrb	r6, [r2, #0]
                if (trigger == NRFX_GPIOTE_TRIGGER_NONE)
   4515a:	f1bc 0f00 	cmp.w	ip, #0
   4515e:	d111      	bne.n	45184 <nrfx_gpiote_input_configure+0xac>
   45160:	4a31      	ldr	r2, [pc, #196]	; (45228 <nrfx_gpiote_input_configure+0x150>)
   45162:	f506 76a2 	add.w	r6, r6, #324	; 0x144
   45166:	f842 c026 	str.w	ip, [r2, r6, lsl #2]
        m_cb.pin_flags[pin] &= ~PIN_FLAG_TRIG_MODE_MASK;
   4516a:	f833 2017 	ldrh.w	r2, [r3, r7, lsl #1]
   4516e:	f022 021c 	bic.w	r2, r2, #28
        m_cb.pin_flags[pin] |= PIN_FLAG_TRIG_MODE_SET(trigger);
   45172:	ea42 028c 	orr.w	r2, r2, ip, lsl #2
   45176:	f823 2017 	strh.w	r2, [r3, r7, lsl #1]
    if (p_handler_config)
   4517a:	bb45      	cbnz	r5, 451ce <nrfx_gpiote_input_configure+0xf6>
        err = NRFX_SUCCESS;
   4517c:	482b      	ldr	r0, [pc, #172]	; (4522c <nrfx_gpiote_input_configure+0x154>)
}
   4517e:	b004      	add	sp, #16
   45180:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Msk;
   45184:	00b2      	lsls	r2, r6, #2
   45186:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
   4518a:	f502 42c0 	add.w	r2, r2, #24576	; 0x6000
                    m_cb.pin_flags[pin] |= PIN_FLAG_TE_ID(ch);
   4518e:	ea41 3146 	orr.w	r1, r1, r6, lsl #13
   45192:	f8d2 0510 	ldr.w	r0, [r2, #1296]	; 0x510
   45196:	f020 0003 	bic.w	r0, r0, #3
   4519a:	f8c2 0510 	str.w	r0, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
   4519e:	f8d2 0510 	ldr.w	r0, [r2, #1296]	; 0x510
   451a2:	f420 304f 	bic.w	r0, r0, #211968	; 0x33c00
   451a6:	f420 7040 	bic.w	r0, r0, #768	; 0x300
   451aa:	f8c2 0510 	str.w	r0, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   451ae:	0220      	lsls	r0, r4, #8
   451b0:	f8d2 e510 	ldr.w	lr, [r2, #1296]	; 0x510
   451b4:	f400 507c 	and.w	r0, r0, #16128	; 0x3f00
   451b8:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
   451bc:	ea40 000e 	orr.w	r0, r0, lr
   451c0:	f041 0120 	orr.w	r1, r1, #32
   451c4:	f823 1017 	strh.w	r1, [r3, r7, lsl #1]
   451c8:	f8c2 0510 	str.w	r0, [r2, #1296]	; 0x510
   451cc:	e7cd      	b.n	4516a <nrfx_gpiote_input_configure+0x92>
        err = pin_handler_set(pin, p_handler_config->handler, p_handler_config->p_context);
   451ce:	e9d5 6700 	ldrd	r6, r7, [r5]
    release_handler(pin);
   451d2:	4620      	mov	r0, r4
   451d4:	f7ff ff3a 	bl	4504c <release_handler>
    if (!handler)
   451d8:	2e00      	cmp	r6, #0
   451da:	d0cf      	beq.n	4517c <nrfx_gpiote_input_configure+0xa4>
        if ((m_cb.handlers[i].handler == handler) && (m_cb.handlers[i].p_context == p_context))
   451dc:	4d10      	ldr	r5, [pc, #64]	; (45220 <nrfx_gpiote_input_configure+0x148>)
   451de:	e9d5 2300 	ldrd	r2, r3, [r5]
   451e2:	4296      	cmp	r6, r2
   451e4:	d101      	bne.n	451ea <nrfx_gpiote_input_configure+0x112>
   451e6:	429f      	cmp	r7, r3
   451e8:	d018      	beq.n	4521c <nrfx_gpiote_input_configure+0x144>
        err = nrfx_flag32_alloc(&m_cb.available_evt_handlers, &id);
   451ea:	4811      	ldr	r0, [pc, #68]	; (45230 <nrfx_gpiote_input_configure+0x158>)
   451ec:	f10d 010f 	add.w	r1, sp, #15
   451f0:	f7ff fdfc 	bl	44dec <nrfx_flag32_alloc>
        if (err != NRFX_SUCCESS)
   451f4:	4b0d      	ldr	r3, [pc, #52]	; (4522c <nrfx_gpiote_input_configure+0x154>)
   451f6:	4298      	cmp	r0, r3
   451f8:	d1c1      	bne.n	4517e <nrfx_gpiote_input_configure+0xa6>
        handler_id = (int32_t)id;
   451fa:	f89d 200f 	ldrb.w	r2, [sp, #15]
    m_cb.handlers[handler_id].handler = handler;
   451fe:	f845 6032 	str.w	r6, [r5, r2, lsl #3]
    m_cb.handlers[handler_id].p_context = p_context;
   45202:	eb05 03c2 	add.w	r3, r5, r2, lsl #3
    m_cb.pin_flags[pin] |= PIN_FLAG_HANDLER(handler_id);
   45206:	3408      	adds	r4, #8
    m_cb.handlers[handler_id].p_context = p_context;
   45208:	605f      	str	r7, [r3, #4]
    m_cb.pin_flags[pin] |= PIN_FLAG_HANDLER(handler_id);
   4520a:	f835 3014 	ldrh.w	r3, [r5, r4, lsl #1]
   4520e:	ea43 2342 	orr.w	r3, r3, r2, lsl #9
   45212:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   45216:	f825 3014 	strh.w	r3, [r5, r4, lsl #1]
    return NRFX_SUCCESS;
   4521a:	e7af      	b.n	4517c <nrfx_gpiote_input_configure+0xa4>
        if ((m_cb.handlers[i].handler == handler) && (m_cb.handlers[i].p_context == p_context))
   4521c:	2200      	movs	r2, #0
   4521e:	e7ee      	b.n	451fe <nrfx_gpiote_input_configure+0x126>
   45220:	20000d44 	.word	0x20000d44
   45224:	0bad0004 	.word	0x0bad0004
   45228:	40006000 	.word	0x40006000
   4522c:	0bad0000 	.word	0x0bad0000
   45230:	20000db8 	.word	0x20000db8

00045234 <nrfx_gpiote_output_configure>:
{
   45234:	b5f0      	push	{r4, r5, r6, r7, lr}
   45236:	4604      	mov	r4, r0
   45238:	b085      	sub	sp, #20
   4523a:	4615      	mov	r5, r2
    if (p_config)
   4523c:	b319      	cbz	r1, 45286 <nrfx_gpiote_output_configure+0x52>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   4523e:	4e33      	ldr	r6, [pc, #204]	; (4530c <nrfx_gpiote_output_configure+0xd8>)
   45240:	f100 0708 	add.w	r7, r0, #8
   45244:	f836 2017 	ldrh.w	r2, [r6, r7, lsl #1]
        if (pin_is_input(pin) && pin_in_use_by_te(pin))
   45248:	0793      	lsls	r3, r2, #30
   4524a:	d403      	bmi.n	45254 <nrfx_gpiote_output_configure+0x20>
   4524c:	f7ff fed6 	bl	44ffc <pin_in_use_by_te>
   45250:	2800      	cmp	r0, #0
   45252:	d158      	bne.n	45306 <nrfx_gpiote_output_configure+0xd2>
        if (pin_has_trigger(pin) && (p_config->input_connect == NRF_GPIO_PIN_INPUT_DISCONNECT))
   45254:	f012 0f1c 	tst.w	r2, #28
   45258:	d002      	beq.n	45260 <nrfx_gpiote_output_configure+0x2c>
   4525a:	784b      	ldrb	r3, [r1, #1]
   4525c:	2b01      	cmp	r3, #1
   4525e:	d052      	beq.n	45306 <nrfx_gpiote_output_configure+0xd2>
        nrf_gpio_pin_dir_t dir = NRF_GPIO_PIN_DIR_OUTPUT;
   45260:	2301      	movs	r3, #1
   45262:	f88d 300f 	strb.w	r3, [sp, #15]
        nrf_gpio_reconfigure(pin, &dir, &p_config->input_connect, &p_config->pull,
   45266:	2300      	movs	r3, #0
   45268:	e9cd 1300 	strd	r1, r3, [sp]
   4526c:	1c4a      	adds	r2, r1, #1
   4526e:	1c8b      	adds	r3, r1, #2
   45270:	4620      	mov	r0, r4
   45272:	f10d 010f 	add.w	r1, sp, #15
   45276:	f00a f845 	bl	4f304 <nrf_gpio_reconfigure>
        m_cb.pin_flags[pin] |= PIN_FLAG_IN_USE | PIN_FLAG_OUTPUT;
   4527a:	f836 3017 	ldrh.w	r3, [r6, r7, lsl #1]
   4527e:	f043 0303 	orr.w	r3, r3, #3
   45282:	f826 3017 	strh.w	r3, [r6, r7, lsl #1]
    if (p_task_config)
   45286:	b915      	cbnz	r5, 4528e <nrfx_gpiote_output_configure+0x5a>
    return NRFX_SUCCESS;
   45288:	4821      	ldr	r0, [pc, #132]	; (45310 <nrfx_gpiote_output_configure+0xdc>)
}
   4528a:	b005      	add	sp, #20
   4528c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   4528e:	4e1f      	ldr	r6, [pc, #124]	; (4530c <nrfx_gpiote_output_configure+0xd8>)
   45290:	f104 0708 	add.w	r7, r4, #8
   45294:	f836 0017 	ldrh.w	r0, [r6, r7, lsl #1]
        if (pin_is_input(pin))
   45298:	0783      	lsls	r3, r0, #30
   4529a:	d534      	bpl.n	45306 <nrfx_gpiote_output_configure+0xd2>
        uint32_t ch = p_task_config->task_ch;
   4529c:	f895 c000 	ldrb.w	ip, [r5]
    p_reg->CONFIG[idx] = 0;
   452a0:	4661      	mov	r1, ip
   452a2:	0089      	lsls	r1, r1, #2
        m_cb.pin_flags[pin] &= ~(PIN_FLAG_TE_USED | PIN_TE_ID_MASK);
   452a4:	f020 0020 	bic.w	r0, r0, #32
   452a8:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
   452ac:	04c0      	lsls	r0, r0, #19
   452ae:	f501 41c0 	add.w	r1, r1, #24576	; 0x6000
   452b2:	0cc0      	lsrs	r0, r0, #19
   452b4:	f826 0017 	strh.w	r0, [r6, r7, lsl #1]
   452b8:	2300      	movs	r3, #0
   452ba:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
        if (p_task_config->polarity != NRF_GPIOTE_POLARITY_NONE)
   452be:	786a      	ldrb	r2, [r5, #1]
   452c0:	2a00      	cmp	r2, #0
   452c2:	d0e1      	beq.n	45288 <nrfx_gpiote_output_configure+0x54>
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk |
   452c4:	f8d1 3510 	ldr.w	r3, [r1, #1296]	; 0x510
                                      p_task_config->init_val);
   452c8:	78ad      	ldrb	r5, [r5, #2]
   452ca:	f423 1399 	bic.w	r3, r3, #1253376	; 0x132000
   452ce:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
   452d2:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   452d6:	f8d1 e510 	ldr.w	lr, [r1, #1296]	; 0x510
   452da:	0223      	lsls	r3, r4, #8
   452dc:	f403 537c 	and.w	r3, r3, #16128	; 0x3f00
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk) |
   452e0:	0412      	lsls	r2, r2, #16
   452e2:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   452e6:	ea43 030e 	orr.w	r3, r3, lr
   452ea:	4313      	orrs	r3, r2
                        ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
   452ec:	052a      	lsls	r2, r5, #20
   452ee:	f402 1280 	and.w	r2, r2, #1048576	; 0x100000
            m_cb.pin_flags[pin] |= PIN_FLAG_TE_ID(ch);
   452f2:	ea40 304c 	orr.w	r0, r0, ip, lsl #13
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   452f6:	4313      	orrs	r3, r2
   452f8:	f040 0020 	orr.w	r0, r0, #32
   452fc:	f826 0017 	strh.w	r0, [r6, r7, lsl #1]
   45300:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
   45304:	e7c0      	b.n	45288 <nrfx_gpiote_output_configure+0x54>
{
   45306:	4803      	ldr	r0, [pc, #12]	; (45314 <nrfx_gpiote_output_configure+0xe0>)
   45308:	e7bf      	b.n	4528a <nrfx_gpiote_output_configure+0x56>
   4530a:	bf00      	nop
   4530c:	20000d44 	.word	0x20000d44
   45310:	0bad0000 	.word	0x0bad0000
   45314:	0bad0004 	.word	0x0bad0004

00045318 <nrfx_gpiote_global_callback_set>:
    m_cb.global_handler.handler = handler;
   45318:	4b01      	ldr	r3, [pc, #4]	; (45320 <nrfx_gpiote_global_callback_set+0x8>)
    m_cb.global_handler.p_context = p_context;
   4531a:	e9c3 0102 	strd	r0, r1, [r3, #8]
}
   4531e:	4770      	bx	lr
   45320:	20000d44 	.word	0x20000d44

00045324 <nrfx_gpiote_channel_get>:
{
   45324:	b508      	push	{r3, lr}
   45326:	4602      	mov	r2, r0
    if (pin_in_use_by_te(pin))
   45328:	f7ff fe68 	bl	44ffc <pin_in_use_by_te>
   4532c:	b138      	cbz	r0, 4533e <nrfx_gpiote_channel_get+0x1a>
        *p_channel = PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   4532e:	4b05      	ldr	r3, [pc, #20]	; (45344 <nrfx_gpiote_channel_get+0x20>)
        return NRFX_SUCCESS;
   45330:	4805      	ldr	r0, [pc, #20]	; (45348 <nrfx_gpiote_channel_get+0x24>)
        *p_channel = PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   45332:	3208      	adds	r2, #8
   45334:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
   45338:	0b5b      	lsrs	r3, r3, #13
   4533a:	700b      	strb	r3, [r1, #0]
}
   4533c:	bd08      	pop	{r3, pc}
        return NRFX_ERROR_INVALID_PARAM;
   4533e:	4803      	ldr	r0, [pc, #12]	; (4534c <nrfx_gpiote_channel_get+0x28>)
   45340:	e7fc      	b.n	4533c <nrfx_gpiote_channel_get+0x18>
   45342:	bf00      	nop
   45344:	20000d44 	.word	0x20000d44
   45348:	0bad0000 	.word	0x0bad0000
   4534c:	0bad0004 	.word	0x0bad0004

00045350 <nrfx_gpiote_init>:
{
   45350:	b538      	push	{r3, r4, r5, lr}
    if (m_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
   45352:	4c0f      	ldr	r4, [pc, #60]	; (45390 <nrfx_gpiote_init+0x40>)
   45354:	f894 5078 	ldrb.w	r5, [r4, #120]	; 0x78
   45358:	b9bd      	cbnz	r5, 4538a <nrfx_gpiote_init+0x3a>
    memset(m_cb.pin_flags, 0, sizeof(m_cb.pin_flags));
   4535a:	2260      	movs	r2, #96	; 0x60
   4535c:	4629      	mov	r1, r5
   4535e:	f104 0010 	add.w	r0, r4, #16
   45362:	f005 fd95 	bl	4ae90 <memset>
    NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_GPIOTE));
   45366:	2006      	movs	r0, #6
   45368:	f7e7 fd24 	bl	2cdb4 <arch_irq_enable>
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   4536c:	4b09      	ldr	r3, [pc, #36]	; (45394 <nrfx_gpiote_init+0x44>)
    return err_code;
   4536e:	480a      	ldr	r0, [pc, #40]	; (45398 <nrfx_gpiote_init+0x48>)
   45370:	f8c3 517c 	str.w	r5, [r3, #380]	; 0x17c
   45374:	f8d3 217c 	ldr.w	r2, [r3, #380]	; 0x17c
    p_reg->INTENSET = mask;
   45378:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
   4537c:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    m_cb.state = NRFX_DRV_STATE_INITIALIZED;
   45380:	2301      	movs	r3, #1
   45382:	f884 3078 	strb.w	r3, [r4, #120]	; 0x78
    m_cb.available_evt_handlers = NRFX_BIT_MASK(NRFX_GPIOTE_CONFIG_NUM_OF_EVT_HANDLERS);
   45386:	6763      	str	r3, [r4, #116]	; 0x74
}
   45388:	bd38      	pop	{r3, r4, r5, pc}
        return err_code;
   4538a:	4804      	ldr	r0, [pc, #16]	; (4539c <nrfx_gpiote_init+0x4c>)
   4538c:	e7fc      	b.n	45388 <nrfx_gpiote_init+0x38>
   4538e:	bf00      	nop
   45390:	20000d44 	.word	0x20000d44
   45394:	40006000 	.word	0x40006000
   45398:	0bad0000 	.word	0x0bad0000
   4539c:	0bad0005 	.word	0x0bad0005

000453a0 <nrfx_gpiote_is_init>:
    return (m_cb.state != NRFX_DRV_STATE_UNINITIALIZED) ? true : false;
   453a0:	4b03      	ldr	r3, [pc, #12]	; (453b0 <nrfx_gpiote_is_init+0x10>)
   453a2:	f893 0078 	ldrb.w	r0, [r3, #120]	; 0x78
}
   453a6:	3800      	subs	r0, #0
   453a8:	bf18      	it	ne
   453aa:	2001      	movne	r0, #1
   453ac:	4770      	bx	lr
   453ae:	bf00      	nop
   453b0:	20000d44 	.word	0x20000d44

000453b4 <nrfx_gpiote_channel_free>:
{
   453b4:	4601      	mov	r1, r0
    return nrfx_flag32_free(&m_cb.available_channels_mask, channel);
   453b6:	4801      	ldr	r0, [pc, #4]	; (453bc <nrfx_gpiote_channel_free+0x8>)
   453b8:	f7ff bd38 	b.w	44e2c <nrfx_flag32_free>
   453bc:	20000db4 	.word	0x20000db4

000453c0 <nrfx_gpiote_channel_alloc>:
{
   453c0:	4601      	mov	r1, r0
    return nrfx_flag32_alloc(&m_cb.available_channels_mask, p_channel);
   453c2:	4801      	ldr	r0, [pc, #4]	; (453c8 <nrfx_gpiote_channel_alloc+0x8>)
   453c4:	f7ff bd12 	b.w	44dec <nrfx_flag32_alloc>
   453c8:	20000db4 	.word	0x20000db4

000453cc <nrfx_gpiote_trigger_enable>:
{
   453cc:	b537      	push	{r0, r1, r2, r4, r5, lr}
   453ce:	4604      	mov	r4, r0
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
   453d0:	f7ff fe14 	bl	44ffc <pin_in_use_by_te>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   453d4:	f104 0208 	add.w	r2, r4, #8
   453d8:	4b1e      	ldr	r3, [pc, #120]	; (45454 <nrfx_gpiote_trigger_enable+0x88>)
   453da:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
   453de:	b1e8      	cbz	r0, 4541c <nrfx_gpiote_trigger_enable+0x50>
   453e0:	f013 0502 	ands.w	r5, r3, #2
   453e4:	d11a      	bne.n	4541c <nrfx_gpiote_trigger_enable+0x50>
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   453e6:	0b5b      	lsrs	r3, r3, #13
#endif

NRF_STATIC_INLINE nrf_gpiote_event_t nrf_gpiote_in_event_get(uint8_t index)
{
    NRFX_ASSERT(index < GPIOTE_CH_NUM);
    return (nrf_gpiote_event_t)NRFX_OFFSETOF(NRF_GPIOTE_Type, EVENTS_IN[index]);
   453e8:	009a      	lsls	r2, r3, #2
    return ((uint32_t)p_reg + event);
   453ea:	f102 4080 	add.w	r0, r2, #1073741824	; 0x40000000
   453ee:	f500 40c2 	add.w	r0, r0, #24832	; 0x6100
   453f2:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
   453f6:	f502 42c0 	add.w	r2, r2, #24576	; 0x6000
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   453fa:	6005      	str	r5, [r0, #0]
   453fc:	6800      	ldr	r0, [r0, #0]
   p_reg->CONFIG[idx] |= GPIOTE_CONFIG_MODE_Event;
   453fe:	f8d2 0510 	ldr.w	r0, [r2, #1296]	; 0x510
   45402:	f040 0001 	orr.w	r0, r0, #1
   45406:	f8c2 0510 	str.w	r0, [r2, #1296]	; 0x510
        if (int_enable)
   4540a:	b129      	cbz	r1, 45418 <nrfx_gpiote_trigger_enable+0x4c>
            nrf_gpiote_int_enable(NRF_GPIOTE, NRFX_BIT(ch));
   4540c:	2201      	movs	r2, #1
   4540e:	fa02 f303 	lsl.w	r3, r2, r3
    p_reg->INTENSET = mask;
   45412:	4a11      	ldr	r2, [pc, #68]	; (45458 <nrfx_gpiote_trigger_enable+0x8c>)
   45414:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
}
   45418:	b003      	add	sp, #12
   4541a:	bd30      	pop	{r4, r5, pc}
    nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
   4541c:	f3c3 0382 	ubfx	r3, r3, #2, #3
    if (trigger == NRFX_GPIOTE_TRIGGER_LOW)
   45420:	2b04      	cmp	r3, #4
   45422:	d012      	beq.n	4544a <nrfx_gpiote_trigger_enable+0x7e>
    else if (trigger == NRFX_GPIOTE_TRIGGER_HIGH)
   45424:	2b05      	cmp	r3, #5
   45426:	d012      	beq.n	4544e <nrfx_gpiote_trigger_enable+0x82>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   45428:	a801      	add	r0, sp, #4
   4542a:	9401      	str	r4, [sp, #4]
   4542c:	f7ff fdd8 	bl	44fe0 <nrf_gpio_pin_port_decode>
    return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
   45430:	9b01      	ldr	r3, [sp, #4]
    return p_reg->IN;
   45432:	f8d0 1510 	ldr.w	r1, [r0, #1296]	; 0x510
    return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
   45436:	40d9      	lsrs	r1, r3
   45438:	f001 0101 	and.w	r1, r1, #1
   4543c:	3102      	adds	r1, #2
        nrf_gpio_cfg_sense_set(pin, get_initial_sense(pin));
   4543e:	4620      	mov	r0, r4
}
   45440:	b003      	add	sp, #12
   45442:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
        nrf_gpio_cfg_sense_set(pin, get_initial_sense(pin));
   45446:	f009 bfa6 	b.w	4f396 <nrf_gpio_cfg_sense_set>
        sense = NRF_GPIO_PIN_SENSE_LOW;
   4544a:	2103      	movs	r1, #3
   4544c:	e7f7      	b.n	4543e <nrfx_gpiote_trigger_enable+0x72>
        sense = NRF_GPIO_PIN_SENSE_HIGH;
   4544e:	2102      	movs	r1, #2
   45450:	e7f5      	b.n	4543e <nrfx_gpiote_trigger_enable+0x72>
   45452:	bf00      	nop
   45454:	20000d44 	.word	0x20000d44
   45458:	40006000 	.word	0x40006000

0004545c <nrfx_gpiote_trigger_disable>:
{
   4545c:	b508      	push	{r3, lr}
   4545e:	4602      	mov	r2, r0
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
   45460:	f7ff fdcc 	bl	44ffc <pin_in_use_by_te>
   45464:	b1c0      	cbz	r0, 45498 <nrfx_gpiote_trigger_disable+0x3c>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   45466:	f102 0108 	add.w	r1, r2, #8
   4546a:	4b0e      	ldr	r3, [pc, #56]	; (454a4 <nrfx_gpiote_trigger_disable+0x48>)
   4546c:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
   45470:	0799      	lsls	r1, r3, #30
   45472:	d411      	bmi.n	45498 <nrfx_gpiote_trigger_disable+0x3c>
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   45474:	0b5b      	lsrs	r3, r3, #13
        nrf_gpiote_int_disable(NRF_GPIOTE, NRFX_BIT(ch));
   45476:	2201      	movs	r2, #1
   45478:	409a      	lsls	r2, r3
    p_reg->INTENCLR = mask;
   4547a:	009b      	lsls	r3, r3, #2
   4547c:	490a      	ldr	r1, [pc, #40]	; (454a8 <nrfx_gpiote_trigger_disable+0x4c>)
   4547e:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   45482:	f503 43c0 	add.w	r3, r3, #24576	; 0x6000
   45486:	f8c1 2308 	str.w	r2, [r1, #776]	; 0x308
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Msk;
   4548a:	f8d3 2510 	ldr.w	r2, [r3, #1296]	; 0x510
   4548e:	f022 0203 	bic.w	r2, r2, #3
   45492:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
}
   45496:	bd08      	pop	{r3, pc}
   45498:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        nrf_gpio_cfg_sense_set(pin, NRF_GPIO_PIN_NOSENSE);
   4549c:	2100      	movs	r1, #0
   4549e:	4610      	mov	r0, r2
   454a0:	f009 bf79 	b.w	4f396 <nrf_gpio_cfg_sense_set>
   454a4:	20000d44 	.word	0x20000d44
   454a8:	40006000 	.word	0x40006000

000454ac <nrfx_gpiote_pin_uninit>:
{
   454ac:	b513      	push	{r0, r1, r4, lr}
    return m_cb.pin_flags[pin] & PIN_FLAG_IN_USE;
   454ae:	4b0e      	ldr	r3, [pc, #56]	; (454e8 <nrfx_gpiote_pin_uninit+0x3c>)
   454b0:	f100 0208 	add.w	r2, r0, #8
{
   454b4:	4604      	mov	r4, r0
    return m_cb.pin_flags[pin] & PIN_FLAG_IN_USE;
   454b6:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    if (!pin_in_use(pin))
   454ba:	07db      	lsls	r3, r3, #31
   454bc:	d511      	bpl.n	454e2 <nrfx_gpiote_pin_uninit+0x36>
    nrfx_gpiote_trigger_disable(pin);
   454be:	f7ff ffcd 	bl	4545c <nrfx_gpiote_trigger_disable>
    pin_handler_trigger_uninit(pin);
   454c2:	4620      	mov	r0, r4
   454c4:	f7ff fdec 	bl	450a0 <pin_handler_trigger_uninit>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   454c8:	a801      	add	r0, sp, #4
   454ca:	9401      	str	r4, [sp, #4]
   454cc:	f7ff fd88 	bl	44fe0 <nrf_gpio_pin_port_decode>
    reg->PIN_CNF[pin_number] = cnf;
   454d0:	9b01      	ldr	r3, [sp, #4]
   454d2:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
   454d6:	2202      	movs	r2, #2
   454d8:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
    nrf_gpio_cfg(
   454dc:	4803      	ldr	r0, [pc, #12]	; (454ec <nrfx_gpiote_pin_uninit+0x40>)
}
   454de:	b002      	add	sp, #8
   454e0:	bd10      	pop	{r4, pc}
        return NRFX_ERROR_INVALID_PARAM;
   454e2:	4803      	ldr	r0, [pc, #12]	; (454f0 <nrfx_gpiote_pin_uninit+0x44>)
   454e4:	e7fb      	b.n	454de <nrfx_gpiote_pin_uninit+0x32>
   454e6:	bf00      	nop
   454e8:	20000d44 	.word	0x20000d44
   454ec:	0bad0000 	.word	0x0bad0000
   454f0:	0bad0004 	.word	0x0bad0004

000454f4 <nrfx_gpiote_irq_handler>:
        call_handler(pin, gpiote_polarity_to_trigger(polarity));
    }
}

void nrfx_gpiote_irq_handler(void)
{
   454f4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   454f8:	4b68      	ldr	r3, [pc, #416]	; (4569c <nrfx_gpiote_irq_handler+0x1a8>)
    return p_reg->INTENSET & mask;
   454fa:	4869      	ldr	r0, [pc, #420]	; (456a0 <nrfx_gpiote_irq_handler+0x1ac>)
    uint32_t i;
    nrf_gpiote_event_t event = NRF_GPIOTE_EVENT_IN_0;
    uint32_t mask = (uint32_t)NRF_GPIOTE_INT_IN0_MASK;

    /* collect status of all GPIOTE pin events. Processing is done once all are collected and cleared.*/
    for (i = 0; i < GPIOTE_CH_NUM; i++)
   454fc:	4969      	ldr	r1, [pc, #420]	; (456a4 <nrfx_gpiote_irq_handler+0x1b0>)
    uint32_t status = 0;
   454fe:	2600      	movs	r6, #0
{
   45500:	b087      	sub	sp, #28
    uint32_t mask = (uint32_t)NRF_GPIOTE_INT_IN0_MASK;
   45502:	2201      	movs	r2, #1
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   45504:	4634      	mov	r4, r6
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   45506:	681d      	ldr	r5, [r3, #0]
    {
        if (nrf_gpiote_event_check(NRF_GPIOTE, event) &&
   45508:	b135      	cbz	r5, 45518 <nrfx_gpiote_irq_handler+0x24>
    return p_reg->INTENSET & mask;
   4550a:	f8d0 5304 	ldr.w	r5, [r0, #772]	; 0x304
   4550e:	4215      	tst	r5, r2
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   45510:	bf1e      	ittt	ne
   45512:	601c      	strne	r4, [r3, #0]
   45514:	681d      	ldrne	r5, [r3, #0]
            nrf_gpiote_int_enable_check(NRF_GPIOTE, mask))
        {
            nrf_gpiote_event_clear(NRF_GPIOTE, event);
            status |= mask;
   45516:	4316      	orrne	r6, r2
    for (i = 0; i < GPIOTE_CH_NUM; i++)
   45518:	3304      	adds	r3, #4
   4551a:	428b      	cmp	r3, r1
        }
        mask <<= 1;
   4551c:	ea4f 0242 	mov.w	r2, r2, lsl #1
    for (i = 0; i < GPIOTE_CH_NUM; i++)
   45520:	d1f1      	bne.n	45506 <nrfx_gpiote_irq_handler+0x12>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   45522:	f8df 917c 	ldr.w	r9, [pc, #380]	; 456a0 <nrfx_gpiote_irq_handler+0x1ac>
   45526:	f8d9 317c 	ldr.w	r3, [r9, #380]	; 0x17c
         * in ascending order. */
        event = (nrf_gpiote_event_t)((uint32_t)event + sizeof(uint32_t));
    }

    /* handle PORT event */
    if (nrf_gpiote_event_check(NRF_GPIOTE, NRF_GPIOTE_EVENT_PORT))
   4552a:	2b00      	cmp	r3, #0
   4552c:	f000 8099 	beq.w	45662 <nrfx_gpiote_irq_handler+0x16e>
        *p_masks = gpio_regs[i]->LATCH;
   45530:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
   45534:	f8d3 2520 	ldr.w	r2, [r3, #1312]	; 0x520
   45538:	9204      	str	r2, [sp, #16]
        gpio_regs[i]->LATCH = *p_masks;
   4553a:	f8c3 2520 	str.w	r2, [r3, #1312]	; 0x520
        *p_masks = gpio_regs[i]->LATCH;
   4553e:	f8d3 2820 	ldr.w	r2, [r3, #2080]	; 0x820
   45542:	9205      	str	r2, [sp, #20]
        gpio_regs[i]->LATCH = *p_masks;
   45544:	f8c3 2820 	str.w	r2, [r3, #2080]	; 0x820
        for (uint32_t i = 0; i < GPIO_COUNT; i++)
   45548:	f04f 0800 	mov.w	r8, #0
            while (latch[i])
   4554c:	f10d 0a10 	add.w	sl, sp, #16
   45550:	ea4f 1348 	mov.w	r3, r8, lsl #5
   45554:	9300      	str	r3, [sp, #0]
__STATIC_INLINE void nrf_bitmask_bit_clear(uint32_t bit, void * p_mask)
{
    uint8_t * p_mask8 = (uint8_t *)p_mask;
    uint32_t byte_idx = BITMASK_BYTE_GET(bit);
    bit = BITMASK_RELBIT_GET(bit);
    p_mask8[byte_idx] &= ~(1 << bit);
   45556:	f04f 0b01 	mov.w	fp, #1
   4555a:	e049      	b.n	455f0 <nrfx_gpiote_irq_handler+0xfc>
                pin += 32 * i;
   4555c:	9b00      	ldr	r3, [sp, #0]
                nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
   4555e:	4a52      	ldr	r2, [pc, #328]	; (456a8 <nrfx_gpiote_irq_handler+0x1b4>)
                uint32_t pin = NRF_CTZ(latch[i]);
   45560:	fa94 f4a4 	rbit	r4, r4
   45564:	fab4 f484 	clz	r4, r4
                pin += 32 * i;
   45568:	441c      	add	r4, r3
    uint32_t byte_idx = BITMASK_BYTE_GET(bit);
   4556a:	08e0      	lsrs	r0, r4, #3
                nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
   4556c:	f104 0308 	add.w	r3, r4, #8
   45570:	9403      	str	r4, [sp, #12]
   45572:	f832 7013 	ldrh.w	r7, [r2, r3, lsl #1]
    p_mask8[byte_idx] &= ~(1 << bit);
   45576:	f81a 3000 	ldrb.w	r3, [sl, r0]
    bit = BITMASK_RELBIT_GET(bit);
   4557a:	f004 0207 	and.w	r2, r4, #7
    p_mask8[byte_idx] &= ~(1 << bit);
   4557e:	fa0b f202 	lsl.w	r2, fp, r2
   45582:	ea23 0302 	bic.w	r3, r3, r2
   45586:	f80a 3000 	strb.w	r3, [sl, r0]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   4558a:	a803      	add	r0, sp, #12
   4558c:	f7ff fd28 	bl	44fe0 <nrf_gpio_pin_port_decode>
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
   45590:	9b03      	ldr	r3, [sp, #12]
   45592:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
   45596:	08b9      	lsrs	r1, r7, #2
   45598:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
   4559c:	f3c7 0582 	ubfx	r5, r7, #2, #3
    if (is_level(trigger))
   455a0:	074a      	lsls	r2, r1, #29
                nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
   455a2:	462f      	mov	r7, r5
                                   GPIO_PIN_CNF_SENSE_Msk) >> GPIO_PIN_CNF_SENSE_Pos);
   455a4:	f3c3 4301 	ubfx	r3, r3, #16, #2
    if (is_level(trigger))
   455a8:	d52c      	bpl.n	45604 <nrfx_gpiote_irq_handler+0x110>
        call_handler(pin, trigger);
   455aa:	4620      	mov	r0, r4
   455ac:	4639      	mov	r1, r7
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
   455ae:	b2dd      	uxtb	r5, r3
   455b0:	f7ff fd2e 	bl	45010 <call_handler>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   455b4:	a803      	add	r0, sp, #12
   455b6:	9403      	str	r4, [sp, #12]
   455b8:	f7ff fd12 	bl	44fe0 <nrf_gpio_pin_port_decode>
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
   455bc:	9b03      	ldr	r3, [sp, #12]
   455be:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
   455c2:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
        if (nrf_gpio_pin_sense_get(pin) == sense)
   455c6:	f3c3 4301 	ubfx	r3, r3, #16, #2
   455ca:	429d      	cmp	r5, r3
   455cc:	d107      	bne.n	455de <nrfx_gpiote_irq_handler+0xea>
            nrf_gpio_cfg_sense_set(pin, NRF_GPIO_PIN_NOSENSE);
   455ce:	2100      	movs	r1, #0
   455d0:	4620      	mov	r0, r4
   455d2:	f009 fee0 	bl	4f396 <nrf_gpio_cfg_sense_set>
            nrf_gpio_cfg_sense_set(pin, sense);
   455d6:	4629      	mov	r1, r5
   455d8:	4620      	mov	r0, r4
   455da:	f009 fedc 	bl	4f396 <nrf_gpio_cfg_sense_set>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   455de:	a803      	add	r0, sp, #12
   455e0:	9403      	str	r4, [sp, #12]
   455e2:	f7ff fcfd 	bl	44fe0 <nrf_gpio_pin_port_decode>
    reg->LATCH = (1 << pin_number);
   455e6:	9b03      	ldr	r3, [sp, #12]
   455e8:	fa0b f303 	lsl.w	r3, fp, r3
   455ec:	f8c0 3520 	str.w	r3, [r0, #1312]	; 0x520
            while (latch[i])
   455f0:	f85a 4028 	ldr.w	r4, [sl, r8, lsl #2]
   455f4:	2c00      	cmp	r4, #0
   455f6:	d1b1      	bne.n	4555c <nrfx_gpiote_irq_handler+0x68>
        for (uint32_t i = 0; i < GPIO_COUNT; i++)
   455f8:	f1b8 0f00 	cmp.w	r8, #0
   455fc:	d11d      	bne.n	4563a <nrfx_gpiote_irq_handler+0x146>
   455fe:	f04f 0801 	mov.w	r8, #1
   45602:	e7a5      	b.n	45550 <nrfx_gpiote_irq_handler+0x5c>
                NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
   45604:	2b02      	cmp	r3, #2
   45606:	d10c      	bne.n	45622 <nrfx_gpiote_irq_handler+0x12e>
        nrf_gpio_cfg_sense_set(pin, next_sense);
   45608:	2103      	movs	r1, #3
   4560a:	4620      	mov	r0, r4
   4560c:	f009 fec3 	bl	4f396 <nrf_gpio_cfg_sense_set>
        if ((trigger == NRFX_GPIOTE_TRIGGER_TOGGLE) ||
   45610:	f005 0305 	and.w	r3, r5, #5
   45614:	2b01      	cmp	r3, #1
   45616:	d1e2      	bne.n	455de <nrfx_gpiote_irq_handler+0xea>
            call_handler(pin, trigger);
   45618:	4639      	mov	r1, r7
   4561a:	4620      	mov	r0, r4
   4561c:	f7ff fcf8 	bl	45010 <call_handler>
   45620:	e7dd      	b.n	455de <nrfx_gpiote_irq_handler+0xea>
        nrf_gpio_cfg_sense_set(pin, next_sense);
   45622:	2102      	movs	r1, #2
   45624:	4620      	mov	r0, r4
   45626:	9301      	str	r3, [sp, #4]
   45628:	f009 feb5 	bl	4f396 <nrf_gpio_cfg_sense_set>
        if ((trigger == NRFX_GPIOTE_TRIGGER_TOGGLE) ||
   4562c:	2d03      	cmp	r5, #3
   4562e:	d0f3      	beq.n	45618 <nrfx_gpiote_irq_handler+0x124>
            (sense == NRF_GPIO_PIN_SENSE_HIGH && trigger == NRFX_GPIOTE_TRIGGER_LOTOHI) ||
   45630:	9b01      	ldr	r3, [sp, #4]
   45632:	2b03      	cmp	r3, #3
   45634:	d1d3      	bne.n	455de <nrfx_gpiote_irq_handler+0xea>
            (sense == NRF_GPIO_PIN_SENSE_LOW && trigger == NRFX_GPIOTE_TRIGGER_HITOLO))
   45636:	2d02      	cmp	r5, #2
   45638:	e7ed      	b.n	45616 <nrfx_gpiote_irq_handler+0x122>
        *p_masks = gpio_regs[i]->LATCH;
   4563a:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   4563e:	f8c9 417c 	str.w	r4, [r9, #380]	; 0x17c
   45642:	f8d9 317c 	ldr.w	r3, [r9, #380]	; 0x17c
   45646:	4919      	ldr	r1, [pc, #100]	; (456ac <nrfx_gpiote_irq_handler+0x1b8>)
   45648:	f8d2 3520 	ldr.w	r3, [r2, #1312]	; 0x520
   4564c:	9304      	str	r3, [sp, #16]
        gpio_regs[i]->LATCH = *p_masks;
   4564e:	f8c2 3520 	str.w	r3, [r2, #1312]	; 0x520
        *p_masks = gpio_regs[i]->LATCH;
   45652:	f8d1 2520 	ldr.w	r2, [r1, #1312]	; 0x520
   45656:	9205      	str	r2, [sp, #20]
        if (latch[port_idx])
   45658:	4313      	orrs	r3, r2
        gpio_regs[i]->LATCH = *p_masks;
   4565a:	f8c1 2520 	str.w	r2, [r1, #1312]	; 0x520
   4565e:	f47f af73 	bne.w	45548 <nrfx_gpiote_irq_handler+0x54>
        mask &= ~NRFX_BIT(ch);
   45662:	2401      	movs	r4, #1
    while (mask)
   45664:	b916      	cbnz	r6, 4566c <nrfx_gpiote_irq_handler+0x178>
        port_event_handle();
    }

    /* Process pin events. */
    gpiote_evt_handle(status);
}
   45666:	b007      	add	sp, #28
   45668:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        uint32_t ch = NRF_CTZ(mask);
   4566c:	fa96 f3a6 	rbit	r3, r6
   45670:	fab3 f383 	clz	r3, r3
        mask &= ~NRFX_BIT(ch);
   45674:	fa04 f203 	lsl.w	r2, r4, r3
   45678:	009b      	lsls	r3, r3, #2
   4567a:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   4567e:	f503 43c0 	add.w	r3, r3, #24576	; 0x6000
   45682:	ea26 0602 	bic.w	r6, r6, r2
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
   45686:	f8d3 0510 	ldr.w	r0, [r3, #1296]	; 0x510
    return (nrf_gpiote_polarity_t)((p_reg->CONFIG[idx] & GPIOTE_CONFIG_POLARITY_Msk) >>
   4568a:	f8d3 1510 	ldr.w	r1, [r3, #1296]	; 0x510
        call_handler(pin, gpiote_polarity_to_trigger(polarity));
   4568e:	f3c0 2005 	ubfx	r0, r0, #8, #6
   45692:	f3c1 4101 	ubfx	r1, r1, #16, #2
   45696:	f7ff fcbb 	bl	45010 <call_handler>
   4569a:	e7e3      	b.n	45664 <nrfx_gpiote_irq_handler+0x170>
   4569c:	40006100 	.word	0x40006100
   456a0:	40006000 	.word	0x40006000
   456a4:	40006120 	.word	0x40006120
   456a8:	20000d44 	.word	0x20000d44
   456ac:	50000300 	.word	0x50000300

000456b0 <nvmc_word_write>:
   456b0:	4a04      	ldr	r2, [pc, #16]	; (456c4 <nvmc_word_write+0x14>)
   456b2:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
{
#if defined(NRF9160_XXAA)
    while (!nrf_nvmc_write_ready_check(NRF_NVMC))
    {}
#else
    while (!nrf_nvmc_ready_check(NRF_NVMC))
   456b6:	07db      	lsls	r3, r3, #31
   456b8:	d5fb      	bpl.n	456b2 <nvmc_word_write+0x2>
    {}
#endif

    *(volatile uint32_t *)addr = value;
   456ba:	6001      	str	r1, [r0, #0]
  __ASM volatile ("dmb 0xF":::"memory");
   456bc:	f3bf 8f5f 	dmb	sy
    __DMB();
}
   456c0:	4770      	bx	lr
   456c2:	bf00      	nop
   456c4:	4001e000 	.word	0x4001e000

000456c8 <nrfx_nvmc_page_erase>:
NRF_STATIC_INLINE uint32_t nrf_ficr_codepagesize_get(NRF_FICR_Type const * p_reg)
{
#if defined(FICR_INFO_CODEPAGESIZE_CODEPAGESIZE_Msk)
    return p_reg->INFO.CODEPAGESIZE;
#else
    return p_reg->CODEPAGESIZE;
   456c8:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   456cc:	691a      	ldr	r2, [r3, #16]
    return !(addr % flash_page_size_get());
   456ce:	fbb0 f3f2 	udiv	r3, r0, r2
   456d2:	fb02 0313 	mls	r3, r2, r3, r0

nrfx_err_t nrfx_nvmc_page_erase(uint32_t addr)
{
    NRFX_ASSERT(is_valid_address(addr, false));

    if (!is_page_aligned_check(addr))
   456d6:	b973      	cbnz	r3, 456f6 <nrfx_nvmc_page_erase+0x2e>
#endif

NRF_STATIC_INLINE void nrf_nvmc_mode_set(NRF_NVMC_Type * p_reg,
                                         nrf_nvmc_mode_t mode)
{
    p_reg->CONFIG = (uint32_t)mode;
   456d8:	4b08      	ldr	r3, [pc, #32]	; (456fc <nrfx_nvmc_page_erase+0x34>)
   456da:	2202      	movs	r2, #2
   456dc:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
    else
    {
        p_reg->ERASEPCR1 = page_addr;
    }
#elif defined(NRF52_SERIES)
    p_reg->ERASEPAGE = page_addr;
   456e0:	f8c3 0508 	str.w	r0, [r3, #1288]	; 0x508
    return (bool)(p_reg->READY & NVMC_READY_READY_Msk);
   456e4:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
        return NRFX_ERROR_INVALID_ADDR;
    }

    nvmc_erase_mode_set();
    nrf_nvmc_page_erase_start(NRF_NVMC, addr);
    while (!nrf_nvmc_ready_check(NRF_NVMC))
   456e8:	07d2      	lsls	r2, r2, #31
   456ea:	d5fb      	bpl.n	456e4 <nrfx_nvmc_page_erase+0x1c>
    p_reg->CONFIG = (uint32_t)mode;
   456ec:	2200      	movs	r2, #0
    {}
    nvmc_readonly_mode_set();

    return NRFX_SUCCESS;
   456ee:	4804      	ldr	r0, [pc, #16]	; (45700 <nrfx_nvmc_page_erase+0x38>)
   456f0:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
   456f4:	4770      	bx	lr
        return NRFX_ERROR_INVALID_ADDR;
   456f6:	4803      	ldr	r0, [pc, #12]	; (45704 <nrfx_nvmc_page_erase+0x3c>)
}
   456f8:	4770      	bx	lr
   456fa:	bf00      	nop
   456fc:	4001e000 	.word	0x4001e000
   45700:	0bad0000 	.word	0x0bad0000
   45704:	0bad000a 	.word	0x0bad000a

00045708 <nrfx_nvmc_word_write>:

    nrfx_nvmc_word_write(aligned_addr, partial_word_create(addr, (const uint8_t *)&value, 2));
}

void nrfx_nvmc_word_write(uint32_t addr, uint32_t value)
{
   45708:	b510      	push	{r4, lr}
   4570a:	4c05      	ldr	r4, [pc, #20]	; (45720 <nrfx_nvmc_word_write+0x18>)
   4570c:	2301      	movs	r3, #1
   4570e:	f8c4 3504 	str.w	r3, [r4, #1284]	; 0x504
    NRFX_ASSERT(is_valid_address(addr, true));
    NRFX_ASSERT(nrfx_is_word_aligned((void const *)addr));

    nvmc_write_mode_set();

    nvmc_word_write(addr, value);
   45712:	f7ff ffcd 	bl	456b0 <nvmc_word_write>
   45716:	2300      	movs	r3, #0
   45718:	f8c4 3504 	str.w	r3, [r4, #1284]	; 0x504

    nvmc_readonly_mode_set();
}
   4571c:	bd10      	pop	{r4, pc}
   4571e:	bf00      	nop
   45720:	4001e000 	.word	0x4001e000

00045724 <nrfx_power_init>:
    return m_usbevt_handler;
}
#endif

nrfx_err_t nrfx_power_init(nrfx_power_config_t const * p_config)
{
   45724:	b510      	push	{r4, lr}
    NRFX_ASSERT(p_config);
    if (m_initialized)
   45726:	4c18      	ldr	r4, [pc, #96]	; (45788 <nrfx_power_init+0x64>)
   45728:	7823      	ldrb	r3, [r4, #0]
   4572a:	bb53      	cbnz	r3, 45782 <nrfx_power_init+0x5e>
    {
        return NRFX_ERROR_ALREADY_INITIALIZED;
    }

#if NRF_POWER_HAS_DCDCEN_VDDH
    nrf_power_dcdcen_vddh_set(NRF_POWER, p_config->dcdcenhv);
   4572c:	7802      	ldrb	r2, [r0, #0]
    if (enable && nrf52_errata_197())
   4572e:	f3c2 0340 	ubfx	r3, r2, #1, #1
   45732:	0792      	lsls	r2, r2, #30
   45734:	d512      	bpl.n	4575c <nrfx_power_init+0x38>
            uint32_t var1 = *(uint32_t *)0x10000130ul;
   45736:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
            if (var1 == 0x08)
   4573a:	f8d3 2130 	ldr.w	r2, [r3, #304]	; 0x130
   4573e:	2a08      	cmp	r2, #8
   45740:	d10b      	bne.n	4575a <nrfx_power_init+0x36>
            uint32_t var2 = *(uint32_t *)0x10000134ul;
   45742:	f8d3 3134 	ldr.w	r3, [r3, #308]	; 0x134
                switch(var2)
   45746:	2b05      	cmp	r3, #5
   45748:	d807      	bhi.n	4575a <nrfx_power_init+0x36>
   4574a:	4a10      	ldr	r2, [pc, #64]	; (4578c <nrfx_power_init+0x68>)
   4574c:	5cd3      	ldrb	r3, [r2, r3]
   4574e:	b123      	cbz	r3, 4575a <nrfx_power_init+0x36>
        *(volatile uint32_t *)0x40000638ul = 1ul;
   45750:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   45754:	2201      	movs	r2, #1
   45756:	f8c3 2638 	str.w	r2, [r3, #1592]	; 0x638
    p_reg->DCDCEN0 = (enable ? POWER_DCDCEN0_DCDCEN_Enabled : POWER_DCDCEN0_DCDCEN_Disabled) <<
   4575a:	2301      	movs	r3, #1
   4575c:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
   45760:	f8c2 3580 	str.w	r3, [r2, #1408]	; 0x580
#elif NRF_REGULATORS_HAS_DCDCEN_VDDH
    nrf_regulators_dcdcen_vddh_set(NRF_REGULATORS, p_config->dcdcenhv);
#endif

#if NRF_POWER_HAS_DCDCEN
    nrf_power_dcdcen_set(NRF_POWER, p_config->dcdcen);
   45764:	7803      	ldrb	r3, [r0, #0]
    p_reg->DCDCEN = (enable ? POWER_DCDCEN_DCDCEN_Enabled : POWER_DCDCEN_DCDCEN_Disabled) <<
   45766:	f003 0301 	and.w	r3, r3, #1
   4576a:	f8c2 3578 	str.w	r3, [r2, #1400]	; 0x578
    if (!NRFX_IRQ_IS_ENABLED(nrfx_get_irq_number(NRF_CLOCK)))
   4576e:	2000      	movs	r0, #0
   45770:	f7e7 fb42 	bl	2cdf8 <arch_irq_is_enabled>
   45774:	b908      	cbnz	r0, 4577a <nrfx_power_init+0x56>
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_CLOCK));
   45776:	f7e7 fb1d 	bl	2cdb4 <arch_irq_enable>
#endif
#endif // defined(REGULATORS_PRESENT)

    nrfx_power_clock_irq_init();

    m_initialized = true;
   4577a:	2301      	movs	r3, #1
    return NRFX_SUCCESS;
   4577c:	4804      	ldr	r0, [pc, #16]	; (45790 <nrfx_power_init+0x6c>)
    m_initialized = true;
   4577e:	7023      	strb	r3, [r4, #0]
}
   45780:	bd10      	pop	{r4, pc}
        return NRFX_ERROR_ALREADY_INITIALIZED;
   45782:	4804      	ldr	r0, [pc, #16]	; (45794 <nrfx_power_init+0x70>)
   45784:	e7fc      	b.n	45780 <nrfx_power_init+0x5c>
   45786:	bf00      	nop
   45788:	20006bbb 	.word	0x20006bbb
   4578c:	000538a4 	.word	0x000538a4
   45790:	0bad0000 	.word	0x0bad0000
   45794:	0bad000c 	.word	0x0bad000c

00045798 <nrfx_power_usbevt_uninit>:
    p_reg->INTENCLR = mask;
   45798:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   4579c:	f44f 7260 	mov.w	r2, #896	; 0x380
   457a0:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
}

void nrfx_power_usbevt_uninit(void)
{
    nrfx_power_usbevt_disable();
    m_usbevt_handler = NULL;
   457a4:	4b01      	ldr	r3, [pc, #4]	; (457ac <nrfx_power_usbevt_uninit+0x14>)
   457a6:	2200      	movs	r2, #0
   457a8:	601a      	str	r2, [r3, #0]
}
   457aa:	4770      	bx	lr
   457ac:	20006688 	.word	0x20006688

000457b0 <nrfx_power_usbevt_init>:
{
   457b0:	b508      	push	{r3, lr}
    nrfx_power_usbevt_uninit();
   457b2:	f7ff fff1 	bl	45798 <nrfx_power_usbevt_uninit>
    if (p_config->handler != NULL)
   457b6:	6803      	ldr	r3, [r0, #0]
   457b8:	b10b      	cbz	r3, 457be <nrfx_power_usbevt_init+0xe>
        m_usbevt_handler = p_config->handler;
   457ba:	4a01      	ldr	r2, [pc, #4]	; (457c0 <nrfx_power_usbevt_init+0x10>)
   457bc:	6013      	str	r3, [r2, #0]
}
   457be:	bd08      	pop	{r3, pc}
   457c0:	20006688 	.word	0x20006688

000457c4 <nrfx_power_irq_handler>:

#endif /* NRF_POWER_HAS_USBREG */


void nrfx_power_irq_handler(void)
{
   457c4:	b510      	push	{r4, lr}
    return p_reg->INTENSET;
   457c6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   457ca:	f8d3 4304 	ldr.w	r4, [r3, #772]	; 0x304
    uint32_t enabled = nrf_power_int_enable_get(NRF_POWER);
    /* Prevent "unused variable" warning when all below blocks are disabled. */
    (void)enabled;

#if NRFX_POWER_SUPPORTS_POFCON
    if ((0 != (enabled & NRF_POWER_INT_POFWARN_MASK)) &&
   457ce:	0762      	lsls	r2, r4, #29
   457d0:	d507      	bpl.n	457e2 <nrfx_power_irq_handler+0x1e>
        nrf_power_event_get_and_clear(NRF_POWER, NRF_POWER_EVENT_POFWARN))
   457d2:	f44f 7084 	mov.w	r0, #264	; 0x108
   457d6:	f009 fdfb 	bl	4f3d0 <nrf_power_event_get_and_clear.constprop.0>
    if ((0 != (enabled & NRF_POWER_INT_POFWARN_MASK)) &&
   457da:	b110      	cbz	r0, 457e2 <nrfx_power_irq_handler+0x1e>
    {
        /* Cannot be null if event is enabled */
        NRFX_ASSERT(m_pofwarn_handler != NULL);
        m_pofwarn_handler();
   457dc:	4b1e      	ldr	r3, [pc, #120]	; (45858 <nrfx_power_irq_handler+0x94>)
   457de:	681b      	ldr	r3, [r3, #0]
   457e0:	4798      	blx	r3
    }
#endif
#if NRF_POWER_HAS_SLEEPEVT
    if ((0 != (enabled & NRF_POWER_INT_SLEEPENTER_MASK)) &&
   457e2:	06a3      	lsls	r3, r4, #26
   457e4:	d508      	bpl.n	457f8 <nrfx_power_irq_handler+0x34>
        nrf_power_event_get_and_clear(NRF_POWER, NRF_POWER_EVENT_SLEEPENTER))
   457e6:	f44f 708a 	mov.w	r0, #276	; 0x114
   457ea:	f009 fdf1 	bl	4f3d0 <nrf_power_event_get_and_clear.constprop.0>
    if ((0 != (enabled & NRF_POWER_INT_SLEEPENTER_MASK)) &&
   457ee:	b118      	cbz	r0, 457f8 <nrfx_power_irq_handler+0x34>
    {
        /* Cannot be null if event is enabled */
        NRFX_ASSERT(m_sleepevt_handler != NULL);
        m_sleepevt_handler(NRFX_POWER_SLEEP_EVT_ENTER);
   457f0:	4b1a      	ldr	r3, [pc, #104]	; (4585c <nrfx_power_irq_handler+0x98>)
   457f2:	2000      	movs	r0, #0
   457f4:	681b      	ldr	r3, [r3, #0]
   457f6:	4798      	blx	r3
    }
    if ((0 != (enabled & NRF_POWER_INT_SLEEPEXIT_MASK)) &&
   457f8:	0660      	lsls	r0, r4, #25
   457fa:	d508      	bpl.n	4580e <nrfx_power_irq_handler+0x4a>
        nrf_power_event_get_and_clear(NRF_POWER, NRF_POWER_EVENT_SLEEPEXIT))
   457fc:	f44f 708c 	mov.w	r0, #280	; 0x118
   45800:	f009 fde6 	bl	4f3d0 <nrf_power_event_get_and_clear.constprop.0>
    if ((0 != (enabled & NRF_POWER_INT_SLEEPEXIT_MASK)) &&
   45804:	b118      	cbz	r0, 4580e <nrfx_power_irq_handler+0x4a>
    {
        /* Cannot be null if event is enabled */
        NRFX_ASSERT(m_sleepevt_handler != NULL);
        m_sleepevt_handler(NRFX_POWER_SLEEP_EVT_EXIT);
   45806:	4b15      	ldr	r3, [pc, #84]	; (4585c <nrfx_power_irq_handler+0x98>)
   45808:	2001      	movs	r0, #1
   4580a:	681b      	ldr	r3, [r3, #0]
   4580c:	4798      	blx	r3
    }
#endif
#if NRF_POWER_HAS_USBREG
    if ((0 != (enabled & NRF_POWER_INT_USBDETECTED_MASK)) &&
   4580e:	0621      	lsls	r1, r4, #24
   45810:	d508      	bpl.n	45824 <nrfx_power_irq_handler+0x60>
        nrf_power_event_get_and_clear(NRF_POWER, NRF_POWER_EVENT_USBDETECTED))
   45812:	f44f 708e 	mov.w	r0, #284	; 0x11c
   45816:	f009 fddb 	bl	4f3d0 <nrf_power_event_get_and_clear.constprop.0>
    if ((0 != (enabled & NRF_POWER_INT_USBDETECTED_MASK)) &&
   4581a:	b118      	cbz	r0, 45824 <nrfx_power_irq_handler+0x60>
    {
        /* Cannot be null if event is enabled */
        NRFX_ASSERT(m_usbevt_handler != NULL);
        m_usbevt_handler(NRFX_POWER_USB_EVT_DETECTED);
   4581c:	4b10      	ldr	r3, [pc, #64]	; (45860 <nrfx_power_irq_handler+0x9c>)
   4581e:	2000      	movs	r0, #0
   45820:	681b      	ldr	r3, [r3, #0]
   45822:	4798      	blx	r3
    }
    if ((0 != (enabled & NRF_POWER_INT_USBREMOVED_MASK)) &&
   45824:	05e2      	lsls	r2, r4, #23
   45826:	d508      	bpl.n	4583a <nrfx_power_irq_handler+0x76>
        nrf_power_event_get_and_clear(NRF_POWER, NRF_POWER_EVENT_USBREMOVED))
   45828:	f44f 7090 	mov.w	r0, #288	; 0x120
   4582c:	f009 fdd0 	bl	4f3d0 <nrf_power_event_get_and_clear.constprop.0>
    if ((0 != (enabled & NRF_POWER_INT_USBREMOVED_MASK)) &&
   45830:	b118      	cbz	r0, 4583a <nrfx_power_irq_handler+0x76>
    {
        /* Cannot be null if event is enabled */
        NRFX_ASSERT(m_usbevt_handler != NULL);
        m_usbevt_handler(NRFX_POWER_USB_EVT_REMOVED);
   45832:	4b0b      	ldr	r3, [pc, #44]	; (45860 <nrfx_power_irq_handler+0x9c>)
   45834:	2001      	movs	r0, #1
   45836:	681b      	ldr	r3, [r3, #0]
   45838:	4798      	blx	r3
    }
    if ((0 != (enabled & NRF_POWER_INT_USBPWRRDY_MASK)) &&
   4583a:	05a3      	lsls	r3, r4, #22
   4583c:	d50a      	bpl.n	45854 <nrfx_power_irq_handler+0x90>
        nrf_power_event_get_and_clear(NRF_POWER, NRF_POWER_EVENT_USBPWRRDY))
   4583e:	f44f 7092 	mov.w	r0, #292	; 0x124
   45842:	f009 fdc5 	bl	4f3d0 <nrf_power_event_get_and_clear.constprop.0>
    if ((0 != (enabled & NRF_POWER_INT_USBPWRRDY_MASK)) &&
   45846:	b128      	cbz	r0, 45854 <nrfx_power_irq_handler+0x90>
    {
        /* Cannot be null if event is enabled */
        NRFX_ASSERT(m_usbevt_handler != NULL);
        m_usbevt_handler(NRFX_POWER_USB_EVT_READY);
   45848:	4b05      	ldr	r3, [pc, #20]	; (45860 <nrfx_power_irq_handler+0x9c>)
    }
#endif
}
   4584a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        m_usbevt_handler(NRFX_POWER_USB_EVT_READY);
   4584e:	681b      	ldr	r3, [r3, #0]
   45850:	2002      	movs	r0, #2
   45852:	4718      	bx	r3
}
   45854:	bd10      	pop	{r4, pc}
   45856:	bf00      	nop
   45858:	20006690 	.word	0x20006690
   4585c:	2000668c 	.word	0x2000668c
   45860:	20006688 	.word	0x20006688

00045864 <nrf52_errata_187>:
            uint32_t var1 = *(uint32_t *)0x10000130ul;
   45864:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
            if (var1 == 0x08)
   45868:	f8d3 2130 	ldr.w	r2, [r3, #304]	; 0x130
   4586c:	2a08      	cmp	r2, #8
   4586e:	d106      	bne.n	4587e <nrf52_errata_187+0x1a>
            uint32_t var2 = *(uint32_t *)0x10000134ul;
   45870:	f8d3 3134 	ldr.w	r3, [r3, #308]	; 0x134
                switch(var2)
   45874:	2b05      	cmp	r3, #5
   45876:	d804      	bhi.n	45882 <nrf52_errata_187+0x1e>
   45878:	4a03      	ldr	r2, [pc, #12]	; (45888 <nrf52_errata_187+0x24>)
   4587a:	5cd0      	ldrb	r0, [r2, r3]
   4587c:	4770      	bx	lr
                        return false;
   4587e:	2000      	movs	r0, #0
   45880:	4770      	bx	lr
            uint32_t var2 = *(uint32_t *)0x10000134ul;
   45882:	2001      	movs	r0, #1
}
   45884:	4770      	bx	lr
   45886:	bf00      	nop
   45888:	000538aa 	.word	0x000538aa

0004588c <ep_state_access>:
 * @param ep Endpoint number.
 */
static inline usbd_ep_state_t* ep_state_access(nrfx_usbd_ep_t ep)
{
    NRFX_USBD_ASSERT_EP_VALID(ep);
    return ((NRF_USBD_EPIN_CHECK(ep) ? m_ep_state.ep_in : m_ep_state.ep_out) +
   4588c:	4b05      	ldr	r3, [pc, #20]	; (458a4 <ep_state_access+0x18>)
   4588e:	f010 0f80 	tst.w	r0, #128	; 0x80
   45892:	f1a3 0290 	sub.w	r2, r3, #144	; 0x90
   45896:	bf08      	it	eq
   45898:	4613      	moveq	r3, r2
        NRF_USBD_EP_NR_GET(ep));
   4589a:	f000 000f 	and.w	r0, r0, #15
}
   4589e:	eb03 1000 	add.w	r0, r3, r0, lsl #4
   458a2:	4770      	bx	lr
   458a4:	2000683c 	.word	0x2000683c

000458a8 <ev_usbreset_handler>:
 * Interrupt runtimes that would be vectorized using @ref m_isr.
 * @{
 */

static void ev_usbreset_handler(void)
{
   458a8:	b507      	push	{r0, r1, r2, lr}
    m_bus_suspend = false;
   458aa:	4a07      	ldr	r2, [pc, #28]	; (458c8 <ev_usbreset_handler+0x20>)
   458ac:	2300      	movs	r3, #0
   458ae:	7013      	strb	r3, [r2, #0]
    m_last_setup_dir = NRFX_USBD_EPOUT0;
   458b0:	4a06      	ldr	r2, [pc, #24]	; (458cc <ev_usbreset_handler+0x24>)
   458b2:	7013      	strb	r3, [r2, #0]

    const nrfx_usbd_evt_t evt = {
   458b4:	2301      	movs	r3, #1
   458b6:	9301      	str	r3, [sp, #4]
            .type = NRFX_USBD_EVT_RESET
    };

    m_event_handler(&evt);
   458b8:	4b05      	ldr	r3, [pc, #20]	; (458d0 <ev_usbreset_handler+0x28>)
   458ba:	a801      	add	r0, sp, #4
   458bc:	681b      	ldr	r3, [r3, #0]
   458be:	4798      	blx	r3
}
   458c0:	b003      	add	sp, #12
   458c2:	f85d fb04 	ldr.w	pc, [sp], #4
   458c6:	bf00      	nop
   458c8:	20006bbe 	.word	0x20006bbe
   458cc:	20006bbd 	.word	0x20006bbd
   458d0:	200068d4 	.word	0x200068d4

000458d4 <ev_usbevent_handler>:
    };
    m_event_handler(&evt);
}

static void ev_usbevent_handler(void)
{
   458d4:	b513      	push	{r0, r1, r4, lr}
    return p_reg->EVENTCAUSE;
   458d6:	4b19      	ldr	r3, [pc, #100]	; (4593c <ev_usbevent_handler+0x68>)
   458d8:	f8d3 4400 	ldr.w	r4, [r3, #1024]	; 0x400
    p_reg->EVENTCAUSE = flags;
   458dc:	f8c3 4400 	str.w	r4, [r3, #1024]	; 0x400
    if (event & NRF_USBD_EVENTCAUSE_ISOOUTCRC_MASK)
    {
        NRFX_LOG_DEBUG("USBD event: ISOOUTCRC");
        /* Currently no support */
    }
    if (event & NRF_USBD_EVENTCAUSE_SUSPEND_MASK)
   458e0:	05e1      	lsls	r1, r4, #23
    (void) p_reg->EVENTCAUSE;
   458e2:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
   458e6:	d508      	bpl.n	458fa <ev_usbevent_handler+0x26>
    {
        NRFX_LOG_DEBUG("USBD event: SUSPEND");
        m_bus_suspend = true;
   458e8:	4b15      	ldr	r3, [pc, #84]	; (45940 <ev_usbevent_handler+0x6c>)
   458ea:	2201      	movs	r2, #1
   458ec:	701a      	strb	r2, [r3, #0]
        const nrfx_usbd_evt_t evt = {
   458ee:	2302      	movs	r3, #2
   458f0:	9301      	str	r3, [sp, #4]
                .type = NRFX_USBD_EVT_SUSPEND
        };
        m_event_handler(&evt);
   458f2:	4b14      	ldr	r3, [pc, #80]	; (45944 <ev_usbevent_handler+0x70>)
   458f4:	a801      	add	r0, sp, #4
   458f6:	681b      	ldr	r3, [r3, #0]
   458f8:	4798      	blx	r3
    }
    if (event & NRF_USBD_EVENTCAUSE_RESUME_MASK)
   458fa:	05a2      	lsls	r2, r4, #22
   458fc:	d508      	bpl.n	45910 <ev_usbevent_handler+0x3c>
    {
        NRFX_LOG_DEBUG("USBD event: RESUME");
        m_bus_suspend = false;
   458fe:	4b10      	ldr	r3, [pc, #64]	; (45940 <ev_usbevent_handler+0x6c>)
   45900:	2200      	movs	r2, #0
   45902:	701a      	strb	r2, [r3, #0]
        const nrfx_usbd_evt_t evt = {
   45904:	2303      	movs	r3, #3
   45906:	9301      	str	r3, [sp, #4]
                .type = NRFX_USBD_EVT_RESUME
        };
        m_event_handler(&evt);
   45908:	4b0e      	ldr	r3, [pc, #56]	; (45944 <ev_usbevent_handler+0x70>)
   4590a:	a801      	add	r0, sp, #4
   4590c:	681b      	ldr	r3, [r3, #0]
   4590e:	4798      	blx	r3
    }
    if (event & NRF_USBD_EVENTCAUSE_WUREQ_MASK)
   45910:	0563      	lsls	r3, r4, #21
   45912:	d510      	bpl.n	45936 <ev_usbevent_handler+0x62>
    {
        NRFX_LOG_DEBUG("USBD event: WUREQ (%s)", m_bus_suspend ? "In Suspend" : "Active");
        if (m_bus_suspend)
   45914:	4b0a      	ldr	r3, [pc, #40]	; (45940 <ev_usbevent_handler+0x6c>)
   45916:	781a      	ldrb	r2, [r3, #0]
   45918:	b16a      	cbz	r2, 45936 <ev_usbevent_handler+0x62>
        {
            NRFX_ASSERT(!nrf_usbd_lowpower_check(NRF_USBD));
            m_bus_suspend = false;
   4591a:	2200      	movs	r2, #0
   4591c:	701a      	strb	r2, [r3, #0]
    p_reg->DPDMVALUE = ((uint32_t)val) << USBD_DPDMVALUE_STATE_Pos;
   4591e:	4b07      	ldr	r3, [pc, #28]	; (4593c <ev_usbevent_handler+0x68>)
   45920:	2201      	movs	r2, #1
   45922:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)task)) = 1UL;
   45926:	659a      	str	r2, [r3, #88]	; 0x58
    (void)*(nrf_usbd_getRegPtr(p_reg, (uint32_t)task));
   45928:	6d9b      	ldr	r3, [r3, #88]	; 0x58

            nrf_usbd_dpdmvalue_set(NRF_USBD, NRF_USBD_DPDMVALUE_RESUME);
            nrf_usbd_task_trigger(NRF_USBD, NRF_USBD_TASK_DRIVEDPDM);

            const nrfx_usbd_evt_t evt = {
   4592a:	2304      	movs	r3, #4
   4592c:	9301      	str	r3, [sp, #4]
                    .type = NRFX_USBD_EVT_WUREQ
            };
            m_event_handler(&evt);
   4592e:	4b05      	ldr	r3, [pc, #20]	; (45944 <ev_usbevent_handler+0x70>)
   45930:	a801      	add	r0, sp, #4
   45932:	681b      	ldr	r3, [r3, #0]
   45934:	4798      	blx	r3
        }
    }
}
   45936:	b002      	add	sp, #8
   45938:	bd10      	pop	{r4, pc}
   4593a:	bf00      	nop
   4593c:	40027000 	.word	0x40027000
   45940:	20006bbe 	.word	0x20006bbe
   45944:	200068d4 	.word	0x200068d4

00045948 <usbd_errata_187_211_begin>:
	__asm__ volatile(
   45948:	f04f 0320 	mov.w	r3, #32
   4594c:	f3ef 8011 	mrs	r0, BASEPRI
   45950:	f383 8812 	msr	BASEPRI_MAX, r3
   45954:	f3bf 8f6f 	isb	sy
 * @brief Begin erratas 187 and 211.
 */
static inline void usbd_errata_187_211_begin(void)
{
    NRFX_CRITICAL_SECTION_ENTER();
    if (*((volatile uint32_t *)(0x4006EC00)) == 0x00000000)
   45958:	4b0a      	ldr	r3, [pc, #40]	; (45984 <usbd_errata_187_211_begin+0x3c>)
   4595a:	f8d3 1c00 	ldr.w	r1, [r3, #3072]	; 0xc00
   4595e:	2203      	movs	r2, #3
   45960:	b961      	cbnz	r1, 4597c <usbd_errata_187_211_begin+0x34>
    {
        *((volatile uint32_t *)(0x4006EC00)) = 0x00009375;
   45962:	f249 3175 	movw	r1, #37749	; 0x9375
   45966:	f8c3 1c00 	str.w	r1, [r3, #3072]	; 0xc00
        *((volatile uint32_t *)(0x4006ED14)) = 0x00000003;
   4596a:	f8c3 2d14 	str.w	r2, [r3, #3348]	; 0xd14
        *((volatile uint32_t *)(0x4006EC00)) = 0x00009375;
   4596e:	f8c3 1c00 	str.w	r1, [r3, #3072]	; 0xc00
	__asm__ volatile(
   45972:	f380 8811 	msr	BASEPRI, r0
   45976:	f3bf 8f6f 	isb	sy
    else
    {
        *((volatile uint32_t *)(0x4006ED14)) = 0x00000003;
    }
    NRFX_CRITICAL_SECTION_EXIT();
}
   4597a:	4770      	bx	lr
        *((volatile uint32_t *)(0x4006ED14)) = 0x00000003;
   4597c:	f8c3 2d14 	str.w	r2, [r3, #3348]	; 0xd14
   45980:	e7f7      	b.n	45972 <usbd_errata_187_211_begin+0x2a>
   45982:	bf00      	nop
   45984:	4006e000 	.word	0x4006e000

00045988 <usbd_errata_187_211_end>:
	__asm__ volatile(
   45988:	f04f 0320 	mov.w	r3, #32
   4598c:	f3ef 8011 	mrs	r0, BASEPRI
   45990:	f383 8812 	msr	BASEPRI_MAX, r3
   45994:	f3bf 8f6f 	isb	sy
 * @brief End erratas 187 and 211.
 */
static inline void usbd_errata_187_211_end(void)
{
    NRFX_CRITICAL_SECTION_ENTER();
    if (*((volatile uint32_t *)(0x4006EC00)) == 0x00000000)
   45998:	4b0a      	ldr	r3, [pc, #40]	; (459c4 <usbd_errata_187_211_end+0x3c>)
   4599a:	f8d3 1c00 	ldr.w	r1, [r3, #3072]	; 0xc00
   4599e:	b961      	cbnz	r1, 459ba <usbd_errata_187_211_end+0x32>
    {
        *((volatile uint32_t *)(0x4006EC00)) = 0x00009375;
   459a0:	f249 3275 	movw	r2, #37749	; 0x9375
   459a4:	f8c3 2c00 	str.w	r2, [r3, #3072]	; 0xc00
        *((volatile uint32_t *)(0x4006ED14)) = 0x00000000;
   459a8:	f8c3 1d14 	str.w	r1, [r3, #3348]	; 0xd14
        *((volatile uint32_t *)(0x4006EC00)) = 0x00009375;
   459ac:	f8c3 2c00 	str.w	r2, [r3, #3072]	; 0xc00
	__asm__ volatile(
   459b0:	f380 8811 	msr	BASEPRI, r0
   459b4:	f3bf 8f6f 	isb	sy
    else
    {
        *((volatile uint32_t *)(0x4006ED14)) = 0x00000000;
    }
    NRFX_CRITICAL_SECTION_EXIT();
}
   459b8:	4770      	bx	lr
        *((volatile uint32_t *)(0x4006ED14)) = 0x00000000;
   459ba:	2200      	movs	r2, #0
   459bc:	f8c3 2d14 	str.w	r2, [r3, #3348]	; 0xd14
   459c0:	e7f6      	b.n	459b0 <usbd_errata_187_211_end+0x28>
   459c2:	bf00      	nop
   459c4:	4006e000 	.word	0x4006e000

000459c8 <nrfx_usbd_feeder_flash>:
{
   459c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   459ca:	684b      	ldr	r3, [r1, #4]
    memcpy(p_buffer, (p_transfer->p_data.tx), tx_size);
   459cc:	4f0b      	ldr	r7, [pc, #44]	; (459fc <nrfx_usbd_feeder_flash+0x34>)
   459ce:	429a      	cmp	r2, r3
   459d0:	bf28      	it	cs
   459d2:	461a      	movcs	r2, r3
{
   459d4:	460c      	mov	r4, r1
   459d6:	4615      	mov	r5, r2
   459d8:	4606      	mov	r6, r0
    memcpy(p_buffer, (p_transfer->p_data.tx), tx_size);
   459da:	6809      	ldr	r1, [r1, #0]
   459dc:	4638      	mov	r0, r7
   459de:	f005 fa4c 	bl	4ae7a <memcpy>
    p_next->size = tx_size;
   459e2:	e9c6 7500 	strd	r7, r5, [r6]
    p_transfer->size -= tx_size;
   459e6:	6860      	ldr	r0, [r4, #4]
    p_transfer->p_data.addr += tx_size;
   459e8:	6823      	ldr	r3, [r4, #0]
    p_transfer->size -= tx_size;
   459ea:	1b40      	subs	r0, r0, r5
    p_transfer->p_data.addr += tx_size;
   459ec:	442b      	add	r3, r5
    p_transfer->size -= tx_size;
   459ee:	6060      	str	r0, [r4, #4]
    p_transfer->p_data.addr += tx_size;
   459f0:	6023      	str	r3, [r4, #0]
}
   459f2:	3800      	subs	r0, #0
   459f4:	bf18      	it	ne
   459f6:	2001      	movne	r0, #1
   459f8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   459fa:	bf00      	nop
   459fc:	20006694 	.word	0x20006694

00045a00 <nrfx_usbd_feeder_flash_zlp>:
{
   45a00:	b570      	push	{r4, r5, r6, lr}
   45a02:	684b      	ldr	r3, [r1, #4]
   45a04:	429a      	cmp	r2, r3
   45a06:	bf28      	it	cs
   45a08:	461a      	movcs	r2, r3
   45a0a:	4606      	mov	r6, r0
   45a0c:	460d      	mov	r5, r1
   45a0e:	4614      	mov	r4, r2
    if (tx_size != 0)
   45a10:	b182      	cbz	r2, 45a34 <nrfx_usbd_feeder_flash_zlp+0x34>
        memcpy(p_buffer, (p_transfer->p_data.tx), tx_size);
   45a12:	6809      	ldr	r1, [r1, #0]
   45a14:	4808      	ldr	r0, [pc, #32]	; (45a38 <nrfx_usbd_feeder_flash_zlp+0x38>)
   45a16:	f005 fa30 	bl	4ae7a <memcpy>
        p_next->p_data.tx = p_buffer;
   45a1a:	4b07      	ldr	r3, [pc, #28]	; (45a38 <nrfx_usbd_feeder_flash_zlp+0x38>)
    p_next->size = tx_size;
   45a1c:	e9c6 3400 	strd	r3, r4, [r6]
    p_transfer->size -= tx_size;
   45a20:	686b      	ldr	r3, [r5, #4]
   45a22:	1b1b      	subs	r3, r3, r4
   45a24:	606b      	str	r3, [r5, #4]
    p_transfer->p_data.addr += tx_size;
   45a26:	682b      	ldr	r3, [r5, #0]
   45a28:	4423      	add	r3, r4
}
   45a2a:	1e20      	subs	r0, r4, #0
    p_transfer->p_data.addr += tx_size;
   45a2c:	602b      	str	r3, [r5, #0]
}
   45a2e:	bf18      	it	ne
   45a30:	2001      	movne	r0, #1
   45a32:	bd70      	pop	{r4, r5, r6, pc}
   45a34:	4613      	mov	r3, r2
   45a36:	e7f1      	b.n	45a1c <nrfx_usbd_feeder_flash_zlp+0x1c>
   45a38:	20006694 	.word	0x20006694

00045a3c <ev_sof_handler>:
{
   45a3c:	b507      	push	{r0, r1, r2, lr}
    nrfx_usbd_evt_t evt =  {
   45a3e:	2300      	movs	r3, #0
   45a40:	f88d 3004 	strb.w	r3, [sp, #4]
    return p_reg->FRAMECNTR;
   45a44:	4b0b      	ldr	r3, [pc, #44]	; (45a74 <ev_sof_handler+0x38>)
   45a46:	f8d3 2520 	ldr.w	r2, [r3, #1312]	; 0x520
            .data = { .sof = { .framecnt = (uint16_t)nrf_usbd_framecntr_get(NRF_USBD) }}
   45a4a:	f8ad 2006 	strh.w	r2, [sp, #6]
    size_t size_isoout = p_reg->SIZE.ISOOUT;
   45a4e:	f8d3 34c0 	ldr.w	r3, [r3, #1216]	; 0x4c0
    m_ep_ready |= iso_ready_mask;
   45a52:	4a09      	ldr	r2, [pc, #36]	; (45a78 <ev_sof_handler+0x3c>)
    uint32_t iso_ready_mask = (1U << ep2bit(NRFX_USBD_EPIN8));
   45a54:	2b00      	cmp	r3, #0
    m_ep_ready |= iso_ready_mask;
   45a56:	6813      	ldr	r3, [r2, #0]
    uint32_t iso_ready_mask = (1U << ep2bit(NRFX_USBD_EPIN8));
   45a58:	bf14      	ite	ne
   45a5a:	f04f 2101 	movne.w	r1, #16777472	; 0x1000100
   45a5e:	f44f 7180 	moveq.w	r1, #256	; 0x100
    m_ep_ready |= iso_ready_mask;
   45a62:	430b      	orrs	r3, r1
   45a64:	6013      	str	r3, [r2, #0]
    m_event_handler(&evt);
   45a66:	4b05      	ldr	r3, [pc, #20]	; (45a7c <ev_sof_handler+0x40>)
   45a68:	a801      	add	r0, sp, #4
   45a6a:	681b      	ldr	r3, [r3, #0]
   45a6c:	4798      	blx	r3
}
   45a6e:	b003      	add	sp, #12
   45a70:	f85d fb04 	ldr.w	pc, [sp], #4
   45a74:	40027000 	.word	0x40027000
   45a78:	200068d0 	.word	0x200068d0
   45a7c:	200068d4 	.word	0x200068d4

00045a80 <atomic_and.constprop.0.isra.0>:
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   45a80:	4b06      	ldr	r3, [pc, #24]	; (45a9c <atomic_and.constprop.0.isra.0+0x1c>)
   45a82:	f3bf 8f5b 	dmb	ish
   45a86:	e853 1f00 	ldrex	r1, [r3]
   45a8a:	4001      	ands	r1, r0
   45a8c:	e843 1200 	strex	r2, r1, [r3]
   45a90:	2a00      	cmp	r2, #0
   45a92:	d1f8      	bne.n	45a86 <atomic_and.constprop.0.isra.0+0x6>
   45a94:	f3bf 8f5b 	dmb	ish
}
   45a98:	4770      	bx	lr
   45a9a:	bf00      	nop
   45a9c:	200068cc 	.word	0x200068cc

00045aa0 <usbd_dma_pending_clear>:
            uint32_t var1 = *(uint32_t *)0x10000130ul;
   45aa0:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
            if (var1 == 0x08)
   45aa4:	f8d3 3130 	ldr.w	r3, [r3, #304]	; 0x130
   45aa8:	2b08      	cmp	r3, #8
        *((volatile uint32_t *)0x40027C1C) = 0x00000000;
   45aaa:	bf02      	ittt	eq
   45aac:	4b03      	ldreq	r3, [pc, #12]	; (45abc <usbd_dma_pending_clear+0x1c>)
   45aae:	2200      	moveq	r2, #0
   45ab0:	f8c3 2c1c 	streq.w	r2, [r3, #3100]	; 0xc1c
    m_dma_pending = false;
   45ab4:	4b02      	ldr	r3, [pc, #8]	; (45ac0 <usbd_dma_pending_clear+0x20>)
   45ab6:	2200      	movs	r2, #0
   45ab8:	701a      	strb	r2, [r3, #0]
}
   45aba:	4770      	bx	lr
   45abc:	40027000 	.word	0x40027000
   45ac0:	20006bbc 	.word	0x20006bbc

00045ac4 <nrf_usbd_ep0in_dma_handler>:
{
   45ac4:	b508      	push	{r3, lr}
    usbd_dma_pending_clear();
   45ac6:	f7ff ffeb 	bl	45aa0 <usbd_dma_pending_clear>
    if (NRFX_USBD_EP_ABORTED == p_state->status)
   45aca:	4b08      	ldr	r3, [pc, #32]	; (45aec <nrf_usbd_ep0in_dma_handler+0x28>)
   45acc:	f893 209e 	ldrb.w	r2, [r3, #158]	; 0x9e
   45ad0:	2a03      	cmp	r2, #3
   45ad2:	d105      	bne.n	45ae0 <nrf_usbd_ep0in_dma_handler+0x1c>
}
   45ad4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   45ad8:	f06f 0001 	mvn.w	r0, #1
   45adc:	f7ff bfd0 	b.w	45a80 <atomic_and.constprop.0.isra.0>
    else if (p_state->handler.feeder == NULL)
   45ae0:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
   45ae4:	2b00      	cmp	r3, #0
   45ae6:	d0f5      	beq.n	45ad4 <nrf_usbd_ep0in_dma_handler+0x10>
}
   45ae8:	bd08      	pop	{r3, pc}
   45aea:	bf00      	nop
   45aec:	200067ac 	.word	0x200067ac

00045af0 <usbd_ep_data_handler>:
{
   45af0:	b573      	push	{r0, r1, r4, r5, r6, lr}
    m_ep_ready |= (1U << bitpos);
   45af2:	2201      	movs	r2, #1
   45af4:	fa02 f501 	lsl.w	r5, r2, r1
   45af8:	491c      	ldr	r1, [pc, #112]	; (45b6c <usbd_ep_data_handler+0x7c>)
   45afa:	4e1d      	ldr	r6, [pc, #116]	; (45b70 <usbd_ep_data_handler+0x80>)
   45afc:	680b      	ldr	r3, [r1, #0]
    if (NRF_USBD_EPIN_CHECK(ep))
   45afe:	f010 0f80 	tst.w	r0, #128	; 0x80
    m_ep_ready |= (1U << bitpos);
   45b02:	ea43 0305 	orr.w	r3, r3, r5
{
   45b06:	4604      	mov	r4, r0
    m_ep_ready |= (1U << bitpos);
   45b08:	600b      	str	r3, [r1, #0]
    if (NRF_USBD_EPIN_CHECK(ep))
   45b0a:	d024      	beq.n	45b56 <usbd_ep_data_handler+0x66>
    return (NRF_USBD_EPIN_CHECK(ep) ? epin_endev : epout_endev)[NRF_USBD_EP_NR_GET(ep)];
   45b0c:	f000 020f 	and.w	r2, r0, #15
   45b10:	4b18      	ldr	r3, [pc, #96]	; (45b74 <usbd_ep_data_handler+0x84>)
    return (bool)*nrf_usbd_getRegPtr_c(p_reg, (uint32_t)event);
   45b12:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    return (volatile const uint32_t*)(((uint8_t *)p_reg) + (uint32_t)offset);
   45b16:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   45b1a:	f503 331c 	add.w	r3, r3, #159744	; 0x27000
    return (bool)*nrf_usbd_getRegPtr_c(p_reg, (uint32_t)event);
   45b1e:	681a      	ldr	r2, [r3, #0]
    if (ret)
   45b20:	b132      	cbz	r2, 45b30 <usbd_ep_data_handler+0x40>
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)event)) = 0UL;
   45b22:	2200      	movs	r2, #0
   45b24:	601a      	str	r2, [r3, #0]
            if (ep != NRFX_USBD_EPIN0)
   45b26:	2880      	cmp	r0, #128	; 0x80
    (void)*(nrf_usbd_getRegPtr(p_reg, (uint32_t)event));
   45b28:	681b      	ldr	r3, [r3, #0]
   45b2a:	d011      	beq.n	45b50 <usbd_ep_data_handler+0x60>
                nrf_usbd_epin_dma_handler(ep);
   45b2c:	f009 fcb8 	bl	4f4a0 <nrf_usbd_epin_dma_handler>
        if (0 == (m_ep_dma_waiting & (1U << bitpos)))
   45b30:	6833      	ldr	r3, [r6, #0]
   45b32:	402b      	ands	r3, r5
   45b34:	d10a      	bne.n	45b4c <usbd_ep_data_handler+0x5c>
            NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
   45b36:	2206      	movs	r2, #6
   45b38:	f88d 2004 	strb.w	r2, [sp, #4]
   45b3c:	f88d 4006 	strb.w	r4, [sp, #6]
   45b40:	f88d 3007 	strb.w	r3, [sp, #7]
            m_event_handler(&evt);
   45b44:	4b0c      	ldr	r3, [pc, #48]	; (45b78 <usbd_ep_data_handler+0x88>)
   45b46:	a801      	add	r0, sp, #4
   45b48:	681b      	ldr	r3, [r3, #0]
   45b4a:	4798      	blx	r3
}
   45b4c:	b002      	add	sp, #8
   45b4e:	bd70      	pop	{r4, r5, r6, pc}
                nrf_usbd_ep0in_dma_handler();
   45b50:	f7ff ffb8 	bl	45ac4 <nrf_usbd_ep0in_dma_handler>
   45b54:	e7ec      	b.n	45b30 <usbd_ep_data_handler+0x40>
        if (0 == (m_ep_dma_waiting & (1U << bitpos)))
   45b56:	6833      	ldr	r3, [r6, #0]
   45b58:	421d      	tst	r5, r3
   45b5a:	d1f7      	bne.n	45b4c <usbd_ep_data_handler+0x5c>
            NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_WAITING);
   45b5c:	2306      	movs	r3, #6
   45b5e:	f88d 3004 	strb.w	r3, [sp, #4]
   45b62:	f88d 0006 	strb.w	r0, [sp, #6]
   45b66:	f88d 2007 	strb.w	r2, [sp, #7]
   45b6a:	e7eb      	b.n	45b44 <usbd_ep_data_handler+0x54>
   45b6c:	200068d0 	.word	0x200068d0
   45b70:	200068cc 	.word	0x200068cc
   45b74:	0005302a 	.word	0x0005302a
   45b78:	200068d4 	.word	0x200068d4

00045b7c <ev_setup_data_handler>:
{
   45b7c:	b508      	push	{r3, lr}
    usbd_ep_data_handler(m_last_setup_dir, ep2bit(m_last_setup_dir));
   45b7e:	4b05      	ldr	r3, [pc, #20]	; (45b94 <ev_setup_data_handler+0x18>)
   45b80:	781a      	ldrb	r2, [r3, #0]
   45b82:	4610      	mov	r0, r2
   45b84:	f009 fc83 	bl	4f48e <ep2bit>
}
   45b88:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    usbd_ep_data_handler(m_last_setup_dir, ep2bit(m_last_setup_dir));
   45b8c:	4601      	mov	r1, r0
   45b8e:	4610      	mov	r0, r2
   45b90:	f7ff bfae 	b.w	45af0 <usbd_ep_data_handler>
   45b94:	20006bbd 	.word	0x20006bbd

00045b98 <ev_dma_epout8_handler>:
static void ev_dma_epout8_handler(void) { nrf_usbd_epoutiso_dma_handler(NRFX_USBD_EPOUT8); }
   45b98:	b507      	push	{r0, r1, r2, lr}
    usbd_dma_pending_clear();
   45b9a:	f7ff ff81 	bl	45aa0 <usbd_dma_pending_clear>
    if (NRFX_USBD_EP_ABORTED == p_state->status)
   45b9e:	4b0c      	ldr	r3, [pc, #48]	; (45bd0 <ev_dma_epout8_handler+0x38>)
   45ba0:	f893 208e 	ldrb.w	r2, [r3, #142]	; 0x8e
   45ba4:	2a03      	cmp	r2, #3
   45ba6:	d010      	beq.n	45bca <ev_dma_epout8_handler+0x32>
    else if (p_state->handler.consumer == NULL)
   45ba8:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
   45bac:	b96b      	cbnz	r3, 45bca <ev_dma_epout8_handler+0x32>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   45bae:	f06f 7080 	mvn.w	r0, #16777216	; 0x1000000
   45bb2:	f7ff ff65 	bl	45a80 <atomic_and.constprop.0.isra.0>
        NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
   45bb6:	2306      	movs	r3, #6
   45bb8:	f88d 3004 	strb.w	r3, [sp, #4]
   45bbc:	2308      	movs	r3, #8
   45bbe:	f8ad 3006 	strh.w	r3, [sp, #6]
        m_event_handler(&evt);
   45bc2:	4b04      	ldr	r3, [pc, #16]	; (45bd4 <ev_dma_epout8_handler+0x3c>)
   45bc4:	a801      	add	r0, sp, #4
   45bc6:	681b      	ldr	r3, [r3, #0]
   45bc8:	4798      	blx	r3
static void ev_dma_epout8_handler(void) { nrf_usbd_epoutiso_dma_handler(NRFX_USBD_EPOUT8); }
   45bca:	b003      	add	sp, #12
   45bcc:	f85d fb04 	ldr.w	pc, [sp], #4
   45bd0:	200067ac 	.word	0x200067ac
   45bd4:	200068d4 	.word	0x200068d4

00045bd8 <ev_dma_epin8_handler>:
static void ev_dma_epin8_handler(void)  { nrf_usbd_epiniso_dma_handler(NRFX_USBD_EPIN8 ); }
   45bd8:	b507      	push	{r0, r1, r2, lr}
    usbd_dma_pending_clear();
   45bda:	f7ff ff61 	bl	45aa0 <usbd_dma_pending_clear>
    if (NRFX_USBD_EP_ABORTED == p_state->status)
   45bde:	4b10      	ldr	r3, [pc, #64]	; (45c20 <ev_dma_epin8_handler+0x48>)
   45be0:	f893 211e 	ldrb.w	r2, [r3, #286]	; 0x11e
   45be4:	2a03      	cmp	r2, #3
   45be6:	d106      	bne.n	45bf6 <ev_dma_epin8_handler+0x1e>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   45be8:	f46f 7080 	mvn.w	r0, #256	; 0x100
static void ev_dma_epin8_handler(void)  { nrf_usbd_epiniso_dma_handler(NRFX_USBD_EPIN8 ); }
   45bec:	b003      	add	sp, #12
   45bee:	f85d eb04 	ldr.w	lr, [sp], #4
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   45bf2:	f7ff bf45 	b.w	45a80 <atomic_and.constprop.0.isra.0>
    else if (p_state->handler.feeder == NULL)
   45bf6:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
   45bfa:	b96b      	cbnz	r3, 45c18 <ev_dma_epin8_handler+0x40>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   45bfc:	f46f 7080 	mvn.w	r0, #256	; 0x100
   45c00:	f7ff ff3e 	bl	45a80 <atomic_and.constprop.0.isra.0>
        NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
   45c04:	2306      	movs	r3, #6
   45c06:	f88d 3004 	strb.w	r3, [sp, #4]
   45c0a:	2388      	movs	r3, #136	; 0x88
   45c0c:	f8ad 3006 	strh.w	r3, [sp, #6]
        m_event_handler(&evt);
   45c10:	4b04      	ldr	r3, [pc, #16]	; (45c24 <ev_dma_epin8_handler+0x4c>)
   45c12:	a801      	add	r0, sp, #4
   45c14:	681b      	ldr	r3, [r3, #0]
   45c16:	4798      	blx	r3
static void ev_dma_epin8_handler(void)  { nrf_usbd_epiniso_dma_handler(NRFX_USBD_EPIN8 ); }
   45c18:	b003      	add	sp, #12
   45c1a:	f85d fb04 	ldr.w	pc, [sp], #4
   45c1e:	bf00      	nop
   45c20:	200067ac 	.word	0x200067ac
   45c24:	200068d4 	.word	0x200068d4

00045c28 <nrfx_usbd_uninit>:

void nrfx_usbd_uninit(void)
{
    NRFX_ASSERT(m_drv_state == NRFX_DRV_STATE_INITIALIZED);

    m_event_handler = NULL;
   45c28:	4a02      	ldr	r2, [pc, #8]	; (45c34 <nrfx_usbd_uninit+0xc>)
   45c2a:	2300      	movs	r3, #0
   45c2c:	6013      	str	r3, [r2, #0]
    m_drv_state = NRFX_DRV_STATE_UNINITIALIZED;
   45c2e:	4a02      	ldr	r2, [pc, #8]	; (45c38 <nrfx_usbd_uninit+0x10>)
   45c30:	7013      	strb	r3, [r2, #0]
    return;
}
   45c32:	4770      	bx	lr
   45c34:	200068d4 	.word	0x200068d4
   45c38:	20006bbf 	.word	0x20006bbf

00045c3c <nrfx_usbd_enable>:


void nrfx_usbd_enable(void)
{
   45c3c:	b508      	push	{r3, lr}
    p_reg->EVENTCAUSE = flags;
   45c3e:	4b4c      	ldr	r3, [pc, #304]	; (45d70 <nrfx_usbd_enable+0x134>)
   45c40:	f44f 6200 	mov.w	r2, #2048	; 0x800
   45c44:	f8c3 2400 	str.w	r2, [r3, #1024]	; 0x400
    (void) p_reg->EVENTCAUSE;
   45c48:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
}

/* Errata: USB cannot be enabled. **/
static inline bool nrfx_usbd_errata_187(void)
{
    return NRFX_USBD_ERRATA_ENABLE && nrf52_errata_187();
   45c4c:	f7ff fe0a 	bl	45864 <nrf52_errata_187>
    if (nrfx_usbd_errata_187())
   45c50:	b108      	cbz	r0, 45c56 <nrfx_usbd_enable+0x1a>
        usbd_errata_187_211_begin();
   45c52:	f7ff fe79 	bl	45948 <usbd_errata_187_211_begin>
            uint32_t var1 = *(uint32_t *)0x10000130ul;
   45c56:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
            if (var1 == 0x08)
   45c5a:	f8d3 3130 	ldr.w	r3, [r3, #304]	; 0x130
   45c5e:	2b08      	cmp	r3, #8
   45c60:	d119      	bne.n	45c96 <nrfx_usbd_enable+0x5a>
	__asm__ volatile(
   45c62:	f04f 0320 	mov.w	r3, #32
   45c66:	f3ef 8011 	mrs	r0, BASEPRI
   45c6a:	f383 8812 	msr	BASEPRI_MAX, r3
   45c6e:	f3bf 8f6f 	isb	sy
    if (*((volatile uint32_t *)(0x4006EC00)) == 0x00000000)
   45c72:	4b40      	ldr	r3, [pc, #256]	; (45d74 <nrfx_usbd_enable+0x138>)
   45c74:	f8d3 1c00 	ldr.w	r1, [r3, #3072]	; 0xc00
   45c78:	22c0      	movs	r2, #192	; 0xc0
   45c7a:	2900      	cmp	r1, #0
   45c7c:	d170      	bne.n	45d60 <nrfx_usbd_enable+0x124>
        *((volatile uint32_t *)(0x4006EC00)) = 0x00009375;
   45c7e:	f249 3175 	movw	r1, #37749	; 0x9375
   45c82:	f8c3 1c00 	str.w	r1, [r3, #3072]	; 0xc00
        *((volatile uint32_t *)(0x4006EC14)) = 0x000000C0;
   45c86:	f8c3 2c14 	str.w	r2, [r3, #3092]	; 0xc14
        *((volatile uint32_t *)(0x4006EC00)) = 0x00009375;
   45c8a:	f8c3 1c00 	str.w	r1, [r3, #3072]	; 0xc00
	__asm__ volatile(
   45c8e:	f380 8811 	msr	BASEPRI, r0
   45c92:	f3bf 8f6f 	isb	sy
    p_reg->ENABLE = USBD_ENABLE_ENABLE_Enabled << USBD_ENABLE_ENABLE_Pos;
   45c96:	4b36      	ldr	r3, [pc, #216]	; (45d70 <nrfx_usbd_enable+0x134>)
   45c98:	2201      	movs	r2, #1
   45c9a:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
    (void) p_reg->ENABLE;
   45c9e:	f8d3 2500 	ldr.w	r2, [r3, #1280]	; 0x500
    return p_reg->EVENTCAUSE;
   45ca2:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
    while (0 == (eventcause & nrf_usbd_eventcause_get(NRF_USBD)))
   45ca6:	0512      	lsls	r2, r2, #20
   45ca8:	d5fb      	bpl.n	45ca2 <nrfx_usbd_enable+0x66>
    p_reg->EVENTCAUSE = flags;
   45caa:	f44f 6200 	mov.w	r2, #2048	; 0x800
   45cae:	f8c3 2400 	str.w	r2, [r3, #1024]	; 0x400
    (void) p_reg->EVENTCAUSE;
   45cb2:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
            uint32_t var1 = *(uint32_t *)0x10000130ul;
   45cb6:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
            if (var1 == 0x08)
   45cba:	f8d3 3130 	ldr.w	r3, [r3, #304]	; 0x130
   45cbe:	2b08      	cmp	r3, #8
   45cc0:	d118      	bne.n	45cf4 <nrfx_usbd_enable+0xb8>
	__asm__ volatile(
   45cc2:	f04f 0320 	mov.w	r3, #32
   45cc6:	f3ef 8011 	mrs	r0, BASEPRI
   45cca:	f383 8812 	msr	BASEPRI_MAX, r3
   45cce:	f3bf 8f6f 	isb	sy
    if (*((volatile uint32_t *)(0x4006EC00)) == 0x00000000)
   45cd2:	4b28      	ldr	r3, [pc, #160]	; (45d74 <nrfx_usbd_enable+0x138>)
   45cd4:	f8d3 1c00 	ldr.w	r1, [r3, #3072]	; 0xc00
   45cd8:	2900      	cmp	r1, #0
   45cda:	d144      	bne.n	45d66 <nrfx_usbd_enable+0x12a>
        *((volatile uint32_t *)(0x4006EC00)) = 0x00009375;
   45cdc:	f249 3275 	movw	r2, #37749	; 0x9375
   45ce0:	f8c3 2c00 	str.w	r2, [r3, #3072]	; 0xc00
        *((volatile uint32_t *)(0x4006EC14)) = 0x00000000;
   45ce4:	f8c3 1c14 	str.w	r1, [r3, #3092]	; 0xc14
        *((volatile uint32_t *)(0x4006EC00)) = 0x00009375;
   45ce8:	f8c3 2c00 	str.w	r2, [r3, #3072]	; 0xc00
	__asm__ volatile(
   45cec:	f380 8811 	msr	BASEPRI, r0
   45cf0:	f3bf 8f6f 	isb	sy
   45cf4:	f7ff fdb6 	bl	45864 <nrf52_errata_187>
    if (nrfx_usbd_errata_187())
   45cf8:	b130      	cbz	r0, 45d08 <nrfx_usbd_enable+0xcc>
        usbd_errata_187_211_end();
   45cfa:	f7ff fe45 	bl	45988 <usbd_errata_187_211_end>
   45cfe:	f7ff fdb1 	bl	45864 <nrf52_errata_187>
    }

#if NRFX_USBD_USE_WORKAROUND_FOR_ANOMALY_211
    if (nrfx_usbd_errata_187() || nrfx_usbd_errata_211())
#else
    if (nrfx_usbd_errata_187())
   45d02:	b108      	cbz	r0, 45d08 <nrfx_usbd_enable+0xcc>
#endif
    {
        usbd_errata_187_211_begin();
   45d04:	f7ff fe20 	bl	45948 <usbd_errata_187_211_begin>
            uint32_t var1 = *(uint32_t *)0x10000130ul;
   45d08:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
            if (var1 == 0x08)
   45d0c:	f8d3 3130 	ldr.w	r3, [r3, #304]	; 0x130
   45d10:	2b08      	cmp	r3, #8
   45d12:	4b17      	ldr	r3, [pc, #92]	; (45d70 <nrfx_usbd_enable+0x134>)
   45d14:	d10a      	bne.n	45d2c <nrfx_usbd_enable+0xf0>
    }

    if (nrfx_usbd_errata_166())
    {
        *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x800)) = 0x7E3;
   45d16:	f240 72e3 	movw	r2, #2019	; 0x7e3
   45d1a:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
        *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)) = 0x40;
   45d1e:	2240      	movs	r2, #64	; 0x40
   45d20:	f8c3 2804 	str.w	r2, [r3, #2052]	; 0x804
  __ASM volatile ("isb 0xF":::"memory");
   45d24:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
   45d28:	f3bf 8f4f 	dsb	sy
    p_reg->ISOINCONFIG = ((uint32_t)config) << USBD_ISOINCONFIG_RESPONSE_Pos;
   45d2c:	2100      	movs	r1, #0
    p_reg->ISOSPLIT = split << USBD_ISOSPLIT_SPLIT_Pos;
   45d2e:	2280      	movs	r2, #128	; 0x80
   45d30:	f8c3 251c 	str.w	r2, [r3, #1308]	; 0x51c
    p_reg->ISOINCONFIG = ((uint32_t)config) << USBD_ISOINCONFIG_RESPONSE_Pos;
   45d34:	f8c3 1530 	str.w	r1, [r3, #1328]	; 0x530
    else
    {
        nrfx_usbd_isoinconfig_set(NRF_USBD_ISOINCONFIG_NORESP);
    }

    m_ep_ready = (((1U << NRF_USBD_EPIN_CNT) - 1U) << NRFX_USBD_EPIN_BITPOS_0);
   45d38:	4b0f      	ldr	r3, [pc, #60]	; (45d78 <nrfx_usbd_enable+0x13c>)
   45d3a:	f240 12ff 	movw	r2, #511	; 0x1ff
   45d3e:	601a      	str	r2, [r3, #0]
    m_ep_dma_waiting = 0;
   45d40:	4b0e      	ldr	r3, [pc, #56]	; (45d7c <nrfx_usbd_enable+0x140>)
   45d42:	6019      	str	r1, [r3, #0]
    usbd_dma_pending_clear();
   45d44:	f7ff feac 	bl	45aa0 <usbd_dma_pending_clear>
    m_last_setup_dir = NRFX_USBD_EPOUT0;
   45d48:	4b0d      	ldr	r3, [pc, #52]	; (45d80 <nrfx_usbd_enable+0x144>)
   45d4a:	7019      	strb	r1, [r3, #0]

    m_drv_state = NRFX_DRV_STATE_POWERED_ON;
   45d4c:	4b0d      	ldr	r3, [pc, #52]	; (45d84 <nrfx_usbd_enable+0x148>)
   45d4e:	2202      	movs	r2, #2
   45d50:	701a      	strb	r2, [r3, #0]
   45d52:	f7ff fd87 	bl	45864 <nrf52_errata_187>

#if NRFX_USBD_USE_WORKAROUND_FOR_ANOMALY_211
    if (nrfx_usbd_errata_187() && !nrfx_usbd_errata_211())
#else
    if (nrfx_usbd_errata_187())
   45d56:	b150      	cbz	r0, 45d6e <nrfx_usbd_enable+0x132>
#endif
    {
        usbd_errata_187_211_end();
    }
}
   45d58:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        usbd_errata_187_211_end();
   45d5c:	f7ff be14 	b.w	45988 <usbd_errata_187_211_end>
        *((volatile uint32_t *)(0x4006EC14)) = 0x000000C0;
   45d60:	f8c3 2c14 	str.w	r2, [r3, #3092]	; 0xc14
   45d64:	e793      	b.n	45c8e <nrfx_usbd_enable+0x52>
        *((volatile uint32_t *)(0x4006EC14)) = 0x00000000;
   45d66:	2200      	movs	r2, #0
   45d68:	f8c3 2c14 	str.w	r2, [r3, #3092]	; 0xc14
   45d6c:	e7be      	b.n	45cec <nrfx_usbd_enable+0xb0>
}
   45d6e:	bd08      	pop	{r3, pc}
   45d70:	40027000 	.word	0x40027000
   45d74:	4006e000 	.word	0x4006e000
   45d78:	200068d0 	.word	0x200068d0
   45d7c:	200068cc 	.word	0x200068cc
   45d80:	20006bbd 	.word	0x20006bbd
   45d84:	20006bbf 	.word	0x20006bbf

00045d88 <nrfx_usbd_start>:
}

void nrfx_usbd_start(bool enable_sof)
{
    NRFX_ASSERT(m_drv_state == NRFX_DRV_STATE_POWERED_ON);
    m_bus_suspend = false;
   45d88:	4b0a      	ldr	r3, [pc, #40]	; (45db4 <nrfx_usbd_start+0x2c>)
   45d8a:	2200      	movs	r2, #0
{
   45d8c:	b510      	push	{r4, lr}
    m_bus_suspend = false;
   45d8e:	701a      	strb	r2, [r3, #0]

    uint32_t ints_to_enable =
   45d90:	4a09      	ldr	r2, [pc, #36]	; (45db8 <nrfx_usbd_start+0x30>)
   45d92:	4b0a      	ldr	r3, [pc, #40]	; (45dbc <nrfx_usbd_start+0x34>)
    p_reg->INTENSET = mask;
   45d94:	4c0a      	ldr	r4, [pc, #40]	; (45dc0 <nrfx_usbd_start+0x38>)
   45d96:	2800      	cmp	r0, #0
   45d98:	bf08      	it	eq
   45d9a:	4613      	moveq	r3, r2
   45d9c:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
   /* Enable all required interrupts */
   nrf_usbd_int_enable(NRF_USBD, ints_to_enable);

   /* Enable interrupt globally */
   NRFX_IRQ_PRIORITY_SET(USBD_IRQn, NRFX_USBD_DEFAULT_CONFIG_IRQ_PRIORITY);
   NRFX_IRQ_ENABLE(USBD_IRQn);
   45da0:	2027      	movs	r0, #39	; 0x27
   45da2:	f7e7 f807 	bl	2cdb4 <arch_irq_enable>
    p_reg->USBPULLUP = USBD_USBPULLUP_CONNECT_Enabled << USBD_USBPULLUP_CONNECT_Pos;
   45da6:	2301      	movs	r3, #1
   45da8:	f8c4 3504 	str.w	r3, [r4, #1284]	; 0x504
    (void) p_reg->USBPULLUP;
   45dac:	f8d4 3504 	ldr.w	r3, [r4, #1284]	; 0x504

   /* Enable pullups */
   nrf_usbd_pullup_enable(NRF_USBD);
}
   45db0:	bd10      	pop	{r4, pc}
   45db2:	bf00      	nop
   45db4:	20006bbe 	.word	0x20006bbe
   45db8:	01c01407 	.word	0x01c01407
   45dbc:	01e01407 	.word	0x01e01407
   45dc0:	40027000 	.word	0x40027000

00045dc4 <nrfx_usbd_is_enabled>:
    return (m_drv_state >= NRFX_DRV_STATE_INITIALIZED);
}

bool nrfx_usbd_is_enabled(void)
{
    return (m_drv_state >= NRFX_DRV_STATE_POWERED_ON);
   45dc4:	4b03      	ldr	r3, [pc, #12]	; (45dd4 <nrfx_usbd_is_enabled+0x10>)
   45dc6:	7818      	ldrb	r0, [r3, #0]
}
   45dc8:	2801      	cmp	r0, #1
   45dca:	bf94      	ite	ls
   45dcc:	2000      	movls	r0, #0
   45dce:	2001      	movhi	r0, #1
   45dd0:	4770      	bx	lr
   45dd2:	bf00      	nop
   45dd4:	20006bbf 	.word	0x20006bbf

00045dd8 <nrfx_usbd_wakeup_req>:

    return suspended;
}

bool nrfx_usbd_wakeup_req(void)
{
   45dd8:	b510      	push	{r4, lr}
	__asm__ volatile(
   45dda:	f04f 0320 	mov.w	r3, #32
   45dde:	f3ef 8411 	mrs	r4, BASEPRI
   45de2:	f383 8812 	msr	BASEPRI_MAX, r3
   45de6:	f3bf 8f6f 	isb	sy
    bool started = false;

    NRFX_CRITICAL_SECTION_ENTER();
    if (m_bus_suspend && nrf_usbd_lowpower_check(NRF_USBD))
   45dea:	4b15      	ldr	r3, [pc, #84]	; (45e40 <nrfx_usbd_wakeup_req+0x68>)
   45dec:	781b      	ldrb	r3, [r3, #0]
   45dee:	f003 00ff 	and.w	r0, r3, #255	; 0xff
   45df2:	b1db      	cbz	r3, 45e2c <nrfx_usbd_wakeup_req+0x54>
    return (p_reg->LOWPOWER != (USBD_LOWPOWER_LOWPOWER_ForceNormal << USBD_LOWPOWER_LOWPOWER_Pos));
   45df4:	4b13      	ldr	r3, [pc, #76]	; (45e44 <nrfx_usbd_wakeup_req+0x6c>)
   45df6:	f8d3 252c 	ldr.w	r2, [r3, #1324]	; 0x52c
   45dfa:	b1fa      	cbz	r2, 45e3c <nrfx_usbd_wakeup_req+0x64>
    p_reg->LOWPOWER = USBD_LOWPOWER_LOWPOWER_ForceNormal << USBD_LOWPOWER_LOWPOWER_Pos;
   45dfc:	2200      	movs	r2, #0
   45dfe:	f8c3 252c 	str.w	r2, [r3, #1324]	; 0x52c
    (void) p_reg->LOWPOWER;
   45e02:	f8d3 352c 	ldr.w	r3, [r3, #1324]	; 0x52c
            uint32_t var1 = *(uint32_t *)0x10000130ul;
   45e06:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
            if (var1 == 0x08)
   45e0a:	f8d3 3130 	ldr.w	r3, [r3, #304]	; 0x130
   45e0e:	2b08      	cmp	r3, #8
   45e10:	d10c      	bne.n	45e2c <nrfx_usbd_wakeup_req+0x54>
        nrf_usbd_lowpower_disable(NRF_USBD);
        started = true;

        if (nrfx_usbd_errata_171())
        {
            if (*((volatile uint32_t *)(0x4006EC00)) == 0x00000000)
   45e12:	4b0d      	ldr	r3, [pc, #52]	; (45e48 <nrfx_usbd_wakeup_req+0x70>)
   45e14:	f8d3 1c00 	ldr.w	r1, [r3, #3072]	; 0xc00
   45e18:	22c0      	movs	r2, #192	; 0xc0
   45e1a:	b961      	cbnz	r1, 45e36 <nrfx_usbd_wakeup_req+0x5e>
            {
                *((volatile uint32_t *)(0x4006EC00)) = 0x00009375;
   45e1c:	f249 3175 	movw	r1, #37749	; 0x9375
   45e20:	f8c3 1c00 	str.w	r1, [r3, #3072]	; 0xc00
                *((volatile uint32_t *)(0x4006EC14)) = 0x000000C0;
   45e24:	f8c3 2c14 	str.w	r2, [r3, #3092]	; 0xc14
                *((volatile uint32_t *)(0x4006EC00)) = 0x00009375;
   45e28:	f8c3 1c00 	str.w	r1, [r3, #3072]	; 0xc00
	__asm__ volatile(
   45e2c:	f384 8811 	msr	BASEPRI, r4
   45e30:	f3bf 8f6f 	isb	sy
        }
    }
    NRFX_CRITICAL_SECTION_EXIT();

    return started;
}
   45e34:	bd10      	pop	{r4, pc}
                *((volatile uint32_t *)(0x4006EC14)) = 0x000000C0;
   45e36:	f8c3 2c14 	str.w	r2, [r3, #3092]	; 0xc14
   45e3a:	e7f7      	b.n	45e2c <nrfx_usbd_wakeup_req+0x54>
    bool started = false;
   45e3c:	4610      	mov	r0, r2
   45e3e:	e7f5      	b.n	45e2c <nrfx_usbd_wakeup_req+0x54>
   45e40:	20006bbe 	.word	0x20006bbe
   45e44:	40027000 	.word	0x40027000
   45e48:	4006e000 	.word	0x4006e000

00045e4c <nrfx_usbd_init>:
{
   45e4c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if (m_drv_state != NRFX_DRV_STATE_UNINITIALIZED)
   45e4e:	4b1c      	ldr	r3, [pc, #112]	; (45ec0 <nrfx_usbd_init+0x74>)
   45e50:	781c      	ldrb	r4, [r3, #0]
   45e52:	bb94      	cbnz	r4, 45eba <nrfx_usbd_init+0x6e>
    m_event_handler = event_handler;
   45e54:	4a1b      	ldr	r2, [pc, #108]	; (45ec4 <nrfx_usbd_init+0x78>)
   45e56:	6010      	str	r0, [r2, #0]
    m_drv_state = NRFX_DRV_STATE_INITIALIZED;
   45e58:	2201      	movs	r2, #1
   45e5a:	701a      	strb	r2, [r3, #0]
        nrfx_usbd_ep_max_packet_size_set(ep, NRF_USBD_EPISO_CHECK(ep) ?
   45e5c:	f240 17ff 	movw	r7, #511	; 0x1ff
        p_state->status = NRFX_USBD_EP_OK;
   45e60:	4626      	mov	r6, r4
        nrfx_usbd_ep_t ep = NRFX_USBD_EPIN(n);
   45e62:	f064 057f 	orn	r5, r4, #127	; 0x7f
        nrfx_usbd_ep_max_packet_size_set(ep, NRF_USBD_EPISO_CHECK(ep) ?
   45e66:	f014 0f08 	tst.w	r4, #8
        nrfx_usbd_ep_t ep = NRFX_USBD_EPIN(n);
   45e6a:	b2ed      	uxtb	r5, r5
        nrfx_usbd_ep_max_packet_size_set(ep, NRF_USBD_EPISO_CHECK(ep) ?
   45e6c:	bf14      	ite	ne
   45e6e:	4639      	movne	r1, r7
   45e70:	2140      	moveq	r1, #64	; 0x40
   45e72:	4628      	mov	r0, r5
   45e74:	f009 fb43 	bl	4f4fe <nrfx_usbd_ep_max_packet_size_set>
        usbd_ep_state_t * p_state = ep_state_access(ep);
   45e78:	4628      	mov	r0, r5
   45e7a:	f7ff fd07 	bl	4588c <ep_state_access>
    for (n = 0; n < NRF_USBD_EPIN_CNT; ++n)
   45e7e:	3401      	adds	r4, #1
   45e80:	2c09      	cmp	r4, #9
        p_state->status = NRFX_USBD_EP_OK;
   45e82:	7386      	strb	r6, [r0, #14]
        p_state->handler.feeder = NULL;
   45e84:	6006      	str	r6, [r0, #0]
        p_state->transfer_cnt = 0;
   45e86:	6086      	str	r6, [r0, #8]
    for (n = 0; n < NRF_USBD_EPIN_CNT; ++n)
   45e88:	d1eb      	bne.n	45e62 <nrfx_usbd_init+0x16>
   45e8a:	2400      	movs	r4, #0
        nrfx_usbd_ep_max_packet_size_set(ep, NRF_USBD_EPISO_CHECK(ep) ?
   45e8c:	f240 17ff 	movw	r7, #511	; 0x1ff
        p_state->status = NRFX_USBD_EP_OK;
   45e90:	4625      	mov	r5, r4
        nrfx_usbd_ep_max_packet_size_set(ep, NRF_USBD_EPISO_CHECK(ep) ?
   45e92:	f014 0f08 	tst.w	r4, #8
   45e96:	b2e6      	uxtb	r6, r4
   45e98:	bf14      	ite	ne
   45e9a:	4639      	movne	r1, r7
   45e9c:	2140      	moveq	r1, #64	; 0x40
   45e9e:	4630      	mov	r0, r6
   45ea0:	f009 fb2d 	bl	4f4fe <nrfx_usbd_ep_max_packet_size_set>
        usbd_ep_state_t * p_state = ep_state_access(ep);
   45ea4:	4630      	mov	r0, r6
   45ea6:	f7ff fcf1 	bl	4588c <ep_state_access>
    for (n = 0; n < NRF_USBD_EPOUT_CNT; ++n)
   45eaa:	3401      	adds	r4, #1
   45eac:	2c09      	cmp	r4, #9
        p_state->status = NRFX_USBD_EP_OK;
   45eae:	7385      	strb	r5, [r0, #14]
        p_state->handler.consumer = NULL;
   45eb0:	6005      	str	r5, [r0, #0]
        p_state->transfer_cnt = 0;
   45eb2:	6085      	str	r5, [r0, #8]
    for (n = 0; n < NRF_USBD_EPOUT_CNT; ++n)
   45eb4:	d1ed      	bne.n	45e92 <nrfx_usbd_init+0x46>
    return NRFX_SUCCESS;
   45eb6:	4804      	ldr	r0, [pc, #16]	; (45ec8 <nrfx_usbd_init+0x7c>)
}
   45eb8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return NRFX_ERROR_INVALID_STATE;
   45eba:	4804      	ldr	r0, [pc, #16]	; (45ecc <nrfx_usbd_init+0x80>)
   45ebc:	e7fc      	b.n	45eb8 <nrfx_usbd_init+0x6c>
   45ebe:	bf00      	nop
   45ec0:	20006bbf 	.word	0x20006bbf
   45ec4:	200068d4 	.word	0x200068d4
   45ec8:	0bad0000 	.word	0x0bad0000
   45ecc:	0bad0005 	.word	0x0bad0005

00045ed0 <nrfx_usbd_ep_transfer>:
}

nrfx_err_t nrfx_usbd_ep_transfer(
    nrfx_usbd_ep_t               ep,
    nrfx_usbd_transfer_t const * p_transfer)
{
   45ed0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   45ed4:	4604      	mov	r4, r0
	__asm__ volatile(
   45ed6:	f04f 0320 	mov.w	r3, #32
   45eda:	f3ef 8611 	mrs	r6, BASEPRI
   45ede:	f383 8812 	msr	BASEPRI_MAX, r3
   45ee2:	f3bf 8f6f 	isb	sy
    const uint8_t ep_bitpos = ep2bit(ep);
    NRFX_ASSERT(NULL != p_transfer);

    NRFX_CRITICAL_SECTION_ENTER();
    /* Setup data transaction can go only in one direction at a time */
    if ((NRF_USBD_EP_NR_GET(ep) == 0) && (ep != m_last_setup_dir))
   45ee6:	f010 090f 	ands.w	r9, r0, #15
   45eea:	d103      	bne.n	45ef4 <nrfx_usbd_ep_transfer+0x24>
   45eec:	4b27      	ldr	r3, [pc, #156]	; (45f8c <nrfx_usbd_ep_transfer+0xbc>)
   45eee:	781b      	ldrb	r3, [r3, #0]
   45ef0:	4283      	cmp	r3, r0
   45ef2:	d147      	bne.n	45f84 <nrfx_usbd_ep_transfer+0xb4>
            (NRFX_USBD_ISO_DEBUG || (!NRF_USBD_EPISO_CHECK(ep))))
        {
            NRFX_LOG_DEBUG("Transfer failed: Invalid EPr\n");
        }
    }
    else if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK)) & (1U << ep_bitpos))
   45ef4:	4b26      	ldr	r3, [pc, #152]	; (45f90 <nrfx_usbd_ep_transfer+0xc0>)
   45ef6:	4f27      	ldr	r7, [pc, #156]	; (45f94 <nrfx_usbd_ep_transfer+0xc4>)
   45ef8:	681a      	ldr	r2, [r3, #0]
   45efa:	683b      	ldr	r3, [r7, #0]
   45efc:	43d2      	mvns	r2, r2
   45efe:	b292      	uxth	r2, r2
    const uint8_t ep_bitpos = ep2bit(ep);
   45f00:	4620      	mov	r0, r4
    else if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK)) & (1U << ep_bitpos))
   45f02:	431a      	orrs	r2, r3
    const uint8_t ep_bitpos = ep2bit(ep);
   45f04:	f009 fac3 	bl	4f48e <ep2bit>
    else if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK)) & (1U << ep_bitpos))
   45f08:	f04f 0801 	mov.w	r8, #1
   45f0c:	fa08 f800 	lsl.w	r8, r8, r0
   45f10:	ea12 0f08 	tst.w	r2, r8
   45f14:	d138      	bne.n	45f88 <nrfx_usbd_ep_transfer+0xb8>
            NRFX_LOG_DEBUG("Transfer failed: EP is busy");
        }
    }
    else
    {
        usbd_ep_state_t * p_state =  ep_state_access(ep);
   45f16:	4620      	mov	r0, r4
   45f18:	f7ff fcb8 	bl	4588c <ep_state_access>
        /* Prepare transfer context and handler description */
        nrfx_usbd_transfer_t * p_context;
        if (NRF_USBD_EPIN_CHECK(ep))
        {
            p_context = m_ep_feeder_state + NRF_USBD_EP_NR_GET(ep);
   45f1c:	230c      	movs	r3, #12
        if (NRF_USBD_EPIN_CHECK(ep))
   45f1e:	0622      	lsls	r2, r4, #24
        usbd_ep_state_t * p_state =  ep_state_access(ep);
   45f20:	4605      	mov	r5, r0
            p_context = m_ep_feeder_state + NRF_USBD_EP_NR_GET(ep);
   45f22:	fb03 f309 	mul.w	r3, r3, r9
        if (NRF_USBD_EPIN_CHECK(ep))
   45f26:	d529      	bpl.n	45f7c <nrfx_usbd_ep_transfer+0xac>

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE bool nrfx_is_in_ram(void const * p_object)
{
    return ((((uint32_t)p_object) & 0xE0000000u) == 0x20000000u);
   45f28:	680a      	ldr	r2, [r1, #0]
            if (nrfx_is_in_ram(p_transfer->p_data.tx))
            {
                /* RAM */
                if (0 == (p_transfer->flags & NRFX_USBD_TRANSFER_ZLP_FLAG))
   45f2a:	6888      	ldr	r0, [r1, #8]
   45f2c:	f002 4260 	and.w	r2, r2, #3758096384	; 0xe0000000
            if (nrfx_is_in_ram(p_transfer->p_data.tx))
   45f30:	f1b2 5f00 	cmp.w	r2, #536870912	; 0x20000000
                if (0 == (p_transfer->flags & NRFX_USBD_TRANSFER_ZLP_FLAG))
   45f34:	f000 0001 	and.w	r0, r0, #1
            if (nrfx_is_in_ram(p_transfer->p_data.tx))
   45f38:	d11d      	bne.n	45f76 <nrfx_usbd_ep_transfer+0xa6>
                if (0 == (p_transfer->flags & NRFX_USBD_TRANSFER_ZLP_FLAG))
   45f3a:	4a17      	ldr	r2, [pc, #92]	; (45f98 <nrfx_usbd_ep_transfer+0xc8>)
   45f3c:	4c17      	ldr	r4, [pc, #92]	; (45f9c <nrfx_usbd_ep_transfer+0xcc>)
   45f3e:	2800      	cmp	r0, #0
   45f40:	bf08      	it	eq
   45f42:	4622      	moveq	r2, r4
            p_context = m_ep_feeder_state + NRF_USBD_EP_NR_GET(ep);
   45f44:	4816      	ldr	r0, [pc, #88]	; (45fa0 <nrfx_usbd_ep_transfer+0xd0>)
   45f46:	4403      	add	r3, r0
        }
        else
        {
            p_context = m_ep_consumer_state + NRF_USBD_EP_NR_GET(ep);
            NRFX_ASSERT((p_transfer->p_data.rx == NULL) || (nrfx_is_in_ram(p_transfer->p_data.rx)));
            p_state->handler.consumer = nrfx_usbd_consumer;
   45f48:	602a      	str	r2, [r5, #0]
        }
        *p_context = *p_transfer;
   45f4a:	c907      	ldmia	r1, {r0, r1, r2}
   45f4c:	e883 0007 	stmia.w	r3, {r0, r1, r2}
        p_state->p_context = p_context;
   45f50:	606b      	str	r3, [r5, #4]

        p_state->transfer_cnt = 0;
   45f52:	2300      	movs	r3, #0
   45f54:	60ab      	str	r3, [r5, #8]
        p_state->status    =  NRFX_USBD_EP_OK;
   45f56:	73ab      	strb	r3, [r5, #14]
        m_ep_dma_waiting   |= 1U << ep_bitpos;
   45f58:	683b      	ldr	r3, [r7, #0]
        ret = NRFX_SUCCESS;
   45f5a:	4812      	ldr	r0, [pc, #72]	; (45fa4 <nrfx_usbd_ep_transfer+0xd4>)
        m_ep_dma_waiting   |= 1U << ep_bitpos;
   45f5c:	ea43 0308 	orr.w	r3, r3, r8
   45f60:	603b      	str	r3, [r7, #0]
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   45f62:	4b11      	ldr	r3, [pc, #68]	; (45fa8 <nrfx_usbd_ep_transfer+0xd8>)
   45f64:	2280      	movs	r2, #128	; 0x80
   45f66:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
	__asm__ volatile(
   45f6a:	f386 8811 	msr	BASEPRI, r6
   45f6e:	f3bf 8f6f 	isb	sy
        usbd_int_rise();
    }
    NRFX_CRITICAL_SECTION_EXIT();
    return ret;
}
   45f72:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
                if (0 == (p_transfer->flags & NRFX_USBD_TRANSFER_ZLP_FLAG))
   45f76:	4a0d      	ldr	r2, [pc, #52]	; (45fac <nrfx_usbd_ep_transfer+0xdc>)
   45f78:	4c0d      	ldr	r4, [pc, #52]	; (45fb0 <nrfx_usbd_ep_transfer+0xe0>)
   45f7a:	e7e0      	b.n	45f3e <nrfx_usbd_ep_transfer+0x6e>
            p_context = m_ep_consumer_state + NRF_USBD_EP_NR_GET(ep);
   45f7c:	4a0d      	ldr	r2, [pc, #52]	; (45fb4 <nrfx_usbd_ep_transfer+0xe4>)
   45f7e:	4413      	add	r3, r2
            p_state->handler.consumer = nrfx_usbd_consumer;
   45f80:	4a0d      	ldr	r2, [pc, #52]	; (45fb8 <nrfx_usbd_ep_transfer+0xe8>)
   45f82:	e7e1      	b.n	45f48 <nrfx_usbd_ep_transfer+0x78>
        ret = NRFX_ERROR_INVALID_ADDR;
   45f84:	480d      	ldr	r0, [pc, #52]	; (45fbc <nrfx_usbd_ep_transfer+0xec>)
   45f86:	e7f0      	b.n	45f6a <nrfx_usbd_ep_transfer+0x9a>
        ret = NRFX_ERROR_BUSY;
   45f88:	480d      	ldr	r0, [pc, #52]	; (45fc0 <nrfx_usbd_ep_transfer+0xf0>)
   45f8a:	e7ee      	b.n	45f6a <nrfx_usbd_ep_transfer+0x9a>
   45f8c:	20006bbd 	.word	0x20006bbd
   45f90:	200068d0 	.word	0x200068d0
   45f94:	200068cc 	.word	0x200068cc
   45f98:	0004f467 	.word	0x0004f467
   45f9c:	0004f445 	.word	0x0004f445
   45fa0:	20006740 	.word	0x20006740
   45fa4:	0bad0000 	.word	0x0bad0000
   45fa8:	e000e100 	.word	0xe000e100
   45fac:	00045a01 	.word	0x00045a01
   45fb0:	000459c9 	.word	0x000459c9
   45fb4:	200066d4 	.word	0x200066d4
   45fb8:	0004f413 	.word	0x0004f413
   45fbc:	0bad000a 	.word	0x0bad000a
   45fc0:	0bad000b 	.word	0x0bad000b

00045fc4 <nrfx_usbd_epout_size_get>:
    if (NRF_USBD_EPISO_CHECK(ep))
   45fc4:	f010 0f08 	tst.w	r0, #8
   45fc8:	4b07      	ldr	r3, [pc, #28]	; (45fe8 <nrfx_usbd_epout_size_get+0x24>)
   45fca:	d006      	beq.n	45fda <nrfx_usbd_epout_size_get+0x16>
        size_t size_isoout = p_reg->SIZE.ISOOUT;
   45fcc:	f8d3 04c0 	ldr.w	r0, [r3, #1216]	; 0x4c0
            size_isoout = 0;
   45fd0:	f410 3f80 	tst.w	r0, #65536	; 0x10000
   45fd4:	bf18      	it	ne
   45fd6:	2000      	movne	r0, #0
   45fd8:	4770      	bx	lr
    return p_reg->SIZE.EPOUT[NRF_USBD_EP_NR_GET(ep)];
   45fda:	f000 000f 	and.w	r0, r0, #15
   45fde:	f500 7094 	add.w	r0, r0, #296	; 0x128
   45fe2:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
}

size_t nrfx_usbd_epout_size_get(nrfx_usbd_ep_t ep)
{
    return nrf_usbd_epout_size_get(NRF_USBD, ep_to_hal(ep));
}
   45fe6:	4770      	bx	lr
   45fe8:	40027000 	.word	0x40027000

00045fec <usbd_dmareq_process>:
{
   45fec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if (!m_dma_pending)
   45ff0:	4e59      	ldr	r6, [pc, #356]	; (46158 <usbd_dmareq_process+0x16c>)
   45ff2:	7833      	ldrb	r3, [r6, #0]
{
   45ff4:	b085      	sub	sp, #20
    if (!m_dma_pending)
   45ff6:	2b00      	cmp	r3, #0
   45ff8:	d173      	bne.n	460e2 <usbd_dmareq_process+0xf6>
        while (0 != (req = m_ep_dma_waiting & m_ep_ready))
   45ffa:	f8df 8160 	ldr.w	r8, [pc, #352]	; 4615c <usbd_dmareq_process+0x170>
   45ffe:	4d58      	ldr	r5, [pc, #352]	; (46160 <usbd_dmareq_process+0x174>)
   46000:	f8d8 4000 	ldr.w	r4, [r8]
   46004:	682b      	ldr	r3, [r5, #0]
   46006:	401c      	ands	r4, r3
   46008:	d06b      	beq.n	460e2 <usbd_dmareq_process+0xf6>
            if (NRFX_USBD_CONFIG_DMASCHEDULER_ISO_BOOST && ((req & USBD_EPISO_BIT_MASK) != 0))
   4600a:	f014 2301 	ands.w	r3, r4, #16777472	; 0x1000100
    return NRF_CTZ(req);
   4600e:	bf14      	ite	ne
   46010:	fa93 f4a3 	rbitne	r4, r3
   46014:	fa94 f4a4 	rbiteq	r4, r4
   46018:	fab4 f484 	clz	r4, r4
                    (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << pos)));
   4601c:	f04f 0901 	mov.w	r9, #1
   46020:	fa09 f904 	lsl.w	r9, r9, r4
    return (nrfx_usbd_ep_t)((bitpos >= NRFX_USBD_EPOUT_BITPOS_0) ?
   46024:	2c0f      	cmp	r4, #15
                    (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << pos)));
   46026:	ea6f 0909 	mvn.w	r9, r9
    return (nrfx_usbd_ep_t)((bitpos >= NRFX_USBD_EPOUT_BITPOS_0) ?
   4602a:	d95d      	bls.n	460e8 <usbd_dmareq_process+0xfc>
   4602c:	3c10      	subs	r4, #16
   4602e:	b2e4      	uxtb	r4, r4
            usbd_ep_state_t * p_state = ep_state_access(ep);
   46030:	4620      	mov	r0, r4
   46032:	f7ff fc2b 	bl	4588c <ep_state_access>
   46036:	4682      	mov	sl, r0
                const size_t rx_size = nrfx_usbd_epout_size_get(ep);
   46038:	4620      	mov	r0, r4
   4603a:	f7ff ffc3 	bl	45fc4 <nrfx_usbd_epout_size_get>
                continue_transfer = p_state->handler.consumer(
   4603e:	f8da 7000 	ldr.w	r7, [sl]
   46042:	f8ba 200c 	ldrh.w	r2, [sl, #12]
   46046:	f8da 1004 	ldr.w	r1, [sl, #4]
   4604a:	4603      	mov	r3, r0
                const size_t rx_size = nrfx_usbd_epout_size_get(ep);
   4604c:	4683      	mov	fp, r0
                continue_transfer = p_state->handler.consumer(
   4604e:	a802      	add	r0, sp, #8
   46050:	47b8      	blx	r7
                if (transfer.p_data.rx == NULL)
   46052:	9b02      	ldr	r3, [sp, #8]
   46054:	2b00      	cmp	r3, #0
   46056:	d153      	bne.n	46100 <usbd_dmareq_process+0x114>
                if (!continue_transfer)
   46058:	b908      	cbnz	r0, 4605e <usbd_dmareq_process+0x72>
                    p_state->handler.consumer = NULL;
   4605a:	f8ca 0000 	str.w	r0, [sl]
            uint32_t var1 = *(uint32_t *)0x10000130ul;
   4605e:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
            if (NRF_USBD_EPIN_CHECK(ep))
   46062:	b261      	sxtb	r1, r4
            if (var1 == 0x08)
   46064:	f8d3 3130 	ldr.w	r3, [r3, #304]	; 0x130
   46068:	2b08      	cmp	r3, #8
        *((volatile uint32_t *)0x40027C1C) = 0x00000082;
   4606a:	bf02      	ittt	eq
   4606c:	4b3d      	ldreq	r3, [pc, #244]	; (46164 <usbd_dmareq_process+0x178>)
   4606e:	2282      	moveq	r2, #130	; 0x82
   46070:	f8c3 2c1c 	streq.w	r2, [r3, #3100]	; 0xc1c
    m_dma_pending = true;
   46074:	2301      	movs	r3, #1
   46076:	7033      	strb	r3, [r6, #0]
            m_ep_ready &= ~(1U << pos);
   46078:	682b      	ldr	r3, [r5, #0]
            p_state->transfer_cnt += transfer.size;
   4607a:	9a03      	ldr	r2, [sp, #12]
            nrf_usbd_ep_easydma_set(NRF_USBD, ep, transfer.p_data.addr, (uint32_t)transfer.size);
   4607c:	9802      	ldr	r0, [sp, #8]
            m_ep_ready &= ~(1U << pos);
   4607e:	ea03 0309 	and.w	r3, r3, r9
   46082:	602b      	str	r3, [r5, #0]
            p_state->transfer_cnt += transfer.size;
   46084:	f8da 3008 	ldr.w	r3, [sl, #8]
    if (NRF_USBD_EPIN_CHECK(ep))
   46088:	2900      	cmp	r1, #0
   4608a:	4413      	add	r3, r2
   4608c:	f8ca 3008 	str.w	r3, [sl, #8]
   46090:	f004 0508 	and.w	r5, r4, #8
   46094:	4b33      	ldr	r3, [pc, #204]	; (46164 <usbd_dmareq_process+0x178>)
            uint8_t epnr = NRF_USBD_EP_NR_GET(ep);
   46096:	f004 040f 	and.w	r4, r4, #15
    if (NRF_USBD_EPIN_CHECK(ep))
   4609a:	da4e      	bge.n	4613a <usbd_dmareq_process+0x14e>
        if (NRF_USBD_EPISO_CHECK(ep))
   4609c:	2d00      	cmp	r5, #0
   4609e:	d044      	beq.n	4612a <usbd_dmareq_process+0x13e>
            p_reg->ISOIN.PTR    = ptr;
   460a0:	f8c3 06a0 	str.w	r0, [r3, #1696]	; 0x6a0
            p_reg->ISOIN.MAXCNT = maxcnt;
   460a4:	f8c3 26a4 	str.w	r2, [r3, #1700]	; 0x6a4
    return (nrf_usbd_task_t)(
   460a8:	2304      	movs	r3, #4
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)task)) = 1UL;
   460aa:	eb03 0384 	add.w	r3, r3, r4, lsl #2
    return (volatile uint32_t*)(((uint8_t *)p_reg) + (uint32_t)offset);
   460ae:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   460b2:	f503 331c 	add.w	r3, r3, #159744	; 0x27000
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)task)) = 1UL;
   460b6:	2201      	movs	r2, #1
   460b8:	601a      	str	r2, [r3, #0]
    (void)*(nrf_usbd_getRegPtr(p_reg, (uint32_t)task));
   460ba:	681b      	ldr	r3, [r3, #0]
    return (NRF_USBD_EPIN_CHECK(ep) ? epin_endev : epout_endev)[NRF_USBD_EP_NR_GET(ep)];
   460bc:	4a2a      	ldr	r2, [pc, #168]	; (46168 <usbd_dmareq_process+0x17c>)
   460be:	4b2b      	ldr	r3, [pc, #172]	; (4616c <usbd_dmareq_process+0x180>)
   460c0:	ea13 0321 	ands.w	r3, r3, r1, asr #32
   460c4:	bf38      	it	cc
   460c6:	4613      	movcc	r3, r2
    return (bool)*nrf_usbd_getRegPtr_c(p_reg, (uint32_t)event);
   460c8:	4926      	ldr	r1, [pc, #152]	; (46164 <usbd_dmareq_process+0x178>)
   460ca:	f833 3014 	ldrh.w	r3, [r3, r4, lsl #1]
    return (volatile const uint32_t*)(((uint8_t *)p_reg) + (uint32_t)offset);
   460ce:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   460d2:	f503 331c 	add.w	r3, r3, #159744	; 0x27000
    return (bool)*nrf_usbd_getRegPtr_c(p_reg, (uint32_t)event);
   460d6:	681a      	ldr	r2, [r3, #0]
            while (!nrf_usbd_event_check(NRF_USBD, nrfx_usbd_ep_to_endevent(ep)) &&
   460d8:	b91a      	cbnz	r2, 460e2 <usbd_dmareq_process+0xf6>
   460da:	f8d1 2100 	ldr.w	r2, [r1, #256]	; 0x100
   460de:	2a00      	cmp	r2, #0
   460e0:	d0f9      	beq.n	460d6 <usbd_dmareq_process+0xea>
}
   460e2:	b005      	add	sp, #20
   460e4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    return (nrfx_usbd_ep_t)((bitpos >= NRFX_USBD_EPOUT_BITPOS_0) ?
   460e8:	f044 0480 	orr.w	r4, r4, #128	; 0x80
            usbd_ep_state_t * p_state = ep_state_access(ep);
   460ec:	4620      	mov	r0, r4
   460ee:	f7ff fbcd 	bl	4588c <ep_state_access>
                continue_transfer = p_state->handler.feeder(
   460f2:	6803      	ldr	r3, [r0, #0]
   460f4:	8982      	ldrh	r2, [r0, #12]
   460f6:	6841      	ldr	r1, [r0, #4]
            usbd_ep_state_t * p_state = ep_state_access(ep);
   460f8:	4682      	mov	sl, r0
                continue_transfer = p_state->handler.feeder(
   460fa:	a802      	add	r0, sp, #8
   460fc:	4798      	blx	r3
   460fe:	e7ab      	b.n	46058 <usbd_dmareq_process+0x6c>
                else if (transfer.size < rx_size)
   46100:	9b03      	ldr	r3, [sp, #12]
   46102:	459b      	cmp	fp, r3
   46104:	d9a8      	bls.n	46058 <usbd_dmareq_process+0x6c>
                    p_state->status = NRFX_USBD_EP_OVERLOAD;
   46106:	2702      	movs	r7, #2
                    (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << pos)));
   46108:	4648      	mov	r0, r9
                    p_state->status = NRFX_USBD_EP_OVERLOAD;
   4610a:	f88a 700e 	strb.w	r7, [sl, #14]
                    (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << pos)));
   4610e:	f7ff fcb7 	bl	45a80 <atomic_and.constprop.0.isra.0>
                    NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OVERLOAD);
   46112:	2306      	movs	r3, #6
   46114:	f88d 3004 	strb.w	r3, [sp, #4]
                    m_event_handler(&evt);
   46118:	4b15      	ldr	r3, [pc, #84]	; (46170 <usbd_dmareq_process+0x184>)
                    NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OVERLOAD);
   4611a:	f88d 4006 	strb.w	r4, [sp, #6]
                    m_event_handler(&evt);
   4611e:	681b      	ldr	r3, [r3, #0]
                    NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OVERLOAD);
   46120:	f88d 7007 	strb.w	r7, [sp, #7]
                    m_event_handler(&evt);
   46124:	a801      	add	r0, sp, #4
   46126:	4798      	blx	r3
                    continue;
   46128:	e76a      	b.n	46000 <usbd_dmareq_process+0x14>
            p_reg->EPIN[epnr].PTR    = ptr;
   4612a:	2514      	movs	r5, #20
   4612c:	fb05 3304 	mla	r3, r5, r4, r3
   46130:	f8c3 0600 	str.w	r0, [r3, #1536]	; 0x600
            p_reg->EPIN[epnr].MAXCNT = maxcnt;
   46134:	f8c3 2604 	str.w	r2, [r3, #1540]	; 0x604
    return (nrf_usbd_task_t)(
   46138:	e7b6      	b.n	460a8 <usbd_dmareq_process+0xbc>
        if (NRF_USBD_EPISO_CHECK(ep))
   4613a:	b12d      	cbz	r5, 46148 <usbd_dmareq_process+0x15c>
            p_reg->ISOOUT.PTR    = ptr;
   4613c:	f8c3 07a0 	str.w	r0, [r3, #1952]	; 0x7a0
            p_reg->ISOOUT.MAXCNT = maxcnt;
   46140:	f8c3 27a4 	str.w	r2, [r3, #1956]	; 0x7a4
   46144:	2328      	movs	r3, #40	; 0x28
   46146:	e7b0      	b.n	460aa <usbd_dmareq_process+0xbe>
            p_reg->EPOUT[epnr].PTR    = ptr;
   46148:	2514      	movs	r5, #20
   4614a:	fb05 3304 	mla	r3, r5, r4, r3
   4614e:	f8c3 0700 	str.w	r0, [r3, #1792]	; 0x700
            p_reg->EPOUT[epnr].MAXCNT = maxcnt;
   46152:	f8c3 2704 	str.w	r2, [r3, #1796]	; 0x704
   46156:	e7f5      	b.n	46144 <usbd_dmareq_process+0x158>
   46158:	20006bbc 	.word	0x20006bbc
   4615c:	200068cc 	.word	0x200068cc
   46160:	200068d0 	.word	0x200068d0
   46164:	40027000 	.word	0x40027000
   46168:	00053018 	.word	0x00053018
   4616c:	0005302a 	.word	0x0005302a
   46170:	200068d4 	.word	0x200068d4

00046174 <ev_epdata_handler>:
{
   46174:	b538      	push	{r3, r4, r5, lr}
    return p_reg->EPDATASTATUS;
   46176:	4b0f      	ldr	r3, [pc, #60]	; (461b4 <ev_epdata_handler+0x40>)
   46178:	f8d3 446c 	ldr.w	r4, [r3, #1132]	; 0x46c
    p_reg->EPDATASTATUS = flags;
   4617c:	f8c3 446c 	str.w	r4, [r3, #1132]	; 0x46c
        dataepstatus &= ~(1UL << bitpos);
   46180:	2501      	movs	r5, #1
    while (dataepstatus)
   46182:	b91c      	cbnz	r4, 4618c <ev_epdata_handler+0x18>
}
   46184:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        usbd_dmareq_process();
   46188:	f7ff bf30 	b.w	45fec <usbd_dmareq_process>
        uint8_t bitpos    = NRF_CTZ(dataepstatus);
   4618c:	fa94 f3a4 	rbit	r3, r4
   46190:	fab3 f383 	clz	r3, r3
    return (nrfx_usbd_ep_t)((bitpos >= NRFX_USBD_EPOUT_BITPOS_0) ?
   46194:	2b0f      	cmp	r3, #15
   46196:	bfc8      	it	gt
   46198:	f1a3 0010 	subgt.w	r0, r3, #16
        uint8_t bitpos    = NRF_CTZ(dataepstatus);
   4619c:	4619      	mov	r1, r3
    return (nrfx_usbd_ep_t)((bitpos >= NRFX_USBD_EPOUT_BITPOS_0) ?
   4619e:	bfd4      	ite	le
   461a0:	f043 0080 	orrle.w	r0, r3, #128	; 0x80
   461a4:	b2c0      	uxtbgt	r0, r0
        dataepstatus &= ~(1UL << bitpos);
   461a6:	fa05 f303 	lsl.w	r3, r5, r3
   461aa:	ea24 0403 	bic.w	r4, r4, r3
        (void)(usbd_ep_data_handler(ep, bitpos));
   461ae:	f7ff fc9f 	bl	45af0 <usbd_ep_data_handler>
   461b2:	e7e6      	b.n	46182 <ev_epdata_handler+0xe>
   461b4:	40027000 	.word	0x40027000

000461b8 <nrf_usbd_epout_dma_handler>:
{
   461b8:	b537      	push	{r0, r1, r2, r4, r5, lr}
    usbd_dma_pending_clear();
   461ba:	f7ff fc71 	bl	45aa0 <usbd_dma_pending_clear>
{
   461be:	4604      	mov	r4, r0
    usbd_ep_state_t * p_state = ep_state_access(ep);
   461c0:	f7ff fb64 	bl	4588c <ep_state_access>
    if (NRFX_USBD_EP_ABORTED == p_state->status)
   461c4:	7b83      	ldrb	r3, [r0, #14]
   461c6:	2b03      	cmp	r3, #3
   461c8:	d10d      	bne.n	461e6 <nrf_usbd_epout_dma_handler+0x2e>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   461ca:	4620      	mov	r0, r4
   461cc:	f009 f95f 	bl	4f48e <ep2bit>
   461d0:	2301      	movs	r3, #1
   461d2:	fa03 f000 	lsl.w	r0, r3, r0
   461d6:	43c0      	mvns	r0, r0
   461d8:	f7ff fc52 	bl	45a80 <atomic_and.constprop.0.isra.0>
}
   461dc:	b003      	add	sp, #12
   461de:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    usbd_dmareq_process();
   461e2:	f7ff bf03 	b.w	45fec <usbd_dmareq_process>
    else if (p_state->handler.consumer == NULL)
   461e6:	6805      	ldr	r5, [r0, #0]
   461e8:	2d00      	cmp	r5, #0
   461ea:	d1f7      	bne.n	461dc <nrf_usbd_epout_dma_handler+0x24>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   461ec:	4620      	mov	r0, r4
   461ee:	f009 f94e 	bl	4f48e <ep2bit>
   461f2:	2301      	movs	r3, #1
   461f4:	fa03 f000 	lsl.w	r0, r3, r0
   461f8:	43c0      	mvns	r0, r0
   461fa:	f7ff fc41 	bl	45a80 <atomic_and.constprop.0.isra.0>
        NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
   461fe:	2306      	movs	r3, #6
   46200:	f88d 3004 	strb.w	r3, [sp, #4]
        m_event_handler(&evt);
   46204:	4b04      	ldr	r3, [pc, #16]	; (46218 <nrf_usbd_epout_dma_handler+0x60>)
        NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
   46206:	f88d 4006 	strb.w	r4, [sp, #6]
        m_event_handler(&evt);
   4620a:	681b      	ldr	r3, [r3, #0]
        NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
   4620c:	f88d 5007 	strb.w	r5, [sp, #7]
        m_event_handler(&evt);
   46210:	a801      	add	r0, sp, #4
   46212:	4798      	blx	r3
   46214:	e7e2      	b.n	461dc <nrf_usbd_epout_dma_handler+0x24>
   46216:	bf00      	nop
   46218:	200068d4 	.word	0x200068d4

0004621c <nrfx_usbd_ep_stall>:
    p_reg->EPSTALL = (USBD_EPSTALL_STALL_Stall << USBD_EPSTALL_STALL_Pos) | ep;
   4621c:	4b02      	ldr	r3, [pc, #8]	; (46228 <nrfx_usbd_ep_stall+0xc>)
   4621e:	f440 7080 	orr.w	r0, r0, #256	; 0x100
   46222:	f8c3 0518 	str.w	r0, [r3, #1304]	; 0x518

void nrfx_usbd_ep_stall(nrfx_usbd_ep_t ep)
{
    NRFX_LOG_DEBUG("USB: EP %x stalled.", ep);
    nrf_usbd_ep_stall(NRF_USBD, ep_to_hal(ep));
}
   46226:	4770      	bx	lr
   46228:	40027000 	.word	0x40027000

0004622c <nrfx_usbd_ep_stall_check>:
    if (NRF_USBD_EPISO_CHECK(ep))
   4622c:	0702      	lsls	r2, r0, #28
   4622e:	d413      	bmi.n	46258 <nrfx_usbd_ep_stall_check+0x2c>
        return p_reg->HALTED.EPIN[epnr];
   46230:	f000 030f 	and.w	r3, r0, #15
    if (NRF_USBD_EPIN_CHECK(ep))
   46234:	f010 0f80 	tst.w	r0, #128	; 0x80
   46238:	4a08      	ldr	r2, [pc, #32]	; (4625c <nrfx_usbd_ep_stall_check+0x30>)
        return p_reg->HALTED.EPOUT[epnr];
   4623a:	bf0b      	itete	eq
   4623c:	f503 7388 	addeq.w	r3, r3, #272	; 0x110
        return p_reg->HALTED.EPIN[epnr];
   46240:	f503 7384 	addne.w	r3, r3, #264	; 0x108
        return p_reg->HALTED.EPOUT[epnr];
   46244:	eb02 0283 	addeq.w	r2, r2, r3, lsl #2
        return p_reg->HALTED.EPIN[epnr];
   46248:	f852 0023 	ldrne.w	r0, [r2, r3, lsl #2]
        return p_reg->HALTED.EPOUT[epnr];
   4624c:	bf08      	it	eq
   4624e:	6850      	ldreq	r0, [r2, #4]
    return USBD_HALTED_EPOUT_GETSTATUS_Halted == nrf_usbd_halted_get(p_reg, ep);
   46250:	1e43      	subs	r3, r0, #1
   46252:	4258      	negs	r0, r3
   46254:	4158      	adcs	r0, r3
   46256:	4770      	bx	lr
        return false;
   46258:	2000      	movs	r0, #0
}

bool nrfx_usbd_ep_stall_check(nrfx_usbd_ep_t ep)
{
    return nrf_usbd_ep_is_stall(NRF_USBD, ep_to_hal(ep));
}
   4625a:	4770      	bx	lr
   4625c:	40027000 	.word	0x40027000

00046260 <nrfx_usbd_ep_dtoggle_clear>:
    p_reg->DTOGGLE = ep | (NRF_USBD_DTOGGLE_NOP << USBD_DTOGGLE_VALUE_Pos);
   46260:	4b04      	ldr	r3, [pc, #16]	; (46274 <nrfx_usbd_ep_dtoggle_clear+0x14>)
   46262:	f8c3 050c 	str.w	r0, [r3, #1292]	; 0x50c
    p_reg->DTOGGLE = ep | (op << USBD_DTOGGLE_VALUE_Pos);
   46266:	f440 7080 	orr.w	r0, r0, #256	; 0x100
   4626a:	f8c3 050c 	str.w	r0, [r3, #1292]	; 0x50c
    (void) p_reg->DTOGGLE;
   4626e:	f8d3 350c 	ldr.w	r3, [r3, #1292]	; 0x50c

void nrfx_usbd_ep_dtoggle_clear(nrfx_usbd_ep_t ep)
{
    nrf_usbd_dtoggle_set(NRF_USBD, ep, NRF_USBD_DTOGGLE_DATA0);
}
   46272:	4770      	bx	lr
   46274:	40027000 	.word	0x40027000

00046278 <nrfx_usbd_setup_get>:

void nrfx_usbd_setup_get(nrfx_usbd_setup_t * p_setup)
{
   46278:	b510      	push	{r4, lr}
    memset(p_setup, 0, sizeof(nrfx_usbd_setup_t));
   4627a:	2208      	movs	r2, #8
   4627c:	2100      	movs	r1, #0
{
   4627e:	4604      	mov	r4, r0
    memset(p_setup, 0, sizeof(nrfx_usbd_setup_t));
   46280:	f004 fe06 	bl	4ae90 <memset>
    return (uint8_t)(p_reg->BMREQUESTTYPE);
   46284:	4b0e      	ldr	r3, [pc, #56]	; (462c0 <nrfx_usbd_setup_get+0x48>)
   46286:	f8d3 2480 	ldr.w	r2, [r3, #1152]	; 0x480
   4628a:	7022      	strb	r2, [r4, #0]
    return (uint8_t)(p_reg->BREQUEST);
   4628c:	f8d3 2484 	ldr.w	r2, [r3, #1156]	; 0x484
   46290:	7062      	strb	r2, [r4, #1]
    const uint16_t val = p_reg->WVALUEL;
   46292:	f8d3 2488 	ldr.w	r2, [r3, #1160]	; 0x488
    return (uint16_t)(val | ((p_reg->WVALUEH) << 8));
   46296:	f8d3 148c 	ldr.w	r1, [r3, #1164]	; 0x48c
   4629a:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    p_setup->bmRequestType = nrf_usbd_setup_bmrequesttype_get(NRF_USBD);
    p_setup->bRequest      = nrf_usbd_setup_brequest_get(NRF_USBD);
    p_setup->wValue        = nrf_usbd_setup_wvalue_get(NRF_USBD);
   4629e:	8062      	strh	r2, [r4, #2]
    const uint16_t val = p_reg->WINDEXL;
   462a0:	f8d3 2490 	ldr.w	r2, [r3, #1168]	; 0x490
    return (uint16_t)(val | ((p_reg->WINDEXH) << 8));
   462a4:	f8d3 1494 	ldr.w	r1, [r3, #1172]	; 0x494
   462a8:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    p_setup->wIndex        = nrf_usbd_setup_windex_get(NRF_USBD);
   462ac:	80a2      	strh	r2, [r4, #4]
    const uint16_t val = p_reg->WLENGTHL;
   462ae:	f8d3 2498 	ldr.w	r2, [r3, #1176]	; 0x498
    return (uint16_t)(val | ((p_reg->WLENGTHH) << 8));
   462b2:	f8d3 349c 	ldr.w	r3, [r3, #1180]	; 0x49c
   462b6:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
    p_setup->wLength       = nrf_usbd_setup_wlength_get(NRF_USBD);
   462ba:	80e3      	strh	r3, [r4, #6]
}
   462bc:	bd10      	pop	{r4, pc}
   462be:	bf00      	nop
   462c0:	40027000 	.word	0x40027000

000462c4 <nrfx_usbd_setup_data_clear>:
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)task)) = 1UL;
   462c4:	4b02      	ldr	r3, [pc, #8]	; (462d0 <nrfx_usbd_setup_data_clear+0xc>)
   462c6:	2201      	movs	r2, #1
   462c8:	64da      	str	r2, [r3, #76]	; 0x4c
    (void)*(nrf_usbd_getRegPtr(p_reg, (uint32_t)task));
   462ca:	6cdb      	ldr	r3, [r3, #76]	; 0x4c

void nrfx_usbd_setup_data_clear(void)
{
    nrf_usbd_task_trigger(NRF_USBD, NRF_USBD_TASK_EP0RCVOUT);
}
   462cc:	4770      	bx	lr
   462ce:	bf00      	nop
   462d0:	40027000 	.word	0x40027000

000462d4 <ev_dma_epout0_handler>:
static void ev_dma_epout0_handler(void) { nrf_usbd_ep0out_dma_handler(); }
   462d4:	b513      	push	{r0, r1, r4, lr}
    usbd_dma_pending_clear();
   462d6:	f7ff fbe3 	bl	45aa0 <usbd_dma_pending_clear>
    if (NRFX_USBD_EP_ABORTED == p_state->status)
   462da:	4b10      	ldr	r3, [pc, #64]	; (4631c <ev_dma_epout0_handler+0x48>)
   462dc:	7b9a      	ldrb	r2, [r3, #14]
   462de:	2a03      	cmp	r2, #3
   462e0:	d106      	bne.n	462f0 <ev_dma_epout0_handler+0x1c>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   462e2:	f46f 3080 	mvn.w	r0, #65536	; 0x10000
static void ev_dma_epout0_handler(void) { nrf_usbd_ep0out_dma_handler(); }
   462e6:	b002      	add	sp, #8
   462e8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   462ec:	f7ff bbc8 	b.w	45a80 <atomic_and.constprop.0.isra.0>
    else if (p_state->handler.consumer == NULL)
   462f0:	681c      	ldr	r4, [r3, #0]
   462f2:	b974      	cbnz	r4, 46312 <ev_dma_epout0_handler+0x3e>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   462f4:	f46f 3080 	mvn.w	r0, #65536	; 0x10000
   462f8:	f7ff fbc2 	bl	45a80 <atomic_and.constprop.0.isra.0>
        NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
   462fc:	2306      	movs	r3, #6
   462fe:	f88d 3004 	strb.w	r3, [sp, #4]
        m_event_handler(&evt);
   46302:	4b07      	ldr	r3, [pc, #28]	; (46320 <ev_dma_epout0_handler+0x4c>)
        NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
   46304:	f8ad 4006 	strh.w	r4, [sp, #6]
        m_event_handler(&evt);
   46308:	681b      	ldr	r3, [r3, #0]
   4630a:	a801      	add	r0, sp, #4
   4630c:	4798      	blx	r3
static void ev_dma_epout0_handler(void) { nrf_usbd_ep0out_dma_handler(); }
   4630e:	b002      	add	sp, #8
   46310:	bd10      	pop	{r4, pc}
   46312:	b002      	add	sp, #8
   46314:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        nrfx_usbd_setup_data_clear();
   46318:	f7ff bfd4 	b.w	462c4 <nrfx_usbd_setup_data_clear>
   4631c:	200067ac 	.word	0x200067ac
   46320:	200068d4 	.word	0x200068d4

00046324 <nrfx_usbd_setup_clear>:
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)task)) = 1UL;
   46324:	4b02      	ldr	r3, [pc, #8]	; (46330 <nrfx_usbd_setup_clear+0xc>)
   46326:	2201      	movs	r2, #1
   46328:	651a      	str	r2, [r3, #80]	; 0x50
    (void)*(nrf_usbd_getRegPtr(p_reg, (uint32_t)task));
   4632a:	6d1b      	ldr	r3, [r3, #80]	; 0x50

void nrfx_usbd_setup_clear(void)
{
    NRFX_LOG_DEBUG(">> ep0status >>");
    nrf_usbd_task_trigger(NRF_USBD, NRF_USBD_TASK_EP0STATUS);
}
   4632c:	4770      	bx	lr
   4632e:	bf00      	nop
   46330:	40027000 	.word	0x40027000

00046334 <nrfx_usbd_setup_stall>:
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)task)) = 1UL;
   46334:	4b02      	ldr	r3, [pc, #8]	; (46340 <nrfx_usbd_setup_stall+0xc>)
   46336:	2201      	movs	r2, #1
   46338:	655a      	str	r2, [r3, #84]	; 0x54
    (void)*(nrf_usbd_getRegPtr(p_reg, (uint32_t)task));
   4633a:	6d5b      	ldr	r3, [r3, #84]	; 0x54

void nrfx_usbd_setup_stall(void)
{
    NRFX_LOG_DEBUG("Setup stalled.");
    nrf_usbd_task_trigger(NRF_USBD, NRF_USBD_TASK_EP0STALL);
}
   4633c:	4770      	bx	lr
   4633e:	bf00      	nop
   46340:	40027000 	.word	0x40027000

00046344 <nrfx_usbd_last_setup_dir_get>:

nrfx_usbd_ep_t nrfx_usbd_last_setup_dir_get(void)
{
    return m_last_setup_dir;
}
   46344:	4b01      	ldr	r3, [pc, #4]	; (4634c <nrfx_usbd_last_setup_dir_get+0x8>)
   46346:	7818      	ldrb	r0, [r3, #0]
   46348:	4770      	bx	lr
   4634a:	bf00      	nop
   4634c:	20006bbd 	.word	0x20006bbd

00046350 <nrfx_usbd_transfer_out_drop>:

void nrfx_usbd_transfer_out_drop(nrfx_usbd_ep_t ep)
{
   46350:	b510      	push	{r4, lr}
   46352:	4602      	mov	r2, r0
	__asm__ volatile(
   46354:	f04f 0320 	mov.w	r3, #32
   46358:	f3ef 8411 	mrs	r4, BASEPRI
   4635c:	f383 8812 	msr	BASEPRI_MAX, r3
   46360:	f3bf 8f6f 	isb	sy
    NRFX_ASSERT(NRF_USBD_EPOUT_CHECK(ep));

    NRFX_CRITICAL_SECTION_ENTER();
    m_ep_ready &= ~(1U << ep2bit(ep));
   46364:	f009 f893 	bl	4f48e <ep2bit>
   46368:	490d      	ldr	r1, [pc, #52]	; (463a0 <nrfx_usbd_transfer_out_drop+0x50>)
   4636a:	2301      	movs	r3, #1
   4636c:	fa03 f000 	lsl.w	r0, r3, r0
   46370:	680b      	ldr	r3, [r1, #0]
   46372:	ea23 0300 	bic.w	r3, r3, r0
   46376:	600b      	str	r3, [r1, #0]
    if (!NRF_USBD_EPISO_CHECK(ep))
   46378:	f012 0108 	ands.w	r1, r2, #8
   4637c:	d10a      	bne.n	46394 <nrfx_usbd_transfer_out_drop+0x44>
    p_reg->SIZE.EPOUT[NRF_USBD_EP_NR_GET(ep)] = 0;
   4637e:	f002 030f 	and.w	r3, r2, #15
   46382:	009b      	lsls	r3, r3, #2
   46384:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   46388:	f503 331c 	add.w	r3, r3, #159744	; 0x27000
   4638c:	f8c3 14a0 	str.w	r1, [r3, #1184]	; 0x4a0
    (void) p_reg->SIZE.EPOUT[NRF_USBD_EP_NR_GET(ep)];
   46390:	f8d3 34a0 	ldr.w	r3, [r3, #1184]	; 0x4a0
	__asm__ volatile(
   46394:	f384 8811 	msr	BASEPRI, r4
   46398:	f3bf 8f6f 	isb	sy
    {
        nrf_usbd_epout_clear(NRF_USBD, ep);
    }
    NRFX_CRITICAL_SECTION_EXIT();
}
   4639c:	bd10      	pop	{r4, pc}
   4639e:	bf00      	nop
   463a0:	200068d0 	.word	0x200068d0

000463a4 <usbd_ep_abort>:
{
   463a4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   463a6:	4601      	mov	r1, r0
	__asm__ volatile(
   463a8:	f04f 0320 	mov.w	r3, #32
   463ac:	f3ef 8511 	mrs	r5, BASEPRI
   463b0:	f383 8812 	msr	BASEPRI_MAX, r3
   463b4:	f3bf 8f6f 	isb	sy
    usbd_ep_state_t * p_state = ep_state_access(ep);
   463b8:	f7ff fa68 	bl	4588c <ep_state_access>
   463bc:	4606      	mov	r6, r0
        if ((~m_ep_dma_waiting) & (1U << ep2bit(ep)))
   463be:	4608      	mov	r0, r1
   463c0:	f009 f865 	bl	4f48e <ep2bit>
   463c4:	2201      	movs	r2, #1
    if (NRF_USBD_EPOUT_CHECK(ep))
   463c6:	f011 0f80 	tst.w	r1, #128	; 0x80
        if ((~m_ep_dma_waiting) & (1U << ep2bit(ep)))
   463ca:	fa02 f200 	lsl.w	r2, r2, r0
   463ce:	482e      	ldr	r0, [pc, #184]	; (46488 <usbd_ep_abort+0xe4>)
    if (NRF_USBD_EPOUT_CHECK(ep))
   463d0:	d119      	bne.n	46406 <usbd_ep_abort+0x62>
        if ((~m_ep_dma_waiting) & (1U << ep2bit(ep)))
   463d2:	6803      	ldr	r3, [r0, #0]
   463d4:	ea32 0303 	bics.w	r3, r2, r3
   463d8:	d00a      	beq.n	463f0 <usbd_ep_abort+0x4c>
            nrfx_usbd_transfer_out_drop(ep);
   463da:	4608      	mov	r0, r1
   463dc:	f7ff ffb8 	bl	46350 <nrfx_usbd_transfer_out_drop>
        p_state->status = NRFX_USBD_EP_ABORTED;
   463e0:	2303      	movs	r3, #3
   463e2:	73b3      	strb	r3, [r6, #14]
	__asm__ volatile(
   463e4:	f385 8811 	msr	BASEPRI, r5
   463e8:	f3bf 8f6f 	isb	sy
}
   463ec:	b003      	add	sp, #12
   463ee:	bdf0      	pop	{r4, r5, r6, r7, pc}
            p_state->handler.consumer = NULL;
   463f0:	6033      	str	r3, [r6, #0]
            m_ep_dma_waiting &= ~(1U << ep2bit(ep));
   463f2:	6803      	ldr	r3, [r0, #0]
            m_ep_ready &= ~(1U << ep2bit(ep));
   463f4:	4925      	ldr	r1, [pc, #148]	; (4648c <usbd_ep_abort+0xe8>)
            m_ep_dma_waiting &= ~(1U << ep2bit(ep));
   463f6:	ea23 0302 	bic.w	r3, r3, r2
   463fa:	6003      	str	r3, [r0, #0]
            m_ep_ready &= ~(1U << ep2bit(ep));
   463fc:	680b      	ldr	r3, [r1, #0]
   463fe:	ea23 0302 	bic.w	r3, r3, r2
   46402:	600b      	str	r3, [r1, #0]
   46404:	e7ec      	b.n	463e0 <usbd_ep_abort+0x3c>
        if(!NRF_USBD_EPISO_CHECK(ep))
   46406:	070b      	lsls	r3, r1, #28
   46408:	d415      	bmi.n	46436 <usbd_ep_abort+0x92>
            if(ep != NRFX_USBD_EPIN0)
   4640a:	2980      	cmp	r1, #128	; 0x80
   4640c:	4b20      	ldr	r3, [pc, #128]	; (46490 <usbd_ep_abort+0xec>)
   4640e:	d02f      	beq.n	46470 <usbd_ep_abort+0xcc>
                *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x800)) = 0x7B6 + (2u * (NRF_USBD_EP_NR_GET(ep) - 1));
   46410:	f001 040f 	and.w	r4, r1, #15
   46414:	f204 34da 	addw	r4, r4, #986	; 0x3da
   46418:	0064      	lsls	r4, r4, #1
   4641a:	f8c3 4800 	str.w	r4, [r3, #2048]	; 0x800
                uint8_t temp = *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804));
   4641e:	f8d3 4804 	ldr.w	r4, [r3, #2052]	; 0x804
                *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)) |= temp;
   46422:	f8d3 7804 	ldr.w	r7, [r3, #2052]	; 0x804
                uint8_t temp = *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804));
   46426:	b2e4      	uxtb	r4, r4
                *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)) |= temp;
   46428:	f044 0402 	orr.w	r4, r4, #2
                *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)) |= temp;
   4642c:	433c      	orrs	r4, r7
   4642e:	f8c3 4804 	str.w	r4, [r3, #2052]	; 0x804
                (void)(*((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)));
   46432:	f8d3 3804 	ldr.w	r3, [r3, #2052]	; 0x804
        if ((m_ep_dma_waiting | (~m_ep_ready)) & (1U << ep2bit(ep)))
   46436:	4f15      	ldr	r7, [pc, #84]	; (4648c <usbd_ep_abort+0xe8>)
   46438:	6804      	ldr	r4, [r0, #0]
   4643a:	683b      	ldr	r3, [r7, #0]
   4643c:	ea64 0c03 	orn	ip, r4, r3
   46440:	ea1c 0f02 	tst.w	ip, r2
   46444:	d0ce      	beq.n	463e4 <usbd_ep_abort+0x40>
            m_ep_ready       |=   1U << ep2bit(ep) ;
   46446:	4313      	orrs	r3, r2
            m_ep_dma_waiting &= ~(1U << ep2bit(ep));
   46448:	ea24 0402 	bic.w	r4, r4, r2
            m_ep_ready       |=   1U << ep2bit(ep) ;
   4644c:	603b      	str	r3, [r7, #0]
            p_state->handler.feeder = NULL;
   4644e:	2300      	movs	r3, #0
            m_ep_dma_waiting &= ~(1U << ep2bit(ep));
   46450:	6004      	str	r4, [r0, #0]
            p_state->handler.feeder = NULL;
   46452:	6033      	str	r3, [r6, #0]
            p_state->status = NRFX_USBD_EP_ABORTED;
   46454:	2303      	movs	r3, #3
   46456:	73b3      	strb	r3, [r6, #14]
            NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_ABORTED);
   46458:	f88d 3007 	strb.w	r3, [sp, #7]
            m_event_handler(&evt);
   4645c:	4b0d      	ldr	r3, [pc, #52]	; (46494 <usbd_ep_abort+0xf0>)
            NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_ABORTED);
   4645e:	f88d 1006 	strb.w	r1, [sp, #6]
   46462:	2206      	movs	r2, #6
            m_event_handler(&evt);
   46464:	681b      	ldr	r3, [r3, #0]
            NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_ABORTED);
   46466:	f88d 2004 	strb.w	r2, [sp, #4]
            m_event_handler(&evt);
   4646a:	a801      	add	r0, sp, #4
   4646c:	4798      	blx	r3
   4646e:	e7b9      	b.n	463e4 <usbd_ep_abort+0x40>
                *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x800)) = 0x7B4;
   46470:	f240 74b4 	movw	r4, #1972	; 0x7b4
   46474:	f8c3 4800 	str.w	r4, [r3, #2048]	; 0x800
                uint8_t temp = *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804));
   46478:	f8d3 4804 	ldr.w	r4, [r3, #2052]	; 0x804
                *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)) |= temp;
   4647c:	f8d3 7804 	ldr.w	r7, [r3, #2052]	; 0x804
                uint8_t temp = *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804));
   46480:	b2e4      	uxtb	r4, r4
                *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)) |= temp;
   46482:	f044 0404 	orr.w	r4, r4, #4
   46486:	e7d1      	b.n	4642c <usbd_ep_abort+0x88>
   46488:	200068cc 	.word	0x200068cc
   4648c:	200068d0 	.word	0x200068d0
   46490:	40027000 	.word	0x40027000
   46494:	200068d4 	.word	0x200068d4

00046498 <ev_setup_handler>:
{
   46498:	b573      	push	{r0, r1, r4, r5, r6, lr}
    return (uint8_t)(p_reg->BMREQUESTTYPE);
   4649a:	4b14      	ldr	r3, [pc, #80]	; (464ec <ev_setup_handler+0x54>)
    if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK))
   4649c:	4c14      	ldr	r4, [pc, #80]	; (464f0 <ev_setup_handler+0x58>)
   4649e:	f8d3 5480 	ldr.w	r5, [r3, #1152]	; 0x480
   464a2:	6823      	ldr	r3, [r4, #0]
        & (1U <<ep2bit(m_last_setup_dir)))
   464a4:	4e13      	ldr	r6, [pc, #76]	; (464f4 <ev_setup_handler+0x5c>)
    if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK))
   464a6:	43da      	mvns	r2, r3
   464a8:	4b13      	ldr	r3, [pc, #76]	; (464f8 <ev_setup_handler+0x60>)
        & (1U <<ep2bit(m_last_setup_dir)))
   464aa:	7831      	ldrb	r1, [r6, #0]
    if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK))
   464ac:	681b      	ldr	r3, [r3, #0]
   464ae:	b292      	uxth	r2, r2
        & (1U <<ep2bit(m_last_setup_dir)))
   464b0:	4608      	mov	r0, r1
    if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK))
   464b2:	431a      	orrs	r2, r3
        & (1U <<ep2bit(m_last_setup_dir)))
   464b4:	f008 ffeb 	bl	4f48e <ep2bit>
   464b8:	2301      	movs	r3, #1
   464ba:	4083      	lsls	r3, r0
    if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK))
   464bc:	4213      	tst	r3, r2
   464be:	d002      	beq.n	464c6 <ev_setup_handler+0x2e>
        usbd_ep_abort(m_last_setup_dir);
   464c0:	4608      	mov	r0, r1
   464c2:	f7ff ff6f 	bl	463a4 <usbd_ep_abort>
        NRFX_USBD_EPOUT0 : NRFX_USBD_EPIN0;
   464c6:	f025 057f 	bic.w	r5, r5, #127	; 0x7f
    (void)(NRFX_ATOMIC_FETCH_AND(
   464ca:	f06f 1001 	mvn.w	r0, #65537	; 0x10001
    m_last_setup_dir =
   464ce:	7035      	strb	r5, [r6, #0]
    (void)(NRFX_ATOMIC_FETCH_AND(
   464d0:	f7ff fad6 	bl	45a80 <atomic_and.constprop.0.isra.0>
    m_ep_ready |= 1U << ep2bit(NRFX_USBD_EPIN0);
   464d4:	6823      	ldr	r3, [r4, #0]
   464d6:	f043 0301 	orr.w	r3, r3, #1
   464da:	6023      	str	r3, [r4, #0]
    const nrfx_usbd_evt_t evt = {
   464dc:	2305      	movs	r3, #5
   464de:	9301      	str	r3, [sp, #4]
    m_event_handler(&evt);
   464e0:	4b06      	ldr	r3, [pc, #24]	; (464fc <ev_setup_handler+0x64>)
   464e2:	a801      	add	r0, sp, #4
   464e4:	681b      	ldr	r3, [r3, #0]
   464e6:	4798      	blx	r3
}
   464e8:	b002      	add	sp, #8
   464ea:	bd70      	pop	{r4, r5, r6, pc}
   464ec:	40027000 	.word	0x40027000
   464f0:	200068d0 	.word	0x200068d0
   464f4:	20006bbd 	.word	0x20006bbd
   464f8:	200068cc 	.word	0x200068cc
   464fc:	200068d4 	.word	0x200068d4

00046500 <nrfx_usbd_irq_handler>:
{
   46500:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    return p_reg->INTENSET;
   46504:	4b1a      	ldr	r3, [pc, #104]	; (46570 <nrfx_usbd_irq_handler+0x70>)
   46506:	f8d3 0304 	ldr.w	r0, [r3, #772]	; 0x304
    uint32_t active = 0;
   4650a:	2300      	movs	r3, #0
            active |= 1UL << event_nr;
   4650c:	2401      	movs	r4, #1
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)event)) = 0UL;
   4650e:	461d      	mov	r5, r3
    while (to_process)
   46510:	b970      	cbnz	r0, 46530 <nrfx_usbd_irq_handler+0x30>
        m_isr[event_nr]();
   46512:	4f18      	ldr	r7, [pc, #96]	; (46574 <nrfx_usbd_irq_handler+0x74>)
    bool setup_active = 0 != (active & NRF_USBD_INT_EP0SETUP_MASK);
   46514:	f403 0600 	and.w	r6, r3, #8388608	; 0x800000
    active &= ~NRF_USBD_INT_EP0SETUP_MASK;
   46518:	f423 0400 	bic.w	r4, r3, #8388608	; 0x800000
        active &= ~(1UL << event_nr);
   4651c:	f04f 0801 	mov.w	r8, #1
    while (active)
   46520:	b9bc      	cbnz	r4, 46552 <nrfx_usbd_irq_handler+0x52>
    usbd_dmareq_process();
   46522:	f7ff fd63 	bl	45fec <usbd_dmareq_process>
    if (setup_active)
   46526:	b306      	cbz	r6, 4656a <nrfx_usbd_irq_handler+0x6a>
}
   46528:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        m_isr[USBD_INTEN_EP0SETUP_Pos]();
   4652c:	f7ff bfb4 	b.w	46498 <ev_setup_handler>
        uint8_t event_nr = NRF_CTZ(to_process);
   46530:	fa90 f2a0 	rbit	r2, r0
   46534:	fab2 f282 	clz	r2, r2
    return (volatile const uint32_t*)(((uint8_t *)p_reg) + (uint32_t)offset);
   46538:	490f      	ldr	r1, [pc, #60]	; (46578 <nrfx_usbd_irq_handler+0x78>)
}

NRF_STATIC_INLINE uint32_t nrfx_bitpos_to_event(uint32_t bit)
{
    static const uint32_t event_reg_offset = 0x100u;
    return event_reg_offset + (bit * sizeof(uint32_t));
   4653a:	0096      	lsls	r6, r2, #2
   4653c:	4431      	add	r1, r6
            active |= 1UL << event_nr;
   4653e:	fa04 f202 	lsl.w	r2, r4, r2
    return (bool)*nrf_usbd_getRegPtr_c(p_reg, (uint32_t)event);
   46542:	680e      	ldr	r6, [r1, #0]
    if (ret)
   46544:	b116      	cbz	r6, 4654c <nrfx_usbd_irq_handler+0x4c>
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)event)) = 0UL;
   46546:	600d      	str	r5, [r1, #0]
    (void)*(nrf_usbd_getRegPtr(p_reg, (uint32_t)event));
   46548:	6809      	ldr	r1, [r1, #0]
   4654a:	4313      	orrs	r3, r2
        to_process &= ~(1UL << event_nr);
   4654c:	ea20 0002 	bic.w	r0, r0, r2
   46550:	e7de      	b.n	46510 <nrfx_usbd_irq_handler+0x10>
        uint8_t event_nr = NRF_CTZ(active);
   46552:	fa94 f5a4 	rbit	r5, r4
   46556:	fab5 f585 	clz	r5, r5
        m_isr[event_nr]();
   4655a:	f857 3025 	ldr.w	r3, [r7, r5, lsl #2]
        active &= ~(1UL << event_nr);
   4655e:	fa08 f505 	lsl.w	r5, r8, r5
        m_isr[event_nr]();
   46562:	4798      	blx	r3
        active &= ~(1UL << event_nr);
   46564:	ea24 0405 	bic.w	r4, r4, r5
   46568:	e7da      	b.n	46520 <nrfx_usbd_irq_handler+0x20>
}
   4656a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   4656e:	bf00      	nop
   46570:	40027000 	.word	0x40027000
   46574:	00052f54 	.word	0x00052f54
   46578:	40027100 	.word	0x40027100

0004657c <usbd_ep_abort_all>:
{
   4657c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    uint32_t ep_waiting = m_ep_dma_waiting | (m_ep_ready & NRFX_USBD_EPOUT_BIT_MASK);
   4657e:	4e11      	ldr	r6, [pc, #68]	; (465c4 <usbd_ep_abort_all+0x48>)
   46580:	4b11      	ldr	r3, [pc, #68]	; (465c8 <usbd_ep_abort_all+0x4c>)
   46582:	6834      	ldr	r4, [r6, #0]
   46584:	681b      	ldr	r3, [r3, #0]
   46586:	0c24      	lsrs	r4, r4, #16
   46588:	0424      	lsls	r4, r4, #16
   4658a:	431c      	orrs	r4, r3
        ep_waiting &= ~(1U << bitpos);
   4658c:	2701      	movs	r7, #1
    while (0 != ep_waiting)
   4658e:	b91c      	cbnz	r4, 46598 <usbd_ep_abort_all+0x1c>
    m_ep_ready = (((1U << NRF_USBD_EPIN_CNT) - 1U) << NRFX_USBD_EPIN_BITPOS_0);
   46590:	f240 13ff 	movw	r3, #511	; 0x1ff
   46594:	6033      	str	r3, [r6, #0]
}
   46596:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        uint8_t bitpos = NRF_CTZ(ep_waiting);
   46598:	fa94 f5a4 	rbit	r5, r4
   4659c:	fab5 f585 	clz	r5, r5
    return (nrfx_usbd_ep_t)((bitpos >= NRFX_USBD_EPOUT_BITPOS_0) ?
   465a0:	2d0f      	cmp	r5, #15
        uint8_t bitpos = NRF_CTZ(ep_waiting);
   465a2:	4628      	mov	r0, r5
    return (nrfx_usbd_ep_t)((bitpos >= NRFX_USBD_EPOUT_BITPOS_0) ?
   465a4:	bfc6      	itte	gt
   465a6:	f1a5 0010 	subgt.w	r0, r5, #16
   465aa:	b2c0      	uxtbgt	r0, r0
   465ac:	f040 0080 	orrle.w	r0, r0, #128	; 0x80
        if (!NRF_USBD_EPISO_CHECK(bit2ep(bitpos)))
   465b0:	0703      	lsls	r3, r0, #28
   465b2:	d401      	bmi.n	465b8 <usbd_ep_abort_all+0x3c>
            usbd_ep_abort(bit2ep(bitpos));
   465b4:	f7ff fef6 	bl	463a4 <usbd_ep_abort>
        ep_waiting &= ~(1U << bitpos);
   465b8:	fa07 f505 	lsl.w	r5, r7, r5
   465bc:	ea24 0405 	bic.w	r4, r4, r5
   465c0:	e7e5      	b.n	4658e <usbd_ep_abort_all+0x12>
   465c2:	bf00      	nop
   465c4:	200068d0 	.word	0x200068d0
   465c8:	200068cc 	.word	0x200068cc

000465cc <nrfx_usbd_stop>:
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   465cc:	4b0c      	ldr	r3, [pc, #48]	; (46600 <nrfx_usbd_stop+0x34>)
   465ce:	2280      	movs	r2, #128	; 0x80
{
   465d0:	b510      	push	{r4, lr}
    if (NRFX_IRQ_IS_ENABLED(USBD_IRQn))
   465d2:	2027      	movs	r0, #39	; 0x27
   465d4:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
   465d8:	f7e6 fc0e 	bl	2cdf8 <arch_irq_is_enabled>
   465dc:	b170      	cbz	r0, 465fc <nrfx_usbd_stop+0x30>
    p_reg->USBPULLUP = USBD_USBPULLUP_CONNECT_Disabled << USBD_USBPULLUP_CONNECT_Pos;
   465de:	4c09      	ldr	r4, [pc, #36]	; (46604 <nrfx_usbd_stop+0x38>)
        usbd_ep_abort_all();
   465e0:	f7ff ffcc 	bl	4657c <usbd_ep_abort_all>
   465e4:	2300      	movs	r3, #0
   465e6:	f8c4 3504 	str.w	r3, [r4, #1284]	; 0x504
        NRFX_IRQ_DISABLE(USBD_IRQn);
   465ea:	2027      	movs	r0, #39	; 0x27
    (void) p_reg->USBPULLUP;
   465ec:	f8d4 3504 	ldr.w	r3, [r4, #1284]	; 0x504
   465f0:	f7e6 fbee 	bl	2cdd0 <arch_irq_disable>
    p_reg->INTENCLR = mask;
   465f4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   465f8:	f8c4 3308 	str.w	r3, [r4, #776]	; 0x308
}
   465fc:	bd10      	pop	{r4, pc}
   465fe:	bf00      	nop
   46600:	e000e100 	.word	0xe000e100
   46604:	40027000 	.word	0x40027000

00046608 <nrfx_usbd_disable>:
{
   46608:	b508      	push	{r3, lr}
    nrfx_usbd_stop();
   4660a:	f7ff ffdf 	bl	465cc <nrfx_usbd_stop>
    return p_reg->INTENSET;
   4660e:	4b08      	ldr	r3, [pc, #32]	; (46630 <nrfx_usbd_disable+0x28>)
   46610:	f8d3 2304 	ldr.w	r2, [r3, #772]	; 0x304
    p_reg->INTENCLR = mask;
   46614:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    p_reg->ENABLE = USBD_ENABLE_ENABLE_Disabled << USBD_ENABLE_ENABLE_Pos;
   46618:	2200      	movs	r2, #0
   4661a:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
    (void) p_reg->ENABLE;
   4661e:	f8d3 3500 	ldr.w	r3, [r3, #1280]	; 0x500
    usbd_dma_pending_clear();
   46622:	f7ff fa3d 	bl	45aa0 <usbd_dma_pending_clear>
    m_drv_state = NRFX_DRV_STATE_INITIALIZED;
   46626:	4b03      	ldr	r3, [pc, #12]	; (46634 <nrfx_usbd_disable+0x2c>)
   46628:	2201      	movs	r2, #1
   4662a:	701a      	strb	r2, [r3, #0]
}
   4662c:	bd08      	pop	{r3, pc}
   4662e:	bf00      	nop
   46630:	40027000 	.word	0x40027000
   46634:	20006bbf 	.word	0x20006bbf

00046638 <nrfx_usbd_suspend>:
{
   46638:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   4663a:	f04f 0320 	mov.w	r3, #32
   4663e:	f3ef 8511 	mrs	r5, BASEPRI
   46642:	f383 8812 	msr	BASEPRI_MAX, r3
   46646:	f3bf 8f6f 	isb	sy
    if (m_bus_suspend)
   4664a:	4b10      	ldr	r3, [pc, #64]	; (4668c <nrfx_usbd_suspend+0x54>)
   4664c:	781b      	ldrb	r3, [r3, #0]
   4664e:	f003 04ff 	and.w	r4, r3, #255	; 0xff
   46652:	b1a3      	cbz	r3, 4667e <nrfx_usbd_suspend+0x46>
        usbd_ep_abort_all();
   46654:	f7ff ff92 	bl	4657c <usbd_ep_abort_all>
    return p_reg->EVENTCAUSE;
   46658:	4b0d      	ldr	r3, [pc, #52]	; (46690 <nrfx_usbd_suspend+0x58>)
   4665a:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
        if (!(nrf_usbd_eventcause_get(NRF_USBD) & NRF_USBD_EVENTCAUSE_RESUME_MASK))
   4665e:	f412 7200 	ands.w	r2, r2, #512	; 0x200
   46662:	d10c      	bne.n	4667e <nrfx_usbd_suspend+0x46>
    p_reg->LOWPOWER = USBD_LOWPOWER_LOWPOWER_LowPower << USBD_LOWPOWER_LOWPOWER_Pos;
   46664:	2101      	movs	r1, #1
   46666:	f8c3 152c 	str.w	r1, [r3, #1324]	; 0x52c
    (void) p_reg->LOWPOWER;
   4666a:	f8d3 152c 	ldr.w	r1, [r3, #1324]	; 0x52c
    return p_reg->EVENTCAUSE;
   4666e:	f8d3 1400 	ldr.w	r1, [r3, #1024]	; 0x400
            if (nrf_usbd_eventcause_get(NRF_USBD) & NRF_USBD_EVENTCAUSE_RESUME_MASK)
   46672:	0589      	lsls	r1, r1, #22
   46674:	d504      	bpl.n	46680 <nrfx_usbd_suspend+0x48>
    p_reg->LOWPOWER = USBD_LOWPOWER_LOWPOWER_ForceNormal << USBD_LOWPOWER_LOWPOWER_Pos;
   46676:	f8c3 252c 	str.w	r2, [r3, #1324]	; 0x52c
    (void) p_reg->LOWPOWER;
   4667a:	f8d3 352c 	ldr.w	r3, [r3, #1324]	; 0x52c
    bool suspended = false;
   4667e:	2400      	movs	r4, #0
	__asm__ volatile(
   46680:	f385 8811 	msr	BASEPRI, r5
   46684:	f3bf 8f6f 	isb	sy
}
   46688:	4620      	mov	r0, r4
   4668a:	bd38      	pop	{r3, r4, r5, pc}
   4668c:	20006bbe 	.word	0x20006bbe
   46690:	40027000 	.word	0x40027000

00046694 <nrfx_usbd_ep_disable>:
{
   46694:	b510      	push	{r4, lr}
   46696:	4604      	mov	r4, r0
    usbd_ep_abort(ep);
   46698:	f7ff fe84 	bl	463a4 <usbd_ep_abort>
    uint8_t epnr = NRF_USBD_EP_NR_GET(ep);
   4669c:	4a10      	ldr	r2, [pc, #64]	; (466e0 <nrfx_usbd_ep_disable+0x4c>)
    if (NRF_USBD_EPIN_CHECK(ep))
   4669e:	f014 0f80 	tst.w	r4, #128	; 0x80
    uint8_t epnr = NRF_USBD_EP_NR_GET(ep);
   466a2:	f004 000f 	and.w	r0, r4, #15
        p_reg->EPINEN &= ~(1UL << epnr);
   466a6:	f04f 0301 	mov.w	r3, #1
   466aa:	bf14      	ite	ne
   466ac:	f8d2 1510 	ldrne.w	r1, [r2, #1296]	; 0x510
        p_reg->EPOUTEN &= ~(1UL << epnr);
   466b0:	f8d2 1514 	ldreq.w	r1, [r2, #1300]	; 0x514
        p_reg->EPINEN &= ~(1UL << epnr);
   466b4:	fa03 f300 	lsl.w	r3, r3, r0
   466b8:	ea6f 0303 	mvn.w	r3, r3
   466bc:	bf15      	itete	ne
   466be:	400b      	andne	r3, r1
        p_reg->EPOUTEN &= ~(1UL << epnr);
   466c0:	400b      	andeq	r3, r1
        p_reg->EPINEN &= ~(1UL << epnr);
   466c2:	f8c2 3510 	strne.w	r3, [r2, #1296]	; 0x510
        p_reg->EPOUTEN &= ~(1UL << epnr);
   466c6:	f8c2 3514 	streq.w	r3, [r2, #1300]	; 0x514
    return 1UL << (NRF_USBD_EPIN_CHECK(ep) ? epin_bitpos : epout_bitpos)[NRF_USBD_EP_NR_GET(ep)];
   466ca:	bf14      	ite	ne
   466cc:	4b05      	ldrne	r3, [pc, #20]	; (466e4 <nrfx_usbd_ep_disable+0x50>)
   466ce:	4b06      	ldreq	r3, [pc, #24]	; (466e8 <nrfx_usbd_ep_disable+0x54>)
   466d0:	5c1a      	ldrb	r2, [r3, r0]
   466d2:	2301      	movs	r3, #1
   466d4:	4093      	lsls	r3, r2
    p_reg->INTENCLR = mask;
   466d6:	4a02      	ldr	r2, [pc, #8]	; (466e0 <nrfx_usbd_ep_disable+0x4c>)
   466d8:	f8c2 3308 	str.w	r3, [r2, #776]	; 0x308
}
   466dc:	bd10      	pop	{r4, pc}
   466de:	bf00      	nop
   466e0:	40027000 	.word	0x40027000
   466e4:	000538b9 	.word	0x000538b9
   466e8:	000538b0 	.word	0x000538b0

000466ec <nrfx_usbd_ep_enable>:
    return 1UL << (NRF_USBD_EPIN_CHECK(ep) ? epin_bitpos : epout_bitpos)[NRF_USBD_EP_NR_GET(ep)];
   466ec:	f010 0f80 	tst.w	r0, #128	; 0x80
{
   466f0:	b570      	push	{r4, r5, r6, lr}
   466f2:	4924      	ldr	r1, [pc, #144]	; (46784 <nrfx_usbd_ep_enable+0x98>)
   466f4:	4604      	mov	r4, r0
   466f6:	f000 030f 	and.w	r3, r0, #15
   466fa:	f04f 0501 	mov.w	r5, #1
    return 1UL << (NRF_USBD_EPIN_CHECK(ep) ? epin_bitpos : epout_bitpos)[NRF_USBD_EP_NR_GET(ep)];
   466fe:	d012      	beq.n	46726 <nrfx_usbd_ep_enable+0x3a>
   46700:	4a21      	ldr	r2, [pc, #132]	; (46788 <nrfx_usbd_ep_enable+0x9c>)
   46702:	5cd2      	ldrb	r2, [r2, r3]
   46704:	fa05 f202 	lsl.w	r2, r5, r2
    p_reg->INTENSET = mask;
   46708:	f8c1 2304 	str.w	r2, [r1, #772]	; 0x304
        return 0 != (p_reg->EPINEN & (1UL << epnr));
   4670c:	f8d1 2510 	ldr.w	r2, [r1, #1296]	; 0x510
   46710:	40da      	lsrs	r2, r3
    if (nrf_usbd_ep_enable_check(NRF_USBD, ep))
   46712:	07d0      	lsls	r0, r2, #31
   46714:	d406      	bmi.n	46724 <nrfx_usbd_ep_enable+0x38>
        p_reg->EPINEN |= 1UL << epnr;
   46716:	f8d1 2510 	ldr.w	r2, [r1, #1296]	; 0x510
   4671a:	fa05 f303 	lsl.w	r3, r5, r3
   4671e:	4313      	orrs	r3, r2
   46720:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
}
   46724:	bd70      	pop	{r4, r5, r6, pc}
    return 1UL << (NRF_USBD_EPIN_CHECK(ep) ? epin_bitpos : epout_bitpos)[NRF_USBD_EP_NR_GET(ep)];
   46726:	4a19      	ldr	r2, [pc, #100]	; (4678c <nrfx_usbd_ep_enable+0xa0>)
   46728:	5cd2      	ldrb	r2, [r2, r3]
   4672a:	fa05 f202 	lsl.w	r2, r5, r2
    p_reg->INTENSET = mask;
   4672e:	f8c1 2304 	str.w	r2, [r1, #772]	; 0x304
        return 0 != (p_reg->EPOUTEN & (1UL << epnr));
   46732:	f8d1 2514 	ldr.w	r2, [r1, #1300]	; 0x514
   46736:	40da      	lsrs	r2, r3
    if (nrf_usbd_ep_enable_check(NRF_USBD, ep))
   46738:	07d2      	lsls	r2, r2, #31
   4673a:	d4f3      	bmi.n	46724 <nrfx_usbd_ep_enable+0x38>
        p_reg->EPOUTEN |= 1UL << epnr;
   4673c:	f8d1 6514 	ldr.w	r6, [r1, #1300]	; 0x514
   46740:	fa05 f203 	lsl.w	r2, r5, r3
   46744:	4332      	orrs	r2, r6
   46746:	f8c1 2514 	str.w	r2, [r1, #1300]	; 0x514
    if ((NRF_USBD_EP_NR_GET(ep) != 0) &&
   4674a:	2b00      	cmp	r3, #0
   4674c:	d0ea      	beq.n	46724 <nrfx_usbd_ep_enable+0x38>
        NRF_USBD_EPOUT_CHECK(ep) &&
   4674e:	0703      	lsls	r3, r0, #28
   46750:	d4e8      	bmi.n	46724 <nrfx_usbd_ep_enable+0x38>
	__asm__ volatile(
   46752:	f04f 0320 	mov.w	r3, #32
   46756:	f3ef 8611 	mrs	r6, BASEPRI
   4675a:	f383 8812 	msr	BASEPRI_MAX, r3
   4675e:	f3bf 8f6f 	isb	sy
        nrfx_usbd_transfer_out_drop(ep);
   46762:	f7ff fdf5 	bl	46350 <nrfx_usbd_transfer_out_drop>
        m_ep_dma_waiting &= ~(1U << ep2bit(ep));
   46766:	4620      	mov	r0, r4
   46768:	f008 fe91 	bl	4f48e <ep2bit>
   4676c:	4a08      	ldr	r2, [pc, #32]	; (46790 <nrfx_usbd_ep_enable+0xa4>)
   4676e:	6813      	ldr	r3, [r2, #0]
   46770:	fa05 f000 	lsl.w	r0, r5, r0
   46774:	ea23 0300 	bic.w	r3, r3, r0
   46778:	6013      	str	r3, [r2, #0]
	__asm__ volatile(
   4677a:	f386 8811 	msr	BASEPRI, r6
   4677e:	f3bf 8f6f 	isb	sy
}
   46782:	e7cf      	b.n	46724 <nrfx_usbd_ep_enable+0x38>
   46784:	40027000 	.word	0x40027000
   46788:	000538b9 	.word	0x000538b9
   4678c:	000538b0 	.word	0x000538b0
   46790:	200068cc 	.word	0x200068cc

00046794 <nrfx_usbd_ep_stall_clear>:
    if (NRF_USBD_EPOUT_CHECK(ep) && nrfx_usbd_ep_stall_check(ep))
   46794:	0603      	lsls	r3, r0, #24
{
   46796:	b510      	push	{r4, lr}
   46798:	4604      	mov	r4, r0
    if (NRF_USBD_EPOUT_CHECK(ep) && nrfx_usbd_ep_stall_check(ep))
   4679a:	d405      	bmi.n	467a8 <nrfx_usbd_ep_stall_clear+0x14>
   4679c:	f7ff fd46 	bl	4622c <nrfx_usbd_ep_stall_check>
   467a0:	b110      	cbz	r0, 467a8 <nrfx_usbd_ep_stall_clear+0x14>
        nrfx_usbd_transfer_out_drop(ep);
   467a2:	4620      	mov	r0, r4
   467a4:	f7ff fdd4 	bl	46350 <nrfx_usbd_transfer_out_drop>
    p_reg->EPSTALL = (USBD_EPSTALL_STALL_UnStall << USBD_EPSTALL_STALL_Pos) | ep;
   467a8:	4b01      	ldr	r3, [pc, #4]	; (467b0 <nrfx_usbd_ep_stall_clear+0x1c>)
   467aa:	f8c3 4518 	str.w	r4, [r3, #1304]	; 0x518
}
   467ae:	bd10      	pop	{r4, pc}
   467b0:	40027000 	.word	0x40027000

000467b4 <compare_ports>:

static int compare_ports(const void *a, const void *b) {
    const struct kscan_gpio *gpio_a = a;
    const struct kscan_gpio *gpio_b = b;

    return gpio_a->spec.port - gpio_b->spec.port;
   467b4:	680b      	ldr	r3, [r1, #0]
   467b6:	6800      	ldr	r0, [r0, #0]
   467b8:	1ac0      	subs	r0, r0, r3
}
   467ba:	4b02      	ldr	r3, [pc, #8]	; (467c4 <compare_ports+0x10>)
    return gpio_a->spec.port - gpio_b->spec.port;
   467bc:	10c0      	asrs	r0, r0, #3
}
   467be:	4358      	muls	r0, r3
   467c0:	4770      	bx	lr
   467c2:	bf00      	nop
   467c4:	aaaaaaab 	.word	0xaaaaaaab

000467c8 <kscan_gpio_list_sort_by_port>:

void kscan_gpio_list_sort_by_port(struct kscan_gpio_list *list) {
    qsort(list->gpios, list->len, sizeof(list->gpios[0]), compare_ports);
   467c8:	e9d0 0100 	ldrd	r0, r1, [r0]
   467cc:	4b01      	ldr	r3, [pc, #4]	; (467d4 <kscan_gpio_list_sort_by_port+0xc>)
   467ce:	220c      	movs	r2, #12
   467d0:	f004 bb07 	b.w	4ade2 <qsort>
   467d4:	000467b5 	.word	0x000467b5

000467d8 <kscan_matrix_init>:
    }

    return 0;
}

static int kscan_matrix_init(const struct device *dev) {
   467d8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    struct kscan_matrix_data *data = dev->data;
   467dc:	6907      	ldr	r7, [r0, #16]
static int kscan_matrix_init(const struct device *dev) {
   467de:	4604      	mov	r4, r0

    data->dev = dev;
   467e0:	4638      	mov	r0, r7
    for (int i = 0; i < data->inputs.len; i++) {
   467e2:	2500      	movs	r5, #0
    data->dev = dev;
   467e4:	f840 4b04 	str.w	r4, [r0], #4

    // Sort inputs by port so we can read each port just once per scan.
    kscan_gpio_list_sort_by_port(&data->inputs);
   467e8:	f7ff ffee 	bl	467c8 <kscan_gpio_list_sort_by_port>
    const struct kscan_matrix_data *data = dev->data;
   467ec:	f8d4 8010 	ldr.w	r8, [r4, #16]
        const struct kscan_gpio *gpio = &data->inputs.gpios[i];
   467f0:	f04f 090c 	mov.w	r9, #12
    for (int i = 0; i < data->inputs.len; i++) {
   467f4:	f8d8 3008 	ldr.w	r3, [r8, #8]
   467f8:	42ab      	cmp	r3, r5
   467fa:	d90a      	bls.n	46812 <kscan_matrix_init+0x3a>
        const struct kscan_gpio *gpio = &data->inputs.gpios[i];
   467fc:	f8d8 b004 	ldr.w	fp, [r8, #4]
   46800:	fb09 f605 	mul.w	r6, r9, r5
   46804:	eb0b 0a06 	add.w	sl, fp, r6
    if (!device_is_ready(gpio->spec.port)) {
   46808:	f85b 0006 	ldr.w	r0, [fp, r6]
   4680c:	f009 f93b 	bl	4fa86 <z_device_is_ready>
   46810:	b990      	cbnz	r0, 46838 <kscan_matrix_init+0x60>

    kscan_matrix_init_inputs(dev);
    kscan_matrix_init_outputs(dev);
   46812:	6866      	ldr	r6, [r4, #4]
    for (int i = 0; i < config->outputs.len; i++) {
   46814:	2500      	movs	r5, #0
        const struct gpio_dt_spec *gpio = &config->outputs.gpios[i].spec;
   46816:	f04f 080c 	mov.w	r8, #12
    for (int i = 0; i < config->outputs.len; i++) {
   4681a:	6873      	ldr	r3, [r6, #4]
   4681c:	42ab      	cmp	r3, r5
   4681e:	d82f      	bhi.n	46880 <kscan_matrix_init+0xa8>
    kscan_matrix_set_all_outputs(dev, 0);
   46820:	6860      	ldr	r0, [r4, #4]
   46822:	2100      	movs	r1, #0
   46824:	f008 ff51 	bl	4f6ca <kscan_matrix_set_all_outputs.isra.0>

    k_work_init_delayable(&data->work, kscan_matrix_work_handler);
   46828:	f107 0010 	add.w	r0, r7, #16
   4682c:	491e      	ldr	r1, [pc, #120]	; (468a8 <kscan_matrix_init+0xd0>)
   4682e:	f009 fbe9 	bl	50004 <k_work_init_delayable>

    return 0;
}
   46832:	2000      	movs	r0, #0
   46834:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    int err = gpio_pin_configure_dt(&gpio->spec, GPIO_INPUT);
   46838:	f44f 3180 	mov.w	r1, #65536	; 0x10000
   4683c:	4650      	mov	r0, sl
   4683e:	f008 fee5 	bl	4f60c <gpio_pin_configure_dt>
    if (err) {
   46842:	2800      	cmp	r0, #0
   46844:	d1e5      	bne.n	46812 <kscan_matrix_init+0x3a>
    struct kscan_matrix_irq_callback *irq = &data->irqs[gpio->index];
   46846:	f8da 3008 	ldr.w	r3, [sl, #8]
   4684a:	6921      	ldr	r1, [r4, #16]
				      gpio_port_pins_t pin_mask)
{
	__ASSERT(callback, "Callback pointer should not be NULL");
	__ASSERT(handler, "Callback handler pointer should not be NULL");

	callback->handler = handler;
   4684c:	f8df c05c 	ldr.w	ip, [pc, #92]	; 468ac <kscan_matrix_init+0xd4>
   46850:	6c09      	ldr	r1, [r1, #64]	; 0x40
   46852:	0118      	lsls	r0, r3, #4
    gpio_init_callback(&irq->callback, kscan_matrix_irq_callback_handler, BIT(gpio->spec.pin));
   46854:	2201      	movs	r2, #1
    irq->dev = dev;
   46856:	500c      	str	r4, [r1, r0]
    gpio_init_callback(&irq->callback, kscan_matrix_irq_callback_handler, BIT(gpio->spec.pin));
   46858:	f89a 0004 	ldrb.w	r0, [sl, #4]
    struct kscan_matrix_irq_callback *irq = &data->irqs[gpio->index];
   4685c:	eb01 1303 	add.w	r3, r1, r3, lsl #4
    gpio_init_callback(&irq->callback, kscan_matrix_irq_callback_handler, BIT(gpio->spec.pin));
   46860:	fa02 f000 	lsl.w	r0, r2, r0
	callback->pin_mask = pin_mask;
   46864:	e9c3 c002 	strd	ip, r0, [r3, #8]
    err = gpio_add_callback(gpio->spec.port, &irq->callback);
   46868:	f85b 0006 	ldr.w	r0, [fp, r6]
    gpio_init_callback(&irq->callback, kscan_matrix_irq_callback_handler, BIT(gpio->spec.pin));
   4686c:	1d19      	adds	r1, r3, #4
				    struct gpio_callback *callback)
{
	const struct gpio_driver_api *api =
		(const struct gpio_driver_api *)port->api;

	if (api->manage_callback == NULL) {
   4686e:	6883      	ldr	r3, [r0, #8]
   46870:	69db      	ldr	r3, [r3, #28]
   46872:	2b00      	cmp	r3, #0
   46874:	d0cd      	beq.n	46812 <kscan_matrix_init+0x3a>
		return -ENOTSUP;
	}

	return api->manage_callback(port, callback, true);
   46876:	4798      	blx	r3
        if (err) {
   46878:	2800      	cmp	r0, #0
   4687a:	d1ca      	bne.n	46812 <kscan_matrix_init+0x3a>
    for (int i = 0; i < data->inputs.len; i++) {
   4687c:	3501      	adds	r5, #1
   4687e:	e7b9      	b.n	467f4 <kscan_matrix_init+0x1c>
        const struct gpio_dt_spec *gpio = &config->outputs.gpios[i].spec;
   46880:	6832      	ldr	r2, [r6, #0]
   46882:	fb08 f305 	mul.w	r3, r8, r5
   46886:	eb02 0903 	add.w	r9, r2, r3
    if (!device_is_ready(gpio->port)) {
   4688a:	58d0      	ldr	r0, [r2, r3]
   4688c:	f009 f8fb 	bl	4fa86 <z_device_is_ready>
   46890:	2800      	cmp	r0, #0
   46892:	d0c5      	beq.n	46820 <kscan_matrix_init+0x48>
    int err = gpio_pin_configure_dt(gpio, GPIO_OUTPUT);
   46894:	f44f 3100 	mov.w	r1, #131072	; 0x20000
   46898:	4648      	mov	r0, r9
   4689a:	f008 feb7 	bl	4f60c <gpio_pin_configure_dt>
        if (err) {
   4689e:	2800      	cmp	r0, #0
   468a0:	d1be      	bne.n	46820 <kscan_matrix_init+0x48>
    for (int i = 0; i < config->outputs.len; i++) {
   468a2:	3501      	adds	r5, #1
   468a4:	e7b9      	b.n	4681a <kscan_matrix_init+0x42>
   468a6:	bf00      	nop
   468a8:	0004f863 	.word	0x0004f863
   468ac:	0004f889 	.word	0x0004f889

000468b0 <vddh_sample_fetch>:
    struct adc_channel_cfg acc;
    struct adc_sequence as;
    struct battery_value value;
};

static int vddh_sample_fetch(const struct device *dev, enum sensor_channel chan) {
   468b0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   468b2:	3927      	subs	r1, #39	; 0x27
   468b4:	b289      	uxth	r1, r1
   468b6:	2912      	cmp	r1, #18
   468b8:	d827      	bhi.n	4690a <vddh_sample_fetch+0x5a>
   468ba:	4b15      	ldr	r3, [pc, #84]	; (46910 <vddh_sample_fetch+0x60>)
   468bc:	40cb      	lsrs	r3, r1
   468be:	07db      	lsls	r3, r3, #31
   468c0:	d523      	bpl.n	4690a <vddh_sample_fetch+0x5a>
        chan != SENSOR_CHAN_ALL) {
        LOG_DBG("Selected channel is not supported: %d.", chan);
        return -ENOTSUP;
    }

    struct vddh_data *drv_data = dev->data;
   468c2:	6905      	ldr	r5, [r0, #16]
		       const struct adc_sequence *sequence);

static inline int z_impl_adc_read(const struct device *dev,
				  const struct adc_sequence *sequence)
{
	const struct adc_driver_api *api =
   468c4:	4813      	ldr	r0, [pc, #76]	; (46914 <vddh_sample_fetch+0x64>)
   468c6:	6886      	ldr	r6, [r0, #8]
				(const struct adc_driver_api *)dev->api;

	return api->read(dev, sequence);
   468c8:	f105 0108 	add.w	r1, r5, #8
   468cc:	6873      	ldr	r3, [r6, #4]
   468ce:	4798      	blx	r3
    struct adc_sequence *as = &drv_data->as;

    int rc = adc_read(adc, as);
    as->calibrate = false;
   468d0:	2300      	movs	r3, #0
   468d2:	76ab      	strb	r3, [r5, #26]

    if (rc != 0) {
   468d4:	4604      	mov	r4, r0
   468d6:	b9a8      	cbnz	r0, 46904 <vddh_sample_fetch+0x54>
        LOG_ERR("Failed to read ADC: %d", rc);
        return rc;
    }

    int32_t val = drv_data->value.adc_raw;
   468d8:	8bab      	ldrh	r3, [r5, #28]
    rc = adc_raw_to_millivolts(adc_ref_internal(adc), drv_data->acc.gain, as->resolution, &val);
   468da:	8932      	ldrh	r2, [r6, #8]
   468dc:	7828      	ldrb	r0, [r5, #0]
   468de:	7e2f      	ldrb	r7, [r5, #24]
static inline int adc_raw_to_millivolts(int32_t ref_mv,
					enum adc_gain gain,
					uint8_t resolution,
					int32_t *valp)
{
	int32_t adc_mv = *valp * ref_mv;
   468e0:	4353      	muls	r3, r2
	int ret = adc_gain_invert(gain, &adc_mv);
   468e2:	a901      	add	r1, sp, #4
	int32_t adc_mv = *valp * ref_mv;
   468e4:	9301      	str	r3, [sp, #4]
	int ret = adc_gain_invert(gain, &adc_mv);
   468e6:	f7fc fe9d 	bl	43624 <adc_gain_invert>

	if (ret == 0) {
   468ea:	4604      	mov	r4, r0
   468ec:	b950      	cbnz	r0, 46904 <vddh_sample_fetch+0x54>
		*valp = (adc_mv >> resolution);
   468ee:	9801      	ldr	r0, [sp, #4]
   468f0:	4138      	asrs	r0, r7
    if (rc != 0) {
        LOG_ERR("Failed to convert raw ADC to mV: %d", rc);
        return rc;
    }

    drv_data->value.millivolts = val * VDDHDIV;
   468f2:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   468f6:	b280      	uxth	r0, r0
   468f8:	83e8      	strh	r0, [r5, #30]
    drv_data->value.state_of_charge = lithium_ion_mv_to_pct(drv_data->value.millivolts);
   468fa:	b200      	sxth	r0, r0
   468fc:	f009 f81d 	bl	4f93a <lithium_ion_mv_to_pct>
   46900:	f885 0020 	strb.w	r0, [r5, #32]

    LOG_DBG("ADC raw %d ~ %d mV => %d%%", drv_data->value.adc_raw, drv_data->value.millivolts,
            drv_data->value.state_of_charge);

    return rc;
}
   46904:	4620      	mov	r0, r4
   46906:	b003      	add	sp, #12
   46908:	bdf0      	pop	{r4, r5, r6, r7, pc}
static int vddh_sample_fetch(const struct device *dev, enum sensor_channel chan) {
   4690a:	f06f 0485 	mvn.w	r4, #133	; 0x85
   4690e:	e7f9      	b.n	46904 <vddh_sample_fetch+0x54>
   46910:	00040021 	.word	0x00040021
   46914:	000508bc 	.word	0x000508bc

00046918 <vddh_init>:
static const struct sensor_driver_api vddh_api = {
    .sample_fetch = vddh_sample_fetch,
    .channel_get = vddh_channel_get,
};

static int vddh_init(const struct device *dev) {
   46918:	b570      	push	{r4, r5, r6, lr}
    struct vddh_data *drv_data = dev->data;
   4691a:	6904      	ldr	r4, [r0, #16]
   4691c:	4d12      	ldr	r5, [pc, #72]	; (46968 <vddh_init+0x50>)
   4691e:	4628      	mov	r0, r5
   46920:	f009 f8b1 	bl	4fa86 <z_device_is_ready>

    if (!device_is_ready(adc)) {
   46924:	b1e0      	cbz	r0, 46960 <vddh_init+0x48>
        LOG_ERR("ADC device is not ready %s", adc->name);
        return -ENODEV;
    }

    drv_data->as = (struct adc_sequence){
   46926:	2214      	movs	r2, #20
   46928:	2100      	movs	r1, #0
   4692a:	f104 0008 	add.w	r0, r4, #8
   4692e:	f004 faaf 	bl	4ae90 <memset>
        .channels = BIT(0),
        .buffer = &drv_data->value.adc_raw,
   46932:	f104 021c 	add.w	r2, r4, #28
        .oversampling = 4,
        .calibrate = true,
    };

#ifdef CONFIG_ADC_NRFX_SAADC
    drv_data->acc = (struct adc_channel_cfg){
   46936:	490d      	ldr	r1, [pc, #52]	; (4696c <vddh_init+0x54>)
    drv_data->as = (struct adc_sequence){
   46938:	6122      	str	r2, [r4, #16]
    drv_data->acc = (struct adc_channel_cfg){
   4693a:	f44f 6250 	mov.w	r2, #3328	; 0xd00
   4693e:	e9c4 1200 	strd	r1, r2, [r4]
    drv_data->as = (struct adc_sequence){
   46942:	2202      	movs	r2, #2
   46944:	2301      	movs	r3, #1
   46946:	6162      	str	r2, [r4, #20]
        .reference = ADC_REF_INTERNAL,
        .acquisition_time = ADC_ACQ_TIME(ADC_ACQ_TIME_MICROSECONDS, 40),
        .input_positive = SAADC_CH_PSELN_PSELN_VDDHDIV5,
    };

    drv_data->as.resolution = 12;
   46948:	f240 420c 	movw	r2, #1036	; 0x40c
    drv_data->as = (struct adc_sequence){
   4694c:	60e3      	str	r3, [r4, #12]
    drv_data->as.resolution = 12;
   4694e:	8322      	strh	r2, [r4, #24]
    drv_data->as = (struct adc_sequence){
   46950:	76a3      	strb	r3, [r4, #26]
	return api->channel_setup(dev, channel_cfg);
   46952:	68ab      	ldr	r3, [r5, #8]
   46954:	4621      	mov	r1, r4
   46956:	4628      	mov	r0, r5
   46958:	681b      	ldr	r3, [r3, #0]

    const int rc = adc_channel_setup(adc, &drv_data->acc);
    LOG_DBG("VDDHDIV5 setup returned %d", rc);

    return rc;
}
   4695a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   4695e:	4718      	bx	r3
   46960:	f06f 0012 	mvn.w	r0, #18
   46964:	bd70      	pop	{r4, r5, r6, pc}
   46966:	bf00      	nop
   46968:	000508bc 	.word	0x000508bc
   4696c:	40280405 	.word	0x40280405

00046970 <ec11_channel_get>:

    return 0;
}

static int ec11_channel_get(const struct device *dev, enum sensor_channel chan,
                            struct sensor_value *val) {
   46970:	b510      	push	{r4, lr}
    struct ec11_data *drv_data = dev->data;
   46972:	6904      	ldr	r4, [r0, #16]
    const struct ec11_config *drv_cfg = dev->config;
   46974:	6840      	ldr	r0, [r0, #4]
    int32_t pulses = drv_data->pulses;
   46976:	f994 3001 	ldrsb.w	r3, [r4, #1]

    if (chan != SENSOR_CHAN_ROTATION) {
   4697a:	2922      	cmp	r1, #34	; 0x22
   4697c:	d11e      	bne.n	469bc <ec11_channel_get+0x4c>
        return -ENOTSUP;
    }

    drv_data->pulses = 0;
   4697e:	2100      	movs	r1, #0
   46980:	7061      	strb	r1, [r4, #1]

    if (drv_cfg->steps > 0) {
   46982:	8a01      	ldrh	r1, [r0, #16]
   46984:	b1a1      	cbz	r1, 469b0 <ec11_channel_get+0x40>
        val->val1 = (pulses * FULL_ROTATION) / drv_cfg->steps;
   46986:	f44f 74b4 	mov.w	r4, #360	; 0x168
   4698a:	4363      	muls	r3, r4
   4698c:	fb93 f1f1 	sdiv	r1, r3, r1
   46990:	6011      	str	r1, [r2, #0]
        val->val2 = (pulses * FULL_ROTATION) % drv_cfg->steps;
   46992:	8a01      	ldrh	r1, [r0, #16]
   46994:	fb93 f4f1 	sdiv	r4, r3, r1
   46998:	fb01 3314 	mls	r3, r1, r4, r3
        if (val->val2 != 0) {
   4699c:	b12b      	cbz	r3, 469aa <ec11_channel_get+0x3a>
            val->val2 *= 1000000;
   4699e:	4909      	ldr	r1, [pc, #36]	; (469c4 <ec11_channel_get+0x54>)
   469a0:	434b      	muls	r3, r1
   469a2:	6053      	str	r3, [r2, #4]
            val->val2 /= drv_cfg->steps;
   469a4:	8a01      	ldrh	r1, [r0, #16]
   469a6:	fb93 f3f1 	sdiv	r3, r3, r1
   469aa:	6053      	str	r3, [r2, #4]
    } else {
        val->val1 = drv_data->ticks;
        val->val2 = drv_data->delta;
    }

    return 0;
   469ac:	2000      	movs	r0, #0
}
   469ae:	bd10      	pop	{r4, pc}
        val->val1 = drv_data->ticks;
   469b0:	f994 3002 	ldrsb.w	r3, [r4, #2]
   469b4:	6013      	str	r3, [r2, #0]
        val->val2 = drv_data->delta;
   469b6:	f994 3003 	ldrsb.w	r3, [r4, #3]
   469ba:	e7f6      	b.n	469aa <ec11_channel_get+0x3a>
        return -ENOTSUP;
   469bc:	f06f 0085 	mvn.w	r0, #133	; 0x85
   469c0:	e7f5      	b.n	469ae <ec11_channel_get+0x3e>
   469c2:	bf00      	nop
   469c4:	000f4240 	.word	0x000f4240

000469c8 <z_sys_init_run_level>:
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
   469c8:	4b0f      	ldr	r3, [pc, #60]	; (46a08 <z_sys_init_run_level+0x40>)
{
   469ca:	b570      	push	{r4, r5, r6, lr}
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
   469cc:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
   469d0:	3001      	adds	r0, #1
   469d2:	f853 6020 	ldr.w	r6, [r3, r0, lsl #2]
   469d6:	42a6      	cmp	r6, r4
   469d8:	d800      	bhi.n	469dc <z_sys_init_run_level+0x14>
				dev->state->init_res = rc;
			}
			dev->state->initialized = true;
		}
	}
}
   469da:	bd70      	pop	{r4, r5, r6, pc}
		int rc = entry->init(dev);
   469dc:	e9d4 3500 	ldrd	r3, r5, [r4]
   469e0:	4628      	mov	r0, r5
   469e2:	4798      	blx	r3
		if (dev != NULL) {
   469e4:	b16d      	cbz	r5, 46a02 <z_sys_init_run_level+0x3a>
			if (rc != 0) {
   469e6:	b138      	cbz	r0, 469f8 <z_sys_init_run_level+0x30>
				if (rc < 0) {
   469e8:	2800      	cmp	r0, #0
   469ea:	bfb8      	it	lt
   469ec:	4240      	neglt	r0, r0
				dev->state->init_res = rc;
   469ee:	68eb      	ldr	r3, [r5, #12]
				if (rc > UINT8_MAX) {
   469f0:	28ff      	cmp	r0, #255	; 0xff
   469f2:	bfa8      	it	ge
   469f4:	20ff      	movge	r0, #255	; 0xff
				dev->state->init_res = rc;
   469f6:	7018      	strb	r0, [r3, #0]
			dev->state->initialized = true;
   469f8:	68ea      	ldr	r2, [r5, #12]
   469fa:	7853      	ldrb	r3, [r2, #1]
   469fc:	f043 0301 	orr.w	r3, r3, #1
   46a00:	7053      	strb	r3, [r2, #1]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
   46a02:	3408      	adds	r4, #8
   46a04:	e7e7      	b.n	469d6 <z_sys_init_run_level+0xe>
   46a06:	bf00      	nop
   46a08:	00053000 	.word	0x00053000

00046a0c <z_impl_device_get_binding>:

const struct device *z_impl_device_get_binding(const char *name)
{
   46a0c:	b570      	push	{r4, r5, r6, lr}
	const struct device *dev;

	/* A null string identifies no device.  So does an empty
	 * string.
	 */
	if ((name == NULL) || (name[0] == '\0')) {
   46a0e:	4605      	mov	r5, r0
   46a10:	b910      	cbnz	r0, 46a18 <z_impl_device_get_binding+0xc>
		return NULL;
   46a12:	2400      	movs	r4, #0
			return dev;
		}
	}

	return NULL;
}
   46a14:	4620      	mov	r0, r4
   46a16:	bd70      	pop	{r4, r5, r6, pc}
	if ((name == NULL) || (name[0] == '\0')) {
   46a18:	7803      	ldrb	r3, [r0, #0]
   46a1a:	2b00      	cmp	r3, #0
   46a1c:	d0f9      	beq.n	46a12 <z_impl_device_get_binding+0x6>
	for (dev = __device_start; dev != __device_end; dev++) {
   46a1e:	4c0e      	ldr	r4, [pc, #56]	; (46a58 <z_impl_device_get_binding+0x4c>)
   46a20:	4e0e      	ldr	r6, [pc, #56]	; (46a5c <z_impl_device_get_binding+0x50>)
   46a22:	42b4      	cmp	r4, r6
   46a24:	d108      	bne.n	46a38 <z_impl_device_get_binding+0x2c>
	for (dev = __device_start; dev != __device_end; dev++) {
   46a26:	4c0c      	ldr	r4, [pc, #48]	; (46a58 <z_impl_device_get_binding+0x4c>)
   46a28:	42b4      	cmp	r4, r6
   46a2a:	d0f2      	beq.n	46a12 <z_impl_device_get_binding+0x6>
		if (z_device_is_ready(dev) && (strcmp(name, dev->name) == 0)) {
   46a2c:	4620      	mov	r0, r4
   46a2e:	f009 f82a 	bl	4fa86 <z_device_is_ready>
   46a32:	b950      	cbnz	r0, 46a4a <z_impl_device_get_binding+0x3e>
	for (dev = __device_start; dev != __device_end; dev++) {
   46a34:	3418      	adds	r4, #24
   46a36:	e7f7      	b.n	46a28 <z_impl_device_get_binding+0x1c>
		if (z_device_is_ready(dev) && (dev->name == name)) {
   46a38:	4620      	mov	r0, r4
   46a3a:	f009 f824 	bl	4fa86 <z_device_is_ready>
   46a3e:	b110      	cbz	r0, 46a46 <z_impl_device_get_binding+0x3a>
   46a40:	6823      	ldr	r3, [r4, #0]
   46a42:	42ab      	cmp	r3, r5
   46a44:	d0e6      	beq.n	46a14 <z_impl_device_get_binding+0x8>
	for (dev = __device_start; dev != __device_end; dev++) {
   46a46:	3418      	adds	r4, #24
   46a48:	e7eb      	b.n	46a22 <z_impl_device_get_binding+0x16>
		if (z_device_is_ready(dev) && (strcmp(name, dev->name) == 0)) {
   46a4a:	6821      	ldr	r1, [r4, #0]
   46a4c:	4628      	mov	r0, r5
   46a4e:	f004 f9e4 	bl	4ae1a <strcmp>
   46a52:	2800      	cmp	r0, #0
   46a54:	d1ee      	bne.n	46a34 <z_impl_device_get_binding+0x28>
   46a56:	e7dd      	b.n	46a14 <z_impl_device_get_binding+0x8>
   46a58:	0005082c 	.word	0x0005082c
   46a5c:	00050a3c 	.word	0x00050a3c

00046a60 <z_impl_z_errno>:
#include <syscalls/z_errno_mrsh.c>

#else
int *z_impl_z_errno(void)
{
	return &_current->errno_var;
   46a60:	4b01      	ldr	r3, [pc, #4]	; (46a68 <z_impl_z_errno+0x8>)
   46a62:	6898      	ldr	r0, [r3, #8]
}
   46a64:	3064      	adds	r0, #100	; 0x64
   46a66:	4770      	bx	lr
   46a68:	2000694c 	.word	0x2000694c

00046a6c <bg_thread_main>:
 * This routine completes kernel initialization by invoking the remaining
 * init functions, then invokes application's main() routine.
 */
__boot_func
static void bg_thread_main(void *unused1, void *unused2, void *unused3)
{
   46a6c:	b508      	push	{r3, lr}
	 * may perform memory management tasks (except for z_phys_map() which
	 * is allowed at any time)
	 */
	z_mem_manage_init();
#endif /* CONFIG_MMU */
	z_sys_post_kernel = true;
   46a6e:	4b0a      	ldr	r3, [pc, #40]	; (46a98 <bg_thread_main+0x2c>)
   46a70:	2201      	movs	r2, #1

	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
   46a72:	2002      	movs	r0, #2
	z_sys_post_kernel = true;
   46a74:	701a      	strb	r2, [r3, #0]
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
   46a76:	f7ff ffa7 	bl	469c8 <z_sys_init_run_level>
#if CONFIG_STACK_POINTER_RANDOM
	z_stack_adjust_initialized = 1;
#endif
	boot_banner();
   46a7a:	f001 fbd5 	bl	48228 <boot_banner>
	void z_cpp_init_static(void);
	z_cpp_init_static();
#endif

	/* Final init level before app starts */
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
   46a7e:	2003      	movs	r0, #3
   46a80:	f7ff ffa2 	bl	469c8 <z_sys_init_run_level>

	z_init_static_threads();
   46a84:	f000 f966 	bl	46d54 <z_init_static_threads>
	z_mem_manage_boot_finish();
#endif /* CONFIG_MMU */

	extern void main(void);

	main();
   46a88:	f7e4 f858 	bl	2ab3c <main>

	/* Mark nonessential since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
   46a8c:	4a03      	ldr	r2, [pc, #12]	; (46a9c <bg_thread_main+0x30>)
   46a8e:	7b13      	ldrb	r3, [r2, #12]
   46a90:	f023 0301 	bic.w	r3, r3, #1
   46a94:	7313      	strb	r3, [r2, #12]

#ifdef CONFIG_COVERAGE_DUMP
	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
#endif
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
   46a96:	bd08      	pop	{r3, pc}
   46a98:	20006bc4 	.word	0x20006bc4
   46a9c:	200035f8 	.word	0x200035f8

00046aa0 <z_bss_zero>:
{
   46aa0:	b508      	push	{r3, lr}
	z_early_memset(__bss_start, 0, __bss_end - __bss_start);
   46aa2:	4803      	ldr	r0, [pc, #12]	; (46ab0 <z_bss_zero+0x10>)
   46aa4:	4a03      	ldr	r2, [pc, #12]	; (46ab4 <z_bss_zero+0x14>)
   46aa6:	2100      	movs	r1, #0
   46aa8:	1a12      	subs	r2, r2, r0
   46aaa:	f009 f81d 	bl	4fae8 <z_early_memset>
}
   46aae:	bd08      	pop	{r3, pc}
   46ab0:	20001498 	.word	0x20001498
   46ab4:	20006bc8 	.word	0x20006bc8

00046ab8 <z_init_cpu>:
	thread->base.is_idle = 1U;
#endif
}

void z_init_cpu(int id)
{
   46ab8:	b570      	push	{r4, r5, r6, lr}
	z_setup_new_thread(thread, stack,
   46aba:	2300      	movs	r3, #0
{
   46abc:	b086      	sub	sp, #24
	z_setup_new_thread(thread, stack,
   46abe:	2201      	movs	r2, #1
   46ac0:	e9cd 2304 	strd	r2, r3, [sp, #16]
	struct k_thread *thread = &z_idle_threads[i];
   46ac4:	4e11      	ldr	r6, [pc, #68]	; (46b0c <z_init_cpu+0x54>)
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
   46ac6:	4d12      	ldr	r5, [pc, #72]	; (46b10 <z_init_cpu+0x58>)
	z_setup_new_thread(thread, stack,
   46ac8:	9301      	str	r3, [sp, #4]
   46aca:	220f      	movs	r2, #15
   46acc:	e9cd 3202 	strd	r3, r2, [sp, #8]
   46ad0:	4910      	ldr	r1, [pc, #64]	; (46b14 <z_init_cpu+0x5c>)
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
   46ad2:	2318      	movs	r3, #24
   46ad4:	fb03 5500 	mla	r5, r3, r0, r5
	struct k_thread *thread = &z_idle_threads[i];
   46ad8:	eb06 16c0 	add.w	r6, r6, r0, lsl #7
	z_setup_new_thread(thread, stack,
   46adc:	f44f 72a0 	mov.w	r2, #320	; 0x140
{
   46ae0:	4604      	mov	r4, r0
	z_setup_new_thread(thread, stack,
   46ae2:	fb02 1100 	mla	r1, r2, r0, r1
   46ae6:	4b0c      	ldr	r3, [pc, #48]	; (46b18 <z_init_cpu+0x60>)
   46ae8:	9500      	str	r5, [sp, #0]
   46aea:	4630      	mov	r0, r6
   46aec:	f000 f8d6 	bl	46c9c <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
   46af0:	7b73      	ldrb	r3, [r6, #13]
	init_idle_thread(id);
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
	_kernel.cpus[id].id = id;
   46af2:	752c      	strb	r4, [r5, #20]
   46af4:	f023 0304 	bic.w	r3, r3, #4
   46af8:	7373      	strb	r3, [r6, #13]
	_kernel.cpus[id].irq_stack =
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
   46afa:	4b08      	ldr	r3, [pc, #32]	; (46b1c <z_init_cpu+0x64>)
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
   46afc:	60ee      	str	r6, [r5, #12]
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
   46afe:	3401      	adds	r4, #1
   46b00:	eb03 23c4 	add.w	r3, r3, r4, lsl #11
	_kernel.cpus[id].irq_stack =
   46b04:	606b      	str	r3, [r5, #4]
		 K_KERNEL_STACK_SIZEOF(z_interrupt_stacks[id]));
#ifdef CONFIG_SCHED_THREAD_USAGE_ALL
	_kernel.cpus[id].usage.track_usage =
		CONFIG_SCHED_THREAD_USAGE_AUTO_ENABLE;
#endif
}
   46b06:	b006      	add	sp, #24
   46b08:	bd70      	pop	{r4, r5, r6, pc}
   46b0a:	bf00      	nop
   46b0c:	20003578 	.word	0x20003578
   46b10:	2000694c 	.word	0x2000694c
   46b14:	200098a8 	.word	0x200098a8
   46b18:	00046e0d 	.word	0x00046e0d
   46b1c:	200090a8 	.word	0x200090a8

00046b20 <z_cstart>:
 *
 * @return Does not return
 */
__boot_func
FUNC_NORETURN void z_cstart(void)
{
   46b20:	b580      	push	{r7, lr}
 * pointer) register, and switched to automatically when taking an exception.
 *
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	uint32_t msp =
   46b22:	4b2e      	ldr	r3, [pc, #184]	; (46bdc <z_cstart+0xbc>)
   46b24:	b0a6      	sub	sp, #152	; 0x98
  \details Assigns the given value to the Main Stack Pointer (MSP).
  \param [in]    topOfMainStack  Main Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __set_MSP(uint32_t topOfMainStack)
{
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
   46b26:	f383 8808 	msr	MSP, r3
	 * for Cortex-M3 and Cortex-M4 (ARMv7-M) MCUs. For the rest
	 * of ARM Cortex-M processors this setting is enforced by
	 * default and it is not configurable.
	 */
#if defined(CONFIG_CPU_CORTEX_M3) || defined(CONFIG_CPU_CORTEX_M4)
	SCB->CCR |= SCB_CCR_STKALIGN_Msk;
   46b2a:	4d2d      	ldr	r5, [pc, #180]	; (46be0 <z_cstart+0xc0>)

#ifdef CONFIG_TIMESLICE_PER_THREAD
	dummy_thread->base.slice_ticks = 0;
#endif

	_current_cpu->current = dummy_thread;
   46b2c:	4e2d      	ldr	r6, [pc, #180]	; (46be4 <z_cstart+0xc4>)
   46b2e:	696b      	ldr	r3, [r5, #20]
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
   46b30:	4f2d      	ldr	r7, [pc, #180]	; (46be8 <z_cstart+0xc8>)
   46b32:	f443 7300 	orr.w	r3, r3, #512	; 0x200
   46b36:	616b      	str	r3, [r5, #20]
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   46b38:	2400      	movs	r4, #0
   46b3a:	23e0      	movs	r3, #224	; 0xe0
   46b3c:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
   46b40:	77ec      	strb	r4, [r5, #31]
   46b42:	762c      	strb	r4, [r5, #24]
   46b44:	766c      	strb	r4, [r5, #25]
   46b46:	76ac      	strb	r4, [r5, #26]
   46b48:	f885 4020 	strb.w	r4, [r5, #32]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
   46b4c:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   46b4e:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
   46b52:	626b      	str	r3, [r5, #36]	; 0x24
   46b54:	f885 4023 	strb.w	r4, [r5, #35]	; 0x23

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
   46b58:	f7e6 fb2e 	bl	2d1b8 <z_arm_fault_init>
	z_arm_cpu_idle_init();
   46b5c:	f7e6 f90c 	bl	2cd78 <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
   46b60:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   46b64:	62ab      	str	r3, [r5, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
   46b66:	62eb      	str	r3, [r5, #44]	; 0x2c
	k_thread_system_pool_assign(dummy_thread);
   46b68:	ad06      	add	r5, sp, #24
	z_arm_clear_faults();
#if defined(CONFIG_ARM_MPU)
	z_arm_mpu_init();
   46b6a:	f7e6 fbe1 	bl	2d330 <z_arm_mpu_init>
	 * to set up access permissions for fixed memory sections, such
	 * as Application Memory or No-Cacheable SRAM area.
	 *
	 * This function is invoked once, upon system initialization.
	 */
	z_arm_configure_static_mpu_regions();
   46b6e:	f7e6 fb6f 	bl	2d250 <z_arm_configure_static_mpu_regions>
	dummy_thread->base.user_options = K_ESSENTIAL;
   46b72:	f240 1301 	movw	r3, #257	; 0x101
	k_thread_system_pool_assign(dummy_thread);
   46b76:	4628      	mov	r0, r5
	dummy_thread->base.user_options = K_ESSENTIAL;
   46b78:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
	dummy_thread->stack_info.size = 0U;
   46b7c:	e9cd 4420 	strd	r4, r4, [sp, #128]	; 0x80
	k_thread_system_pool_assign(dummy_thread);
   46b80:	f001 fb34 	bl	481ec <k_thread_system_pool_assign>
	_current_cpu->current = dummy_thread;
   46b84:	60b5      	str	r5, [r6, #8]
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
   46b86:	f008 ff7d 	bl	4fa84 <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
   46b8a:	4620      	mov	r0, r4
   46b8c:	f7ff ff1c 	bl	469c8 <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
   46b90:	2001      	movs	r0, #1
	_kernel.ready_q.cache = &z_main_thread;
   46b92:	4d16      	ldr	r5, [pc, #88]	; (46bec <z_cstart+0xcc>)
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
   46b94:	f7ff ff18 	bl	469c8 <z_sys_init_run_level>
	z_sched_init();
   46b98:	f000 ff6c 	bl	47a74 <z_sched_init>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
   46b9c:	4b14      	ldr	r3, [pc, #80]	; (46bf0 <z_cstart+0xd0>)
	_kernel.ready_q.cache = &z_main_thread;
   46b9e:	61f5      	str	r5, [r6, #28]
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
   46ba0:	9305      	str	r3, [sp, #20]
   46ba2:	2301      	movs	r3, #1
   46ba4:	4913      	ldr	r1, [pc, #76]	; (46bf4 <z_cstart+0xd4>)
   46ba6:	9400      	str	r4, [sp, #0]
   46ba8:	e9cd 4303 	strd	r4, r3, [sp, #12]
   46bac:	f44f 6280 	mov.w	r2, #1024	; 0x400
   46bb0:	463b      	mov	r3, r7
   46bb2:	e9cd 4401 	strd	r4, r4, [sp, #4]
   46bb6:	4628      	mov	r0, r5
   46bb8:	f000 f870 	bl	46c9c <z_setup_new_thread>
   46bbc:	7b6a      	ldrb	r2, [r5, #13]
   46bbe:	4606      	mov	r6, r0
   46bc0:	f022 0204 	bic.w	r2, r2, #4
	z_ready_thread(&z_main_thread);
   46bc4:	4628      	mov	r0, r5
   46bc6:	736a      	strb	r2, [r5, #13]
   46bc8:	f009 fad4 	bl	50174 <z_ready_thread>
	z_init_cpu(0);
   46bcc:	4620      	mov	r0, r4
   46bce:	f7ff ff73 	bl	46ab8 <z_init_cpu>
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
   46bd2:	463a      	mov	r2, r7
   46bd4:	4631      	mov	r1, r6
   46bd6:	4628      	mov	r0, r5
   46bd8:	f7e6 f9d4 	bl	2cf84 <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
   46bdc:	200098a8 	.word	0x200098a8
   46be0:	e000ed00 	.word	0xe000ed00
   46be4:	2000694c 	.word	0x2000694c
   46be8:	00046a6d 	.word	0x00046a6d
   46bec:	200035f8 	.word	0x200035f8
   46bf0:	000538dd 	.word	0x000538dd
   46bf4:	200099e8 	.word	0x200099e8

00046bf8 <statics_init>:

	SYS_PORT_TRACING_OBJ_INIT(k_heap, h);
}

static int statics_init(const struct device *unused)
{
   46bf8:	b538      	push	{r3, r4, r5, lr}
	ARG_UNUSED(unused);
	STRUCT_SECTION_FOREACH(k_heap, h) {
   46bfa:	4c06      	ldr	r4, [pc, #24]	; (46c14 <statics_init+0x1c>)
   46bfc:	4d06      	ldr	r5, [pc, #24]	; (46c18 <statics_init+0x20>)
   46bfe:	42ac      	cmp	r4, r5
   46c00:	d301      	bcc.n	46c06 <statics_init+0xe>
		{
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
		}
	}
	return 0;
}
   46c02:	2000      	movs	r0, #0
   46c04:	bd38      	pop	{r3, r4, r5, pc}
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
   46c06:	e9d4 1201 	ldrd	r1, r2, [r4, #4]
   46c0a:	4620      	mov	r0, r4
   46c0c:	f008 ff70 	bl	4faf0 <k_heap_init>
	STRUCT_SECTION_FOREACH(k_heap, h) {
   46c10:	3414      	adds	r4, #20
   46c12:	e7f4      	b.n	46bfe <statics_init+0x6>
   46c14:	200010e0 	.word	0x200010e0
   46c18:	200010f4 	.word	0x200010f4

00046c1c <init_mem_slab_module>:
 * Perform any initialization that wasn't done at build time.
 *
 * @return 0 on success, fails otherwise.
 */
static int init_mem_slab_module(const struct device *dev)
{
   46c1c:	b538      	push	{r3, r4, r5, lr}
	int rc = 0;
	ARG_UNUSED(dev);

	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   46c1e:	4c06      	ldr	r4, [pc, #24]	; (46c38 <init_mem_slab_module+0x1c>)
   46c20:	4d06      	ldr	r5, [pc, #24]	; (46c3c <init_mem_slab_module+0x20>)
	int rc = 0;
   46c22:	2000      	movs	r0, #0
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   46c24:	42ac      	cmp	r4, r5
   46c26:	d300      	bcc.n	46c2a <init_mem_slab_module+0xe>
		z_object_init(slab);
	}

out:
	return rc;
}
   46c28:	bd38      	pop	{r3, r4, r5, pc}
		rc = create_free_list(slab);
   46c2a:	4620      	mov	r0, r4
   46c2c:	f008 ffd2 	bl	4fbd4 <create_free_list>
		if (rc < 0) {
   46c30:	2800      	cmp	r0, #0
   46c32:	dbf9      	blt.n	46c28 <init_mem_slab_module+0xc>
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   46c34:	341c      	adds	r4, #28
   46c36:	e7f5      	b.n	46c24 <init_mem_slab_module+0x8>
   46c38:	20001070 	.word	0x20001070
   46c3c:	200010e0 	.word	0x200010e0

00046c40 <k_mem_slab_alloc>:

	return rc;
}

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, k_timeout_t timeout)
{
   46c40:	b573      	push	{r0, r1, r4, r5, r6, lr}
   46c42:	460c      	mov	r4, r1
	__asm__ volatile(
   46c44:	f04f 0520 	mov.w	r5, #32
   46c48:	f3ef 8111 	mrs	r1, BASEPRI
   46c4c:	f385 8812 	msr	BASEPRI_MAX, r5
   46c50:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&slab->lock);
	int result;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, alloc, slab, timeout);

	if (slab->free_list != NULL) {
   46c54:	6945      	ldr	r5, [r0, #20]
   46c56:	b15d      	cbz	r5, 46c70 <k_mem_slab_alloc+0x30>
		/* take a free block */
		*mem = slab->free_list;
   46c58:	6025      	str	r5, [r4, #0]
		slab->free_list = *(char **)(slab->free_list);
   46c5a:	682b      	ldr	r3, [r5, #0]
   46c5c:	6143      	str	r3, [r0, #20]
		slab->num_used++;
   46c5e:	6983      	ldr	r3, [r0, #24]
   46c60:	3301      	adds	r3, #1
   46c62:	6183      	str	r3, [r0, #24]

#ifdef CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION
		slab->max_used = MAX(slab->num_used, slab->max_used);
#endif

		result = 0;
   46c64:	2000      	movs	r0, #0
	__asm__ volatile(
   46c66:	f381 8811 	msr	BASEPRI, r1
   46c6a:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, alloc, slab, timeout, result);

	k_spin_unlock(&slab->lock, key);

	return result;
   46c6e:	e011      	b.n	46c94 <k_mem_slab_alloc+0x54>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT) ||
   46c70:	ea52 0603 	orrs.w	r6, r2, r3
   46c74:	d103      	bne.n	46c7e <k_mem_slab_alloc+0x3e>
		*mem = NULL;
   46c76:	6025      	str	r5, [r4, #0]
		result = -ENOMEM;
   46c78:	f06f 000b 	mvn.w	r0, #11
   46c7c:	e7f3      	b.n	46c66 <k_mem_slab_alloc+0x26>
		result = z_pend_curr(&slab->lock, key, &slab->wait_q, timeout);
   46c7e:	e9cd 2300 	strd	r2, r3, [sp]
   46c82:	4602      	mov	r2, r0
   46c84:	3008      	adds	r0, #8
   46c86:	f000 fe09 	bl	4789c <z_pend_curr>
		if (result == 0) {
   46c8a:	b918      	cbnz	r0, 46c94 <k_mem_slab_alloc+0x54>
			*mem = _current->base.swap_data;
   46c8c:	4b02      	ldr	r3, [pc, #8]	; (46c98 <k_mem_slab_alloc+0x58>)
   46c8e:	689b      	ldr	r3, [r3, #8]
   46c90:	695b      	ldr	r3, [r3, #20]
   46c92:	6023      	str	r3, [r4, #0]
}
   46c94:	b002      	add	sp, #8
   46c96:	bd70      	pop	{r4, r5, r6, pc}
   46c98:	2000694c 	.word	0x2000694c

00046c9c <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
   46c9c:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
	thread_base->user_options = (uint8_t)options;
   46ca0:	9e0e      	ldr	r6, [sp, #56]	; 0x38
   46ca2:	7306      	strb	r6, [r0, #12]
	thread_base->thread_state = (uint8_t)initial_state;
   46ca4:	2604      	movs	r6, #4
   46ca6:	7346      	strb	r6, [r0, #13]

	thread_base->prio = priority;
   46ca8:	9e0d      	ldr	r6, [sp, #52]	; 0x34
   46caa:	7386      	strb	r6, [r0, #14]
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
   46cac:	f100 0558 	add.w	r5, r0, #88	; 0x58
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
   46cb0:	1dd6      	adds	r6, r2, #7
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
	list->tail = (sys_dnode_t *)list;
   46cb2:	e9c0 5516 	strd	r5, r5, [r0, #88]	; 0x58
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
   46cb6:	9a0c      	ldr	r2, [sp, #48]	; 0x30
	thread_base->pended_on = NULL;
   46cb8:	2500      	movs	r5, #0
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
   46cba:	f026 0607 	bic.w	r6, r6, #7
 */

static inline void sys_dnode_init(sys_dnode_t *node)
{
	node->next = NULL;
	node->prev = NULL;
   46cbe:	e9c0 5506 	strd	r5, r5, [r0, #24]
	new_thread->stack_info.size = stack_buf_size;
   46cc2:	e9c0 161a 	strd	r1, r6, [r0, #104]	; 0x68
	thread_base->pended_on = NULL;
   46cc6:	6085      	str	r5, [r0, #8]

	thread_base->sched_locked = 0U;
   46cc8:	73c5      	strb	r5, [r0, #15]
	new_thread->stack_info.delta = delta;
   46cca:	6705      	str	r5, [r0, #112]	; 0x70
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
   46ccc:	9202      	str	r2, [sp, #8]
   46cce:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   46cd0:	9201      	str	r2, [sp, #4]
	stack_ptr = (char *)stack + stack_obj_size;
   46cd2:	eb01 0806 	add.w	r8, r1, r6
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
   46cd6:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   46cd8:	9200      	str	r2, [sp, #0]
   46cda:	4642      	mov	r2, r8
{
   46cdc:	4604      	mov	r4, r0
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
   46cde:	f7e6 f935 	bl	2cf4c <arch_new_thread>
	if (!_current) {
   46ce2:	4b05      	ldr	r3, [pc, #20]	; (46cf8 <z_setup_new_thread+0x5c>)
	new_thread->init_data = NULL;
   46ce4:	6565      	str	r5, [r4, #84]	; 0x54
	if (!_current) {
   46ce6:	689b      	ldr	r3, [r3, #8]
   46ce8:	b103      	cbz	r3, 46cec <z_setup_new_thread+0x50>
	new_thread->resource_pool = _current->resource_pool;
   46cea:	6f5b      	ldr	r3, [r3, #116]	; 0x74
	return stack_ptr;
   46cec:	6763      	str	r3, [r4, #116]	; 0x74
}
   46cee:	4640      	mov	r0, r8
   46cf0:	b004      	add	sp, #16
   46cf2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   46cf6:	bf00      	nop
   46cf8:	2000694c 	.word	0x2000694c

00046cfc <z_impl_k_thread_create>:
{
   46cfc:	b5f0      	push	{r4, r5, r6, r7, lr}
   46cfe:	b087      	sub	sp, #28
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   46d00:	2500      	movs	r5, #0
   46d02:	9505      	str	r5, [sp, #20]
   46d04:	9d10      	ldr	r5, [sp, #64]	; 0x40
   46d06:	9504      	str	r5, [sp, #16]
   46d08:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
   46d0a:	9503      	str	r5, [sp, #12]
   46d0c:	9d0e      	ldr	r5, [sp, #56]	; 0x38
   46d0e:	9502      	str	r5, [sp, #8]
{
   46d10:	e9dd 7612 	ldrd	r7, r6, [sp, #72]	; 0x48
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   46d14:	9d0d      	ldr	r5, [sp, #52]	; 0x34
   46d16:	9501      	str	r5, [sp, #4]
   46d18:	9d0c      	ldr	r5, [sp, #48]	; 0x30
   46d1a:	9500      	str	r5, [sp, #0]
{
   46d1c:	4604      	mov	r4, r0
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   46d1e:	f7ff ffbd 	bl	46c9c <z_setup_new_thread>
	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
   46d22:	f1b6 3fff 	cmp.w	r6, #4294967295	; 0xffffffff
   46d26:	bf08      	it	eq
   46d28:	f1b7 3fff 	cmpeq.w	r7, #4294967295	; 0xffffffff
   46d2c:	d005      	beq.n	46d3a <z_impl_k_thread_create+0x3e>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   46d2e:	ea56 0307 	orrs.w	r3, r6, r7
   46d32:	d105      	bne.n	46d40 <z_impl_k_thread_create+0x44>
	z_sched_start(thread);
   46d34:	4620      	mov	r0, r4
   46d36:	f000 fe1d 	bl	47974 <z_sched_start>
}
   46d3a:	4620      	mov	r0, r4
   46d3c:	b007      	add	sp, #28
   46d3e:	bdf0      	pop	{r4, r5, r6, r7, pc}

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
   46d40:	4903      	ldr	r1, [pc, #12]	; (46d50 <z_impl_k_thread_create+0x54>)
   46d42:	463a      	mov	r2, r7
   46d44:	4633      	mov	r3, r6
   46d46:	f104 0018 	add.w	r0, r4, #24
   46d4a:	f001 f81b 	bl	47d84 <z_add_timeout>
   46d4e:	e7f4      	b.n	46d3a <z_impl_k_thread_create+0x3e>
   46d50:	000500e1 	.word	0x000500e1

00046d54 <z_init_static_threads>:
{
   46d54:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   46d58:	4c29      	ldr	r4, [pc, #164]	; (46e00 <z_init_static_threads+0xac>)
	_FOREACH_STATIC_THREAD(thread_data) {
   46d5a:	4d2a      	ldr	r5, [pc, #168]	; (46e04 <z_init_static_threads+0xb0>)
{
   46d5c:	b087      	sub	sp, #28
   46d5e:	4626      	mov	r6, r4
	_FOREACH_STATIC_THREAD(thread_data) {
   46d60:	42ae      	cmp	r6, r5
   46d62:	f104 0430 	add.w	r4, r4, #48	; 0x30
   46d66:	d30f      	bcc.n	46d88 <z_init_static_threads+0x34>
	k_sched_lock();
   46d68:	f000 fe54 	bl	47a14 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
   46d6c:	4c24      	ldr	r4, [pc, #144]	; (46e00 <z_init_static_threads+0xac>)
   46d6e:	f8df 9098 	ldr.w	r9, [pc, #152]	; 46e08 <z_init_static_threads+0xb4>
   46d72:	f44f 4600 	mov.w	r6, #32768	; 0x8000
   46d76:	f240 37e7 	movw	r7, #999	; 0x3e7
   46d7a:	42ac      	cmp	r4, r5
   46d7c:	d320      	bcc.n	46dc0 <z_init_static_threads+0x6c>
}
   46d7e:	b007      	add	sp, #28
   46d80:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
	k_sched_unlock();
   46d84:	f000 be5a 	b.w	47a3c <k_sched_unlock>
		z_setup_new_thread(
   46d88:	f854 3c04 	ldr.w	r3, [r4, #-4]
   46d8c:	9305      	str	r3, [sp, #20]
   46d8e:	f854 3c10 	ldr.w	r3, [r4, #-16]
   46d92:	9304      	str	r3, [sp, #16]
   46d94:	f854 3c14 	ldr.w	r3, [r4, #-20]
   46d98:	9303      	str	r3, [sp, #12]
   46d9a:	f854 3c18 	ldr.w	r3, [r4, #-24]
   46d9e:	9302      	str	r3, [sp, #8]
   46da0:	f854 3c1c 	ldr.w	r3, [r4, #-28]
   46da4:	9301      	str	r3, [sp, #4]
   46da6:	f854 3c20 	ldr.w	r3, [r4, #-32]
   46daa:	9300      	str	r3, [sp, #0]
   46dac:	e954 230a 	ldrd	r2, r3, [r4, #-40]	; 0x28
   46db0:	e954 010c 	ldrd	r0, r1, [r4, #-48]	; 0x30
   46db4:	f7ff ff72 	bl	46c9c <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
   46db8:	f854 3c30 	ldr.w	r3, [r4, #-48]
   46dbc:	655e      	str	r6, [r3, #84]	; 0x54
	_FOREACH_STATIC_THREAD(thread_data) {
   46dbe:	e7ce      	b.n	46d5e <z_init_static_threads+0xa>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
   46dc0:	6a63      	ldr	r3, [r4, #36]	; 0x24
   46dc2:	1c5a      	adds	r2, r3, #1
   46dc4:	d00d      	beq.n	46de2 <z_init_static_threads+0x8e>
					    K_MSEC(thread_data->init_delay));
   46dc6:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   46dca:	2100      	movs	r1, #0
   46dcc:	4638      	mov	r0, r7
   46dce:	fbc3 0106 	smlal	r0, r1, r3, r6
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   46dd2:	ea51 33c3 	orrs.w	r3, r1, r3, lsl #15
			schedule_new_thread(thread_data->init_thread,
   46dd6:	f8d4 8000 	ldr.w	r8, [r4]
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   46dda:	d104      	bne.n	46de6 <z_init_static_threads+0x92>
	z_sched_start(thread);
   46ddc:	4640      	mov	r0, r8
   46dde:	f000 fdc9 	bl	47974 <z_sched_start>
	_FOREACH_STATIC_THREAD(thread_data) {
   46de2:	3430      	adds	r4, #48	; 0x30
   46de4:	e7c9      	b.n	46d7a <z_init_static_threads+0x26>
   46de6:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   46dea:	2300      	movs	r3, #0
   46dec:	f7df f988 	bl	26100 <__aeabi_uldivmod>
   46df0:	4602      	mov	r2, r0
   46df2:	460b      	mov	r3, r1
   46df4:	f108 0018 	add.w	r0, r8, #24
   46df8:	4649      	mov	r1, r9
   46dfa:	f000 ffc3 	bl	47d84 <z_add_timeout>
   46dfe:	e7f0      	b.n	46de2 <z_init_static_threads+0x8e>
   46e00:	20000ffc 	.word	0x20000ffc
   46e04:	20000ffc 	.word	0x20000ffc
   46e08:	000500e1 	.word	0x000500e1

00046e0c <idle>:
#endif	/* CONFIG_PM */
	sys_clock_idle_exit();
}

void idle(void *unused1, void *unused2, void *unused3)
{
   46e0c:	b508      	push	{r3, lr}
		 * higher level construct.
		 */
		(void) arch_irq_lock();

#ifdef CONFIG_PM
		_kernel.idle = z_get_next_timeout_expiry();
   46e0e:	4c0b      	ldr	r4, [pc, #44]	; (46e3c <idle+0x30>)
	return !z_sys_post_kernel;
   46e10:	4d0b      	ldr	r5, [pc, #44]	; (46e40 <idle+0x34>)
	__asm__ volatile(
   46e12:	f04f 0220 	mov.w	r2, #32
   46e16:	f3ef 8311 	mrs	r3, BASEPRI
   46e1a:	f382 8812 	msr	BASEPRI_MAX, r2
   46e1e:	f3bf 8f6f 	isb	sy
   46e22:	f009 fa6d 	bl	50300 <z_get_next_timeout_expiry>
		 * processing in those cases i.e. skips k_cpu_idle().
		 * The kernel's idle processing re-enables interrupts
		 * which is essential for the kernel's scheduling
		 * logic.
		 */
		if (k_is_pre_kernel() || !pm_system_suspend(_kernel.idle)) {
   46e26:	782b      	ldrb	r3, [r5, #0]
		_kernel.idle = z_get_next_timeout_expiry();
   46e28:	61a0      	str	r0, [r4, #24]
		if (k_is_pre_kernel() || !pm_system_suspend(_kernel.idle)) {
   46e2a:	b913      	cbnz	r3, 46e32 <idle+0x26>
	arch_cpu_idle();
   46e2c:	f7e5 ffaa 	bl	2cd84 <arch_cpu_idle>
}
   46e30:	e7ef      	b.n	46e12 <idle+0x6>
   46e32:	f7e5 fdad 	bl	2c990 <pm_system_suspend>
   46e36:	2800      	cmp	r0, #0
   46e38:	d1eb      	bne.n	46e12 <idle+0x6>
   46e3a:	e7f7      	b.n	46e2c <idle+0x20>
   46e3c:	2000694c 	.word	0x2000694c
   46e40:	20006bc4 	.word	0x20006bc4

00046e44 <z_impl_k_msgq_put>:
	return 0;
}


int z_impl_k_msgq_put(struct k_msgq *msgq, const void *data, k_timeout_t timeout)
{
   46e44:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   46e48:	4604      	mov	r4, r0
   46e4a:	460e      	mov	r6, r1

	struct k_thread *pending_thread;
	k_spinlock_key_t key;
	int result;

	key = k_spin_lock(&msgq->lock);
   46e4c:	f100 0808 	add.w	r8, r0, #8
   46e50:	f04f 0120 	mov.w	r1, #32
   46e54:	f3ef 8711 	mrs	r7, BASEPRI
   46e58:	f381 8812 	msr	BASEPRI_MAX, r1
   46e5c:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, put, msgq, timeout);

	if (msgq->used_msgs < msgq->max_msgs) {
   46e60:	6a05      	ldr	r5, [r0, #32]
   46e62:	68c1      	ldr	r1, [r0, #12]
   46e64:	428d      	cmp	r5, r1
   46e66:	d22f      	bcs.n	46ec8 <z_impl_k_msgq_put+0x84>
		/* message queue isn't full */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
   46e68:	f009 f9bb 	bl	501e2 <z_unpend_first_thread>
		if (pending_thread != NULL) {
			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, put, msgq, timeout, 0);

			/* give message to waiting thread */
			(void)memcpy(pending_thread->base.swap_data, data,
   46e6c:	68a2      	ldr	r2, [r4, #8]
		if (pending_thread != NULL) {
   46e6e:	4605      	mov	r5, r0
			(void)memcpy(pending_thread->base.swap_data, data,
   46e70:	4631      	mov	r1, r6
		if (pending_thread != NULL) {
   46e72:	b178      	cbz	r0, 46e94 <z_impl_k_msgq_put+0x50>
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
   46e74:	2400      	movs	r4, #0
			(void)memcpy(pending_thread->base.swap_data, data,
   46e76:	6940      	ldr	r0, [r0, #20]
   46e78:	f003 ffff 	bl	4ae7a <memcpy>
			       msgq->msg_size);
			/* wake up waiting thread */
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
   46e7c:	4628      	mov	r0, r5
   46e7e:	67ec      	str	r4, [r5, #124]	; 0x7c
   46e80:	f009 f978 	bl	50174 <z_ready_thread>
			z_reschedule(&msgq->lock, key);
   46e84:	4640      	mov	r0, r8
   46e86:	4639      	mov	r1, r7
   46e88:	f000 fd62 	bl	47950 <z_reschedule>
			return 0;
   46e8c:	4620      	mov	r0, r4
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, put, msgq, timeout, result);

	k_spin_unlock(&msgq->lock, key);

	return result;
}
   46e8e:	b002      	add	sp, #8
   46e90:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			(void)memcpy(msgq->write_ptr, data, msgq->msg_size);
   46e94:	69e0      	ldr	r0, [r4, #28]
   46e96:	f003 fff0 	bl	4ae7a <memcpy>
			msgq->write_ptr += msgq->msg_size;
   46e9a:	69e3      	ldr	r3, [r4, #28]
   46e9c:	68a2      	ldr	r2, [r4, #8]
   46e9e:	4413      	add	r3, r2
			if (msgq->write_ptr == msgq->buffer_end) {
   46ea0:	6962      	ldr	r2, [r4, #20]
			msgq->write_ptr += msgq->msg_size;
   46ea2:	61e3      	str	r3, [r4, #28]
			if (msgq->write_ptr == msgq->buffer_end) {
   46ea4:	4293      	cmp	r3, r2
				msgq->write_ptr = msgq->buffer_start;
   46ea6:	bf04      	itt	eq
   46ea8:	6923      	ldreq	r3, [r4, #16]
   46eaa:	61e3      	streq	r3, [r4, #28]
			msgq->used_msgs++;
   46eac:	6a23      	ldr	r3, [r4, #32]
   46eae:	3301      	adds	r3, #1
	z_handle_obj_poll_events(&msgq->poll_events, state);
   46eb0:	f104 0024 	add.w	r0, r4, #36	; 0x24
			msgq->used_msgs++;
   46eb4:	6223      	str	r3, [r4, #32]
	z_handle_obj_poll_events(&msgq->poll_events, state);
   46eb6:	2110      	movs	r1, #16
   46eb8:	f009 fbd7 	bl	5066a <z_handle_obj_poll_events>
		result = 0;
   46ebc:	2000      	movs	r0, #0
	__asm__ volatile(
   46ebe:	f387 8811 	msr	BASEPRI, r7
   46ec2:	f3bf 8f6f 	isb	sy
	return result;
   46ec6:	e7e2      	b.n	46e8e <z_impl_k_msgq_put+0x4a>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   46ec8:	ea52 0103 	orrs.w	r1, r2, r3
   46ecc:	d00a      	beq.n	46ee4 <z_impl_k_msgq_put+0xa0>
		_current->base.swap_data = (void *) data;
   46ece:	4907      	ldr	r1, [pc, #28]	; (46eec <z_impl_k_msgq_put+0xa8>)
   46ed0:	6889      	ldr	r1, [r1, #8]
   46ed2:	614e      	str	r6, [r1, #20]
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   46ed4:	e9cd 2300 	strd	r2, r3, [sp]
   46ed8:	4639      	mov	r1, r7
   46eda:	4602      	mov	r2, r0
   46edc:	4640      	mov	r0, r8
   46ede:	f000 fcdd 	bl	4789c <z_pend_curr>
		return result;
   46ee2:	e7d4      	b.n	46e8e <z_impl_k_msgq_put+0x4a>
		result = -ENOMSG;
   46ee4:	f06f 0022 	mvn.w	r0, #34	; 0x22
   46ee8:	e7e9      	b.n	46ebe <z_impl_k_msgq_put+0x7a>
   46eea:	bf00      	nop
   46eec:	2000694c 	.word	0x2000694c

00046ef0 <z_impl_k_msgq_get>:
}
#include <syscalls/k_msgq_get_attrs_mrsh.c>
#endif

int z_impl_k_msgq_get(struct k_msgq *msgq, void *data, k_timeout_t timeout)
{
   46ef0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   46ef2:	4604      	mov	r4, r0

	k_spinlock_key_t key;
	struct k_thread *pending_thread;
	int result;

	key = k_spin_lock(&msgq->lock);
   46ef4:	f104 0708 	add.w	r7, r4, #8
{
   46ef8:	4608      	mov	r0, r1
	__asm__ volatile(
   46efa:	f04f 0120 	mov.w	r1, #32
   46efe:	f3ef 8611 	mrs	r6, BASEPRI
   46f02:	f381 8812 	msr	BASEPRI_MAX, r1
   46f06:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, get, msgq, timeout);

	if (msgq->used_msgs > 0U) {
   46f0a:	6a21      	ldr	r1, [r4, #32]
   46f0c:	2900      	cmp	r1, #0
   46f0e:	d031      	beq.n	46f74 <z_impl_k_msgq_get+0x84>
		/* take first available message from queue */
		(void)memcpy(data, msgq->read_ptr, msgq->msg_size);
   46f10:	68a2      	ldr	r2, [r4, #8]
   46f12:	69a1      	ldr	r1, [r4, #24]
   46f14:	f003 ffb1 	bl	4ae7a <memcpy>
		msgq->read_ptr += msgq->msg_size;
   46f18:	69a3      	ldr	r3, [r4, #24]
   46f1a:	68a2      	ldr	r2, [r4, #8]
   46f1c:	4413      	add	r3, r2
		if (msgq->read_ptr == msgq->buffer_end) {
   46f1e:	6962      	ldr	r2, [r4, #20]
		msgq->read_ptr += msgq->msg_size;
   46f20:	61a3      	str	r3, [r4, #24]
		if (msgq->read_ptr == msgq->buffer_end) {
   46f22:	4293      	cmp	r3, r2
			msgq->read_ptr = msgq->buffer_start;
   46f24:	bf04      	itt	eq
   46f26:	6923      	ldreq	r3, [r4, #16]
   46f28:	61a3      	streq	r3, [r4, #24]
		}
		msgq->used_msgs--;
   46f2a:	6a23      	ldr	r3, [r4, #32]
   46f2c:	3b01      	subs	r3, #1
   46f2e:	6223      	str	r3, [r4, #32]

		/* handle first thread waiting to write (if any) */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
   46f30:	4620      	mov	r0, r4
   46f32:	f009 f956 	bl	501e2 <z_unpend_first_thread>
		if (pending_thread != NULL) {
   46f36:	4605      	mov	r5, r0
   46f38:	b360      	cbz	r0, 46f94 <z_impl_k_msgq_get+0xa4>
			SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_msgq, get, msgq, timeout);

			/* add thread's message to queue */
			(void)memcpy(msgq->write_ptr, pending_thread->base.swap_data,
   46f3a:	6941      	ldr	r1, [r0, #20]
   46f3c:	68a2      	ldr	r2, [r4, #8]
   46f3e:	69e0      	ldr	r0, [r4, #28]
   46f40:	f003 ff9b 	bl	4ae7a <memcpy>
			       msgq->msg_size);
			msgq->write_ptr += msgq->msg_size;
   46f44:	69e3      	ldr	r3, [r4, #28]
   46f46:	68a2      	ldr	r2, [r4, #8]
   46f48:	4413      	add	r3, r2
			if (msgq->write_ptr == msgq->buffer_end) {
   46f4a:	6962      	ldr	r2, [r4, #20]
			msgq->write_ptr += msgq->msg_size;
   46f4c:	61e3      	str	r3, [r4, #28]
			if (msgq->write_ptr == msgq->buffer_end) {
   46f4e:	4293      	cmp	r3, r2
				msgq->write_ptr = msgq->buffer_start;
   46f50:	bf04      	itt	eq
   46f52:	6923      	ldreq	r3, [r4, #16]
   46f54:	61e3      	streq	r3, [r4, #28]
			}
			msgq->used_msgs++;
   46f56:	6a23      	ldr	r3, [r4, #32]
   46f58:	3301      	adds	r3, #1
   46f5a:	6223      	str	r3, [r4, #32]
   46f5c:	2400      	movs	r4, #0

			/* wake up waiting thread */
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
   46f5e:	4628      	mov	r0, r5
   46f60:	67ec      	str	r4, [r5, #124]	; 0x7c
   46f62:	f009 f907 	bl	50174 <z_ready_thread>
			z_reschedule(&msgq->lock, key);
   46f66:	4638      	mov	r0, r7
   46f68:	4631      	mov	r1, r6
   46f6a:	f000 fcf1 	bl	47950 <z_reschedule>

			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, get, msgq, timeout, 0);

			return 0;
   46f6e:	4620      	mov	r0, r4
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, get, msgq, timeout, result);

	k_spin_unlock(&msgq->lock, key);

	return result;
}
   46f70:	b003      	add	sp, #12
   46f72:	bdf0      	pop	{r4, r5, r6, r7, pc}
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   46f74:	ea52 0103 	orrs.w	r1, r2, r3
   46f78:	d00a      	beq.n	46f90 <z_impl_k_msgq_get+0xa0>
		_current->base.swap_data = data;
   46f7a:	4909      	ldr	r1, [pc, #36]	; (46fa0 <z_impl_k_msgq_get+0xb0>)
   46f7c:	6889      	ldr	r1, [r1, #8]
   46f7e:	6148      	str	r0, [r1, #20]
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   46f80:	e9cd 2300 	strd	r2, r3, [sp]
   46f84:	4631      	mov	r1, r6
   46f86:	4622      	mov	r2, r4
   46f88:	4638      	mov	r0, r7
   46f8a:	f000 fc87 	bl	4789c <z_pend_curr>
		return result;
   46f8e:	e7ef      	b.n	46f70 <z_impl_k_msgq_get+0x80>
		result = -ENOMSG;
   46f90:	f06f 0022 	mvn.w	r0, #34	; 0x22
	__asm__ volatile(
   46f94:	f386 8811 	msr	BASEPRI, r6
   46f98:	f3bf 8f6f 	isb	sy
	return result;
   46f9c:	e7e8      	b.n	46f70 <z_impl_k_msgq_get+0x80>
   46f9e:	bf00      	nop
   46fa0:	2000694c 	.word	0x2000694c

00046fa4 <z_impl_k_mutex_lock>:
	}
	return false;
}

int z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)
{
   46fa4:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   46fa8:	4604      	mov	r4, r0
   46faa:	4617      	mov	r7, r2
   46fac:	461e      	mov	r6, r3
	__asm__ volatile(
   46fae:	f04f 0320 	mov.w	r3, #32
   46fb2:	f3ef 8811 	mrs	r8, BASEPRI
   46fb6:	f383 8812 	msr	BASEPRI_MAX, r3
   46fba:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, lock, mutex, timeout);

	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
   46fbe:	68c3      	ldr	r3, [r0, #12]
   46fc0:	4a33      	ldr	r2, [pc, #204]	; (47090 <z_impl_k_mutex_lock+0xec>)
   46fc2:	b17b      	cbz	r3, 46fe4 <z_impl_k_mutex_lock+0x40>
   46fc4:	6880      	ldr	r0, [r0, #8]
   46fc6:	6891      	ldr	r1, [r2, #8]
   46fc8:	4288      	cmp	r0, r1
   46fca:	d019      	beq.n	47000 <z_impl_k_mutex_lock+0x5c>
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, 0);

		return 0;
	}

	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
   46fcc:	ea57 0306 	orrs.w	r3, r7, r6
   46fd0:	d118      	bne.n	47004 <z_impl_k_mutex_lock+0x60>
	__asm__ volatile(
   46fd2:	f388 8811 	msr	BASEPRI, r8
   46fd6:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EBUSY);

		return -EBUSY;
   46fda:	f06f 000f 	mvn.w	r0, #15
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EAGAIN);

	return -EAGAIN;
}
   46fde:	b002      	add	sp, #8
   46fe0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
					_current->base.prio :
   46fe4:	6891      	ldr	r1, [r2, #8]
   46fe6:	f991 100e 	ldrsb.w	r1, [r1, #14]
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
   46fea:	6121      	str	r1, [r4, #16]
		mutex->lock_count++;
   46fec:	3301      	adds	r3, #1
   46fee:	60e3      	str	r3, [r4, #12]
		mutex->owner = _current;
   46ff0:	6893      	ldr	r3, [r2, #8]
   46ff2:	60a3      	str	r3, [r4, #8]
   46ff4:	f388 8811 	msr	BASEPRI, r8
   46ff8:	f3bf 8f6f 	isb	sy
		return 0;
   46ffc:	2000      	movs	r0, #0
   46ffe:	e7ee      	b.n	46fde <z_impl_k_mutex_lock+0x3a>
					_current->base.prio :
   47000:	6921      	ldr	r1, [r4, #16]
   47002:	e7f2      	b.n	46fea <z_impl_k_mutex_lock+0x46>
	new_prio = new_prio_for_inheritance(_current->base.prio,
   47004:	f991 100e 	ldrsb.w	r1, [r1, #14]
   47008:	f990 300e 	ldrsb.w	r3, [r0, #14]
	return prio >= CONFIG_PRIORITY_CEILING;
}

static inline int z_get_new_prio_with_ceiling(int prio)
{
	return z_is_under_prio_ceiling(prio) ? prio : CONFIG_PRIORITY_CEILING;
   4700c:	4299      	cmp	r1, r3
   4700e:	bfa8      	it	ge
   47010:	4619      	movge	r1, r3
   47012:	f06f 027e 	mvn.w	r2, #126	; 0x7e
   47016:	4291      	cmp	r1, r2
   47018:	bfb8      	it	lt
   4701a:	4611      	movlt	r1, r2
	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
   4701c:	428b      	cmp	r3, r1
   4701e:	dd2e      	ble.n	4707e <z_impl_k_mutex_lock+0xda>
		resched = adjust_owner_prio(mutex, new_prio);
   47020:	f008 fe29 	bl	4fc76 <adjust_owner_prio.isra.0>
   47024:	4605      	mov	r5, r0
	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
   47026:	e9cd 7600 	strd	r7, r6, [sp]
   4702a:	481a      	ldr	r0, [pc, #104]	; (47094 <z_impl_k_mutex_lock+0xf0>)
   4702c:	4622      	mov	r2, r4
   4702e:	4641      	mov	r1, r8
   47030:	f000 fc34 	bl	4789c <z_pend_curr>
	if (got_mutex == 0) {
   47034:	2800      	cmp	r0, #0
   47036:	d0e1      	beq.n	46ffc <z_impl_k_mutex_lock+0x58>
	__asm__ volatile(
   47038:	f04f 0320 	mov.w	r3, #32
   4703c:	f3ef 8611 	mrs	r6, BASEPRI
   47040:	f383 8812 	msr	BASEPRI_MAX, r3
   47044:	f3bf 8f6f 	isb	sy
	if (likely(mutex->owner != NULL)) {
   47048:	68a0      	ldr	r0, [r4, #8]
   4704a:	b1d0      	cbz	r0, 47082 <z_impl_k_mutex_lock+0xde>
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
   4704c:	6823      	ldr	r3, [r4, #0]
			new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
   4704e:	6921      	ldr	r1, [r4, #16]
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
   47050:	429c      	cmp	r4, r3
   47052:	d00a      	beq.n	4706a <z_impl_k_mutex_lock+0xc6>
   47054:	b14b      	cbz	r3, 4706a <z_impl_k_mutex_lock+0xc6>
   47056:	f993 300e 	ldrsb.w	r3, [r3, #14]
   4705a:	4299      	cmp	r1, r3
   4705c:	bfa8      	it	ge
   4705e:	4619      	movge	r1, r3
   47060:	f06f 037e 	mvn.w	r3, #126	; 0x7e
   47064:	4299      	cmp	r1, r3
   47066:	bfb8      	it	lt
   47068:	4619      	movlt	r1, r3
		resched = adjust_owner_prio(mutex, new_prio) || resched;
   4706a:	f008 fe04 	bl	4fc76 <adjust_owner_prio.isra.0>
   4706e:	b140      	cbz	r0, 47082 <z_impl_k_mutex_lock+0xde>
		z_reschedule(&lock, key);
   47070:	4808      	ldr	r0, [pc, #32]	; (47094 <z_impl_k_mutex_lock+0xf0>)
   47072:	4631      	mov	r1, r6
   47074:	f000 fc6c 	bl	47950 <z_reschedule>
	return -EAGAIN;
   47078:	f06f 000a 	mvn.w	r0, #10
   4707c:	e7af      	b.n	46fde <z_impl_k_mutex_lock+0x3a>
	bool resched = false;
   4707e:	2500      	movs	r5, #0
   47080:	e7d1      	b.n	47026 <z_impl_k_mutex_lock+0x82>
	if (resched) {
   47082:	2d00      	cmp	r5, #0
   47084:	d1f4      	bne.n	47070 <z_impl_k_mutex_lock+0xcc>
	__asm__ volatile(
   47086:	f386 8811 	msr	BASEPRI, r6
   4708a:	f3bf 8f6f 	isb	sy
   4708e:	e7f3      	b.n	47078 <z_impl_k_mutex_lock+0xd4>
   47090:	2000694c 	.word	0x2000694c
   47094:	20006bc5 	.word	0x20006bc5

00047098 <z_impl_k_mutex_unlock>:
}
#include <syscalls/k_mutex_lock_mrsh.c>
#endif

int z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
   47098:	b538      	push	{r3, r4, r5, lr}

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, unlock, mutex);

	CHECKIF(mutex->owner == NULL) {
   4709a:	6883      	ldr	r3, [r0, #8]
{
   4709c:	4604      	mov	r4, r0
	CHECKIF(mutex->owner == NULL) {
   4709e:	b36b      	cbz	r3, 470fc <z_impl_k_mutex_unlock+0x64>
		return -EINVAL;
	}
	/*
	 * The current thread does not own the mutex.
	 */
	CHECKIF(mutex->owner != _current) {
   470a0:	4a19      	ldr	r2, [pc, #100]	; (47108 <z_impl_k_mutex_unlock+0x70>)
   470a2:	6892      	ldr	r2, [r2, #8]
   470a4:	4293      	cmp	r3, r2
   470a6:	d12c      	bne.n	47102 <z_impl_k_mutex_unlock+0x6a>

	/*
	 * If we are the owner and count is greater than 1, then decrement
	 * the count and return and keep current thread as the owner.
	 */
	if (mutex->lock_count > 1U) {
   470a8:	68c3      	ldr	r3, [r0, #12]
   470aa:	2b01      	cmp	r3, #1
   470ac:	d903      	bls.n	470b6 <z_impl_k_mutex_unlock+0x1e>
		mutex->lock_count--;
   470ae:	3b01      	subs	r3, #1
   470b0:	60c3      	str	r3, [r0, #12]


k_mutex_unlock_return:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, 0);

	return 0;
   470b2:	2000      	movs	r0, #0
}
   470b4:	bd38      	pop	{r3, r4, r5, pc}
	__asm__ volatile(
   470b6:	f04f 0320 	mov.w	r3, #32
   470ba:	f3ef 8511 	mrs	r5, BASEPRI
   470be:	f383 8812 	msr	BASEPRI_MAX, r3
   470c2:	f3bf 8f6f 	isb	sy
	adjust_owner_prio(mutex, mutex->owner_orig_prio);
   470c6:	6901      	ldr	r1, [r0, #16]
   470c8:	6880      	ldr	r0, [r0, #8]
   470ca:	f008 fdd4 	bl	4fc76 <adjust_owner_prio.isra.0>
	new_owner = z_unpend_first_thread(&mutex->wait_q);
   470ce:	4620      	mov	r0, r4
   470d0:	f009 f887 	bl	501e2 <z_unpend_first_thread>
	mutex->owner = new_owner;
   470d4:	60a0      	str	r0, [r4, #8]
	if (new_owner != NULL) {
   470d6:	b158      	cbz	r0, 470f0 <z_impl_k_mutex_unlock+0x58>
		mutex->owner_orig_prio = new_owner->base.prio;
   470d8:	f990 200e 	ldrsb.w	r2, [r0, #14]
   470dc:	6122      	str	r2, [r4, #16]
   470de:	2200      	movs	r2, #0
   470e0:	67c2      	str	r2, [r0, #124]	; 0x7c
		z_ready_thread(new_owner);
   470e2:	f009 f847 	bl	50174 <z_ready_thread>
		z_reschedule(&lock, key);
   470e6:	4809      	ldr	r0, [pc, #36]	; (4710c <z_impl_k_mutex_unlock+0x74>)
   470e8:	4629      	mov	r1, r5
   470ea:	f000 fc31 	bl	47950 <z_reschedule>
   470ee:	e7e0      	b.n	470b2 <z_impl_k_mutex_unlock+0x1a>
		mutex->lock_count = 0U;
   470f0:	60e0      	str	r0, [r4, #12]
	__asm__ volatile(
   470f2:	f385 8811 	msr	BASEPRI, r5
   470f6:	f3bf 8f6f 	isb	sy
   470fa:	e7da      	b.n	470b2 <z_impl_k_mutex_unlock+0x1a>
		return -EINVAL;
   470fc:	f06f 0015 	mvn.w	r0, #21
   47100:	e7d8      	b.n	470b4 <z_impl_k_mutex_unlock+0x1c>
		return -EPERM;
   47102:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   47106:	e7d5      	b.n	470b4 <z_impl_k_mutex_unlock+0x1c>
   47108:	2000694c 	.word	0x2000694c
   4710c:	20006bc5 	.word	0x20006bc5

00047110 <z_impl_k_queue_get>:

	return 0;
}

void *z_impl_k_queue_get(struct k_queue *queue, k_timeout_t timeout)
{
   47110:	b537      	push	{r0, r1, r2, r4, r5, lr}
   47112:	4611      	mov	r1, r2
	__asm__ volatile(
   47114:	f04f 0220 	mov.w	r2, #32
   47118:	f3ef 8511 	mrs	r5, BASEPRI
   4711c:	f382 8812 	msr	BASEPRI_MAX, r2
   47120:	f3bf 8f6f 	isb	sy
   47124:	6804      	ldr	r4, [r0, #0]
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
	void *data;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, get, queue, timeout);

	if (likely(!sys_sflist_is_empty(&queue->data_q))) {
   47126:	b19c      	cbz	r4, 47150 <z_impl_k_queue_get+0x40>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   47128:	6823      	ldr	r3, [r4, #0]
 *
 * @return A pointer to the first node of the list
 */
static inline sys_sfnode_t *sys_sflist_get_not_empty(sys_sflist_t *list);

Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   4712a:	6842      	ldr	r2, [r0, #4]
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   4712c:	f023 0303 	bic.w	r3, r3, #3
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   47130:	4294      	cmp	r4, r2
	list->head = node;
   47132:	6003      	str	r3, [r0, #0]
	list->tail = node;
   47134:	bf08      	it	eq
   47136:	6043      	streq	r3, [r0, #4]
		sys_sfnode_t *node;

		node = sys_sflist_get_not_empty(&queue->data_q);
		data = z_queue_node_peek(node, true);
   47138:	2101      	movs	r1, #1
   4713a:	4620      	mov	r0, r4
   4713c:	f008 fe10 	bl	4fd60 <z_queue_node_peek>
   47140:	4604      	mov	r4, r0
	__asm__ volatile(
   47142:	f385 8811 	msr	BASEPRI, r5
   47146:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, get, queue, timeout,
		(ret != 0) ? NULL : _current->base.swap_data);

	return (ret != 0) ? NULL : _current->base.swap_data;
}
   4714a:	4620      	mov	r0, r4
   4714c:	b003      	add	sp, #12
   4714e:	bd30      	pop	{r4, r5, pc}
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   47150:	ea51 0203 	orrs.w	r2, r1, r3
   47154:	d0f5      	beq.n	47142 <z_impl_k_queue_get+0x32>
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   47156:	f100 0208 	add.w	r2, r0, #8
	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);
   4715a:	e9cd 1300 	strd	r1, r3, [sp]
   4715e:	4610      	mov	r0, r2
   47160:	4629      	mov	r1, r5
   47162:	f000 fb9b 	bl	4789c <z_pend_curr>
	return (ret != 0) ? NULL : _current->base.swap_data;
   47166:	2800      	cmp	r0, #0
   47168:	d1ef      	bne.n	4714a <z_impl_k_queue_get+0x3a>
   4716a:	4b02      	ldr	r3, [pc, #8]	; (47174 <z_impl_k_queue_get+0x64>)
   4716c:	689b      	ldr	r3, [r3, #8]
   4716e:	695c      	ldr	r4, [r3, #20]
   47170:	e7eb      	b.n	4714a <z_impl_k_queue_get+0x3a>
   47172:	bf00      	nop
   47174:	2000694c 	.word	0x2000694c

00047178 <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
   47178:	b538      	push	{r3, r4, r5, lr}
   4717a:	4604      	mov	r4, r0
	__asm__ volatile(
   4717c:	f04f 0320 	mov.w	r3, #32
   47180:	f3ef 8511 	mrs	r5, BASEPRI
   47184:	f383 8812 	msr	BASEPRI_MAX, r3
   47188:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, give, sem);

	thread = z_unpend_first_thread(&sem->wait_q);
   4718c:	f009 f829 	bl	501e2 <z_unpend_first_thread>

	if (thread != NULL) {
   47190:	b148      	cbz	r0, 471a6 <z_impl_k_sem_give+0x2e>
   47192:	2200      	movs	r2, #0
   47194:	67c2      	str	r2, [r0, #124]	; 0x7c
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
   47196:	f008 ffed 	bl	50174 <z_ready_thread>
	} else {
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		handle_poll_events(sem);
	}

	z_reschedule(&lock, key);
   4719a:	4629      	mov	r1, r5
   4719c:	4808      	ldr	r0, [pc, #32]	; (471c0 <z_impl_k_sem_give+0x48>)

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, give, sem);
}
   4719e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule(&lock, key);
   471a2:	f000 bbd5 	b.w	47950 <z_reschedule>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
   471a6:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
   471aa:	429a      	cmp	r2, r3
   471ac:	bf18      	it	ne
   471ae:	3301      	addne	r3, #1
   471b0:	60a3      	str	r3, [r4, #8]
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
   471b2:	2102      	movs	r1, #2
   471b4:	f104 0010 	add.w	r0, r4, #16
   471b8:	f009 fa57 	bl	5066a <z_handle_obj_poll_events>
}
   471bc:	e7ed      	b.n	4719a <z_impl_k_sem_give+0x22>
   471be:	bf00      	nop
   471c0:	20006bc5 	.word	0x20006bc5

000471c4 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
   471c4:	b513      	push	{r0, r1, r4, lr}
   471c6:	f04f 0420 	mov.w	r4, #32
   471ca:	f3ef 8111 	mrs	r1, BASEPRI
   471ce:	f384 8812 	msr	BASEPRI_MAX, r4
   471d2:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, take, sem, timeout);

	if (likely(sem->count > 0U)) {
   471d6:	6884      	ldr	r4, [r0, #8]
   471d8:	b144      	cbz	r4, 471ec <z_impl_k_sem_take+0x28>
		sem->count--;
   471da:	3c01      	subs	r4, #1
   471dc:	6084      	str	r4, [r0, #8]
	__asm__ volatile(
   471de:	f381 8811 	msr	BASEPRI, r1
   471e2:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		ret = 0;
   471e6:	2000      	movs	r0, #0

out:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, take, sem, timeout, ret);

	return ret;
}
   471e8:	b002      	add	sp, #8
   471ea:	bd10      	pop	{r4, pc}
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   471ec:	ea52 0403 	orrs.w	r4, r2, r3
   471f0:	d106      	bne.n	47200 <z_impl_k_sem_take+0x3c>
   471f2:	f381 8811 	msr	BASEPRI, r1
   471f6:	f3bf 8f6f 	isb	sy
		ret = -EBUSY;
   471fa:	f06f 000f 	mvn.w	r0, #15
   471fe:	e7f3      	b.n	471e8 <z_impl_k_sem_take+0x24>
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
   47200:	e9cd 2300 	strd	r2, r3, [sp]
   47204:	4602      	mov	r2, r0
   47206:	4802      	ldr	r0, [pc, #8]	; (47210 <z_impl_k_sem_take+0x4c>)
   47208:	f000 fb48 	bl	4789c <z_pend_curr>
	return ret;
   4720c:	e7ec      	b.n	471e8 <z_impl_k_sem_take+0x24>
   4720e:	bf00      	nop
   47210:	20006bc5 	.word	0x20006bc5

00047214 <z_impl_k_sem_reset>:

void z_impl_k_sem_reset(struct k_sem *sem)
{
   47214:	b570      	push	{r4, r5, r6, lr}
   47216:	4604      	mov	r4, r0
	__asm__ volatile(
   47218:	f04f 0320 	mov.w	r3, #32
   4721c:	f3ef 8511 	mrs	r5, BASEPRI
   47220:	f383 8812 	msr	BASEPRI_MAX, r3
   47224:	f3bf 8f6f 	isb	sy
   47228:	f06f 060a 	mvn.w	r6, #10
	struct k_thread *thread;
	k_spinlock_key_t key = k_spin_lock(&lock);

	while (true) {
		thread = z_unpend_first_thread(&sem->wait_q);
   4722c:	4620      	mov	r0, r4
   4722e:	f008 ffd8 	bl	501e2 <z_unpend_first_thread>
		if (thread == NULL) {
   47232:	b118      	cbz	r0, 4723c <z_impl_k_sem_reset+0x28>
   47234:	67c6      	str	r6, [r0, #124]	; 0x7c
			break;
		}
		arch_thread_return_value_set(thread, -EAGAIN);
		z_ready_thread(thread);
   47236:	f008 ff9d 	bl	50174 <z_ready_thread>
		thread = z_unpend_first_thread(&sem->wait_q);
   4723a:	e7f7      	b.n	4722c <z_impl_k_sem_reset+0x18>
	}
	sem->count = 0;
   4723c:	60a0      	str	r0, [r4, #8]
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
   4723e:	2102      	movs	r1, #2
   47240:	f104 0010 	add.w	r0, r4, #16
   47244:	f009 fa11 	bl	5066a <z_handle_obj_poll_events>

	SYS_PORT_TRACING_OBJ_FUNC(k_sem, reset, sem);

	handle_poll_events(sem);

	z_reschedule(&lock, key);
   47248:	4629      	mov	r1, r5
   4724a:	4802      	ldr	r0, [pc, #8]	; (47254 <z_impl_k_sem_reset+0x40>)
}
   4724c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_reschedule(&lock, key);
   47250:	f000 bb7e 	b.w	47950 <z_reschedule>
   47254:	20006bc5 	.word	0x20006bc5

00047258 <k_sys_work_q_init>:
			     CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE);

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(const struct device *dev)
{
   47258:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	ARG_UNUSED(dev);
	struct k_work_queue_config cfg = {
   4725a:	4b09      	ldr	r3, [pc, #36]	; (47280 <k_sys_work_q_init+0x28>)
   4725c:	9302      	str	r3, [sp, #8]
		.name = "sysworkq",
		.no_yield = IS_ENABLED(CONFIG_SYSTEM_WORKQUEUE_NO_YIELD),
	};

	k_work_queue_start(&k_sys_work_q,
   4725e:	ab02      	add	r3, sp, #8
	struct k_work_queue_config cfg = {
   47260:	2400      	movs	r4, #0
	k_work_queue_start(&k_sys_work_q,
   47262:	9300      	str	r3, [sp, #0]
   47264:	4907      	ldr	r1, [pc, #28]	; (47284 <k_sys_work_q_init+0x2c>)
   47266:	4808      	ldr	r0, [pc, #32]	; (47288 <k_sys_work_q_init+0x30>)
	struct k_work_queue_config cfg = {
   47268:	f88d 400c 	strb.w	r4, [sp, #12]
	k_work_queue_start(&k_sys_work_q,
   4726c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   47270:	f44f 6200 	mov.w	r2, #2048	; 0x800
   47274:	f000 f924 	bl	474c0 <k_work_queue_start>
			    sys_work_q_stack,
			    K_KERNEL_STACK_SIZEOF(sys_work_q_stack),
			    CONFIG_SYSTEM_WORKQUEUE_PRIORITY, &cfg);
	return 0;
}
   47278:	4620      	mov	r0, r4
   4727a:	b004      	add	sp, #16
   4727c:	bd10      	pop	{r4, pc}
   4727e:	bf00      	nop
   47280:	000538e2 	.word	0x000538e2
   47284:	20009de8 	.word	0x20009de8
   47288:	20003678 	.word	0x20003678

0004728c <work_queue_main>:
/* Loop executed by a work queue thread.
 *
 * @param workq_ptr pointer to the work queue structure
 */
static void work_queue_main(void *workq_ptr, void *p2, void *p3)
{
   4728c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	return list->head;
   47290:	4e4a      	ldr	r6, [pc, #296]	; (473bc <work_queue_main+0x130>)
   47292:	b085      	sub	sp, #20
   47294:	4604      	mov	r4, r0
			 * stop.  Just go to sleep: when something happens the
			 * work thread will be woken and we can check again.
			 */

			(void)z_sched_wait(&lock, key, &queue->notifyq,
					   K_FOREVER, NULL);
   47296:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
   4729a:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
   4729e:	f04f 0320 	mov.w	r3, #32
   472a2:	f3ef 8711 	mrs	r7, BASEPRI
   472a6:	f383 8812 	msr	BASEPRI_MAX, r3
   472aa:	f3bf 8f6f 	isb	sy
   472ae:	f8d4 5080 	ldr.w	r5, [r4, #128]	; 0x80
Z_GENLIST_GET(slist, snode)
   472b2:	b98d      	cbnz	r5, 472d8 <work_queue_main+0x4c>
		} else if (flag_test_and_clear(&queue->flags,
   472b4:	2102      	movs	r1, #2
   472b6:	f104 0098 	add.w	r0, r4, #152	; 0x98
   472ba:	f008 fded 	bl	4fe98 <flag_test_and_clear>
   472be:	2800      	cmp	r0, #0
   472c0:	d143      	bne.n	4734a <work_queue_main+0xbe>
			(void)z_sched_wait(&lock, key, &queue->notifyq,
   472c2:	2300      	movs	r3, #0
   472c4:	e9cd 8900 	strd	r8, r9, [sp]
   472c8:	9302      	str	r3, [sp, #8]
   472ca:	f104 0288 	add.w	r2, r4, #136	; 0x88
   472ce:	4639      	mov	r1, r7
   472d0:	483b      	ldr	r0, [pc, #236]	; (473c0 <work_queue_main+0x134>)
   472d2:	f000 fcdd 	bl	47c90 <z_sched_wait>
			continue;
   472d6:	e7e2      	b.n	4729e <work_queue_main+0x12>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   472d8:	f8d4 2084 	ldr.w	r2, [r4, #132]	; 0x84
	return node->next;
   472dc:	682b      	ldr	r3, [r5, #0]
	list->head = node;
   472de:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   472e2:	4295      	cmp	r5, r2
	list->tail = node;
   472e4:	bf08      	it	eq
   472e6:	f8c4 3084 	streq.w	r3, [r4, #132]	; 0x84
	*flagp |= BIT(bit);
   472ea:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
   472ee:	f043 0302 	orr.w	r3, r3, #2
   472f2:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
	*flagp &= ~BIT(bit);
   472f6:	68eb      	ldr	r3, [r5, #12]
   472f8:	f023 0304 	bic.w	r3, r3, #4
   472fc:	f043 0301 	orr.w	r3, r3, #1
   47300:	60eb      	str	r3, [r5, #12]
			handler = work->handler;
   47302:	686b      	ldr	r3, [r5, #4]
	__asm__ volatile(
   47304:	f387 8811 	msr	BASEPRI, r7
   47308:	f3bf 8f6f 	isb	sy
		}

		k_spin_unlock(&lock, key);

		__ASSERT_NO_MSG(handler != NULL);
		handler(work);
   4730c:	4628      	mov	r0, r5
   4730e:	4798      	blx	r3
	__asm__ volatile(
   47310:	f04f 0320 	mov.w	r3, #32
   47314:	f3ef 8b11 	mrs	fp, BASEPRI
   47318:	f383 8812 	msr	BASEPRI_MAX, r3
   4731c:	f3bf 8f6f 	isb	sy
	*flagp &= ~BIT(bit);
   47320:	68eb      	ldr	r3, [r5, #12]
		 * starving other threads.
		 */
		key = k_spin_lock(&lock);

		flag_clear(&work->flags, K_WORK_RUNNING_BIT);
		if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
   47322:	0799      	lsls	r1, r3, #30
	*flagp &= ~BIT(bit);
   47324:	f023 0201 	bic.w	r2, r3, #1
		if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
   47328:	d419      	bmi.n	4735e <work_queue_main+0xd2>
	*flagp &= ~BIT(bit);
   4732a:	60ea      	str	r2, [r5, #12]
   4732c:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
   47330:	f023 0302 	bic.w	r3, r3, #2
   47334:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
	__asm__ volatile(
   47338:	f38b 8811 	msr	BASEPRI, fp
   4733c:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);

		/* Optionally yield to prevent the work queue from
		 * starving other threads.
		 */
		if (yield) {
   47340:	05db      	lsls	r3, r3, #23
   47342:	d4ac      	bmi.n	4729e <work_queue_main+0x12>
	z_impl_k_yield();
   47344:	f000 fba2 	bl	47a8c <z_impl_k_yield>
}
   47348:	e7a9      	b.n	4729e <work_queue_main+0x12>
			(void)z_sched_wake_all(&queue->drainq, 1, NULL);
   4734a:	f104 0590 	add.w	r5, r4, #144	; 0x90
static inline bool z_sched_wake_all(_wait_q_t *wait_q, int swap_retval,
				    void *swap_data)
{
	bool woken = false;

	while (z_sched_wake(wait_q, swap_retval, swap_data)) {
   4734e:	2200      	movs	r2, #0
   47350:	2101      	movs	r1, #1
   47352:	4628      	mov	r0, r5
   47354:	f008 ff9b 	bl	5028e <z_sched_wake>
   47358:	2800      	cmp	r0, #0
   4735a:	d1f8      	bne.n	4734e <work_queue_main+0xc2>
   4735c:	e7b1      	b.n	472c2 <work_queue_main+0x36>
	return list->head;
   4735e:	6830      	ldr	r0, [r6, #0]
	*flagp &= ~BIT(bit);
   47360:	f023 0303 	bic.w	r3, r3, #3
   47364:	60eb      	str	r3, [r5, #12]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
   47366:	2800      	cmp	r0, #0
   47368:	d0e0      	beq.n	4732c <work_queue_main+0xa0>
	return node->next;
   4736a:	2700      	movs	r7, #0
   4736c:	f8d0 a000 	ldr.w	sl, [r0]
	parent->next = child;
   47370:	463b      	mov	r3, r7
   47372:	2800      	cmp	r0, #0
   47374:	d0da      	beq.n	4732c <work_queue_main+0xa0>
		if (wc->work == work) {
   47376:	6842      	ldr	r2, [r0, #4]
   47378:	4295      	cmp	r5, r2
			sys_slist_remove(&pending_cancels, prev, &wc->node);
   4737a:	4601      	mov	r1, r0
		if (wc->work == work) {
   4737c:	d10c      	bne.n	47398 <work_queue_main+0x10c>
	return node->next;
   4737e:	6801      	ldr	r1, [r0, #0]
Z_GENLIST_REMOVE(slist, snode)
   47380:	b99f      	cbnz	r7, 473aa <work_queue_main+0x11e>
   47382:	6872      	ldr	r2, [r6, #4]
	list->head = node;
   47384:	6031      	str	r1, [r6, #0]
Z_GENLIST_REMOVE(slist, snode)
   47386:	4282      	cmp	r2, r0
   47388:	d100      	bne.n	4738c <work_queue_main+0x100>
	list->tail = node;
   4738a:	6071      	str	r1, [r6, #4]
	parent->next = child;
   4738c:	f840 3b08 	str.w	r3, [r0], #8
	z_impl_k_sem_give(sem);
   47390:	f7ff fef2 	bl	47178 <z_impl_k_sem_give>
}
   47394:	4639      	mov	r1, r7
   47396:	2300      	movs	r3, #0
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
   47398:	f1ba 0f00 	cmp.w	sl, #0
   4739c:	d00b      	beq.n	473b6 <work_queue_main+0x12a>
	return node->next;
   4739e:	f8da 2000 	ldr.w	r2, [sl]
   473a2:	4650      	mov	r0, sl
   473a4:	460f      	mov	r7, r1
   473a6:	4692      	mov	sl, r2
   473a8:	e7e3      	b.n	47372 <work_queue_main+0xe6>
	parent->next = child;
   473aa:	6039      	str	r1, [r7, #0]
Z_GENLIST_REMOVE(slist, snode)
   473ac:	6872      	ldr	r2, [r6, #4]
   473ae:	4282      	cmp	r2, r0
	list->tail = node;
   473b0:	bf08      	it	eq
   473b2:	6077      	streq	r7, [r6, #4]
}
   473b4:	e7ea      	b.n	4738c <work_queue_main+0x100>
   473b6:	4652      	mov	r2, sl
   473b8:	e7f3      	b.n	473a2 <work_queue_main+0x116>
   473ba:	bf00      	nop
   473bc:	20006974 	.word	0x20006974
   473c0:	20006bc5 	.word	0x20006bc5

000473c4 <cancel_sync_locked>:
{
   473c4:	b570      	push	{r4, r5, r6, lr}
	return (*flagp & BIT(bit)) != 0U;
   473c6:	68c3      	ldr	r3, [r0, #12]
   473c8:	f3c3 0640 	ubfx	r6, r3, #1, #1
	if (ret) {
   473cc:	079b      	lsls	r3, r3, #30
{
   473ce:	4605      	mov	r5, r0
   473d0:	460c      	mov	r4, r1
	if (ret) {
   473d2:	d50d      	bpl.n	473f0 <cancel_sync_locked+0x2c>
	return z_impl_k_sem_init(sem, initial_count, limit);
   473d4:	2201      	movs	r2, #1
   473d6:	2100      	movs	r1, #0
   473d8:	f104 0008 	add.w	r0, r4, #8
   473dc:	f008 fd4c 	bl	4fe78 <z_impl_k_sem_init>
	parent->next = child;
   473e0:	2300      	movs	r3, #0
   473e2:	6023      	str	r3, [r4, #0]
	return list->tail;
   473e4:	4b05      	ldr	r3, [pc, #20]	; (473fc <cancel_sync_locked+0x38>)
	canceler->work = work;
   473e6:	6065      	str	r5, [r4, #4]
   473e8:	685a      	ldr	r2, [r3, #4]
Z_GENLIST_APPEND(slist, snode)
   473ea:	b91a      	cbnz	r2, 473f4 <cancel_sync_locked+0x30>
	list->head = node;
   473ec:	e9c3 4400 	strd	r4, r4, [r3]
}
   473f0:	4630      	mov	r0, r6
   473f2:	bd70      	pop	{r4, r5, r6, pc}
	parent->next = child;
   473f4:	6014      	str	r4, [r2, #0]
	list->tail = node;
   473f6:	605c      	str	r4, [r3, #4]
}
   473f8:	e7fa      	b.n	473f0 <cancel_sync_locked+0x2c>
   473fa:	bf00      	nop
   473fc:	20006974 	.word	0x20006974

00047400 <submit_to_queue_locked>:
{
   47400:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	return (*flagp & BIT(bit)) != 0U;
   47402:	68c3      	ldr	r3, [r0, #12]
	if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
   47404:	079a      	lsls	r2, r3, #30
{
   47406:	4604      	mov	r4, r0
   47408:	460f      	mov	r7, r1
	if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
   4740a:	f3c3 0640 	ubfx	r6, r3, #1, #1
   4740e:	d42c      	bmi.n	4746a <submit_to_queue_locked+0x6a>
	} else if (!flag_test(&work->flags, K_WORK_QUEUED_BIT)) {
   47410:	075b      	lsls	r3, r3, #29
   47412:	d41a      	bmi.n	4744a <submit_to_queue_locked+0x4a>
		if (*queuep == NULL) {
   47414:	680b      	ldr	r3, [r1, #0]
   47416:	b90b      	cbnz	r3, 4741c <submit_to_queue_locked+0x1c>
			*queuep = work->queue;
   47418:	6883      	ldr	r3, [r0, #8]
   4741a:	600b      	str	r3, [r1, #0]
	return (*flagp & BIT(bit)) != 0U;
   4741c:	68e3      	ldr	r3, [r4, #12]
		if (flag_test(&work->flags, K_WORK_RUNNING_BIT)) {
   4741e:	07dd      	lsls	r5, r3, #31
			*queuep = work->queue;
   47420:	bf44      	itt	mi
   47422:	68a3      	ldrmi	r3, [r4, #8]
   47424:	603b      	strmi	r3, [r7, #0]
		int rc = queue_submit_locked(*queuep, work);
   47426:	683d      	ldr	r5, [r7, #0]
			ret = 2;
   47428:	bf4c      	ite	mi
   4742a:	2602      	movmi	r6, #2
		ret = 1;
   4742c:	2601      	movpl	r6, #1
	if (queue == NULL) {
   4742e:	2d00      	cmp	r5, #0
   47430:	d03a      	beq.n	474a8 <submit_to_queue_locked+0xa8>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
   47432:	4b1f      	ldr	r3, [pc, #124]	; (474b0 <submit_to_queue_locked+0xb0>)
   47434:	689b      	ldr	r3, [r3, #8]
   47436:	42ab      	cmp	r3, r5
   47438:	d00a      	beq.n	47450 <submit_to_queue_locked+0x50>
	return (*flagp & BIT(bit)) != 0U;
   4743a:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
   4743e:	07d8      	lsls	r0, r3, #31
	return (*flagp & BIT(bit)) != 0U;
   47440:	f3c3 0280 	ubfx	r2, r3, #2, #1
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
   47444:	d414      	bmi.n	47470 <submit_to_queue_locked+0x70>
		ret = -EBUSY;
   47446:	f06f 0612 	mvn.w	r6, #18
		*queuep = NULL;
   4744a:	2300      	movs	r3, #0
   4744c:	603b      	str	r3, [r7, #0]
	return ret;
   4744e:	e025      	b.n	4749c <submit_to_queue_locked+0x9c>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
   47450:	f008 fbff 	bl	4fc52 <k_is_in_isr>
   47454:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
   47458:	2800      	cmp	r0, #0
   4745a:	d1f0      	bne.n	4743e <submit_to_queue_locked+0x3e>
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
   4745c:	07d9      	lsls	r1, r3, #31
	return (*flagp & BIT(bit)) != 0U;
   4745e:	f3c3 02c0 	ubfx	r2, r3, #3, #1
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
   47462:	d5f0      	bpl.n	47446 <submit_to_queue_locked+0x46>
	} else if (plugged && !draining) {
   47464:	b152      	cbz	r2, 4747c <submit_to_queue_locked+0x7c>
   47466:	075b      	lsls	r3, r3, #29
   47468:	d408      	bmi.n	4747c <submit_to_queue_locked+0x7c>
		ret = -EBUSY;
   4746a:	f06f 060f 	mvn.w	r6, #15
   4746e:	e7ec      	b.n	4744a <submit_to_queue_locked+0x4a>
	} else if (draining && !chained) {
   47470:	2a00      	cmp	r2, #0
   47472:	d1fa      	bne.n	4746a <submit_to_queue_locked+0x6a>
	return (*flagp & BIT(bit)) != 0U;
   47474:	f3c3 03c0 	ubfx	r3, r3, #3, #1
	} else if (plugged && !draining) {
   47478:	2b00      	cmp	r3, #0
   4747a:	d1f6      	bne.n	4746a <submit_to_queue_locked+0x6a>
	parent->next = child;
   4747c:	2300      	movs	r3, #0
   4747e:	6023      	str	r3, [r4, #0]
	return list->tail;
   47480:	f8d5 3084 	ldr.w	r3, [r5, #132]	; 0x84
Z_GENLIST_APPEND(slist, snode)
   47484:	b963      	cbnz	r3, 474a0 <submit_to_queue_locked+0xa0>
	list->head = node;
   47486:	e9c5 4420 	strd	r4, r4, [r5, #128]	; 0x80
		(void)notify_queue_locked(queue);
   4748a:	4628      	mov	r0, r5
   4748c:	f008 fd1d 	bl	4feca <notify_queue_locked.isra.0>
	*flagp |= BIT(bit);
   47490:	68e3      	ldr	r3, [r4, #12]
   47492:	f043 0304 	orr.w	r3, r3, #4
   47496:	60e3      	str	r3, [r4, #12]
			work->queue = *queuep;
   47498:	683b      	ldr	r3, [r7, #0]
   4749a:	60a3      	str	r3, [r4, #8]
}
   4749c:	4630      	mov	r0, r6
   4749e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	parent->next = child;
   474a0:	601c      	str	r4, [r3, #0]
	list->tail = node;
   474a2:	f8c5 4084 	str.w	r4, [r5, #132]	; 0x84
}
   474a6:	e7f0      	b.n	4748a <submit_to_queue_locked+0x8a>
		return -EINVAL;
   474a8:	f06f 0615 	mvn.w	r6, #21
   474ac:	e7cd      	b.n	4744a <submit_to_queue_locked+0x4a>
   474ae:	bf00      	nop
   474b0:	2000694c 	.word	0x2000694c

000474b4 <k_work_submit>:
{
   474b4:	4601      	mov	r1, r0
	int ret = k_work_submit_to_queue(&k_sys_work_q, work);
   474b6:	4801      	ldr	r0, [pc, #4]	; (474bc <k_work_submit+0x8>)
   474b8:	f008 bd8d 	b.w	4ffd6 <k_work_submit_to_queue>
   474bc:	20003678 	.word	0x20003678

000474c0 <k_work_queue_start>:
void k_work_queue_start(struct k_work_q *queue,
			k_thread_stack_t *stack,
			size_t stack_size,
			int prio,
			const struct k_work_queue_config *cfg)
{
   474c0:	b5f0      	push	{r4, r5, r6, r7, lr}
   474c2:	b089      	sub	sp, #36	; 0x24
   474c4:	4604      	mov	r4, r0
	list->head = NULL;
   474c6:	2000      	movs	r0, #0
	list->tail = NULL;
   474c8:	e9c4 0020 	strd	r0, r0, [r4, #128]	; 0x80
   474cc:	9d0e      	ldr	r5, [sp, #56]	; 0x38
   474ce:	f104 0088 	add.w	r0, r4, #136	; 0x88
	list->tail = (sys_dnode_t *)list;
   474d2:	e9c4 0022 	strd	r0, r0, [r4, #136]	; 0x88
   474d6:	f104 0090 	add.w	r0, r4, #144	; 0x90
   474da:	e9c4 0024 	strd	r0, r0, [r4, #144]	; 0x90

	sys_slist_init(&queue->pending);
	z_waitq_init(&queue->notifyq);
	z_waitq_init(&queue->drainq);

	if ((cfg != NULL) && cfg->no_yield) {
   474de:	b31d      	cbz	r5, 47528 <k_work_queue_start+0x68>
   474e0:	7928      	ldrb	r0, [r5, #4]
		flags |= K_WORK_QUEUE_NO_YIELD;
   474e2:	2800      	cmp	r0, #0
   474e4:	f240 1001 	movw	r0, #257	; 0x101
   474e8:	bf08      	it	eq
   474ea:	2001      	moveq	r0, #1
	*flagp = flags;
   474ec:	f8c4 0098 	str.w	r0, [r4, #152]	; 0x98
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   474f0:	2000      	movs	r0, #0
   474f2:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
   474f6:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
   474fa:	e9cd 3003 	strd	r3, r0, [sp, #12]
   474fe:	e9cd 0001 	strd	r0, r0, [sp, #4]
   47502:	e9cd 6706 	strd	r6, r7, [sp, #24]
   47506:	4b09      	ldr	r3, [pc, #36]	; (4752c <k_work_queue_start+0x6c>)
   47508:	9400      	str	r4, [sp, #0]
   4750a:	4620      	mov	r0, r4
   4750c:	f7ff fbf6 	bl	46cfc <z_impl_k_thread_create>

	(void)k_thread_create(&queue->thread, stack, stack_size,
			      work_queue_main, queue, NULL, NULL,
			      prio, 0, K_FOREVER);

	if ((cfg != NULL) && (cfg->name != NULL)) {
   47510:	b125      	cbz	r5, 4751c <k_work_queue_start+0x5c>
   47512:	6829      	ldr	r1, [r5, #0]
   47514:	b111      	cbz	r1, 4751c <k_work_queue_start+0x5c>
	return z_impl_k_thread_name_set(thread, str);
   47516:	4620      	mov	r0, r4
   47518:	f008 fba1 	bl	4fc5e <z_impl_k_thread_name_set>
	z_impl_k_thread_start(thread);
   4751c:	4620      	mov	r0, r4
	}

	k_thread_start(&queue->thread);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work_queue, start, queue);
}
   4751e:	b009      	add	sp, #36	; 0x24
   47520:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
   47524:	f008 bb9e 	b.w	4fc64 <z_impl_k_thread_start>
	uint32_t flags = K_WORK_QUEUE_STARTED;
   47528:	2001      	movs	r0, #1
   4752a:	e7df      	b.n	474ec <k_work_queue_start+0x2c>
   4752c:	0004728d 	.word	0x0004728d

00047530 <k_work_schedule_for_queue>:
}

int k_work_schedule_for_queue(struct k_work_q *queue,
			       struct k_work_delayable *dwork,
			       k_timeout_t delay)
{
   47530:	b537      	push	{r0, r1, r2, r4, r5, lr}
   47532:	9001      	str	r0, [sp, #4]
   47534:	4608      	mov	r0, r1
	__asm__ volatile(
   47536:	f04f 0120 	mov.w	r1, #32
   4753a:	f3ef 8411 	mrs	r4, BASEPRI
   4753e:	f381 8812 	msr	BASEPRI_MAX, r1
   47542:	f3bf 8f6f 	isb	sy
	return *flagp;
   47546:	68c1      	ldr	r1, [r0, #12]
	struct k_work *work = &dwork->work;
	int ret = 0;
	k_spinlock_key_t key = k_spin_lock(&lock);

	/* Schedule the work item if it's idle or running. */
	if ((work_busy_get_locked(work) & ~K_WORK_RUNNING) == 0U) {
   47548:	f011 0f0e 	tst.w	r1, #14
   4754c:	d116      	bne.n	4757c <k_work_schedule_for_queue+0x4c>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   4754e:	ea53 0502 	orrs.w	r5, r3, r2
   47552:	d108      	bne.n	47566 <k_work_schedule_for_queue+0x36>
		return submit_to_queue_locked(work, queuep);
   47554:	a901      	add	r1, sp, #4
   47556:	f7ff ff53 	bl	47400 <submit_to_queue_locked>
	__asm__ volatile(
   4755a:	f384 8811 	msr	BASEPRI, r4
   4755e:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&lock, key);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, schedule_for_queue, queue, dwork, delay, ret);

	return ret;
}
   47562:	b003      	add	sp, #12
   47564:	bd30      	pop	{r4, r5, pc}
	*flagp |= BIT(bit);
   47566:	f041 0108 	orr.w	r1, r1, #8
   4756a:	60c1      	str	r1, [r0, #12]
	dwork->queue = *queuep;
   4756c:	9901      	ldr	r1, [sp, #4]
   4756e:	6281      	str	r1, [r0, #40]	; 0x28
	z_add_timeout(&dwork->timeout, work_timeout, delay);
   47570:	3010      	adds	r0, #16
   47572:	4903      	ldr	r1, [pc, #12]	; (47580 <k_work_schedule_for_queue+0x50>)
   47574:	f000 fc06 	bl	47d84 <z_add_timeout>
	return ret;
   47578:	2001      	movs	r0, #1
   4757a:	e7ee      	b.n	4755a <k_work_schedule_for_queue+0x2a>
	int ret = 0;
   4757c:	2000      	movs	r0, #0
   4757e:	e7ec      	b.n	4755a <k_work_schedule_for_queue+0x2a>
   47580:	0004ff3f 	.word	0x0004ff3f

00047584 <k_work_schedule>:

int k_work_schedule(struct k_work_delayable *dwork,
				   k_timeout_t delay)
{
   47584:	4601      	mov	r1, r0
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work, schedule, dwork, delay);

	int ret = k_work_schedule_for_queue(&k_sys_work_q, dwork, delay);
   47586:	4801      	ldr	r0, [pc, #4]	; (4758c <k_work_schedule+0x8>)
   47588:	f7ff bfd2 	b.w	47530 <k_work_schedule_for_queue>
   4758c:	20003678 	.word	0x20003678

00047590 <k_work_reschedule_for_queue>:
}

int k_work_reschedule_for_queue(struct k_work_q *queue,
				 struct k_work_delayable *dwork,
				 k_timeout_t delay)
{
   47590:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   47592:	460c      	mov	r4, r1
   47594:	9001      	str	r0, [sp, #4]
   47596:	4616      	mov	r6, r2
   47598:	461d      	mov	r5, r3
	__asm__ volatile(
   4759a:	f04f 0320 	mov.w	r3, #32
   4759e:	f3ef 8711 	mrs	r7, BASEPRI
   475a2:	f383 8812 	msr	BASEPRI_MAX, r3
   475a6:	f3bf 8f6f 	isb	sy

	int ret = 0;
	k_spinlock_key_t key = k_spin_lock(&lock);

	/* Remove any active scheduling. */
	(void)unschedule_locked(dwork);
   475aa:	4608      	mov	r0, r1
   475ac:	f008 fc7f 	bl	4feae <unschedule_locked>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   475b0:	ea55 0306 	orrs.w	r3, r5, r6
   475b4:	d109      	bne.n	475ca <k_work_reschedule_for_queue+0x3a>
		return submit_to_queue_locked(work, queuep);
   475b6:	a901      	add	r1, sp, #4
   475b8:	4620      	mov	r0, r4
   475ba:	f7ff ff21 	bl	47400 <submit_to_queue_locked>
	__asm__ volatile(
   475be:	f387 8811 	msr	BASEPRI, r7
   475c2:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&lock, key);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, reschedule_for_queue, queue, dwork, delay, ret);

	return ret;
}
   475c6:	b003      	add	sp, #12
   475c8:	bdf0      	pop	{r4, r5, r6, r7, pc}
	*flagp |= BIT(bit);
   475ca:	68e3      	ldr	r3, [r4, #12]
	z_add_timeout(&dwork->timeout, work_timeout, delay);
   475cc:	4906      	ldr	r1, [pc, #24]	; (475e8 <k_work_reschedule_for_queue+0x58>)
	*flagp |= BIT(bit);
   475ce:	f043 0308 	orr.w	r3, r3, #8
   475d2:	60e3      	str	r3, [r4, #12]
	dwork->queue = *queuep;
   475d4:	9b01      	ldr	r3, [sp, #4]
   475d6:	62a3      	str	r3, [r4, #40]	; 0x28
	z_add_timeout(&dwork->timeout, work_timeout, delay);
   475d8:	f104 0010 	add.w	r0, r4, #16
   475dc:	4632      	mov	r2, r6
   475de:	462b      	mov	r3, r5
   475e0:	f000 fbd0 	bl	47d84 <z_add_timeout>
	return ret;
   475e4:	2001      	movs	r0, #1
   475e6:	e7ea      	b.n	475be <k_work_reschedule_for_queue+0x2e>
   475e8:	0004ff3f 	.word	0x0004ff3f

000475ec <k_work_reschedule>:

int k_work_reschedule(struct k_work_delayable *dwork,
				     k_timeout_t delay)
{
   475ec:	4601      	mov	r1, r0
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work, reschedule, dwork, delay);

	int ret = k_work_reschedule_for_queue(&k_sys_work_q, dwork, delay);
   475ee:	4801      	ldr	r0, [pc, #4]	; (475f4 <k_work_reschedule+0x8>)
   475f0:	f7ff bfce 	b.w	47590 <k_work_reschedule_for_queue>
   475f4:	20003678 	.word	0x20003678

000475f8 <z_reset_time_slice>:
 */
static struct k_thread *pending_current;
#endif

void z_reset_time_slice(struct k_thread *curr)
{
   475f8:	b538      	push	{r3, r4, r5, lr}
	int ret = slice_ticks;
   475fa:	4d07      	ldr	r5, [pc, #28]	; (47618 <z_reset_time_slice+0x20>)
   475fc:	682c      	ldr	r4, [r5, #0]
	/* Add the elapsed time since the last announced tick to the
	 * slice count, as we'll see those "expired" ticks arrive in a
	 * FUTURE z_time_slice() call.
	 */
	if (slice_time(curr) != 0) {
   475fe:	b154      	cbz	r4, 47616 <z_reset_time_slice+0x1e>
		_current_cpu->slice_ticks = slice_time(curr) + sys_clock_elapsed();
   47600:	f7fd faec 	bl	44bdc <sys_clock_elapsed>
   47604:	4b05      	ldr	r3, [pc, #20]	; (4761c <z_reset_time_slice+0x24>)
   47606:	4404      	add	r4, r0
   47608:	611c      	str	r4, [r3, #16]
		z_set_timeout_expiry(slice_time(curr), false);
   4760a:	6828      	ldr	r0, [r5, #0]
   4760c:	2100      	movs	r1, #0
	}
}
   4760e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		z_set_timeout_expiry(slice_time(curr), false);
   47612:	f008 be85 	b.w	50320 <z_set_timeout_expiry>
}
   47616:	bd38      	pop	{r3, r4, r5, pc}
   47618:	20006984 	.word	0x20006984
   4761c:	2000694c 	.word	0x2000694c

00047620 <update_cache>:
	}
#endif
}

static void update_cache(int preempt_ok)
{
   47620:	b538      	push	{r3, r4, r5, lr}
	return list->head == list;
   47622:	4d0d      	ldr	r5, [pc, #52]	; (47658 <update_cache+0x38>)
   47624:	462b      	mov	r3, r5
   47626:	f853 4f20 	ldr.w	r4, [r3, #32]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   4762a:	429c      	cmp	r4, r3
   4762c:	d000      	beq.n	47630 <update_cache+0x10>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
   4762e:	b904      	cbnz	r4, 47632 <update_cache+0x12>
   47630:	68ec      	ldr	r4, [r5, #12]
	if (z_is_thread_prevented_from_running(_current)) {
   47632:	68ab      	ldr	r3, [r5, #8]
	if (preempt_ok != 0) {
   47634:	b938      	cbnz	r0, 47646 <update_cache+0x26>
	if (z_is_thread_prevented_from_running(_current)) {
   47636:	7b5a      	ldrb	r2, [r3, #13]
   47638:	06d2      	lsls	r2, r2, #27
   4763a:	d104      	bne.n	47646 <update_cache+0x26>
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
   4763c:	69a2      	ldr	r2, [r4, #24]
   4763e:	b912      	cbnz	r2, 47646 <update_cache+0x26>
	if (is_preempt(_current) || is_metairq(thread)) {
   47640:	89da      	ldrh	r2, [r3, #14]
   47642:	2a7f      	cmp	r2, #127	; 0x7f
   47644:	d805      	bhi.n	47652 <update_cache+0x32>
#ifndef CONFIG_SMP
	struct k_thread *thread = next_up();

	if (should_preempt(thread, preempt_ok)) {
#ifdef CONFIG_TIMESLICING
		if (thread != _current) {
   47646:	429c      	cmp	r4, r3
   47648:	d002      	beq.n	47650 <update_cache+0x30>
			z_reset_time_slice(thread);
   4764a:	4620      	mov	r0, r4
   4764c:	f7ff ffd4 	bl	475f8 <z_reset_time_slice>
		}
#endif
		update_metairq_preempt(thread);
		_kernel.ready_q.cache = thread;
   47650:	4623      	mov	r3, r4
   47652:	61eb      	str	r3, [r5, #28]
	 * thread because if the thread gets preempted for whatever
	 * reason the scheduler will make the same decision anyway.
	 */
	_current_cpu->swap_ok = preempt_ok;
#endif
}
   47654:	bd38      	pop	{r3, r4, r5, pc}
   47656:	bf00      	nop
   47658:	2000694c 	.word	0x2000694c

0004765c <move_thread_to_end_of_prio_q>:
{
   4765c:	b570      	push	{r4, r5, r6, lr}
	if (z_is_thread_queued(thread)) {
   4765e:	f990 200d 	ldrsb.w	r2, [r0, #13]
	return (thread->base.thread_state & state) != 0U;
   47662:	7b43      	ldrb	r3, [r0, #13]
   47664:	2a00      	cmp	r2, #0
{
   47666:	4601      	mov	r1, r0
	if (z_is_thread_queued(thread)) {
   47668:	da04      	bge.n	47674 <move_thread_to_end_of_prio_q+0x18>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   4766a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   4766e:	7343      	strb	r3, [r0, #13]

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
   47670:	f008 fd1b 	bl	500aa <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
   47674:	7b4b      	ldrb	r3, [r1, #13]
	return list->head == list;
   47676:	4a15      	ldr	r2, [pc, #84]	; (476cc <move_thread_to_end_of_prio_q+0x70>)
   47678:	f063 037f 	orn	r3, r3, #127	; 0x7f
   4767c:	4610      	mov	r0, r2
   4767e:	734b      	strb	r3, [r1, #13]
   47680:	f850 3f20 	ldr.w	r3, [r0, #32]!
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
   47684:	6a54      	ldr	r4, [r2, #36]	; 0x24
	return sys_dlist_is_empty(list) ? NULL : list->head;
   47686:	4283      	cmp	r3, r0
   47688:	bf08      	it	eq
   4768a:	2300      	moveq	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   4768c:	b923      	cbnz	r3, 47698 <move_thread_to_end_of_prio_q+0x3c>
static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	sys_dnode_t *const tail = list->tail;

	node->next = list;
	node->prev = tail;
   4768e:	e9c1 0400 	strd	r0, r4, [r1]

	tail->next = node;
   47692:	6021      	str	r1, [r4, #0]
	list->tail = node;
   47694:	6251      	str	r1, [r2, #36]	; 0x24
}
   47696:	e00c      	b.n	476b2 <move_thread_to_end_of_prio_q+0x56>
	int32_t b1 = thread_1->base.prio;
   47698:	f991 500e 	ldrsb.w	r5, [r1, #14]
	int32_t b2 = thread_2->base.prio;
   4769c:	f993 600e 	ldrsb.w	r6, [r3, #14]
	if (b1 != b2) {
   476a0:	42b5      	cmp	r5, r6
   476a2:	d00e      	beq.n	476c2 <move_thread_to_end_of_prio_q+0x66>
		if (z_sched_prio_cmp(thread, t) > 0) {
   476a4:	42ae      	cmp	r6, r5
   476a6:	dd0c      	ble.n	476c2 <move_thread_to_end_of_prio_q+0x66>
 * @param successor the position before which "node" will be inserted
 * @param node the element to insert
 */
static inline void sys_dlist_insert(sys_dnode_t *successor, sys_dnode_t *node)
{
	sys_dnode_t *const prev = successor->prev;
   476a8:	6858      	ldr	r0, [r3, #4]

	node->prev = prev;
	node->next = successor;
   476aa:	e9c1 3000 	strd	r3, r0, [r1]
	prev->next = node;
   476ae:	6001      	str	r1, [r0, #0]
	successor->prev = node;
   476b0:	6059      	str	r1, [r3, #4]
	update_cache(thread == _current);
   476b2:	6890      	ldr	r0, [r2, #8]
   476b4:	1a43      	subs	r3, r0, r1
   476b6:	4258      	negs	r0, r3
}
   476b8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	update_cache(thread == _current);
   476bc:	4158      	adcs	r0, r3
   476be:	f7ff bfaf 	b.w	47620 <update_cache>
	return (node == list->tail) ? NULL : node->next;
   476c2:	429c      	cmp	r4, r3
   476c4:	d0e3      	beq.n	4768e <move_thread_to_end_of_prio_q+0x32>
   476c6:	681b      	ldr	r3, [r3, #0]
   476c8:	e7e0      	b.n	4768c <move_thread_to_end_of_prio_q+0x30>
   476ca:	bf00      	nop
   476cc:	2000694c 	.word	0x2000694c

000476d0 <ready_thread>:
{
   476d0:	b470      	push	{r4, r5, r6}
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
   476d2:	f990 300d 	ldrsb.w	r3, [r0, #13]
   476d6:	7b42      	ldrb	r2, [r0, #13]
   476d8:	2b00      	cmp	r3, #0
   476da:	db29      	blt.n	47730 <ready_thread+0x60>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   476dc:	06d3      	lsls	r3, r2, #27
   476de:	d127      	bne.n	47730 <ready_thread+0x60>
	return node->next != NULL;
   476e0:	6983      	ldr	r3, [r0, #24]
   476e2:	bb2b      	cbnz	r3, 47730 <ready_thread+0x60>
	return list->head == list;
   476e4:	4913      	ldr	r1, [pc, #76]	; (47734 <ready_thread+0x64>)
	thread->base.thread_state |= _THREAD_QUEUED;
   476e6:	f062 027f 	orn	r2, r2, #127	; 0x7f
   476ea:	7342      	strb	r2, [r0, #13]
   476ec:	460a      	mov	r2, r1
   476ee:	f852 4f20 	ldr.w	r4, [r2, #32]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   476f2:	4294      	cmp	r4, r2
   476f4:	bf18      	it	ne
   476f6:	4623      	movne	r3, r4
	return (node == list->tail) ? NULL : node->next;
   476f8:	6a4c      	ldr	r4, [r1, #36]	; 0x24
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   476fa:	b923      	cbnz	r3, 47706 <ready_thread+0x36>
	node->prev = tail;
   476fc:	e9c0 2400 	strd	r2, r4, [r0]
	tail->next = node;
   47700:	6020      	str	r0, [r4, #0]
	list->tail = node;
   47702:	6248      	str	r0, [r1, #36]	; 0x24
}
   47704:	e00c      	b.n	47720 <ready_thread+0x50>
	int32_t b1 = thread_1->base.prio;
   47706:	f990 500e 	ldrsb.w	r5, [r0, #14]
	int32_t b2 = thread_2->base.prio;
   4770a:	f993 600e 	ldrsb.w	r6, [r3, #14]
	if (b1 != b2) {
   4770e:	42b5      	cmp	r5, r6
   47710:	d00a      	beq.n	47728 <ready_thread+0x58>
		if (z_sched_prio_cmp(thread, t) > 0) {
   47712:	42ae      	cmp	r6, r5
   47714:	dd08      	ble.n	47728 <ready_thread+0x58>
	sys_dnode_t *const prev = successor->prev;
   47716:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   47718:	e9c0 3200 	strd	r3, r2, [r0]
	prev->next = node;
   4771c:	6010      	str	r0, [r2, #0]
	successor->prev = node;
   4771e:	6058      	str	r0, [r3, #4]
}
   47720:	bc70      	pop	{r4, r5, r6}
		update_cache(0);
   47722:	2000      	movs	r0, #0
   47724:	f7ff bf7c 	b.w	47620 <update_cache>
	return (node == list->tail) ? NULL : node->next;
   47728:	42a3      	cmp	r3, r4
   4772a:	d0e7      	beq.n	476fc <ready_thread+0x2c>
   4772c:	681b      	ldr	r3, [r3, #0]
   4772e:	e7e4      	b.n	476fa <ready_thread+0x2a>
}
   47730:	bc70      	pop	{r4, r5, r6}
   47732:	4770      	bx	lr
   47734:	2000694c 	.word	0x2000694c

00047738 <unready_thread>:
{
   47738:	b508      	push	{r3, lr}
	if (z_is_thread_queued(thread)) {
   4773a:	f990 200d 	ldrsb.w	r2, [r0, #13]
	return (thread->base.thread_state & state) != 0U;
   4773e:	7b43      	ldrb	r3, [r0, #13]
   47740:	2a00      	cmp	r2, #0
{
   47742:	4601      	mov	r1, r0
	if (z_is_thread_queued(thread)) {
   47744:	da04      	bge.n	47750 <unready_thread+0x18>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   47746:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   4774a:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   4774c:	f008 fcad 	bl	500aa <sys_dlist_remove>
	update_cache(thread == _current);
   47750:	4b04      	ldr	r3, [pc, #16]	; (47764 <unready_thread+0x2c>)
   47752:	6898      	ldr	r0, [r3, #8]
   47754:	1a43      	subs	r3, r0, r1
   47756:	4258      	negs	r0, r3
   47758:	4158      	adcs	r0, r3
}
   4775a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	update_cache(thread == _current);
   4775e:	f7ff bf5f 	b.w	47620 <update_cache>
   47762:	bf00      	nop
   47764:	2000694c 	.word	0x2000694c

00047768 <pend>:
{
   47768:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4776c:	4606      	mov	r6, r0
   4776e:	4615      	mov	r5, r2
   47770:	461c      	mov	r4, r3
	__asm__ volatile(
   47772:	f04f 0320 	mov.w	r3, #32
   47776:	f3ef 8711 	mrs	r7, BASEPRI
   4777a:	f383 8812 	msr	BASEPRI_MAX, r3
   4777e:	f3bf 8f6f 	isb	sy
		add_to_waitq_locked(thread, wait_q);
   47782:	f008 fccf 	bl	50124 <add_to_waitq_locked>
	__asm__ volatile(
   47786:	f387 8811 	msr	BASEPRI, r7
   4778a:	f3bf 8f6f 	isb	sy
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   4778e:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
   47792:	bf08      	it	eq
   47794:	f1b5 3fff 	cmpeq.w	r5, #4294967295	; 0xffffffff
   47798:	d008      	beq.n	477ac <pend+0x44>
   4779a:	462a      	mov	r2, r5
   4779c:	4623      	mov	r3, r4
   4779e:	f106 0018 	add.w	r0, r6, #24
   477a2:	4903      	ldr	r1, [pc, #12]	; (477b0 <pend+0x48>)
}
   477a4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   477a8:	f000 baec 	b.w	47d84 <z_add_timeout>
   477ac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   477b0:	000500e1 	.word	0x000500e1

000477b4 <k_sched_time_slice_set>:
{
   477b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   477b6:	4604      	mov	r4, r0
   477b8:	460d      	mov	r5, r1
	__asm__ volatile(
   477ba:	f04f 0320 	mov.w	r3, #32
   477be:	f3ef 8711 	mrs	r7, BASEPRI
   477c2:	f383 8812 	msr	BASEPRI_MAX, r3
   477c6:	f3bf 8f6f 	isb	sy
			return (uint32_t)((t * to_hz + off) / from_hz);
   477ca:	2600      	movs	r6, #0
   477cc:	f44f 4c00 	mov.w	ip, #32768	; 0x8000
   477d0:	f240 30e7 	movw	r0, #999	; 0x3e7
   477d4:	4631      	mov	r1, r6
   477d6:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   477da:	2300      	movs	r3, #0
   477dc:	fbe4 010c 	umlal	r0, r1, r4, ip
   477e0:	f7de fc8e 	bl	26100 <__aeabi_uldivmod>
		if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && slice > 0) {
   477e4:	42b4      	cmp	r4, r6
   477e6:	dd02      	ble.n	477ee <k_sched_time_slice_set+0x3a>
			slice_ticks = MAX(2, slice_ticks);
   477e8:	2802      	cmp	r0, #2
   477ea:	bfb8      	it	lt
   477ec:	2002      	movlt	r0, #2
		slice_ticks = k_ms_to_ticks_ceil32(slice);
   477ee:	4a07      	ldr	r2, [pc, #28]	; (4780c <k_sched_time_slice_set+0x58>)
		_current_cpu->slice_ticks = 0;
   477f0:	4b07      	ldr	r3, [pc, #28]	; (47810 <k_sched_time_slice_set+0x5c>)
		slice_ticks = k_ms_to_ticks_ceil32(slice);
   477f2:	6010      	str	r0, [r2, #0]
		slice_max_prio = prio;
   477f4:	4a07      	ldr	r2, [pc, #28]	; (47814 <k_sched_time_slice_set+0x60>)
		z_reset_time_slice(_current);
   477f6:	6898      	ldr	r0, [r3, #8]
		_current_cpu->slice_ticks = 0;
   477f8:	611e      	str	r6, [r3, #16]
		slice_max_prio = prio;
   477fa:	6015      	str	r5, [r2, #0]
		z_reset_time_slice(_current);
   477fc:	f7ff fefc 	bl	475f8 <z_reset_time_slice>
	__asm__ volatile(
   47800:	f387 8811 	msr	BASEPRI, r7
   47804:	f3bf 8f6f 	isb	sy
}
   47808:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   4780a:	bf00      	nop
   4780c:	20006984 	.word	0x20006984
   47810:	2000694c 	.word	0x2000694c
   47814:	20006980 	.word	0x20006980

00047818 <z_time_slice>:
{
   47818:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   4781a:	f04f 0320 	mov.w	r3, #32
   4781e:	f3ef 8511 	mrs	r5, BASEPRI
   47822:	f383 8812 	msr	BASEPRI_MAX, r3
   47826:	f3bf 8f6f 	isb	sy
	if (pending_current == _current) {
   4782a:	4b17      	ldr	r3, [pc, #92]	; (47888 <z_time_slice+0x70>)
   4782c:	4a17      	ldr	r2, [pc, #92]	; (4788c <z_time_slice+0x74>)
   4782e:	689c      	ldr	r4, [r3, #8]
   47830:	6811      	ldr	r1, [r2, #0]
   47832:	428c      	cmp	r4, r1
   47834:	d107      	bne.n	47846 <z_time_slice+0x2e>
	z_reset_time_slice(curr);
   47836:	4620      	mov	r0, r4
   47838:	f7ff fede 	bl	475f8 <z_reset_time_slice>
	__asm__ volatile(
   4783c:	f385 8811 	msr	BASEPRI, r5
   47840:	f3bf 8f6f 	isb	sy
}
   47844:	bd38      	pop	{r3, r4, r5, pc}
	pending_current = NULL;
   47846:	2100      	movs	r1, #0
   47848:	6011      	str	r1, [r2, #0]
	int ret = slice_ticks;
   4784a:	4a11      	ldr	r2, [pc, #68]	; (47890 <z_time_slice+0x78>)
	if (slice_time(_current) && sliceable(_current)) {
   4784c:	6812      	ldr	r2, [r2, #0]
   4784e:	b1c2      	cbz	r2, 47882 <z_time_slice+0x6a>
		&& !z_is_idle_thread_object(thread);
   47850:	89e2      	ldrh	r2, [r4, #14]
   47852:	2a7f      	cmp	r2, #127	; 0x7f
   47854:	d815      	bhi.n	47882 <z_time_slice+0x6a>
		&& !z_is_thread_prevented_from_running(thread)
   47856:	7b62      	ldrb	r2, [r4, #13]
   47858:	06d2      	lsls	r2, r2, #27
   4785a:	d112      	bne.n	47882 <z_time_slice+0x6a>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
   4785c:	4a0d      	ldr	r2, [pc, #52]	; (47894 <z_time_slice+0x7c>)
   4785e:	f994 100e 	ldrsb.w	r1, [r4, #14]
   47862:	6812      	ldr	r2, [r2, #0]
   47864:	4291      	cmp	r1, r2
   47866:	db0c      	blt.n	47882 <z_time_slice+0x6a>
		&& !z_is_idle_thread_object(thread);
   47868:	4a0b      	ldr	r2, [pc, #44]	; (47898 <z_time_slice+0x80>)
   4786a:	4294      	cmp	r4, r2
   4786c:	d009      	beq.n	47882 <z_time_slice+0x6a>
		if (ticks >= _current_cpu->slice_ticks) {
   4786e:	691a      	ldr	r2, [r3, #16]
   47870:	4282      	cmp	r2, r0
   47872:	dc03      	bgt.n	4787c <z_time_slice+0x64>
		move_thread_to_end_of_prio_q(curr);
   47874:	4620      	mov	r0, r4
   47876:	f7ff fef1 	bl	4765c <move_thread_to_end_of_prio_q>
   4787a:	e7dc      	b.n	47836 <z_time_slice+0x1e>
			_current_cpu->slice_ticks -= ticks;
   4787c:	1a12      	subs	r2, r2, r0
		_current_cpu->slice_ticks = 0;
   4787e:	611a      	str	r2, [r3, #16]
   47880:	e7dc      	b.n	4783c <z_time_slice+0x24>
   47882:	2200      	movs	r2, #0
   47884:	e7fb      	b.n	4787e <z_time_slice+0x66>
   47886:	bf00      	nop
   47888:	2000694c 	.word	0x2000694c
   4788c:	2000697c 	.word	0x2000697c
   47890:	20006984 	.word	0x20006984
   47894:	20006980 	.word	0x20006980
   47898:	20003578 	.word	0x20003578

0004789c <z_pend_curr>:
{
   4789c:	b510      	push	{r4, lr}
	pending_current = _current;
   4789e:	4b07      	ldr	r3, [pc, #28]	; (478bc <z_pend_curr+0x20>)
   478a0:	6898      	ldr	r0, [r3, #8]
   478a2:	4b07      	ldr	r3, [pc, #28]	; (478c0 <z_pend_curr+0x24>)
{
   478a4:	460c      	mov	r4, r1
	pending_current = _current;
   478a6:	6018      	str	r0, [r3, #0]
{
   478a8:	4611      	mov	r1, r2
	pend(_current, wait_q, timeout);
   478aa:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   478ae:	f7ff ff5b 	bl	47768 <pend>
	ret = arch_swap(key);
   478b2:	4620      	mov	r0, r4
}
   478b4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   478b8:	f7e5 bafa 	b.w	2ceb0 <arch_swap>
   478bc:	2000694c 	.word	0x2000694c
   478c0:	2000697c 	.word	0x2000697c

000478c4 <z_set_prio>:
{
   478c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   478c6:	4604      	mov	r4, r0
	__asm__ volatile(
   478c8:	f04f 0320 	mov.w	r3, #32
   478cc:	f3ef 8611 	mrs	r6, BASEPRI
   478d0:	f383 8812 	msr	BASEPRI_MAX, r3
   478d4:	f3bf 8f6f 	isb	sy
	uint8_t state = thread->base.thread_state;
   478d8:	7b43      	ldrb	r3, [r0, #13]
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   478da:	06da      	lsls	r2, r3, #27
				thread->base.prio = prio;
   478dc:	b249      	sxtb	r1, r1
   478de:	d119      	bne.n	47914 <z_set_prio+0x50>
	return node->next != NULL;
   478e0:	6985      	ldr	r5, [r0, #24]
   478e2:	b9bd      	cbnz	r5, 47914 <z_set_prio+0x50>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   478e4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   478e8:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   478ea:	f008 fbde 	bl	500aa <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
   478ee:	7b43      	ldrb	r3, [r0, #13]
	return list->head == list;
   478f0:	4a16      	ldr	r2, [pc, #88]	; (4794c <z_set_prio+0x88>)
				thread->base.prio = prio;
   478f2:	7381      	strb	r1, [r0, #14]
	thread->base.thread_state |= _THREAD_QUEUED;
   478f4:	f063 037f 	orn	r3, r3, #127	; 0x7f
   478f8:	7343      	strb	r3, [r0, #13]
   478fa:	4613      	mov	r3, r2
   478fc:	f853 0f20 	ldr.w	r0, [r3, #32]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   47900:	4298      	cmp	r0, r3
   47902:	bf18      	it	ne
   47904:	4605      	movne	r5, r0
	return (node == list->tail) ? NULL : node->next;
   47906:	6a50      	ldr	r0, [r2, #36]	; 0x24
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   47908:	b95d      	cbnz	r5, 47922 <z_set_prio+0x5e>
	node->prev = tail;
   4790a:	e9c4 3000 	strd	r3, r0, [r4]
	tail->next = node;
   4790e:	6004      	str	r4, [r0, #0]
	list->tail = node;
   47910:	6254      	str	r4, [r2, #36]	; 0x24
}
   47912:	e011      	b.n	47938 <z_set_prio+0x74>
			thread->base.prio = prio;
   47914:	73a1      	strb	r1, [r4, #14]
   47916:	2000      	movs	r0, #0
	__asm__ volatile(
   47918:	f386 8811 	msr	BASEPRI, r6
   4791c:	f3bf 8f6f 	isb	sy
}
   47920:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	int32_t b2 = thread_2->base.prio;
   47922:	f995 700e 	ldrsb.w	r7, [r5, #14]
	if (b1 != b2) {
   47926:	42b9      	cmp	r1, r7
   47928:	d00b      	beq.n	47942 <z_set_prio+0x7e>
		if (z_sched_prio_cmp(thread, t) > 0) {
   4792a:	428f      	cmp	r7, r1
   4792c:	dd09      	ble.n	47942 <z_set_prio+0x7e>
	sys_dnode_t *const prev = successor->prev;
   4792e:	686b      	ldr	r3, [r5, #4]
	node->next = successor;
   47930:	e9c4 5300 	strd	r5, r3, [r4]
	prev->next = node;
   47934:	601c      	str	r4, [r3, #0]
	successor->prev = node;
   47936:	606c      	str	r4, [r5, #4]
			update_cache(1);
   47938:	2001      	movs	r0, #1
   4793a:	f7ff fe71 	bl	47620 <update_cache>
   4793e:	2001      	movs	r0, #1
   47940:	e7ea      	b.n	47918 <z_set_prio+0x54>
	return (node == list->tail) ? NULL : node->next;
   47942:	42a8      	cmp	r0, r5
   47944:	d0e1      	beq.n	4790a <z_set_prio+0x46>
   47946:	682d      	ldr	r5, [r5, #0]
   47948:	e7de      	b.n	47908 <z_set_prio+0x44>
   4794a:	bf00      	nop
   4794c:	2000694c 	.word	0x2000694c

00047950 <z_reschedule>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
   47950:	b949      	cbnz	r1, 47966 <z_reschedule+0x16>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   47952:	f3ef 8005 	mrs	r0, IPSR
   47956:	b930      	cbnz	r0, 47966 <z_reschedule+0x16>
	new_thread = _kernel.ready_q.cache;
   47958:	4b05      	ldr	r3, [pc, #20]	; (47970 <z_reschedule+0x20>)
	if (resched(key.key) && need_swap()) {
   4795a:	69da      	ldr	r2, [r3, #28]
   4795c:	689b      	ldr	r3, [r3, #8]
   4795e:	429a      	cmp	r2, r3
   47960:	d001      	beq.n	47966 <z_reschedule+0x16>
   47962:	f7e5 baa5 	b.w	2ceb0 <arch_swap>
   47966:	f381 8811 	msr	BASEPRI, r1
   4796a:	f3bf 8f6f 	isb	sy
}
   4796e:	4770      	bx	lr
   47970:	2000694c 	.word	0x2000694c

00047974 <z_sched_start>:
{
   47974:	b510      	push	{r4, lr}
	__asm__ volatile(
   47976:	f04f 0220 	mov.w	r2, #32
   4797a:	f3ef 8411 	mrs	r4, BASEPRI
   4797e:	f382 8812 	msr	BASEPRI_MAX, r2
   47982:	f3bf 8f6f 	isb	sy
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
   47986:	7b42      	ldrb	r2, [r0, #13]
	if (z_has_thread_started(thread)) {
   47988:	0751      	lsls	r1, r2, #29
   4798a:	d404      	bmi.n	47996 <z_sched_start+0x22>
	__asm__ volatile(
   4798c:	f384 8811 	msr	BASEPRI, r4
   47990:	f3bf 8f6f 	isb	sy
}
   47994:	bd10      	pop	{r4, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
   47996:	f022 0204 	bic.w	r2, r2, #4
   4799a:	7342      	strb	r2, [r0, #13]
	ready_thread(thread);
   4799c:	f7ff fe98 	bl	476d0 <ready_thread>
	z_reschedule(&sched_spinlock, key);
   479a0:	4621      	mov	r1, r4
   479a2:	4802      	ldr	r0, [pc, #8]	; (479ac <z_sched_start+0x38>)
}
   479a4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule(&sched_spinlock, key);
   479a8:	f7ff bfd2 	b.w	47950 <z_reschedule>
   479ac:	20006bc5 	.word	0x20006bc5

000479b0 <z_impl_k_thread_suspend>:
{
   479b0:	b570      	push	{r4, r5, r6, lr}
   479b2:	4604      	mov	r4, r0
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
   479b4:	3018      	adds	r0, #24
   479b6:	f008 fc8d 	bl	502d4 <z_abort_timeout>
	__asm__ volatile(
   479ba:	f04f 0320 	mov.w	r3, #32
   479be:	f3ef 8611 	mrs	r6, BASEPRI
   479c2:	f383 8812 	msr	BASEPRI_MAX, r3
   479c6:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
   479ca:	f994 200d 	ldrsb.w	r2, [r4, #13]
	return (thread->base.thread_state & state) != 0U;
   479ce:	7b63      	ldrb	r3, [r4, #13]
   479d0:	2a00      	cmp	r2, #0
   479d2:	da05      	bge.n	479e0 <z_impl_k_thread_suspend+0x30>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   479d4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   479d8:	7363      	strb	r3, [r4, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   479da:	4620      	mov	r0, r4
   479dc:	f008 fb65 	bl	500aa <sys_dlist_remove>
		update_cache(thread == _current);
   479e0:	4d0b      	ldr	r5, [pc, #44]	; (47a10 <z_impl_k_thread_suspend+0x60>)
	thread->base.thread_state |= _THREAD_SUSPENDED;
   479e2:	7b63      	ldrb	r3, [r4, #13]
   479e4:	68a8      	ldr	r0, [r5, #8]
   479e6:	f043 0310 	orr.w	r3, r3, #16
   479ea:	7363      	strb	r3, [r4, #13]
   479ec:	1b03      	subs	r3, r0, r4
   479ee:	4258      	negs	r0, r3
   479f0:	4158      	adcs	r0, r3
   479f2:	f7ff fe15 	bl	47620 <update_cache>
	__asm__ volatile(
   479f6:	f386 8811 	msr	BASEPRI, r6
   479fa:	f3bf 8f6f 	isb	sy
	if (thread == _current) {
   479fe:	68ab      	ldr	r3, [r5, #8]
   47a00:	42a3      	cmp	r3, r4
   47a02:	d103      	bne.n	47a0c <z_impl_k_thread_suspend+0x5c>
}
   47a04:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule_unlocked();
   47a08:	f008 bc27 	b.w	5025a <z_reschedule_unlocked>
}
   47a0c:	bd70      	pop	{r4, r5, r6, pc}
   47a0e:	bf00      	nop
   47a10:	2000694c 	.word	0x2000694c

00047a14 <k_sched_lock>:
	__asm__ volatile(
   47a14:	f04f 0320 	mov.w	r3, #32
   47a18:	f3ef 8111 	mrs	r1, BASEPRI
   47a1c:	f383 8812 	msr	BASEPRI_MAX, r3
   47a20:	f3bf 8f6f 	isb	sy
	--_current->base.sched_locked;
   47a24:	4b04      	ldr	r3, [pc, #16]	; (47a38 <k_sched_lock+0x24>)
   47a26:	689a      	ldr	r2, [r3, #8]
   47a28:	7bd3      	ldrb	r3, [r2, #15]
   47a2a:	3b01      	subs	r3, #1
   47a2c:	73d3      	strb	r3, [r2, #15]
	__asm__ volatile(
   47a2e:	f381 8811 	msr	BASEPRI, r1
   47a32:	f3bf 8f6f 	isb	sy
}
   47a36:	4770      	bx	lr
   47a38:	2000694c 	.word	0x2000694c

00047a3c <k_sched_unlock>:
{
   47a3c:	b510      	push	{r4, lr}
	__asm__ volatile(
   47a3e:	f04f 0320 	mov.w	r3, #32
   47a42:	f3ef 8411 	mrs	r4, BASEPRI
   47a46:	f383 8812 	msr	BASEPRI_MAX, r3
   47a4a:	f3bf 8f6f 	isb	sy
		++_current->base.sched_locked;
   47a4e:	4b08      	ldr	r3, [pc, #32]	; (47a70 <k_sched_unlock+0x34>)
   47a50:	689a      	ldr	r2, [r3, #8]
   47a52:	7bd3      	ldrb	r3, [r2, #15]
   47a54:	3301      	adds	r3, #1
   47a56:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
   47a58:	2000      	movs	r0, #0
   47a5a:	f7ff fde1 	bl	47620 <update_cache>
	__asm__ volatile(
   47a5e:	f384 8811 	msr	BASEPRI, r4
   47a62:	f3bf 8f6f 	isb	sy
}
   47a66:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule_unlocked();
   47a6a:	f008 bbf6 	b.w	5025a <z_reschedule_unlocked>
   47a6e:	bf00      	nop
   47a70:	2000694c 	.word	0x2000694c

00047a74 <z_sched_init>:
	list->head = (sys_dnode_t *)list;
   47a74:	4b04      	ldr	r3, [pc, #16]	; (47a88 <z_sched_init+0x14>)
#else
	init_ready_q(&_kernel.ready_q);
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
   47a76:	2100      	movs	r1, #0
   47a78:	f103 0220 	add.w	r2, r3, #32
	list->tail = (sys_dnode_t *)list;
   47a7c:	e9c3 2208 	strd	r2, r2, [r3, #32]
   47a80:	4608      	mov	r0, r1
   47a82:	f7ff be97 	b.w	477b4 <k_sched_time_slice_set>
   47a86:	bf00      	nop
   47a88:	2000694c 	.word	0x2000694c

00047a8c <z_impl_k_yield>:
	return !(k_is_pre_kernel() || k_is_in_isr() ||
		 z_is_idle_thread_object(_current));
}

void z_impl_k_yield(void)
{
   47a8c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	__asm__ volatile(
   47a8e:	f04f 0320 	mov.w	r3, #32
   47a92:	f3ef 8511 	mrs	r5, BASEPRI
   47a96:	f383 8812 	msr	BASEPRI_MAX, r3
   47a9a:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if (!IS_ENABLED(CONFIG_SMP) ||
	    z_is_thread_queued(_current)) {
		dequeue_thread(_current);
   47a9e:	4919      	ldr	r1, [pc, #100]	; (47b04 <z_impl_k_yield+0x78>)
   47aa0:	6888      	ldr	r0, [r1, #8]
	thread->base.thread_state &= ~_THREAD_QUEUED;
   47aa2:	7b43      	ldrb	r3, [r0, #13]
   47aa4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   47aa8:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   47aaa:	f008 fafe 	bl	500aa <sys_dlist_remove>
	}
	queue_thread(_current);
   47aae:	688b      	ldr	r3, [r1, #8]
	thread->base.thread_state |= _THREAD_QUEUED;
   47ab0:	7b5a      	ldrb	r2, [r3, #13]
	return list->head == list;
   47ab2:	4608      	mov	r0, r1
   47ab4:	f062 027f 	orn	r2, r2, #127	; 0x7f
   47ab8:	735a      	strb	r2, [r3, #13]
   47aba:	f850 2f20 	ldr.w	r2, [r0, #32]!
	return (node == list->tail) ? NULL : node->next;
   47abe:	6a4c      	ldr	r4, [r1, #36]	; 0x24
	return sys_dlist_is_empty(list) ? NULL : list->head;
   47ac0:	4282      	cmp	r2, r0
   47ac2:	bf08      	it	eq
   47ac4:	2200      	moveq	r2, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   47ac6:	b922      	cbnz	r2, 47ad2 <z_impl_k_yield+0x46>
	node->prev = tail;
   47ac8:	e9c3 0400 	strd	r0, r4, [r3]
	tail->next = node;
   47acc:	6023      	str	r3, [r4, #0]
	list->tail = node;
   47ace:	624b      	str	r3, [r1, #36]	; 0x24
}
   47ad0:	e00c      	b.n	47aec <z_impl_k_yield+0x60>
	int32_t b1 = thread_1->base.prio;
   47ad2:	f993 600e 	ldrsb.w	r6, [r3, #14]
	int32_t b2 = thread_2->base.prio;
   47ad6:	f992 700e 	ldrsb.w	r7, [r2, #14]
	if (b1 != b2) {
   47ada:	42be      	cmp	r6, r7
   47adc:	d00e      	beq.n	47afc <z_impl_k_yield+0x70>
		if (z_sched_prio_cmp(thread, t) > 0) {
   47ade:	42b7      	cmp	r7, r6
   47ae0:	dd0c      	ble.n	47afc <z_impl_k_yield+0x70>
	sys_dnode_t *const prev = successor->prev;
   47ae2:	6851      	ldr	r1, [r2, #4]
	node->next = successor;
   47ae4:	e9c3 2100 	strd	r2, r1, [r3]
	prev->next = node;
   47ae8:	600b      	str	r3, [r1, #0]
	successor->prev = node;
   47aea:	6053      	str	r3, [r2, #4]
	update_cache(1);
   47aec:	2001      	movs	r0, #1
   47aee:	f7ff fd97 	bl	47620 <update_cache>
   47af2:	4628      	mov	r0, r5
	z_swap(&sched_spinlock, key);
}
   47af4:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   47af8:	f7e5 b9da 	b.w	2ceb0 <arch_swap>
	return (node == list->tail) ? NULL : node->next;
   47afc:	42a2      	cmp	r2, r4
   47afe:	d0e3      	beq.n	47ac8 <z_impl_k_yield+0x3c>
   47b00:	6812      	ldr	r2, [r2, #0]
   47b02:	e7e0      	b.n	47ac6 <z_impl_k_yield+0x3a>
   47b04:	2000694c 	.word	0x2000694c

00047b08 <z_tick_sleep>:
	 */
	LOG_DBG("thread %p for %u ticks", _current, ticks);
#endif

	/* wait of 0 ms is treated as a 'yield' */
	if (ticks == 0) {
   47b08:	ea50 0301 	orrs.w	r3, r0, r1
{
   47b0c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   47b10:	4605      	mov	r5, r0
   47b12:	460e      	mov	r6, r1
	if (ticks == 0) {
   47b14:	d103      	bne.n	47b1e <z_tick_sleep+0x16>
	z_impl_k_yield();
   47b16:	f7ff ffb9 	bl	47a8c <z_impl_k_yield>
		k_yield();
		return 0;
   47b1a:	2000      	movs	r0, #0
   47b1c:	e02c      	b.n	47b78 <z_tick_sleep+0x70>
	}

	k_timeout_t timeout = Z_TIMEOUT_TICKS(ticks);
	if (Z_TICK_ABS(ticks) <= 0) {
   47b1e:	1c83      	adds	r3, r0, #2
   47b20:	f171 33ff 	sbcs.w	r3, r1, #4294967295	; 0xffffffff
   47b24:	db2a      	blt.n	47b7c <z_tick_sleep+0x74>
		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
   47b26:	f008 fc17 	bl	50358 <sys_clock_tick_get_32>
   47b2a:	1944      	adds	r4, r0, r5
   47b2c:	f04f 0320 	mov.w	r3, #32
   47b30:	f3ef 8811 	mrs	r8, BASEPRI
   47b34:	f383 8812 	msr	BASEPRI_MAX, r3
   47b38:	f3bf 8f6f 	isb	sy
	}

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

#if defined(CONFIG_TIMESLICING) && defined(CONFIG_SWAP_NONATOMIC)
	pending_current = _current;
   47b3c:	4f11      	ldr	r7, [pc, #68]	; (47b84 <z_tick_sleep+0x7c>)
   47b3e:	4b12      	ldr	r3, [pc, #72]	; (47b88 <z_tick_sleep+0x80>)
   47b40:	68b8      	ldr	r0, [r7, #8]
   47b42:	6018      	str	r0, [r3, #0]
#endif
	unready_thread(_current);
   47b44:	f7ff fdf8 	bl	47738 <unready_thread>
	z_add_thread_timeout(_current, timeout);
   47b48:	68b8      	ldr	r0, [r7, #8]
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
   47b4a:	4910      	ldr	r1, [pc, #64]	; (47b8c <z_tick_sleep+0x84>)
   47b4c:	462a      	mov	r2, r5
   47b4e:	4633      	mov	r3, r6
   47b50:	3018      	adds	r0, #24
   47b52:	f000 f917 	bl	47d84 <z_add_timeout>
	z_mark_thread_as_suspended(_current);
   47b56:	68ba      	ldr	r2, [r7, #8]
	thread->base.thread_state |= _THREAD_SUSPENDED;
   47b58:	7b53      	ldrb	r3, [r2, #13]
   47b5a:	f043 0310 	orr.w	r3, r3, #16
   47b5e:	7353      	strb	r3, [r2, #13]
   47b60:	4640      	mov	r0, r8
   47b62:	f7e5 f9a5 	bl	2ceb0 <arch_swap>

	(void)z_swap(&sched_spinlock, key);

	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");

	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
   47b66:	f008 fbf7 	bl	50358 <sys_clock_tick_get_32>
   47b6a:	1a20      	subs	r0, r4, r0
   47b6c:	eb63 0303 	sbc.w	r3, r3, r3
	if (ticks > 0) {
   47b70:	2801      	cmp	r0, #1
   47b72:	f173 0300 	sbcs.w	r3, r3, #0
   47b76:	dbd0      	blt.n	47b1a <z_tick_sleep+0x12>
		return ticks;
	}
#endif

	return 0;
}
   47b78:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		expected_wakeup_ticks = Z_TICK_ABS(ticks);
   47b7c:	f06f 0401 	mvn.w	r4, #1
   47b80:	1a24      	subs	r4, r4, r0
   47b82:	e7d3      	b.n	47b2c <z_tick_sleep+0x24>
   47b84:	2000694c 	.word	0x2000694c
   47b88:	2000697c 	.word	0x2000697c
   47b8c:	000500e1 	.word	0x000500e1

00047b90 <z_impl_k_sleep>:
	__ASSERT(!arch_is_in_isr(), "");

	SYS_PORT_TRACING_FUNC_ENTER(k_thread, sleep, timeout);

	/* in case of K_FOREVER, we suspend */
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   47b90:	f1b1 3fff 	cmp.w	r1, #4294967295	; 0xffffffff
   47b94:	bf08      	it	eq
   47b96:	f1b0 3fff 	cmpeq.w	r0, #4294967295	; 0xffffffff
{
   47b9a:	b508      	push	{r3, lr}
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   47b9c:	d106      	bne.n	47bac <z_impl_k_sleep+0x1c>
		k_thread_suspend(_current);
   47b9e:	4b08      	ldr	r3, [pc, #32]	; (47bc0 <z_impl_k_sleep+0x30>)
   47ba0:	6898      	ldr	r0, [r3, #8]
	z_impl_k_thread_suspend(thread);
   47ba2:	f7ff ff05 	bl	479b0 <z_impl_k_thread_suspend>

		SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, (int32_t) K_TICKS_FOREVER);

		return (int32_t) K_TICKS_FOREVER;
   47ba6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	int32_t ret = k_ticks_to_ms_floor64(ticks);

	SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, ret);

	return ret;
}
   47baa:	bd08      	pop	{r3, pc}
	ticks = z_tick_sleep(ticks);
   47bac:	f7ff ffac 	bl	47b08 <z_tick_sleep>
			return ((t * to_hz + off) / from_hz);
   47bb0:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   47bb4:	fb80 0303 	smull	r0, r3, r0, r3
   47bb8:	0bc0      	lsrs	r0, r0, #15
   47bba:	ea40 4043 	orr.w	r0, r0, r3, lsl #17
	return ret;
   47bbe:	e7f4      	b.n	47baa <z_impl_k_sleep+0x1a>
   47bc0:	2000694c 	.word	0x2000694c

00047bc4 <z_impl_z_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
   47bc4:	4b01      	ldr	r3, [pc, #4]	; (47bcc <z_impl_z_current_get+0x8>)
   47bc6:	6898      	ldr	r0, [r3, #8]
   47bc8:	4770      	bx	lr
   47bca:	bf00      	nop
   47bcc:	2000694c 	.word	0x2000694c

00047bd0 <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
   47bd0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   47bd4:	4604      	mov	r4, r0
   47bd6:	f04f 0320 	mov.w	r3, #32
   47bda:	f3ef 8611 	mrs	r6, BASEPRI
   47bde:	f383 8812 	msr	BASEPRI_MAX, r3
   47be2:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.user_options & K_ESSENTIAL) != 0) {
   47be6:	7b03      	ldrb	r3, [r0, #12]
   47be8:	07d9      	lsls	r1, r3, #31
   47bea:	d50b      	bpl.n	47c04 <z_thread_abort+0x34>
	__asm__ volatile(
   47bec:	f386 8811 	msr	BASEPRI, r6
   47bf0:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&sched_spinlock, key);
		__ASSERT(false, "aborting essential thread %p", thread);
		k_panic();
   47bf4:	4040      	eors	r0, r0
   47bf6:	f380 8811 	msr	BASEPRI, r0
   47bfa:	f04f 0004 	mov.w	r0, #4
   47bfe:	df02      	svc	2
	if (thread == _current && !arch_is_in_isr()) {
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
	}
	k_spin_unlock(&sched_spinlock, key);
}
   47c00:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
   47c04:	7b43      	ldrb	r3, [r0, #13]
   47c06:	071a      	lsls	r2, r3, #28
   47c08:	d504      	bpl.n	47c14 <z_thread_abort+0x44>
   47c0a:	f386 8811 	msr	BASEPRI, r6
   47c0e:	f3bf 8f6f 	isb	sy
   47c12:	e7f5      	b.n	47c00 <z_thread_abort+0x30>
		thread->base.thread_state &= ~_THREAD_ABORTING;
   47c14:	f023 0220 	bic.w	r2, r3, #32
   47c18:	f042 0108 	orr.w	r1, r2, #8
		if (z_is_thread_queued(thread)) {
   47c1c:	09d2      	lsrs	r2, r2, #7
   47c1e:	d120      	bne.n	47c62 <z_thread_abort+0x92>
		thread->base.thread_state &= ~_THREAD_ABORTING;
   47c20:	7341      	strb	r1, [r0, #13]
		if (thread->base.pended_on != NULL) {
   47c22:	68a3      	ldr	r3, [r4, #8]
   47c24:	b113      	cbz	r3, 47c2c <z_thread_abort+0x5c>
			unpend_thread_no_timeout(thread);
   47c26:	4620      	mov	r0, r4
   47c28:	f008 fa47 	bl	500ba <unpend_thread_no_timeout>
	return z_abort_timeout(&thread->base.timeout);
   47c2c:	f104 0018 	add.w	r0, r4, #24
   47c30:	f008 fb50 	bl	502d4 <z_abort_timeout>
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
   47c34:	f104 0758 	add.w	r7, r4, #88	; 0x58
   47c38:	f04f 0800 	mov.w	r8, #0
	return list->head == list;
   47c3c:	6da5      	ldr	r5, [r4, #88]	; 0x58
	return sys_dlist_is_empty(list) ? NULL : list->head;
   47c3e:	42bd      	cmp	r5, r7
   47c40:	d000      	beq.n	47c44 <z_thread_abort+0x74>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
   47c42:	b9b5      	cbnz	r5, 47c72 <z_thread_abort+0xa2>
		update_cache(1);
   47c44:	2001      	movs	r0, #1
   47c46:	f7ff fceb 	bl	47620 <update_cache>
	if (thread == _current && !arch_is_in_isr()) {
   47c4a:	4b10      	ldr	r3, [pc, #64]	; (47c8c <z_thread_abort+0xbc>)
   47c4c:	689b      	ldr	r3, [r3, #8]
   47c4e:	42a3      	cmp	r3, r4
   47c50:	d1db      	bne.n	47c0a <z_thread_abort+0x3a>
   47c52:	f3ef 8305 	mrs	r3, IPSR
   47c56:	2b00      	cmp	r3, #0
   47c58:	d1d7      	bne.n	47c0a <z_thread_abort+0x3a>
   47c5a:	4630      	mov	r0, r6
   47c5c:	f7e5 f928 	bl	2ceb0 <arch_swap>
	return ret;
   47c60:	e7d3      	b.n	47c0a <z_thread_abort+0x3a>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   47c62:	f003 035f 	and.w	r3, r3, #95	; 0x5f
   47c66:	f043 0308 	orr.w	r3, r3, #8
   47c6a:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   47c6c:	f008 fa1d 	bl	500aa <sys_dlist_remove>
}
   47c70:	e7d7      	b.n	47c22 <z_thread_abort+0x52>
		unpend_thread_no_timeout(thread);
   47c72:	4628      	mov	r0, r5
   47c74:	f008 fa21 	bl	500ba <unpend_thread_no_timeout>
   47c78:	f105 0018 	add.w	r0, r5, #24
   47c7c:	f008 fb2a 	bl	502d4 <z_abort_timeout>
   47c80:	f8c5 807c 	str.w	r8, [r5, #124]	; 0x7c
		ready_thread(thread);
   47c84:	4628      	mov	r0, r5
   47c86:	f7ff fd23 	bl	476d0 <ready_thread>
   47c8a:	e7d7      	b.n	47c3c <z_thread_abort+0x6c>
   47c8c:	2000694c 	.word	0x2000694c

00047c90 <z_sched_wait>:
	return ret;
}

int z_sched_wait(struct k_spinlock *lock, k_spinlock_key_t key,
		 _wait_q_t *wait_q, k_timeout_t timeout, void **data)
{
   47c90:	b5d3      	push	{r0, r1, r4, r6, r7, lr}
	int ret = z_pend_curr(lock, key, wait_q, timeout);
   47c92:	e9dd 6706 	ldrd	r6, r7, [sp, #24]
{
   47c96:	9c08      	ldr	r4, [sp, #32]
	int ret = z_pend_curr(lock, key, wait_q, timeout);
   47c98:	e9cd 6700 	strd	r6, r7, [sp]
   47c9c:	f7ff fdfe 	bl	4789c <z_pend_curr>

	if (data != NULL) {
   47ca0:	b11c      	cbz	r4, 47caa <z_sched_wait+0x1a>
		*data = _current->base.swap_data;
   47ca2:	4b03      	ldr	r3, [pc, #12]	; (47cb0 <z_sched_wait+0x20>)
   47ca4:	689b      	ldr	r3, [r3, #8]
   47ca6:	695b      	ldr	r3, [r3, #20]
   47ca8:	6023      	str	r3, [r4, #0]
	}
	return ret;
}
   47caa:	b002      	add	sp, #8
   47cac:	bdd0      	pop	{r4, r6, r7, pc}
   47cae:	bf00      	nop
   47cb0:	2000694c 	.word	0x2000694c

00047cb4 <z_data_copy>:
 * @brief Copy the data section from ROM to RAM
 *
 * This routine copies the data section from ROM to RAM.
 */
void z_data_copy(void)
{
   47cb4:	b508      	push	{r3, lr}
	z_early_memcpy(&__data_region_start, &__data_region_load_start,
		       __data_region_end - __data_region_start);
   47cb6:	4806      	ldr	r0, [pc, #24]	; (47cd0 <z_data_copy+0x1c>)
	z_early_memcpy(&__data_region_start, &__data_region_load_start,
   47cb8:	4a06      	ldr	r2, [pc, #24]	; (47cd4 <z_data_copy+0x20>)
   47cba:	4907      	ldr	r1, [pc, #28]	; (47cd8 <z_data_copy+0x24>)
   47cbc:	1a12      	subs	r2, r2, r0
   47cbe:	f007 ff15 	bl	4faec <z_early_memcpy>
#else
	z_early_memcpy(&_app_smem_start, &_app_smem_rom_start,
		       _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
   47cc2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_early_memcpy(&__ramfunc_start, &__ramfunc_load_start,
   47cc6:	4a05      	ldr	r2, [pc, #20]	; (47cdc <z_data_copy+0x28>)
   47cc8:	4905      	ldr	r1, [pc, #20]	; (47ce0 <z_data_copy+0x2c>)
   47cca:	4806      	ldr	r0, [pc, #24]	; (47ce4 <z_data_copy+0x30>)
   47ccc:	f007 bf0e 	b.w	4faec <z_early_memcpy>
   47cd0:	20000000 	.word	0x20000000
   47cd4:	20001498 	.word	0x20001498
   47cd8:	00053984 	.word	0x00053984
   47cdc:	00000000 	.word	0x00000000
   47ce0:	00053984 	.word	0x00053984
   47ce4:	20000000 	.word	0x20000000

00047ce8 <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
   47ce8:	4b03      	ldr	r3, [pc, #12]	; (47cf8 <elapsed+0x10>)
   47cea:	681b      	ldr	r3, [r3, #0]
   47cec:	b90b      	cbnz	r3, 47cf2 <elapsed+0xa>
   47cee:	f7fc bf75 	b.w	44bdc <sys_clock_elapsed>
}
   47cf2:	2000      	movs	r0, #0
   47cf4:	4770      	bx	lr
   47cf6:	bf00      	nop
   47cf8:	20006988 	.word	0x20006988

00047cfc <next_timeout>:

static int32_t next_timeout(void)
{
   47cfc:	b510      	push	{r4, lr}
	return list->head == list;
   47cfe:	4b11      	ldr	r3, [pc, #68]	; (47d44 <next_timeout+0x48>)
   47d00:	681c      	ldr	r4, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   47d02:	429c      	cmp	r4, r3
   47d04:	d10a      	bne.n	47d1c <next_timeout+0x20>
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
   47d06:	f7ff ffef 	bl	47ce8 <elapsed>
	int32_t ret;

	if ((to == NULL) ||
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
		ret = MAX_WAIT;
   47d0a:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
	} else {
		ret = MAX(0, to->dticks - ticks_elapsed);
	}

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
   47d0e:	4b0e      	ldr	r3, [pc, #56]	; (47d48 <next_timeout+0x4c>)
   47d10:	691b      	ldr	r3, [r3, #16]
   47d12:	b113      	cbz	r3, 47d1a <next_timeout+0x1e>
   47d14:	4298      	cmp	r0, r3
   47d16:	bfa8      	it	ge
   47d18:	4618      	movge	r0, r3
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
   47d1a:	bd10      	pop	{r4, pc}
	int32_t ticks_elapsed = elapsed();
   47d1c:	f7ff ffe4 	bl	47ce8 <elapsed>
	if ((to == NULL) ||
   47d20:	2c00      	cmp	r4, #0
   47d22:	d0f2      	beq.n	47d0a <next_timeout+0xe>
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
   47d24:	e9d4 3204 	ldrd	r3, r2, [r4, #16]
   47d28:	1a1b      	subs	r3, r3, r0
   47d2a:	eb62 72e0 	sbc.w	r2, r2, r0, asr #31
	if ((to == NULL) ||
   47d2e:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
   47d32:	f172 0100 	sbcs.w	r1, r2, #0
   47d36:	dae8      	bge.n	47d0a <next_timeout+0xe>
		ret = MAX(0, to->dticks - ticks_elapsed);
   47d38:	2a00      	cmp	r2, #0
   47d3a:	bfac      	ite	ge
   47d3c:	4618      	movge	r0, r3
   47d3e:	2000      	movlt	r0, #0
   47d40:	e7e5      	b.n	47d0e <next_timeout+0x12>
   47d42:	bf00      	nop
   47d44:	20000e68 	.word	0x20000e68
   47d48:	2000694c 	.word	0x2000694c

00047d4c <remove_timeout>:
{
   47d4c:	b530      	push	{r4, r5, lr}
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   47d4e:	b170      	cbz	r0, 47d6e <remove_timeout+0x22>
	return (node == list->tail) ? NULL : node->next;
   47d50:	4b0b      	ldr	r3, [pc, #44]	; (47d80 <remove_timeout+0x34>)
   47d52:	685b      	ldr	r3, [r3, #4]
   47d54:	4298      	cmp	r0, r3
   47d56:	d00a      	beq.n	47d6e <remove_timeout+0x22>
   47d58:	6803      	ldr	r3, [r0, #0]
	if (next(t) != NULL) {
   47d5a:	b143      	cbz	r3, 47d6e <remove_timeout+0x22>
		next(t)->dticks += t->dticks;
   47d5c:	e9d3 2104 	ldrd	r2, r1, [r3, #16]
   47d60:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
   47d64:	1912      	adds	r2, r2, r4
   47d66:	eb41 0105 	adc.w	r1, r1, r5
   47d6a:	e9c3 2104 	strd	r2, r1, [r3, #16]
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
	sys_dnode_t *const next = node->next;
   47d6e:	e9d0 3200 	ldrd	r3, r2, [r0]

	prev->next = next;
   47d72:	6013      	str	r3, [r2, #0]
	next->prev = prev;
   47d74:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   47d76:	2300      	movs	r3, #0
	node->prev = NULL;
   47d78:	e9c0 3300 	strd	r3, r3, [r0]
}
   47d7c:	bd30      	pop	{r4, r5, pc}
   47d7e:	bf00      	nop
   47d80:	20000e68 	.word	0x20000e68

00047d84 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   47d84:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   47d88:	bf08      	it	eq
   47d8a:	f1b2 3fff 	cmpeq.w	r2, #4294967295	; 0xffffffff
{
   47d8e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   47d90:	4604      	mov	r4, r0
   47d92:	461d      	mov	r5, r3
   47d94:	4616      	mov	r6, r2
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   47d96:	d061      	beq.n	47e5c <z_add_timeout+0xd8>
#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
   47d98:	6081      	str	r1, [r0, #8]
	__asm__ volatile(
   47d9a:	f04f 0320 	mov.w	r3, #32
   47d9e:	f3ef 8711 	mrs	r7, BASEPRI
   47da2:	f383 8812 	msr	BASEPRI_MAX, r3
   47da6:	f3bf 8f6f 	isb	sy

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
   47daa:	3201      	adds	r2, #1
   47dac:	f175 33ff 	sbcs.w	r3, r5, #4294967295	; 0xffffffff
   47db0:	da24      	bge.n	47dfc <z_add_timeout+0x78>
		    Z_TICK_ABS(timeout.ticks) >= 0) {
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
   47db2:	4930      	ldr	r1, [pc, #192]	; (47e74 <z_add_timeout+0xf0>)
   47db4:	e9d1 2000 	ldrd	r2, r0, [r1]
   47db8:	f06f 0301 	mvn.w	r3, #1
   47dbc:	1a9b      	subs	r3, r3, r2
   47dbe:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   47dc2:	eb62 0000 	sbc.w	r0, r2, r0
   47dc6:	1b9e      	subs	r6, r3, r6
   47dc8:	eb60 0005 	sbc.w	r0, r0, r5

			to->dticks = MAX(1, ticks);
   47dcc:	2e01      	cmp	r6, #1
   47dce:	f170 0300 	sbcs.w	r3, r0, #0
   47dd2:	da01      	bge.n	47dd8 <z_add_timeout+0x54>
   47dd4:	2601      	movs	r6, #1
   47dd6:	2000      	movs	r0, #0
   47dd8:	e9c4 6004 	strd	r6, r0, [r4, #16]
	return list->head == list;
   47ddc:	4e26      	ldr	r6, [pc, #152]	; (47e78 <z_add_timeout+0xf4>)
   47dde:	f8d6 c000 	ldr.w	ip, [r6]
	return (node == list->tail) ? NULL : node->next;
   47de2:	6875      	ldr	r5, [r6, #4]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   47de4:	45b4      	cmp	ip, r6
   47de6:	bf08      	it	eq
   47de8:	f04f 0c00 	moveq.w	ip, #0
		} else {
			to->dticks = timeout.ticks + 1 + elapsed();
		}

		for (t = first(); t != NULL; t = next(t)) {
   47dec:	f1bc 0f00 	cmp.w	ip, #0
   47df0:	d10d      	bne.n	47e0e <z_add_timeout+0x8a>
	node->prev = tail;
   47df2:	e9c4 6500 	strd	r6, r5, [r4]
	tail->next = node;
   47df6:	602c      	str	r4, [r5, #0]
	list->tail = node;
   47df8:	6074      	str	r4, [r6, #4]
}
   47dfa:	e01c      	b.n	47e36 <z_add_timeout+0xb2>
			to->dticks = timeout.ticks + 1 + elapsed();
   47dfc:	f7ff ff74 	bl	47ce8 <elapsed>
   47e00:	3601      	adds	r6, #1
   47e02:	f145 0500 	adc.w	r5, r5, #0
   47e06:	1836      	adds	r6, r6, r0
   47e08:	eb45 70e0 	adc.w	r0, r5, r0, asr #31
   47e0c:	e7e4      	b.n	47dd8 <z_add_timeout+0x54>
			if (t->dticks > to->dticks) {
   47e0e:	e9dc 2004 	ldrd	r2, r0, [ip, #16]
   47e12:	e9d4 3104 	ldrd	r3, r1, [r4, #16]
   47e16:	4293      	cmp	r3, r2
   47e18:	eb71 0e00 	sbcs.w	lr, r1, r0
   47e1c:	da1f      	bge.n	47e5e <z_add_timeout+0xda>
				t->dticks -= to->dticks;
   47e1e:	1ad2      	subs	r2, r2, r3
	sys_dnode_t *const prev = successor->prev;
   47e20:	f8dc 3004 	ldr.w	r3, [ip, #4]
   47e24:	eb60 0001 	sbc.w	r0, r0, r1
   47e28:	e9cc 2004 	strd	r2, r0, [ip, #16]
	node->next = successor;
   47e2c:	e9c4 c300 	strd	ip, r3, [r4]
	prev->next = node;
   47e30:	601c      	str	r4, [r3, #0]
	successor->prev = node;
   47e32:	f8cc 4004 	str.w	r4, [ip, #4]
	return list->head == list;
   47e36:	6833      	ldr	r3, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   47e38:	42b3      	cmp	r3, r6
   47e3a:	d00b      	beq.n	47e54 <z_add_timeout+0xd0>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
   47e3c:	429c      	cmp	r4, r3
   47e3e:	d109      	bne.n	47e54 <z_add_timeout+0xd0>
			 * last announcement, and slice_ticks is based
			 * on that. It means that the time remaining for
			 * the next announcement can be less than
			 * slice_ticks.
			 */
			int32_t next_time = next_timeout();
   47e40:	f7ff ff5c 	bl	47cfc <next_timeout>

			if (next_time == 0 ||
   47e44:	b118      	cbz	r0, 47e4e <z_add_timeout+0xca>
			    _current_cpu->slice_ticks != next_time) {
   47e46:	4b0d      	ldr	r3, [pc, #52]	; (47e7c <z_add_timeout+0xf8>)
			if (next_time == 0 ||
   47e48:	691b      	ldr	r3, [r3, #16]
   47e4a:	4283      	cmp	r3, r0
   47e4c:	d002      	beq.n	47e54 <z_add_timeout+0xd0>
				sys_clock_set_timeout(next_time, false);
   47e4e:	2100      	movs	r1, #0
   47e50:	f7fc fe92 	bl	44b78 <sys_clock_set_timeout>
	__asm__ volatile(
   47e54:	f387 8811 	msr	BASEPRI, r7
   47e58:	f3bf 8f6f 	isb	sy
#else
			sys_clock_set_timeout(next_timeout(), false);
#endif	/* CONFIG_TIMESLICING */
		}
	}
}
   47e5c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			to->dticks -= t->dticks;
   47e5e:	1a9b      	subs	r3, r3, r2
   47e60:	eb61 0100 	sbc.w	r1, r1, r0
	return (node == list->tail) ? NULL : node->next;
   47e64:	45ac      	cmp	ip, r5
   47e66:	e9c4 3104 	strd	r3, r1, [r4, #16]
   47e6a:	d0c2      	beq.n	47df2 <z_add_timeout+0x6e>
   47e6c:	f8dc c000 	ldr.w	ip, [ip]
   47e70:	e7bc      	b.n	47dec <z_add_timeout+0x68>
   47e72:	bf00      	nop
   47e74:	20003718 	.word	0x20003718
   47e78:	20000e68 	.word	0x20000e68
   47e7c:	2000694c 	.word	0x2000694c

00047e80 <sys_clock_announce>:
		}
	}
}

void sys_clock_announce(int32_t ticks)
{
   47e80:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   47e84:	4604      	mov	r4, r0
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
   47e86:	f7ff fcc7 	bl	47818 <z_time_slice>
	__asm__ volatile(
   47e8a:	f04f 0320 	mov.w	r3, #32
   47e8e:	f3ef 8611 	mrs	r6, BASEPRI
   47e92:	f383 8812 	msr	BASEPRI_MAX, r3
   47e96:	f3bf 8f6f 	isb	sy
		announce_remaining += ticks;
		k_spin_unlock(&timeout_lock, key);
		return;
	}

	announce_remaining = ticks;
   47e9a:	4f23      	ldr	r7, [pc, #140]	; (47f28 <sys_clock_announce+0xa8>)
	return list->head == list;
   47e9c:	f8df 808c 	ldr.w	r8, [pc, #140]	; 47f2c <sys_clock_announce+0xac>
   47ea0:	f8d8 0000 	ldr.w	r0, [r8]

	while (first() != NULL && first()->dticks <= announce_remaining) {
		struct _timeout *t = first();
		int dt = t->dticks;

		curr_tick += dt;
   47ea4:	4a22      	ldr	r2, [pc, #136]	; (47f30 <sys_clock_announce+0xb0>)
	announce_remaining = ticks;
   47ea6:	603c      	str	r4, [r7, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   47ea8:	4540      	cmp	r0, r8
		curr_tick += dt;
   47eaa:	e9d2 3e00 	ldrd	r3, lr, [r2]
   47eae:	ea4f 71e4 	mov.w	r1, r4, asr #31
   47eb2:	d00b      	beq.n	47ecc <sys_clock_announce+0x4c>
	while (first() != NULL && first()->dticks <= announce_remaining) {
   47eb4:	b150      	cbz	r0, 47ecc <sys_clock_announce+0x4c>
   47eb6:	e9d0 5c04 	ldrd	r5, ip, [r0, #16]
   47eba:	42ac      	cmp	r4, r5
   47ebc:	eb71 090c 	sbcs.w	r9, r1, ip
   47ec0:	da16      	bge.n	47ef0 <sys_clock_announce+0x70>
		key = k_spin_lock(&timeout_lock);
		announce_remaining -= dt;
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
   47ec2:	1b2d      	subs	r5, r5, r4
   47ec4:	eb6c 0c01 	sbc.w	ip, ip, r1
   47ec8:	e9c0 5c04 	strd	r5, ip, [r0, #16]
	}

	curr_tick += announce_remaining;
   47ecc:	18e3      	adds	r3, r4, r3
   47ece:	eb4e 0101 	adc.w	r1, lr, r1
	announce_remaining = 0;
   47ed2:	2400      	movs	r4, #0
	curr_tick += announce_remaining;
   47ed4:	e9c2 3100 	strd	r3, r1, [r2]
	announce_remaining = 0;
   47ed8:	603c      	str	r4, [r7, #0]

	sys_clock_set_timeout(next_timeout(), false);
   47eda:	f7ff ff0f 	bl	47cfc <next_timeout>
   47ede:	4621      	mov	r1, r4
   47ee0:	f7fc fe4a 	bl	44b78 <sys_clock_set_timeout>
	__asm__ volatile(
   47ee4:	f386 8811 	msr	BASEPRI, r6
   47ee8:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&timeout_lock, key);
}
   47eec:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		curr_tick += dt;
   47ef0:	18eb      	adds	r3, r5, r3
   47ef2:	eb4e 71e5 	adc.w	r1, lr, r5, asr #31
   47ef6:	e9c2 3100 	strd	r3, r1, [r2]
		t->dticks = 0;
   47efa:	2200      	movs	r2, #0
   47efc:	2300      	movs	r3, #0
   47efe:	e9c0 2304 	strd	r2, r3, [r0, #16]
		remove_timeout(t);
   47f02:	f7ff ff23 	bl	47d4c <remove_timeout>
   47f06:	f386 8811 	msr	BASEPRI, r6
   47f0a:	f3bf 8f6f 	isb	sy
		t->fn(t);
   47f0e:	6883      	ldr	r3, [r0, #8]
   47f10:	4798      	blx	r3
	__asm__ volatile(
   47f12:	f04f 0320 	mov.w	r3, #32
   47f16:	f3ef 8611 	mrs	r6, BASEPRI
   47f1a:	f383 8812 	msr	BASEPRI_MAX, r3
   47f1e:	f3bf 8f6f 	isb	sy
		announce_remaining -= dt;
   47f22:	683c      	ldr	r4, [r7, #0]
   47f24:	1b64      	subs	r4, r4, r5
   47f26:	e7bb      	b.n	47ea0 <sys_clock_announce+0x20>
   47f28:	20006988 	.word	0x20006988
   47f2c:	20000e68 	.word	0x20000e68
   47f30:	20003718 	.word	0x20003718

00047f34 <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
   47f34:	b510      	push	{r4, lr}
   47f36:	f04f 0320 	mov.w	r3, #32
   47f3a:	f3ef 8411 	mrs	r4, BASEPRI
   47f3e:	f383 8812 	msr	BASEPRI_MAX, r3
   47f42:	f3bf 8f6f 	isb	sy
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + elapsed();
   47f46:	f7ff fecf 	bl	47ce8 <elapsed>
   47f4a:	4a06      	ldr	r2, [pc, #24]	; (47f64 <sys_clock_tick_get+0x30>)
   47f4c:	4603      	mov	r3, r0
   47f4e:	e9d2 0100 	ldrd	r0, r1, [r2]
   47f52:	1818      	adds	r0, r3, r0
   47f54:	eb41 71e3 	adc.w	r1, r1, r3, asr #31
	__asm__ volatile(
   47f58:	f384 8811 	msr	BASEPRI, r4
   47f5c:	f3bf 8f6f 	isb	sy
	}
	return t;
}
   47f60:	bd10      	pop	{r4, pc}
   47f62:	bf00      	nop
   47f64:	20003718 	.word	0x20003718

00047f68 <z_timer_expiration_handler>:
 * @brief Handle expiration of a kernel timer object.
 *
 * @param t  Timeout used by the timer.
 */
void z_timer_expiration_handler(struct _timeout *t)
{
   47f68:	b570      	push	{r4, r5, r6, lr}
   47f6a:	4604      	mov	r4, r0
	__asm__ volatile(
   47f6c:	f04f 0320 	mov.w	r3, #32
   47f70:	f3ef 8511 	mrs	r5, BASEPRI
   47f74:	f383 8812 	msr	BASEPRI_MAX, r3
   47f78:	f3bf 8f6f 	isb	sy

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
   47f7c:	e9d0 320a 	ldrd	r3, r2, [r0, #40]	; 0x28
   47f80:	3301      	adds	r3, #1
   47f82:	f142 0200 	adc.w	r2, r2, #0
   47f86:	2b02      	cmp	r3, #2
   47f88:	f172 0200 	sbcs.w	r2, r2, #0
   47f8c:	d322      	bcc.n	47fd4 <z_timer_expiration_handler+0x6c>
	return z_impl_k_uptime_ticks();
   47f8e:	f008 f9e7 	bl	50360 <z_impl_k_uptime_ticks>
		 * we "should" have run.  Requires absolute timeouts.
		 * (Note offset by one: we're nominally at the
		 * beginning of a tick, so need to defeat the "round
		 * down" behavior on timeout addition).
		 */
		next = K_TIMEOUT_ABS_TICKS(k_uptime_ticks() + 1
   47f92:	e9d4 320a 	ldrd	r3, r2, [r4, #40]	; 0x28
   47f96:	3001      	adds	r0, #1
   47f98:	f141 0100 	adc.w	r1, r1, #0
   47f9c:	18c0      	adds	r0, r0, r3
   47f9e:	eb41 0102 	adc.w	r1, r1, r2
   47fa2:	2801      	cmp	r0, #1
   47fa4:	f171 0100 	sbcs.w	r1, r1, #0
   47fa8:	db32      	blt.n	48010 <z_timer_expiration_handler+0xa8>
   47faa:	f008 f9d9 	bl	50360 <z_impl_k_uptime_ticks>
   47fae:	3001      	adds	r0, #1
   47fb0:	f141 0300 	adc.w	r3, r1, #0
   47fb4:	e9d4 210a 	ldrd	r2, r1, [r4, #40]	; 0x28
   47fb8:	1880      	adds	r0, r0, r2
   47fba:	f06f 0201 	mvn.w	r2, #1
   47fbe:	eb43 0301 	adc.w	r3, r3, r1
   47fc2:	1a12      	subs	r2, r2, r0
   47fc4:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   47fc8:	eb61 0303 	sbc.w	r3, r1, r3
					   + timer->period.ticks);
#endif
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   47fcc:	491a      	ldr	r1, [pc, #104]	; (48038 <z_timer_expiration_handler+0xd0>)
   47fce:	4620      	mov	r0, r4
   47fd0:	f7ff fed8 	bl	47d84 <z_add_timeout>
			      next);
	}

	/* update timer's status */
	timer->status += 1U;
   47fd4:	6b23      	ldr	r3, [r4, #48]	; 0x30
   47fd6:	3301      	adds	r3, #1
   47fd8:	6323      	str	r3, [r4, #48]	; 0x30

	/* invoke timer expiry function */
	if (timer->expiry_fn != NULL) {
   47fda:	6a23      	ldr	r3, [r4, #32]
   47fdc:	b173      	cbz	r3, 47ffc <z_timer_expiration_handler+0x94>
	__asm__ volatile(
   47fde:	f385 8811 	msr	BASEPRI, r5
   47fe2:	f3bf 8f6f 	isb	sy
		/* Unlock for user handler. */
		k_spin_unlock(&lock, key);
		timer->expiry_fn(timer);
   47fe6:	6a23      	ldr	r3, [r4, #32]
   47fe8:	4620      	mov	r0, r4
   47fea:	4798      	blx	r3
	__asm__ volatile(
   47fec:	f04f 0320 	mov.w	r3, #32
   47ff0:	f3ef 8511 	mrs	r5, BASEPRI
   47ff4:	f383 8812 	msr	BASEPRI_MAX, r3
   47ff8:	f3bf 8f6f 	isb	sy
	return list->head == list;
   47ffc:	f854 6f18 	ldr.w	r6, [r4, #24]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   48000:	42a6      	cmp	r6, r4
   48002:	d000      	beq.n	48006 <z_timer_expiration_handler+0x9e>
		return;
	}

	thread = z_waitq_head(&timer->wait_q);

	if (thread == NULL) {
   48004:	b94e      	cbnz	r6, 4801a <z_timer_expiration_handler+0xb2>
	__asm__ volatile(
   48006:	f385 8811 	msr	BASEPRI, r5
   4800a:	f3bf 8f6f 	isb	sy
	arch_thread_return_value_set(thread, 0);

	k_spin_unlock(&lock, key);

	z_ready_thread(thread);
}
   4800e:	bd70      	pop	{r4, r5, r6, pc}
		next = K_TIMEOUT_ABS_TICKS(k_uptime_ticks() + 1
   48010:	f06f 0201 	mvn.w	r2, #1
   48014:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   48018:	e7d8      	b.n	47fcc <z_timer_expiration_handler+0x64>
	z_unpend_thread_no_timeout(thread);
   4801a:	4630      	mov	r0, r6
   4801c:	f008 f8ba 	bl	50194 <z_unpend_thread_no_timeout>
   48020:	2300      	movs	r3, #0
   48022:	67f3      	str	r3, [r6, #124]	; 0x7c
   48024:	f385 8811 	msr	BASEPRI, r5
   48028:	f3bf 8f6f 	isb	sy
	z_ready_thread(thread);
   4802c:	4630      	mov	r0, r6
}
   4802e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_ready_thread(thread);
   48032:	f008 b89f 	b.w	50174 <z_ready_thread>
   48036:	bf00      	nop
   48038:	00047f69 	.word	0x00047f69

0004803c <z_impl_k_timer_start>:
}


void z_impl_k_timer_start(struct k_timer *timer, k_timeout_t duration,
			  k_timeout_t period)
{
   4803c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, start, timer, duration, period);

	if (K_TIMEOUT_EQ(duration, K_FOREVER)) {
   48040:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   48044:	bf08      	it	eq
   48046:	f1b2 3fff 	cmpeq.w	r2, #4294967295	; 0xffffffff
{
   4804a:	4605      	mov	r5, r0
   4804c:	4614      	mov	r4, r2
   4804e:	e9dd 6008 	ldrd	r6, r0, [sp, #32]
   48052:	4619      	mov	r1, r3
   48054:	4691      	mov	r9, r2
   48056:	4698      	mov	r8, r3
	if (K_TIMEOUT_EQ(duration, K_FOREVER)) {
   48058:	d037      	beq.n	480ca <z_impl_k_timer_start+0x8e>
	 * for backwards compatibility.  This is unfortunate
	 * (i.e. k_timer_start() doesn't treat its initial sleep
	 * argument the same way k_sleep() does), but historical.  The
	 * timer_api test relies on this behavior.
	 */
	if (!K_TIMEOUT_EQ(period, K_FOREVER) && period.ticks != 0 &&
   4805a:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
   4805e:	bf08      	it	eq
   48060:	f1b6 3fff 	cmpeq.w	r6, #4294967295	; 0xffffffff
   48064:	4637      	mov	r7, r6
   48066:	4682      	mov	sl, r0
   48068:	d011      	beq.n	4808e <z_impl_k_timer_start+0x52>
   4806a:	ea50 0306 	orrs.w	r3, r0, r6
   4806e:	d00e      	beq.n	4808e <z_impl_k_timer_start+0x52>
   48070:	1c72      	adds	r2, r6, #1
   48072:	f170 33ff 	sbcs.w	r3, r0, #4294967295	; 0xffffffff
   48076:	db0a      	blt.n	4808e <z_impl_k_timer_start+0x52>
	    Z_TICK_ABS(period.ticks) < 0) {
		period.ticks = MAX(period.ticks - 1, 1);
   48078:	2e02      	cmp	r6, #2
   4807a:	4684      	mov	ip, r0
   4807c:	f170 0000 	sbcs.w	r0, r0, #0
   48080:	bfbc      	itt	lt
   48082:	2702      	movlt	r7, #2
   48084:	f04f 0c00 	movlt.w	ip, #0
   48088:	3f01      	subs	r7, #1
   4808a:	f14c 3aff 	adc.w	sl, ip, #4294967295	; 0xffffffff
	}
	if (Z_TICK_ABS(duration.ticks) < 0) {
   4808e:	1c63      	adds	r3, r4, #1
   48090:	f171 33ff 	sbcs.w	r3, r1, #4294967295	; 0xffffffff
   48094:	db0a      	blt.n	480ac <z_impl_k_timer_start+0x70>
		duration.ticks = MAX(duration.ticks - 1, 0);
   48096:	2c01      	cmp	r4, #1
   48098:	f171 0300 	sbcs.w	r3, r1, #0
   4809c:	4622      	mov	r2, r4
   4809e:	bfbc      	itt	lt
   480a0:	2201      	movlt	r2, #1
   480a2:	2100      	movlt	r1, #0
   480a4:	f112 39ff 	adds.w	r9, r2, #4294967295	; 0xffffffff
   480a8:	f141 38ff 	adc.w	r8, r1, #4294967295	; 0xffffffff
	}

	(void)z_abort_timeout(&timer->timeout);
   480ac:	4628      	mov	r0, r5
   480ae:	f008 f911 	bl	502d4 <z_abort_timeout>
	timer->period = period;
   480b2:	e9c5 7a0a 	strd	r7, sl, [r5, #40]	; 0x28
	timer->status = 0U;
   480b6:	2300      	movs	r3, #0
   480b8:	632b      	str	r3, [r5, #48]	; 0x30

	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   480ba:	464a      	mov	r2, r9
   480bc:	4643      	mov	r3, r8
   480be:	4628      	mov	r0, r5
   480c0:	4903      	ldr	r1, [pc, #12]	; (480d0 <z_impl_k_timer_start+0x94>)
		     duration);
}
   480c2:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   480c6:	f7ff be5d 	b.w	47d84 <z_add_timeout>
}
   480ca:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   480ce:	bf00      	nop
   480d0:	00047f69 	.word	0x00047f69

000480d4 <z_impl_k_poll>:
	return 0;
}

int z_impl_k_poll(struct k_poll_event *events, int num_events,
		  k_timeout_t timeout)
{
   480d4:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
   480d8:	461d      	mov	r5, r3
	int events_registered;
	k_spinlock_key_t key;
	struct z_poller *poller = &_current->poller;
   480da:	4b29      	ldr	r3, [pc, #164]	; (48180 <z_impl_k_poll+0xac>)
   480dc:	689f      	ldr	r7, [r3, #8]

	poller->is_polling = true;
   480de:	2301      	movs	r3, #1
   480e0:	f887 3060 	strb.w	r3, [r7, #96]	; 0x60
	poller->mode = MODE_POLL;
   480e4:	f887 3061 	strb.w	r3, [r7, #97]	; 0x61
	__ASSERT(events != NULL, "NULL events\n");
	__ASSERT(num_events >= 0, "<0 events\n");

	SYS_PORT_TRACING_FUNC_ENTER(k_poll_api, poll, events);

	events_registered = register_events(events, num_events, poller,
   480e8:	ea52 0305 	orrs.w	r3, r2, r5
{
   480ec:	4616      	mov	r6, r2
	events_registered = register_events(events, num_events, poller,
   480ee:	bf0c      	ite	eq
   480f0:	2301      	moveq	r3, #1
   480f2:	2300      	movne	r3, #0
   480f4:	f107 0260 	add.w	r2, r7, #96	; 0x60
{
   480f8:	4680      	mov	r8, r0
	events_registered = register_events(events, num_events, poller,
   480fa:	f008 f9a7 	bl	5044c <register_events>
   480fe:	4681      	mov	r9, r0
	__asm__ volatile(
   48100:	f04f 0320 	mov.w	r3, #32
   48104:	f3ef 8a11 	mrs	sl, BASEPRI
   48108:	f383 8812 	msr	BASEPRI_MAX, r3
   4810c:	f3bf 8f6f 	isb	sy
	/*
	 * If we're not polling anymore, it means that at least one event
	 * condition is met, either when looping through the events here or
	 * because one of the events registered has had its state changed.
	 */
	if (!poller->is_polling) {
   48110:	f897 4060 	ldrb.w	r4, [r7, #96]	; 0x60
   48114:	b964      	cbnz	r4, 48130 <z_impl_k_poll+0x5c>
		clear_event_registrations(events, events_registered, key);
   48116:	4601      	mov	r1, r0
   48118:	4652      	mov	r2, sl
   4811a:	4640      	mov	r0, r8
   4811c:	f008 fa67 	bl	505ee <clear_event_registrations>
	__asm__ volatile(
   48120:	f38a 8811 	msr	BASEPRI, sl
   48124:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&lock, key);

	SYS_PORT_TRACING_FUNC_EXIT(k_poll_api, poll, events, swap_rc);

	return swap_rc;
}
   48128:	4620      	mov	r0, r4
   4812a:	b002      	add	sp, #8
   4812c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	poller->is_polling = false;
   48130:	2300      	movs	r3, #0
   48132:	f887 3060 	strb.w	r3, [r7, #96]	; 0x60
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   48136:	ea56 0305 	orrs.w	r3, r6, r5
   4813a:	d106      	bne.n	4814a <z_impl_k_poll+0x76>
   4813c:	f38a 8811 	msr	BASEPRI, sl
   48140:	f3bf 8f6f 	isb	sy
		return -EAGAIN;
   48144:	f06f 040a 	mvn.w	r4, #10
   48148:	e7ee      	b.n	48128 <z_impl_k_poll+0x54>
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
   4814a:	e9cd 6500 	strd	r6, r5, [sp]
   4814e:	4a0d      	ldr	r2, [pc, #52]	; (48184 <z_impl_k_poll+0xb0>)
   48150:	480d      	ldr	r0, [pc, #52]	; (48188 <z_impl_k_poll+0xb4>)
   48152:	4651      	mov	r1, sl
   48154:	f7ff fba2 	bl	4789c <z_pend_curr>
   48158:	4604      	mov	r4, r0
	__asm__ volatile(
   4815a:	f04f 0320 	mov.w	r3, #32
   4815e:	f3ef 8511 	mrs	r5, BASEPRI
   48162:	f383 8812 	msr	BASEPRI_MAX, r3
   48166:	f3bf 8f6f 	isb	sy
	clear_event_registrations(events, events_registered, key);
   4816a:	462a      	mov	r2, r5
   4816c:	4649      	mov	r1, r9
   4816e:	4640      	mov	r0, r8
   48170:	f008 fa3d 	bl	505ee <clear_event_registrations>
	__asm__ volatile(
   48174:	f385 8811 	msr	BASEPRI, r5
   48178:	f3bf 8f6f 	isb	sy
	return swap_rc;
   4817c:	e7d4      	b.n	48128 <z_impl_k_poll+0x54>
   4817e:	bf00      	nop
   48180:	2000694c 	.word	0x2000694c
   48184:	20000e70 	.word	0x20000e70
   48188:	20006bc5 	.word	0x20006bc5

0004818c <z_impl_k_poll_signal_raise>:
}
#include <syscalls/k_poll_signal_check_mrsh.c>
#endif

int z_impl_k_poll_signal_raise(struct k_poll_signal *sig, int result)
{
   4818c:	b538      	push	{r3, r4, r5, lr}
   4818e:	4603      	mov	r3, r0
	__asm__ volatile(
   48190:	f04f 0220 	mov.w	r2, #32
   48194:	f3ef 8511 	mrs	r5, BASEPRI
   48198:	f382 8812 	msr	BASEPRI_MAX, r2
   4819c:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_poll_event *poll_event;

	sig->result = result;
   481a0:	60c1      	str	r1, [r0, #12]
	sig->signaled = 1U;
   481a2:	2101      	movs	r1, #1
   481a4:	6081      	str	r1, [r0, #8]
	return list->head == list;
   481a6:	6800      	ldr	r0, [r0, #0]

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node = NULL;

	if (!sys_dlist_is_empty(list)) {
   481a8:	4283      	cmp	r3, r0
   481aa:	d106      	bne.n	481ba <z_impl_k_poll_signal_raise+0x2e>
	__asm__ volatile(
   481ac:	f385 8811 	msr	BASEPRI, r5
   481b0:	f3bf 8f6f 	isb	sy
	if (poll_event == NULL) {
		k_spin_unlock(&lock, key);

		SYS_PORT_TRACING_FUNC(k_poll_api, signal_raise, sig, 0);

		return 0;
   481b4:	2400      	movs	r4, #0

	SYS_PORT_TRACING_FUNC(k_poll_api, signal_raise, sig, rc);

	z_reschedule(&lock, key);
	return rc;
}
   481b6:	4620      	mov	r0, r4
   481b8:	bd38      	pop	{r3, r4, r5, pc}
	sys_dnode_t *const next = node->next;
   481ba:	e9d0 3200 	ldrd	r3, r2, [r0]
	prev->next = next;
   481be:	6013      	str	r3, [r2, #0]
	next->prev = prev;
   481c0:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   481c2:	2300      	movs	r3, #0
	node->prev = NULL;
   481c4:	e9c0 3300 	strd	r3, r3, [r0]
	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);
   481c8:	f008 f9b7 	bl	5053a <signal_poll_event>
	z_reschedule(&lock, key);
   481cc:	4629      	mov	r1, r5
	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);
   481ce:	4604      	mov	r4, r0
	z_reschedule(&lock, key);
   481d0:	4801      	ldr	r0, [pc, #4]	; (481d8 <z_impl_k_poll_signal_raise+0x4c>)
   481d2:	f7ff fbbd 	bl	47950 <z_reschedule>
	return rc;
   481d6:	e7ee      	b.n	481b6 <z_impl_k_poll_signal_raise+0x2a>
   481d8:	20006bc5 	.word	0x20006bc5

000481dc <k_aligned_alloc>:

K_HEAP_DEFINE(_system_heap, CONFIG_HEAP_MEM_POOL_SIZE);
#define _SYSTEM_HEAP (&_system_heap)

void *k_aligned_alloc(size_t align, size_t size)
{
   481dc:	460a      	mov	r2, r1
	__ASSERT((align & (align - 1)) == 0,
		"align must be a power of 2");

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap_sys, k_aligned_alloc, _SYSTEM_HEAP);

	void *ret = z_heap_aligned_alloc(_SYSTEM_HEAP, align, size);
   481de:	4601      	mov	r1, r0
   481e0:	4801      	ldr	r0, [pc, #4]	; (481e8 <k_aligned_alloc+0xc>)
   481e2:	f008 ba55 	b.w	50690 <z_heap_aligned_alloc>
   481e6:	bf00      	nop
   481e8:	200010e0 	.word	0x200010e0

000481ec <k_thread_system_pool_assign>:
	return ret;
}

void k_thread_system_pool_assign(struct k_thread *thread)
{
	thread->resource_pool = _SYSTEM_HEAP;
   481ec:	4b01      	ldr	r3, [pc, #4]	; (481f4 <k_thread_system_pool_assign+0x8>)
   481ee:	6743      	str	r3, [r0, #116]	; 0x74
}
   481f0:	4770      	bx	lr
   481f2:	bf00      	nop
   481f4:	200010e0 	.word	0x200010e0

000481f8 <z_thread_aligned_alloc>:
#else
#define _SYSTEM_HEAP	NULL
#endif

void *z_thread_aligned_alloc(size_t align, size_t size)
{
   481f8:	b538      	push	{r3, r4, r5, lr}
   481fa:	4604      	mov	r4, r0
   481fc:	460d      	mov	r5, r1
	void *ret;
	struct k_heap *heap;

	if (k_is_in_isr()) {
   481fe:	f007 fd28 	bl	4fc52 <k_is_in_isr>
   48202:	b920      	cbnz	r0, 4820e <z_thread_aligned_alloc+0x16>
		heap = _SYSTEM_HEAP;
	} else {
		heap = _current->resource_pool;
   48204:	4b06      	ldr	r3, [pc, #24]	; (48220 <z_thread_aligned_alloc+0x28>)
   48206:	689b      	ldr	r3, [r3, #8]
   48208:	6f5b      	ldr	r3, [r3, #116]	; 0x74
	}

	if (heap != NULL) {
   4820a:	b90b      	cbnz	r3, 48210 <z_thread_aligned_alloc+0x18>
	} else {
		ret = NULL;
	}

	return ret;
}
   4820c:	bd38      	pop	{r3, r4, r5, pc}
		heap = _SYSTEM_HEAP;
   4820e:	4b05      	ldr	r3, [pc, #20]	; (48224 <z_thread_aligned_alloc+0x2c>)
		ret = z_heap_aligned_alloc(heap, align, size);
   48210:	462a      	mov	r2, r5
   48212:	4621      	mov	r1, r4
   48214:	4618      	mov	r0, r3
}
   48216:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		ret = z_heap_aligned_alloc(heap, align, size);
   4821a:	f008 ba39 	b.w	50690 <z_heap_aligned_alloc>
   4821e:	bf00      	nop
   48220:	2000694c 	.word	0x2000694c
   48224:	200010e0 	.word	0x200010e0

00048228 <boot_banner>:
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
   48228:	4a02      	ldr	r2, [pc, #8]	; (48234 <boot_banner+0xc>)
   4822a:	4903      	ldr	r1, [pc, #12]	; (48238 <boot_banner+0x10>)
   4822c:	4803      	ldr	r0, [pc, #12]	; (4823c <boot_banner+0x14>)
   4822e:	f000 bc29 	b.w	48a84 <printk>
   48232:	bf00      	nop
   48234:	0005391e 	.word	0x0005391e
   48238:	000538eb 	.word	0x000538eb
   4823c:	000538f8 	.word	0x000538f8

00048240 <_OffsetAbsSyms>:

#include <gen_offset.h>

#include "offsets_aarch32.c"

GEN_ABS_SYM_END
   48240:	4770      	bx	lr

00048242 <strlcpy>:
 *
 * Nathan Myers <ncm-nospam@cantrip.org>, 2003/06/03
 * Placed in the public domain.
 */

size_t strlcpy(char *dst, const char *src, size_t size) {
   48242:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   48244:	4606      	mov	r6, r0
    const size_t len = strlen(src);
   48246:	4608      	mov	r0, r1
size_t strlcpy(char *dst, const char *src, size_t size) {
   48248:	460f      	mov	r7, r1
   4824a:	4614      	mov	r4, r2
    const size_t len = strlen(src);
   4824c:	f002 fdde 	bl	4ae0c <strlen>
   48250:	4605      	mov	r5, r0
    if (size != 0) {
   48252:	b154      	cbz	r4, 4826a <strlcpy+0x28>
        memcpy(dst, src, (len > size - 1) ? size - 1 : len);
   48254:	3c01      	subs	r4, #1
   48256:	4284      	cmp	r4, r0
   48258:	4622      	mov	r2, r4
   4825a:	4639      	mov	r1, r7
   4825c:	bf28      	it	cs
   4825e:	4602      	movcs	r2, r0
   48260:	4630      	mov	r0, r6
   48262:	f002 fe0a 	bl	4ae7a <memcpy>
        dst[size - 1] = 0;
   48266:	2300      	movs	r3, #0
   48268:	5533      	strb	r3, [r6, r4]
    }
    return len;
}
   4826a:	4628      	mov	r0, r5
   4826c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0004826e <zmk_sensors_init>:

#define SENSOR_INIT(idx, _t) zmk_sensors_init_item(idx);

static int zmk_sensors_init(const struct device *_arg) {
   4826e:	b508      	push	{r3, lr}
    LISTIFY(ZMK_KEYMAP_SENSORS_LEN, SENSOR_INIT, (), 0)
   48270:	2000      	movs	r0, #0
   48272:	f7e0 fd9b 	bl	28dac <zmk_sensors_init_item>
   48276:	2001      	movs	r0, #1
   48278:	f7e0 fd98 	bl	28dac <zmk_sensors_init_item>

    return 0;
}
   4827c:	2000      	movs	r0, #0
   4827e:	bd08      	pop	{r3, pc}

00048280 <zmk_event_manager_raise>:

int zmk_event_manager_raise(zmk_event_t *event) { return zmk_event_manager_handle_from(event, 0); }
   48280:	2100      	movs	r1, #0
   48282:	f7e0 bdd7 	b.w	28e34 <zmk_event_manager_handle_from>

00048286 <gpio_pin_set>:
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   48286:	2301      	movs	r3, #1
   48288:	fa03 f101 	lsl.w	r1, r3, r1
   4828c:	6903      	ldr	r3, [r0, #16]
   4828e:	681b      	ldr	r3, [r3, #0]
   48290:	4219      	tst	r1, r3
		value = (value != 0) ? 0 : 1;
   48292:	bf18      	it	ne
   48294:	f082 0201 	eorne.w	r2, r2, #1
	if (value != 0)	{
   48298:	b112      	cbz	r2, 482a0 <gpio_pin_set+0x1a>
	return api->port_set_bits_raw(port, pins);
   4829a:	6883      	ldr	r3, [r0, #8]
   4829c:	68db      	ldr	r3, [r3, #12]
	return api->port_clear_bits_raw(port, pins);
   4829e:	4718      	bx	r3
   482a0:	6883      	ldr	r3, [r0, #8]
   482a2:	691b      	ldr	r3, [r3, #16]
   482a4:	e7fb      	b.n	4829e <gpio_pin_set+0x18>

000482a6 <ext_power_generic_get>:
    return data->status;
   482a6:	6903      	ldr	r3, [r0, #16]
}
   482a8:	7818      	ldrb	r0, [r3, #0]
   482aa:	4770      	bx	lr

000482ac <ext_power_generic_enable>:
static int ext_power_generic_enable(const struct device *dev) {
   482ac:	b510      	push	{r4, lr}
    const struct ext_power_generic_config *config = dev->config;
   482ae:	6843      	ldr	r3, [r0, #4]
    struct ext_power_generic_data *data = dev->data;
   482b0:	6904      	ldr	r4, [r0, #16]
	return gpio_pin_set(spec->port, spec->pin, value);
   482b2:	7919      	ldrb	r1, [r3, #4]
   482b4:	6818      	ldr	r0, [r3, #0]
   482b6:	2201      	movs	r2, #1
   482b8:	f7ff ffe5 	bl	48286 <gpio_pin_set>
    if (gpio_pin_set_dt(&config->control, 1)) {
   482bc:	b928      	cbnz	r0, 482ca <ext_power_generic_enable+0x1e>
    data->status = true;
   482be:	2301      	movs	r3, #1
   482c0:	7023      	strb	r3, [r4, #0]
}
   482c2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    return ext_power_save_state();
   482c6:	f7e0 be57 	b.w	28f78 <ext_power_save_state>
}
   482ca:	f06f 0004 	mvn.w	r0, #4
   482ce:	bd10      	pop	{r4, pc}

000482d0 <ext_power_generic_disable>:
static int ext_power_generic_disable(const struct device *dev) {
   482d0:	b510      	push	{r4, lr}
    const struct ext_power_generic_config *config = dev->config;
   482d2:	6843      	ldr	r3, [r0, #4]
    struct ext_power_generic_data *data = dev->data;
   482d4:	6904      	ldr	r4, [r0, #16]
   482d6:	7919      	ldrb	r1, [r3, #4]
   482d8:	6818      	ldr	r0, [r3, #0]
   482da:	2200      	movs	r2, #0
   482dc:	f7ff ffd3 	bl	48286 <gpio_pin_set>
    if (gpio_pin_set_dt(&config->control, 0)) {
   482e0:	b920      	cbnz	r0, 482ec <ext_power_generic_disable+0x1c>
    data->status = false;
   482e2:	7020      	strb	r0, [r4, #0]
}
   482e4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    return ext_power_save_state();
   482e8:	f7e0 be46 	b.w	28f78 <ext_power_save_state>
}
   482ec:	f06f 0004 	mvn.w	r0, #4
   482f0:	bd10      	pop	{r4, pc}

000482f2 <behavior_reset_init>:
#if DT_HAS_COMPAT_STATUS_OKAY(DT_DRV_COMPAT)
struct behavior_reset_config {
    int type;
};

static int behavior_reset_init(const struct device *dev) { return 0; };
   482f2:	2000      	movs	r0, #0
   482f4:	4770      	bx	lr

000482f6 <on_keymap_binding_pressed>:

static int on_keymap_binding_pressed(struct zmk_behavior_binding *binding,
                                     struct zmk_behavior_binding_event event) {
   482f6:	b082      	sub	sp, #8
   482f8:	b508      	push	{r3, lr}
   482fa:	a902      	add	r1, sp, #8
   482fc:	e881 000c 	stmia.w	r1, {r2, r3}
    const struct device *dev = device_get_binding(binding->behavior_dev);
   48300:	6800      	ldr	r0, [r0, #0]
   48302:	f7fe fb83 	bl	46a0c <z_impl_device_get_binding>
    const struct behavior_reset_config *cfg = dev->config;

    // TODO: Correct magic code for going into DFU?
    // See
    // https://github.com/adafruit/Adafruit_nRF52_Bootloader/blob/d6b28e66053eea467166f44875e3c7ec741cb471/src/main.c#L107
    sys_reboot(cfg->type);
   48306:	6843      	ldr	r3, [r0, #4]
   48308:	6818      	ldr	r0, [r3, #0]
   4830a:	f7e2 ff8f 	bl	2b22c <sys_reboot>

0004830e <ext_power_enable>:
    if (api->enable == NULL) {
   4830e:	6883      	ldr	r3, [r0, #8]
   48310:	681b      	ldr	r3, [r3, #0]
   48312:	b103      	cbz	r3, 48316 <ext_power_enable+0x8>
    return api->enable(dev);
   48314:	4718      	bx	r3
		return (int) arch_syscall_invoke1(parm0.x, K_SYSCALL_EXT_POWER_ENABLE);
	}
#endif
	compiler_barrier();
	return z_impl_ext_power_enable(dev);
}
   48316:	f06f 0085 	mvn.w	r0, #133	; 0x85
   4831a:	4770      	bx	lr

0004831c <ext_power_disable>:
__syscall int ext_power_disable(const struct device *dev);

static inline int z_impl_ext_power_disable(const struct device *dev) {
    const struct ext_power_api *api = (const struct ext_power_api *)dev->api;

    if (api->disable == NULL) {
   4831c:	6883      	ldr	r3, [r0, #8]
   4831e:	685b      	ldr	r3, [r3, #4]
   48320:	b103      	cbz	r3, 48324 <ext_power_disable+0x8>
        return -ENOTSUP;
    }

    return api->disable(dev);
   48322:	4718      	bx	r3
		return (int) arch_syscall_invoke1(parm0.x, K_SYSCALL_EXT_POWER_DISABLE);
	}
#endif
	compiler_barrier();
	return z_impl_ext_power_disable(dev);
}
   48324:	f06f 0085 	mvn.w	r0, #133	; 0x85
   48328:	4770      	bx	lr

0004832a <ext_power_get>:
__syscall int ext_power_get(const struct device *dev);

static inline int z_impl_ext_power_get(const struct device *dev) {
    const struct ext_power_api *api = (const struct ext_power_api *)dev->api;

    if (api->get == NULL) {
   4832a:	6883      	ldr	r3, [r0, #8]
   4832c:	689b      	ldr	r3, [r3, #8]
   4832e:	b103      	cbz	r3, 48332 <ext_power_get+0x8>
        return -ENOTSUP;
    }

    return api->get(dev);
   48330:	4718      	bx	r3
		return (int) arch_syscall_invoke1(parm0.x, K_SYSCALL_EXT_POWER_GET);
	}
#endif
	compiler_barrier();
	return z_impl_ext_power_get(dev);
}
   48332:	f06f 0085 	mvn.w	r0, #133	; 0x85
   48336:	4770      	bx	lr

00048338 <on_keymap_binding_released>:

static int on_keymap_binding_released(struct zmk_behavior_binding *binding,
                                      struct zmk_behavior_binding_event event) {
   48338:	b082      	sub	sp, #8
   4833a:	e88d 000c 	stmia.w	sp, {r2, r3}
    return ZMK_BEHAVIOR_OPAQUE;
}
   4833e:	2000      	movs	r0, #0
   48340:	b002      	add	sp, #8
   48342:	4770      	bx	lr

00048344 <behavior_ext_power_init>:

static int behavior_ext_power_init(const struct device *dev) { return 0; };
   48344:	2000      	movs	r0, #0
   48346:	4770      	bx	lr

00048348 <zmk_hid_register_mods>:
int zmk_hid_register_mods(zmk_mod_flags_t modifiers) {
   48348:	b570      	push	{r4, r5, r6, lr}
   4834a:	2400      	movs	r4, #0
   4834c:	4606      	mov	r6, r0
    int ret = 0;
   4834e:	4625      	mov	r5, r4
        if (modifiers & (1 << i)) {
   48350:	fa46 f304 	asr.w	r3, r6, r4
   48354:	07db      	lsls	r3, r3, #31
   48356:	d503      	bpl.n	48360 <zmk_hid_register_mods+0x18>
            ret += zmk_hid_register_mod(i);
   48358:	b2e0      	uxtb	r0, r4
   4835a:	f7e0 fef5 	bl	29148 <zmk_hid_register_mod>
   4835e:	4405      	add	r5, r0
    for (zmk_mod_t i = 0; i < 8; i++) {
   48360:	3401      	adds	r4, #1
   48362:	2c08      	cmp	r4, #8
   48364:	d1f4      	bne.n	48350 <zmk_hid_register_mods+0x8>
}
   48366:	4628      	mov	r0, r5
   48368:	bd70      	pop	{r4, r5, r6, pc}

0004836a <zmk_hid_unregister_mods>:
int zmk_hid_unregister_mods(zmk_mod_flags_t modifiers) {
   4836a:	b570      	push	{r4, r5, r6, lr}
   4836c:	2400      	movs	r4, #0
   4836e:	4606      	mov	r6, r0
    int ret = 0;
   48370:	4625      	mov	r5, r4
        if (modifiers & (1 << i)) {
   48372:	fa46 f304 	asr.w	r3, r6, r4
   48376:	07db      	lsls	r3, r3, #31
   48378:	d503      	bpl.n	48382 <zmk_hid_unregister_mods+0x18>
            ret += zmk_hid_unregister_mod(i);
   4837a:	b2e0      	uxtb	r0, r4
   4837c:	f7e0 ff0a 	bl	29194 <zmk_hid_unregister_mod>
   48380:	4405      	add	r5, r0
    for (zmk_mod_t i = 0; i < 8; i++) {
   48382:	3401      	adds	r4, #1
   48384:	2c08      	cmp	r4, #8
   48386:	d1f4      	bne.n	48372 <zmk_hid_unregister_mods+0x8>
}
   48388:	4628      	mov	r0, r5
   4838a:	bd70      	pop	{r4, r5, r6, pc}

0004838c <zmk_hid_press>:
    switch (ZMK_HID_USAGE_PAGE(usage)) {
   4838c:	f3c0 4307 	ubfx	r3, r0, #16, #8
   48390:	2b07      	cmp	r3, #7
   48392:	d004      	beq.n	4839e <zmk_hid_press+0x12>
   48394:	2b0c      	cmp	r3, #12
   48396:	d005      	beq.n	483a4 <zmk_hid_press+0x18>
}
   48398:	f06f 0015 	mvn.w	r0, #21
   4839c:	4770      	bx	lr
        return zmk_hid_keyboard_press(ZMK_HID_USAGE_ID(usage));
   4839e:	b280      	uxth	r0, r0
   483a0:	f7e0 bf58 	b.w	29254 <zmk_hid_keyboard_press>
        return zmk_hid_consumer_press(ZMK_HID_USAGE_ID(usage));
   483a4:	b280      	uxth	r0, r0
   483a6:	f7e0 bf8f 	b.w	292c8 <zmk_hid_consumer_press>

000483aa <zmk_hid_release>:
    switch (ZMK_HID_USAGE_PAGE(usage)) {
   483aa:	f3c0 4307 	ubfx	r3, r0, #16, #8
   483ae:	2b07      	cmp	r3, #7
   483b0:	d004      	beq.n	483bc <zmk_hid_release+0x12>
   483b2:	2b0c      	cmp	r3, #12
   483b4:	d005      	beq.n	483c2 <zmk_hid_release+0x18>
}
   483b6:	f06f 0015 	mvn.w	r0, #21
   483ba:	4770      	bx	lr
        return zmk_hid_keyboard_release(ZMK_HID_USAGE_ID(usage));
   483bc:	b280      	uxth	r0, r0
   483be:	f7e0 bf61 	b.w	29284 <zmk_hid_keyboard_release>
        return zmk_hid_consumer_release(ZMK_HID_USAGE_ID(usage));
   483c2:	b280      	uxth	r0, r0
   483c4:	f7e0 bf94 	b.w	292f0 <zmk_hid_consumer_release>

000483c8 <behavior_key_press_init>:
#include <zmk/events/keycode_state_changed.h>
#include <zmk/behavior.h>

LOG_MODULE_DECLARE(zmk, CONFIG_ZMK_LOG_LEVEL);

static int behavior_key_press_init(const struct device *dev) { return 0; };
   483c8:	2000      	movs	r0, #0
   483ca:	4770      	bx	lr

000483cc <zmk_keycode_state_changed_from_encoded>:
};

ZMK_EVENT_DECLARE(zmk_keycode_state_changed);

static inline struct zmk_keycode_state_changed_event *
zmk_keycode_state_changed_from_encoded(uint32_t encoded, bool pressed, int64_t timestamp) {
   483cc:	b570      	push	{r4, r5, r6, lr}
    uint16_t page = ZMK_HID_USAGE_PAGE(encoded);
    uint16_t id = ZMK_HID_USAGE_ID(encoded);
    uint8_t implicit_modifiers = 0x00;
    uint8_t explicit_modifiers = 0x00;

    if (!page) {
   483ce:	f410 0f7f 	tst.w	r0, #16711680	; 0xff0000
   483d2:	b286      	uxth	r6, r0
    uint16_t page = ZMK_HID_USAGE_PAGE(encoded);
   483d4:	f3c0 4407 	ubfx	r4, r0, #16, #8
zmk_keycode_state_changed_from_encoded(uint32_t encoded, bool pressed, int64_t timestamp) {
   483d8:	b088      	sub	sp, #32
    zmk_key_t key;
    bool pressed;
};

static inline bool is_mod(uint8_t usage_page, uint32_t keycode) {
    return (keycode >= HID_USAGE_KEY_KEYBOARD_LEFTCONTROL &&
   483da:	f1a6 05e0 	sub.w	r5, r6, #224	; 0xe0
   483de:	ea4f 6010 	mov.w	r0, r0, lsr #24
    if (!page) {
   483e2:	d11a      	bne.n	4841a <zmk_keycode_state_changed_from_encoded+0x4e>
            keycode <= HID_USAGE_KEY_KEYBOARD_RIGHT_GUI && usage_page == HID_USAGE_KEY);
   483e4:	2d07      	cmp	r5, #7
   483e6:	d91c      	bls.n	48422 <zmk_keycode_state_changed_from_encoded+0x56>
        page = HID_USAGE_KEY;
   483e8:	2407      	movs	r4, #7
    }

    if (is_mod(page, id)) {
        explicit_modifiers = SELECT_MODS(encoded);
    } else {
        implicit_modifiers = SELECT_MODS(encoded);
   483ea:	b2c5      	uxtb	r5, r0
    uint8_t explicit_modifiers = 0x00;
   483ec:	2000      	movs	r0, #0
    }

    return new_zmk_keycode_state_changed(
        (struct zmk_keycode_state_changed){.usage_page = page,
   483ee:	e9cd 2306 	strd	r2, r3, [sp, #24]
    return new_zmk_keycode_state_changed(
   483f2:	ab08      	add	r3, sp, #32
        (struct zmk_keycode_state_changed){.usage_page = page,
   483f4:	f88d 0011 	strb.w	r0, [sp, #17]
   483f8:	f88d 1012 	strb.w	r1, [sp, #18]
    return new_zmk_keycode_state_changed(
   483fc:	e913 0003 	ldmdb	r3, {r0, r1}
   48400:	e88d 0003 	stmia.w	sp, {r0, r1}
        (struct zmk_keycode_state_changed){.usage_page = page,
   48404:	f8ad 4008 	strh.w	r4, [sp, #8]
   48408:	9603      	str	r6, [sp, #12]
   4840a:	f88d 5010 	strb.w	r5, [sp, #16]
    return new_zmk_keycode_state_changed(
   4840e:	ab02      	add	r3, sp, #8
   48410:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
   48412:	f7e1 fa99 	bl	29948 <new_zmk_keycode_state_changed>
                                           .keycode = id,
                                           .implicit_modifiers = implicit_modifiers,
                                           .explicit_modifiers = explicit_modifiers,
                                           .state = pressed,
                                           .timestamp = timestamp});
}
   48416:	b008      	add	sp, #32
   48418:	bd70      	pop	{r4, r5, r6, pc}
   4841a:	2d07      	cmp	r5, #7
   4841c:	d8e5      	bhi.n	483ea <zmk_keycode_state_changed_from_encoded+0x1e>
   4841e:	2c07      	cmp	r4, #7
   48420:	d1e3      	bne.n	483ea <zmk_keycode_state_changed_from_encoded+0x1e>
        explicit_modifiers = SELECT_MODS(encoded);
   48422:	b2c0      	uxtb	r0, r0
   48424:	2407      	movs	r4, #7
    uint8_t implicit_modifiers = 0x00;
   48426:	2500      	movs	r5, #0
   48428:	e7e1      	b.n	483ee <zmk_keycode_state_changed_from_encoded+0x22>

0004842a <on_keymap_binding_released>:
    return ZMK_EVENT_RAISE(
        zmk_keycode_state_changed_from_encoded(binding->param1, true, event.timestamp));
}

static int on_keymap_binding_released(struct zmk_behavior_binding *binding,
                                      struct zmk_behavior_binding_event event) {
   4842a:	b082      	sub	sp, #8
   4842c:	b508      	push	{r3, lr}
   4842e:	a902      	add	r1, sp, #8
   48430:	e881 000c 	stmia.w	r1, {r2, r3}
    LOG_DBG("position %d keycode 0x%02X", event.position, binding->param1);
    return ZMK_EVENT_RAISE(
   48434:	6840      	ldr	r0, [r0, #4]
   48436:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   4843a:	2100      	movs	r1, #0
   4843c:	f7ff ffc6 	bl	483cc <zmk_keycode_state_changed_from_encoded>
        zmk_keycode_state_changed_from_encoded(binding->param1, false, event.timestamp));
}
   48440:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   48444:	b002      	add	sp, #8
    return ZMK_EVENT_RAISE(
   48446:	f7ff bf1b 	b.w	48280 <zmk_event_manager_raise>

0004844a <on_keymap_binding_pressed>:
                                     struct zmk_behavior_binding_event event) {
   4844a:	b082      	sub	sp, #8
   4844c:	b508      	push	{r3, lr}
   4844e:	a902      	add	r1, sp, #8
   48450:	e881 000c 	stmia.w	r1, {r2, r3}
    return ZMK_EVENT_RAISE(
   48454:	6840      	ldr	r0, [r0, #4]
   48456:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   4845a:	2101      	movs	r1, #1
   4845c:	f7ff ffb6 	bl	483cc <zmk_keycode_state_changed_from_encoded>
}
   48460:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   48464:	b002      	add	sp, #8
    return ZMK_EVENT_RAISE(
   48466:	f7ff bf0b 	b.w	48280 <zmk_event_manager_raise>

0004846a <behavior_mo_init>:
LOG_MODULE_DECLARE(zmk, CONFIG_ZMK_LOG_LEVEL);

struct behavior_mo_config {};
struct behavior_mo_data {};

static int behavior_mo_init(const struct device *dev) { return 0; };
   4846a:	2000      	movs	r0, #0
   4846c:	4770      	bx	lr

0004846e <mo_keymap_binding_released>:
    LOG_DBG("position %d layer %d", event.position, binding->param1);
    return zmk_keymap_layer_activate(binding->param1);
}

static int mo_keymap_binding_released(struct zmk_behavior_binding *binding,
                                      struct zmk_behavior_binding_event event) {
   4846e:	b082      	sub	sp, #8
   48470:	e88d 000c 	stmia.w	sp, {r2, r3}
    LOG_DBG("position %d layer %d", event.position, binding->param1);
    return zmk_keymap_layer_deactivate(binding->param1);
   48474:	7900      	ldrb	r0, [r0, #4]
}
   48476:	b002      	add	sp, #8
    return zmk_keymap_layer_deactivate(binding->param1);
   48478:	f000 b8cc 	b.w	48614 <zmk_keymap_layer_deactivate>

0004847c <mo_keymap_binding_pressed>:
                                     struct zmk_behavior_binding_event event) {
   4847c:	b082      	sub	sp, #8
   4847e:	e88d 000c 	stmia.w	sp, {r2, r3}
    return zmk_keymap_layer_activate(binding->param1);
   48482:	7900      	ldrb	r0, [r0, #4]
}
   48484:	b002      	add	sp, #8
    return zmk_keymap_layer_activate(binding->param1);
   48486:	f000 b8c2 	b.w	4860e <zmk_keymap_layer_activate>

0004848a <behavior_transparent_init>:

LOG_MODULE_DECLARE(zmk, CONFIG_ZMK_LOG_LEVEL);

#if DT_HAS_COMPAT_STATUS_OKAY(DT_DRV_COMPAT)

static int behavior_transparent_init(const struct device *dev) { return 0; };
   4848a:	2000      	movs	r0, #0
   4848c:	4770      	bx	lr

0004848e <on_keymap_binding_pressed>:

static int on_keymap_binding_pressed(struct zmk_behavior_binding *binding,
                                     struct zmk_behavior_binding_event event) {
   4848e:	b082      	sub	sp, #8
   48490:	e88d 000c 	stmia.w	sp, {r2, r3}
    return ZMK_BEHAVIOR_TRANSPARENT;
}
   48494:	2001      	movs	r0, #1
   48496:	b002      	add	sp, #8
   48498:	4770      	bx	lr

0004849a <on_keymap_binding_released>:

static int on_keymap_binding_released(struct zmk_behavior_binding *binding,
   4849a:	b082      	sub	sp, #8
   4849c:	e88d 000c 	stmia.w	sp, {r2, r3}
   484a0:	2001      	movs	r0, #1
   484a2:	b002      	add	sp, #8
   484a4:	4770      	bx	lr

000484a6 <behavior_none_init>:

LOG_MODULE_DECLARE(zmk, CONFIG_ZMK_LOG_LEVEL);

#if DT_HAS_COMPAT_STATUS_OKAY(DT_DRV_COMPAT)

static int behavior_none_init(const struct device *dev) { return 0; };
   484a6:	2000      	movs	r0, #0
   484a8:	4770      	bx	lr

000484aa <on_keymap_binding_pressed>:

static int on_keymap_binding_pressed(struct zmk_behavior_binding *binding,
                                     struct zmk_behavior_binding_event event) {
   484aa:	b082      	sub	sp, #8
   484ac:	e88d 000c 	stmia.w	sp, {r2, r3}
    return ZMK_BEHAVIOR_OPAQUE;
}
   484b0:	2000      	movs	r0, #0
   484b2:	b002      	add	sp, #8
   484b4:	4770      	bx	lr

000484b6 <on_keymap_binding_released>:

static int on_keymap_binding_released(struct zmk_behavior_binding *binding,
   484b6:	b082      	sub	sp, #8
   484b8:	e88d 000c 	stmia.w	sp, {r2, r3}
   484bc:	2000      	movs	r0, #0
   484be:	b002      	add	sp, #8
   484c0:	4770      	bx	lr

000484c2 <behavior_sensor_rotate_var_init>:

static const struct behavior_driver_api behavior_sensor_rotate_var_driver_api = {
    .sensor_binding_accept_data = zmk_behavior_sensor_rotate_common_accept_data,
    .sensor_binding_process = zmk_behavior_sensor_rotate_common_process};

static int behavior_sensor_rotate_var_init(const struct device *dev) { return 0; };
   484c2:	2000      	movs	r0, #0
   484c4:	4770      	bx	lr

000484c6 <zmk_behavior_sensor_rotate_common_process>:

int zmk_behavior_sensor_rotate_common_process(struct zmk_behavior_binding *binding,
                                              struct zmk_behavior_binding_event event,
                                              enum behavior_sensor_binding_process_mode mode) {
   484c6:	b082      	sub	sp, #8
   484c8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   484cc:	b086      	sub	sp, #24
   484ce:	a90e      	add	r1, sp, #56	; 0x38
   484d0:	4605      	mov	r5, r0
   484d2:	e881 000c 	stmia.w	r1, {r2, r3}
   484d6:	f89d 8048 	ldrb.w	r8, [sp, #72]	; 0x48
    const struct device *dev = device_get_binding(binding->behavior_dev);
   484da:	6800      	ldr	r0, [r0, #0]
   484dc:	4617      	mov	r7, r2
   484de:	461e      	mov	r6, r3
   484e0:	f7fe fa94 	bl	46a0c <z_impl_device_get_binding>
    const struct behavior_sensor_rotate_config *cfg = dev->config;
    struct behavior_sensor_rotate_data *data = dev->data;

    const int sensor_index = ZMK_SENSOR_POSITION_FROM_VIRTUAL_KEY_POSITION(event.position);
   484e4:	f1a6 023c 	sub.w	r2, r6, #60	; 0x3c
   484e8:	0053      	lsls	r3, r2, #1

    if (mode != BEHAVIOR_SENSOR_BINDING_PROCESS_MODE_TRIGGER) {
        data->triggers[sensor_index][event.layer] = 0;
   484ea:	4413      	add	r3, r2
   484ec:	443b      	add	r3, r7
    const struct behavior_sensor_rotate_config *cfg = dev->config;
   484ee:	6844      	ldr	r4, [r0, #4]
    struct behavior_sensor_rotate_data *data = dev->data;
   484f0:	6901      	ldr	r1, [r0, #16]
        data->triggers[sensor_index][event.layer] = 0;
   484f2:	330c      	adds	r3, #12
    if (mode != BEHAVIOR_SENSOR_BINDING_PROCESS_MODE_TRIGGER) {
   484f4:	f1b8 0f00 	cmp.w	r8, #0
   484f8:	d004      	beq.n	48504 <zmk_behavior_sensor_rotate_common_process+0x3e>
        data->triggers[sensor_index][event.layer] = 0;
   484fa:	2200      	movs	r2, #0
   484fc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
        return ZMK_BEHAVIOR_TRANSPARENT;
   48500:	2001      	movs	r0, #1
   48502:	e026      	b.n	48552 <zmk_behavior_sensor_rotate_common_process+0x8c>
    }

    int triggers = data->triggers[sensor_index][event.layer];
   48504:	f851 7023 	ldr.w	r7, [r1, r3, lsl #2]

    struct zmk_behavior_binding triggered_binding;
    if (triggers > 0) {
   48508:	2f00      	cmp	r7, #0
   4850a:	dd27      	ble.n	4855c <zmk_behavior_sensor_rotate_common_process+0x96>
        triggered_binding = cfg->cw_binding;
   4850c:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
   48510:	ab06      	add	r3, sp, #24
   48512:	e903 0007 	stmdb	r3, {r0, r1, r2}
        if (cfg->override_params) {
   48516:	7f23      	ldrb	r3, [r4, #28]
   48518:	b10b      	cbz	r3, 4851e <zmk_behavior_sensor_rotate_common_process+0x58>
            triggered_binding.param1 = binding->param1;
   4851a:	686b      	ldr	r3, [r5, #4]
   4851c:	9304      	str	r3, [sp, #16]
        return ZMK_BEHAVIOR_TRANSPARENT;
    }

    LOG_DBG("Sensor binding: %s", binding->behavior_dev);

    for (int i = 0; i < triggers; i++) {
   4851e:	f04f 0800 	mov.w	r8, #0
        zmk_behavior_queue_add(event.position, triggered_binding, true, cfg->tap_ms);
   48522:	f04f 0a01 	mov.w	sl, #1
   48526:	ad03      	add	r5, sp, #12
        zmk_behavior_queue_add(event.position, triggered_binding, false, 0);
   48528:	46c1      	mov	r9, r8
        zmk_behavior_queue_add(event.position, triggered_binding, true, cfg->tap_ms);
   4852a:	69a3      	ldr	r3, [r4, #24]
   4852c:	e9cd a300 	strd	sl, r3, [sp]
   48530:	4630      	mov	r0, r6
   48532:	e895 000e 	ldmia.w	r5, {r1, r2, r3}
   48536:	f7e0 ffb3 	bl	294a0 <zmk_behavior_queue_add>
        zmk_behavior_queue_add(event.position, triggered_binding, false, 0);
   4853a:	e9cd 9900 	strd	r9, r9, [sp]
   4853e:	4630      	mov	r0, r6
   48540:	e895 000e 	ldmia.w	r5, {r1, r2, r3}
    for (int i = 0; i < triggers; i++) {
   48544:	f108 0801 	add.w	r8, r8, #1
        zmk_behavior_queue_add(event.position, triggered_binding, false, 0);
   48548:	f7e0 ffaa 	bl	294a0 <zmk_behavior_queue_add>
    for (int i = 0; i < triggers; i++) {
   4854c:	45b8      	cmp	r8, r7
   4854e:	d1ec      	bne.n	4852a <zmk_behavior_sensor_rotate_common_process+0x64>
    }

    return ZMK_BEHAVIOR_OPAQUE;
   48550:	2000      	movs	r0, #0
}
   48552:	b006      	add	sp, #24
   48554:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   48558:	b002      	add	sp, #8
   4855a:	4770      	bx	lr
    } else if (triggers < 0) {
   4855c:	d0d0      	beq.n	48500 <zmk_behavior_sensor_rotate_common_process+0x3a>
        triggered_binding = cfg->ccw_binding;
   4855e:	f104 030c 	add.w	r3, r4, #12
   48562:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
   48566:	ab06      	add	r3, sp, #24
   48568:	e903 0007 	stmdb	r3, {r0, r1, r2}
        if (cfg->override_params) {
   4856c:	7f23      	ldrb	r3, [r4, #28]
   4856e:	b90b      	cbnz	r3, 48574 <zmk_behavior_sensor_rotate_common_process+0xae>
        triggers = -triggers;
   48570:	427f      	negs	r7, r7
   48572:	e7d4      	b.n	4851e <zmk_behavior_sensor_rotate_common_process+0x58>
            triggered_binding.param1 = binding->param2;
   48574:	68ab      	ldr	r3, [r5, #8]
   48576:	9304      	str	r3, [sp, #16]
   48578:	e7fa      	b.n	48570 <zmk_behavior_sensor_rotate_common_process+0xaa>

0004857a <endpoint_listener>:

static int endpoint_listener(const zmk_event_t *eh) {
   4857a:	b508      	push	{r3, lr}
    update_current_endpoint();
   4857c:	f7e1 f810 	bl	295a0 <update_current_endpoint>
    return 0;
}
   48580:	2000      	movs	r0, #0
   48582:	bd08      	pop	{r3, pc}

00048584 <zmk_endpoints_send_report>:
    switch (usage_page) {
   48584:	2807      	cmp	r0, #7
   48586:	d004      	beq.n	48592 <zmk_endpoints_send_report+0xe>
   48588:	280c      	cmp	r0, #12
   4858a:	d004      	beq.n	48596 <zmk_endpoints_send_report+0x12>
}
   4858c:	f06f 0085 	mvn.w	r0, #133	; 0x85
   48590:	4770      	bx	lr
        return send_keyboard_report();
   48592:	f7e0 bfb1 	b.w	294f8 <send_keyboard_report>
        return send_consumer_report();
   48596:	f7e0 bfc7 	b.w	29528 <send_consumer_report>

0004859a <hid_listener>:
        }
    }
    return zmk_endpoints_send_report(ev->usage_page);
}

int hid_listener(const zmk_event_t *eh) {
   4859a:	b538      	push	{r3, r4, r5, lr}
    const struct zmk_keycode_state_changed *ev = as_zmk_keycode_state_changed(eh);
   4859c:	f7e1 f9f0 	bl	29980 <as_zmk_keycode_state_changed>
    if (ev) {
   485a0:	4604      	mov	r4, r0
   485a2:	b1e8      	cbz	r0, 485e0 <hid_listener+0x46>
    err = zmk_hid_press(ZMK_HID_USAGE(ev->usage_page, ev->keycode));
   485a4:	8803      	ldrh	r3, [r0, #0]
   485a6:	6840      	ldr	r0, [r0, #4]
   485a8:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
        if (ev->state) {
   485ac:	7aa3      	ldrb	r3, [r4, #10]
   485ae:	b1cb      	cbz	r3, 485e4 <hid_listener+0x4a>
    err = zmk_hid_press(ZMK_HID_USAGE(ev->usage_page, ev->keycode));
   485b0:	f7ff feec 	bl	4838c <zmk_hid_press>
    if (err < 0) {
   485b4:	2800      	cmp	r0, #0
   485b6:	db13      	blt.n	485e0 <hid_listener+0x46>
    explicit_mods_changed = zmk_hid_register_mods(ev->explicit_modifiers);
   485b8:	7a60      	ldrb	r0, [r4, #9]
   485ba:	f7ff fec5 	bl	48348 <zmk_hid_register_mods>
   485be:	4605      	mov	r5, r0
    implicit_mods_changed = zmk_hid_implicit_modifiers_press(ev->implicit_modifiers);
   485c0:	7a20      	ldrb	r0, [r4, #8]
   485c2:	f7e0 fe15 	bl	291f0 <zmk_hid_implicit_modifiers_press>
    if (ev->usage_page != HID_USAGE_KEY &&
   485c6:	8823      	ldrh	r3, [r4, #0]
   485c8:	2b07      	cmp	r3, #7
   485ca:	d006      	beq.n	485da <hid_listener+0x40>
   485cc:	2d00      	cmp	r5, #0
   485ce:	dc01      	bgt.n	485d4 <hid_listener+0x3a>
        (explicit_mods_changed > 0 || implicit_mods_changed > 0)) {
   485d0:	2800      	cmp	r0, #0
   485d2:	dd02      	ble.n	485da <hid_listener+0x40>
        err = zmk_endpoints_send_report(HID_USAGE_KEY);
   485d4:	2007      	movs	r0, #7
   485d6:	f7ff ffd5 	bl	48584 <zmk_endpoints_send_report>
    return zmk_endpoints_send_report(ev->usage_page);
   485da:	8820      	ldrh	r0, [r4, #0]
   485dc:	f7ff ffd2 	bl	48584 <zmk_endpoints_send_report>
        } else {
            hid_listener_keycode_released(ev);
        }
    }
    return 0;
}
   485e0:	2000      	movs	r0, #0
   485e2:	bd38      	pop	{r3, r4, r5, pc}
    err = zmk_hid_release(ZMK_HID_USAGE(ev->usage_page, ev->keycode));
   485e4:	f7ff fee1 	bl	483aa <zmk_hid_release>
    if (err < 0) {
   485e8:	2800      	cmp	r0, #0
   485ea:	dbf9      	blt.n	485e0 <hid_listener+0x46>
    explicit_mods_changed = zmk_hid_unregister_mods(ev->explicit_modifiers);
   485ec:	7a60      	ldrb	r0, [r4, #9]
   485ee:	f7ff febc 	bl	4836a <zmk_hid_unregister_mods>
   485f2:	4605      	mov	r5, r0
    implicit_mods_changed = zmk_hid_implicit_modifiers_release();
   485f4:	f7e0 fe16 	bl	29224 <zmk_hid_implicit_modifiers_release>
   485f8:	e7e5      	b.n	485c6 <hid_listener+0x2c>

000485fa <zmk_keymap_layer_active_with_state>:
bool zmk_keymap_layer_active_with_state(uint8_t layer, zmk_keymap_layers_state_t state_to_test) {
   485fa:	4603      	mov	r3, r0
    return (state_to_test & (BIT(layer))) == (BIT(layer)) || layer == _zmk_keymap_layer_default;
   485fc:	2001      	movs	r0, #1
   485fe:	fa00 f203 	lsl.w	r2, r0, r3
   48602:	438a      	bics	r2, r1
   48604:	bf1c      	itt	ne
   48606:	fab3 f083 	clzne	r0, r3
   4860a:	0940      	lsrne	r0, r0, #5
};
   4860c:	4770      	bx	lr

0004860e <zmk_keymap_layer_activate>:
int zmk_keymap_layer_activate(uint8_t layer) { return set_layer_state(layer, true); };
   4860e:	2101      	movs	r1, #1
   48610:	f7e1 b81c 	b.w	2964c <set_layer_state>

00048614 <zmk_keymap_layer_deactivate>:
int zmk_keymap_layer_deactivate(uint8_t layer) { return set_layer_state(layer, false); };
   48614:	2100      	movs	r1, #0
   48616:	f7e1 b819 	b.w	2964c <set_layer_state>

0004861a <invoke_locally>:
                   bool pressed) {
   4861a:	b082      	sub	sp, #8
   4861c:	b570      	push	{r4, r5, r6, lr}
   4861e:	b088      	sub	sp, #32
   48620:	a90c      	add	r1, sp, #48	; 0x30
   48622:	e881 000c 	stmia.w	r1, {r2, r3}
   48626:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
   4862a:	4606      	mov	r6, r0
   4862c:	466c      	mov	r4, sp
   4862e:	ad04      	add	r5, sp, #16
    if (pressed) {
   48630:	b1e3      	cbz	r3, 4866c <invoke_locally+0x52>
        return behavior_keymap_binding_pressed(binding, event);
   48632:	c90f      	ldmia	r1, {r0, r1, r2, r3}
   48634:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
	return z_impl_behavior_keymap_binding_pressed(binding, event);
   48638:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
   4863c:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
    const struct device *dev = device_get_binding(binding->behavior_dev);
   48640:	6830      	ldr	r0, [r6, #0]
   48642:	f7fe f9e3 	bl	46a0c <z_impl_device_get_binding>
    if (dev == NULL) {
   48646:	b300      	cbz	r0, 4868a <invoke_locally+0x70>
    if (api->binding_pressed == NULL) {
   48648:	6883      	ldr	r3, [r0, #8]
   4864a:	689c      	ldr	r4, [r3, #8]
    if (api->binding_released == NULL) {
   4864c:	b324      	cbz	r4, 48698 <invoke_locally+0x7e>
    return api->binding_released(binding, event);
   4864e:	aa08      	add	r2, sp, #32
   48650:	e912 0003 	ldmdb	r2, {r0, r1}
   48654:	ab0e      	add	r3, sp, #56	; 0x38
   48656:	e883 0003 	stmia.w	r3, {r0, r1}
   4865a:	e895 000c 	ldmia.w	r5, {r2, r3}
   4865e:	4630      	mov	r0, r6
   48660:	4621      	mov	r1, r4
}
   48662:	b008      	add	sp, #32
   48664:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   48668:	b002      	add	sp, #8
   4866a:	4708      	bx	r1
        return behavior_keymap_binding_released(binding, event);
   4866c:	ab0c      	add	r3, sp, #48	; 0x30
   4866e:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
   48670:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
	return z_impl_behavior_keymap_binding_released(binding, event);
   48674:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
   48678:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
    const struct device *dev = device_get_binding(binding->behavior_dev);
   4867c:	6830      	ldr	r0, [r6, #0]
   4867e:	f7fe f9c5 	bl	46a0c <z_impl_device_get_binding>
    if (dev == NULL) {
   48682:	b110      	cbz	r0, 4868a <invoke_locally+0x70>
    if (api->binding_released == NULL) {
   48684:	6883      	ldr	r3, [r0, #8]
   48686:	68dc      	ldr	r4, [r3, #12]
   48688:	e7e0      	b.n	4864c <invoke_locally+0x32>
        return -EINVAL;
   4868a:	f06f 0015 	mvn.w	r0, #21
}
   4868e:	b008      	add	sp, #32
   48690:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   48694:	b002      	add	sp, #8
   48696:	4770      	bx	lr
        return -ENOTSUP;
   48698:	f06f 0085 	mvn.w	r0, #133	; 0x85
        return behavior_keymap_binding_released(binding, event);
   4869c:	e7f7      	b.n	4868e <invoke_locally+0x74>

0004869e <keymap_listener>:

#endif /* ZMK_KEYMAP_HAS_SENSORS */

int keymap_listener(const zmk_event_t *eh) {
   4869e:	b537      	push	{r0, r1, r2, r4, r5, lr}
   486a0:	4604      	mov	r4, r0
    const struct zmk_position_state_changed *pos_ev;
    if ((pos_ev = as_zmk_position_state_changed(eh)) != NULL) {
   486a2:	f7e0 fcc9 	bl	29038 <as_zmk_position_state_changed>
   486a6:	4603      	mov	r3, r0
   486a8:	b150      	cbz	r0, 486c0 <keymap_listener+0x22>
        return zmk_keymap_position_state_changed(pos_ev->source, pos_ev->position, pos_ev->state,
   486aa:	e9d3 4504 	ldrd	r4, r5, [r3, #16]
   486ae:	7a02      	ldrb	r2, [r0, #8]
   486b0:	7800      	ldrb	r0, [r0, #0]
   486b2:	e9cd 4500 	strd	r4, r5, [sp]
   486b6:	6859      	ldr	r1, [r3, #4]
   486b8:	f7e1 f886 	bl	297c8 <zmk_keymap_position_state_changed>
                                       sensor_ev->channel_data_size, sensor_ev->timestamp);
    }
#endif /* ZMK_KEYMAP_HAS_SENSORS */

    return -ENOTSUP;
}
   486bc:	b003      	add	sp, #12
   486be:	bd30      	pop	{r4, r5, pc}
    if ((sensor_ev = as_zmk_sensor_event(eh)) != NULL) {
   486c0:	4620      	mov	r0, r4
   486c2:	f7e0 fcdf 	bl	29084 <as_zmk_sensor_event>
   486c6:	4601      	mov	r1, r0
   486c8:	b150      	cbz	r0, 486e0 <keymap_listener+0x42>
        return zmk_keymap_sensor_event(sensor_ev->sensor_index, sensor_ev->channel_data,
   486ca:	e9d1 2304 	ldrd	r2, r3, [r1, #16]
   486ce:	7e00      	ldrb	r0, [r0, #24]
   486d0:	e9cd 2300 	strd	r2, r3, [sp]
   486d4:	3104      	adds	r1, #4
   486d6:	f851 2c04 	ldr.w	r2, [r1, #-4]
   486da:	f7e1 f89f 	bl	2981c <zmk_keymap_sensor_event>
   486de:	e7ed      	b.n	486bc <keymap_listener+0x1e>
    return -ENOTSUP;
   486e0:	f06f 0085 	mvn.w	r0, #133	; 0x85
   486e4:	e7ea      	b.n	486bc <keymap_listener+0x1e>

000486e6 <behavior_bt_init>:
    }

    return -ENOTSUP;
}

static int behavior_bt_init(const struct device *dev) { return 0; };
   486e6:	2000      	movs	r0, #0
   486e8:	4770      	bx	lr

000486ea <on_keymap_binding_released>:

static int on_keymap_binding_released(struct zmk_behavior_binding *binding,
                                      struct zmk_behavior_binding_event event) {
   486ea:	b082      	sub	sp, #8
   486ec:	e88d 000c 	stmia.w	sp, {r2, r3}
    return ZMK_BEHAVIOR_OPAQUE;
}
   486f0:	2000      	movs	r0, #0
   486f2:	b002      	add	sp, #8
   486f4:	4770      	bx	lr

000486f6 <on_keymap_binding_pressed>:
                                     struct zmk_behavior_binding_event event) {
   486f6:	b082      	sub	sp, #8
   486f8:	e88d 000c 	stmia.w	sp, {r2, r3}
    switch (binding->param1) {
   486fc:	6843      	ldr	r3, [r0, #4]
   486fe:	2b03      	cmp	r3, #3
   48700:	d810      	bhi.n	48724 <on_keymap_binding_pressed+0x2e>
   48702:	e8df f003 	tbb	[pc, r3]
   48706:	0502      	.short	0x0502
   48708:	0b08      	.short	0x0b08
}
   4870a:	b002      	add	sp, #8
        return zmk_ble_clear_bonds();
   4870c:	f7e1 bb9e 	b.w	29e4c <zmk_ble_clear_bonds>
}
   48710:	b002      	add	sp, #8
        return zmk_ble_prof_next();
   48712:	f7e1 bbdb 	b.w	29ecc <zmk_ble_prof_next>
}
   48716:	b002      	add	sp, #8
        return zmk_ble_prof_prev();
   48718:	f7e1 bbe6 	b.w	29ee8 <zmk_ble_prof_prev>
        return zmk_ble_prof_select(binding->param2);
   4871c:	7a00      	ldrb	r0, [r0, #8]
}
   4871e:	b002      	add	sp, #8
        return zmk_ble_prof_select(binding->param2);
   48720:	f7e1 bbb8 	b.w	29e94 <zmk_ble_prof_select>
}
   48724:	f06f 0085 	mvn.w	r0, #133	; 0x85
   48728:	b002      	add	sp, #8
   4872a:	4770      	bx	lr

0004872c <raise_profile_changed_event_callback>:
    raise_profile_changed_event();
   4872c:	f7e1 b948 	b.w	299c0 <raise_profile_changed_event>

00048730 <auth_cancel>:
static void auth_cancel(struct bt_conn *conn) {
   48730:	b500      	push	{lr}
   48732:	b089      	sub	sp, #36	; 0x24
    bt_addr_le_to_str(bt_conn_get_dst(conn), addr, sizeof(addr));
   48734:	f003 fc20 	bl	4bf78 <bt_conn_get_dst>
   48738:	4669      	mov	r1, sp
   4873a:	f7e1 f963 	bl	29a04 <bt_addr_le_to_str.constprop.0.isra.0>
}
   4873e:	b009      	add	sp, #36	; 0x24
   48740:	f85d fb04 	ldr.w	pc, [sp], #4

00048744 <security_changed>:
static void security_changed(struct bt_conn *conn, bt_security_t level, enum bt_security_err err) {
   48744:	b500      	push	{lr}
   48746:	b089      	sub	sp, #36	; 0x24
    bt_addr_le_to_str(bt_conn_get_dst(conn), addr, sizeof(addr));
   48748:	f003 fc16 	bl	4bf78 <bt_conn_get_dst>
   4874c:	4669      	mov	r1, sp
   4874e:	f7e1 f959 	bl	29a04 <bt_addr_le_to_str.constprop.0.isra.0>
}
   48752:	b009      	add	sp, #36	; 0x24
   48754:	f85d fb04 	ldr.w	pc, [sp], #4

00048758 <le_param_updated>:
                             uint16_t timeout) {
   48758:	b500      	push	{lr}
   4875a:	b089      	sub	sp, #36	; 0x24
    bt_addr_le_to_str(bt_conn_get_dst(conn), addr, sizeof(addr));
   4875c:	f003 fc0c 	bl	4bf78 <bt_conn_get_dst>
   48760:	4669      	mov	r1, sp
   48762:	f7e1 f94f 	bl	29a04 <bt_addr_le_to_str.constprop.0.isra.0>
}
   48766:	b009      	add	sp, #36	; 0x24
   48768:	f85d fb04 	ldr.w	pc, [sp], #4

0004876c <auth_pairing_accept>:
                                                const struct bt_conn_pairing_feat *const feat) {
   4876c:	b500      	push	{lr}
   4876e:	b08b      	sub	sp, #44	; 0x2c
    bt_conn_get_info(conn, &info);
   48770:	a901      	add	r1, sp, #4
   48772:	f7e7 fd4d 	bl	30210 <bt_conn_get_info>
    if (info.role == BT_CONN_ROLE_PERIPHERAL && !zmk_ble_active_profile_is_open()) {
   48776:	f89d 3005 	ldrb.w	r3, [sp, #5]
   4877a:	2b01      	cmp	r3, #1
   4877c:	d102      	bne.n	48784 <auth_pairing_accept+0x18>
   4877e:	f7e1 fa0f 	bl	29ba0 <zmk_ble_active_profile_is_open>
   48782:	b118      	cbz	r0, 4878c <auth_pairing_accept+0x20>
    return BT_SECURITY_ERR_SUCCESS;
   48784:	2000      	movs	r0, #0
};
   48786:	b00b      	add	sp, #44	; 0x2c
   48788:	f85d fb04 	ldr.w	pc, [sp], #4
        return BT_SECURITY_ERR_PAIR_NOT_ALLOWED;
   4878c:	2006      	movs	r0, #6
   4878e:	e7fa      	b.n	48786 <auth_pairing_accept+0x1a>

00048790 <update_advertising_callback>:
static void update_advertising_callback(struct k_work *work) { update_advertising(); }
   48790:	f7e1 ba76 	b.w	29c80 <update_advertising>

00048794 <input_ccc_changed>:
}
   48794:	4770      	bx	lr

00048796 <write_ctrl_point>:
                                const void *buf, uint16_t len, uint16_t offset, uint8_t flags) {
   48796:	b538      	push	{r3, r4, r5, lr}
   48798:	460c      	mov	r4, r1
   4879a:	f8bd 0010 	ldrh.w	r0, [sp, #16]
    uint8_t *value = attr->user_data;
   4879e:	68e5      	ldr	r5, [r4, #12]
    if (offset + len > sizeof(ctrl_point)) {
   487a0:	461c      	mov	r4, r3
   487a2:	18c3      	adds	r3, r0, r3
   487a4:	2b01      	cmp	r3, #1
                                const void *buf, uint16_t len, uint16_t offset, uint8_t flags) {
   487a6:	4611      	mov	r1, r2
    if (offset + len > sizeof(ctrl_point)) {
   487a8:	dc05      	bgt.n	487b6 <write_ctrl_point+0x20>
    memcpy(value + offset, buf, len);
   487aa:	4622      	mov	r2, r4
   487ac:	4428      	add	r0, r5
   487ae:	f002 fb64 	bl	4ae7a <memcpy>
}
   487b2:	4620      	mov	r0, r4
   487b4:	bd38      	pop	{r3, r4, r5, pc}
        return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   487b6:	f06f 0406 	mvn.w	r4, #6
   487ba:	e7fa      	b.n	487b2 <write_ctrl_point+0x1c>

000487bc <read_hids_consumer_input_report>:
                                               uint16_t len, uint16_t offset) {
   487bc:	b5f0      	push	{r4, r5, r6, r7, lr}
   487be:	b085      	sub	sp, #20
   487c0:	461f      	mov	r7, r3
   487c2:	4604      	mov	r4, r0
   487c4:	460d      	mov	r5, r1
   487c6:	4616      	mov	r6, r2
    struct zmk_hid_consumer_report_body *report_body = &zmk_hid_get_consumer_report()->body;
   487c8:	f7e0 fdb2 	bl	29330 <zmk_hid_get_consumer_report>
    return bt_gatt_attr_read(conn, attr, buf, len, offset, report_body,
   487cc:	230c      	movs	r3, #12
   487ce:	9302      	str	r3, [sp, #8]
    struct zmk_hid_consumer_report_body *report_body = &zmk_hid_get_consumer_report()->body;
   487d0:	3001      	adds	r0, #1
    return bt_gatt_attr_read(conn, attr, buf, len, offset, report_body,
   487d2:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
   487d6:	9001      	str	r0, [sp, #4]
   487d8:	9300      	str	r3, [sp, #0]
   487da:	4632      	mov	r2, r6
   487dc:	463b      	mov	r3, r7
   487de:	4629      	mov	r1, r5
   487e0:	4620      	mov	r0, r4
   487e2:	f004 fe9b 	bl	4d51c <bt_gatt_attr_read>
}
   487e6:	b005      	add	sp, #20
   487e8:	bdf0      	pop	{r4, r5, r6, r7, pc}

000487ea <read_hids_report_ref>:
                                    void *buf, uint16_t len, uint16_t offset) {
   487ea:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    return bt_gatt_attr_read(conn, attr, buf, len, offset, attr->user_data,
   487ec:	2402      	movs	r4, #2
   487ee:	9402      	str	r4, [sp, #8]
   487f0:	68cc      	ldr	r4, [r1, #12]
   487f2:	9401      	str	r4, [sp, #4]
   487f4:	f8bd 4018 	ldrh.w	r4, [sp, #24]
   487f8:	9400      	str	r4, [sp, #0]
   487fa:	f004 fe8f 	bl	4d51c <bt_gatt_attr_read>
}
   487fe:	b004      	add	sp, #16
   48800:	bd10      	pop	{r4, pc}

00048802 <read_hids_info>:
                              uint16_t len, uint16_t offset) {
   48802:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    return bt_gatt_attr_read(conn, attr, buf, len, offset, attr->user_data,
   48804:	2404      	movs	r4, #4
   48806:	9402      	str	r4, [sp, #8]
   48808:	68cc      	ldr	r4, [r1, #12]
   4880a:	9401      	str	r4, [sp, #4]
   4880c:	f8bd 4018 	ldrh.w	r4, [sp, #24]
   48810:	9400      	str	r4, [sp, #0]
   48812:	f004 fe83 	bl	4d51c <bt_gatt_attr_read>
}
   48816:	b004      	add	sp, #16
   48818:	bd10      	pop	{r4, pc}

0004881a <read_hids_input_report>:
                                      void *buf, uint16_t len, uint16_t offset) {
   4881a:	b5f0      	push	{r4, r5, r6, r7, lr}
   4881c:	b085      	sub	sp, #20
   4881e:	461f      	mov	r7, r3
   48820:	4604      	mov	r4, r0
   48822:	460d      	mov	r5, r1
   48824:	4616      	mov	r6, r2
    struct zmk_hid_keyboard_report_body *report_body = &zmk_hid_get_keyboard_report()->body;
   48826:	f7e0 fd7f 	bl	29328 <zmk_hid_get_keyboard_report>
    return bt_gatt_attr_read(conn, attr, buf, len, offset, report_body,
   4882a:	2308      	movs	r3, #8
   4882c:	9302      	str	r3, [sp, #8]
    struct zmk_hid_keyboard_report_body *report_body = &zmk_hid_get_keyboard_report()->body;
   4882e:	3001      	adds	r0, #1
    return bt_gatt_attr_read(conn, attr, buf, len, offset, report_body,
   48830:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
   48834:	9001      	str	r0, [sp, #4]
   48836:	9300      	str	r3, [sp, #0]
   48838:	4632      	mov	r2, r6
   4883a:	463b      	mov	r3, r7
   4883c:	4629      	mov	r1, r5
   4883e:	4620      	mov	r0, r4
   48840:	f004 fe6c 	bl	4d51c <bt_gatt_attr_read>
}
   48844:	b005      	add	sp, #20
   48846:	bdf0      	pop	{r4, r5, r6, r7, pc}

00048848 <release_peripheral_slot_for_conn>:
int release_peripheral_slot_for_conn(struct bt_conn *conn) {
   48848:	b508      	push	{r3, lr}
    int idx = peripheral_slot_index_for_conn(conn);
   4884a:	f7e1 fe1d 	bl	2a488 <peripheral_slot_index_for_conn>
    if (idx < 0) {
   4884e:	2800      	cmp	r0, #0
   48850:	db03      	blt.n	4885a <release_peripheral_slot_for_conn+0x12>
}
   48852:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    return release_peripheral_slot(idx);
   48856:	f7e1 bf7b 	b.w	2a750 <release_peripheral_slot>
}
   4885a:	bd08      	pop	{r3, pc}

0004885c <split_central_disconnected>:
static void split_central_disconnected(struct bt_conn *conn, uint8_t reason) {
   4885c:	b510      	push	{r4, lr}
   4885e:	b088      	sub	sp, #32
   48860:	4604      	mov	r4, r0
    bt_addr_le_to_str(bt_conn_get_dst(conn), addr, sizeof(addr));
   48862:	f003 fb89 	bl	4bf78 <bt_conn_get_dst>
   48866:	4669      	mov	r1, sp
   48868:	f7e1 fd28 	bl	2a2bc <bt_addr_le_to_str.constprop.0.isra.0>
    err = release_peripheral_slot_for_conn(conn);
   4886c:	4620      	mov	r0, r4
   4886e:	f7ff ffeb 	bl	48848 <release_peripheral_slot_for_conn>
    if (err < 0) {
   48872:	2800      	cmp	r0, #0
   48874:	db01      	blt.n	4887a <split_central_disconnected+0x1e>
    start_scanning();
   48876:	f7e1 fcb7 	bl	2a1e8 <start_scanning>
}
   4887a:	b008      	add	sp, #32
   4887c:	bd10      	pop	{r4, pc}

0004887e <zmk_split_bt_invoke_behavior>:
                                 struct zmk_behavior_binding_event event, bool state) {
   4887e:	b082      	sub	sp, #8
   48880:	b530      	push	{r4, r5, lr}
   48882:	b08d      	sub	sp, #52	; 0x34
   48884:	4604      	mov	r4, r0
   48886:	a810      	add	r0, sp, #64	; 0x40
   48888:	e880 000c 	stmia.w	r0, {r2, r3}
    struct zmk_split_run_behavior_payload payload = {.data = {
   4888c:	2300      	movs	r3, #0
   4888e:	f8cd 3012 	str.w	r3, [sp, #18]
   48892:	f8cd 3016 	str.w	r3, [sp, #22]
   48896:	f88d 301a 	strb.w	r3, [sp, #26]
   4889a:	9b11      	ldr	r3, [sp, #68]	; 0x44
   4889c:	f88d 3008 	strb.w	r3, [sp, #8]
   488a0:	f89d 3050 	ldrb.w	r3, [sp, #80]	; 0x50
   488a4:	f88d 3009 	strb.w	r3, [sp, #9]
   488a8:	684b      	ldr	r3, [r1, #4]
   488aa:	f8cd 300a 	str.w	r3, [sp, #10]
    if (strlcpy(payload.behavior_dev, binding->behavior_dev, payload_dev_size) >=
   488ae:	2209      	movs	r2, #9
    struct zmk_split_run_behavior_payload payload = {.data = {
   488b0:	688b      	ldr	r3, [r1, #8]
    if (strlcpy(payload.behavior_dev, binding->behavior_dev, payload_dev_size) >=
   488b2:	6809      	ldr	r1, [r1, #0]
    struct zmk_split_run_behavior_payload payload = {.data = {
   488b4:	f8cd 300e 	str.w	r3, [sp, #14]
    if (strlcpy(payload.behavior_dev, binding->behavior_dev, payload_dev_size) >=
   488b8:	f10d 0012 	add.w	r0, sp, #18
   488bc:	f7ff fcc1 	bl	48242 <strlcpy>
    struct zmk_split_run_behavior_payload_wrapper wrapper = {.source = source, .payload = payload};
   488c0:	ad06      	add	r5, sp, #24
   488c2:	f88d 401c 	strb.w	r4, [sp, #28]
   488c6:	aa02      	add	r2, sp, #8
   488c8:	f10d 031d 	add.w	r3, sp, #29
   488cc:	4614      	mov	r4, r2
   488ce:	cc03      	ldmia	r4!, {r0, r1}
   488d0:	42ac      	cmp	r4, r5
   488d2:	6018      	str	r0, [r3, #0]
   488d4:	6059      	str	r1, [r3, #4]
   488d6:	4622      	mov	r2, r4
   488d8:	f103 0308 	add.w	r3, r3, #8
   488dc:	d1f6      	bne.n	488cc <zmk_split_bt_invoke_behavior+0x4e>
   488de:	8821      	ldrh	r1, [r4, #0]
   488e0:	78a2      	ldrb	r2, [r4, #2]
   488e2:	709a      	strb	r2, [r3, #2]
   488e4:	8019      	strh	r1, [r3, #0]
    return split_bt_invoke_behavior_payload(wrapper);
   488e6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   488e8:	9300      	str	r3, [sp, #0]
   488ea:	ab07      	add	r3, sp, #28
   488ec:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
   488ee:	f7e1 fcb5 	bl	2a25c <split_bt_invoke_behavior_payload>
}
   488f2:	b00d      	add	sp, #52	; 0x34
   488f4:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   488f8:	b002      	add	sp, #8
   488fa:	4770      	bx	lr

000488fc <raise_usb_status_changed_event>:
static void raise_usb_status_changed_event(struct k_work *_work) {
   488fc:	b508      	push	{r3, lr}
    ZMK_EVENT_RAISE(new_zmk_usb_conn_state_changed(
   488fe:	f7e2 f8a1 	bl	2aa44 <zmk_usb_get_conn_state>
   48902:	f7e0 fbc9 	bl	29098 <new_zmk_usb_conn_state_changed>
}
   48906:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    ZMK_EVENT_RAISE(new_zmk_usb_conn_state_changed(
   4890a:	f7ff bcb9 	b.w	48280 <zmk_event_manager_raise>

0004890e <u8_to_dec>:
 */

#include <zephyr/sys/util.h>

uint8_t u8_to_dec(char *buf, uint8_t buflen, uint8_t value)
{
   4890e:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint8_t divisor = 100;
   48910:	2364      	movs	r3, #100	; 0x64
{
   48912:	4605      	mov	r5, r0
	uint8_t num_digits = 0;
	uint8_t digit;

	while (buflen > 0 && divisor > 0) {
   48914:	2604      	movs	r6, #4
	uint8_t num_digits = 0;
   48916:	2000      	movs	r0, #0
			buflen--;
			num_digits++;
		}

		value -= digit * divisor;
		divisor /= 10;
   48918:	270a      	movs	r7, #10
	while (buflen > 0 && divisor > 0) {
   4891a:	b969      	cbnz	r1, 48938 <u8_to_dec+0x2a>
	if (buflen) {
		*buf = '\0';
	}

	return num_digits;
}
   4891c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (digit != 0 || divisor == 1 || num_digits != 0) {
   4891e:	429a      	cmp	r2, r3
   48920:	fbb2 f4f3 	udiv	r4, r2, r3
   48924:	d20c      	bcs.n	48940 <u8_to_dec+0x32>
   48926:	2b01      	cmp	r3, #1
   48928:	d00a      	beq.n	48940 <u8_to_dec+0x32>
   4892a:	b948      	cbnz	r0, 48940 <u8_to_dec+0x32>
		value -= digit * divisor;
   4892c:	fb03 2214 	mls	r2, r3, r4, r2
   48930:	b2d2      	uxtb	r2, r2
		divisor /= 10;
   48932:	240a      	movs	r4, #10
   48934:	fbb3 f3f4 	udiv	r3, r3, r4
	while (buflen > 0 && divisor > 0) {
   48938:	3e01      	subs	r6, #1
   4893a:	d1f0      	bne.n	4891e <u8_to_dec+0x10>
		*buf = '\0';
   4893c:	702e      	strb	r6, [r5, #0]
	return num_digits;
   4893e:	e7ed      	b.n	4891c <u8_to_dec+0xe>
			*buf = (char)digit + '0';
   48940:	3430      	adds	r4, #48	; 0x30
   48942:	f805 4b01 	strb.w	r4, [r5], #1
			buflen--;
   48946:	fbb2 f4f3 	udiv	r4, r2, r3
   4894a:	3901      	subs	r1, #1
   4894c:	fb03 2214 	mls	r2, r3, r4, r2
			num_digits++;
   48950:	3001      	adds	r0, #1
		divisor /= 10;
   48952:	fbb3 f3f7 	udiv	r3, r3, r7
			buflen--;
   48956:	b2c9      	uxtb	r1, r1
			num_digits++;
   48958:	b2c0      	uxtb	r0, r0
		value -= digit * divisor;
   4895a:	b2d2      	uxtb	r2, r2
		divisor /= 10;
   4895c:	b2db      	uxtb	r3, r3
   4895e:	e7dc      	b.n	4891a <u8_to_dec+0xc>

00048960 <char2hex>:
#include <errno.h>
#include <zephyr/sys/util.h>

int char2hex(char c, uint8_t *x)
{
	if (c >= '0' && c <= '9') {
   48960:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
   48964:	b2db      	uxtb	r3, r3
   48966:	2b09      	cmp	r3, #9
   48968:	d802      	bhi.n	48970 <char2hex+0x10>
		*x = c - '0';
   4896a:	700b      	strb	r3, [r1, #0]
		*x = c - 'A' + 10;
	} else {
		return -EINVAL;
	}

	return 0;
   4896c:	2000      	movs	r0, #0
   4896e:	4770      	bx	lr
	} else if (c >= 'a' && c <= 'f') {
   48970:	f1a0 0361 	sub.w	r3, r0, #97	; 0x61
   48974:	2b05      	cmp	r3, #5
   48976:	d802      	bhi.n	4897e <char2hex+0x1e>
		*x = c - 'a' + 10;
   48978:	3857      	subs	r0, #87	; 0x57
		*x = c - 'A' + 10;
   4897a:	b2c3      	uxtb	r3, r0
   4897c:	e7f5      	b.n	4896a <char2hex+0xa>
	} else if (c >= 'A' && c <= 'F') {
   4897e:	f1a0 0341 	sub.w	r3, r0, #65	; 0x41
   48982:	2b05      	cmp	r3, #5
   48984:	d801      	bhi.n	4898a <char2hex+0x2a>
		*x = c - 'A' + 10;
   48986:	3837      	subs	r0, #55	; 0x37
   48988:	e7f7      	b.n	4897a <char2hex+0x1a>
		return -EINVAL;
   4898a:	f06f 0015 	mvn.w	r0, #21
}
   4898e:	4770      	bx	lr

00048990 <hex2bin>:
	hex[2 * buflen] = '\0';
	return 2 * buflen;
}

size_t hex2bin(const char *hex, size_t hexlen, uint8_t *buf, size_t buflen)
{
   48990:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   48992:	4605      	mov	r5, r0
	uint8_t dec;

	if (buflen < hexlen / 2 + hexlen % 2) {
   48994:	f001 0001 	and.w	r0, r1, #1
   48998:	eb00 0651 	add.w	r6, r0, r1, lsr #1
   4899c:	429e      	cmp	r6, r3
   4899e:	ea4f 0751 	mov.w	r7, r1, lsr #1
   489a2:	d903      	bls.n	489ac <hex2bin+0x1c>
		return 0;
   489a4:	2600      	movs	r6, #0
		}
		buf[i] += dec;
	}

	return hexlen / 2 + hexlen % 2;
}
   489a6:	4630      	mov	r0, r6
   489a8:	b003      	add	sp, #12
   489aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (hexlen % 2) {
   489ac:	b158      	cbz	r0, 489c6 <hex2bin+0x36>
		if (char2hex(hex[0], &dec) < 0) {
   489ae:	7828      	ldrb	r0, [r5, #0]
   489b0:	f10d 0107 	add.w	r1, sp, #7
   489b4:	f7ff ffd4 	bl	48960 <char2hex>
   489b8:	2800      	cmp	r0, #0
   489ba:	dbf3      	blt.n	489a4 <hex2bin+0x14>
		buf[0] = dec;
   489bc:	f89d 3007 	ldrb.w	r3, [sp, #7]
   489c0:	f802 3b01 	strb.w	r3, [r2], #1
		hex++;
   489c4:	3501      	adds	r5, #1
	for (size_t i = 0; i < hexlen / 2; i++) {
   489c6:	3501      	adds	r5, #1
   489c8:	4417      	add	r7, r2
   489ca:	42ba      	cmp	r2, r7
   489cc:	d0eb      	beq.n	489a6 <hex2bin+0x16>
		if (char2hex(hex[2 * i], &dec) < 0) {
   489ce:	f815 0c01 	ldrb.w	r0, [r5, #-1]
   489d2:	f10d 0107 	add.w	r1, sp, #7
   489d6:	f7ff ffc3 	bl	48960 <char2hex>
   489da:	2800      	cmp	r0, #0
   489dc:	dbe2      	blt.n	489a4 <hex2bin+0x14>
		buf[i] = dec << 4;
   489de:	f89d 4007 	ldrb.w	r4, [sp, #7]
   489e2:	0124      	lsls	r4, r4, #4
   489e4:	b2e4      	uxtb	r4, r4
   489e6:	7014      	strb	r4, [r2, #0]
		if (char2hex(hex[2 * i + 1], &dec) < 0) {
   489e8:	f815 0b02 	ldrb.w	r0, [r5], #2
   489ec:	f7ff ffb8 	bl	48960 <char2hex>
   489f0:	2800      	cmp	r0, #0
   489f2:	dbd7      	blt.n	489a4 <hex2bin+0x14>
		buf[i] += dec;
   489f4:	f89d 3007 	ldrb.w	r3, [sp, #7]
   489f8:	441c      	add	r4, r3
   489fa:	f802 4b01 	strb.w	r4, [r2], #1
	for (size_t i = 0; i < hexlen / 2; i++) {
   489fe:	e7e4      	b.n	489ca <hex2bin+0x3a>

00048a00 <sys_notify_validate>:

int sys_notify_validate(struct sys_notify *notify)
{
	int rv = 0;

	if (notify == NULL) {
   48a00:	4603      	mov	r3, r0
   48a02:	b140      	cbz	r0, 48a16 <sys_notify_validate+0x16>
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
   48a04:	6842      	ldr	r2, [r0, #4]
	return method & SYS_NOTIFY_METHOD_MASK;
   48a06:	f002 0203 	and.w	r2, r2, #3
		return -EINVAL;
	}

	/* Validate configuration based on mode */
	switch (sys_notify_get_method(notify)) {
   48a0a:	2a02      	cmp	r2, #2
   48a0c:	d006      	beq.n	48a1c <sys_notify_validate+0x1c>
   48a0e:	2a03      	cmp	r2, #3
   48a10:	d004      	beq.n	48a1c <sys_notify_validate+0x1c>
   48a12:	2a01      	cmp	r2, #1
   48a14:	d005      	beq.n	48a22 <sys_notify_validate+0x22>
   48a16:	f06f 0015 	mvn.w	r0, #21
	if (rv == 0) {
		notify->result = 0;
	}

	return rv;
}
   48a1a:	4770      	bx	lr
		if (notify->method.signal == NULL) {
   48a1c:	681a      	ldr	r2, [r3, #0]
   48a1e:	2a00      	cmp	r2, #0
   48a20:	d0f9      	beq.n	48a16 <sys_notify_validate+0x16>
		notify->result = 0;
   48a22:	2000      	movs	r0, #0
   48a24:	6098      	str	r0, [r3, #8]
   48a26:	4770      	bx	lr

00048a28 <sys_notify_finalize>:

sys_notify_generic_callback sys_notify_finalize(struct sys_notify *notify,
						    int res)
{
   48a28:	b510      	push	{r4, lr}
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
   48a2a:	6842      	ldr	r2, [r0, #4]
	uint32_t method = sys_notify_get_method(notify);

	/* Store the result and capture secondary notification
	 * information.
	 */
	notify->result = res;
   48a2c:	6081      	str	r1, [r0, #8]
	return method & SYS_NOTIFY_METHOD_MASK;
   48a2e:	f002 0203 	and.w	r2, r2, #3
	switch (method) {
   48a32:	2a02      	cmp	r2, #2
{
   48a34:	4603      	mov	r3, r0
	switch (method) {
   48a36:	f04f 0400 	mov.w	r4, #0
   48a3a:	d007      	beq.n	48a4c <sys_notify_finalize+0x24>
   48a3c:	2a03      	cmp	r2, #3
   48a3e:	d002      	beq.n	48a46 <sys_notify_finalize+0x1e>
	/* Mark completion by clearing the flags field to the
	 * completed state, releasing any spin-waiters, then complete
	 * secondary notification.
	 */
	compiler_barrier();
	notify->flags = SYS_NOTIFY_METHOD_COMPLETED;
   48a40:	605c      	str	r4, [r3, #4]
	sys_notify_generic_callback rv = NULL;
   48a42:	2000      	movs	r0, #0
   48a44:	e001      	b.n	48a4a <sys_notify_finalize+0x22>
		rv = notify->method.callback;
   48a46:	6818      	ldr	r0, [r3, #0]
	notify->flags = SYS_NOTIFY_METHOD_COMPLETED;
   48a48:	605c      	str	r4, [r3, #4]
	if (IS_ENABLED(CONFIG_POLL) && (sig != NULL)) {
		k_poll_signal_raise(sig, res);
	}

	return rv;
}
   48a4a:	bd10      	pop	{r4, pc}
		sig = notify->method.signal;
   48a4c:	6818      	ldr	r0, [r3, #0]
	notify->flags = SYS_NOTIFY_METHOD_COMPLETED;
   48a4e:	605c      	str	r4, [r3, #4]
	if (IS_ENABLED(CONFIG_POLL) && (sig != NULL)) {
   48a50:	2800      	cmp	r0, #0
   48a52:	d0f6      	beq.n	48a42 <sys_notify_finalize+0x1a>
	return z_impl_k_poll_signal_raise(sig, result);
   48a54:	f7ff fb9a 	bl	4818c <z_impl_k_poll_signal_raise>
   48a58:	e7f3      	b.n	48a42 <sys_notify_finalize+0x1a>

00048a5a <arch_printk_char_out>:
}
   48a5a:	2000      	movs	r0, #0
   48a5c:	4770      	bx	lr

00048a5e <str_out>:
{
   48a5e:	b530      	push	{r4, r5, lr}
	if (ctx->str == NULL || ctx->count >= ctx->max) {
   48a60:	688a      	ldr	r2, [r1, #8]
   48a62:	680c      	ldr	r4, [r1, #0]
		ctx->str[ctx->count++] = '\0';
   48a64:	1c55      	adds	r5, r2, #1
	if (ctx->str == NULL || ctx->count >= ctx->max) {
   48a66:	b114      	cbz	r4, 48a6e <str_out+0x10>
   48a68:	684b      	ldr	r3, [r1, #4]
   48a6a:	4293      	cmp	r3, r2
   48a6c:	dc01      	bgt.n	48a72 <str_out+0x14>
		ctx->count++;
   48a6e:	608d      	str	r5, [r1, #8]
}
   48a70:	bd30      	pop	{r4, r5, pc}
	if (ctx->count == ctx->max - 1) {
   48a72:	3b01      	subs	r3, #1
   48a74:	4293      	cmp	r3, r2
		ctx->str[ctx->count++] = '\0';
   48a76:	bf08      	it	eq
   48a78:	2200      	moveq	r2, #0
   48a7a:	608d      	str	r5, [r1, #8]
   48a7c:	bf0c      	ite	eq
   48a7e:	54e2      	strbeq	r2, [r4, r3]
		ctx->str[ctx->count++] = c;
   48a80:	54a0      	strbne	r0, [r4, r2]
   48a82:	e7f5      	b.n	48a70 <str_out+0x12>

00048a84 <printk>:
{
   48a84:	b40f      	push	{r0, r1, r2, r3}
   48a86:	b507      	push	{r0, r1, r2, lr}
   48a88:	a904      	add	r1, sp, #16
   48a8a:	f851 0b04 	ldr.w	r0, [r1], #4
	va_start(ap, fmt);
   48a8e:	9101      	str	r1, [sp, #4]
	vprintk(fmt, ap);
   48a90:	f7e2 f876 	bl	2ab80 <vprintk>
}
   48a94:	b003      	add	sp, #12
   48a96:	f85d eb04 	ldr.w	lr, [sp], #4
   48a9a:	b004      	add	sp, #16
   48a9c:	4770      	bx	lr

00048a9e <snprintk>:
{
   48a9e:	b40c      	push	{r2, r3}
   48aa0:	b507      	push	{r0, r1, r2, lr}
   48aa2:	ab04      	add	r3, sp, #16
   48aa4:	f853 2b04 	ldr.w	r2, [r3], #4
	va_start(ap, fmt);
   48aa8:	9301      	str	r3, [sp, #4]
	ret = vsnprintk(str, size, fmt, ap);
   48aaa:	f7e2 f877 	bl	2ab9c <vsnprintk>
}
   48aae:	b003      	add	sp, #12
   48ab0:	f85d eb04 	ldr.w	lr, [sp], #4
   48ab4:	b002      	add	sp, #8
   48ab6:	4770      	bx	lr

00048ab8 <sys_slist_find_and_remove>:
	return list->head;
   48ab8:	6803      	ldr	r3, [r0, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   48aba:	2200      	movs	r2, #0
   48abc:	b90b      	cbnz	r3, 48ac2 <sys_slist_find_and_remove+0xa>
   48abe:	4618      	mov	r0, r3
   48ac0:	4770      	bx	lr
   48ac2:	428b      	cmp	r3, r1
   48ac4:	d110      	bne.n	48ae8 <sys_slist_find_and_remove+0x30>
	return node->next;
   48ac6:	680b      	ldr	r3, [r1, #0]
Z_GENLIST_REMOVE(slist, snode)
   48ac8:	b942      	cbnz	r2, 48adc <sys_slist_find_and_remove+0x24>
   48aca:	6842      	ldr	r2, [r0, #4]
	list->head = node;
   48acc:	6003      	str	r3, [r0, #0]
Z_GENLIST_REMOVE(slist, snode)
   48ace:	4291      	cmp	r1, r2
   48ad0:	d100      	bne.n	48ad4 <sys_slist_find_and_remove+0x1c>
	list->tail = node;
   48ad2:	6043      	str	r3, [r0, #4]
	parent->next = child;
   48ad4:	2300      	movs	r3, #0
   48ad6:	600b      	str	r3, [r1, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   48ad8:	2001      	movs	r0, #1
Z_GENLIST_REMOVE(slist, snode)
   48ada:	4770      	bx	lr
	parent->next = child;
   48adc:	6013      	str	r3, [r2, #0]
Z_GENLIST_REMOVE(slist, snode)
   48ade:	6843      	ldr	r3, [r0, #4]
   48ae0:	4299      	cmp	r1, r3
	list->tail = node;
   48ae2:	bf08      	it	eq
   48ae4:	6042      	streq	r2, [r0, #4]
}
   48ae6:	e7f5      	b.n	48ad4 <sys_slist_find_and_remove+0x1c>
	return node->next;
   48ae8:	461a      	mov	r2, r3
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   48aea:	681b      	ldr	r3, [r3, #0]
   48aec:	e7e6      	b.n	48abc <sys_slist_find_and_remove+0x4>

00048aee <process_recheck>:
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   48aee:	8b03      	ldrh	r3, [r0, #24]
	if ((state == ONOFF_STATE_OFF)
   48af0:	f013 0307 	ands.w	r3, r3, #7
   48af4:	d105      	bne.n	48b02 <process_recheck+0x14>
	    && !sys_slist_is_empty(&mgr->clients)) {
   48af6:	6803      	ldr	r3, [r0, #0]
		evt = EVT_START;
   48af8:	2b00      	cmp	r3, #0
   48afa:	bf0c      	ite	eq
   48afc:	2000      	moveq	r0, #0
   48afe:	2003      	movne	r0, #3
   48b00:	4770      	bx	lr
	} else if ((state == ONOFF_STATE_ON)
   48b02:	2b02      	cmp	r3, #2
   48b04:	d105      	bne.n	48b12 <process_recheck+0x24>
		   && (mgr->refs == 0U)) {
   48b06:	8b40      	ldrh	r0, [r0, #26]
   48b08:	fab0 f080 	clz	r0, r0
   48b0c:	0940      	lsrs	r0, r0, #5
   48b0e:	0080      	lsls	r0, r0, #2
   48b10:	4770      	bx	lr
	} else if ((state == ONOFF_STATE_ERROR)
   48b12:	2b01      	cmp	r3, #1
   48b14:	d105      	bne.n	48b22 <process_recheck+0x34>
		   && !sys_slist_is_empty(&mgr->clients)) {
   48b16:	6803      	ldr	r3, [r0, #0]
		evt = EVT_RESET;
   48b18:	2b00      	cmp	r3, #0
   48b1a:	bf0c      	ite	eq
   48b1c:	2000      	moveq	r0, #0
   48b1e:	2005      	movne	r0, #5
   48b20:	4770      	bx	lr
	int evt = EVT_NOP;
   48b22:	2000      	movs	r0, #0
}
   48b24:	4770      	bx	lr

00048b26 <validate_args>:
{
   48b26:	b510      	push	{r4, lr}
   48b28:	460c      	mov	r4, r1
	if ((mgr == NULL) || (cli == NULL)) {
   48b2a:	b100      	cbz	r0, 48b2e <validate_args+0x8>
   48b2c:	b911      	cbnz	r1, 48b34 <validate_args+0xe>
		return -EINVAL;
   48b2e:	f06f 0015 	mvn.w	r0, #21
}
   48b32:	bd10      	pop	{r4, pc}
	int rv = sys_notify_validate(&cli->notify);
   48b34:	1d08      	adds	r0, r1, #4
   48b36:	f7ff ff63 	bl	48a00 <sys_notify_validate>
	if ((rv == 0)
   48b3a:	2800      	cmp	r0, #0
   48b3c:	d1f9      	bne.n	48b32 <validate_args+0xc>
	    && ((cli->notify.flags
   48b3e:	68a3      	ldr	r3, [r4, #8]
   48b40:	2b03      	cmp	r3, #3
   48b42:	d9f6      	bls.n	48b32 <validate_args+0xc>
   48b44:	e7f3      	b.n	48b2e <validate_args+0x8>

00048b46 <notify_one>:
{
   48b46:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   48b4a:	460d      	mov	r5, r1
   48b4c:	4607      	mov	r7, r0
		(onoff_client_callback)sys_notify_finalize(&cli->notify, res);
   48b4e:	4619      	mov	r1, r3
   48b50:	1d28      	adds	r0, r5, #4
{
   48b52:	4690      	mov	r8, r2
   48b54:	461e      	mov	r6, r3
		(onoff_client_callback)sys_notify_finalize(&cli->notify, res);
   48b56:	f7ff ff67 	bl	48a28 <sys_notify_finalize>
	if (cb) {
   48b5a:	4604      	mov	r4, r0
   48b5c:	b138      	cbz	r0, 48b6e <notify_one+0x28>
		cb(mgr, cli, state, res);
   48b5e:	4633      	mov	r3, r6
   48b60:	4642      	mov	r2, r8
   48b62:	4629      	mov	r1, r5
   48b64:	4638      	mov	r0, r7
   48b66:	46a4      	mov	ip, r4
}
   48b68:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		cb(mgr, cli, state, res);
   48b6c:	4760      	bx	ip
}
   48b6e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00048b72 <transition_complete>:
{
   48b72:	b410      	push	{r4}
	__asm__ volatile(
   48b74:	f04f 0420 	mov.w	r4, #32
   48b78:	f3ef 8211 	mrs	r2, BASEPRI
   48b7c:	f384 8812 	msr	BASEPRI_MAX, r4
   48b80:	f3bf 8f6f 	isb	sy
	mgr->last_res = res;
   48b84:	6141      	str	r1, [r0, #20]
}
   48b86:	bc10      	pop	{r4}
	process_event(mgr, EVT_COMPLETE, key);
   48b88:	2101      	movs	r1, #1
   48b8a:	f7e2 b81d 	b.w	2abc8 <process_event>

00048b8e <onoff_manager_init>:
{
   48b8e:	b538      	push	{r3, r4, r5, lr}
   48b90:	460c      	mov	r4, r1
	if ((mgr == NULL)
   48b92:	4605      	mov	r5, r0
   48b94:	b158      	cbz	r0, 48bae <onoff_manager_init+0x20>
	    || (transitions == NULL)
   48b96:	b151      	cbz	r1, 48bae <onoff_manager_init+0x20>
	    || (transitions->start == NULL)
   48b98:	680b      	ldr	r3, [r1, #0]
   48b9a:	b143      	cbz	r3, 48bae <onoff_manager_init+0x20>
	    || (transitions->stop == NULL)) {
   48b9c:	684b      	ldr	r3, [r1, #4]
   48b9e:	b133      	cbz	r3, 48bae <onoff_manager_init+0x20>
	*mgr = (struct onoff_manager)ONOFF_MANAGER_INITIALIZER(transitions);
   48ba0:	221c      	movs	r2, #28
   48ba2:	2100      	movs	r1, #0
   48ba4:	f002 f974 	bl	4ae90 <memset>
   48ba8:	612c      	str	r4, [r5, #16]
	return 0;
   48baa:	2000      	movs	r0, #0
}
   48bac:	bd38      	pop	{r3, r4, r5, pc}
		return -EINVAL;
   48bae:	f06f 0015 	mvn.w	r0, #21
   48bb2:	e7fb      	b.n	48bac <onoff_manager_init+0x1e>

00048bb4 <onoff_request>:

int onoff_request(struct onoff_manager *mgr,
		  struct onoff_client *cli)
{
   48bb4:	b570      	push	{r4, r5, r6, lr}
   48bb6:	4605      	mov	r5, r0
   48bb8:	460e      	mov	r6, r1
	bool add_client = false;        /* add client to pending list */
	bool start = false;             /* trigger a start transition */
	bool notify = false;            /* do client notification */
	int rv = validate_args(mgr, cli);
   48bba:	f7ff ffb4 	bl	48b26 <validate_args>

	if (rv < 0) {
   48bbe:	1e04      	subs	r4, r0, #0
   48bc0:	db15      	blt.n	48bee <onoff_request+0x3a>
   48bc2:	f04f 0320 	mov.w	r3, #32
   48bc6:	f3ef 8211 	mrs	r2, BASEPRI
   48bca:	f383 8812 	msr	BASEPRI_MAX, r3
   48bce:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&mgr->lock);
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;

	/* Reject if this would overflow the reference count. */
	if (mgr->refs == SERVICE_REFS_MAX) {
   48bd2:	8b6b      	ldrh	r3, [r5, #26]
   48bd4:	8b2c      	ldrh	r4, [r5, #24]
   48bd6:	f64f 71ff 	movw	r1, #65535	; 0xffff
   48bda:	428b      	cmp	r3, r1
   48bdc:	f004 0407 	and.w	r4, r4, #7
   48be0:	d107      	bne.n	48bf2 <onoff_request+0x3e>
	__asm__ volatile(
   48be2:	f382 8811 	msr	BASEPRI, r2
   48be6:	f3bf 8f6f 	isb	sy
		rv = -EAGAIN;
   48bea:	f06f 040a 	mvn.w	r4, #10
			notify_one(mgr, cli, state, 0);
		}
	}

	return rv;
}
   48bee:	4620      	mov	r0, r4
   48bf0:	bd70      	pop	{r4, r5, r6, pc}
	if (state == ONOFF_STATE_ON) {
   48bf2:	2c02      	cmp	r4, #2
   48bf4:	d10c      	bne.n	48c10 <onoff_request+0x5c>
		mgr->refs += 1U;
   48bf6:	3301      	adds	r3, #1
   48bf8:	836b      	strh	r3, [r5, #26]
   48bfa:	f382 8811 	msr	BASEPRI, r2
   48bfe:	f3bf 8f6f 	isb	sy
			notify_one(mgr, cli, state, 0);
   48c02:	2300      	movs	r3, #0
   48c04:	4622      	mov	r2, r4
   48c06:	4631      	mov	r1, r6
   48c08:	4628      	mov	r0, r5
   48c0a:	f7ff ff9c 	bl	48b46 <notify_one>
   48c0e:	e7ee      	b.n	48bee <onoff_request+0x3a>
	} else if ((state == ONOFF_STATE_OFF)
   48c10:	2c06      	cmp	r4, #6
   48c12:	d814      	bhi.n	48c3e <onoff_request+0x8a>
   48c14:	e8df f004 	tbb	[pc, r4]
   48c18:	13131304 	.word	0x13131304
   48c1c:	1a04      	.short	0x1a04
   48c1e:	04          	.byte	0x04
   48c1f:	00          	.byte	0x00
	parent->next = child;
   48c20:	2300      	movs	r3, #0
   48c22:	6033      	str	r3, [r6, #0]
	return list->tail;
   48c24:	686b      	ldr	r3, [r5, #4]
Z_GENLIST_APPEND(slist, snode)
   48c26:	b93b      	cbnz	r3, 48c38 <onoff_request+0x84>
	list->head = node;
   48c28:	e9c5 6600 	strd	r6, r6, [r5]
	if (start) {
   48c2c:	b9ac      	cbnz	r4, 48c5a <onoff_request+0xa6>
		process_event(mgr, EVT_RECHECK, key);
   48c2e:	2102      	movs	r1, #2
   48c30:	4628      	mov	r0, r5
   48c32:	f7e1 ffc9 	bl	2abc8 <process_event>
   48c36:	e7da      	b.n	48bee <onoff_request+0x3a>
	parent->next = child;
   48c38:	601e      	str	r6, [r3, #0]
	list->tail = node;
   48c3a:	606e      	str	r6, [r5, #4]
}
   48c3c:	e7f6      	b.n	48c2c <onoff_request+0x78>
   48c3e:	f382 8811 	msr	BASEPRI, r2
   48c42:	f3bf 8f6f 	isb	sy
		rv = -EIO;
   48c46:	f06f 0404 	mvn.w	r4, #4
   48c4a:	e7d0      	b.n	48bee <onoff_request+0x3a>
   48c4c:	f382 8811 	msr	BASEPRI, r2
   48c50:	f3bf 8f6f 	isb	sy
   48c54:	f06f 0485 	mvn.w	r4, #133	; 0x85
   48c58:	e7c9      	b.n	48bee <onoff_request+0x3a>
   48c5a:	f382 8811 	msr	BASEPRI, r2
   48c5e:	f3bf 8f6f 	isb	sy
		if (notify) {
   48c62:	e7c4      	b.n	48bee <onoff_request+0x3a>

00048c64 <onoff_release>:

int onoff_release(struct onoff_manager *mgr)
{
   48c64:	b510      	push	{r4, lr}
	__asm__ volatile(
   48c66:	f04f 0320 	mov.w	r3, #32
   48c6a:	f3ef 8211 	mrs	r2, BASEPRI
   48c6e:	f383 8812 	msr	BASEPRI_MAX, r3
   48c72:	f3bf 8f6f 	isb	sy
	bool stop = false;      /* trigger a stop transition */

	k_spinlock_key_t key = k_spin_lock(&mgr->lock);
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   48c76:	8b04      	ldrh	r4, [r0, #24]
   48c78:	f004 0407 	and.w	r4, r4, #7
	int rv = state;

	if (state != ONOFF_STATE_ON) {
   48c7c:	2c02      	cmp	r4, #2
   48c7e:	d00a      	beq.n	48c96 <onoff_release+0x32>
		if (state == ONOFF_STATE_ERROR) {
			rv = -EIO;
		} else {
			rv = -ENOTSUP;
   48c80:	2c01      	cmp	r4, #1
   48c82:	bf0c      	ite	eq
   48c84:	f06f 0004 	mvneq.w	r0, #4
   48c88:	f06f 0085 	mvnne.w	r0, #133	; 0x85
	__asm__ volatile(
   48c8c:	f382 8811 	msr	BASEPRI, r2
   48c90:	f3bf 8f6f 	isb	sy
		process_event(mgr, EVT_RECHECK, key);
	} else {
		k_spin_unlock(&mgr->lock, key);
	}

	return rv;
   48c94:	e008      	b.n	48ca8 <onoff_release+0x44>
	mgr->refs -= 1U;
   48c96:	8b43      	ldrh	r3, [r0, #26]
   48c98:	3b01      	subs	r3, #1
   48c9a:	b29b      	uxth	r3, r3
   48c9c:	8343      	strh	r3, [r0, #26]
	if (stop) {
   48c9e:	b923      	cbnz	r3, 48caa <onoff_release+0x46>
		process_event(mgr, EVT_RECHECK, key);
   48ca0:	4621      	mov	r1, r4
   48ca2:	f7e1 ff91 	bl	2abc8 <process_event>
	int rv = state;
   48ca6:	4620      	mov	r0, r4
}
   48ca8:	bd10      	pop	{r4, pc}
	int rv = state;
   48caa:	4620      	mov	r0, r4
   48cac:	e7ee      	b.n	48c8c <onoff_release+0x28>

00048cae <onoff_cancel>:
	return rv;
}

int onoff_cancel(struct onoff_manager *mgr,
		 struct onoff_client *cli)
{
   48cae:	b538      	push	{r3, r4, r5, lr}
	if ((mgr == NULL) || (cli == NULL)) {
   48cb0:	b1b0      	cbz	r0, 48ce0 <onoff_cancel+0x32>
   48cb2:	b1a9      	cbz	r1, 48ce0 <onoff_cancel+0x32>
	__asm__ volatile(
   48cb4:	f04f 0220 	mov.w	r2, #32
   48cb8:	f3ef 8511 	mrs	r5, BASEPRI
   48cbc:	f382 8812 	msr	BASEPRI_MAX, r2
   48cc0:	f3bf 8f6f 	isb	sy
		return -EINVAL;
	}

	int rv = -EALREADY;
	k_spinlock_key_t key = k_spin_lock(&mgr->lock);
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   48cc4:	8b04      	ldrh	r4, [r0, #24]

	if (sys_slist_find_and_remove(&mgr->clients, &cli->node)) {
   48cc6:	f7ff fef7 	bl	48ab8 <sys_slist_find_and_remove>
   48cca:	b130      	cbz	r0, 48cda <onoff_cancel+0x2c>
		__ASSERT_NO_MSG((state == ONOFF_STATE_TO_ON)
				|| (state == ONOFF_STATE_TO_OFF)
				|| (state == ONOFF_STATE_RESETTING));
		rv = state;
   48ccc:	f004 0007 	and.w	r0, r4, #7
	__asm__ volatile(
   48cd0:	f385 8811 	msr	BASEPRI, r5
   48cd4:	f3bf 8f6f 	isb	sy
	}

	k_spin_unlock(&mgr->lock, key);

	return rv;
}
   48cd8:	bd38      	pop	{r3, r4, r5, pc}
	int rv = -EALREADY;
   48cda:	f06f 0077 	mvn.w	r0, #119	; 0x77
   48cde:	e7f7      	b.n	48cd0 <onoff_cancel+0x22>
		return -EINVAL;
   48ce0:	f06f 0015 	mvn.w	r0, #21
   48ce4:	e7f8      	b.n	48cd8 <onoff_cancel+0x2a>

00048ce6 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
   48ce6:	4604      	mov	r4, r0
   48ce8:	b508      	push	{r3, lr}
   48cea:	4608      	mov	r0, r1
   48cec:	4611      	mov	r1, r2
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
   48cee:	461a      	mov	r2, r3
   48cf0:	47a0      	blx	r4
	return z_impl_z_current_get();
   48cf2:	f7fe ff67 	bl	47bc4 <z_impl_z_current_get>
	z_impl_k_thread_abort(thread);
   48cf6:	f7e4 fa95 	bl	2d224 <z_impl_k_thread_abort>

00048cfa <chunk_size>:
	void *cmem = &buf[c];

	if (big_heap(h)) {
		return ((uint32_t *)cmem)[f];
	} else {
		return ((uint16_t *)cmem)[f];
   48cfa:	eb00 00c1 	add.w	r0, r0, r1, lsl #3
   48cfe:	8840      	ldrh	r0, [r0, #2]
}

static inline chunksz_t chunk_size(struct z_heap *h, chunkid_t c)
{
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
}
   48d00:	0840      	lsrs	r0, r0, #1
   48d02:	4770      	bx	lr

00048d04 <free_list_add>:
	h->free_bytes += chunksz_to_bytes(h, chunk_size(h, c));
#endif
}

static void free_list_add(struct z_heap *h, chunkid_t c)
{
   48d04:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   48d06:	4603      	mov	r3, r0
	if (!solo_free_header(h, c)) {
		int bidx = bucket_idx(h, chunk_size(h, c));
   48d08:	f7ff fff7 	bl	48cfa <chunk_size>
}

static inline int bucket_idx(struct z_heap *h, chunksz_t sz)
{
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
	return 31 - __builtin_clz(usable_sz);
   48d0c:	fab0 f080 	clz	r0, r0
   48d10:	f1c0 001f 	rsb	r0, r0, #31
	if (b->next == 0U) {
   48d14:	eb03 0c80 	add.w	ip, r3, r0, lsl #2
	void *cmem = &buf[c];
   48d18:	00ca      	lsls	r2, r1, #3
   48d1a:	f8dc 6010 	ldr.w	r6, [ip, #16]
		((uint16_t *)cmem)[f] = val;
   48d1e:	1d17      	adds	r7, r2, #4
{
   48d20:	460c      	mov	r4, r1
   48d22:	3206      	adds	r2, #6
   48d24:	b28d      	uxth	r5, r1
	if (b->next == 0U) {
   48d26:	b956      	cbnz	r6, 48d3e <free_list_add+0x3a>
		h->avail_buckets |= BIT(bidx);
   48d28:	2101      	movs	r1, #1
   48d2a:	fa01 f000 	lsl.w	r0, r1, r0
   48d2e:	68d9      	ldr	r1, [r3, #12]
   48d30:	4301      	orrs	r1, r0
   48d32:	60d9      	str	r1, [r3, #12]
		b->next = c;
   48d34:	f8cc 4010 	str.w	r4, [ip, #16]
   48d38:	53dd      	strh	r5, [r3, r7]
   48d3a:	529d      	strh	r5, [r3, r2]
		free_list_add_bidx(h, c, bidx);
	}
}
   48d3c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	void *cmem = &buf[c];
   48d3e:	00f1      	lsls	r1, r6, #3
		return ((uint16_t *)cmem)[f];
   48d40:	3104      	adds	r1, #4
   48d42:	5a58      	ldrh	r0, [r3, r1]
		((uint16_t *)cmem)[f] = val;
   48d44:	53d8      	strh	r0, [r3, r7]
   48d46:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
   48d4a:	529e      	strh	r6, [r3, r2]
   48d4c:	80c5      	strh	r5, [r0, #6]
   48d4e:	525d      	strh	r5, [r3, r1]
   48d50:	e7f4      	b.n	48d3c <free_list_add+0x38>

00048d52 <free_list_remove_bidx>:
{
   48d52:	b510      	push	{r4, lr}
		return ((uint16_t *)cmem)[f];
   48d54:	eb00 04c1 	add.w	r4, r0, r1, lsl #3
   48d58:	88e3      	ldrh	r3, [r4, #6]
	if (next_free_chunk(h, c) == c) {
   48d5a:	4299      	cmp	r1, r3
   48d5c:	f102 0104 	add.w	r1, r2, #4
   48d60:	d10a      	bne.n	48d78 <free_list_remove_bidx+0x26>
		h->avail_buckets &= ~BIT(bidx);
   48d62:	2301      	movs	r3, #1
   48d64:	fa03 f202 	lsl.w	r2, r3, r2
   48d68:	68c3      	ldr	r3, [r0, #12]
   48d6a:	ea23 0302 	bic.w	r3, r3, r2
   48d6e:	60c3      	str	r3, [r0, #12]
		b->next = 0;
   48d70:	2300      	movs	r3, #0
   48d72:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
}
   48d76:	bd10      	pop	{r4, pc}
   48d78:	88a2      	ldrh	r2, [r4, #4]
		b->next = second;
   48d7a:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
		((uint16_t *)cmem)[f] = val;
   48d7e:	eb00 01c2 	add.w	r1, r0, r2, lsl #3
   48d82:	eb00 00c3 	add.w	r0, r0, r3, lsl #3
   48d86:	80cb      	strh	r3, [r1, #6]
   48d88:	8082      	strh	r2, [r0, #4]
}
   48d8a:	e7f4      	b.n	48d76 <free_list_remove_bidx+0x24>

00048d8c <free_list_remove>:
{
   48d8c:	b508      	push	{r3, lr}
   48d8e:	4603      	mov	r3, r0
		int bidx = bucket_idx(h, chunk_size(h, c));
   48d90:	f7ff ffb3 	bl	48cfa <chunk_size>
	return 31 - __builtin_clz(usable_sz);
   48d94:	fab0 f280 	clz	r2, r0
		free_list_remove_bidx(h, c, bidx);
   48d98:	f1c2 021f 	rsb	r2, r2, #31
   48d9c:	4618      	mov	r0, r3
}
   48d9e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		free_list_remove_bidx(h, c, bidx);
   48da2:	f7ff bfd6 	b.w	48d52 <free_list_remove_bidx>

00048da6 <alloc_chunk>:

	return chunk_sz - (addr - chunk_base);
}

static chunkid_t alloc_chunk(struct z_heap *h, chunksz_t sz)
{
   48da6:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   48daa:	fab1 f581 	clz	r5, r1
   48dae:	f1c5 091f 	rsb	r9, r5, #31
	 * course.  But even in pathological situations we still
	 * maintain our constant time performance and at worst see
	 * fragmentation waste of the order of the block allocated
	 * only.
	 */
	if (b->next) {
   48db2:	eb00 0889 	add.w	r8, r0, r9, lsl #2
{
   48db6:	4603      	mov	r3, r0
	if (b->next) {
   48db8:	f8d8 2010 	ldr.w	r2, [r8, #16]
{
   48dbc:	460e      	mov	r6, r1
	if (b->next) {
   48dbe:	b1c2      	cbz	r2, 48df2 <alloc_chunk+0x4c>
   48dc0:	2703      	movs	r7, #3
		chunkid_t first = b->next;
		int i = CONFIG_SYS_HEAP_ALLOC_LOOPS;
		do {
			chunkid_t c = b->next;
   48dc2:	f8d8 4010 	ldr.w	r4, [r8, #16]
			if (chunk_size(h, c) >= sz) {
   48dc6:	4618      	mov	r0, r3
   48dc8:	4621      	mov	r1, r4
   48dca:	f7ff ff96 	bl	48cfa <chunk_size>
   48dce:	42b0      	cmp	r0, r6
   48dd0:	d306      	bcc.n	48de0 <alloc_chunk+0x3a>
				free_list_remove_bidx(h, c, bi);
   48dd2:	464a      	mov	r2, r9

	if (bmask != 0U) {
		int minbucket = __builtin_ctz(bmask);
		chunkid_t c = h->buckets[minbucket].next;

		free_list_remove_bidx(h, c, minbucket);
   48dd4:	4618      	mov	r0, r3
   48dd6:	f7ff ffbc 	bl	48d52 <free_list_remove_bidx>
		CHECK(chunk_size(h, c) >= sz);
		return c;
	}

	return 0;
}
   48dda:	4620      	mov	r0, r4
   48ddc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return ((uint16_t *)cmem)[f];
   48de0:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
		} while (--i && b->next != first);
   48de4:	3f01      	subs	r7, #1
   48de6:	88e0      	ldrh	r0, [r4, #6]
			b->next = next_free_chunk(h, c);
   48de8:	f8c8 0010 	str.w	r0, [r8, #16]
		} while (--i && b->next != first);
   48dec:	d001      	beq.n	48df2 <alloc_chunk+0x4c>
   48dee:	4282      	cmp	r2, r0
   48df0:	d1e7      	bne.n	48dc2 <alloc_chunk+0x1c>
	uint32_t bmask = h->avail_buckets & ~BIT_MASK(bi + 1);
   48df2:	f1c5 0220 	rsb	r2, r5, #32
   48df6:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   48dfa:	4094      	lsls	r4, r2
   48dfc:	68da      	ldr	r2, [r3, #12]
	if (bmask != 0U) {
   48dfe:	4014      	ands	r4, r2
   48e00:	d0eb      	beq.n	48dda <alloc_chunk+0x34>
		int minbucket = __builtin_ctz(bmask);
   48e02:	fa94 f2a4 	rbit	r2, r4
   48e06:	fab2 f282 	clz	r2, r2
		chunkid_t c = h->buckets[minbucket].next;
   48e0a:	1d11      	adds	r1, r2, #4
   48e0c:	f853 4021 	ldr.w	r4, [r3, r1, lsl #2]
		free_list_remove_bidx(h, c, minbucket);
   48e10:	4621      	mov	r1, r4
   48e12:	e7df      	b.n	48dd4 <alloc_chunk+0x2e>

00048e14 <merge_chunks>:
{
   48e14:	b538      	push	{r3, r4, r5, lr}
   48e16:	4603      	mov	r3, r0
	chunksz_t newsz = chunk_size(h, lc) + chunk_size(h, rc);
   48e18:	f7ff ff6f 	bl	48cfa <chunk_size>
{
   48e1c:	460d      	mov	r5, r1
	chunksz_t newsz = chunk_size(h, lc) + chunk_size(h, rc);
   48e1e:	4604      	mov	r4, r0
   48e20:	4611      	mov	r1, r2
   48e22:	4618      	mov	r0, r3
   48e24:	f7ff ff69 	bl	48cfa <chunk_size>
		((uint16_t *)cmem)[f] = val;
   48e28:	eb03 05c5 	add.w	r5, r3, r5, lsl #3
   48e2c:	4404      	add	r4, r0
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   48e2e:	0060      	lsls	r0, r4, #1
		((uint16_t *)cmem)[f] = val;
   48e30:	8068      	strh	r0, [r5, #2]
	return c + chunk_size(h, c);
   48e32:	4618      	mov	r0, r3
   48e34:	f7ff ff61 	bl	48cfa <chunk_size>
	void *cmem = &buf[c];
   48e38:	4401      	add	r1, r0
		((uint16_t *)cmem)[f] = val;
   48e3a:	f823 4031 	strh.w	r4, [r3, r1, lsl #3]
}
   48e3e:	bd38      	pop	{r3, r4, r5, pc}

00048e40 <split_chunks>:
{
   48e40:	b538      	push	{r3, r4, r5, lr}
   48e42:	4603      	mov	r3, r0
	chunksz_t sz0 = chunk_size(h, lc);
   48e44:	f7ff ff59 	bl	48cfa <chunk_size>
{
   48e48:	460c      	mov	r4, r1
	chunksz_t rsz = sz0 - lsz;
   48e4a:	1aa5      	subs	r5, r4, r2
	chunksz_t lsz = rc - lc;
   48e4c:	1a51      	subs	r1, r2, r1
   48e4e:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
	chunksz_t rsz = sz0 - lsz;
   48e52:	4405      	add	r5, r0
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   48e54:	0048      	lsls	r0, r1, #1
		((uint16_t *)cmem)[f] = val;
   48e56:	8060      	strh	r0, [r4, #2]
   48e58:	eb03 00c2 	add.w	r0, r3, r2, lsl #3
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   48e5c:	006c      	lsls	r4, r5, #1
		((uint16_t *)cmem)[f] = val;
   48e5e:	8044      	strh	r4, [r0, #2]
   48e60:	f823 1032 	strh.w	r1, [r3, r2, lsl #3]
	return c + chunk_size(h, c);
   48e64:	4618      	mov	r0, r3
   48e66:	4611      	mov	r1, r2
   48e68:	f7ff ff47 	bl	48cfa <chunk_size>
	void *cmem = &buf[c];
   48e6c:	4401      	add	r1, r0
		((uint16_t *)cmem)[f] = val;
   48e6e:	f823 5031 	strh.w	r5, [r3, r1, lsl #3]
}
   48e72:	bd38      	pop	{r3, r4, r5, pc}

00048e74 <free_chunk>:
{
   48e74:	b538      	push	{r3, r4, r5, lr}
   48e76:	4605      	mov	r5, r0
	return c + chunk_size(h, c);
   48e78:	f7ff ff3f 	bl	48cfa <chunk_size>
   48e7c:	460c      	mov	r4, r1
   48e7e:	4401      	add	r1, r0
		return ((uint16_t *)cmem)[f];
   48e80:	eb05 03c1 	add.w	r3, r5, r1, lsl #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
   48e84:	885b      	ldrh	r3, [r3, #2]
	if (!chunk_used(h, right_chunk(h, c))) {
   48e86:	07da      	lsls	r2, r3, #31
   48e88:	d40a      	bmi.n	48ea0 <free_chunk+0x2c>
		free_list_remove(h, right_chunk(h, c));
   48e8a:	4628      	mov	r0, r5
   48e8c:	f7ff ff7e 	bl	48d8c <free_list_remove>
	return c + chunk_size(h, c);
   48e90:	4621      	mov	r1, r4
   48e92:	4628      	mov	r0, r5
   48e94:	f7ff ff31 	bl	48cfa <chunk_size>
		merge_chunks(h, c, right_chunk(h, c));
   48e98:	1822      	adds	r2, r4, r0
   48e9a:	4628      	mov	r0, r5
   48e9c:	f7ff ffba 	bl	48e14 <merge_chunks>
		return ((uint16_t *)cmem)[f];
   48ea0:	f835 1034 	ldrh.w	r1, [r5, r4, lsl #3]
	return c - chunk_field(h, c, LEFT_SIZE);
   48ea4:	1a61      	subs	r1, r4, r1
		return ((uint16_t *)cmem)[f];
   48ea6:	eb05 03c1 	add.w	r3, r5, r1, lsl #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
   48eaa:	885b      	ldrh	r3, [r3, #2]
	if (!chunk_used(h, left_chunk(h, c))) {
   48eac:	07db      	lsls	r3, r3, #31
   48eae:	d40c      	bmi.n	48eca <free_chunk+0x56>
		free_list_remove(h, left_chunk(h, c));
   48eb0:	4628      	mov	r0, r5
   48eb2:	f7ff ff6b 	bl	48d8c <free_list_remove>
		return ((uint16_t *)cmem)[f];
   48eb6:	f835 1034 	ldrh.w	r1, [r5, r4, lsl #3]
		merge_chunks(h, left_chunk(h, c), c);
   48eba:	4622      	mov	r2, r4
   48ebc:	1a61      	subs	r1, r4, r1
   48ebe:	4628      	mov	r0, r5
   48ec0:	f7ff ffa8 	bl	48e14 <merge_chunks>
   48ec4:	f835 3034 	ldrh.w	r3, [r5, r4, lsl #3]
	return c - chunk_field(h, c, LEFT_SIZE);
   48ec8:	1ae4      	subs	r4, r4, r3
	free_list_add(h, c);
   48eca:	4621      	mov	r1, r4
   48ecc:	4628      	mov	r0, r5
}
   48ece:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	free_list_add(h, c);
   48ed2:	f7ff bf17 	b.w	48d04 <free_list_add>

00048ed6 <sys_heap_free>:
	if (mem == NULL) {
   48ed6:	b161      	cbz	r1, 48ef2 <sys_heap_free+0x1c>
   48ed8:	6800      	ldr	r0, [r0, #0]
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   48eda:	3904      	subs	r1, #4
   48edc:	1a09      	subs	r1, r1, r0
	void *cmem = &buf[c];
   48ede:	f021 0307 	bic.w	r3, r1, #7
   48ee2:	4403      	add	r3, r0
	free_chunk(h, c);
   48ee4:	08c9      	lsrs	r1, r1, #3
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
   48ee6:	885a      	ldrh	r2, [r3, #2]
   48ee8:	f022 0201 	bic.w	r2, r2, #1
   48eec:	805a      	strh	r2, [r3, #2]
   48eee:	f7ff bfc1 	b.w	48e74 <free_chunk>
}
   48ef2:	4770      	bx	lr

00048ef4 <sys_heap_alloc>:

void *sys_heap_alloc(struct sys_heap *heap, size_t bytes)
{
   48ef4:	b570      	push	{r4, r5, r6, lr}
	struct z_heap *h = heap->heap;
   48ef6:	6805      	ldr	r5, [r0, #0]
	void *mem;

	if (bytes == 0U || size_too_big(h, bytes)) {
   48ef8:	b909      	cbnz	r1, 48efe <sys_heap_alloc+0xa>
		return NULL;
   48efa:	2000      	movs	r0, #0
				   chunksz_to_bytes(h, chunk_size(h, c)));
#endif

	IF_ENABLED(CONFIG_MSAN, (__msan_allocated_memory(mem, bytes)));
	return mem;
}
   48efc:	bd70      	pop	{r4, r5, r6, pc}
	if (bytes == 0U || size_too_big(h, bytes)) {
   48efe:	68ab      	ldr	r3, [r5, #8]
   48f00:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
   48f04:	d9f9      	bls.n	48efa <sys_heap_alloc+0x6>
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   48f06:	310b      	adds	r1, #11
   48f08:	08cc      	lsrs	r4, r1, #3
	chunkid_t c = alloc_chunk(h, chunk_sz);
   48f0a:	4621      	mov	r1, r4
   48f0c:	4628      	mov	r0, r5
   48f0e:	f7ff ff4a 	bl	48da6 <alloc_chunk>
	if (c == 0U) {
   48f12:	4606      	mov	r6, r0
   48f14:	2800      	cmp	r0, #0
   48f16:	d0f0      	beq.n	48efa <sys_heap_alloc+0x6>
	if (chunk_size(h, c) > chunk_sz) {
   48f18:	4601      	mov	r1, r0
   48f1a:	4628      	mov	r0, r5
   48f1c:	f7ff feed 	bl	48cfa <chunk_size>
   48f20:	42a0      	cmp	r0, r4
   48f22:	d907      	bls.n	48f34 <sys_heap_alloc+0x40>
		split_chunks(h, c, c + chunk_sz);
   48f24:	1932      	adds	r2, r6, r4
   48f26:	4628      	mov	r0, r5
   48f28:	f7ff ff8a 	bl	48e40 <split_chunks>
		free_list_add(h, c + chunk_sz);
   48f2c:	4611      	mov	r1, r2
   48f2e:	4628      	mov	r0, r5
   48f30:	f7ff fee8 	bl	48d04 <free_list_add>
	void *cmem = &buf[c];
   48f34:	eb05 02c6 	add.w	r2, r5, r6, lsl #3
	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
   48f38:	4610      	mov	r0, r2
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   48f3a:	8853      	ldrh	r3, [r2, #2]
   48f3c:	f043 0301 	orr.w	r3, r3, #1
   48f40:	8053      	strh	r3, [r2, #2]
   48f42:	3004      	adds	r0, #4
	return mem;
   48f44:	e7da      	b.n	48efc <sys_heap_alloc+0x8>

00048f46 <sys_heap_aligned_alloc>:

void *sys_heap_aligned_alloc(struct sys_heap *heap, size_t align, size_t bytes)
{
   48f46:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   48f4a:	f101 39ff 	add.w	r9, r1, #4294967295	; 0xffffffff
	 * value to efficiently accommodate z_heap_aligned_alloc().
	 * So if e.g. align = 0x28 (32 | 8) this means we align to a 32-byte
	 * boundary and then rewind 8 bytes.
	 */
	rew = align & -align;
	if (align != rew) {
   48f4e:	ea19 0901 	ands.w	r9, r9, r1
	struct z_heap *h = heap->heap;
   48f52:	6806      	ldr	r6, [r0, #0]
{
   48f54:	460f      	mov	r7, r1
   48f56:	4614      	mov	r4, r2
	if (align != rew) {
   48f58:	d00c      	beq.n	48f74 <sys_heap_aligned_alloc+0x2e>
	rew = align & -align;
   48f5a:	424b      	negs	r3, r1
   48f5c:	400b      	ands	r3, r1
		align -= rew;
		gap = MIN(rew, chunk_header_bytes(h));
   48f5e:	2b04      	cmp	r3, #4
   48f60:	461a      	mov	r2, r3
   48f62:	464f      	mov	r7, r9
   48f64:	bf28      	it	cs
   48f66:	2204      	movcs	r2, #4
	rew = align & -align;
   48f68:	4699      	mov	r9, r3
		rew = 0;
		gap = chunk_header_bytes(h);
	}
	__ASSERT((align & (align - 1)) == 0, "align must be a power of 2");

	if (bytes == 0 || size_too_big(h, bytes)) {
   48f6a:	b964      	cbnz	r4, 48f86 <sys_heap_aligned_alloc+0x40>
		return NULL;
   48f6c:	2500      	movs	r5, #0
				   chunksz_to_bytes(h, chunk_size(h, c)));
#endif

	IF_ENABLED(CONFIG_MSAN, (__msan_allocated_memory(mem, bytes)));
	return mem;
}
   48f6e:	4628      	mov	r0, r5
   48f70:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (align <= chunk_header_bytes(h)) {
   48f74:	2904      	cmp	r1, #4
   48f76:	d804      	bhi.n	48f82 <sys_heap_aligned_alloc+0x3c>
}
   48f78:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
			return sys_heap_alloc(heap, bytes);
   48f7c:	4611      	mov	r1, r2
   48f7e:	f7ff bfb9 	b.w	48ef4 <sys_heap_alloc>
		gap = chunk_header_bytes(h);
   48f82:	2204      	movs	r2, #4
   48f84:	e7f1      	b.n	48f6a <sys_heap_aligned_alloc+0x24>
	if (bytes == 0 || size_too_big(h, bytes)) {
   48f86:	68b3      	ldr	r3, [r6, #8]
   48f88:	ebb3 0fd4 	cmp.w	r3, r4, lsr #3
   48f8c:	d9ee      	bls.n	48f6c <sys_heap_aligned_alloc+0x26>
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   48f8e:	f104 010b 	add.w	r1, r4, #11
   48f92:	4439      	add	r1, r7
   48f94:	1a89      	subs	r1, r1, r2
	chunkid_t c0 = alloc_chunk(h, padded_sz);
   48f96:	08c9      	lsrs	r1, r1, #3
   48f98:	4630      	mov	r0, r6
   48f9a:	f7ff ff04 	bl	48da6 <alloc_chunk>
	if (c0 == 0) {
   48f9e:	4680      	mov	r8, r0
   48fa0:	2800      	cmp	r0, #0
   48fa2:	d0e3      	beq.n	48f6c <sys_heap_aligned_alloc+0x26>
	mem = (uint8_t *) ROUND_UP(mem + rew, align) - rew;
   48fa4:	f109 0504 	add.w	r5, r9, #4
   48fa8:	eb05 05c0 	add.w	r5, r5, r0, lsl #3
   48fac:	1e7b      	subs	r3, r7, #1
   48fae:	4435      	add	r5, r6
   48fb0:	441d      	add	r5, r3
   48fb2:	427f      	negs	r7, r7
   48fb4:	403d      	ands	r5, r7
   48fb6:	eba5 0509 	sub.w	r5, r5, r9
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
   48fba:	442c      	add	r4, r5
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   48fbc:	1f2b      	subs	r3, r5, #4
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
   48fbe:	3407      	adds	r4, #7
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   48fc0:	1b9b      	subs	r3, r3, r6
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
   48fc2:	f024 0407 	bic.w	r4, r4, #7
	chunkid_t c_end = end - chunk_buf(h);
   48fc6:	1ba4      	subs	r4, r4, r6
	if (c > c0) {
   48fc8:	ebb0 0fd3 	cmp.w	r0, r3, lsr #3
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   48fcc:	ea4f 07d3 	mov.w	r7, r3, lsr #3
	chunkid_t c_end = end - chunk_buf(h);
   48fd0:	ea4f 04e4 	mov.w	r4, r4, asr #3
	if (c > c0) {
   48fd4:	d208      	bcs.n	48fe8 <sys_heap_aligned_alloc+0xa2>
		split_chunks(h, c0, c);
   48fd6:	4601      	mov	r1, r0
   48fd8:	463a      	mov	r2, r7
   48fda:	4630      	mov	r0, r6
   48fdc:	f7ff ff30 	bl	48e40 <split_chunks>
		free_list_add(h, c0);
   48fe0:	4641      	mov	r1, r8
   48fe2:	4630      	mov	r0, r6
   48fe4:	f7ff fe8e 	bl	48d04 <free_list_add>
	return c + chunk_size(h, c);
   48fe8:	4639      	mov	r1, r7
   48fea:	4630      	mov	r0, r6
   48fec:	f7ff fe85 	bl	48cfa <chunk_size>
   48ff0:	4438      	add	r0, r7
	if (right_chunk(h, c) > c_end) {
   48ff2:	4284      	cmp	r4, r0
   48ff4:	d207      	bcs.n	49006 <sys_heap_aligned_alloc+0xc0>
		split_chunks(h, c, c_end);
   48ff6:	4630      	mov	r0, r6
   48ff8:	4622      	mov	r2, r4
   48ffa:	f7ff ff21 	bl	48e40 <split_chunks>
		free_list_add(h, c_end);
   48ffe:	4621      	mov	r1, r4
   49000:	4630      	mov	r0, r6
   49002:	f7ff fe7f 	bl	48d04 <free_list_add>
	void *cmem = &buf[c];
   49006:	eb06 06c7 	add.w	r6, r6, r7, lsl #3
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   4900a:	8873      	ldrh	r3, [r6, #2]
   4900c:	f043 0301 	orr.w	r3, r3, #1
   49010:	8073      	strh	r3, [r6, #2]
   49012:	e7ac      	b.n	48f6e <sys_heap_aligned_alloc+0x28>

00049014 <sys_heap_init>:
		__ASSERT(bytes / CHUNK_UNIT <= 0x7fffffffU, "heap size is too big");
	}

	/* Reserve the end marker chunk's header */
	__ASSERT(bytes > heap_footer_bytes(bytes), "heap size is too small");
	bytes -= heap_footer_bytes(bytes);
   49014:	3a04      	subs	r2, #4
{
   49016:	b4f0      	push	{r4, r5, r6, r7}
   49018:	4604      	mov	r4, r0

	/* Round the start up, the end down */
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
   4901a:	1dc8      	adds	r0, r1, #7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
   4901c:	4411      	add	r1, r2
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
   4901e:	f020 0007 	bic.w	r0, r0, #7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
   49022:	f021 0107 	bic.w	r1, r1, #7
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
   49026:	1a0e      	subs	r6, r1, r0
   49028:	08f3      	lsrs	r3, r6, #3

	CHECK(end > addr);
	__ASSERT(heap_sz > chunksz(sizeof(struct z_heap)), "heap size is too small");

	struct z_heap *h = (struct z_heap *)addr;
	heap->heap = h;
   4902a:	6020      	str	r0, [r4, #0]
	return 31 - __builtin_clz(usable_sz);
   4902c:	fab3 f283 	clz	r2, r3
	h->end_chunk = heap_sz;
	h->avail_buckets = 0;
   49030:	4604      	mov	r4, r0
	h->allocated_bytes = 0;
	h->max_allocated_bytes = 0;
#endif

	int nb_buckets = bucket_idx(h, heap_sz) + 1;
	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
   49032:	f1c2 0524 	rsb	r5, r2, #36	; 0x24
	h->avail_buckets = 0;
   49036:	2700      	movs	r7, #0
	h->end_chunk = heap_sz;
   49038:	6083      	str	r3, [r0, #8]
	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
   4903a:	00ad      	lsls	r5, r5, #2
	h->avail_buckets = 0;
   4903c:	f844 7f0c 	str.w	r7, [r4, #12]!
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   49040:	3507      	adds	r5, #7
	int nb_buckets = bucket_idx(h, heap_sz) + 1;
   49042:	f1c2 0220 	rsb	r2, r2, #32
   49046:	08e9      	lsrs	r1, r5, #3
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) <= heap_sz, "heap size is too small");

	for (int i = 0; i < nb_buckets; i++) {
   49048:	eb04 0282 	add.w	r2, r4, r2, lsl #2
		h->buckets[i].next = 0;
   4904c:	f844 7f04 	str.w	r7, [r4, #4]!
	for (int i = 0; i < nb_buckets; i++) {
   49050:	4294      	cmp	r4, r2
   49052:	d1fb      	bne.n	4904c <sys_heap_init+0x38>
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   49054:	004a      	lsls	r2, r1, #1
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   49056:	f042 0201 	orr.w	r2, r2, #1
   4905a:	8042      	strh	r2, [r0, #2]
		((uint16_t *)cmem)[f] = val;
   4905c:	eb00 04c1 	add.w	r4, r0, r1, lsl #3
	set_chunk_size(h, 0, chunk0_size);
	set_left_chunk_size(h, 0, 0);
	set_chunk_used(h, 0, true);

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
   49060:	1a5a      	subs	r2, r3, r1
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   49062:	0055      	lsls	r5, r2, #1
		((uint16_t *)cmem)[f] = val;
   49064:	8007      	strh	r7, [r0, #0]
   49066:	8065      	strh	r5, [r4, #2]
   49068:	1984      	adds	r4, r0, r6
   4906a:	f820 1031 	strh.w	r1, [r0, r1, lsl #3]
	void *cmem = &buf[c];
   4906e:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
		((uint16_t *)cmem)[f] = val;
   49072:	8067      	strh	r7, [r4, #2]
   49074:	5382      	strh	r2, [r0, r6]
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   49076:	885a      	ldrh	r2, [r3, #2]
   49078:	f042 0201 	orr.w	r2, r2, #1
   4907c:	805a      	strh	r2, [r3, #2]
	set_chunk_size(h, heap_sz, 0);
	set_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);
	set_chunk_used(h, heap_sz, true);

	free_list_add(h, chunk0_size);
}
   4907e:	bcf0      	pop	{r4, r5, r6, r7}
	free_list_add(h, chunk0_size);
   49080:	f7ff be40 	b.w	48d04 <free_list_add>

00049084 <assert_print>:

	k_panic();
}

void assert_print(const char *fmt, ...)
{
   49084:	b40f      	push	{r0, r1, r2, r3}
   49086:	b507      	push	{r0, r1, r2, lr}
   49088:	a904      	add	r1, sp, #16
   4908a:	f851 0b04 	ldr.w	r0, [r1], #4
	va_list ap;

	va_start(ap, fmt);
   4908e:	9101      	str	r1, [sp, #4]

	vprintk(fmt, ap);
   49090:	f7e1 fd76 	bl	2ab80 <vprintk>

	va_end(ap);
}
   49094:	b003      	add	sp, #12
   49096:	f85d eb04 	ldr.w	lr, [sp], #4
   4909a:	b004      	add	sp, #16
   4909c:	4770      	bx	lr

0004909e <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_DEPRECATED, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_WARN_DEPRECATED, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_ENFORCE_ZEPHYR_STDINT, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
   4909e:	4770      	bx	lr

000490a0 <read_str>:
{
   490a0:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	return bt_gatt_attr_read(conn, attr, buf, len, offset, attr->user_data,
   490a4:	f8d1 800c 	ldr.w	r8, [r1, #12]
{
   490a8:	4605      	mov	r5, r0
				 strlen(attr->user_data));
   490aa:	4640      	mov	r0, r8
{
   490ac:	461f      	mov	r7, r3
   490ae:	460c      	mov	r4, r1
   490b0:	4616      	mov	r6, r2
				 strlen(attr->user_data));
   490b2:	f001 feab 	bl	4ae0c <strlen>
	return bt_gatt_attr_read(conn, attr, buf, len, offset, attr->user_data,
   490b6:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
   490ba:	9300      	str	r3, [sp, #0]
   490bc:	b280      	uxth	r0, r0
   490be:	e9cd 8001 	strd	r8, r0, [sp, #4]
   490c2:	463b      	mov	r3, r7
   490c4:	4632      	mov	r2, r6
   490c6:	4621      	mov	r1, r4
   490c8:	4628      	mov	r0, r5
   490ca:	f004 fa27 	bl	4d51c <bt_gatt_attr_read>
}
   490ce:	b004      	add	sp, #16
   490d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000490d4 <blvl_ccc_cfg_changed>:
}
   490d4:	4770      	bx	lr

000490d6 <bas_init>:
}
   490d6:	2000      	movs	r0, #0
   490d8:	4770      	bx	lr

000490da <nvs_flash_rd>:
{
   490da:	b470      	push	{r4, r5, r6}
	offset += addr & ADDR_OFFS_MASK;
   490dc:	6806      	ldr	r6, [r0, #0]
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
   490de:	8984      	ldrh	r4, [r0, #12]
	rc = flash_read(fs->flash_device, offset, data, len);
   490e0:	6a80      	ldr	r0, [r0, #40]	; 0x28
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
   490e2:	0c0d      	lsrs	r5, r1, #16
	offset += addr & ADDR_OFFS_MASK;
   490e4:	fa16 f181 	uxtah	r1, r6, r1
   490e8:	fb05 1104 	mla	r1, r5, r4, r1
	return api->read(dev, offset, data, len);
   490ec:	6884      	ldr	r4, [r0, #8]
   490ee:	6824      	ldr	r4, [r4, #0]
   490f0:	46a4      	mov	ip, r4
}
   490f2:	bc70      	pop	{r4, r5, r6}
   490f4:	4760      	bx	ip

000490f6 <nvs_sector_advance>:
	*addr += (1 << ADDR_SECT_SHIFT);
   490f6:	680b      	ldr	r3, [r1, #0]
   490f8:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
   490fc:	600b      	str	r3, [r1, #0]
	if ((*addr >> ADDR_SECT_SHIFT) == fs->sector_count) {
   490fe:	89c0      	ldrh	r0, [r0, #14]
   49100:	0c1a      	lsrs	r2, r3, #16
   49102:	ebb0 4f13 	cmp.w	r0, r3, lsr #16
		*addr -= (fs->sector_count << ADDR_SECT_SHIFT);
   49106:	bf04      	itt	eq
   49108:	eba3 4302 	subeq.w	r3, r3, r2, lsl #16
   4910c:	600b      	streq	r3, [r1, #0]
}
   4910e:	4770      	bx	lr

00049110 <nvs_flash_block_cmp>:
{
   49110:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   49114:	461c      	mov	r4, r3
		NVS_BLOCK_SIZE & ~(fs->flash_parameters->write_block_size - 1U);
   49116:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
   49118:	681d      	ldr	r5, [r3, #0]
   4911a:	426d      	negs	r5, r5
{
   4911c:	b089      	sub	sp, #36	; 0x24
   4911e:	4681      	mov	r9, r0
   49120:	460e      	mov	r6, r1
   49122:	4617      	mov	r7, r2
	block_size =
   49124:	f005 0520 	and.w	r5, r5, #32
	while (len) {
   49128:	b91c      	cbnz	r4, 49132 <nvs_flash_block_cmp+0x22>
	return 0;
   4912a:	4620      	mov	r0, r4
}
   4912c:	b009      	add	sp, #36	; 0x24
   4912e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		bytes_to_cmp = MIN(block_size, len);
   49132:	42ac      	cmp	r4, r5
   49134:	46a0      	mov	r8, r4
   49136:	bf28      	it	cs
   49138:	46a8      	movcs	r8, r5
		rc = nvs_flash_rd(fs, addr, buf, bytes_to_cmp);
   4913a:	4643      	mov	r3, r8
   4913c:	466a      	mov	r2, sp
   4913e:	4631      	mov	r1, r6
   49140:	4648      	mov	r0, r9
   49142:	f7ff ffca 	bl	490da <nvs_flash_rd>
		if (rc) {
   49146:	2800      	cmp	r0, #0
   49148:	d1f0      	bne.n	4912c <nvs_flash_block_cmp+0x1c>
		rc = memcmp(data8, buf, bytes_to_cmp);
   4914a:	4642      	mov	r2, r8
   4914c:	4669      	mov	r1, sp
   4914e:	4638      	mov	r0, r7
   49150:	f001 fe83 	bl	4ae5a <memcmp>
		if (rc) {
   49154:	b920      	cbnz	r0, 49160 <nvs_flash_block_cmp+0x50>
		len -= bytes_to_cmp;
   49156:	eba4 0408 	sub.w	r4, r4, r8
		addr += bytes_to_cmp;
   4915a:	4446      	add	r6, r8
		data8 += bytes_to_cmp;
   4915c:	4447      	add	r7, r8
   4915e:	e7e3      	b.n	49128 <nvs_flash_block_cmp+0x18>
			return 1;
   49160:	2001      	movs	r0, #1
   49162:	e7e3      	b.n	4912c <nvs_flash_block_cmp+0x1c>

00049164 <nvs_flash_cmp_const>:
{
   49164:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   49168:	461c      	mov	r4, r3
		NVS_BLOCK_SIZE & ~(fs->flash_parameters->write_block_size - 1U);
   4916a:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
   4916c:	681d      	ldr	r5, [r3, #0]
   4916e:	426d      	negs	r5, r5
{
   49170:	b088      	sub	sp, #32
	block_size =
   49172:	f005 0520 	and.w	r5, r5, #32
{
   49176:	4607      	mov	r7, r0
   49178:	460e      	mov	r6, r1
	(void)memset(cmp, value, block_size);
   4917a:	4668      	mov	r0, sp
{
   4917c:	4611      	mov	r1, r2
	(void)memset(cmp, value, block_size);
   4917e:	462a      	mov	r2, r5
   49180:	f001 fe86 	bl	4ae90 <memset>
	while (len) {
   49184:	b91c      	cbnz	r4, 4918e <nvs_flash_cmp_const+0x2a>
	return 0;
   49186:	4620      	mov	r0, r4
}
   49188:	b008      	add	sp, #32
   4918a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		bytes_to_cmp = MIN(block_size, len);
   4918e:	42ac      	cmp	r4, r5
   49190:	46a0      	mov	r8, r4
   49192:	bf28      	it	cs
   49194:	46a8      	movcs	r8, r5
		rc = nvs_flash_block_cmp(fs, addr, cmp, bytes_to_cmp);
   49196:	4643      	mov	r3, r8
   49198:	466a      	mov	r2, sp
   4919a:	4631      	mov	r1, r6
   4919c:	4638      	mov	r0, r7
   4919e:	f7ff ffb7 	bl	49110 <nvs_flash_block_cmp>
		if (rc) {
   491a2:	2800      	cmp	r0, #0
   491a4:	d1f0      	bne.n	49188 <nvs_flash_cmp_const+0x24>
		len -= bytes_to_cmp;
   491a6:	eba4 0408 	sub.w	r4, r4, r8
		addr += bytes_to_cmp;
   491aa:	4446      	add	r6, r8
   491ac:	e7ea      	b.n	49184 <nvs_flash_cmp_const+0x20>

000491ae <nvs_flash_erase_sector>:
{
   491ae:	b538      	push	{r3, r4, r5, lr}
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
   491b0:	8982      	ldrh	r2, [r0, #12]
   491b2:	6803      	ldr	r3, [r0, #0]
	addr &= ADDR_SECT_MASK;
   491b4:	0c0d      	lsrs	r5, r1, #16
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
   491b6:	0c09      	lsrs	r1, r1, #16
{
   491b8:	4604      	mov	r4, r0
	addr &= ADDR_SECT_MASK;
   491ba:	042d      	lsls	r5, r5, #16
	rc = flash_erase(fs->flash_device, offset, fs->sector_size);
   491bc:	6a80      	ldr	r0, [r0, #40]	; 0x28
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
   491be:	fb02 3101 	mla	r1, r2, r1, r3
	rc = api->erase(dev, offset, size);
   491c2:	6883      	ldr	r3, [r0, #8]
   491c4:	689b      	ldr	r3, [r3, #8]
   491c6:	4798      	blx	r3
	if (rc) {
   491c8:	b950      	cbnz	r0, 491e0 <nvs_flash_erase_sector+0x32>
	if (nvs_flash_cmp_const(fs, addr, fs->flash_parameters->erase_value,
   491ca:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   491cc:	89a3      	ldrh	r3, [r4, #12]
   491ce:	7912      	ldrb	r2, [r2, #4]
   491d0:	4629      	mov	r1, r5
   491d2:	4620      	mov	r0, r4
   491d4:	f7ff ffc6 	bl	49164 <nvs_flash_cmp_const>
		rc = -ENXIO;
   491d8:	2800      	cmp	r0, #0
   491da:	bf18      	it	ne
   491dc:	f06f 0005 	mvnne.w	r0, #5
}
   491e0:	bd38      	pop	{r3, r4, r5, pc}

000491e2 <nvs_ate_crc8_update>:
{
   491e2:	b510      	push	{r4, lr}
	crc8 = crc8_ccitt(0xff, entry, offsetof(struct nvs_ate, crc8));
   491e4:	4601      	mov	r1, r0
{
   491e6:	4604      	mov	r4, r0
	crc8 = crc8_ccitt(0xff, entry, offsetof(struct nvs_ate, crc8));
   491e8:	2207      	movs	r2, #7
   491ea:	20ff      	movs	r0, #255	; 0xff
   491ec:	f7e1 fcac 	bl	2ab48 <crc8_ccitt>
	entry->crc8 = crc8;
   491f0:	71e0      	strb	r0, [r4, #7]
}
   491f2:	bd10      	pop	{r4, pc}

000491f4 <nvs_al_size.isra.0>:
	if (write_block_size <= 1U) {
   491f4:	7803      	ldrb	r3, [r0, #0]
   491f6:	2b01      	cmp	r3, #1
	return (len + (write_block_size - 1U)) & ~(write_block_size - 1U);
   491f8:	bf81      	itttt	hi
   491fa:	f101 31ff 	addhi.w	r1, r1, #4294967295	; 0xffffffff
   491fe:	18c9      	addhi	r1, r1, r3
   49200:	425b      	neghi	r3, r3
   49202:	4019      	andhi	r1, r3
}
   49204:	4608      	mov	r0, r1
   49206:	4770      	bx	lr

00049208 <nvs_ate_valid>:
{
   49208:	b570      	push	{r4, r5, r6, lr}
   4920a:	460c      	mov	r4, r1
   4920c:	4605      	mov	r5, r0
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   4920e:	2108      	movs	r1, #8
   49210:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
   49212:	f7ff ffef 	bl	491f4 <nvs_al_size.isra.0>
	crc8 = crc8_ccitt(0xff, entry, offsetof(struct nvs_ate, crc8));
   49216:	2207      	movs	r2, #7
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   49218:	4606      	mov	r6, r0
	crc8 = crc8_ccitt(0xff, entry, offsetof(struct nvs_ate, crc8));
   4921a:	4621      	mov	r1, r4
   4921c:	20ff      	movs	r0, #255	; 0xff
   4921e:	f7e1 fc93 	bl	2ab48 <crc8_ccitt>
	if (crc8 == entry->crc8) {
   49222:	79e3      	ldrb	r3, [r4, #7]
   49224:	4283      	cmp	r3, r0
   49226:	d107      	bne.n	49238 <nvs_ate_valid+0x30>
	    (entry->offset >= (fs->sector_size - ate_size))) {
   49228:	89aa      	ldrh	r2, [r5, #12]
   4922a:	8863      	ldrh	r3, [r4, #2]
   4922c:	1b90      	subs	r0, r2, r6
	if ((nvs_ate_crc8_check(entry)) ||
   4922e:	4283      	cmp	r3, r0
   49230:	bf2c      	ite	cs
   49232:	2000      	movcs	r0, #0
   49234:	2001      	movcc	r0, #1
}
   49236:	bd70      	pop	{r4, r5, r6, pc}
		return 0;
   49238:	2000      	movs	r0, #0
   4923a:	e7fc      	b.n	49236 <nvs_ate_valid+0x2e>

0004923c <nvs_close_ate_valid>:
{
   4923c:	b538      	push	{r3, r4, r5, lr}
   4923e:	4605      	mov	r5, r0
   49240:	460c      	mov	r4, r1
	if ((!nvs_ate_valid(fs, entry)) || (entry->len != 0U) ||
   49242:	f7ff ffe1 	bl	49208 <nvs_ate_valid>
   49246:	b1a0      	cbz	r0, 49272 <nvs_close_ate_valid+0x36>
   49248:	88a0      	ldrh	r0, [r4, #4]
   4924a:	b998      	cbnz	r0, 49274 <nvs_close_ate_valid+0x38>
   4924c:	8822      	ldrh	r2, [r4, #0]
   4924e:	f64f 73ff 	movw	r3, #65535	; 0xffff
   49252:	429a      	cmp	r2, r3
   49254:	d10d      	bne.n	49272 <nvs_close_ate_valid+0x36>
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   49256:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
   49258:	2108      	movs	r1, #8
   4925a:	f7ff ffcb 	bl	491f4 <nvs_al_size.isra.0>
	if ((fs->sector_size - entry->offset) % ate_size) {
   4925e:	8862      	ldrh	r2, [r4, #2]
   49260:	89ab      	ldrh	r3, [r5, #12]
   49262:	1a9b      	subs	r3, r3, r2
   49264:	fbb3 f2f0 	udiv	r2, r3, r0
   49268:	fb02 3010 	mls	r0, r2, r0, r3
   4926c:	fab0 f080 	clz	r0, r0
   49270:	0940      	lsrs	r0, r0, #5
}
   49272:	bd38      	pop	{r3, r4, r5, pc}
		return 0;
   49274:	2000      	movs	r0, #0
   49276:	e7fc      	b.n	49272 <nvs_close_ate_valid+0x36>

00049278 <nvs_prev_ate>:
{
   49278:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   4927a:	4604      	mov	r4, r0
   4927c:	460d      	mov	r5, r1
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   4927e:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
   49280:	2108      	movs	r1, #8
   49282:	f7ff ffb7 	bl	491f4 <nvs_al_size.isra.0>
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
   49286:	6829      	ldr	r1, [r5, #0]
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   49288:	4607      	mov	r7, r0
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
   4928a:	2308      	movs	r3, #8
   4928c:	4620      	mov	r0, r4
   4928e:	f7ff ff24 	bl	490da <nvs_flash_rd>
	if (rc) {
   49292:	4606      	mov	r6, r0
   49294:	2800      	cmp	r0, #0
   49296:	d136      	bne.n	49306 <nvs_prev_ate+0x8e>
	*addr += ate_size;
   49298:	682b      	ldr	r3, [r5, #0]
   4929a:	443b      	add	r3, r7
   4929c:	602b      	str	r3, [r5, #0]
	if (((*addr) & ADDR_OFFS_MASK) != (fs->sector_size - ate_size)) {
   4929e:	89a2      	ldrh	r2, [r4, #12]
   492a0:	b299      	uxth	r1, r3
   492a2:	1bd2      	subs	r2, r2, r7
   492a4:	4291      	cmp	r1, r2
   492a6:	d12e      	bne.n	49306 <nvs_prev_ate+0x8e>
	if (((*addr) >> ADDR_SECT_SHIFT) == 0U) {
   492a8:	0c1a      	lsrs	r2, r3, #16
		*addr += ((fs->sector_count - 1) << ADDR_SECT_SHIFT);
   492aa:	bf03      	ittte	eq
   492ac:	89e2      	ldrheq	r2, [r4, #14]
   492ae:	f102 32ff 	addeq.w	r2, r2, #4294967295	; 0xffffffff
   492b2:	eb03 4102 	addeq.w	r1, r3, r2, lsl #16
		*addr -= (1 << ADDR_SECT_SHIFT);
   492b6:	f5a3 3180 	subne.w	r1, r3, #65536	; 0x10000
   492ba:	6029      	str	r1, [r5, #0]
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
   492bc:	2308      	movs	r3, #8
   492be:	466a      	mov	r2, sp
   492c0:	4620      	mov	r0, r4
   492c2:	f7ff ff0a 	bl	490da <nvs_flash_rd>
	if (rc) {
   492c6:	b9e8      	cbnz	r0, 49304 <nvs_prev_ate+0x8c>
	rc = nvs_ate_cmp_const(&close_ate, fs->flash_parameters->erase_value);
   492c8:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   492ca:	791a      	ldrb	r2, [r3, #4]
	for (i = 0; i < sizeof(struct nvs_ate); i++) {
   492cc:	466b      	mov	r3, sp
		if (data8[i] != value) {
   492ce:	f813 1b01 	ldrb.w	r1, [r3], #1
   492d2:	428a      	cmp	r2, r1
   492d4:	d10c      	bne.n	492f0 <nvs_prev_ate+0x78>
	for (i = 0; i < sizeof(struct nvs_ate); i++) {
   492d6:	3001      	adds	r0, #1
   492d8:	2808      	cmp	r0, #8
   492da:	d1f8      	bne.n	492ce <nvs_prev_ate+0x56>
		*addr = fs->ate_wra;
   492dc:	6863      	ldr	r3, [r4, #4]
   492de:	e005      	b.n	492ec <nvs_prev_ate+0x74>
		(*addr) &= ADDR_SECT_MASK;
   492e0:	682b      	ldr	r3, [r5, #0]
		(*addr) += close_ate.offset;
   492e2:	f8bd 2002 	ldrh.w	r2, [sp, #2]
		(*addr) &= ADDR_SECT_MASK;
   492e6:	0c1b      	lsrs	r3, r3, #16
   492e8:	041b      	lsls	r3, r3, #16
		(*addr) += close_ate.offset;
   492ea:	4413      	add	r3, r2
		*addr = fs->ate_wra;
   492ec:	602b      	str	r3, [r5, #0]
		return 0;
   492ee:	e00a      	b.n	49306 <nvs_prev_ate+0x8e>
	if (nvs_close_ate_valid(fs, &close_ate)) {
   492f0:	4669      	mov	r1, sp
   492f2:	4620      	mov	r0, r4
   492f4:	f7ff ffa2 	bl	4923c <nvs_close_ate_valid>
   492f8:	2800      	cmp	r0, #0
   492fa:	d1f1      	bne.n	492e0 <nvs_prev_ate+0x68>
	return nvs_recover_last_ate(fs, addr);
   492fc:	4629      	mov	r1, r5
   492fe:	4620      	mov	r0, r4
   49300:	f7e1 fff4 	bl	2b2ec <nvs_recover_last_ate>
   49304:	4606      	mov	r6, r0
}
   49306:	4630      	mov	r0, r6
   49308:	b003      	add	sp, #12
   4930a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0004930c <nvs_flash_al_wrt>:
{
   4930c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   49310:	4607      	mov	r7, r0
   49312:	b089      	sub	sp, #36	; 0x24
   49314:	4690      	mov	r8, r2
	if (!len) {
   49316:	461e      	mov	r6, r3
   49318:	b91b      	cbnz	r3, 49322 <nvs_flash_al_wrt+0x16>
		return 0;
   4931a:	2000      	movs	r0, #0
}
   4931c:	b009      	add	sp, #36	; 0x24
   4931e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	offset += addr & ADDR_OFFS_MASK;
   49322:	683c      	ldr	r4, [r7, #0]
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
   49324:	8983      	ldrh	r3, [r0, #12]
   49326:	0c08      	lsrs	r0, r1, #16
	offset += addr & ADDR_OFFS_MASK;
   49328:	fa14 f181 	uxtah	r1, r4, r1
   4932c:	fb00 1403 	mla	r4, r0, r3, r1
	blen = len & ~(fs->flash_parameters->write_block_size - 1U);
   49330:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   49332:	681d      	ldr	r5, [r3, #0]
   49334:	426d      	negs	r5, r5
	if (blen > 0) {
   49336:	4035      	ands	r5, r6
   49338:	d00c      	beq.n	49354 <nvs_flash_al_wrt+0x48>
		rc = flash_write(fs->flash_device, offset, data8, blen);
   4933a:	6ab8      	ldr	r0, [r7, #40]	; 0x28
	rc = api->write(dev, offset, data, len);
   4933c:	6883      	ldr	r3, [r0, #8]
   4933e:	4621      	mov	r1, r4
   49340:	f8d3 9004 	ldr.w	r9, [r3, #4]
   49344:	462b      	mov	r3, r5
   49346:	47c8      	blx	r9
		if (rc) {
   49348:	2800      	cmp	r0, #0
   4934a:	d1e7      	bne.n	4931c <nvs_flash_al_wrt+0x10>
	if (len) {
   4934c:	1b76      	subs	r6, r6, r5
   4934e:	d0e4      	beq.n	4931a <nvs_flash_al_wrt+0xe>
		offset += blen;
   49350:	442c      	add	r4, r5
		data8 += blen;
   49352:	44a8      	add	r8, r5
		memcpy(buf, data8, len);
   49354:	4632      	mov	r2, r6
   49356:	4641      	mov	r1, r8
   49358:	4668      	mov	r0, sp
   4935a:	f001 fd8e 	bl	4ae7a <memcpy>
		(void)memset(buf + len, fs->flash_parameters->erase_value,
   4935e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   49360:	681a      	ldr	r2, [r3, #0]
   49362:	7919      	ldrb	r1, [r3, #4]
   49364:	1b92      	subs	r2, r2, r6
   49366:	eb0d 0006 	add.w	r0, sp, r6
   4936a:	f001 fd91 	bl	4ae90 <memset>
				 fs->flash_parameters->write_block_size);
   4936e:	e9d7 030a 	ldrd	r0, r3, [r7, #40]	; 0x28
   49372:	681b      	ldr	r3, [r3, #0]
   49374:	6882      	ldr	r2, [r0, #8]
   49376:	4621      	mov	r1, r4
   49378:	6855      	ldr	r5, [r2, #4]
   4937a:	466a      	mov	r2, sp
   4937c:	47a8      	blx	r5
	return rc;
   4937e:	e7cd      	b.n	4931c <nvs_flash_al_wrt+0x10>

00049380 <nvs_flash_ate_wrt>:
{
   49380:	b510      	push	{r4, lr}
   49382:	460a      	mov	r2, r1
	rc = nvs_flash_al_wrt(fs, fs->ate_wra, entry,
   49384:	2308      	movs	r3, #8
   49386:	6841      	ldr	r1, [r0, #4]
{
   49388:	4604      	mov	r4, r0
	rc = nvs_flash_al_wrt(fs, fs->ate_wra, entry,
   4938a:	f7ff ffbf 	bl	4930c <nvs_flash_al_wrt>
	fs->ate_wra -= nvs_al_size(fs, sizeof(struct nvs_ate));
   4938e:	2108      	movs	r1, #8
	rc = nvs_flash_al_wrt(fs, fs->ate_wra, entry,
   49390:	4602      	mov	r2, r0
	fs->ate_wra -= nvs_al_size(fs, sizeof(struct nvs_ate));
   49392:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   49394:	f7ff ff2e 	bl	491f4 <nvs_al_size.isra.0>
   49398:	6863      	ldr	r3, [r4, #4]
   4939a:	1a1b      	subs	r3, r3, r0
   4939c:	6063      	str	r3, [r4, #4]
}
   4939e:	4610      	mov	r0, r2
   493a0:	bd10      	pop	{r4, pc}

000493a2 <nvs_add_gc_done_ate>:
{
   493a2:	b513      	push	{r0, r1, r4, lr}
	gc_done_ate.id = 0xffff;
   493a4:	f64f 73ff 	movw	r3, #65535	; 0xffff
   493a8:	f8ad 3000 	strh.w	r3, [sp]
	gc_done_ate.len = 0U;
   493ac:	2300      	movs	r3, #0
{
   493ae:	4604      	mov	r4, r0
	gc_done_ate.len = 0U;
   493b0:	f8ad 3004 	strh.w	r3, [sp, #4]
	gc_done_ate.offset = (uint16_t)(fs->data_wra & ADDR_OFFS_MASK);
   493b4:	6883      	ldr	r3, [r0, #8]
   493b6:	f8ad 3002 	strh.w	r3, [sp, #2]
	nvs_ate_crc8_update(&gc_done_ate);
   493ba:	4668      	mov	r0, sp
   493bc:	f7ff ff11 	bl	491e2 <nvs_ate_crc8_update>
	return nvs_flash_ate_wrt(fs, &gc_done_ate);
   493c0:	4669      	mov	r1, sp
   493c2:	4620      	mov	r0, r4
   493c4:	f7ff ffdc 	bl	49380 <nvs_flash_ate_wrt>
}
   493c8:	b002      	add	sp, #8
   493ca:	bd10      	pop	{r4, pc}

000493cc <nvs_gc>:
{
   493cc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   493d0:	4604      	mov	r4, r0
   493d2:	b095      	sub	sp, #84	; 0x54
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   493d4:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
   493d6:	2108      	movs	r1, #8
   493d8:	f7ff ff0c 	bl	491f4 <nvs_al_size.isra.0>
	sec_addr = (fs->ate_wra & ADDR_SECT_MASK);
   493dc:	6863      	ldr	r3, [r4, #4]
   493de:	0c1b      	lsrs	r3, r3, #16
   493e0:	041b      	lsls	r3, r3, #16
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   493e2:	4605      	mov	r5, r0
	nvs_sector_advance(fs, &sec_addr);
   493e4:	a903      	add	r1, sp, #12
   493e6:	4620      	mov	r0, r4
	sec_addr = (fs->ate_wra & ADDR_SECT_MASK);
   493e8:	9303      	str	r3, [sp, #12]
	nvs_sector_advance(fs, &sec_addr);
   493ea:	f7ff fe84 	bl	490f6 <nvs_sector_advance>
	gc_addr = sec_addr + fs->sector_size - ate_size;
   493ee:	f8dd b00c 	ldr.w	fp, [sp, #12]
   493f2:	89a6      	ldrh	r6, [r4, #12]
   493f4:	445e      	add	r6, fp
   493f6:	1b76      	subs	r6, r6, r5
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
   493f8:	aa06      	add	r2, sp, #24
   493fa:	2308      	movs	r3, #8
   493fc:	4631      	mov	r1, r6
   493fe:	4620      	mov	r0, r4
	gc_addr = sec_addr + fs->sector_size - ate_size;
   49400:	9604      	str	r6, [sp, #16]
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
   49402:	f7ff fe6a 	bl	490da <nvs_flash_rd>
	if (rc < 0) {
   49406:	1e02      	subs	r2, r0, #0
   49408:	f2c0 80a9 	blt.w	4955e <nvs_gc+0x192>
	rc = nvs_ate_cmp_const(&close_ate, fs->flash_parameters->erase_value);
   4940c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   4940e:	aa06      	add	r2, sp, #24
   49410:	7919      	ldrb	r1, [r3, #4]
	for (i = 0; i < sizeof(struct nvs_ate); i++) {
   49412:	2300      	movs	r3, #0
		if (data8[i] != value) {
   49414:	f812 0b01 	ldrb.w	r0, [r2], #1
   49418:	4281      	cmp	r1, r0
   4941a:	f040 808f 	bne.w	4953c <nvs_gc+0x170>
	for (i = 0; i < sizeof(struct nvs_ate); i++) {
   4941e:	3301      	adds	r3, #1
   49420:	2b08      	cmp	r3, #8
   49422:	d1f7      	bne.n	49414 <nvs_gc+0x48>
	if (fs->ate_wra >= (fs->data_wra + ate_size)) {
   49424:	68a3      	ldr	r3, [r4, #8]
   49426:	6862      	ldr	r2, [r4, #4]
   49428:	442b      	add	r3, r5
   4942a:	429a      	cmp	r2, r3
   4942c:	d27e      	bcs.n	4952c <nvs_gc+0x160>
	rc = nvs_flash_erase_sector(fs, sec_addr);
   4942e:	4659      	mov	r1, fp
   49430:	4620      	mov	r0, r4
   49432:	f7ff febc 	bl	491ae <nvs_flash_erase_sector>
   49436:	4602      	mov	r2, r0
	if (rc) {
   49438:	e091      	b.n	4955e <nvs_gc+0x192>
		gc_addr += close_ate.offset;
   4943a:	f8bd 301a 	ldrh.w	r3, [sp, #26]
		gc_addr &= ADDR_SECT_MASK;
   4943e:	0c36      	lsrs	r6, r6, #16
   49440:	0436      	lsls	r6, r6, #16
		gc_addr += close_ate.offset;
   49442:	441e      	add	r6, r3
   49444:	9604      	str	r6, [sp, #16]
		rc = nvs_prev_ate(fs, &gc_addr, &gc_ate);
   49446:	aa08      	add	r2, sp, #32
   49448:	a904      	add	r1, sp, #16
   4944a:	4620      	mov	r0, r4
		gc_prev_addr = gc_addr;
   4944c:	f8dd a010 	ldr.w	sl, [sp, #16]
		rc = nvs_prev_ate(fs, &gc_addr, &gc_ate);
   49450:	f7ff ff12 	bl	49278 <nvs_prev_ate>
		if (rc) {
   49454:	4602      	mov	r2, r0
   49456:	2800      	cmp	r0, #0
   49458:	f040 8081 	bne.w	4955e <nvs_gc+0x192>
		if (!nvs_ate_valid(fs, &gc_ate)) {
   4945c:	a908      	add	r1, sp, #32
   4945e:	4620      	mov	r0, r4
   49460:	f7ff fed2 	bl	49208 <nvs_ate_valid>
   49464:	b918      	cbnz	r0, 4946e <nvs_gc+0xa2>
	} while (gc_prev_addr != stop_addr);
   49466:	9b01      	ldr	r3, [sp, #4]
   49468:	459a      	cmp	sl, r3
   4946a:	d1ec      	bne.n	49446 <nvs_gc+0x7a>
   4946c:	e7da      	b.n	49424 <nvs_gc+0x58>
		wlk_addr = fs->ate_wra;
   4946e:	6863      	ldr	r3, [r4, #4]
   49470:	9305      	str	r3, [sp, #20]
			rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
   49472:	aa0a      	add	r2, sp, #40	; 0x28
   49474:	a905      	add	r1, sp, #20
   49476:	4620      	mov	r0, r4
			wlk_prev_addr = wlk_addr;
   49478:	9e05      	ldr	r6, [sp, #20]
			rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
   4947a:	f7ff fefd 	bl	49278 <nvs_prev_ate>
			if (rc) {
   4947e:	4602      	mov	r2, r0
   49480:	2800      	cmp	r0, #0
   49482:	d16c      	bne.n	4955e <nvs_gc+0x192>
			if ((wlk_ate.id == gc_ate.id) &&
   49484:	f8bd 2028 	ldrh.w	r2, [sp, #40]	; 0x28
   49488:	f8bd 3020 	ldrh.w	r3, [sp, #32]
   4948c:	429a      	cmp	r2, r3
   4948e:	d027      	beq.n	494e0 <nvs_gc+0x114>
		} while (wlk_addr != fs->ate_wra);
   49490:	6862      	ldr	r2, [r4, #4]
   49492:	9b05      	ldr	r3, [sp, #20]
   49494:	429a      	cmp	r2, r3
   49496:	d1ec      	bne.n	49472 <nvs_gc+0xa6>
		if ((wlk_prev_addr == gc_prev_addr) && gc_ate.len) {
   49498:	4556      	cmp	r6, sl
   4949a:	d1e4      	bne.n	49466 <nvs_gc+0x9a>
   4949c:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
   494a0:	2b00      	cmp	r3, #0
   494a2:	d0e0      	beq.n	49466 <nvs_gc+0x9a>
			data_addr += gc_ate.offset;
   494a4:	f8bd 7022 	ldrh.w	r7, [sp, #34]	; 0x22
			data_addr = (gc_prev_addr & ADDR_SECT_MASK);
   494a8:	ea4f 431a 	mov.w	r3, sl, lsr #16
   494ac:	041b      	lsls	r3, r3, #16
			data_addr += gc_ate.offset;
   494ae:	441f      	add	r7, r3
			nvs_ate_crc8_update(&gc_ate);
   494b0:	a808      	add	r0, sp, #32
			gc_ate.offset = (uint16_t)(fs->data_wra & ADDR_OFFS_MASK);
   494b2:	68a3      	ldr	r3, [r4, #8]
   494b4:	f8ad 3022 	strh.w	r3, [sp, #34]	; 0x22
			nvs_ate_crc8_update(&gc_ate);
   494b8:	f7ff fe93 	bl	491e2 <nvs_ate_crc8_update>
		NVS_BLOCK_SIZE & ~(fs->flash_parameters->write_block_size - 1U);
   494bc:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
			rc = nvs_flash_block_move(fs, data_addr, gc_ate.len);
   494be:	f8bd 9024 	ldrh.w	r9, [sp, #36]	; 0x24
		NVS_BLOCK_SIZE & ~(fs->flash_parameters->write_block_size - 1U);
   494c2:	681e      	ldr	r6, [r3, #0]
   494c4:	4276      	negs	r6, r6
	block_size =
   494c6:	f006 0620 	and.w	r6, r6, #32
	while (len) {
   494ca:	f1b9 0f00 	cmp.w	r9, #0
   494ce:	d10e      	bne.n	494ee <nvs_gc+0x122>
			rc = nvs_flash_ate_wrt(fs, &gc_ate);
   494d0:	a908      	add	r1, sp, #32
   494d2:	4620      	mov	r0, r4
   494d4:	f7ff ff54 	bl	49380 <nvs_flash_ate_wrt>
			if (rc) {
   494d8:	4602      	mov	r2, r0
   494da:	2800      	cmp	r0, #0
   494dc:	d0c3      	beq.n	49466 <nvs_gc+0x9a>
   494de:	e03e      	b.n	4955e <nvs_gc+0x192>
			    (nvs_ate_valid(fs, &wlk_ate))) {
   494e0:	a90a      	add	r1, sp, #40	; 0x28
   494e2:	4620      	mov	r0, r4
   494e4:	f7ff fe90 	bl	49208 <nvs_ate_valid>
			if ((wlk_ate.id == gc_ate.id) &&
   494e8:	2800      	cmp	r0, #0
   494ea:	d0d1      	beq.n	49490 <nvs_gc+0xc4>
   494ec:	e7d4      	b.n	49498 <nvs_gc+0xcc>
		bytes_to_copy = MIN(block_size, len);
   494ee:	454e      	cmp	r6, r9
   494f0:	46b0      	mov	r8, r6
   494f2:	bf28      	it	cs
   494f4:	46c8      	movcs	r8, r9
		rc = nvs_flash_rd(fs, addr, buf, bytes_to_copy);
   494f6:	aa0c      	add	r2, sp, #48	; 0x30
   494f8:	4643      	mov	r3, r8
   494fa:	4639      	mov	r1, r7
   494fc:	4620      	mov	r0, r4
   494fe:	f7ff fdec 	bl	490da <nvs_flash_rd>
		if (rc) {
   49502:	4602      	mov	r2, r0
   49504:	bb58      	cbnz	r0, 4955e <nvs_gc+0x192>
	rc = nvs_flash_al_wrt(fs, fs->data_wra, data, len);
   49506:	4643      	mov	r3, r8
   49508:	68a1      	ldr	r1, [r4, #8]
   4950a:	aa0c      	add	r2, sp, #48	; 0x30
   4950c:	4620      	mov	r0, r4
   4950e:	f7ff fefd 	bl	4930c <nvs_flash_al_wrt>
	fs->data_wra += nvs_al_size(fs, len);
   49512:	4641      	mov	r1, r8
	rc = nvs_flash_al_wrt(fs, fs->data_wra, data, len);
   49514:	4602      	mov	r2, r0
	fs->data_wra += nvs_al_size(fs, len);
   49516:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   49518:	f7ff fe6c 	bl	491f4 <nvs_al_size.isra.0>
   4951c:	68a3      	ldr	r3, [r4, #8]
   4951e:	4403      	add	r3, r0
   49520:	60a3      	str	r3, [r4, #8]
		if (rc) {
   49522:	b9e2      	cbnz	r2, 4955e <nvs_gc+0x192>
		len -= bytes_to_copy;
   49524:	eba9 0908 	sub.w	r9, r9, r8
		addr += bytes_to_copy;
   49528:	4447      	add	r7, r8
   4952a:	e7ce      	b.n	494ca <nvs_gc+0xfe>
		rc = nvs_add_gc_done_ate(fs);
   4952c:	4620      	mov	r0, r4
   4952e:	f7ff ff38 	bl	493a2 <nvs_add_gc_done_ate>
		if (rc) {
   49532:	4602      	mov	r2, r0
   49534:	2800      	cmp	r0, #0
   49536:	f43f af7a 	beq.w	4942e <nvs_gc+0x62>
   4953a:	e010      	b.n	4955e <nvs_gc+0x192>
	stop_addr = gc_addr - ate_size;
   4953c:	1b73      	subs	r3, r6, r5
	if (nvs_close_ate_valid(fs, &close_ate)) {
   4953e:	a906      	add	r1, sp, #24
   49540:	4620      	mov	r0, r4
	stop_addr = gc_addr - ate_size;
   49542:	9301      	str	r3, [sp, #4]
	if (nvs_close_ate_valid(fs, &close_ate)) {
   49544:	f7ff fe7a 	bl	4923c <nvs_close_ate_valid>
   49548:	2800      	cmp	r0, #0
   4954a:	f47f af76 	bne.w	4943a <nvs_gc+0x6e>
		rc = nvs_recover_last_ate(fs, &gc_addr);
   4954e:	a904      	add	r1, sp, #16
   49550:	4620      	mov	r0, r4
   49552:	f7e1 fecb 	bl	2b2ec <nvs_recover_last_ate>
		if (rc) {
   49556:	4602      	mov	r2, r0
   49558:	2800      	cmp	r0, #0
   4955a:	f43f af74 	beq.w	49446 <nvs_gc+0x7a>
}
   4955e:	4610      	mov	r0, r2
   49560:	b015      	add	sp, #84	; 0x54
   49562:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00049566 <nvs_delete>:

int nvs_delete(struct nvs_fs *fs, uint16_t id)
{
	return nvs_write(fs, id, NULL, 0);
   49566:	2300      	movs	r3, #0
   49568:	461a      	mov	r2, r3
   4956a:	f7e2 b851 	b.w	2b610 <nvs_write>

0004956e <nvs_read_hist>:
}

ssize_t nvs_read_hist(struct nvs_fs *fs, uint16_t id, void *data, size_t len,
		      uint16_t cnt)
{
   4956e:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
   49572:	461e      	mov	r6, r3
	uint32_t wlk_addr, rd_addr;
	uint16_t cnt_his;
	struct nvs_ate wlk_ate;
	size_t ate_size;

	if (!fs->ready) {
   49574:	7c03      	ldrb	r3, [r0, #16]
{
   49576:	f8bd 9030 	ldrh.w	r9, [sp, #48]	; 0x30
   4957a:	4604      	mov	r4, r0
   4957c:	460f      	mov	r7, r1
   4957e:	4690      	mov	r8, r2
	if (!fs->ready) {
   49580:	2b00      	cmp	r3, #0
   49582:	d04e      	beq.n	49622 <nvs_read_hist+0xb4>
		LOG_ERR("NVS not initialized");
		return -EACCES;
	}

	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   49584:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
   49586:	2108      	movs	r1, #8
   49588:	f7ff fe34 	bl	491f4 <nvs_al_size.isra.0>

	if (len > (fs->sector_size - 2 * ate_size)) {
   4958c:	89a3      	ldrh	r3, [r4, #12]
   4958e:	eba3 0340 	sub.w	r3, r3, r0, lsl #1
   49592:	429e      	cmp	r6, r3
   49594:	d848      	bhi.n	49628 <nvs_read_hist+0xba>
	if (wlk_addr == NVS_LOOKUP_CACHE_NO_ADDR) {
		rc = -ENOENT;
		goto err;
	}
#else
	wlk_addr = fs->ate_wra;
   49596:	f8d4 a004 	ldr.w	sl, [r4, #4]
   4959a:	f8cd a004 	str.w	sl, [sp, #4]
	cnt_his = 0U;
   4959e:	2500      	movs	r5, #0
#endif
	rd_addr = wlk_addr;

	while (cnt_his <= cnt) {
   495a0:	45a9      	cmp	r9, r5
   495a2:	4651      	mov	r1, sl
		rd_addr = wlk_addr;
   495a4:	f8dd a004 	ldr.w	sl, [sp, #4]
	while (cnt_his <= cnt) {
   495a8:	d20b      	bcs.n	495c2 <nvs_read_hist+0x54>
		if (wlk_addr == fs->ate_wra) {
			break;
		}
	}

	if (((wlk_addr == fs->ate_wra) && (wlk_ate.id != id)) ||
   495aa:	6863      	ldr	r3, [r4, #4]
   495ac:	4553      	cmp	r3, sl
   495ae:	d120      	bne.n	495f2 <nvs_read_hist+0x84>
   495b0:	f8bd 3008 	ldrh.w	r3, [sp, #8]
   495b4:	42bb      	cmp	r3, r7
   495b6:	d01c      	beq.n	495f2 <nvs_read_hist+0x84>
	    (wlk_ate.len == 0U) || (cnt_his < cnt)) {
		return -ENOENT;
   495b8:	f06f 0001 	mvn.w	r0, #1

	return wlk_ate.len;

err:
	return rc;
}
   495bc:	b004      	add	sp, #16
   495be:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
   495c2:	aa02      	add	r2, sp, #8
   495c4:	a901      	add	r1, sp, #4
   495c6:	4620      	mov	r0, r4
   495c8:	f7ff fe56 	bl	49278 <nvs_prev_ate>
		if (rc) {
   495cc:	2800      	cmp	r0, #0
   495ce:	d1f5      	bne.n	495bc <nvs_read_hist+0x4e>
		if ((wlk_ate.id == id) &&  (nvs_ate_valid(fs, &wlk_ate))) {
   495d0:	f8bd 3008 	ldrh.w	r3, [sp, #8]
   495d4:	42bb      	cmp	r3, r7
   495d6:	d106      	bne.n	495e6 <nvs_read_hist+0x78>
   495d8:	a902      	add	r1, sp, #8
   495da:	4620      	mov	r0, r4
   495dc:	f7ff fe14 	bl	49208 <nvs_ate_valid>
   495e0:	b108      	cbz	r0, 495e6 <nvs_read_hist+0x78>
			cnt_his++;
   495e2:	3501      	adds	r5, #1
   495e4:	b2ad      	uxth	r5, r5
		if (wlk_addr == fs->ate_wra) {
   495e6:	6862      	ldr	r2, [r4, #4]
   495e8:	9b01      	ldr	r3, [sp, #4]
   495ea:	429a      	cmp	r2, r3
   495ec:	d1d8      	bne.n	495a0 <nvs_read_hist+0x32>
		rd_addr = wlk_addr;
   495ee:	4651      	mov	r1, sl
   495f0:	e7de      	b.n	495b0 <nvs_read_hist+0x42>
	    (wlk_ate.len == 0U) || (cnt_his < cnt)) {
   495f2:	f8bd 300c 	ldrh.w	r3, [sp, #12]
	if (((wlk_addr == fs->ate_wra) && (wlk_ate.id != id)) ||
   495f6:	2b00      	cmp	r3, #0
   495f8:	d0de      	beq.n	495b8 <nvs_read_hist+0x4a>
	    (wlk_ate.len == 0U) || (cnt_his < cnt)) {
   495fa:	45a9      	cmp	r9, r5
   495fc:	d8dc      	bhi.n	495b8 <nvs_read_hist+0x4a>
	rd_addr += wlk_ate.offset;
   495fe:	f8bd 000a 	ldrh.w	r0, [sp, #10]
	rd_addr &= ADDR_SECT_MASK;
   49602:	0c09      	lsrs	r1, r1, #16
	rc = nvs_flash_rd(fs, rd_addr, data, MIN(len, wlk_ate.len));
   49604:	42b3      	cmp	r3, r6
	rd_addr &= ADDR_SECT_MASK;
   49606:	ea4f 4101 	mov.w	r1, r1, lsl #16
	rc = nvs_flash_rd(fs, rd_addr, data, MIN(len, wlk_ate.len));
   4960a:	bf28      	it	cs
   4960c:	4633      	movcs	r3, r6
   4960e:	4401      	add	r1, r0
   49610:	4642      	mov	r2, r8
   49612:	4620      	mov	r0, r4
   49614:	f7ff fd61 	bl	490da <nvs_flash_rd>
	if (rc) {
   49618:	2800      	cmp	r0, #0
   4961a:	d1cf      	bne.n	495bc <nvs_read_hist+0x4e>
	return wlk_ate.len;
   4961c:	f8bd 000c 	ldrh.w	r0, [sp, #12]
   49620:	e7cc      	b.n	495bc <nvs_read_hist+0x4e>
		return -EACCES;
   49622:	f06f 000c 	mvn.w	r0, #12
   49626:	e7c9      	b.n	495bc <nvs_read_hist+0x4e>
		return -EINVAL;
   49628:	f06f 0015 	mvn.w	r0, #21
   4962c:	e7c6      	b.n	495bc <nvs_read_hist+0x4e>

0004962e <nvs_read>:

ssize_t nvs_read(struct nvs_fs *fs, uint16_t id, void *data, size_t len)
{
   4962e:	b513      	push	{r0, r1, r4, lr}
	int rc;

	rc = nvs_read_hist(fs, id, data, len, 0);
   49630:	2400      	movs	r4, #0
   49632:	9400      	str	r4, [sp, #0]
   49634:	f7ff ff9b 	bl	4956e <nvs_read_hist>
	return rc;
}
   49638:	b002      	add	sp, #8
   4963a:	bd10      	pop	{r4, pc}

0004963c <usb_write>:
{
   4963c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   49640:	4606      	mov	r6, r0
   49642:	460f      	mov	r7, r1
   49644:	4690      	mov	r8, r2
   49646:	4699      	mov	r9, r3
   49648:	250b      	movs	r5, #11
		ret = usb_dc_ep_write(ep, data, data_len, bytes_ret);
   4964a:	464b      	mov	r3, r9
   4964c:	4642      	mov	r2, r8
   4964e:	4639      	mov	r1, r7
   49650:	4630      	mov	r0, r6
   49652:	f7f9 feb5 	bl	433c0 <usb_dc_ep_write>
		if (ret == -EAGAIN) {
   49656:	f110 0f0b 	cmn.w	r0, #11
		ret = usb_dc_ep_write(ep, data, data_len, bytes_ret);
   4965a:	4604      	mov	r4, r0
		if (ret == -EAGAIN) {
   4965c:	d103      	bne.n	49666 <usb_write+0x2a>
	z_impl_k_yield();
   4965e:	f7fe fa15 	bl	47a8c <z_impl_k_yield>
	} while (ret == -EAGAIN && tries--);
   49662:	3d01      	subs	r5, #1
   49664:	d1f1      	bne.n	4964a <usb_write+0xe>
}
   49666:	4620      	mov	r0, r4
   49668:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0004966c <usb_get_dev_data_by_cfg>:
	return list->head;
   4966c:	6800      	ldr	r0, [r0, #0]
struct usb_dev_data *usb_get_dev_data_by_cfg(sys_slist_t *list,
					     struct usb_cfg_data *cfg)
{
	struct usb_dev_data *dev_data;

	SYS_SLIST_FOR_EACH_CONTAINER(list, dev_data, node) {
   4966e:	b140      	cbz	r0, 49682 <usb_get_dev_data_by_cfg+0x16>
		const struct device *dev = dev_data->dev;
		const struct usb_cfg_data *cfg_cur = dev->config;
   49670:	f850 3c04 	ldr.w	r3, [r0, #-4]

		if (cfg_cur == cfg) {
   49674:	685b      	ldr	r3, [r3, #4]
   49676:	428b      	cmp	r3, r1
	SYS_SLIST_FOR_EACH_CONTAINER(list, dev_data, node) {
   49678:	f1a0 0004 	sub.w	r0, r0, #4
		if (cfg_cur == cfg) {
   4967c:	d001      	beq.n	49682 <usb_get_dev_data_by_cfg+0x16>
	return node->next;
   4967e:	6840      	ldr	r0, [r0, #4]
   49680:	e7f5      	b.n	4966e <usb_get_dev_data_by_cfg+0x2>
	}

	LOG_DBG("Device data not found for cfg %p", cfg);

	return NULL;
}
   49682:	4770      	bx	lr

00049684 <usb_get_dev_data_by_iface>:
	return list->head;
   49684:	6800      	ldr	r0, [r0, #0]
struct usb_dev_data *usb_get_dev_data_by_iface(sys_slist_t *list,
					       uint8_t iface_num)
{
	struct usb_dev_data *dev_data;

	SYS_SLIST_FOR_EACH_CONTAINER(list, dev_data, node) {
   49686:	b150      	cbz	r0, 4969e <usb_get_dev_data_by_iface+0x1a>
		const struct device *dev = dev_data->dev;
		const struct usb_cfg_data *cfg = dev->config;
   49688:	f850 3c04 	ldr.w	r3, [r0, #-4]
		const struct usb_if_descriptor *if_desc =
   4968c:	685b      	ldr	r3, [r3, #4]
						cfg->interface_descriptor;

		if (if_desc->bInterfaceNumber == iface_num) {
   4968e:	685b      	ldr	r3, [r3, #4]
   49690:	789b      	ldrb	r3, [r3, #2]
   49692:	428b      	cmp	r3, r1
	SYS_SLIST_FOR_EACH_CONTAINER(list, dev_data, node) {
   49694:	f1a0 0004 	sub.w	r0, r0, #4
		if (if_desc->bInterfaceNumber == iface_num) {
   49698:	d001      	beq.n	4969e <usb_get_dev_data_by_iface+0x1a>
	return node->next;
   4969a:	6840      	ldr	r0, [r0, #4]
   4969c:	e7f3      	b.n	49686 <usb_get_dev_data_by_iface+0x2>
	}

	LOG_DBG("Device data not found for iface number %u", iface_num);

	return NULL;
}
   4969e:	4770      	bx	lr

000496a0 <usb_get_dev_data_by_ep>:

struct usb_dev_data *usb_get_dev_data_by_ep(sys_slist_t *list, uint8_t ep)
{
   496a0:	b530      	push	{r4, r5, lr}
	return list->head;
   496a2:	6800      	ldr	r0, [r0, #0]
	struct usb_dev_data *dev_data;

	SYS_SLIST_FOR_EACH_CONTAINER(list, dev_data, node) {
   496a4:	b188      	cbz	r0, 496ca <usb_get_dev_data_by_ep+0x2a>
		const struct device *dev = dev_data->dev;
		const struct usb_cfg_data *cfg = dev->config;
   496a6:	f850 3c04 	ldr.w	r3, [r0, #-4]
   496aa:	685b      	ldr	r3, [r3, #4]
		const struct usb_ep_cfg_data *ep_data = cfg->endpoint;
   496ac:	6a1a      	ldr	r2, [r3, #32]

		for (uint8_t i = 0; i < cfg->num_endpoints; i++) {
   496ae:	7f1d      	ldrb	r5, [r3, #28]
	SYS_SLIST_FOR_EACH_CONTAINER(list, dev_data, node) {
   496b0:	3804      	subs	r0, #4
		for (uint8_t i = 0; i < cfg->num_endpoints; i++) {
   496b2:	2300      	movs	r3, #0
			if (ep_data[i].ep_addr == ep) {
   496b4:	3a04      	subs	r2, #4
		for (uint8_t i = 0; i < cfg->num_endpoints; i++) {
   496b6:	b2dc      	uxtb	r4, r3
   496b8:	42a5      	cmp	r5, r4
   496ba:	d801      	bhi.n	496c0 <usb_get_dev_data_by_ep+0x20>
	return node->next;
   496bc:	6840      	ldr	r0, [r0, #4]
   496be:	e7f1      	b.n	496a4 <usb_get_dev_data_by_ep+0x4>
			if (ep_data[i].ep_addr == ep) {
   496c0:	3301      	adds	r3, #1
   496c2:	f812 4033 	ldrb.w	r4, [r2, r3, lsl #3]
   496c6:	428c      	cmp	r4, r1
   496c8:	d1f5      	bne.n	496b6 <usb_get_dev_data_by_ep+0x16>
	}

	LOG_DBG("Device data not found for ep %u", ep);

	return NULL;
}
   496ca:	bd30      	pop	{r4, r5, pc}

000496cc <flash_area_close>:

void flash_area_close(const struct flash_area *fa)
{
	/* nothing to do for now */
}
   496cc:	4770      	bx	lr

000496ce <get_sectors_cb>:
{
   496ce:	b570      	push	{r4, r5, r6, lr}
	if (info->start_offset < data->area_off) {
   496d0:	684c      	ldr	r4, [r1, #4]
   496d2:	6803      	ldr	r3, [r0, #0]
   496d4:	42a3      	cmp	r3, r4
   496d6:	d201      	bcs.n	496dc <get_sectors_cb+0xe>
		*bail_value = true;
   496d8:	2001      	movs	r0, #1
}
   496da:	bd70      	pop	{r4, r5, r6, pc}
	} else if (info->start_offset >= data->area_off + data->area_len) {
   496dc:	688a      	ldr	r2, [r1, #8]
   496de:	4422      	add	r2, r4
   496e0:	4293      	cmp	r3, r2
   496e2:	d301      	bcc.n	496e8 <get_sectors_cb+0x1a>
		*bail_value = false;
   496e4:	2000      	movs	r0, #0
   496e6:	e7f8      	b.n	496da <get_sectors_cb+0xc>
	} else if (data->ret_idx >= data->ret_len) {
   496e8:	e9d1 2503 	ldrd	r2, r5, [r1, #12]
   496ec:	694e      	ldr	r6, [r1, #20]
   496ee:	42b5      	cmp	r5, r6
   496f0:	d303      	bcc.n	496fa <get_sectors_cb+0x2c>
		data->status = -ENOMEM;
   496f2:	f06f 030b 	mvn.w	r3, #11
   496f6:	618b      	str	r3, [r1, #24]
		return true;
   496f8:	e7f4      	b.n	496e4 <get_sectors_cb+0x16>
	ret[data->ret_idx].fs_off = info->start_offset - data->area_off;
   496fa:	1b1b      	subs	r3, r3, r4
   496fc:	f842 3035 	str.w	r3, [r2, r5, lsl #3]
	ret[data->ret_idx].fs_size = info->size;
   49700:	6843      	ldr	r3, [r0, #4]
   49702:	6908      	ldr	r0, [r1, #16]
   49704:	eb02 02c0 	add.w	r2, r2, r0, lsl #3
   49708:	6053      	str	r3, [r2, #4]
	data->ret_idx++;
   4970a:	690b      	ldr	r3, [r1, #16]
   4970c:	3301      	adds	r3, #1
   4970e:	610b      	str	r3, [r1, #16]
	return true;
   49710:	e7e2      	b.n	496d8 <get_sectors_cb+0xa>

00049712 <settings_delete>:
	return settings_save_one(name, NULL, 0);
   49712:	2200      	movs	r2, #0
   49714:	4611      	mov	r1, r2
   49716:	f7e2 bec1 	b.w	2c49c <settings_save_one>

0004971a <settings_name_steq>:
{
   4971a:	4603      	mov	r3, r0
   4971c:	b510      	push	{r4, lr}
   4971e:	4608      	mov	r0, r1
	if (next) {
   49720:	b10a      	cbz	r2, 49726 <settings_name_steq+0xc>
		*next = NULL;
   49722:	2100      	movs	r1, #0
   49724:	6011      	str	r1, [r2, #0]
	if ((!name) || (!key)) {
   49726:	b153      	cbz	r3, 4973e <settings_name_steq+0x24>
   49728:	b1d0      	cbz	r0, 49760 <settings_name_steq+0x46>
   4972a:	1e41      	subs	r1, r0, #1
	while ((*key != '\0') && (*key == *name) &&
   4972c:	f811 0f01 	ldrb.w	r0, [r1, #1]!
	       (*name != '\0') && (*name != SETTINGS_NAME_END)) {
   49730:	b180      	cbz	r0, 49754 <settings_name_steq+0x3a>
	while ((*key != '\0') && (*key == *name) &&
   49732:	f813 4b01 	ldrb.w	r4, [r3], #1
   49736:	42a0      	cmp	r0, r4
   49738:	d101      	bne.n	4973e <settings_name_steq+0x24>
	       (*name != '\0') && (*name != SETTINGS_NAME_END)) {
   4973a:	283d      	cmp	r0, #61	; 0x3d
   4973c:	d1f6      	bne.n	4972c <settings_name_steq+0x12>
		return 0;
   4973e:	2000      	movs	r0, #0
   49740:	e00e      	b.n	49760 <settings_name_steq+0x46>
			*next = name + 1;
   49742:	3301      	adds	r3, #1
   49744:	6013      	str	r3, [r2, #0]
   49746:	e00a      	b.n	4975e <settings_name_steq+0x44>
	if ((*name == SETTINGS_NAME_END) || (*name == '\0')) {
   49748:	283d      	cmp	r0, #61	; 0x3d
   4974a:	d008      	beq.n	4975e <settings_name_steq+0x44>
   4974c:	fab0 f080 	clz	r0, r0
   49750:	0940      	lsrs	r0, r0, #5
   49752:	e005      	b.n	49760 <settings_name_steq+0x46>
	if (*name == SETTINGS_NAME_SEPARATOR) {
   49754:	7818      	ldrb	r0, [r3, #0]
   49756:	282f      	cmp	r0, #47	; 0x2f
   49758:	d1f6      	bne.n	49748 <settings_name_steq+0x2e>
		if (next) {
   4975a:	2a00      	cmp	r2, #0
   4975c:	d1f1      	bne.n	49742 <settings_name_steq+0x28>
		return 1;
   4975e:	2001      	movs	r0, #1
}
   49760:	bd10      	pop	{r4, pc}

00049762 <settings_name_next>:
{
   49762:	b510      	push	{r4, lr}
	if (next) {
   49764:	b109      	cbz	r1, 4976a <settings_name_next+0x8>
		*next = NULL;
   49766:	2300      	movs	r3, #0
   49768:	600b      	str	r3, [r1, #0]
	if (!name) {
   4976a:	b158      	cbz	r0, 49784 <settings_name_next+0x22>
   4976c:	4603      	mov	r3, r0
	while ((*name != '\0') && (*name != SETTINGS_NAME_END) &&
   4976e:	781a      	ldrb	r2, [r3, #0]
   49770:	461c      	mov	r4, r3
   49772:	3301      	adds	r3, #1
   49774:	b12a      	cbz	r2, 49782 <settings_name_next+0x20>
   49776:	2a3d      	cmp	r2, #61	; 0x3d
   49778:	d003      	beq.n	49782 <settings_name_next+0x20>
   4977a:	2a2f      	cmp	r2, #47	; 0x2f
   4977c:	d1f7      	bne.n	4976e <settings_name_next+0xc>
		if (next) {
   4977e:	b101      	cbz	r1, 49782 <settings_name_next+0x20>
			*next = name + 1;
   49780:	600b      	str	r3, [r1, #0]
   49782:	1a20      	subs	r0, r4, r0
}
   49784:	bd10      	pop	{r4, pc}

00049786 <settings_call_set_handler>:
{
   49786:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   4978a:	f8dd 8020 	ldr.w	r8, [sp, #32]
	const char *name_key = name;
   4978e:	9001      	str	r0, [sp, #4]
{
   49790:	4607      	mov	r7, r0
   49792:	460c      	mov	r4, r1
   49794:	4615      	mov	r5, r2
   49796:	461e      	mov	r6, r3
	if (load_arg && load_arg->subtree &&
   49798:	f1b8 0f00 	cmp.w	r8, #0
   4979c:	d007      	beq.n	497ae <settings_call_set_handler+0x28>
   4979e:	f8d8 1000 	ldr.w	r1, [r8]
   497a2:	b981      	cbnz	r1, 497c6 <settings_call_set_handler+0x40>
	if (load_arg && load_arg->cb) {
   497a4:	f8d8 e004 	ldr.w	lr, [r8, #4]
   497a8:	f1be 0f00 	cmp.w	lr, #0
   497ac:	d114      	bne.n	497d8 <settings_call_set_handler+0x52>
		ch = settings_parse_and_lookup(name, &name_key);
   497ae:	a901      	add	r1, sp, #4
   497b0:	4638      	mov	r0, r7
   497b2:	f7e2 ff43 	bl	2c63c <settings_parse_and_lookup>
		if (!ch) {
   497b6:	b158      	cbz	r0, 497d0 <settings_call_set_handler+0x4a>
		rc = ch->h_set(name_key, len, read_cb, read_cb_arg);
   497b8:	6887      	ldr	r7, [r0, #8]
   497ba:	9801      	ldr	r0, [sp, #4]
   497bc:	4633      	mov	r3, r6
   497be:	462a      	mov	r2, r5
   497c0:	4621      	mov	r1, r4
   497c2:	47b8      	blx	r7
		if (rc != 0) {
   497c4:	e004      	b.n	497d0 <settings_call_set_handler+0x4a>
	    !settings_name_steq(name, load_arg->subtree, &name_key)) {
   497c6:	aa01      	add	r2, sp, #4
   497c8:	f7ff ffa7 	bl	4971a <settings_name_steq>
	if (load_arg && load_arg->subtree &&
   497cc:	2800      	cmp	r0, #0
   497ce:	d1e9      	bne.n	497a4 <settings_call_set_handler+0x1e>
}
   497d0:	2000      	movs	r0, #0
   497d2:	b002      	add	sp, #8
   497d4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		rc = load_arg->cb(name_key, len, read_cb, read_cb_arg,
   497d8:	f8d8 3008 	ldr.w	r3, [r8, #8]
   497dc:	9801      	ldr	r0, [sp, #4]
   497de:	9308      	str	r3, [sp, #32]
   497e0:	462a      	mov	r2, r5
   497e2:	4633      	mov	r3, r6
   497e4:	4621      	mov	r1, r4
   497e6:	46f4      	mov	ip, lr
}
   497e8:	b002      	add	sp, #8
   497ea:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		rc = load_arg->cb(name_key, len, read_cb, read_cb_arg,
   497ee:	4760      	bx	ip

000497f0 <settings_nvs_storage_get>:
static void *settings_nvs_storage_get(struct settings_store *cs)
{
	struct settings_nvs *cf = (struct settings_nvs *)cs;

	return &cf->cf_nvs;
}
   497f0:	3008      	adds	r0, #8
   497f2:	4770      	bx	lr

000497f4 <settings_nvs_read_fn>:
{
   497f4:	b510      	push	{r4, lr}
	rc = nvs_read(rd_fn_arg->fs, rd_fn_arg->id, data, len);
   497f6:	4613      	mov	r3, r2
{
   497f8:	4614      	mov	r4, r2
	rc = nvs_read(rd_fn_arg->fs, rd_fn_arg->id, data, len);
   497fa:	460a      	mov	r2, r1
   497fc:	8881      	ldrh	r1, [r0, #4]
   497fe:	6800      	ldr	r0, [r0, #0]
   49800:	f7ff ff15 	bl	4962e <nvs_read>
}
   49804:	42a0      	cmp	r0, r4
   49806:	bfa8      	it	ge
   49808:	4620      	movge	r0, r4
   4980a:	bd10      	pop	{r4, pc}

0004980c <settings_nvs_save>:
{
   4980c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   49810:	b097      	sub	sp, #92	; 0x5c
   49812:	4604      	mov	r4, r0
   49814:	9201      	str	r2, [sp, #4]
   49816:	469a      	mov	sl, r3
	if (!name) {
   49818:	4689      	mov	r9, r1
   4981a:	2900      	cmp	r1, #0
   4981c:	d07e      	beq.n	4991c <settings_nvs_save+0x110>
	delete = ((value == NULL) || (val_len == 0));
   4981e:	b1da      	cbz	r2, 49858 <settings_nvs_save+0x4c>
   49820:	faba f78a 	clz	r7, sl
   49824:	097f      	lsrs	r7, r7, #5
	name_id = cf->last_name_id + 1;
   49826:	8f25      	ldrh	r5, [r4, #56]	; 0x38
   49828:	3501      	adds	r5, #1
   4982a:	b2ad      	uxth	r5, r5
	write_name_id = cf->last_name_id + 1;
   4982c:	46a8      	mov	r8, r5
		rc = nvs_read(&cf->cf_nvs, name_id, &rdname, sizeof(rdname));
   4982e:	f104 0b08 	add.w	fp, r4, #8
		name_id--;
   49832:	1e6e      	subs	r6, r5, #1
   49834:	b2b6      	uxth	r6, r6
		if (name_id == NVS_NAMECNT_ID) {
   49836:	f5b6 4f00 	cmp.w	r6, #32768	; 0x8000
   4983a:	d040      	beq.n	498be <settings_nvs_save+0xb2>
		rc = nvs_read(&cf->cf_nvs, name_id, &rdname, sizeof(rdname));
   4983c:	234a      	movs	r3, #74	; 0x4a
   4983e:	aa03      	add	r2, sp, #12
   49840:	4631      	mov	r1, r6
   49842:	4658      	mov	r0, fp
   49844:	f7ff fef3 	bl	4962e <nvs_read>
		if (rc < 0) {
   49848:	2800      	cmp	r0, #0
   4984a:	da07      	bge.n	4985c <settings_nvs_save+0x50>
		name_id--;
   4984c:	f110 0f02 	cmn.w	r0, #2
   49850:	bf08      	it	eq
   49852:	46b0      	moveq	r8, r6
   49854:	4635      	mov	r5, r6
   49856:	e7ec      	b.n	49832 <settings_nvs_save+0x26>
	delete = ((value == NULL) || (val_len == 0));
   49858:	2701      	movs	r7, #1
   4985a:	e7e4      	b.n	49826 <settings_nvs_save+0x1a>
		rdname[rc] = '\0';
   4985c:	f100 0358 	add.w	r3, r0, #88	; 0x58
   49860:	eb0d 0003 	add.w	r0, sp, r3
   49864:	2300      	movs	r3, #0
   49866:	f800 3c4c 	strb.w	r3, [r0, #-76]
		if (strcmp(name, rdname)) {
   4986a:	a903      	add	r1, sp, #12
   4986c:	4648      	mov	r0, r9
   4986e:	f001 fad4 	bl	4ae1a <strcmp>
   49872:	2800      	cmp	r0, #0
   49874:	d1ee      	bne.n	49854 <settings_nvs_save+0x48>
		if ((delete) && (name_id == cf->last_name_id)) {
   49876:	b32f      	cbz	r7, 498c4 <settings_nvs_save+0xb8>
   49878:	8f23      	ldrh	r3, [r4, #56]	; 0x38
   4987a:	42b3      	cmp	r3, r6
   4987c:	d008      	beq.n	49890 <settings_nvs_save+0x84>
			rc = nvs_delete(&cf->cf_nvs, name_id);
   4987e:	4631      	mov	r1, r6
   49880:	4658      	mov	r0, fp
   49882:	f7ff fe70 	bl	49566 <nvs_delete>
			if (rc >= 0) {
   49886:	2800      	cmp	r0, #0
   49888:	da0f      	bge.n	498aa <settings_nvs_save+0x9e>
}
   4988a:	b017      	add	sp, #92	; 0x5c
   4988c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			cf->last_name_id--;
   49890:	4622      	mov	r2, r4
   49892:	1e73      	subs	r3, r6, #1
   49894:	f822 3f38 	strh.w	r3, [r2, #56]!
			rc = nvs_write(&cf->cf_nvs, NVS_NAMECNT_ID,
   49898:	f44f 4100 	mov.w	r1, #32768	; 0x8000
   4989c:	2302      	movs	r3, #2
   4989e:	4658      	mov	r0, fp
   498a0:	f7e1 feb6 	bl	2b610 <nvs_write>
			if (rc < 0) {
   498a4:	2800      	cmp	r0, #0
   498a6:	daea      	bge.n	4987e <settings_nvs_save+0x72>
   498a8:	e7ef      	b.n	4988a <settings_nvs_save+0x7e>
				rc = nvs_delete(&cf->cf_nvs, name_id +
   498aa:	f505 517f 	add.w	r1, r5, #16320	; 0x3fc0
   498ae:	313f      	adds	r1, #63	; 0x3f
   498b0:	b289      	uxth	r1, r1
   498b2:	4658      	mov	r0, fp
   498b4:	f7ff fe57 	bl	49566 <nvs_delete>
	if (rc < 0) {
   498b8:	ea00 70e0 	and.w	r0, r0, r0, asr #31
   498bc:	e7e5      	b.n	4988a <settings_nvs_save+0x7e>
	if (delete) {
   498be:	b1ff      	cbz	r7, 49900 <settings_nvs_save+0xf4>
			return 0;
   498c0:	2000      	movs	r0, #0
   498c2:	e7e2      	b.n	4988a <settings_nvs_save+0x7e>
		name_id--;
   498c4:	46b0      	mov	r8, r6
	if (write_name_id == NVS_NAMECNT_ID + NVS_NAME_ID_OFFSET) {
   498c6:	f5b8 4f40 	cmp.w	r8, #49152	; 0xc000
   498ca:	d02a      	beq.n	49922 <settings_nvs_save+0x116>
	rc = nvs_write(&cf->cf_nvs, write_name_id + NVS_NAME_ID_OFFSET,
   498cc:	f104 0508 	add.w	r5, r4, #8
   498d0:	f508 4180 	add.w	r1, r8, #16384	; 0x4000
   498d4:	9a01      	ldr	r2, [sp, #4]
   498d6:	4653      	mov	r3, sl
   498d8:	b289      	uxth	r1, r1
   498da:	4628      	mov	r0, r5
   498dc:	f7e1 fe98 	bl	2b610 <nvs_write>
	if (rc < 0) {
   498e0:	2800      	cmp	r0, #0
   498e2:	dbd2      	blt.n	4988a <settings_nvs_save+0x7e>
	if (write_name) {
   498e4:	b977      	cbnz	r7, 49904 <settings_nvs_save+0xf8>
	if (write_name_id > cf->last_name_id) {
   498e6:	8f23      	ldrh	r3, [r4, #56]	; 0x38
   498e8:	4543      	cmp	r3, r8
   498ea:	d2e9      	bcs.n	498c0 <settings_nvs_save+0xb4>
		cf->last_name_id = write_name_id;
   498ec:	4622      	mov	r2, r4
		rc = nvs_write(&cf->cf_nvs, NVS_NAMECNT_ID, &cf->last_name_id,
   498ee:	2302      	movs	r3, #2
		cf->last_name_id = write_name_id;
   498f0:	f822 8f38 	strh.w	r8, [r2, #56]!
		rc = nvs_write(&cf->cf_nvs, NVS_NAMECNT_ID, &cf->last_name_id,
   498f4:	f44f 4100 	mov.w	r1, #32768	; 0x8000
   498f8:	4628      	mov	r0, r5
   498fa:	f7e1 fe89 	bl	2b610 <nvs_write>
   498fe:	e7db      	b.n	498b8 <settings_nvs_save+0xac>
	write_name = true;
   49900:	2701      	movs	r7, #1
   49902:	e7e0      	b.n	498c6 <settings_nvs_save+0xba>
		rc = nvs_write(&cf->cf_nvs, write_name_id, name, strlen(name));
   49904:	4648      	mov	r0, r9
   49906:	f001 fa81 	bl	4ae0c <strlen>
   4990a:	464a      	mov	r2, r9
   4990c:	4603      	mov	r3, r0
   4990e:	4641      	mov	r1, r8
   49910:	4628      	mov	r0, r5
   49912:	f7e1 fe7d 	bl	2b610 <nvs_write>
		if (rc < 0) {
   49916:	2800      	cmp	r0, #0
   49918:	dae5      	bge.n	498e6 <settings_nvs_save+0xda>
   4991a:	e7b6      	b.n	4988a <settings_nvs_save+0x7e>
		return -EINVAL;
   4991c:	f06f 0015 	mvn.w	r0, #21
   49920:	e7b3      	b.n	4988a <settings_nvs_save+0x7e>
		return -ENOMEM;
   49922:	f06f 000b 	mvn.w	r0, #11
   49926:	e7b0      	b.n	4988a <settings_nvs_save+0x7e>

00049928 <settings_nvs_backend_init>:
{
   49928:	b573      	push	{r0, r1, r4, r5, r6, lr}
	cf->cf_nvs.flash_device = cf->flash_dev;
   4992a:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
   4992c:	6303      	str	r3, [r0, #48]	; 0x30
{
   4992e:	4604      	mov	r4, r0
	if (cf->cf_nvs.flash_device == NULL) {
   49930:	b1c3      	cbz	r3, 49964 <settings_nvs_backend_init+0x3c>
	rc = nvs_mount(&cf->cf_nvs);
   49932:	f100 0608 	add.w	r6, r0, #8
   49936:	4630      	mov	r0, r6
   49938:	f7e1 fd0a 	bl	2b350 <nvs_mount>
	if (rc) {
   4993c:	4605      	mov	r5, r0
   4993e:	b970      	cbnz	r0, 4995e <settings_nvs_backend_init+0x36>
	rc = nvs_read(&cf->cf_nvs, NVS_NAMECNT_ID, &last_name_id,
   49940:	2302      	movs	r3, #2
   49942:	f10d 0206 	add.w	r2, sp, #6
   49946:	f44f 4100 	mov.w	r1, #32768	; 0x8000
   4994a:	4630      	mov	r0, r6
   4994c:	f7ff fe6f 	bl	4962e <nvs_read>
	if (rc < 0) {
   49950:	2800      	cmp	r0, #0
		cf->last_name_id = last_name_id;
   49952:	bfac      	ite	ge
   49954:	f8bd 3006 	ldrhge.w	r3, [sp, #6]
   49958:	f44f 4300 	movlt.w	r3, #32768	; 0x8000
   4995c:	8723      	strh	r3, [r4, #56]	; 0x38
}
   4995e:	4628      	mov	r0, r5
   49960:	b002      	add	sp, #8
   49962:	bd70      	pop	{r4, r5, r6, pc}
		return -ENODEV;
   49964:	f06f 0512 	mvn.w	r5, #18
   49968:	e7f9      	b.n	4995e <settings_nvs_backend_init+0x36>

0004996a <_copy>:

#define MASK_TWENTY_SEVEN 0x1b

unsigned int _copy(uint8_t *to, unsigned int to_len,
		   const uint8_t *from, unsigned int from_len)
{
   4996a:	b538      	push	{r3, r4, r5, lr}
   4996c:	460d      	mov	r5, r1
	if (from_len <= to_len) {
   4996e:	42ab      	cmp	r3, r5
{
   49970:	4611      	mov	r1, r2
   49972:	461c      	mov	r4, r3
	if (from_len <= to_len) {
   49974:	d804      	bhi.n	49980 <_copy+0x16>
		(void)memcpy(to, from, from_len);
   49976:	461a      	mov	r2, r3
   49978:	f001 fa7f 	bl	4ae7a <memcpy>
		return from_len;
	} else {
		return TC_CRYPTO_FAIL;
	}
}
   4997c:	4620      	mov	r0, r4
   4997e:	bd38      	pop	{r3, r4, r5, pc}
		return TC_CRYPTO_FAIL;
   49980:	2400      	movs	r4, #0
   49982:	e7fb      	b.n	4997c <_copy+0x12>

00049984 <_set>:

void _set(void *to, uint8_t val, unsigned int len)
{
	(void)memset(to, val, len);
   49984:	f001 ba84 	b.w	4ae90 <memset>

00049988 <_double_byte>:
/*
 * Doubles the value of a byte for values up to 127.
 */
uint8_t _double_byte(uint8_t a)
{
	return ((a<<1) ^ ((a>>7) * MASK_TWENTY_SEVEN));
   49988:	09c3      	lsrs	r3, r0, #7
   4998a:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   4998e:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
   49992:	ea83 0040 	eor.w	r0, r3, r0, lsl #1
}
   49996:	b2c0      	uxtb	r0, r0
   49998:	4770      	bx	lr

0004999a <uECC_make_key>:
	}
	return 0;
}

int uECC_make_key(uint8_t *public_key, uint8_t *private_key, uECC_Curve curve)
{
   4999a:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   4999e:	4606      	mov	r6, r0
   499a0:	b0a9      	sub	sp, #164	; 0xa4
   499a2:	4688      	mov	r8, r1
   499a4:	4614      	mov	r4, r2
   499a6:	2740      	movs	r7, #64	; 0x40
			!rng_function((uint8_t *)_random, 2 * NUM_ECC_WORDS*uECC_WORD_SIZE)) {
        		return 0;
		}

		/* computing modular reduction of _random (see FIPS 186.4 B.4.1): */
		uECC_vli_mmod(_private, _random, curve->n, BITS_TO_WORDS(curve->num_n_bits));
   499a8:	f102 0924 	add.w	r9, r2, #36	; 0x24
		uECC_RNG_Function rng_function = uECC_get_rng();
   499ac:	f7e3 f8be 	bl	2cb2c <uECC_get_rng>
		if (!rng_function ||
   499b0:	4603      	mov	r3, r0
   499b2:	2800      	cmp	r0, #0
   499b4:	d03e      	beq.n	49a34 <uECC_make_key+0x9a>
			!rng_function((uint8_t *)_random, 2 * NUM_ECC_WORDS*uECC_WORD_SIZE)) {
   499b6:	2140      	movs	r1, #64	; 0x40
   499b8:	a808      	add	r0, sp, #32
   499ba:	4798      	blx	r3
		if (!rng_function ||
   499bc:	b3d0      	cbz	r0, 49a34 <uECC_make_key+0x9a>
		uECC_vli_mmod(_private, _random, curve->n, BITS_TO_WORDS(curve->num_n_bits));
   499be:	f9b4 2002 	ldrsh.w	r2, [r4, #2]
   499c2:	f112 031f 	adds.w	r3, r2, #31
   499c6:	bf48      	it	mi
   499c8:	f102 033e 	addmi.w	r3, r2, #62	; 0x3e
   499cc:	466d      	mov	r5, sp
   499ce:	464a      	mov	r2, r9
   499d0:	a908      	add	r1, sp, #32
   499d2:	4628      	mov	r0, r5
   499d4:	f343 1347 	sbfx	r3, r3, #5, #8
   499d8:	f000 f9f6 	bl	49dc8 <uECC_vli_mmod>

		/* Computing public-key from private: */
		if (EccPoint_compute_public_key(_public, _private, curve)) {
   499dc:	4622      	mov	r2, r4
   499de:	4629      	mov	r1, r5
   499e0:	a818      	add	r0, sp, #96	; 0x60
   499e2:	f000 fe09 	bl	4a5f8 <EccPoint_compute_public_key>
   499e6:	b318      	cbz	r0, 49a30 <uECC_make_key+0x96>

			/* Converting buffers to correct bit order: */
			uECC_vli_nativeToBytes(private_key,
					       BITS_TO_BYTES(curve->num_n_bits),
   499e8:	f9b4 3002 	ldrsh.w	r3, [r4, #2]
			uECC_vli_nativeToBytes(private_key,
   499ec:	1dd9      	adds	r1, r3, #7
   499ee:	bf48      	it	mi
   499f0:	f103 010e 	addmi.w	r1, r3, #14
   499f4:	462a      	mov	r2, r5
   499f6:	4640      	mov	r0, r8
   499f8:	10c9      	asrs	r1, r1, #3
   499fa:	f000 fe25 	bl	4a648 <uECC_vli_nativeToBytes>
					       _private);
			uECC_vli_nativeToBytes(public_key,
   499fe:	f994 1001 	ldrsb.w	r1, [r4, #1]
   49a02:	aa18      	add	r2, sp, #96	; 0x60
   49a04:	4630      	mov	r0, r6
   49a06:	f000 fe1f 	bl	4a648 <uECC_vli_nativeToBytes>
					       curve->num_bytes,
					       _public);
			uECC_vli_nativeToBytes(public_key + curve->num_bytes,
   49a0a:	f994 1001 	ldrsb.w	r1, [r4, #1]
 					       curve->num_bytes,
					       _public + curve->num_words);
   49a0e:	f994 2000 	ldrsb.w	r2, [r4]
			uECC_vli_nativeToBytes(public_key + curve->num_bytes,
   49a12:	ab18      	add	r3, sp, #96	; 0x60
   49a14:	eb03 0282 	add.w	r2, r3, r2, lsl #2
   49a18:	1870      	adds	r0, r6, r1
   49a1a:	f000 fe15 	bl	4a648 <uECC_vli_nativeToBytes>
#ifdef TINYCRYPT_ARCH_HAS_SET_SECURE
extern void _set_secure(void *to, uint8_t val, unsigned int len);
#else /* ! TINYCRYPT_ARCH_HAS_SET_SECURE */
static inline void _set_secure(void *to, uint8_t val, unsigned int len)
{
  (void) memset(to, val, len);
   49a1e:	2220      	movs	r2, #32
   49a20:	2100      	movs	r1, #0
   49a22:	4628      	mov	r0, r5
   49a24:	f001 fa34 	bl	4ae90 <memset>

			/* erasing temporary buffer that stored secret: */
			_set_secure(_private, 0, NUM_ECC_BYTES);

      			return 1;
   49a28:	2001      	movs	r0, #1
    		}
  	}
	return 0;
}
   49a2a:	b029      	add	sp, #164	; 0xa4
   49a2c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	for (tries = 0; tries < uECC_RNG_MAX_TRIES; ++tries) {
   49a30:	3f01      	subs	r7, #1
   49a32:	d1bb      	bne.n	499ac <uECC_make_key+0x12>
        		return 0;
   49a34:	2000      	movs	r0, #0
   49a36:	e7f8      	b.n	49a2a <uECC_make_key+0x90>

00049a38 <uECC_shared_secret>:

int uECC_shared_secret(const uint8_t *public_key, const uint8_t *private_key,
		       uint8_t *secret, uECC_Curve curve)
{
   49a38:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   49a3c:	461c      	mov	r4, r3
	uECC_word_t tmp[NUM_ECC_WORDS];
	uECC_word_t *p2[2] = {_private, tmp};
	uECC_word_t *initial_Z = 0;
	uECC_word_t carry;
	wordcount_t num_words = curve->num_words;
	wordcount_t num_bytes = curve->num_bytes;
   49a3e:	f993 7001 	ldrsb.w	r7, [r3, #1]
	wordcount_t num_words = curve->num_words;
   49a42:	f993 a000 	ldrsb.w	sl, [r3]
	int r;

	/* Converting buffers to correct bit order: */
	uECC_vli_bytesToNative(_private,
      			       private_key,
			       BITS_TO_BYTES(curve->num_n_bits));
   49a46:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
{
   49a4a:	b0a4      	sub	sp, #144	; 0x90
   49a4c:	4690      	mov	r8, r2
	uECC_vli_bytesToNative(_private,
   49a4e:	1dda      	adds	r2, r3, #7
   49a50:	bf48      	it	mi
   49a52:	f103 020e 	addmi.w	r2, r3, #14
	uECC_word_t *p2[2] = {_private, tmp};
   49a56:	ad04      	add	r5, sp, #16
{
   49a58:	4681      	mov	r9, r0
	uECC_word_t *p2[2] = {_private, tmp};
   49a5a:	ae0c      	add	r6, sp, #48	; 0x30
	uECC_vli_bytesToNative(_private,
   49a5c:	4628      	mov	r0, r5
   49a5e:	10d2      	asrs	r2, r2, #3
	uECC_word_t *p2[2] = {_private, tmp};
   49a60:	9502      	str	r5, [sp, #8]
   49a62:	9603      	str	r6, [sp, #12]
	uECC_vli_bytesToNative(_private,
   49a64:	f000 fe04 	bl	4a670 <uECC_vli_bytesToNative>
	uECC_vli_bytesToNative(_public,
   49a68:	463a      	mov	r2, r7
   49a6a:	4649      	mov	r1, r9
   49a6c:	a814      	add	r0, sp, #80	; 0x50
   49a6e:	f000 fdff 	bl	4a670 <uECC_vli_bytesToNative>
      			       public_key,
			       num_bytes);
	uECC_vli_bytesToNative(_public + num_words,
   49a72:	ab14      	add	r3, sp, #80	; 0x50
   49a74:	eb09 0107 	add.w	r1, r9, r7
   49a78:	eb03 008a 	add.w	r0, r3, sl, lsl #2
   49a7c:	463a      	mov	r2, r7
   49a7e:	f000 fdf7 	bl	4a670 <uECC_vli_bytesToNative>
			       public_key + num_bytes,
			       num_bytes);

	/* Regularize the bitcount for the private key so that attackers cannot use a
	 * side channel attack to learn the number of leading zeros. */
	carry = regularize_k(_private, _private, tmp, curve);
   49a82:	4623      	mov	r3, r4
   49a84:	4632      	mov	r2, r6
   49a86:	4629      	mov	r1, r5
   49a88:	4628      	mov	r0, r5
   49a8a:	f000 fd89 	bl	4a5a0 <regularize_k>
			goto clear_and_out;
    		}
    		initial_Z = p2[carry];
  	}

	EccPoint_mult(_public, _public, p2[!carry], initial_Z, curve->num_n_bits + 1,
   49a8e:	fab0 f380 	clz	r3, r0
   49a92:	9401      	str	r4, [sp, #4]
   49a94:	aa24      	add	r2, sp, #144	; 0x90
   49a96:	095b      	lsrs	r3, r3, #5
   49a98:	eb02 0183 	add.w	r1, r2, r3, lsl #2
   49a9c:	8863      	ldrh	r3, [r4, #2]
   49a9e:	3301      	adds	r3, #1
   49aa0:	b21b      	sxth	r3, r3
   49aa2:	9300      	str	r3, [sp, #0]
   49aa4:	f851 2c88 	ldr.w	r2, [r1, #-136]
   49aa8:	a914      	add	r1, sp, #80	; 0x50
   49aaa:	2300      	movs	r3, #0
   49aac:	4608      	mov	r0, r1
   49aae:	f000 fcaf 	bl	4a410 <EccPoint_mult>
		      curve);

	uECC_vli_nativeToBytes(secret, num_bytes, _public);
   49ab2:	aa14      	add	r2, sp, #80	; 0x50
   49ab4:	4639      	mov	r1, r7
   49ab6:	4640      	mov	r0, r8
   49ab8:	f000 fdc6 	bl	4a648 <uECC_vli_nativeToBytes>
	r = !EccPoint_isZero(_public, curve);
   49abc:	4621      	mov	r1, r4
   49abe:	a814      	add	r0, sp, #80	; 0x50
   49ac0:	f000 fc1b 	bl	4a2fa <EccPoint_isZero>
   49ac4:	af02      	add	r7, sp, #8
   49ac6:	4604      	mov	r4, r0
   49ac8:	2208      	movs	r2, #8
   49aca:	2100      	movs	r1, #0
   49acc:	4638      	mov	r0, r7
   49ace:	f001 f9df 	bl	4ae90 <memset>
   49ad2:	2220      	movs	r2, #32
   49ad4:	2100      	movs	r1, #0
   49ad6:	4630      	mov	r0, r6
   49ad8:	f001 f9da 	bl	4ae90 <memset>
   49adc:	2220      	movs	r2, #32
   49ade:	2100      	movs	r1, #0
   49ae0:	4628      	mov	r0, r5
   49ae2:	f001 f9d5 	bl	4ae90 <memset>
	_set_secure(p2, 0, sizeof(p2));
	_set_secure(tmp, 0, sizeof(tmp));
	_set_secure(_private, 0, sizeof(_private));

	return r;
}
   49ae6:	fab4 f084 	clz	r0, r4
   49aea:	0940      	lsrs	r0, r0, #5
   49aec:	b024      	add	sp, #144	; 0x90
   49aee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

00049af2 <uECC_vli_add>:
{
   49af2:	b5f0      	push	{r4, r5, r6, r7, lr}
	for (i = 0; i < num_words; ++i) {
   49af4:	2400      	movs	r4, #0
{
   49af6:	4606      	mov	r6, r0
	uECC_word_t carry = 0;
   49af8:	4620      	mov	r0, r4
	for (i = 0; i < num_words; ++i) {
   49afa:	b265      	sxtb	r5, r4
   49afc:	42ab      	cmp	r3, r5
   49afe:	dc00      	bgt.n	49b02 <uECC_vli_add+0x10>
}
   49b00:	bdf0      	pop	{r4, r5, r6, r7, pc}
		uECC_word_t sum = left[i] + right[i] + carry;
   49b02:	f851 7024 	ldr.w	r7, [r1, r4, lsl #2]
   49b06:	f852 5024 	ldr.w	r5, [r2, r4, lsl #2]
   49b0a:	443d      	add	r5, r7
   49b0c:	4405      	add	r5, r0
	return (p_true*(cond)) | (p_false*(!cond));
   49b0e:	42af      	cmp	r7, r5
   49b10:	f000 0001 	and.w	r0, r0, #1
   49b14:	bf18      	it	ne
   49b16:	2000      	movne	r0, #0
		result[i] = sum;
   49b18:	f846 5024 	str.w	r5, [r6, r4, lsl #2]
	return (p_true*(cond)) | (p_false*(!cond));
   49b1c:	bf88      	it	hi
   49b1e:	f040 0001 	orrhi.w	r0, r0, #1
	for (i = 0; i < num_words; ++i) {
   49b22:	3401      	adds	r4, #1
   49b24:	e7e9      	b.n	49afa <uECC_vli_add+0x8>

00049b26 <uECC_vli_rshift1>:
	vli += num_words;
   49b26:	eb00 0181 	add.w	r1, r0, r1, lsl #2
	uECC_word_t carry = 0;
   49b2a:	2300      	movs	r3, #0
	while (vli-- > end) {
   49b2c:	4288      	cmp	r0, r1
   49b2e:	d300      	bcc.n	49b32 <uECC_vli_rshift1+0xc>
}
   49b30:	4770      	bx	lr
		uECC_word_t temp = *vli;
   49b32:	f851 2d04 	ldr.w	r2, [r1, #-4]!
		*vli = (temp >> 1) | carry;
   49b36:	ea43 0352 	orr.w	r3, r3, r2, lsr #1
   49b3a:	600b      	str	r3, [r1, #0]
		carry = temp << (uECC_WORD_BITS - 1);
   49b3c:	07d3      	lsls	r3, r2, #31
   49b3e:	e7f5      	b.n	49b2c <uECC_vli_rshift1+0x6>

00049b40 <vli_modInv_update>:
{
   49b40:	b570      	push	{r4, r5, r6, lr}
	if (!EVEN(uv)) {
   49b42:	6803      	ldr	r3, [r0, #0]
   49b44:	07db      	lsls	r3, r3, #31
{
   49b46:	4605      	mov	r5, r0
   49b48:	4614      	mov	r4, r2
	if (!EVEN(uv)) {
   49b4a:	d404      	bmi.n	49b56 <vli_modInv_update+0x16>
}
   49b4c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	uECC_vli_rshift1(uv, num_words);
   49b50:	4611      	mov	r1, r2
   49b52:	f7ff bfe8 	b.w	49b26 <uECC_vli_rshift1>
		carry = uECC_vli_add(uv, uv, mod, num_words);
   49b56:	4613      	mov	r3, r2
   49b58:	460a      	mov	r2, r1
   49b5a:	4601      	mov	r1, r0
   49b5c:	f7ff ffc9 	bl	49af2 <uECC_vli_add>
	uECC_vli_rshift1(uv, num_words);
   49b60:	4621      	mov	r1, r4
		carry = uECC_vli_add(uv, uv, mod, num_words);
   49b62:	4606      	mov	r6, r0
	uECC_vli_rshift1(uv, num_words);
   49b64:	4628      	mov	r0, r5
   49b66:	f7ff ffde 	bl	49b26 <uECC_vli_rshift1>
	if (carry) {
   49b6a:	b146      	cbz	r6, 49b7e <vli_modInv_update+0x3e>
		uv[num_words - 1] |= HIGH_BIT_SET;
   49b6c:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
   49b70:	3c01      	subs	r4, #1
   49b72:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
   49b76:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   49b7a:	f845 3024 	str.w	r3, [r5, r4, lsl #2]
}
   49b7e:	bd70      	pop	{r4, r5, r6, pc}

00049b80 <uECC_vli_mult>:
	for (k = 0; k < num_words; ++k) {
   49b80:	f04f 0c00 	mov.w	ip, #0
{
   49b84:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uECC_word_t r1 = 0;
   49b88:	4665      	mov	r5, ip
	uECC_word_t r0 = 0;
   49b8a:	4664      	mov	r4, ip
	for (k = 0; k < num_words; ++k) {
   49b8c:	fa4f f98c 	sxtb.w	r9, ip
   49b90:	454b      	cmp	r3, r9
   49b92:	dc16      	bgt.n	49bc2 <uECC_vli_mult+0x42>
	for (k = num_words; k < num_words * 2 - 1; ++k) {
   49b94:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
   49b98:	eb06 0643 	add.w	r6, r6, r3, lsl #1
   49b9c:	9601      	str	r6, [sp, #4]
   49b9e:	f04f 0800 	mov.w	r8, #0
   49ba2:	9f01      	ldr	r7, [sp, #4]
   49ba4:	fa53 fe88 	uxtab	lr, r3, r8
   49ba8:	fa4f fe8e 	sxtb.w	lr, lr
   49bac:	45be      	cmp	lr, r7
   49bae:	fa5f f688 	uxtb.w	r6, r8
   49bb2:	db28      	blt.n	49c06 <uECC_vli_mult+0x86>
	result[num_words * 2 - 1] = r0;
   49bb4:	eb00 00c3 	add.w	r0, r0, r3, lsl #3
   49bb8:	f840 4c04 	str.w	r4, [r0, #-4]
}
   49bbc:	b003      	add	sp, #12
   49bbe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	for (k = 0; k < num_words; ++k) {
   49bc2:	f04f 0e00 	mov.w	lr, #0
   49bc6:	eb02 0a8c 	add.w	sl, r2, ip, lsl #2
   49bca:	46f0      	mov	r8, lr
	uECC_dword_t p = (uECC_dword_t)a * b;
   49bcc:	f851 702e 	ldr.w	r7, [r1, lr, lsl #2]
			muladd(left[i], right[k - i], &r0, &r1, &r2);
   49bd0:	f85a 6904 	ldr.w	r6, [sl], #-4
	uECC_dword_t p = (uECC_dword_t)a * b;
   49bd4:	fba6 6707 	umull	r6, r7, r6, r7
   49bd8:	1936      	adds	r6, r6, r4
		for (i = 0; i <= k; ++i) {
   49bda:	f10e 0e01 	add.w	lr, lr, #1
   49bde:	416f      	adcs	r7, r5
	*r0 = (uECC_word_t)r01;
   49be0:	4634      	mov	r4, r6
		for (i = 0; i <= k; ++i) {
   49be2:	fa4f f68e 	sxtb.w	r6, lr
   49be6:	f04f 0b00 	mov.w	fp, #0
   49bea:	bf28      	it	cs
   49bec:	f04f 0b01 	movcs.w	fp, #1
   49bf0:	454e      	cmp	r6, r9
	*r2 += (r01 < p);
   49bf2:	44d8      	add	r8, fp
	*r1 = r01 >> uECC_WORD_BITS;
   49bf4:	463d      	mov	r5, r7
		for (i = 0; i <= k; ++i) {
   49bf6:	dde9      	ble.n	49bcc <uECC_vli_mult+0x4c>
		result[k] = r0;
   49bf8:	f840 402c 	str.w	r4, [r0, ip, lsl #2]
	*r2 += (r01 < p);
   49bfc:	4645      	mov	r5, r8
   49bfe:	f10c 0c01 	add.w	ip, ip, #1
	*r1 = r01 >> uECC_WORD_BITS;
   49c02:	463c      	mov	r4, r7
   49c04:	e7c2      	b.n	49b8c <uECC_vli_mult+0xc>
		for (i = (k + 1) - num_words; i < num_words; ++i) {
   49c06:	3601      	adds	r6, #1
   49c08:	46a9      	mov	r9, r5
   49c0a:	b276      	sxtb	r6, r6
   49c0c:	eb02 0a8e 	add.w	sl, r2, lr, lsl #2
   49c10:	2500      	movs	r5, #0
   49c12:	b277      	sxtb	r7, r6
   49c14:	42bb      	cmp	r3, r7
   49c16:	dc05      	bgt.n	49c24 <uECC_vli_mult+0xa4>
		result[k] = r0;
   49c18:	f840 402e 	str.w	r4, [r0, lr, lsl #2]
	for (k = num_words; k < num_words * 2 - 1; ++k) {
   49c1c:	f108 0801 	add.w	r8, r8, #1
		result[k] = r0;
   49c20:	464c      	mov	r4, r9
   49c22:	e7be      	b.n	49ba2 <uECC_vli_mult+0x22>
			muladd(left[i], right[k - i], &r0, &r1, &r2);
   49c24:	f06f 0703 	mvn.w	r7, #3
   49c28:	4377      	muls	r7, r6
	uECC_dword_t p = (uECC_dword_t)a * b;
   49c2a:	f851 c026 	ldr.w	ip, [r1, r6, lsl #2]
   49c2e:	f85a 7007 	ldr.w	r7, [sl, r7]
   49c32:	fba7 7c0c 	umull	r7, ip, r7, ip
   49c36:	193f      	adds	r7, r7, r4
   49c38:	eb5c 0c09 	adcs.w	ip, ip, r9
   49c3c:	f04f 0b00 	mov.w	fp, #0
   49c40:	bf28      	it	cs
   49c42:	f04f 0b01 	movcs.w	fp, #1
	*r2 += (r01 < p);
   49c46:	445d      	add	r5, fp
	*r1 = r01 >> uECC_WORD_BITS;
   49c48:	46e1      	mov	r9, ip
	*r0 = (uECC_word_t)r01;
   49c4a:	463c      	mov	r4, r7
		for (i = (k + 1) - num_words; i < num_words; ++i) {
   49c4c:	3601      	adds	r6, #1
   49c4e:	e7e0      	b.n	49c12 <uECC_vli_mult+0x92>

00049c50 <uECC_vli_clear>:
	for (i = 0; i < num_words; ++i) {
   49c50:	2300      	movs	r3, #0
{
   49c52:	b510      	push	{r4, lr}
		 vli[i] = 0;
   49c54:	461c      	mov	r4, r3
	for (i = 0; i < num_words; ++i) {
   49c56:	b25a      	sxtb	r2, r3
   49c58:	4291      	cmp	r1, r2
   49c5a:	dc00      	bgt.n	49c5e <uECC_vli_clear+0xe>
}
   49c5c:	bd10      	pop	{r4, pc}
		 vli[i] = 0;
   49c5e:	f840 4023 	str.w	r4, [r0, r3, lsl #2]
	for (i = 0; i < num_words; ++i) {
   49c62:	3301      	adds	r3, #1
   49c64:	e7f7      	b.n	49c56 <uECC_vli_clear+0x6>

00049c66 <uECC_vli_isZero>:
{
   49c66:	b510      	push	{r4, lr}
	for (i = 0; i < num_words; ++i) {
   49c68:	2300      	movs	r3, #0
	uECC_word_t bits = 0;
   49c6a:	461a      	mov	r2, r3
	for (i = 0; i < num_words; ++i) {
   49c6c:	b25c      	sxtb	r4, r3
   49c6e:	42a1      	cmp	r1, r4
   49c70:	dc03      	bgt.n	49c7a <uECC_vli_isZero+0x14>
}
   49c72:	fab2 f082 	clz	r0, r2
   49c76:	0940      	lsrs	r0, r0, #5
   49c78:	bd10      	pop	{r4, pc}
		bits |= vli[i];
   49c7a:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
   49c7e:	3301      	adds	r3, #1
   49c80:	4322      	orrs	r2, r4
	for (i = 0; i < num_words; ++i) {
   49c82:	e7f3      	b.n	49c6c <uECC_vli_isZero+0x6>

00049c84 <uECC_vli_testBit>:
	return (vli[bit >> uECC_WORD_BITS_SHIFT] &
   49c84:	114a      	asrs	r2, r1, #5
		((uECC_word_t)1 << (bit & uECC_WORD_BITS_MASK)));
   49c86:	2301      	movs	r3, #1
	return (vli[bit >> uECC_WORD_BITS_SHIFT] &
   49c88:	f850 0022 	ldr.w	r0, [r0, r2, lsl #2]
		((uECC_word_t)1 << (bit & uECC_WORD_BITS_MASK)));
   49c8c:	f001 011f 	and.w	r1, r1, #31
   49c90:	408b      	lsls	r3, r1
}
   49c92:	4018      	ands	r0, r3
   49c94:	4770      	bx	lr

00049c96 <uECC_vli_numBits>:
	for (i = max_words - 1; i >= 0 && vli[i] == 0; --i) {
   49c96:	1e4b      	subs	r3, r1, #1
{
   49c98:	b510      	push	{r4, lr}
   49c9a:	b25b      	sxtb	r3, r3
	for (i = max_words - 1; i >= 0 && vli[i] == 0; --i) {
   49c9c:	1d04      	adds	r4, r0, #4
   49c9e:	061a      	lsls	r2, r3, #24
   49ca0:	d403      	bmi.n	49caa <uECC_vli_numBits+0x14>
   49ca2:	1e5a      	subs	r2, r3, #1
   49ca4:	f854 1022 	ldr.w	r1, [r4, r2, lsl #2]
   49ca8:	b171      	cbz	r1, 49cc8 <uECC_vli_numBits+0x32>
	return (i + 1);
   49caa:	3301      	adds	r3, #1
   49cac:	b25b      	sxtb	r3, r3
	if (num_digits == 0) {
   49cae:	b183      	cbz	r3, 49cd2 <uECC_vli_numBits+0x3c>
	digit = vli[num_digits - 1];
   49cb0:	f103 4280 	add.w	r2, r3, #1073741824	; 0x40000000
   49cb4:	3a01      	subs	r2, #1
   49cb6:	f850 1022 	ldr.w	r1, [r0, r2, lsl #2]
	for (i = 0; digit; ++i) {
   49cba:	2200      	movs	r2, #0
   49cbc:	b931      	cbnz	r1, 49ccc <uECC_vli_numBits+0x36>
	return (((bitcount_t)(num_digits - 1) << uECC_WORD_BITS_SHIFT) + i);
   49cbe:	3b01      	subs	r3, #1
   49cc0:	eb02 1243 	add.w	r2, r2, r3, lsl #5
   49cc4:	b210      	sxth	r0, r2
}
   49cc6:	bd10      	pop	{r4, pc}
   49cc8:	4613      	mov	r3, r2
   49cca:	e7e8      	b.n	49c9e <uECC_vli_numBits+0x8>
		digit >>= 1;
   49ccc:	0849      	lsrs	r1, r1, #1
	for (i = 0; digit; ++i) {
   49cce:	3201      	adds	r2, #1
   49cd0:	e7f4      	b.n	49cbc <uECC_vli_numBits+0x26>
		return 0;
   49cd2:	4618      	mov	r0, r3
   49cd4:	e7f7      	b.n	49cc6 <uECC_vli_numBits+0x30>

00049cd6 <uECC_vli_set>:
{
   49cd6:	b510      	push	{r4, lr}
	for (i = 0; i < num_words; ++i) {
   49cd8:	2300      	movs	r3, #0
   49cda:	b25c      	sxtb	r4, r3
   49cdc:	42a2      	cmp	r2, r4
   49cde:	dc00      	bgt.n	49ce2 <uECC_vli_set+0xc>
}
   49ce0:	bd10      	pop	{r4, pc}
		dest[i] = src[i];
   49ce2:	f851 4023 	ldr.w	r4, [r1, r3, lsl #2]
   49ce6:	f840 4023 	str.w	r4, [r0, r3, lsl #2]
	for (i = 0; i < num_words; ++i) {
   49cea:	3301      	adds	r3, #1
   49cec:	e7f5      	b.n	49cda <uECC_vli_set+0x4>

00049cee <uECC_vli_cmp_unsafe>:
{
   49cee:	b510      	push	{r4, lr}
	for (i = num_words - 1; i >= 0; --i) {
   49cf0:	3a01      	subs	r2, #1
   49cf2:	b252      	sxtb	r2, r2
   49cf4:	0613      	lsls	r3, r2, #24
   49cf6:	d501      	bpl.n	49cfc <uECC_vli_cmp_unsafe+0xe>
	return 0;
   49cf8:	2000      	movs	r0, #0
}
   49cfa:	bd10      	pop	{r4, pc}
		if (left[i] > right[i]) {
   49cfc:	f850 4022 	ldr.w	r4, [r0, r2, lsl #2]
   49d00:	f851 3022 	ldr.w	r3, [r1, r2, lsl #2]
   49d04:	429c      	cmp	r4, r3
   49d06:	d805      	bhi.n	49d14 <uECC_vli_cmp_unsafe+0x26>
		} else if (left[i] < right[i]) {
   49d08:	f102 32ff 	add.w	r2, r2, #4294967295	; 0xffffffff
   49d0c:	d2f2      	bcs.n	49cf4 <uECC_vli_cmp_unsafe+0x6>
			return -1;
   49d0e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   49d12:	e7f2      	b.n	49cfa <uECC_vli_cmp_unsafe+0xc>
			return 1;
   49d14:	2001      	movs	r0, #1
   49d16:	e7f0      	b.n	49cfa <uECC_vli_cmp_unsafe+0xc>

00049d18 <uECC_vli_equal>:
{
   49d18:	b530      	push	{r4, r5, lr}
	for (i = num_words - 1; i >= 0; --i) {
   49d1a:	3a01      	subs	r2, #1
   49d1c:	b252      	sxtb	r2, r2
	uECC_word_t diff = 0;
   49d1e:	2300      	movs	r3, #0
	for (i = num_words - 1; i >= 0; --i) {
   49d20:	0614      	lsls	r4, r2, #24
   49d22:	d503      	bpl.n	49d2c <uECC_vli_equal+0x14>
}
   49d24:	1e18      	subs	r0, r3, #0
   49d26:	bf18      	it	ne
   49d28:	2001      	movne	r0, #1
   49d2a:	bd30      	pop	{r4, r5, pc}
		diff |= (left[i] ^ right[i]);
   49d2c:	f850 4022 	ldr.w	r4, [r0, r2, lsl #2]
   49d30:	f851 5022 	ldr.w	r5, [r1, r2, lsl #2]
   49d34:	406c      	eors	r4, r5
   49d36:	4323      	orrs	r3, r4
	for (i = num_words - 1; i >= 0; --i) {
   49d38:	3a01      	subs	r2, #1
   49d3a:	e7f1      	b.n	49d20 <uECC_vli_equal+0x8>

00049d3c <uECC_vli_sub>:
{
   49d3c:	b5f0      	push	{r4, r5, r6, r7, lr}
	for (i = 0; i < num_words; ++i) {
   49d3e:	2400      	movs	r4, #0
{
   49d40:	4606      	mov	r6, r0
   49d42:	469c      	mov	ip, r3
	uECC_word_t borrow = 0;
   49d44:	4620      	mov	r0, r4
	for (i = 0; i < num_words; ++i) {
   49d46:	b265      	sxtb	r5, r4
   49d48:	4565      	cmp	r5, ip
   49d4a:	db00      	blt.n	49d4e <uECC_vli_sub+0x12>
}
   49d4c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		uECC_word_t diff = left[i] - right[i] - borrow;
   49d4e:	f851 7024 	ldr.w	r7, [r1, r4, lsl #2]
   49d52:	f852 3024 	ldr.w	r3, [r2, r4, lsl #2]
   49d56:	1a3d      	subs	r5, r7, r0
   49d58:	1aed      	subs	r5, r5, r3
	return (p_true*(cond)) | (p_false*(!cond));
   49d5a:	42af      	cmp	r7, r5
   49d5c:	f000 0001 	and.w	r0, r0, #1
   49d60:	bf18      	it	ne
   49d62:	2000      	movne	r0, #0
		result[i] = diff;
   49d64:	f846 5024 	str.w	r5, [r6, r4, lsl #2]
	return (p_true*(cond)) | (p_false*(!cond));
   49d68:	bf38      	it	cc
   49d6a:	f040 0001 	orrcc.w	r0, r0, #1
	for (i = 0; i < num_words; ++i) {
   49d6e:	3401      	adds	r4, #1
   49d70:	e7e9      	b.n	49d46 <uECC_vli_sub+0xa>

00049d72 <uECC_vli_modAdd>:
{
   49d72:	b570      	push	{r4, r5, r6, lr}
   49d74:	f99d 6010 	ldrsb.w	r6, [sp, #16]
   49d78:	461d      	mov	r5, r3
	uECC_word_t carry = uECC_vli_add(result, left, right, num_words);
   49d7a:	4633      	mov	r3, r6
{
   49d7c:	4604      	mov	r4, r0
	uECC_word_t carry = uECC_vli_add(result, left, right, num_words);
   49d7e:	f7ff feb8 	bl	49af2 <uECC_vli_add>
	if (carry || uECC_vli_cmp_unsafe(mod, result, num_words) != 1) {
   49d82:	b930      	cbnz	r0, 49d92 <uECC_vli_modAdd+0x20>
   49d84:	4632      	mov	r2, r6
   49d86:	4621      	mov	r1, r4
   49d88:	4628      	mov	r0, r5
   49d8a:	f7ff ffb0 	bl	49cee <uECC_vli_cmp_unsafe>
   49d8e:	2801      	cmp	r0, #1
   49d90:	d007      	beq.n	49da2 <uECC_vli_modAdd+0x30>
		uECC_vli_sub(result, result, mod, num_words);
   49d92:	4633      	mov	r3, r6
   49d94:	462a      	mov	r2, r5
   49d96:	4621      	mov	r1, r4
   49d98:	4620      	mov	r0, r4
}
   49d9a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		uECC_vli_sub(result, result, mod, num_words);
   49d9e:	f7ff bfcd 	b.w	49d3c <uECC_vli_sub>
}
   49da2:	bd70      	pop	{r4, r5, r6, pc}

00049da4 <uECC_vli_modSub>:
{
   49da4:	b570      	push	{r4, r5, r6, lr}
   49da6:	f99d 6010 	ldrsb.w	r6, [sp, #16]
   49daa:	461d      	mov	r5, r3
	uECC_word_t l_borrow = uECC_vli_sub(result, left, right, num_words);
   49dac:	4633      	mov	r3, r6
{
   49dae:	4604      	mov	r4, r0
	uECC_word_t l_borrow = uECC_vli_sub(result, left, right, num_words);
   49db0:	f7ff ffc4 	bl	49d3c <uECC_vli_sub>
	if (l_borrow) {
   49db4:	b138      	cbz	r0, 49dc6 <uECC_vli_modSub+0x22>
		uECC_vli_add(result, result, mod, num_words);
   49db6:	4633      	mov	r3, r6
   49db8:	462a      	mov	r2, r5
   49dba:	4621      	mov	r1, r4
   49dbc:	4620      	mov	r0, r4
}
   49dbe:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		uECC_vli_add(result, result, mod, num_words);
   49dc2:	f7ff be96 	b.w	49af2 <uECC_vli_add>
}
   49dc6:	bd70      	pop	{r4, r5, r6, pc}

00049dc8 <uECC_vli_mmod>:
{
   49dc8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   49dcc:	b0a5      	sub	sp, #148	; 0x94
   49dce:	461d      	mov	r5, r3
	uECC_word_t *v[2] = {tmp, product};
   49dd0:	ab14      	add	r3, sp, #80	; 0x50
   49dd2:	e9cd 3102 	strd	r3, r1, [sp, #8]
{
   49dd6:	9001      	str	r0, [sp, #4]
			   uECC_vli_numBits(mod, num_words);
   49dd8:	4629      	mov	r1, r5
   49dda:	4610      	mov	r0, r2
{
   49ddc:	4617      	mov	r7, r2
			   uECC_vli_numBits(mod, num_words);
   49dde:	f7ff ff5a 	bl	49c96 <uECC_vli_numBits>
	bitcount_t shift = (num_words * 2 * uECC_WORD_BITS) -
   49de2:	ebc0 1485 	rsb	r4, r0, r5, lsl #6
   49de6:	b224      	sxth	r4, r4
	wordcount_t word_shift = shift / uECC_WORD_BITS;
   49de8:	2c00      	cmp	r4, #0
   49dea:	4621      	mov	r1, r4
   49dec:	bfb8      	it	lt
   49dee:	f104 011f 	addlt.w	r1, r4, #31
	wordcount_t bit_shift = shift % uECC_WORD_BITS;
   49df2:	4263      	negs	r3, r4
   49df4:	f003 031f 	and.w	r3, r3, #31
	wordcount_t word_shift = shift / uECC_WORD_BITS;
   49df8:	f341 1147 	sbfx	r1, r1, #5, #8
	wordcount_t bit_shift = shift % uECC_WORD_BITS;
   49dfc:	f004 061f 	and.w	r6, r4, #31
	uECC_vli_clear(mod_multiple, word_shift);
   49e00:	a804      	add	r0, sp, #16
	wordcount_t bit_shift = shift % uECC_WORD_BITS;
   49e02:	bf58      	it	pl
   49e04:	425e      	negpl	r6, r3
	uECC_vli_clear(mod_multiple, word_shift);
   49e06:	f7ff ff23 	bl	49c50 <uECC_vli_clear>
	if (bit_shift > 0) {
   49e0a:	2e00      	cmp	r6, #0
   49e0c:	ea4f 0081 	mov.w	r0, r1, lsl #2
   49e10:	dd2d      	ble.n	49e6e <uECC_vli_mmod+0xa6>
   49e12:	ab04      	add	r3, sp, #16
	uECC_word_t carry = 0;
   49e14:	2200      	movs	r2, #0
   49e16:	4418      	add	r0, r3
			carry = mod[index] >> (uECC_WORD_BITS - bit_shift);
   49e18:	f1c6 0e20 	rsb	lr, r6, #32
		for(index = 0; index < (uECC_word_t)num_words; ++index) {
   49e1c:	4613      	mov	r3, r2
   49e1e:	429d      	cmp	r5, r3
   49e20:	d81a      	bhi.n	49e58 <uECC_vli_mmod+0x90>
		uECC_vli_rshift1(mod_multiple + num_words, num_words);
   49e22:	ab04      	add	r3, sp, #16
   49e24:	eb03 0385 	add.w	r3, r3, r5, lsl #2
   49e28:	9300      	str	r3, [sp, #0]
		mod_multiple[num_words - 1] |= mod_multiple[num_words] <<
   49e2a:	1e6f      	subs	r7, r5, #1
   49e2c:	ab24      	add	r3, sp, #144	; 0x90
		for (i = 0; i < num_words * 2; ++i) {
   49e2e:	ea4f 0845 	mov.w	r8, r5, lsl #1
		uECC_vli_rshift1(mod_multiple + num_words, num_words);
   49e32:	ea4f 0985 	mov.w	r9, r5, lsl #2
   49e36:	2601      	movs	r6, #1
		mod_multiple[num_words - 1] |= mod_multiple[num_words] <<
   49e38:	eb03 0787 	add.w	r7, r3, r7, lsl #2
	for (index = 1; shift >= 0; --shift) {
   49e3c:	2c00      	cmp	r4, #0
   49e3e:	da53      	bge.n	49ee8 <uECC_vli_mmod+0x120>
	uECC_vli_set(result, v[index], num_words);
   49e40:	ab24      	add	r3, sp, #144	; 0x90
   49e42:	eb03 0686 	add.w	r6, r3, r6, lsl #2
   49e46:	9801      	ldr	r0, [sp, #4]
   49e48:	f856 1c88 	ldr.w	r1, [r6, #-136]
   49e4c:	462a      	mov	r2, r5
   49e4e:	f7ff ff42 	bl	49cd6 <uECC_vli_set>
}
   49e52:	b025      	add	sp, #148	; 0x94
   49e54:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			mod_multiple[word_shift + index] = (mod[index] << bit_shift) | carry;
   49e58:	f857 c023 	ldr.w	ip, [r7, r3, lsl #2]
   49e5c:	fa0c f106 	lsl.w	r1, ip, r6
   49e60:	430a      	orrs	r2, r1
   49e62:	f840 2b04 	str.w	r2, [r0], #4
		for(index = 0; index < (uECC_word_t)num_words; ++index) {
   49e66:	3301      	adds	r3, #1
			carry = mod[index] >> (uECC_WORD_BITS - bit_shift);
   49e68:	fa2c f20e 	lsr.w	r2, ip, lr
		for(index = 0; index < (uECC_word_t)num_words; ++index) {
   49e6c:	e7d7      	b.n	49e1e <uECC_vli_mmod+0x56>
		uECC_vli_set(mod_multiple + word_shift, mod, num_words);
   49e6e:	ab04      	add	r3, sp, #16
   49e70:	462a      	mov	r2, r5
   49e72:	4639      	mov	r1, r7
   49e74:	4418      	add	r0, r3
   49e76:	f7ff ff2e 	bl	49cd6 <uECC_vli_set>
   49e7a:	e7d2      	b.n	49e22 <uECC_vli_mmod+0x5a>
			uECC_word_t diff = v[index][i] - mod_multiple[i] - borrow;
   49e7c:	f85a 3c88 	ldr.w	r3, [sl, #-136]
   49e80:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
   49e84:	ab24      	add	r3, sp, #144	; 0x90
   49e86:	eb03 0380 	add.w	r3, r3, r0, lsl #2
   49e8a:	f10c 0c01 	add.w	ip, ip, #1
   49e8e:	f853 3c80 	ldr.w	r3, [r3, #-128]
   49e92:	440b      	add	r3, r1
   49e94:	1ad3      	subs	r3, r2, r3
   49e96:	bf34      	ite	cc
   49e98:	f04f 0b01 	movcc.w	fp, #1
   49e9c:	f04f 0b00 	movcs.w	fp, #0
			if (diff != v[index][i]) {
   49ea0:	429a      	cmp	r2, r3
			v[1 - index][i] = diff;
   49ea2:	f85e 2c88 	ldr.w	r2, [lr, #-136]
   49ea6:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
				borrow = (diff > v[index][i]);
   49eaa:	bf18      	it	ne
   49eac:	4659      	movne	r1, fp
		for (i = 0; i < num_words * 2; ++i) {
   49eae:	fa4f f08c 	sxtb.w	r0, ip
   49eb2:	4540      	cmp	r0, r8
   49eb4:	dbe2      	blt.n	49e7c <uECC_vli_mmod+0xb4>
		index = !(index ^ borrow);
   49eb6:	1a73      	subs	r3, r6, r1
   49eb8:	425e      	negs	r6, r3
		uECC_vli_rshift1(mod_multiple, num_words);
   49eba:	4629      	mov	r1, r5
   49ebc:	a804      	add	r0, sp, #16
		index = !(index ^ borrow);
   49ebe:	415e      	adcs	r6, r3
		uECC_vli_rshift1(mod_multiple, num_words);
   49ec0:	f7ff fe31 	bl	49b26 <uECC_vli_rshift1>
		mod_multiple[num_words - 1] |= mod_multiple[num_words] <<
   49ec4:	f109 0390 	add.w	r3, r9, #144	; 0x90
   49ec8:	446b      	add	r3, sp
		uECC_vli_rshift1(mod_multiple + num_words, num_words);
   49eca:	9800      	ldr	r0, [sp, #0]
		mod_multiple[num_words - 1] |= mod_multiple[num_words] <<
   49ecc:	f853 2c80 	ldr.w	r2, [r3, #-128]
   49ed0:	f857 3c80 	ldr.w	r3, [r7, #-128]
   49ed4:	ea43 73c2 	orr.w	r3, r3, r2, lsl #31
   49ed8:	f847 3c80 	str.w	r3, [r7, #-128]
		uECC_vli_rshift1(mod_multiple + num_words, num_words);
   49edc:	4629      	mov	r1, r5
   49ede:	3c01      	subs	r4, #1
   49ee0:	f7ff fe21 	bl	49b26 <uECC_vli_rshift1>
	for (index = 1; shift >= 0; --shift) {
   49ee4:	b224      	sxth	r4, r4
   49ee6:	e7a9      	b.n	49e3c <uECC_vli_mmod+0x74>
			uECC_word_t diff = v[index][i] - mod_multiple[i] - borrow;
   49ee8:	ab24      	add	r3, sp, #144	; 0x90
   49eea:	f04f 0c00 	mov.w	ip, #0
			v[1 - index][i] = diff;
   49eee:	f1c6 0e01 	rsb	lr, r6, #1
		uECC_word_t borrow = 0;
   49ef2:	4661      	mov	r1, ip
			uECC_word_t diff = v[index][i] - mod_multiple[i] - borrow;
   49ef4:	eb03 0a86 	add.w	sl, r3, r6, lsl #2
			v[1 - index][i] = diff;
   49ef8:	eb03 0e8e 	add.w	lr, r3, lr, lsl #2
   49efc:	e7d7      	b.n	49eae <uECC_vli_mmod+0xe6>

00049efe <uECC_vli_modMult_fast>:
{
   49efe:	b530      	push	{r4, r5, lr}
   49f00:	461c      	mov	r4, r3
   49f02:	b091      	sub	sp, #68	; 0x44
   49f04:	4605      	mov	r5, r0
	uECC_vli_mult(product, left, right, curve->num_words);
   49f06:	f993 3000 	ldrsb.w	r3, [r3]
   49f0a:	4668      	mov	r0, sp
   49f0c:	f7ff fe38 	bl	49b80 <uECC_vli_mult>
	curve->mmod_fast(result, product);
   49f10:	f8d4 30ac 	ldr.w	r3, [r4, #172]	; 0xac
   49f14:	4669      	mov	r1, sp
   49f16:	4628      	mov	r0, r5
   49f18:	4798      	blx	r3
}
   49f1a:	b011      	add	sp, #68	; 0x44
   49f1c:	bd30      	pop	{r4, r5, pc}

00049f1e <uECC_vli_modSquare_fast>:
{
   49f1e:	4613      	mov	r3, r2
	uECC_vli_modMult_fast(result, left, left, curve);
   49f20:	460a      	mov	r2, r1
   49f22:	f7ff bfec 	b.w	49efe <uECC_vli_modMult_fast>

00049f26 <double_jacobian_default>:
{
   49f26:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	wordcount_t num_words = curve->num_words;
   49f2a:	f993 6000 	ldrsb.w	r6, [r3]
{
   49f2e:	b092      	sub	sp, #72	; 0x48
   49f30:	4604      	mov	r4, r0
   49f32:	4689      	mov	r9, r1
	if (uECC_vli_isZero(Z1, num_words)) {
   49f34:	4610      	mov	r0, r2
   49f36:	4631      	mov	r1, r6
{
   49f38:	4615      	mov	r5, r2
   49f3a:	461f      	mov	r7, r3
	if (uECC_vli_isZero(Z1, num_words)) {
   49f3c:	f7ff fe93 	bl	49c66 <uECC_vli_isZero>
   49f40:	2800      	cmp	r0, #0
   49f42:	f040 8091 	bne.w	4a068 <double_jacobian_default+0x142>
	uECC_vli_modSquare_fast(t4, Y1, curve);   /* t4 = y1^2 */
   49f46:	463a      	mov	r2, r7
   49f48:	4649      	mov	r1, r9
   49f4a:	a802      	add	r0, sp, #8
   49f4c:	f7ff ffe7 	bl	49f1e <uECC_vli_modSquare_fast>
	uECC_vli_modMult_fast(t5, X1, t4, curve); /* t5 = x1*y1^2 = A */
   49f50:	463b      	mov	r3, r7
   49f52:	aa02      	add	r2, sp, #8
   49f54:	4621      	mov	r1, r4
   49f56:	a80a      	add	r0, sp, #40	; 0x28
   49f58:	f7ff ffd1 	bl	49efe <uECC_vli_modMult_fast>
	uECC_vli_modSquare_fast(t4, t4, curve);   /* t4 = y1^4 */
   49f5c:	a902      	add	r1, sp, #8
   49f5e:	4608      	mov	r0, r1
   49f60:	463a      	mov	r2, r7
   49f62:	f7ff ffdc 	bl	49f1e <uECC_vli_modSquare_fast>
	uECC_vli_modMult_fast(Y1, Y1, Z1, curve); /* t2 = y1*z1 = z3 */
   49f66:	463b      	mov	r3, r7
   49f68:	462a      	mov	r2, r5
   49f6a:	4649      	mov	r1, r9
   49f6c:	4648      	mov	r0, r9
   49f6e:	f7ff ffc6 	bl	49efe <uECC_vli_modMult_fast>
	uECC_vli_modAdd(X1, X1, Z1, curve->p, num_words); /* t1 = x1 + z1^2 */
   49f72:	f107 0804 	add.w	r8, r7, #4
	uECC_vli_modSquare_fast(Z1, Z1, curve);   /* t3 = z1^2 */
   49f76:	463a      	mov	r2, r7
   49f78:	4629      	mov	r1, r5
   49f7a:	4628      	mov	r0, r5
   49f7c:	f7ff ffcf 	bl	49f1e <uECC_vli_modSquare_fast>
	uECC_vli_modAdd(X1, X1, Z1, curve->p, num_words); /* t1 = x1 + z1^2 */
   49f80:	4643      	mov	r3, r8
   49f82:	462a      	mov	r2, r5
   49f84:	4621      	mov	r1, r4
   49f86:	4620      	mov	r0, r4
   49f88:	9600      	str	r6, [sp, #0]
   49f8a:	f7ff fef2 	bl	49d72 <uECC_vli_modAdd>
	uECC_vli_modAdd(Z1, Z1, Z1, curve->p, num_words); /* t3 = 2*z1^2 */
   49f8e:	4643      	mov	r3, r8
   49f90:	462a      	mov	r2, r5
   49f92:	4629      	mov	r1, r5
   49f94:	4628      	mov	r0, r5
   49f96:	9600      	str	r6, [sp, #0]
   49f98:	f7ff feeb 	bl	49d72 <uECC_vli_modAdd>
	uECC_vli_modSub(Z1, X1, Z1, curve->p, num_words); /* t3 = x1 - z1^2 */
   49f9c:	4643      	mov	r3, r8
   49f9e:	462a      	mov	r2, r5
   49fa0:	4621      	mov	r1, r4
   49fa2:	4628      	mov	r0, r5
   49fa4:	9600      	str	r6, [sp, #0]
   49fa6:	f7ff fefd 	bl	49da4 <uECC_vli_modSub>
	uECC_vli_modMult_fast(X1, X1, Z1, curve); /* t1 = x1^2 - z1^4 */
   49faa:	463b      	mov	r3, r7
   49fac:	462a      	mov	r2, r5
   49fae:	4621      	mov	r1, r4
   49fb0:	4620      	mov	r0, r4
   49fb2:	f7ff ffa4 	bl	49efe <uECC_vli_modMult_fast>
	uECC_vli_modAdd(Z1, X1, X1, curve->p, num_words); /* t3 = 2*(x1^2 - z1^4) */
   49fb6:	4643      	mov	r3, r8
   49fb8:	4622      	mov	r2, r4
   49fba:	4621      	mov	r1, r4
   49fbc:	4628      	mov	r0, r5
   49fbe:	9600      	str	r6, [sp, #0]
   49fc0:	f7ff fed7 	bl	49d72 <uECC_vli_modAdd>
	uECC_vli_modAdd(X1, X1, Z1, curve->p, num_words); /* t1 = 3*(x1^2 - z1^4) */
   49fc4:	4643      	mov	r3, r8
   49fc6:	9600      	str	r6, [sp, #0]
   49fc8:	462a      	mov	r2, r5
   49fca:	4621      	mov	r1, r4
   49fcc:	4620      	mov	r0, r4
   49fce:	f7ff fed0 	bl	49d72 <uECC_vli_modAdd>
	return (vli[bit >> uECC_WORD_BITS_SHIFT] &
   49fd2:	6823      	ldr	r3, [r4, #0]
	if (uECC_vli_testBit(X1, 0)) {
   49fd4:	07db      	lsls	r3, r3, #31
   49fd6:	d54a      	bpl.n	4a06e <double_jacobian_default+0x148>
		uECC_word_t l_carry = uECC_vli_add(X1, X1, curve->p, num_words);
   49fd8:	4633      	mov	r3, r6
   49fda:	4642      	mov	r2, r8
   49fdc:	4621      	mov	r1, r4
   49fde:	4620      	mov	r0, r4
   49fe0:	f7ff fd87 	bl	49af2 <uECC_vli_add>
		uECC_vli_rshift1(X1, num_words);
   49fe4:	4631      	mov	r1, r6
		uECC_word_t l_carry = uECC_vli_add(X1, X1, curve->p, num_words);
   49fe6:	4682      	mov	sl, r0
		uECC_vli_rshift1(X1, num_words);
   49fe8:	4620      	mov	r0, r4
   49fea:	f7ff fd9c 	bl	49b26 <uECC_vli_rshift1>
		X1[num_words - 1] |= l_carry << (uECC_WORD_BITS - 1);
   49fee:	f106 4380 	add.w	r3, r6, #1073741824	; 0x40000000
   49ff2:	3b01      	subs	r3, #1
   49ff4:	f854 2023 	ldr.w	r2, [r4, r3, lsl #2]
   49ff8:	ea42 72ca 	orr.w	r2, r2, sl, lsl #31
   49ffc:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
	uECC_vli_modSquare_fast(Z1, X1, curve); /* t3 = B^2 */
   4a000:	463a      	mov	r2, r7
   4a002:	4621      	mov	r1, r4
   4a004:	4628      	mov	r0, r5
   4a006:	f7ff ff8a 	bl	49f1e <uECC_vli_modSquare_fast>
	uECC_vli_modSub(Z1, Z1, t5, curve->p, num_words); /* t3 = B^2 - A */
   4a00a:	4643      	mov	r3, r8
   4a00c:	aa0a      	add	r2, sp, #40	; 0x28
   4a00e:	4629      	mov	r1, r5
   4a010:	4628      	mov	r0, r5
   4a012:	9600      	str	r6, [sp, #0]
   4a014:	f7ff fec6 	bl	49da4 <uECC_vli_modSub>
	uECC_vli_modSub(Z1, Z1, t5, curve->p, num_words); /* t3 = B^2 - 2A = x3 */
   4a018:	4643      	mov	r3, r8
   4a01a:	aa0a      	add	r2, sp, #40	; 0x28
   4a01c:	4629      	mov	r1, r5
   4a01e:	4628      	mov	r0, r5
   4a020:	9600      	str	r6, [sp, #0]
   4a022:	f7ff febf 	bl	49da4 <uECC_vli_modSub>
	uECC_vli_modSub(t5, t5, Z1, curve->p, num_words); /* t5 = A - x3 */
   4a026:	a90a      	add	r1, sp, #40	; 0x28
   4a028:	4608      	mov	r0, r1
   4a02a:	4643      	mov	r3, r8
   4a02c:	462a      	mov	r2, r5
   4a02e:	9600      	str	r6, [sp, #0]
   4a030:	f7ff feb8 	bl	49da4 <uECC_vli_modSub>
	uECC_vli_modMult_fast(X1, X1, t5, curve); /* t1 = B * (A - x3) */
   4a034:	463b      	mov	r3, r7
   4a036:	aa0a      	add	r2, sp, #40	; 0x28
   4a038:	4621      	mov	r1, r4
   4a03a:	4620      	mov	r0, r4
   4a03c:	f7ff ff5f 	bl	49efe <uECC_vli_modMult_fast>
	uECC_vli_modSub(t4, X1, t4, curve->p, num_words);
   4a040:	aa02      	add	r2, sp, #8
   4a042:	4643      	mov	r3, r8
   4a044:	4610      	mov	r0, r2
   4a046:	4621      	mov	r1, r4
   4a048:	9600      	str	r6, [sp, #0]
   4a04a:	f7ff feab 	bl	49da4 <uECC_vli_modSub>
	uECC_vli_set(X1, Z1, num_words);
   4a04e:	4632      	mov	r2, r6
   4a050:	4629      	mov	r1, r5
   4a052:	4620      	mov	r0, r4
   4a054:	f7ff fe3f 	bl	49cd6 <uECC_vli_set>
	uECC_vli_set(Z1, Y1, num_words);
   4a058:	4649      	mov	r1, r9
   4a05a:	4628      	mov	r0, r5
   4a05c:	f7ff fe3b 	bl	49cd6 <uECC_vli_set>
	uECC_vli_set(Y1, t4, num_words);
   4a060:	a902      	add	r1, sp, #8
   4a062:	4648      	mov	r0, r9
   4a064:	f7ff fe37 	bl	49cd6 <uECC_vli_set>
}
   4a068:	b012      	add	sp, #72	; 0x48
   4a06a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		uECC_vli_rshift1(X1, num_words);
   4a06e:	4631      	mov	r1, r6
   4a070:	4620      	mov	r0, r4
   4a072:	f7ff fd58 	bl	49b26 <uECC_vli_rshift1>
   4a076:	e7c3      	b.n	4a000 <double_jacobian_default+0xda>

0004a078 <x_side_default>:
{
   4a078:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4a07c:	4615      	mov	r5, r2
   4a07e:	b08a      	sub	sp, #40	; 0x28
   4a080:	4604      	mov	r4, r0
   4a082:	460e      	mov	r6, r1
	uECC_word_t _3[NUM_ECC_WORDS] = {3}; /* -a = 3 */
   4a084:	221c      	movs	r2, #28
   4a086:	2100      	movs	r1, #0
   4a088:	a803      	add	r0, sp, #12
   4a08a:	f000 ff01 	bl	4ae90 <memset>
	uECC_vli_modSub(result, result, _3, curve->p, num_words); /* r = x^2 - 3 */
   4a08e:	1d2f      	adds	r7, r5, #4
	wordcount_t num_words = curve->num_words;
   4a090:	f995 8000 	ldrsb.w	r8, [r5]
	uECC_word_t _3[NUM_ECC_WORDS] = {3}; /* -a = 3 */
   4a094:	2303      	movs	r3, #3
	uECC_vli_modSquare_fast(result, x, curve); /* r = x^2 */
   4a096:	462a      	mov	r2, r5
   4a098:	4631      	mov	r1, r6
   4a09a:	4620      	mov	r0, r4
	uECC_word_t _3[NUM_ECC_WORDS] = {3}; /* -a = 3 */
   4a09c:	9302      	str	r3, [sp, #8]
	uECC_vli_modSquare_fast(result, x, curve); /* r = x^2 */
   4a09e:	f7ff ff3e 	bl	49f1e <uECC_vli_modSquare_fast>
	uECC_vli_modSub(result, result, _3, curve->p, num_words); /* r = x^2 - 3 */
   4a0a2:	463b      	mov	r3, r7
   4a0a4:	aa02      	add	r2, sp, #8
   4a0a6:	4621      	mov	r1, r4
   4a0a8:	4620      	mov	r0, r4
   4a0aa:	f8cd 8000 	str.w	r8, [sp]
   4a0ae:	f7ff fe79 	bl	49da4 <uECC_vli_modSub>
	uECC_vli_modMult_fast(result, result, x, curve); /* r = x^3 - 3x */
   4a0b2:	462b      	mov	r3, r5
   4a0b4:	4632      	mov	r2, r6
   4a0b6:	4621      	mov	r1, r4
   4a0b8:	4620      	mov	r0, r4
   4a0ba:	f7ff ff20 	bl	49efe <uECC_vli_modMult_fast>
	uECC_vli_modAdd(result, result, curve->b, curve->p, num_words);
   4a0be:	f8cd 8000 	str.w	r8, [sp]
   4a0c2:	463b      	mov	r3, r7
   4a0c4:	f105 0284 	add.w	r2, r5, #132	; 0x84
   4a0c8:	4621      	mov	r1, r4
   4a0ca:	4620      	mov	r0, r4
   4a0cc:	f7ff fe51 	bl	49d72 <uECC_vli_modAdd>
}
   4a0d0:	b00a      	add	sp, #40	; 0x28
   4a0d2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0004a0d6 <XYcZ_addC>:
   or P => P - Q, Q => P + Q
 */
static void XYcZ_addC(uECC_word_t * X1, uECC_word_t * Y1,
		      uECC_word_t * X2, uECC_word_t * Y2,
		      uECC_Curve curve)
{
   4a0d6:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   4a0da:	b09a      	sub	sp, #104	; 0x68
   4a0dc:	4616      	mov	r6, r2
   4a0de:	f8dd 8088 	ldr.w	r8, [sp, #136]	; 0x88
	/* t1 = X1, t2 = Y1, t3 = X2, t4 = Y2 */
	uECC_word_t t5[NUM_ECC_WORDS];
	uECC_word_t t6[NUM_ECC_WORDS];
	uECC_word_t t7[NUM_ECC_WORDS];
	wordcount_t num_words = curve->num_words;
   4a0e2:	4644      	mov	r4, r8
{
   4a0e4:	4699      	mov	r9, r3
	wordcount_t num_words = curve->num_words;
   4a0e6:	f914 5b04 	ldrsb.w	r5, [r4], #4

	uECC_vli_modSub(t5, X2, X1, curve->p, num_words); /* t5 = x2 - x1 */
   4a0ea:	9500      	str	r5, [sp, #0]
{
   4a0ec:	4607      	mov	r7, r0
   4a0ee:	468a      	mov	sl, r1
	uECC_vli_modSub(t5, X2, X1, curve->p, num_words); /* t5 = x2 - x1 */
   4a0f0:	4623      	mov	r3, r4
   4a0f2:	4602      	mov	r2, r0
   4a0f4:	4631      	mov	r1, r6
   4a0f6:	a802      	add	r0, sp, #8
   4a0f8:	f7ff fe54 	bl	49da4 <uECC_vli_modSub>
	uECC_vli_modSquare_fast(t5, t5, curve); /* t5 = (x2 - x1)^2 = A */
   4a0fc:	a902      	add	r1, sp, #8
   4a0fe:	4642      	mov	r2, r8
   4a100:	4608      	mov	r0, r1
   4a102:	f7ff ff0c 	bl	49f1e <uECC_vli_modSquare_fast>
	uECC_vli_modMult_fast(X1, X1, t5, curve); /* t1 = x1*A = B */
   4a106:	4643      	mov	r3, r8
   4a108:	aa02      	add	r2, sp, #8
   4a10a:	4639      	mov	r1, r7
   4a10c:	4638      	mov	r0, r7
   4a10e:	f7ff fef6 	bl	49efe <uECC_vli_modMult_fast>
	uECC_vli_modMult_fast(X2, X2, t5, curve); /* t3 = x2*A = C */
   4a112:	4643      	mov	r3, r8
   4a114:	aa02      	add	r2, sp, #8
   4a116:	4631      	mov	r1, r6
   4a118:	4630      	mov	r0, r6
   4a11a:	f7ff fef0 	bl	49efe <uECC_vli_modMult_fast>
	uECC_vli_modAdd(t5, Y2, Y1, curve->p, num_words); /* t5 = y2 + y1 */
   4a11e:	4623      	mov	r3, r4
   4a120:	4652      	mov	r2, sl
   4a122:	4649      	mov	r1, r9
   4a124:	a802      	add	r0, sp, #8
   4a126:	9500      	str	r5, [sp, #0]
   4a128:	f7ff fe23 	bl	49d72 <uECC_vli_modAdd>
	uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words); /* t4 = y2 - y1 */
   4a12c:	4623      	mov	r3, r4
   4a12e:	4652      	mov	r2, sl
   4a130:	4649      	mov	r1, r9
   4a132:	4648      	mov	r0, r9
   4a134:	9500      	str	r5, [sp, #0]
   4a136:	f7ff fe35 	bl	49da4 <uECC_vli_modSub>

	uECC_vli_modSub(t6, X2, X1, curve->p, num_words); /* t6 = C - B */
   4a13a:	4623      	mov	r3, r4
   4a13c:	463a      	mov	r2, r7
   4a13e:	4631      	mov	r1, r6
   4a140:	a80a      	add	r0, sp, #40	; 0x28
   4a142:	9500      	str	r5, [sp, #0]
   4a144:	f7ff fe2e 	bl	49da4 <uECC_vli_modSub>
	uECC_vli_modMult_fast(Y1, Y1, t6, curve); /* t2 = y1 * (C - B) = E */
   4a148:	4643      	mov	r3, r8
   4a14a:	aa0a      	add	r2, sp, #40	; 0x28
   4a14c:	4651      	mov	r1, sl
   4a14e:	4650      	mov	r0, sl
   4a150:	f7ff fed5 	bl	49efe <uECC_vli_modMult_fast>
	uECC_vli_modAdd(t6, X1, X2, curve->p, num_words); /* t6 = B + C */
   4a154:	4623      	mov	r3, r4
   4a156:	4632      	mov	r2, r6
   4a158:	4639      	mov	r1, r7
   4a15a:	a80a      	add	r0, sp, #40	; 0x28
   4a15c:	9500      	str	r5, [sp, #0]
   4a15e:	f7ff fe08 	bl	49d72 <uECC_vli_modAdd>
	uECC_vli_modSquare_fast(X2, Y2, curve); /* t3 = (y2 - y1)^2 = D */
   4a162:	4642      	mov	r2, r8
   4a164:	4649      	mov	r1, r9
   4a166:	4630      	mov	r0, r6
   4a168:	f7ff fed9 	bl	49f1e <uECC_vli_modSquare_fast>
	uECC_vli_modSub(X2, X2, t6, curve->p, num_words); /* t3 = D - (B + C) = x3 */
   4a16c:	4623      	mov	r3, r4
   4a16e:	aa0a      	add	r2, sp, #40	; 0x28
   4a170:	4631      	mov	r1, r6
   4a172:	4630      	mov	r0, r6
   4a174:	9500      	str	r5, [sp, #0]
   4a176:	f7ff fe15 	bl	49da4 <uECC_vli_modSub>

	uECC_vli_modSub(t7, X1, X2, curve->p, num_words); /* t7 = B - x3 */
   4a17a:	4623      	mov	r3, r4
   4a17c:	4632      	mov	r2, r6
   4a17e:	4639      	mov	r1, r7
   4a180:	a812      	add	r0, sp, #72	; 0x48
   4a182:	9500      	str	r5, [sp, #0]
   4a184:	f7ff fe0e 	bl	49da4 <uECC_vli_modSub>
	uECC_vli_modMult_fast(Y2, Y2, t7, curve); /* t4 = (y2 - y1)*(B - x3) */
   4a188:	4643      	mov	r3, r8
   4a18a:	aa12      	add	r2, sp, #72	; 0x48
   4a18c:	4649      	mov	r1, r9
   4a18e:	4648      	mov	r0, r9
   4a190:	f7ff feb5 	bl	49efe <uECC_vli_modMult_fast>
	/* t4 = (y2 - y1)*(B - x3) - E = y3: */
	uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words);
   4a194:	4623      	mov	r3, r4
   4a196:	4652      	mov	r2, sl
   4a198:	4649      	mov	r1, r9
   4a19a:	4648      	mov	r0, r9
   4a19c:	9500      	str	r5, [sp, #0]
   4a19e:	f7ff fe01 	bl	49da4 <uECC_vli_modSub>

	uECC_vli_modSquare_fast(t7, t5, curve); /* t7 = (y2 + y1)^2 = F */
   4a1a2:	4642      	mov	r2, r8
   4a1a4:	a902      	add	r1, sp, #8
   4a1a6:	a812      	add	r0, sp, #72	; 0x48
   4a1a8:	f7ff feb9 	bl	49f1e <uECC_vli_modSquare_fast>
	uECC_vli_modSub(t7, t7, t6, curve->p, num_words); /* t7 = F - (B + C) = x3' */
   4a1ac:	a912      	add	r1, sp, #72	; 0x48
   4a1ae:	4623      	mov	r3, r4
   4a1b0:	aa0a      	add	r2, sp, #40	; 0x28
   4a1b2:	4608      	mov	r0, r1
   4a1b4:	9500      	str	r5, [sp, #0]
   4a1b6:	f7ff fdf5 	bl	49da4 <uECC_vli_modSub>
	uECC_vli_modSub(t6, t7, X1, curve->p, num_words); /* t6 = x3' - B */
   4a1ba:	4623      	mov	r3, r4
   4a1bc:	463a      	mov	r2, r7
   4a1be:	a912      	add	r1, sp, #72	; 0x48
   4a1c0:	a80a      	add	r0, sp, #40	; 0x28
   4a1c2:	9500      	str	r5, [sp, #0]
   4a1c4:	f7ff fdee 	bl	49da4 <uECC_vli_modSub>
	uECC_vli_modMult_fast(t6, t6, t5, curve); /* t6 = (y2+y1)*(x3' - B) */
   4a1c8:	a90a      	add	r1, sp, #40	; 0x28
   4a1ca:	4643      	mov	r3, r8
   4a1cc:	aa02      	add	r2, sp, #8
   4a1ce:	4608      	mov	r0, r1
   4a1d0:	f7ff fe95 	bl	49efe <uECC_vli_modMult_fast>
	/* t2 = (y2+y1)*(x3' - B) - E = y3': */
	uECC_vli_modSub(Y1, t6, Y1, curve->p, num_words);
   4a1d4:	4623      	mov	r3, r4
   4a1d6:	4652      	mov	r2, sl
   4a1d8:	a90a      	add	r1, sp, #40	; 0x28
   4a1da:	4650      	mov	r0, sl
   4a1dc:	9500      	str	r5, [sp, #0]
   4a1de:	f7ff fde1 	bl	49da4 <uECC_vli_modSub>

	uECC_vli_set(X1, t7, num_words);
   4a1e2:	462a      	mov	r2, r5
   4a1e4:	a912      	add	r1, sp, #72	; 0x48
   4a1e6:	4638      	mov	r0, r7
   4a1e8:	f7ff fd75 	bl	49cd6 <uECC_vli_set>
}
   4a1ec:	b01a      	add	sp, #104	; 0x68
   4a1ee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0004a1f2 <uECC_vli_modInv>:
{
   4a1f2:	b5f0      	push	{r4, r5, r6, r7, lr}
   4a1f4:	460f      	mov	r7, r1
   4a1f6:	b0a1      	sub	sp, #132	; 0x84
   4a1f8:	4606      	mov	r6, r0
	if (uECC_vli_isZero(input, num_words)) {
   4a1fa:	4619      	mov	r1, r3
   4a1fc:	4638      	mov	r0, r7
{
   4a1fe:	4615      	mov	r5, r2
   4a200:	461c      	mov	r4, r3
	if (uECC_vli_isZero(input, num_words)) {
   4a202:	f7ff fd30 	bl	49c66 <uECC_vli_isZero>
   4a206:	b128      	cbz	r0, 4a214 <uECC_vli_modInv+0x22>
		uECC_vli_clear(result, num_words);
   4a208:	4630      	mov	r0, r6
}
   4a20a:	b021      	add	sp, #132	; 0x84
   4a20c:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		uECC_vli_clear(result, num_words);
   4a210:	f7ff bd1e 	b.w	49c50 <uECC_vli_clear>
	uECC_vli_set(a, input, num_words);
   4a214:	4622      	mov	r2, r4
   4a216:	4639      	mov	r1, r7
   4a218:	4668      	mov	r0, sp
   4a21a:	f7ff fd5c 	bl	49cd6 <uECC_vli_set>
	uECC_vli_set(b, mod, num_words);
   4a21e:	4629      	mov	r1, r5
   4a220:	a808      	add	r0, sp, #32
   4a222:	f7ff fd58 	bl	49cd6 <uECC_vli_set>
	uECC_vli_clear(u, num_words);
   4a226:	a810      	add	r0, sp, #64	; 0x40
   4a228:	4621      	mov	r1, r4
   4a22a:	f7ff fd11 	bl	49c50 <uECC_vli_clear>
	u[0] = 1;
   4a22e:	2301      	movs	r3, #1
	uECC_vli_clear(v, num_words);
   4a230:	a818      	add	r0, sp, #96	; 0x60
	u[0] = 1;
   4a232:	9310      	str	r3, [sp, #64]	; 0x40
	uECC_vli_clear(v, num_words);
   4a234:	f7ff fd0c 	bl	49c50 <uECC_vli_clear>
	while ((cmpResult = uECC_vli_cmp_unsafe(a, b, num_words)) != 0) {
   4a238:	4622      	mov	r2, r4
   4a23a:	a908      	add	r1, sp, #32
   4a23c:	4668      	mov	r0, sp
   4a23e:	f7ff fd56 	bl	49cee <uECC_vli_cmp_unsafe>
   4a242:	b930      	cbnz	r0, 4a252 <uECC_vli_modInv+0x60>
  	uECC_vli_set(result, u, num_words);
   4a244:	4622      	mov	r2, r4
   4a246:	a910      	add	r1, sp, #64	; 0x40
   4a248:	4630      	mov	r0, r6
   4a24a:	f7ff fd44 	bl	49cd6 <uECC_vli_set>
}
   4a24e:	b021      	add	sp, #132	; 0x84
   4a250:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (EVEN(a)) {
   4a252:	9b00      	ldr	r3, [sp, #0]
   4a254:	07da      	lsls	r2, r3, #31
   4a256:	d409      	bmi.n	4a26c <uECC_vli_modInv+0x7a>
			uECC_vli_rshift1(a, num_words);
   4a258:	4621      	mov	r1, r4
   4a25a:	4668      	mov	r0, sp
   4a25c:	f7ff fc63 	bl	49b26 <uECC_vli_rshift1>
      			vli_modInv_update(u, mod, num_words);
   4a260:	4622      	mov	r2, r4
   4a262:	4629      	mov	r1, r5
   4a264:	a810      	add	r0, sp, #64	; 0x40
      			vli_modInv_update(v, mod, num_words);
   4a266:	f7ff fc6b 	bl	49b40 <vli_modInv_update>
   4a26a:	e7e5      	b.n	4a238 <uECC_vli_modInv+0x46>
    		} else if (EVEN(b)) {
   4a26c:	9b08      	ldr	r3, [sp, #32]
   4a26e:	07db      	lsls	r3, r3, #31
   4a270:	d407      	bmi.n	4a282 <uECC_vli_modInv+0x90>
			uECC_vli_rshift1(b, num_words);
   4a272:	4621      	mov	r1, r4
   4a274:	a808      	add	r0, sp, #32
   4a276:	f7ff fc56 	bl	49b26 <uECC_vli_rshift1>
      			vli_modInv_update(v, mod, num_words);
   4a27a:	4622      	mov	r2, r4
   4a27c:	4629      	mov	r1, r5
   4a27e:	a818      	add	r0, sp, #96	; 0x60
   4a280:	e7f1      	b.n	4a266 <uECC_vli_modInv+0x74>
		} else if (cmpResult > 0) {
   4a282:	2800      	cmp	r0, #0
			uECC_vli_sub(a, a, b, num_words);
   4a284:	4623      	mov	r3, r4
		} else if (cmpResult > 0) {
   4a286:	dd1c      	ble.n	4a2c2 <uECC_vli_modInv+0xd0>
			uECC_vli_sub(a, a, b, num_words);
   4a288:	aa08      	add	r2, sp, #32
   4a28a:	4669      	mov	r1, sp
   4a28c:	4668      	mov	r0, sp
   4a28e:	f7ff fd55 	bl	49d3c <uECC_vli_sub>
			uECC_vli_rshift1(a, num_words);
   4a292:	4621      	mov	r1, r4
   4a294:	4668      	mov	r0, sp
   4a296:	f7ff fc46 	bl	49b26 <uECC_vli_rshift1>
			if (uECC_vli_cmp_unsafe(u, v, num_words) < 0) {
   4a29a:	4622      	mov	r2, r4
   4a29c:	a918      	add	r1, sp, #96	; 0x60
   4a29e:	a810      	add	r0, sp, #64	; 0x40
   4a2a0:	f7ff fd25 	bl	49cee <uECC_vli_cmp_unsafe>
   4a2a4:	2800      	cmp	r0, #0
   4a2a6:	da05      	bge.n	4a2b4 <uECC_vli_modInv+0xc2>
        			uECC_vli_add(u, u, mod, num_words);
   4a2a8:	a910      	add	r1, sp, #64	; 0x40
   4a2aa:	4623      	mov	r3, r4
   4a2ac:	462a      	mov	r2, r5
   4a2ae:	4608      	mov	r0, r1
   4a2b0:	f7ff fc1f 	bl	49af2 <uECC_vli_add>
      			uECC_vli_sub(u, u, v, num_words);
   4a2b4:	a910      	add	r1, sp, #64	; 0x40
   4a2b6:	4623      	mov	r3, r4
   4a2b8:	aa18      	add	r2, sp, #96	; 0x60
   4a2ba:	4608      	mov	r0, r1
   4a2bc:	f7ff fd3e 	bl	49d3c <uECC_vli_sub>
   4a2c0:	e7ce      	b.n	4a260 <uECC_vli_modInv+0x6e>
      			uECC_vli_sub(b, b, a, num_words);
   4a2c2:	466a      	mov	r2, sp
   4a2c4:	a808      	add	r0, sp, #32
   4a2c6:	f7ff fd39 	bl	49d3c <uECC_vli_sub>
      			uECC_vli_rshift1(b, num_words);
   4a2ca:	4621      	mov	r1, r4
   4a2cc:	a808      	add	r0, sp, #32
   4a2ce:	f7ff fc2a 	bl	49b26 <uECC_vli_rshift1>
      			if (uECC_vli_cmp_unsafe(v, u, num_words) < 0) {
   4a2d2:	4622      	mov	r2, r4
   4a2d4:	a910      	add	r1, sp, #64	; 0x40
   4a2d6:	a818      	add	r0, sp, #96	; 0x60
   4a2d8:	f7ff fd09 	bl	49cee <uECC_vli_cmp_unsafe>
   4a2dc:	2800      	cmp	r0, #0
   4a2de:	da05      	bge.n	4a2ec <uECC_vli_modInv+0xfa>
        			uECC_vli_add(v, v, mod, num_words);
   4a2e0:	a918      	add	r1, sp, #96	; 0x60
   4a2e2:	4623      	mov	r3, r4
   4a2e4:	462a      	mov	r2, r5
   4a2e6:	4608      	mov	r0, r1
   4a2e8:	f7ff fc03 	bl	49af2 <uECC_vli_add>
      			uECC_vli_sub(v, v, u, num_words);
   4a2ec:	a918      	add	r1, sp, #96	; 0x60
   4a2ee:	4623      	mov	r3, r4
   4a2f0:	aa10      	add	r2, sp, #64	; 0x40
   4a2f2:	4608      	mov	r0, r1
   4a2f4:	f7ff fd22 	bl	49d3c <uECC_vli_sub>
   4a2f8:	e7bf      	b.n	4a27a <uECC_vli_modInv+0x88>

0004a2fa <EccPoint_isZero>:
	return uECC_vli_isZero(point, curve->num_words * 2);
   4a2fa:	7809      	ldrb	r1, [r1, #0]
   4a2fc:	0049      	lsls	r1, r1, #1
   4a2fe:	b249      	sxtb	r1, r1
   4a300:	f7ff bcb1 	b.w	49c66 <uECC_vli_isZero>

0004a304 <apply_z>:
{
   4a304:	b5f0      	push	{r4, r5, r6, r7, lr}
   4a306:	4615      	mov	r5, r2
   4a308:	b089      	sub	sp, #36	; 0x24
   4a30a:	461c      	mov	r4, r3
   4a30c:	4607      	mov	r7, r0
   4a30e:	460e      	mov	r6, r1
	uECC_vli_modSquare_fast(t1, Z, curve);    /* z^2 */
   4a310:	461a      	mov	r2, r3
   4a312:	4629      	mov	r1, r5
   4a314:	4668      	mov	r0, sp
   4a316:	f7ff fe02 	bl	49f1e <uECC_vli_modSquare_fast>
	uECC_vli_modMult_fast(X1, X1, t1, curve); /* x1 * z^2 */
   4a31a:	4623      	mov	r3, r4
   4a31c:	466a      	mov	r2, sp
   4a31e:	4639      	mov	r1, r7
   4a320:	4638      	mov	r0, r7
   4a322:	f7ff fdec 	bl	49efe <uECC_vli_modMult_fast>
	uECC_vli_modMult_fast(t1, t1, Z, curve);  /* z^3 */
   4a326:	4623      	mov	r3, r4
   4a328:	462a      	mov	r2, r5
   4a32a:	4669      	mov	r1, sp
   4a32c:	4668      	mov	r0, sp
   4a32e:	f7ff fde6 	bl	49efe <uECC_vli_modMult_fast>
	uECC_vli_modMult_fast(Y1, Y1, t1, curve); /* y1 * z^3 */
   4a332:	4623      	mov	r3, r4
   4a334:	466a      	mov	r2, sp
   4a336:	4631      	mov	r1, r6
   4a338:	4630      	mov	r0, r6
   4a33a:	f7ff fde0 	bl	49efe <uECC_vli_modMult_fast>
}
   4a33e:	b009      	add	sp, #36	; 0x24
   4a340:	bdf0      	pop	{r4, r5, r6, r7, pc}

0004a342 <XYcZ_add>:
{
   4a342:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   4a346:	b08a      	sub	sp, #40	; 0x28
   4a348:	4614      	mov	r4, r2
   4a34a:	f8dd a048 	ldr.w	sl, [sp, #72]	; 0x48
	wordcount_t num_words = curve->num_words;
   4a34e:	4655      	mov	r5, sl
{
   4a350:	461f      	mov	r7, r3
	wordcount_t num_words = curve->num_words;
   4a352:	f915 6b04 	ldrsb.w	r6, [r5], #4
	uECC_vli_modSub(t5, X2, X1, curve->p, num_words); /* t5 = x2 - x1 */
   4a356:	9600      	str	r6, [sp, #0]
{
   4a358:	4680      	mov	r8, r0
   4a35a:	4689      	mov	r9, r1
	uECC_vli_modSub(t5, X2, X1, curve->p, num_words); /* t5 = x2 - x1 */
   4a35c:	462b      	mov	r3, r5
   4a35e:	4602      	mov	r2, r0
   4a360:	4621      	mov	r1, r4
   4a362:	a802      	add	r0, sp, #8
   4a364:	f7ff fd1e 	bl	49da4 <uECC_vli_modSub>
	uECC_vli_modSquare_fast(t5, t5, curve); /* t5 = (x2 - x1)^2 = A */
   4a368:	a902      	add	r1, sp, #8
   4a36a:	4652      	mov	r2, sl
   4a36c:	4608      	mov	r0, r1
   4a36e:	f7ff fdd6 	bl	49f1e <uECC_vli_modSquare_fast>
	uECC_vli_modMult_fast(X1, X1, t5, curve); /* t1 = x1*A = B */
   4a372:	4653      	mov	r3, sl
   4a374:	aa02      	add	r2, sp, #8
   4a376:	4641      	mov	r1, r8
   4a378:	4640      	mov	r0, r8
   4a37a:	f7ff fdc0 	bl	49efe <uECC_vli_modMult_fast>
	uECC_vli_modMult_fast(X2, X2, t5, curve); /* t3 = x2*A = C */
   4a37e:	4653      	mov	r3, sl
   4a380:	aa02      	add	r2, sp, #8
   4a382:	4621      	mov	r1, r4
   4a384:	4620      	mov	r0, r4
   4a386:	f7ff fdba 	bl	49efe <uECC_vli_modMult_fast>
	uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words); /* t4 = y2 - y1 */
   4a38a:	462b      	mov	r3, r5
   4a38c:	464a      	mov	r2, r9
   4a38e:	4639      	mov	r1, r7
   4a390:	4638      	mov	r0, r7
   4a392:	9600      	str	r6, [sp, #0]
   4a394:	f7ff fd06 	bl	49da4 <uECC_vli_modSub>
	uECC_vli_modSquare_fast(t5, Y2, curve); /* t5 = (y2 - y1)^2 = D */
   4a398:	4652      	mov	r2, sl
   4a39a:	4639      	mov	r1, r7
   4a39c:	a802      	add	r0, sp, #8
   4a39e:	f7ff fdbe 	bl	49f1e <uECC_vli_modSquare_fast>
	uECC_vli_modSub(t5, t5, X1, curve->p, num_words); /* t5 = D - B */
   4a3a2:	a902      	add	r1, sp, #8
   4a3a4:	462b      	mov	r3, r5
   4a3a6:	4642      	mov	r2, r8
   4a3a8:	4608      	mov	r0, r1
   4a3aa:	9600      	str	r6, [sp, #0]
   4a3ac:	f7ff fcfa 	bl	49da4 <uECC_vli_modSub>
	uECC_vli_modSub(t5, t5, X2, curve->p, num_words); /* t5 = D - B - C = x3 */
   4a3b0:	a902      	add	r1, sp, #8
   4a3b2:	462b      	mov	r3, r5
   4a3b4:	4622      	mov	r2, r4
   4a3b6:	4608      	mov	r0, r1
   4a3b8:	9600      	str	r6, [sp, #0]
   4a3ba:	f7ff fcf3 	bl	49da4 <uECC_vli_modSub>
	uECC_vli_modSub(X2, X2, X1, curve->p, num_words); /* t3 = C - B */
   4a3be:	462b      	mov	r3, r5
   4a3c0:	4642      	mov	r2, r8
   4a3c2:	4621      	mov	r1, r4
   4a3c4:	4620      	mov	r0, r4
   4a3c6:	9600      	str	r6, [sp, #0]
   4a3c8:	f7ff fcec 	bl	49da4 <uECC_vli_modSub>
	uECC_vli_modMult_fast(Y1, Y1, X2, curve); /* t2 = y1*(C - B) */
   4a3cc:	4653      	mov	r3, sl
   4a3ce:	4622      	mov	r2, r4
   4a3d0:	4649      	mov	r1, r9
   4a3d2:	4648      	mov	r0, r9
   4a3d4:	f7ff fd93 	bl	49efe <uECC_vli_modMult_fast>
	uECC_vli_modSub(X2, X1, t5, curve->p, num_words); /* t3 = B - x3 */
   4a3d8:	462b      	mov	r3, r5
   4a3da:	aa02      	add	r2, sp, #8
   4a3dc:	4641      	mov	r1, r8
   4a3de:	4620      	mov	r0, r4
   4a3e0:	9600      	str	r6, [sp, #0]
   4a3e2:	f7ff fcdf 	bl	49da4 <uECC_vli_modSub>
	uECC_vli_modMult_fast(Y2, Y2, X2, curve); /* t4 = (y2 - y1)*(B - x3) */
   4a3e6:	4653      	mov	r3, sl
   4a3e8:	4622      	mov	r2, r4
   4a3ea:	4639      	mov	r1, r7
   4a3ec:	4638      	mov	r0, r7
   4a3ee:	f7ff fd86 	bl	49efe <uECC_vli_modMult_fast>
	uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words); /* t4 = y3 */
   4a3f2:	462b      	mov	r3, r5
   4a3f4:	464a      	mov	r2, r9
   4a3f6:	4639      	mov	r1, r7
   4a3f8:	4638      	mov	r0, r7
   4a3fa:	9600      	str	r6, [sp, #0]
   4a3fc:	f7ff fcd2 	bl	49da4 <uECC_vli_modSub>
	uECC_vli_set(X2, t5, num_words);
   4a400:	4632      	mov	r2, r6
   4a402:	a902      	add	r1, sp, #8
   4a404:	4620      	mov	r0, r4
   4a406:	f7ff fc66 	bl	49cd6 <uECC_vli_set>
}
   4a40a:	b00a      	add	sp, #40	; 0x28
   4a40c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0004a410 <EccPoint_mult>:

void EccPoint_mult(uECC_word_t * result, const uECC_word_t * point,
		   const uECC_word_t * scalar,
		   const uECC_word_t * initial_Z,
		   bitcount_t num_bits, uECC_Curve curve) 
{
   4a410:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4a414:	b0af      	sub	sp, #188	; 0xbc
   4a416:	4691      	mov	r9, r2
   4a418:	9c39      	ldr	r4, [sp, #228]	; 0xe4
   4a41a:	9002      	str	r0, [sp, #8]
	uECC_word_t Rx[2][NUM_ECC_WORDS];
	uECC_word_t Ry[2][NUM_ECC_WORDS];
	uECC_word_t z[NUM_ECC_WORDS];
	bitcount_t i;
	uECC_word_t nb;
	wordcount_t num_words = curve->num_words;
   4a41c:	f994 6000 	ldrsb.w	r6, [r4]

	uECC_vli_set(Rx[1], point, num_words);
   4a420:	a816      	add	r0, sp, #88	; 0x58
   4a422:	4632      	mov	r2, r6
{
   4a424:	461d      	mov	r5, r3
	uECC_vli_set(Rx[1], point, num_words);
   4a426:	f7ff fc56 	bl	49cd6 <uECC_vli_set>
  	uECC_vli_set(Ry[1], point + num_words, num_words);
   4a42a:	00b3      	lsls	r3, r6, #2
   4a42c:	9303      	str	r3, [sp, #12]
   4a42e:	eb01 0386 	add.w	r3, r1, r6, lsl #2
{
   4a432:	4688      	mov	r8, r1
  	uECC_vli_set(Ry[1], point + num_words, num_words);
   4a434:	a826      	add	r0, sp, #152	; 0x98
   4a436:	4619      	mov	r1, r3
   4a438:	9304      	str	r3, [sp, #16]
   4a43a:	f7ff fc4c 	bl	49cd6 <uECC_vli_set>
	if (initial_Z) {
   4a43e:	2d00      	cmp	r5, #0
   4a440:	f000 8081 	beq.w	4a546 <EccPoint_mult+0x136>
		uECC_vli_set(z, initial_Z, num_words);
   4a444:	4629      	mov	r1, r5
   4a446:	a806      	add	r0, sp, #24
   4a448:	f7ff fc45 	bl	49cd6 <uECC_vli_set>
	uECC_vli_set(X2, X1, num_words);
   4a44c:	4632      	mov	r2, r6
   4a44e:	a916      	add	r1, sp, #88	; 0x58
   4a450:	a80e      	add	r0, sp, #56	; 0x38
   4a452:	f7ff fc40 	bl	49cd6 <uECC_vli_set>
	uECC_vli_set(Y2, Y1, num_words);
   4a456:	a926      	add	r1, sp, #152	; 0x98
   4a458:	a81e      	add	r0, sp, #120	; 0x78
   4a45a:	f7ff fc3c 	bl	49cd6 <uECC_vli_set>
	apply_z(X1, Y1, z, curve);
   4a45e:	4623      	mov	r3, r4
   4a460:	aa06      	add	r2, sp, #24
   4a462:	a816      	add	r0, sp, #88	; 0x58
   4a464:	f7ff ff4e 	bl	4a304 <apply_z>
	curve->double_jacobian(X1, Y1, z, curve);
   4a468:	f8d4 50a4 	ldr.w	r5, [r4, #164]	; 0xa4
   4a46c:	4623      	mov	r3, r4
   4a46e:	aa06      	add	r2, sp, #24
   4a470:	a926      	add	r1, sp, #152	; 0x98
   4a472:	a816      	add	r0, sp, #88	; 0x58
   4a474:	47a8      	blx	r5
	apply_z(X2, Y2, z, curve);
   4a476:	4623      	mov	r3, r4
   4a478:	aa06      	add	r2, sp, #24
   4a47a:	a91e      	add	r1, sp, #120	; 0x78
   4a47c:	a80e      	add	r0, sp, #56	; 0x38
   4a47e:	f7ff ff41 	bl	4a304 <apply_z>

	XYcZ_initial_double(Rx[1], Ry[1], Rx[0], Ry[0], initial_Z, curve);

	for (i = num_bits - 2; i > 0; --i) {
   4a482:	f9bd 50e0 	ldrsh.w	r5, [sp, #224]	; 0xe0
   4a486:	3d02      	subs	r5, #2
   4a488:	b22d      	sxth	r5, r5
   4a48a:	2d00      	cmp	r5, #0
   4a48c:	dc62      	bgt.n	4a554 <EccPoint_mult+0x144>
	return (vli[bit >> uECC_WORD_BITS_SHIFT] &
   4a48e:	f8d9 5000 	ldr.w	r5, [r9]
		XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
		XYcZ_add(Rx[nb], Ry[nb], Rx[1 - nb], Ry[1 - nb], curve);
	}

	nb = !uECC_vli_testBit(scalar, 0);
	XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
   4a492:	9400      	str	r4, [sp, #0]
	return (vli[bit >> uECC_WORD_BITS_SHIFT] &
   4a494:	f005 0701 	and.w	r7, r5, #1
	XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
   4a498:	ab0e      	add	r3, sp, #56	; 0x38
   4a49a:	eb03 1947 	add.w	r9, r3, r7, lsl #5
   4a49e:	43ed      	mvns	r5, r5
   4a4a0:	ab1e      	add	r3, sp, #120	; 0x78
   4a4a2:	eb03 1747 	add.w	r7, r3, r7, lsl #5
   4a4a6:	f005 0501 	and.w	r5, r5, #1
   4a4aa:	ab0e      	add	r3, sp, #56	; 0x38
   4a4ac:	eb03 1a45 	add.w	sl, r3, r5, lsl #5
   4a4b0:	ab1e      	add	r3, sp, #120	; 0x78
   4a4b2:	eb03 1545 	add.w	r5, r3, r5, lsl #5
   4a4b6:	462b      	mov	r3, r5
   4a4b8:	4652      	mov	r2, sl
   4a4ba:	4639      	mov	r1, r7
   4a4bc:	4648      	mov	r0, r9

	/* Find final 1/Z value. */
	uECC_vli_modSub(z, Rx[1], Rx[0], curve->p, num_words); /* X1 - X0 */
   4a4be:	f104 0b04 	add.w	fp, r4, #4
	XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
   4a4c2:	f7ff fe08 	bl	4a0d6 <XYcZ_addC>
	uECC_vli_modSub(z, Rx[1], Rx[0], curve->p, num_words); /* X1 - X0 */
   4a4c6:	465b      	mov	r3, fp
   4a4c8:	aa0e      	add	r2, sp, #56	; 0x38
   4a4ca:	a916      	add	r1, sp, #88	; 0x58
   4a4cc:	a806      	add	r0, sp, #24
   4a4ce:	9600      	str	r6, [sp, #0]
   4a4d0:	f7ff fc68 	bl	49da4 <uECC_vli_modSub>
	uECC_vli_modMult_fast(z, z, Ry[1 - nb], curve); /* Yb * (X1 - X0) */
   4a4d4:	a906      	add	r1, sp, #24
   4a4d6:	4623      	mov	r3, r4
   4a4d8:	463a      	mov	r2, r7
   4a4da:	4608      	mov	r0, r1
   4a4dc:	f7ff fd0f 	bl	49efe <uECC_vli_modMult_fast>
	uECC_vli_modMult_fast(z, z, point, curve); /* xP * Yb * (X1 - X0) */
   4a4e0:	a906      	add	r1, sp, #24
   4a4e2:	4623      	mov	r3, r4
   4a4e4:	4642      	mov	r2, r8
   4a4e6:	4608      	mov	r0, r1
   4a4e8:	f7ff fd09 	bl	49efe <uECC_vli_modMult_fast>
	uECC_vli_modInv(z, z, curve->p, num_words); /* 1 / (xP * Yb * (X1 - X0))*/
   4a4ec:	a906      	add	r1, sp, #24
   4a4ee:	4633      	mov	r3, r6
   4a4f0:	465a      	mov	r2, fp
   4a4f2:	4608      	mov	r0, r1
   4a4f4:	f7ff fe7d 	bl	4a1f2 <uECC_vli_modInv>
	/* yP / (xP * Yb * (X1 - X0)) */
	uECC_vli_modMult_fast(z, z, point + num_words, curve);
   4a4f8:	a906      	add	r1, sp, #24
   4a4fa:	9a04      	ldr	r2, [sp, #16]
   4a4fc:	4623      	mov	r3, r4
   4a4fe:	4608      	mov	r0, r1
   4a500:	f7ff fcfd 	bl	49efe <uECC_vli_modMult_fast>
	/* Xb * yP / (xP * Yb * (X1 - X0)) */
	uECC_vli_modMult_fast(z, z, Rx[1 - nb], curve);
   4a504:	a906      	add	r1, sp, #24
   4a506:	4623      	mov	r3, r4
   4a508:	464a      	mov	r2, r9
   4a50a:	4608      	mov	r0, r1
   4a50c:	f7ff fcf7 	bl	49efe <uECC_vli_modMult_fast>
	/* End 1/Z calculation */

	XYcZ_add(Rx[nb], Ry[nb], Rx[1 - nb], Ry[1 - nb], curve);
   4a510:	463b      	mov	r3, r7
   4a512:	464a      	mov	r2, r9
   4a514:	4629      	mov	r1, r5
   4a516:	4650      	mov	r0, sl
   4a518:	9400      	str	r4, [sp, #0]
   4a51a:	f7ff ff12 	bl	4a342 <XYcZ_add>
	apply_z(Rx[0], Ry[0], z, curve);
   4a51e:	4623      	mov	r3, r4
   4a520:	aa06      	add	r2, sp, #24
   4a522:	a91e      	add	r1, sp, #120	; 0x78
   4a524:	a80e      	add	r0, sp, #56	; 0x38
   4a526:	f7ff feed 	bl	4a304 <apply_z>

	uECC_vli_set(result, Rx[0], num_words);
   4a52a:	9802      	ldr	r0, [sp, #8]
   4a52c:	4632      	mov	r2, r6
   4a52e:	a90e      	add	r1, sp, #56	; 0x38
   4a530:	f7ff fbd1 	bl	49cd6 <uECC_vli_set>
	uECC_vli_set(result + num_words, Ry[0], num_words);
   4a534:	e9dd 0302 	ldrd	r0, r3, [sp, #8]
   4a538:	a91e      	add	r1, sp, #120	; 0x78
   4a53a:	4418      	add	r0, r3
   4a53c:	f7ff fbcb 	bl	49cd6 <uECC_vli_set>
}
   4a540:	b02f      	add	sp, #188	; 0xbc
   4a542:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		uECC_vli_clear(z, num_words);
   4a546:	4631      	mov	r1, r6
   4a548:	a806      	add	r0, sp, #24
   4a54a:	f7ff fb81 	bl	49c50 <uECC_vli_clear>
		z[0] = 1;
   4a54e:	2301      	movs	r3, #1
   4a550:	9306      	str	r3, [sp, #24]
   4a552:	e77b      	b.n	4a44c <EccPoint_mult+0x3c>
		nb = !uECC_vli_testBit(scalar, i);
   4a554:	4629      	mov	r1, r5
   4a556:	4648      	mov	r0, r9
   4a558:	f7ff fb94 	bl	49c84 <uECC_vli_testBit>
   4a55c:	fab0 f780 	clz	r7, r0
   4a560:	097f      	lsrs	r7, r7, #5
		XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
   4a562:	f1c7 0101 	rsb	r1, r7, #1
   4a566:	ab0e      	add	r3, sp, #56	; 0x38
   4a568:	eb03 1b41 	add.w	fp, r3, r1, lsl #5
   4a56c:	ab1e      	add	r3, sp, #120	; 0x78
   4a56e:	eb03 1141 	add.w	r1, r3, r1, lsl #5
   4a572:	ab0e      	add	r3, sp, #56	; 0x38
   4a574:	eb03 1a47 	add.w	sl, r3, r7, lsl #5
   4a578:	ab1e      	add	r3, sp, #120	; 0x78
   4a57a:	eb03 1747 	add.w	r7, r3, r7, lsl #5
   4a57e:	463b      	mov	r3, r7
   4a580:	4652      	mov	r2, sl
   4a582:	4658      	mov	r0, fp
   4a584:	9400      	str	r4, [sp, #0]
   4a586:	9105      	str	r1, [sp, #20]
   4a588:	f7ff fda5 	bl	4a0d6 <XYcZ_addC>
		XYcZ_add(Rx[nb], Ry[nb], Rx[1 - nb], Ry[1 - nb], curve);
   4a58c:	9905      	ldr	r1, [sp, #20]
   4a58e:	9400      	str	r4, [sp, #0]
   4a590:	460b      	mov	r3, r1
   4a592:	465a      	mov	r2, fp
   4a594:	4639      	mov	r1, r7
   4a596:	4650      	mov	r0, sl
   4a598:	f7ff fed3 	bl	4a342 <XYcZ_add>
	for (i = num_bits - 2; i > 0; --i) {
   4a59c:	3d01      	subs	r5, #1
   4a59e:	e773      	b.n	4a488 <EccPoint_mult+0x78>

0004a5a0 <regularize_k>:

uECC_word_t regularize_k(const uECC_word_t * const k, uECC_word_t *k0,
			 uECC_word_t *k1, uECC_Curve curve)
{
   4a5a0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}

	wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
   4a5a4:	f9b3 9002 	ldrsh.w	r9, [r3, #2]
   4a5a8:	f119 061f 	adds.w	r6, r9, #31
   4a5ac:	bf48      	it	mi
   4a5ae:	f109 063e 	addmi.w	r6, r9, #62	; 0x3e
{
   4a5b2:	460f      	mov	r7, r1

	bitcount_t num_n_bits = curve->num_n_bits;

	uECC_word_t carry = uECC_vli_add(k0, k, curve->n, num_n_words) ||
   4a5b4:	f103 0524 	add.w	r5, r3, #36	; 0x24
	wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
   4a5b8:	f346 1647 	sbfx	r6, r6, #5, #8
	uECC_word_t carry = uECC_vli_add(k0, k, curve->n, num_n_words) ||
   4a5bc:	4601      	mov	r1, r0
{
   4a5be:	4690      	mov	r8, r2
	uECC_word_t carry = uECC_vli_add(k0, k, curve->n, num_n_words) ||
   4a5c0:	4633      	mov	r3, r6
   4a5c2:	462a      	mov	r2, r5
   4a5c4:	4638      	mov	r0, r7
   4a5c6:	f7ff fa94 	bl	49af2 <uECC_vli_add>
   4a5ca:	4604      	mov	r4, r0
   4a5cc:	b990      	cbnz	r0, 4a5f4 <regularize_k+0x54>
   4a5ce:	ebb9 1f46 	cmp.w	r9, r6, lsl #5
   4a5d2:	da06      	bge.n	4a5e2 <regularize_k+0x42>
			     (num_n_bits < ((bitcount_t)num_n_words * uECC_WORD_SIZE * 8) &&
			     uECC_vli_testBit(k0, num_n_bits));
   4a5d4:	4649      	mov	r1, r9
   4a5d6:	4638      	mov	r0, r7
   4a5d8:	f7ff fb54 	bl	49c84 <uECC_vli_testBit>
			     (num_n_bits < ((bitcount_t)num_n_words * uECC_WORD_SIZE * 8) &&
   4a5dc:	1e04      	subs	r4, r0, #0
   4a5de:	bf18      	it	ne
   4a5e0:	2401      	movne	r4, #1

	uECC_vli_add(k1, k0, curve->n, num_n_words);
   4a5e2:	4633      	mov	r3, r6
   4a5e4:	462a      	mov	r2, r5
   4a5e6:	4639      	mov	r1, r7
   4a5e8:	4640      	mov	r0, r8
   4a5ea:	f7ff fa82 	bl	49af2 <uECC_vli_add>

	return carry;
}
   4a5ee:	4620      	mov	r0, r4
   4a5f0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	uECC_word_t carry = uECC_vli_add(k0, k, curve->n, num_n_words) ||
   4a5f4:	2401      	movs	r4, #1
   4a5f6:	e7f4      	b.n	4a5e2 <regularize_k+0x42>

0004a5f8 <EccPoint_compute_public_key>:

uECC_word_t EccPoint_compute_public_key(uECC_word_t *result,
					uECC_word_t *private_key,
					uECC_Curve curve)
{
   4a5f8:	b530      	push	{r4, r5, lr}
   4a5fa:	4614      	mov	r4, r2
   4a5fc:	b095      	sub	sp, #84	; 0x54
   4a5fe:	4605      	mov	r5, r0

	uECC_word_t tmp1[NUM_ECC_WORDS];
 	uECC_word_t tmp2[NUM_ECC_WORDS];
	uECC_word_t *p2[2] = {tmp1, tmp2};
   4a600:	aa0c      	add	r2, sp, #48	; 0x30
	uECC_word_t carry;

	/* Regularize the bitcount for the private key so that attackers cannot
	 * use a side channel attack to learn the number of leading zeros. */
	carry = regularize_k(private_key, tmp1, tmp2, curve);
   4a602:	4623      	mov	r3, r4
{
   4a604:	4608      	mov	r0, r1
	uECC_word_t *p2[2] = {tmp1, tmp2};
   4a606:	a904      	add	r1, sp, #16
   4a608:	9102      	str	r1, [sp, #8]
   4a60a:	9203      	str	r2, [sp, #12]
	carry = regularize_k(private_key, tmp1, tmp2, curve);
   4a60c:	f7ff ffc8 	bl	4a5a0 <regularize_k>

	EccPoint_mult(result, curve->G, p2[!carry], 0, curve->num_n_bits + 1, curve);
   4a610:	fab0 f380 	clz	r3, r0
   4a614:	9401      	str	r4, [sp, #4]
   4a616:	095b      	lsrs	r3, r3, #5
   4a618:	aa14      	add	r2, sp, #80	; 0x50
   4a61a:	eb02 0283 	add.w	r2, r2, r3, lsl #2
   4a61e:	8863      	ldrh	r3, [r4, #2]
   4a620:	3301      	adds	r3, #1
   4a622:	b21b      	sxth	r3, r3
   4a624:	9300      	str	r3, [sp, #0]
   4a626:	f852 2c48 	ldr.w	r2, [r2, #-72]
   4a62a:	2300      	movs	r3, #0
   4a62c:	f104 0144 	add.w	r1, r4, #68	; 0x44
   4a630:	4628      	mov	r0, r5
   4a632:	f7ff feed 	bl	4a410 <EccPoint_mult>

	if (EccPoint_isZero(result, curve)) {
   4a636:	4621      	mov	r1, r4
   4a638:	4628      	mov	r0, r5
   4a63a:	f7ff fe5e 	bl	4a2fa <EccPoint_isZero>
		return 0;
	}
	return 1;
}
   4a63e:	fab0 f080 	clz	r0, r0
   4a642:	0940      	lsrs	r0, r0, #5
   4a644:	b015      	add	sp, #84	; 0x54
   4a646:	bd30      	pop	{r4, r5, pc}

0004a648 <uECC_vli_nativeToBytes>:

/* Converts an integer in uECC native format to big-endian bytes. */
void uECC_vli_nativeToBytes(uint8_t *bytes, int num_bytes,
			    const unsigned int *native)
{
   4a648:	b5f0      	push	{r4, r5, r6, r7, lr}
	wordcount_t i;
	for (i = 0; i < num_bytes; ++i) {
   4a64a:	2500      	movs	r5, #0
		unsigned b = num_bytes - 1 - i;
   4a64c:	1e4f      	subs	r7, r1, #1
   4a64e:	b26c      	sxtb	r4, r5
	for (i = 0; i < num_bytes; ++i) {
   4a650:	428c      	cmp	r4, r1
   4a652:	f105 0501 	add.w	r5, r5, #1
   4a656:	db00      	blt.n	4a65a <uECC_vli_nativeToBytes+0x12>
		bytes[i] = native[b / uECC_WORD_SIZE] >> (8 * (b % uECC_WORD_SIZE));
	}
}
   4a658:	bdf0      	pop	{r4, r5, r6, r7, pc}
		unsigned b = num_bytes - 1 - i;
   4a65a:	1b3b      	subs	r3, r7, r4
		bytes[i] = native[b / uECC_WORD_SIZE] >> (8 * (b % uECC_WORD_SIZE));
   4a65c:	f023 0603 	bic.w	r6, r3, #3
   4a660:	f003 0303 	and.w	r3, r3, #3
   4a664:	5996      	ldr	r6, [r2, r6]
   4a666:	00db      	lsls	r3, r3, #3
   4a668:	fa26 f303 	lsr.w	r3, r6, r3
   4a66c:	5503      	strb	r3, [r0, r4]
	for (i = 0; i < num_bytes; ++i) {
   4a66e:	e7ee      	b.n	4a64e <uECC_vli_nativeToBytes+0x6>

0004a670 <uECC_vli_bytesToNative>:

/* Converts big-endian bytes to an integer in uECC native format. */
void uECC_vli_bytesToNative(unsigned int *native, const uint8_t *bytes,
			    int num_bytes)
{
   4a670:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   4a672:	460e      	mov	r6, r1
	wordcount_t i;
	uECC_vli_clear(native, (num_bytes + (uECC_WORD_SIZE - 1)) / uECC_WORD_SIZE);
   4a674:	1cd1      	adds	r1, r2, #3
   4a676:	bf48      	it	mi
   4a678:	1d91      	addmi	r1, r2, #6
   4a67a:	f341 0187 	sbfx	r1, r1, #2, #8
{
   4a67e:	4614      	mov	r4, r2
	uECC_vli_clear(native, (num_bytes + (uECC_WORD_SIZE - 1)) / uECC_WORD_SIZE);
   4a680:	f7ff fae6 	bl	49c50 <uECC_vli_clear>
	for (i = 0; i < num_bytes; ++i) {
   4a684:	2500      	movs	r5, #0
		unsigned b = num_bytes - 1 - i;
   4a686:	1e67      	subs	r7, r4, #1
   4a688:	b26a      	sxtb	r2, r5
	for (i = 0; i < num_bytes; ++i) {
   4a68a:	42a2      	cmp	r2, r4
   4a68c:	f105 0501 	add.w	r5, r5, #1
   4a690:	db00      	blt.n	4a694 <uECC_vli_bytesToNative+0x24>
		native[b / uECC_WORD_SIZE] |=
			(uECC_word_t)bytes[i] << (8 * (b % uECC_WORD_SIZE));
  	}
}
   4a692:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		unsigned b = num_bytes - 1 - i;
   4a694:	1abb      	subs	r3, r7, r2
		native[b / uECC_WORD_SIZE] |=
   4a696:	f023 0103 	bic.w	r1, r3, #3
			(uECC_word_t)bytes[i] << (8 * (b % uECC_WORD_SIZE));
   4a69a:	5cb2      	ldrb	r2, [r6, r2]
   4a69c:	f003 0303 	and.w	r3, r3, #3
   4a6a0:	00db      	lsls	r3, r3, #3
   4a6a2:	409a      	lsls	r2, r3
		native[b / uECC_WORD_SIZE] |=
   4a6a4:	5843      	ldr	r3, [r0, r1]
   4a6a6:	4313      	orrs	r3, r2
   4a6a8:	5043      	str	r3, [r0, r1]
	for (i = 0; i < num_bytes; ++i) {
   4a6aa:	e7ed      	b.n	4a688 <uECC_vli_bytesToNative+0x18>

0004a6ac <uECC_valid_point>:
	return 0;
}


int uECC_valid_point(const uECC_word_t *point, uECC_Curve curve)
{
   4a6ac:	b5f0      	push	{r4, r5, r6, r7, lr}
   4a6ae:	b091      	sub	sp, #68	; 0x44
	uECC_word_t tmp1[NUM_ECC_WORDS];
	uECC_word_t tmp2[NUM_ECC_WORDS];
	wordcount_t num_words = curve->num_words;
   4a6b0:	f991 6000 	ldrsb.w	r6, [r1]
{
   4a6b4:	4605      	mov	r5, r0
   4a6b6:	460c      	mov	r4, r1

	/* The point at infinity is invalid. */
	if (EccPoint_isZero(point, curve)) {
   4a6b8:	f7ff fe1f 	bl	4a2fa <EccPoint_isZero>
   4a6bc:	bb28      	cbnz	r0, 4a70a <uECC_valid_point+0x5e>
		return -1;
	}

	/* x and y must be smaller than p. */
	if (uECC_vli_cmp_unsafe(curve->p, point, num_words) != 1 ||
   4a6be:	1d27      	adds	r7, r4, #4
   4a6c0:	4632      	mov	r2, r6
   4a6c2:	4629      	mov	r1, r5
   4a6c4:	4638      	mov	r0, r7
   4a6c6:	f7ff fb12 	bl	49cee <uECC_vli_cmp_unsafe>
   4a6ca:	2801      	cmp	r0, #1
   4a6cc:	d120      	bne.n	4a710 <uECC_valid_point+0x64>
		uECC_vli_cmp_unsafe(curve->p, point + num_words, num_words) != 1) {
   4a6ce:	4632      	mov	r2, r6
   4a6d0:	eb05 0186 	add.w	r1, r5, r6, lsl #2
   4a6d4:	4638      	mov	r0, r7
   4a6d6:	f7ff fb0a 	bl	49cee <uECC_vli_cmp_unsafe>
	if (uECC_vli_cmp_unsafe(curve->p, point, num_words) != 1 ||
   4a6da:	2801      	cmp	r0, #1
   4a6dc:	d118      	bne.n	4a710 <uECC_valid_point+0x64>
		return -2;
	}

	uECC_vli_modSquare_fast(tmp1, point + num_words, curve);
   4a6de:	4622      	mov	r2, r4
   4a6e0:	4668      	mov	r0, sp
   4a6e2:	f7ff fc1c 	bl	49f1e <uECC_vli_modSquare_fast>
	curve->x_side(tmp2, point, curve); /* tmp2 = x^3 + ax + b */
   4a6e6:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
   4a6ea:	4622      	mov	r2, r4
   4a6ec:	4629      	mov	r1, r5
   4a6ee:	a808      	add	r0, sp, #32
   4a6f0:	4798      	blx	r3

	/* Make sure that y^2 == x^3 + ax + b */
	if (uECC_vli_equal(tmp1, tmp2, num_words) != 0)
   4a6f2:	4632      	mov	r2, r6
   4a6f4:	a908      	add	r1, sp, #32
   4a6f6:	4668      	mov	r0, sp
   4a6f8:	f7ff fb0e 	bl	49d18 <uECC_vli_equal>
		return -3;

	return 0;
   4a6fc:	2800      	cmp	r0, #0
   4a6fe:	bf14      	ite	ne
   4a700:	f06f 0002 	mvnne.w	r0, #2
   4a704:	2000      	moveq	r0, #0
}
   4a706:	b011      	add	sp, #68	; 0x44
   4a708:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return -1;
   4a70a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   4a70e:	e7fa      	b.n	4a706 <uECC_valid_point+0x5a>
		return -2;
   4a710:	f06f 0001 	mvn.w	r0, #1
   4a714:	e7f7      	b.n	4a706 <uECC_valid_point+0x5a>

0004a716 <uECC_valid_public_key>:

int uECC_valid_public_key(const uint8_t *public_key, uECC_Curve curve)
{
   4a716:	b5f0      	push	{r4, r5, r6, r7, lr}
   4a718:	460c      	mov	r4, r1

	uECC_word_t _public[NUM_ECC_WORDS * 2];

	uECC_vli_bytesToNative(_public, public_key, curve->num_bytes);
   4a71a:	f991 7001 	ldrsb.w	r7, [r1, #1]
{
   4a71e:	b091      	sub	sp, #68	; 0x44
	uECC_vli_bytesToNative(
	_public + curve->num_words,
   4a720:	4626      	mov	r6, r4
	uECC_vli_bytesToNative(_public, public_key, curve->num_bytes);
   4a722:	4601      	mov	r1, r0
{
   4a724:	4605      	mov	r5, r0
	uECC_vli_bytesToNative(_public, public_key, curve->num_bytes);
   4a726:	463a      	mov	r2, r7
   4a728:	4668      	mov	r0, sp
   4a72a:	f7ff ffa1 	bl	4a670 <uECC_vli_bytesToNative>
	_public + curve->num_words,
   4a72e:	f916 0b44 	ldrsb.w	r0, [r6], #68
	uECC_vli_bytesToNative(
   4a732:	463a      	mov	r2, r7
   4a734:	19e9      	adds	r1, r5, r7
   4a736:	eb0d 0080 	add.w	r0, sp, r0, lsl #2
   4a73a:	f7ff ff99 	bl	4a670 <uECC_vli_bytesToNative>
	public_key + curve->num_bytes,
	curve->num_bytes);

	if (uECC_vli_cmp_unsafe(_public, curve->G, NUM_ECC_WORDS * 2) == 0) {
   4a73e:	2210      	movs	r2, #16
   4a740:	4631      	mov	r1, r6
   4a742:	4668      	mov	r0, sp
   4a744:	f7ff fad3 	bl	49cee <uECC_vli_cmp_unsafe>
   4a748:	b128      	cbz	r0, 4a756 <uECC_valid_public_key+0x40>
		return -4;
	}

	return uECC_valid_point(_public, curve);
   4a74a:	4621      	mov	r1, r4
   4a74c:	4668      	mov	r0, sp
   4a74e:	f7ff ffad 	bl	4a6ac <uECC_valid_point>
}
   4a752:	b011      	add	sp, #68	; 0x44
   4a754:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return -4;
   4a756:	f06f 0003 	mvn.w	r0, #3
   4a75a:	e7fa      	b.n	4a752 <uECC_valid_public_key+0x3c>

0004a75c <add_round_key>:
	s[0] ^= (uint8_t)(k[0] >> 24); s[1] ^= (uint8_t)(k[0] >> 16);
   4a75c:	78cb      	ldrb	r3, [r1, #3]
   4a75e:	7802      	ldrb	r2, [r0, #0]
   4a760:	4053      	eors	r3, r2
   4a762:	7003      	strb	r3, [r0, #0]
   4a764:	884b      	ldrh	r3, [r1, #2]
   4a766:	7842      	ldrb	r2, [r0, #1]
   4a768:	4053      	eors	r3, r2
   4a76a:	7043      	strb	r3, [r0, #1]
	s[2] ^= (uint8_t)(k[0] >> 8); s[3] ^= (uint8_t)(k[0]);
   4a76c:	680a      	ldr	r2, [r1, #0]
   4a76e:	7883      	ldrb	r3, [r0, #2]
   4a770:	ea83 2312 	eor.w	r3, r3, r2, lsr #8
   4a774:	7083      	strb	r3, [r0, #2]
   4a776:	680a      	ldr	r2, [r1, #0]
   4a778:	78c3      	ldrb	r3, [r0, #3]
   4a77a:	4053      	eors	r3, r2
   4a77c:	70c3      	strb	r3, [r0, #3]
	s[4] ^= (uint8_t)(k[1] >> 24); s[5] ^= (uint8_t)(k[1] >> 16);
   4a77e:	79cb      	ldrb	r3, [r1, #7]
   4a780:	7902      	ldrb	r2, [r0, #4]
   4a782:	4053      	eors	r3, r2
   4a784:	7103      	strb	r3, [r0, #4]
   4a786:	88cb      	ldrh	r3, [r1, #6]
   4a788:	7942      	ldrb	r2, [r0, #5]
   4a78a:	4053      	eors	r3, r2
   4a78c:	7143      	strb	r3, [r0, #5]
	s[6] ^= (uint8_t)(k[1] >> 8); s[7] ^= (uint8_t)(k[1]);
   4a78e:	684a      	ldr	r2, [r1, #4]
   4a790:	7983      	ldrb	r3, [r0, #6]
   4a792:	ea83 2312 	eor.w	r3, r3, r2, lsr #8
   4a796:	7183      	strb	r3, [r0, #6]
   4a798:	684a      	ldr	r2, [r1, #4]
   4a79a:	79c3      	ldrb	r3, [r0, #7]
   4a79c:	4053      	eors	r3, r2
   4a79e:	71c3      	strb	r3, [r0, #7]
	s[8] ^= (uint8_t)(k[2] >> 24); s[9] ^= (uint8_t)(k[2] >> 16);
   4a7a0:	7acb      	ldrb	r3, [r1, #11]
   4a7a2:	7a02      	ldrb	r2, [r0, #8]
   4a7a4:	4053      	eors	r3, r2
   4a7a6:	7203      	strb	r3, [r0, #8]
   4a7a8:	7a42      	ldrb	r2, [r0, #9]
   4a7aa:	894b      	ldrh	r3, [r1, #10]
   4a7ac:	4053      	eors	r3, r2
   4a7ae:	7243      	strb	r3, [r0, #9]
	s[10] ^= (uint8_t)(k[2] >> 8); s[11] ^= (uint8_t)(k[2]);
   4a7b0:	688a      	ldr	r2, [r1, #8]
   4a7b2:	7a83      	ldrb	r3, [r0, #10]
   4a7b4:	ea83 2312 	eor.w	r3, r3, r2, lsr #8
   4a7b8:	7283      	strb	r3, [r0, #10]
   4a7ba:	688a      	ldr	r2, [r1, #8]
   4a7bc:	7ac3      	ldrb	r3, [r0, #11]
   4a7be:	4053      	eors	r3, r2
   4a7c0:	72c3      	strb	r3, [r0, #11]
	s[12] ^= (uint8_t)(k[3] >> 24); s[13] ^= (uint8_t)(k[3] >> 16);
   4a7c2:	7bcb      	ldrb	r3, [r1, #15]
   4a7c4:	7b02      	ldrb	r2, [r0, #12]
   4a7c6:	4053      	eors	r3, r2
   4a7c8:	7303      	strb	r3, [r0, #12]
   4a7ca:	89cb      	ldrh	r3, [r1, #14]
   4a7cc:	7b42      	ldrb	r2, [r0, #13]
   4a7ce:	4053      	eors	r3, r2
   4a7d0:	7343      	strb	r3, [r0, #13]
	s[14] ^= (uint8_t)(k[3] >> 8); s[15] ^= (uint8_t)(k[3]);
   4a7d2:	68ca      	ldr	r2, [r1, #12]
   4a7d4:	7b83      	ldrb	r3, [r0, #14]
   4a7d6:	ea83 2312 	eor.w	r3, r3, r2, lsr #8
   4a7da:	7383      	strb	r3, [r0, #14]
   4a7dc:	68ca      	ldr	r2, [r1, #12]
   4a7de:	7bc3      	ldrb	r3, [r0, #15]
   4a7e0:	4053      	eors	r3, r2
   4a7e2:	73c3      	strb	r3, [r0, #15]
}
   4a7e4:	4770      	bx	lr

0004a7e6 <shift_rows>:
/*
 * This shift_rows also implements the matrix flip required for mix_columns, but
 * performs it here to reduce the number of memory operations.
 */
static inline void shift_rows(uint8_t *s)
{
   4a7e6:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	uint8_t t[Nb * Nk];

	t[0]  = s[0]; t[1] = s[5]; t[2] = s[10]; t[3] = s[15];
   4a7e8:	7802      	ldrb	r2, [r0, #0]
   4a7ea:	f88d 2000 	strb.w	r2, [sp]
   4a7ee:	7942      	ldrb	r2, [r0, #5]
   4a7f0:	f88d 2001 	strb.w	r2, [sp, #1]
   4a7f4:	7a82      	ldrb	r2, [r0, #10]
   4a7f6:	f88d 2002 	strb.w	r2, [sp, #2]
   4a7fa:	7bc2      	ldrb	r2, [r0, #15]
   4a7fc:	f88d 2003 	strb.w	r2, [sp, #3]
	t[4]  = s[4]; t[5] = s[9]; t[6] = s[14]; t[7] = s[3];
   4a800:	7902      	ldrb	r2, [r0, #4]
   4a802:	f88d 2004 	strb.w	r2, [sp, #4]
   4a806:	7a42      	ldrb	r2, [r0, #9]
   4a808:	f88d 2005 	strb.w	r2, [sp, #5]
   4a80c:	7b82      	ldrb	r2, [r0, #14]
   4a80e:	f88d 2006 	strb.w	r2, [sp, #6]
   4a812:	78c2      	ldrb	r2, [r0, #3]
   4a814:	f88d 2007 	strb.w	r2, [sp, #7]
	t[8]  = s[8]; t[9] = s[13]; t[10] = s[2]; t[11] = s[7];
   4a818:	7a02      	ldrb	r2, [r0, #8]
   4a81a:	f88d 2008 	strb.w	r2, [sp, #8]
   4a81e:	7b42      	ldrb	r2, [r0, #13]
   4a820:	f88d 2009 	strb.w	r2, [sp, #9]
   4a824:	7882      	ldrb	r2, [r0, #2]
   4a826:	f88d 200a 	strb.w	r2, [sp, #10]
   4a82a:	79c2      	ldrb	r2, [r0, #7]
   4a82c:	f88d 200b 	strb.w	r2, [sp, #11]
	t[12] = s[12]; t[13] = s[1]; t[14] = s[6]; t[15] = s[11];
   4a830:	7b02      	ldrb	r2, [r0, #12]
   4a832:	f88d 200c 	strb.w	r2, [sp, #12]
   4a836:	7842      	ldrb	r2, [r0, #1]
   4a838:	7ac3      	ldrb	r3, [r0, #11]
   4a83a:	f88d 200d 	strb.w	r2, [sp, #13]
   4a83e:	7982      	ldrb	r2, [r0, #6]
   4a840:	f88d 200e 	strb.w	r2, [sp, #14]
   4a844:	f88d 300f 	strb.w	r3, [sp, #15]
	(void) _copy(s, sizeof(t), t, sizeof(t));
   4a848:	2310      	movs	r3, #16
   4a84a:	466a      	mov	r2, sp
   4a84c:	4619      	mov	r1, r3
   4a84e:	f7ff f88c 	bl	4996a <_copy>
}
   4a852:	b005      	add	sp, #20
   4a854:	f85d fb04 	ldr.w	pc, [sp], #4

0004a858 <mult_row_column>:
{
   4a858:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   4a85a:	4606      	mov	r6, r0
	out[0] = _double_byte(in[0]) ^ triple(in[1]) ^ in[2] ^ in[3];
   4a85c:	7808      	ldrb	r0, [r1, #0]
{
   4a85e:	460c      	mov	r4, r1
	out[0] = _double_byte(in[0]) ^ triple(in[1]) ^ in[2] ^ in[3];
   4a860:	f7ff f892 	bl	49988 <_double_byte>
   4a864:	4605      	mov	r5, r0
   4a866:	7860      	ldrb	r0, [r4, #1]
   4a868:	f7ff f88e 	bl	49988 <_double_byte>
   4a86c:	78a2      	ldrb	r2, [r4, #2]
   4a86e:	7863      	ldrb	r3, [r4, #1]
   4a870:	4053      	eors	r3, r2
   4a872:	78e2      	ldrb	r2, [r4, #3]
   4a874:	4053      	eors	r3, r2
   4a876:	405d      	eors	r5, r3
   4a878:	4068      	eors	r0, r5
   4a87a:	7030      	strb	r0, [r6, #0]
	out[1] = in[0] ^ _double_byte(in[1]) ^ triple(in[2]) ^ in[3];
   4a87c:	7860      	ldrb	r0, [r4, #1]
   4a87e:	7827      	ldrb	r7, [r4, #0]
   4a880:	f7ff f882 	bl	49988 <_double_byte>
   4a884:	4605      	mov	r5, r0
   4a886:	78a0      	ldrb	r0, [r4, #2]
   4a888:	f7ff f87e 	bl	49988 <_double_byte>
   4a88c:	78a3      	ldrb	r3, [r4, #2]
   4a88e:	405f      	eors	r7, r3
   4a890:	78e3      	ldrb	r3, [r4, #3]
   4a892:	405f      	eors	r7, r3
   4a894:	407d      	eors	r5, r7
   4a896:	4068      	eors	r0, r5
   4a898:	7070      	strb	r0, [r6, #1]
	out[2] = in[0] ^ in[1] ^ _double_byte(in[2]) ^ triple(in[3]);
   4a89a:	7863      	ldrb	r3, [r4, #1]
   4a89c:	7827      	ldrb	r7, [r4, #0]
   4a89e:	78a0      	ldrb	r0, [r4, #2]
   4a8a0:	405f      	eors	r7, r3
   4a8a2:	f7ff f871 	bl	49988 <_double_byte>
   4a8a6:	4605      	mov	r5, r0
   4a8a8:	78e0      	ldrb	r0, [r4, #3]
   4a8aa:	f7ff f86d 	bl	49988 <_double_byte>
   4a8ae:	78e3      	ldrb	r3, [r4, #3]
   4a8b0:	405f      	eors	r7, r3
   4a8b2:	407d      	eors	r5, r7
   4a8b4:	4068      	eors	r0, r5
   4a8b6:	70b0      	strb	r0, [r6, #2]
	out[3] = triple(in[0]) ^ in[1] ^ in[2] ^ _double_byte(in[3]);
   4a8b8:	7820      	ldrb	r0, [r4, #0]
   4a8ba:	f7ff f865 	bl	49988 <_double_byte>
   4a8be:	7862      	ldrb	r2, [r4, #1]
   4a8c0:	7823      	ldrb	r3, [r4, #0]
   4a8c2:	4053      	eors	r3, r2
   4a8c4:	78a2      	ldrb	r2, [r4, #2]
   4a8c6:	4053      	eors	r3, r2
   4a8c8:	ea80 0503 	eor.w	r5, r0, r3
   4a8cc:	78e0      	ldrb	r0, [r4, #3]
   4a8ce:	f7ff f85b 	bl	49988 <_double_byte>
   4a8d2:	b2ed      	uxtb	r5, r5
   4a8d4:	4045      	eors	r5, r0
   4a8d6:	70f5      	strb	r5, [r6, #3]
}
   4a8d8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0004a8da <tc_aes_encrypt>:

int tc_aes_encrypt(uint8_t *out, const uint8_t *in, const TCAesKeySched_t s)
{
   4a8da:	b570      	push	{r4, r5, r6, lr}
   4a8dc:	4614      	mov	r4, r2
   4a8de:	b088      	sub	sp, #32
	uint8_t state[Nk*Nb];
	unsigned int i;

	if (out == (uint8_t *) 0) {
   4a8e0:	4605      	mov	r5, r0
   4a8e2:	2800      	cmp	r0, #0
   4a8e4:	d049      	beq.n	4a97a <tc_aes_encrypt+0xa0>
		return TC_CRYPTO_FAIL;
	} else if (in == (const uint8_t *) 0) {
   4a8e6:	2900      	cmp	r1, #0
   4a8e8:	d049      	beq.n	4a97e <tc_aes_encrypt+0xa4>
		return TC_CRYPTO_FAIL;
	} else if (s == (TCAesKeySched_t) 0) {
   4a8ea:	2a00      	cmp	r2, #0
   4a8ec:	d049      	beq.n	4a982 <tc_aes_encrypt+0xa8>
		return TC_CRYPTO_FAIL;
	}

	(void)_copy(state, sizeof(state), in, sizeof(state));
   4a8ee:	2310      	movs	r3, #16
   4a8f0:	460a      	mov	r2, r1
   4a8f2:	4668      	mov	r0, sp
   4a8f4:	4619      	mov	r1, r3
   4a8f6:	f7ff f838 	bl	4996a <_copy>
	add_round_key(state, s->words);
   4a8fa:	4621      	mov	r1, r4
   4a8fc:	4668      	mov	r0, sp
   4a8fe:	f7ff ff2d 	bl	4a75c <add_round_key>

	for (i = 0; i < (Nr - 1); ++i) {
   4a902:	3410      	adds	r4, #16
   4a904:	f101 06a0 	add.w	r6, r1, #160	; 0xa0
		sub_bytes(state);
   4a908:	4668      	mov	r0, sp
   4a90a:	f7e2 f9d7 	bl	2ccbc <sub_bytes>
		shift_rows(state);
   4a90e:	4668      	mov	r0, sp
   4a910:	f7ff ff69 	bl	4a7e6 <shift_rows>
	mult_row_column(t, s);
   4a914:	4669      	mov	r1, sp
   4a916:	a804      	add	r0, sp, #16
   4a918:	f7ff ff9e 	bl	4a858 <mult_row_column>
	mult_row_column(&t[Nb], s+Nb);
   4a91c:	a901      	add	r1, sp, #4
   4a91e:	a805      	add	r0, sp, #20
   4a920:	f7ff ff9a 	bl	4a858 <mult_row_column>
	mult_row_column(&t[2 * Nb], s + (2 * Nb));
   4a924:	a902      	add	r1, sp, #8
   4a926:	a806      	add	r0, sp, #24
   4a928:	f7ff ff96 	bl	4a858 <mult_row_column>
	mult_row_column(&t[3 * Nb], s + (3 * Nb));
   4a92c:	a903      	add	r1, sp, #12
   4a92e:	a807      	add	r0, sp, #28
   4a930:	f7ff ff92 	bl	4a858 <mult_row_column>
	(void) _copy(s, sizeof(t), t, sizeof(t));
   4a934:	2310      	movs	r3, #16
   4a936:	4619      	mov	r1, r3
   4a938:	eb0d 0203 	add.w	r2, sp, r3
   4a93c:	4668      	mov	r0, sp
   4a93e:	f7ff f814 	bl	4996a <_copy>
		mix_columns(state);
		add_round_key(state, s->words + Nb*(i+1));
   4a942:	4621      	mov	r1, r4
   4a944:	4668      	mov	r0, sp
	for (i = 0; i < (Nr - 1); ++i) {
   4a946:	3410      	adds	r4, #16
		add_round_key(state, s->words + Nb*(i+1));
   4a948:	f7ff ff08 	bl	4a75c <add_round_key>
	for (i = 0; i < (Nr - 1); ++i) {
   4a94c:	42b4      	cmp	r4, r6
   4a94e:	d1db      	bne.n	4a908 <tc_aes_encrypt+0x2e>
	}

	sub_bytes(state);
   4a950:	f7e2 f9b4 	bl	2ccbc <sub_bytes>
	shift_rows(state);
   4a954:	4668      	mov	r0, sp
   4a956:	f7ff ff46 	bl	4a7e6 <shift_rows>
	add_round_key(state, s->words + Nb*(i+1));
   4a95a:	4621      	mov	r1, r4
   4a95c:	4668      	mov	r0, sp
   4a95e:	f7ff fefd 	bl	4a75c <add_round_key>

	(void)_copy(out, sizeof(state), state, sizeof(state));
   4a962:	2310      	movs	r3, #16
   4a964:	4619      	mov	r1, r3
   4a966:	466a      	mov	r2, sp
   4a968:	4628      	mov	r0, r5
   4a96a:	f7fe fffe 	bl	4996a <_copy>

	/* zeroing out the state buffer */
	_set(state, TC_ZERO_BYTE, sizeof(state));
   4a96e:	4668      	mov	r0, sp
   4a970:	2210      	movs	r2, #16
   4a972:	2100      	movs	r1, #0
   4a974:	f7ff f806 	bl	49984 <_set>

	return TC_CRYPTO_SUCCESS;
   4a978:	2001      	movs	r0, #1
}
   4a97a:	b008      	add	sp, #32
   4a97c:	bd70      	pop	{r4, r5, r6, pc}
		return TC_CRYPTO_FAIL;
   4a97e:	4608      	mov	r0, r1
   4a980:	e7fb      	b.n	4a97a <tc_aes_encrypt+0xa0>
   4a982:	4610      	mov	r0, r2
   4a984:	e7f9      	b.n	4a97a <tc_aes_encrypt+0xa0>

0004a986 <gf_double>:
 *           the in and out buffers do not overlap.
 *  effects: doubles the GF(2^n) value pointed to by "in" and places
 *           the result in the GF(2^n) value pointed to by "out."
 */
void gf_double(uint8_t *out, uint8_t *in)
{
   4a986:	b510      	push	{r4, lr}

	/* start with low order byte */
	uint8_t *x = in + (TC_AES_BLOCK_SIZE - 1);

	/* if msb == 1, we need to add the gf_wrap value, otherwise add 0 */
	uint8_t carry = (in[0] >> 7) ? gf_wrap : 0;
   4a988:	460a      	mov	r2, r1

	out += (TC_AES_BLOCK_SIZE - 1);
   4a98a:	300f      	adds	r0, #15
	uint8_t carry = (in[0] >> 7) ? gf_wrap : 0;
   4a98c:	f912 3b10 	ldrsb.w	r3, [r2], #16
   4a990:	2b00      	cmp	r3, #0
   4a992:	bfac      	ite	ge
   4a994:	2300      	movge	r3, #0
   4a996:	2387      	movlt	r3, #135	; 0x87
	for (;;) {
		*out-- = (*x << 1) ^ carry;
   4a998:	f812 4d01 	ldrb.w	r4, [r2, #-1]!
   4a99c:	ea83 0344 	eor.w	r3, r3, r4, lsl #1
		if (x == in) {
   4a9a0:	428a      	cmp	r2, r1
		*out-- = (*x << 1) ^ carry;
   4a9a2:	f800 3901 	strb.w	r3, [r0], #-1
		if (x == in) {
   4a9a6:	d002      	beq.n	4a9ae <gf_double+0x28>
			break;
		}
		carry = *x-- >> 7;
   4a9a8:	7813      	ldrb	r3, [r2, #0]
   4a9aa:	09db      	lsrs	r3, r3, #7
		*out-- = (*x << 1) ^ carry;
   4a9ac:	e7f4      	b.n	4a998 <gf_double+0x12>
	}
}
   4a9ae:	bd10      	pop	{r4, pc}

0004a9b0 <tc_cmac_erase>:

	return TC_CRYPTO_SUCCESS;
}

int tc_cmac_erase(TCCmacState_t s)
{
   4a9b0:	b508      	push	{r3, lr}
	if (s == (TCCmacState_t) 0) {
   4a9b2:	b120      	cbz	r0, 4a9be <tc_cmac_erase+0xe>
		return TC_CRYPTO_FAIL;
	}

	/* destroy the current state */
	_set(s, 0, sizeof(*s));
   4a9b4:	2258      	movs	r2, #88	; 0x58
   4a9b6:	2100      	movs	r1, #0
   4a9b8:	f7fe ffe4 	bl	49984 <_set>
   4a9bc:	2001      	movs	r0, #1

	return TC_CRYPTO_SUCCESS;
}
   4a9be:	bd08      	pop	{r3, pc}

0004a9c0 <tc_cmac_init>:

int tc_cmac_init(TCCmacState_t s)
{
   4a9c0:	b510      	push	{r4, lr}
	/* input sanity check: */
	if (s == (TCCmacState_t) 0) {
   4a9c2:	4604      	mov	r4, r0
   4a9c4:	b188      	cbz	r0, 4a9ea <tc_cmac_init+0x2a>
		return TC_CRYPTO_FAIL;
	}

	/* CMAC starts with an all zero initialization vector */
	_set(s->iv, 0, TC_AES_BLOCK_SIZE);
   4a9c6:	2210      	movs	r2, #16
   4a9c8:	2100      	movs	r1, #0
   4a9ca:	f7fe ffdb 	bl	49984 <_set>

	/* and the leftover buffer is empty */
	_set(s->leftover, 0, TC_AES_BLOCK_SIZE);
   4a9ce:	2210      	movs	r2, #16
   4a9d0:	f104 0030 	add.w	r0, r4, #48	; 0x30
   4a9d4:	2100      	movs	r1, #0
   4a9d6:	f7fe ffd5 	bl	49984 <_set>
	s->leftover_offset = 0;
   4a9da:	2300      	movs	r3, #0
   4a9dc:	6463      	str	r3, [r4, #68]	; 0x44

	/* Set countdown to max number of calls allowed before re-keying: */
	s->countdown = MAX_CALLS;
   4a9de:	2200      	movs	r2, #0
   4a9e0:	f44f 3380 	mov.w	r3, #65536	; 0x10000
   4a9e4:	e9c4 2314 	strd	r2, r3, [r4, #80]	; 0x50
   4a9e8:	2001      	movs	r0, #1

	return TC_CRYPTO_SUCCESS;
}
   4a9ea:	bd10      	pop	{r4, pc}

0004a9ec <tc_cmac_setup>:
{
   4a9ec:	b570      	push	{r4, r5, r6, lr}
   4a9ee:	4604      	mov	r4, r0
   4a9f0:	460d      	mov	r5, r1
   4a9f2:	4616      	mov	r6, r2
	if (s == (TCCmacState_t) 0 ||
   4a9f4:	b310      	cbz	r0, 4aa3c <tc_cmac_setup+0x50>
   4a9f6:	b311      	cbz	r1, 4aa3e <tc_cmac_setup+0x52>
	_set(s, 0, sizeof(*s));
   4a9f8:	2258      	movs	r2, #88	; 0x58
   4a9fa:	2100      	movs	r1, #0
   4a9fc:	f7fe ffc2 	bl	49984 <_set>
	tc_aes128_set_encrypt_key(s->sched, key);
   4aa00:	4629      	mov	r1, r5
	s->sched = sched;
   4aa02:	64a6      	str	r6, [r4, #72]	; 0x48
	tc_aes128_set_encrypt_key(s->sched, key);
   4aa04:	4630      	mov	r0, r6
   4aa06:	f7e2 f965 	bl	2ccd4 <tc_aes128_set_encrypt_key>
	_set(s->iv, 0, TC_AES_BLOCK_SIZE);
   4aa0a:	2210      	movs	r2, #16
   4aa0c:	2100      	movs	r1, #0
   4aa0e:	4620      	mov	r0, r4
   4aa10:	f7fe ffb8 	bl	49984 <_set>
	gf_double (s->K1, s->iv);
   4aa14:	f104 0510 	add.w	r5, r4, #16
	tc_aes_encrypt(s->iv, s->iv, s->sched);
   4aa18:	6ca2      	ldr	r2, [r4, #72]	; 0x48
   4aa1a:	4621      	mov	r1, r4
   4aa1c:	4620      	mov	r0, r4
   4aa1e:	f7ff ff5c 	bl	4a8da <tc_aes_encrypt>
	gf_double (s->K1, s->iv);
   4aa22:	4621      	mov	r1, r4
   4aa24:	4628      	mov	r0, r5
   4aa26:	f7ff ffae 	bl	4a986 <gf_double>
	gf_double (s->K2, s->K1);
   4aa2a:	4629      	mov	r1, r5
   4aa2c:	f104 0020 	add.w	r0, r4, #32
   4aa30:	f7ff ffa9 	bl	4a986 <gf_double>
	tc_cmac_init(s);
   4aa34:	4620      	mov	r0, r4
   4aa36:	f7ff ffc3 	bl	4a9c0 <tc_cmac_init>
	return TC_CRYPTO_SUCCESS;
   4aa3a:	2001      	movs	r0, #1
}
   4aa3c:	bd70      	pop	{r4, r5, r6, pc}
		return TC_CRYPTO_FAIL;
   4aa3e:	4608      	mov	r0, r1
   4aa40:	e7fc      	b.n	4aa3c <tc_cmac_setup+0x50>

0004aa42 <tc_cmac_update>:

int tc_cmac_update(TCCmacState_t s, const uint8_t *data, size_t data_length)
{
   4aa42:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4aa46:	460e      	mov	r6, r1
   4aa48:	4615      	mov	r5, r2
	unsigned int i;

	/* input sanity check: */
	if (s == (TCCmacState_t) 0) {
   4aa4a:	4604      	mov	r4, r0
   4aa4c:	2800      	cmp	r0, #0
   4aa4e:	d060      	beq.n	4ab12 <tc_cmac_update+0xd0>
		return TC_CRYPTO_FAIL;
	}
	if (data_length == 0) {
   4aa50:	b1fa      	cbz	r2, 4aa92 <tc_cmac_update+0x50>
		return  TC_CRYPTO_SUCCESS;
	}
	if (data == (const uint8_t *) 0) {
   4aa52:	2900      	cmp	r1, #0
   4aa54:	d05d      	beq.n	4ab12 <tc_cmac_update+0xd0>
		return TC_CRYPTO_FAIL;
	}

	if (s->countdown == 0) {
   4aa56:	e9d0 3214 	ldrd	r3, r2, [r0, #80]	; 0x50
   4aa5a:	ea53 0102 	orrs.w	r1, r3, r2
   4aa5e:	d058      	beq.n	4ab12 <tc_cmac_update+0xd0>
		return TC_CRYPTO_FAIL;
	}

	s->countdown--;
   4aa60:	3b01      	subs	r3, #1

	if (s->leftover_offset > 0) {
   4aa62:	f8d0 8044 	ldr.w	r8, [r0, #68]	; 0x44
	s->countdown--;
   4aa66:	f142 32ff 	adc.w	r2, r2, #4294967295	; 0xffffffff
   4aa6a:	e9c0 3214 	strd	r3, r2, [r0, #80]	; 0x50
	if (s->leftover_offset > 0) {
   4aa6e:	f1b8 0f00 	cmp.w	r8, #0
   4aa72:	d02c      	beq.n	4aace <tc_cmac_update+0x8c>
		/* last data added to s didn't end on a TC_AES_BLOCK_SIZE byte boundary */
		size_t remaining_space = TC_AES_BLOCK_SIZE - s->leftover_offset;
   4aa74:	f1c8 0710 	rsb	r7, r8, #16

		if (data_length < remaining_space) {
			/* still not enough data to encrypt this time either */
			_copy(&s->leftover[s->leftover_offset], data_length, data, data_length);
   4aa78:	f108 0030 	add.w	r0, r8, #48	; 0x30
		if (data_length < remaining_space) {
   4aa7c:	42bd      	cmp	r5, r7
			_copy(&s->leftover[s->leftover_offset], data_length, data, data_length);
   4aa7e:	4420      	add	r0, r4
		if (data_length < remaining_space) {
   4aa80:	d20a      	bcs.n	4aa98 <tc_cmac_update+0x56>
			_copy(&s->leftover[s->leftover_offset], data_length, data, data_length);
   4aa82:	462b      	mov	r3, r5
   4aa84:	4632      	mov	r2, r6
   4aa86:	4629      	mov	r1, r5
   4aa88:	f7fe ff6f 	bl	4996a <_copy>
			s->leftover_offset += data_length;
   4aa8c:	6c63      	ldr	r3, [r4, #68]	; 0x44
   4aa8e:	442b      	add	r3, r5
   4aa90:	6463      	str	r3, [r4, #68]	; 0x44
		return  TC_CRYPTO_SUCCESS;
   4aa92:	2001      	movs	r0, #1
		_copy(s->leftover, data_length, data, data_length);
		s->leftover_offset = data_length;
	}

	return TC_CRYPTO_SUCCESS;
}
   4aa94:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		_copy(&s->leftover[s->leftover_offset],
   4aa98:	463b      	mov	r3, r7
   4aa9a:	4632      	mov	r2, r6
   4aa9c:	4639      	mov	r1, r7
   4aa9e:	f7fe ff64 	bl	4996a <_copy>
		data_length -= remaining_space;
   4aaa2:	3d10      	subs	r5, #16
		s->leftover_offset = 0;
   4aaa4:	2300      	movs	r3, #0
   4aaa6:	6463      	str	r3, [r4, #68]	; 0x44
		data_length -= remaining_space;
   4aaa8:	4445      	add	r5, r8
		data += remaining_space;
   4aaaa:	443e      	add	r6, r7
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   4aaac:	1e63      	subs	r3, r4, #1
   4aaae:	f104 010f 	add.w	r1, r4, #15
			s->iv[i] ^= s->leftover[i];
   4aab2:	f813 2f01 	ldrb.w	r2, [r3, #1]!
   4aab6:	f893 0030 	ldrb.w	r0, [r3, #48]	; 0x30
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   4aaba:	428b      	cmp	r3, r1
			s->iv[i] ^= s->leftover[i];
   4aabc:	ea82 0200 	eor.w	r2, r2, r0
   4aac0:	701a      	strb	r2, [r3, #0]
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   4aac2:	d1f6      	bne.n	4aab2 <tc_cmac_update+0x70>
		tc_aes_encrypt(s->iv, s->iv, s->sched);
   4aac4:	6ca2      	ldr	r2, [r4, #72]	; 0x48
   4aac6:	4621      	mov	r1, r4
   4aac8:	4620      	mov	r0, r4
   4aaca:	f7ff ff06 	bl	4a8da <tc_aes_encrypt>
   4aace:	f104 070f 	add.w	r7, r4, #15
	while (data_length > TC_AES_BLOCK_SIZE) {
   4aad2:	2d10      	cmp	r5, #16
   4aad4:	d80a      	bhi.n	4aaec <tc_cmac_update+0xaa>
	if (data_length > 0) {
   4aad6:	2d00      	cmp	r5, #0
   4aad8:	d0db      	beq.n	4aa92 <tc_cmac_update+0x50>
		_copy(s->leftover, data_length, data, data_length);
   4aada:	462b      	mov	r3, r5
   4aadc:	4632      	mov	r2, r6
   4aade:	4629      	mov	r1, r5
   4aae0:	f104 0030 	add.w	r0, r4, #48	; 0x30
   4aae4:	f7fe ff41 	bl	4996a <_copy>
		s->leftover_offset = data_length;
   4aae8:	6465      	str	r5, [r4, #68]	; 0x44
   4aaea:	e7d2      	b.n	4aa92 <tc_cmac_update+0x50>
   4aaec:	1e63      	subs	r3, r4, #1
   4aaee:	1e71      	subs	r1, r6, #1
			s->iv[i] ^= data[i];
   4aaf0:	f813 2f01 	ldrb.w	r2, [r3, #1]!
   4aaf4:	f811 0f01 	ldrb.w	r0, [r1, #1]!
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   4aaf8:	42bb      	cmp	r3, r7
			s->iv[i] ^= data[i];
   4aafa:	ea82 0200 	eor.w	r2, r2, r0
   4aafe:	701a      	strb	r2, [r3, #0]
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   4ab00:	d1f6      	bne.n	4aaf0 <tc_cmac_update+0xae>
		tc_aes_encrypt(s->iv, s->iv, s->sched);
   4ab02:	6ca2      	ldr	r2, [r4, #72]	; 0x48
   4ab04:	4621      	mov	r1, r4
   4ab06:	4620      	mov	r0, r4
   4ab08:	f7ff fee7 	bl	4a8da <tc_aes_encrypt>
		data += TC_AES_BLOCK_SIZE;
   4ab0c:	3610      	adds	r6, #16
		data_length  -= TC_AES_BLOCK_SIZE;
   4ab0e:	3d10      	subs	r5, #16
   4ab10:	e7df      	b.n	4aad2 <tc_cmac_update+0x90>
		return TC_CRYPTO_FAIL;
   4ab12:	2000      	movs	r0, #0
   4ab14:	e7be      	b.n	4aa94 <tc_cmac_update+0x52>

0004ab16 <tc_cmac_final>:

int tc_cmac_final(uint8_t *tag, TCCmacState_t s)
{
   4ab16:	b570      	push	{r4, r5, r6, lr}
   4ab18:	460c      	mov	r4, r1
	uint8_t *k;
	unsigned int i;

	/* input sanity check: */
	if (tag == (uint8_t *) 0 ||
   4ab1a:	4605      	mov	r5, r0
   4ab1c:	b1e8      	cbz	r0, 4ab5a <tc_cmac_final+0x44>
   4ab1e:	b369      	cbz	r1, 4ab7c <tc_cmac_final+0x66>
	    s == (TCCmacState_t) 0) {
		return TC_CRYPTO_FAIL;
	}

	if (s->leftover_offset == TC_AES_BLOCK_SIZE) {
   4ab20:	6c4a      	ldr	r2, [r1, #68]	; 0x44
   4ab22:	2a10      	cmp	r2, #16
   4ab24:	d11a      	bne.n	4ab5c <tc_cmac_final+0x46>
		/* the last message block is a full-sized block */
		k = (uint8_t *) s->K1;
   4ab26:	3110      	adds	r1, #16

		_set(&s->leftover[s->leftover_offset], 0, remaining);
		s->leftover[s->leftover_offset] = TC_CMAC_PADDING;
		k = (uint8_t *) s->K2;
	}
	for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   4ab28:	1e63      	subs	r3, r4, #1
   4ab2a:	3901      	subs	r1, #1
   4ab2c:	f104 000f 	add.w	r0, r4, #15
		s->iv[i] ^= s->leftover[i] ^ k[i];
   4ab30:	f813 2f01 	ldrb.w	r2, [r3, #1]!
   4ab34:	f893 6030 	ldrb.w	r6, [r3, #48]	; 0x30
   4ab38:	4072      	eors	r2, r6
   4ab3a:	f811 6f01 	ldrb.w	r6, [r1, #1]!
	for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   4ab3e:	4298      	cmp	r0, r3
		s->iv[i] ^= s->leftover[i] ^ k[i];
   4ab40:	ea82 0206 	eor.w	r2, r2, r6
   4ab44:	701a      	strb	r2, [r3, #0]
	for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   4ab46:	d1f3      	bne.n	4ab30 <tc_cmac_final+0x1a>
	}

	tc_aes_encrypt(tag, s->iv, s->sched);
   4ab48:	6ca2      	ldr	r2, [r4, #72]	; 0x48
   4ab4a:	4621      	mov	r1, r4
   4ab4c:	4628      	mov	r0, r5
   4ab4e:	f7ff fec4 	bl	4a8da <tc_aes_encrypt>

	/* erasing state: */
	tc_cmac_erase(s);
   4ab52:	4620      	mov	r0, r4
   4ab54:	f7ff ff2c 	bl	4a9b0 <tc_cmac_erase>

	return TC_CRYPTO_SUCCESS;
   4ab58:	2001      	movs	r0, #1
}
   4ab5a:	bd70      	pop	{r4, r5, r6, pc}
		_set(&s->leftover[s->leftover_offset], 0, remaining);
   4ab5c:	f102 0030 	add.w	r0, r2, #48	; 0x30
   4ab60:	2100      	movs	r1, #0
   4ab62:	f1c2 0210 	rsb	r2, r2, #16
   4ab66:	4420      	add	r0, r4
   4ab68:	f7fe ff0c 	bl	49984 <_set>
		s->leftover[s->leftover_offset] = TC_CMAC_PADDING;
   4ab6c:	6c63      	ldr	r3, [r4, #68]	; 0x44
   4ab6e:	4423      	add	r3, r4
   4ab70:	2280      	movs	r2, #128	; 0x80
   4ab72:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
		k = (uint8_t *) s->K2;
   4ab76:	f104 0120 	add.w	r1, r4, #32
   4ab7a:	e7d5      	b.n	4ab28 <tc_cmac_final+0x12>
		return TC_CRYPTO_FAIL;
   4ab7c:	4608      	mov	r0, r1
   4ab7e:	e7ec      	b.n	4ab5a <tc_cmac_final+0x44>

0004ab80 <z_arm_fatal_error>:
{

	if (esf != NULL) {
		esf_dump(esf);
	}
	z_fatal_error(reason, esf);
   4ab80:	f004 bf97 	b.w	4fab2 <z_fatal_error>

0004ab84 <z_do_kernel_oops>:
 *
 * @param esf exception frame
 * @param callee_regs Callee-saved registers (R4-R11)
 */
void z_do_kernel_oops(const z_arch_esf_t *esf, _callee_saved_t *callee_regs)
{
   4ab84:	4601      	mov	r1, r0
	z_fatal_error(reason, esf);
   4ab86:	6800      	ldr	r0, [r0, #0]
   4ab88:	f004 bf93 	b.w	4fab2 <z_fatal_error>

0004ab8c <z_irq_spurious>:
	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
   4ab8c:	2100      	movs	r1, #0
   4ab8e:	2001      	movs	r0, #1
   4ab90:	f7ff bff6 	b.w	4ab80 <z_arm_fatal_error>

0004ab94 <z_arm_nmi>:
 * Simply call what is installed in 'static void(*handler)(void)'.
 *
 */

void z_arm_nmi(void)
{
   4ab94:	b508      	push	{r3, lr}
	handler();
   4ab96:	f7e2 f963 	bl	2ce60 <z_SysNmiOnReset>
	z_arm_int_exit();
}
   4ab9a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_int_exit();
   4ab9e:	f7e2 ba23 	b.w	2cfe8 <z_arm_exc_exit>

0004aba2 <atoi>:

#include <stdlib.h>
#include <ctype.h>

int atoi(const char *s)
{
   4aba2:	b510      	push	{r4, lr}
	int n = 0;
	int neg = 0;

	while (isspace((unsigned char)*s)) {
   4aba4:	7802      	ldrb	r2, [r0, #0]
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
}

static inline int isspace(int c)
{
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
   4aba6:	2a20      	cmp	r2, #32
   4aba8:	4603      	mov	r3, r0
   4abaa:	f100 0001 	add.w	r0, r0, #1
   4abae:	d0f9      	beq.n	4aba4 <atoi+0x2>
   4abb0:	f1a2 0109 	sub.w	r1, r2, #9
   4abb4:	2904      	cmp	r1, #4
   4abb6:	d9f5      	bls.n	4aba4 <atoi+0x2>
		s++;
	}
	switch (*s) {
   4abb8:	2a2b      	cmp	r2, #43	; 0x2b
   4abba:	d008      	beq.n	4abce <atoi+0x2c>
	case '-':
		neg = 1;
		s++;
   4abbc:	2a2d      	cmp	r2, #45	; 0x2d
   4abbe:	bf0a      	itet	eq
   4abc0:	4603      	moveq	r3, r0
   4abc2:	2100      	movne	r1, #0
   4abc4:	2101      	moveq	r1, #1
   4abc6:	3b01      	subs	r3, #1
		neg = 1;
   4abc8:	2000      	movs	r0, #0
		 */
		break;
	}
	/* Compute n as a negative number to avoid overflow on INT_MIN */
	while (isdigit((unsigned char)*s)) {
		n = 10*n - (*s++ - '0');
   4abca:	240a      	movs	r4, #10
   4abcc:	e004      	b.n	4abd8 <atoi+0x36>
		s++;
   4abce:	4603      	mov	r3, r0
	int neg = 0;
   4abd0:	2100      	movs	r1, #0
   4abd2:	e7f8      	b.n	4abc6 <atoi+0x24>
		n = 10*n - (*s++ - '0');
   4abd4:	4360      	muls	r0, r4
   4abd6:	1a80      	subs	r0, r0, r2
	while (isdigit((unsigned char)*s)) {
   4abd8:	f813 2f01 	ldrb.w	r2, [r3, #1]!
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
   4abdc:	3a30      	subs	r2, #48	; 0x30
   4abde:	2a09      	cmp	r2, #9
   4abe0:	d9f8      	bls.n	4abd4 <atoi+0x32>
	}
	return neg ? n : -n;
   4abe2:	b901      	cbnz	r1, 4abe6 <atoi+0x44>
   4abe4:	4240      	negs	r0, r0
}
   4abe6:	bd10      	pop	{r4, pc}

0004abe8 <strtoul>:
 *
 * Ignores `locale' stuff.  Assumes that the upper and lower case
 * alphabets and digits are each contiguous.
 */
unsigned long strtoul(const char *nptr, char **endptr, register int base)
{
   4abe8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4abec:	4684      	mov	ip, r0
   4abee:	460f      	mov	r7, r1
	register const char *s = nptr;
   4abf0:	4604      	mov	r4, r0

	/*
	 * See strtol for comments as to the logic used.
	 */
	do {
		c = *s++;
   4abf2:	4621      	mov	r1, r4
   4abf4:	f814 3b01 	ldrb.w	r3, [r4], #1
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
   4abf8:	2b20      	cmp	r3, #32
   4abfa:	d0fa      	beq.n	4abf2 <strtoul+0xa>
   4abfc:	f1a3 0009 	sub.w	r0, r3, #9
   4ac00:	2804      	cmp	r0, #4
   4ac02:	d9f6      	bls.n	4abf2 <strtoul+0xa>
	} while (isspace((unsigned char)c));
	if (c == '-') {
   4ac04:	2b2d      	cmp	r3, #45	; 0x2d
   4ac06:	d125      	bne.n	4ac54 <strtoul+0x6c>
		neg = 1;
		c = *s++;
   4ac08:	784b      	ldrb	r3, [r1, #1]
   4ac0a:	1c8c      	adds	r4, r1, #2
		neg = 1;
   4ac0c:	f04f 0e01 	mov.w	lr, #1
	} else if (c == '+') {
		c = *s++;
	}

	if ((base == 0 || base == 16) &&
   4ac10:	bb3a      	cbnz	r2, 4ac62 <strtoul+0x7a>
   4ac12:	2b30      	cmp	r3, #48	; 0x30
   4ac14:	d032      	beq.n	4ac7c <strtoul+0x94>
		s += 2;
		base = 16;
	}

	if (base == 0) {
		base = c == '0' ? 8 : 10;
   4ac16:	220a      	movs	r2, #10
	}

	cutoff = (unsigned long)ULONG_MAX / (unsigned long)base;
   4ac18:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
	cutlim = (unsigned long)ULONG_MAX % (unsigned long)base;
	for (acc = 0, any = 0;; c = *s++) {
   4ac1c:	2500      	movs	r5, #0
	cutoff = (unsigned long)ULONG_MAX / (unsigned long)base;
   4ac1e:	fbb1 f1f2 	udiv	r1, r1, r2
	cutlim = (unsigned long)ULONG_MAX % (unsigned long)base;
   4ac22:	fb02 f801 	mul.w	r8, r2, r1
   4ac26:	ea6f 0808 	mvn.w	r8, r8
	for (acc = 0, any = 0;; c = *s++) {
   4ac2a:	4628      	mov	r0, r5
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
   4ac2c:	f1a3 0630 	sub.w	r6, r3, #48	; 0x30
		if (isdigit((unsigned char)c)) {
   4ac30:	2e09      	cmp	r6, #9
   4ac32:	d82a      	bhi.n	4ac8a <strtoul+0xa2>
			c -= '0';
   4ac34:	4633      	mov	r3, r6
		} else if (isalpha((unsigned char)c)) {
			c -= isupper((unsigned char)c) ? 'A' - 10 : 'a' - 10;
		} else {
			break;
		}
		if (c >= base) {
   4ac36:	429a      	cmp	r2, r3
   4ac38:	dd37      	ble.n	4acaa <strtoul+0xc2>
			break;
		}
		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim)) {
   4ac3a:	1c6e      	adds	r6, r5, #1
   4ac3c:	d007      	beq.n	4ac4e <strtoul+0x66>
   4ac3e:	4288      	cmp	r0, r1
   4ac40:	d830      	bhi.n	4aca4 <strtoul+0xbc>
   4ac42:	d101      	bne.n	4ac48 <strtoul+0x60>
   4ac44:	4543      	cmp	r3, r8
   4ac46:	dc2d      	bgt.n	4aca4 <strtoul+0xbc>
			any = -1;
		} else {
			any = 1;
			acc *= base;
			acc += c;
   4ac48:	fb00 3002 	mla	r0, r0, r2, r3
			any = 1;
   4ac4c:	2501      	movs	r5, #1
	for (acc = 0, any = 0;; c = *s++) {
   4ac4e:	f814 3b01 	ldrb.w	r3, [r4], #1
		if (isdigit((unsigned char)c)) {
   4ac52:	e7eb      	b.n	4ac2c <strtoul+0x44>
	} else if (c == '+') {
   4ac54:	2b2b      	cmp	r3, #43	; 0x2b
		c = *s++;
   4ac56:	bf04      	itt	eq
   4ac58:	784b      	ldrbeq	r3, [r1, #1]
   4ac5a:	1c8c      	addeq	r4, r1, #2
	register int neg = 0, any, cutlim;
   4ac5c:	f04f 0e00 	mov.w	lr, #0
   4ac60:	e7d6      	b.n	4ac10 <strtoul+0x28>
	if ((base == 0 || base == 16) &&
   4ac62:	2a10      	cmp	r2, #16
   4ac64:	d1d8      	bne.n	4ac18 <strtoul+0x30>
   4ac66:	2b30      	cmp	r3, #48	; 0x30
   4ac68:	d1d6      	bne.n	4ac18 <strtoul+0x30>
	    c == '0' && (*s == 'x' || *s == 'X')) {
   4ac6a:	7821      	ldrb	r1, [r4, #0]
   4ac6c:	f001 01df 	and.w	r1, r1, #223	; 0xdf
   4ac70:	2958      	cmp	r1, #88	; 0x58
   4ac72:	d1d1      	bne.n	4ac18 <strtoul+0x30>
		c = s[1];
   4ac74:	7863      	ldrb	r3, [r4, #1]
		base = 16;
   4ac76:	2210      	movs	r2, #16
		s += 2;
   4ac78:	3402      	adds	r4, #2
	if (base == 0) {
   4ac7a:	e7cd      	b.n	4ac18 <strtoul+0x30>
	    c == '0' && (*s == 'x' || *s == 'X')) {
   4ac7c:	7822      	ldrb	r2, [r4, #0]
   4ac7e:	f002 02df 	and.w	r2, r2, #223	; 0xdf
   4ac82:	2a58      	cmp	r2, #88	; 0x58
   4ac84:	d0f6      	beq.n	4ac74 <strtoul+0x8c>
		base = c == '0' ? 8 : 10;
   4ac86:	2208      	movs	r2, #8
   4ac88:	e7c6      	b.n	4ac18 <strtoul+0x30>
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
   4ac8a:	f043 0620 	orr.w	r6, r3, #32
   4ac8e:	3e61      	subs	r6, #97	; 0x61
		} else if (isalpha((unsigned char)c)) {
   4ac90:	2e19      	cmp	r6, #25
   4ac92:	d80a      	bhi.n	4acaa <strtoul+0xc2>
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
   4ac94:	f1a3 0641 	sub.w	r6, r3, #65	; 0x41
			c -= isupper((unsigned char)c) ? 'A' - 10 : 'a' - 10;
   4ac98:	2e1a      	cmp	r6, #26
   4ac9a:	bf34      	ite	cc
   4ac9c:	2637      	movcc	r6, #55	; 0x37
   4ac9e:	2657      	movcs	r6, #87	; 0x57
   4aca0:	1b9b      	subs	r3, r3, r6
   4aca2:	e7c8      	b.n	4ac36 <strtoul+0x4e>
			any = -1;
   4aca4:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   4aca8:	e7d1      	b.n	4ac4e <strtoul+0x66>
		}
	}
	if (any < 0) {
   4acaa:	1c6b      	adds	r3, r5, #1
   4acac:	d107      	bne.n	4acbe <strtoul+0xd6>
	if (z_syscall_trap()) {
		return (int *) arch_syscall_invoke0(K_SYSCALL_Z_ERRNO);
	}
#endif
	compiler_barrier();
	return z_impl_z_errno();
   4acae:	f7fb fed7 	bl	46a60 <z_impl_z_errno>
		acc = ULONG_MAX;
		errno = ERANGE;
   4acb2:	2322      	movs	r3, #34	; 0x22
   4acb4:	6003      	str	r3, [r0, #0]
		acc = ULONG_MAX;
   4acb6:	4628      	mov	r0, r5
	} else if (neg) {
		acc = -acc;
	}
	if (endptr != NULL) {
   4acb8:	b947      	cbnz	r7, 4accc <strtoul+0xe4>
		*endptr = (char *)(any ? s - 1 : nptr);
	}
	return acc;
}
   4acba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	} else if (neg) {
   4acbe:	f1be 0f00 	cmp.w	lr, #0
   4acc2:	d000      	beq.n	4acc6 <strtoul+0xde>
		acc = -acc;
   4acc4:	4240      	negs	r0, r0
	if (endptr != NULL) {
   4acc6:	2f00      	cmp	r7, #0
   4acc8:	d0f7      	beq.n	4acba <strtoul+0xd2>
		*endptr = (char *)(any ? s - 1 : nptr);
   4acca:	b10d      	cbz	r5, 4acd0 <strtoul+0xe8>
   4accc:	f104 3cff 	add.w	ip, r4, #4294967295	; 0xffffffff
   4acd0:	f8c7 c000 	str.w	ip, [r7]
	return acc;
   4acd4:	e7f1      	b.n	4acba <strtoul+0xd2>

0004acd6 <compare>:
		int (*comp3)(const void *a, const void *b, void *arg);
	};
};

static inline int compare(struct qsort_comp *cmp, void *a, void *b)
{
   4acd6:	b410      	push	{r4}
   4acd8:	4603      	mov	r3, r0
   4acda:	4608      	mov	r0, r1
   4acdc:	4611      	mov	r1, r2
	if (cmp->has3) {
   4acde:	781a      	ldrb	r2, [r3, #0]
		return cmp->comp3(a, b, cmp->arg);
   4ace0:	689c      	ldr	r4, [r3, #8]
	if (cmp->has3) {
   4ace2:	b11a      	cbz	r2, 4acec <compare+0x16>
		return cmp->comp3(a, b, cmp->arg);
   4ace4:	685a      	ldr	r2, [r3, #4]
   4ace6:	4623      	mov	r3, r4
	}

	return cmp->comp2(a, b);
}
   4ace8:	bc10      	pop	{r4}
		return cmp->comp3(a, b, cmp->arg);
   4acea:	4718      	bx	r3
	return cmp->comp2(a, b);
   4acec:	4623      	mov	r3, r4
}
   4acee:	bc10      	pop	{r4}
	return cmp->comp2(a, b);
   4acf0:	4718      	bx	r3

0004acf2 <sift_down>:

static void sift_down(void *base, int start, int end, size_t size, struct qsort_comp *cmp)
{
   4acf2:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4acf6:	4607      	mov	r7, r0
   4acf8:	460e      	mov	r6, r1
   4acfa:	4692      	mov	sl, r2
   4acfc:	461d      	mov	r5, r3
	int root;
	int child;
	int swap;

	for (swap = start, root = swap; left(root) < end; root = swap) {
   4acfe:	ea4f 0846 	mov.w	r8, r6, lsl #1
   4ad02:	f108 0401 	add.w	r4, r8, #1
   4ad06:	4554      	cmp	r4, sl
   4ad08:	db01      	blt.n	4ad0e <sift_down+0x1c>
			return;
		}

		byteswp(A(root), A(swap), size);
	}
}
   4ad0a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (compare(cmp, A(swap), A(child)) < 0) {
   4ad0e:	fb05 7906 	mla	r9, r5, r6, r7
   4ad12:	fb05 fb04 	mul.w	fp, r5, r4
   4ad16:	980a      	ldr	r0, [sp, #40]	; 0x28
   4ad18:	eb07 020b 	add.w	r2, r7, fp
   4ad1c:	4649      	mov	r1, r9
   4ad1e:	f7ff ffda 	bl	4acd6 <compare>
   4ad22:	2800      	cmp	r0, #0
		if (right(root) < end && compare(cmp, A(swap), A(right(root))) < 0) {
   4ad24:	f108 0802 	add.w	r8, r8, #2
		if (compare(cmp, A(swap), A(child)) < 0) {
   4ad28:	db03      	blt.n	4ad32 <sift_down+0x40>
		if (right(root) < end && compare(cmp, A(swap), A(right(root))) < 0) {
   4ad2a:	45c2      	cmp	sl, r8
   4ad2c:	dded      	ble.n	4ad0a <sift_down+0x18>
   4ad2e:	4634      	mov	r4, r6
   4ad30:	e001      	b.n	4ad36 <sift_down+0x44>
   4ad32:	45c2      	cmp	sl, r8
   4ad34:	dd0b      	ble.n	4ad4e <sift_down+0x5c>
   4ad36:	eb0b 0205 	add.w	r2, fp, r5
   4ad3a:	fb05 7104 	mla	r1, r5, r4, r7
   4ad3e:	980a      	ldr	r0, [sp, #40]	; 0x28
   4ad40:	443a      	add	r2, r7
   4ad42:	f7ff ffc8 	bl	4acd6 <compare>
   4ad46:	ea34 0420 	bics.w	r4, r4, r0, asr #32
   4ad4a:	bf28      	it	cs
   4ad4c:	4644      	movcs	r4, r8
		if (swap == root) {
   4ad4e:	42a6      	cmp	r6, r4
   4ad50:	d0db      	beq.n	4ad0a <sift_down+0x18>
		byteswp(A(root), A(swap), size);
   4ad52:	fb05 7304 	mla	r3, r5, r4, r7
{
	uint8_t t;
	uint8_t *aa = (uint8_t *)a;
	uint8_t *bb = (uint8_t *)b;

	for (; size > 0; --size) {
   4ad56:	eb09 0205 	add.w	r2, r9, r5
   4ad5a:	454a      	cmp	r2, r9
   4ad5c:	d101      	bne.n	4ad62 <sift_down+0x70>
   4ad5e:	4626      	mov	r6, r4
   4ad60:	e7cd      	b.n	4acfe <sift_down+0xc>
		t = *aa;
   4ad62:	f899 1000 	ldrb.w	r1, [r9]
		*aa++ = *bb;
   4ad66:	7818      	ldrb	r0, [r3, #0]
   4ad68:	f809 0b01 	strb.w	r0, [r9], #1
		*bb++ = t;
   4ad6c:	f803 1b01 	strb.w	r1, [r3], #1
	for (; size > 0; --size) {
   4ad70:	e7f3      	b.n	4ad5a <sift_down+0x68>

0004ad72 <heap_sort>:
		sift_down(base, start, nmemb, size, cmp);
	}
}

static void heap_sort(void *base, int nmemb, size_t size, struct qsort_comp *cmp)
{
   4ad72:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
	for (start = parent(nmemb - 1); start >= 0; --start) {
   4ad76:	1e8d      	subs	r5, r1, #2
{
   4ad78:	4607      	mov	r7, r0
   4ad7a:	460c      	mov	r4, r1
   4ad7c:	4616      	mov	r6, r2
   4ad7e:	4698      	mov	r8, r3
	for (start = parent(nmemb - 1); start >= 0; --start) {
   4ad80:	106d      	asrs	r5, r5, #1
   4ad82:	2d00      	cmp	r5, #0
   4ad84:	da0b      	bge.n	4ad9e <heap_sort+0x2c>
	int end;

	heapify(base, nmemb, size, cmp);

	for (end = nmemb - 1; end > 0; --end) {
   4ad86:	3c01      	subs	r4, #1
   4ad88:	fb06 f504 	mul.w	r5, r6, r4
   4ad8c:	eb07 0905 	add.w	r9, r7, r5
   4ad90:	4435      	add	r5, r6
   4ad92:	443d      	add	r5, r7
   4ad94:	2c00      	cmp	r4, #0
   4ad96:	dc0c      	bgt.n	4adb2 <heap_sort+0x40>
		byteswp(A(end), A(0), size);
		sift_down(base, 0, end, size, cmp);
	}
}
   4ad98:	b003      	add	sp, #12
   4ad9a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		sift_down(base, start, nmemb, size, cmp);
   4ad9e:	4629      	mov	r1, r5
   4ada0:	f8cd 8000 	str.w	r8, [sp]
   4ada4:	4633      	mov	r3, r6
   4ada6:	4622      	mov	r2, r4
   4ada8:	4638      	mov	r0, r7
   4adaa:	f7ff ffa2 	bl	4acf2 <sift_down>
	for (start = parent(nmemb - 1); start >= 0; --start) {
   4adae:	3d01      	subs	r5, #1
   4adb0:	e7e7      	b.n	4ad82 <heap_sort+0x10>
		byteswp(A(end), A(0), size);
   4adb2:	464b      	mov	r3, r9
	uint8_t *bb = (uint8_t *)b;
   4adb4:	463a      	mov	r2, r7
	for (; size > 0; --size) {
   4adb6:	42ab      	cmp	r3, r5
   4adb8:	d10c      	bne.n	4add4 <heap_sort+0x62>
		sift_down(base, 0, end, size, cmp);
   4adba:	4622      	mov	r2, r4
   4adbc:	f8cd 8000 	str.w	r8, [sp]
   4adc0:	4633      	mov	r3, r6
   4adc2:	2100      	movs	r1, #0
   4adc4:	4638      	mov	r0, r7
   4adc6:	f7ff ff94 	bl	4acf2 <sift_down>
	for (end = nmemb - 1; end > 0; --end) {
   4adca:	3c01      	subs	r4, #1
   4adcc:	eba9 0906 	sub.w	r9, r9, r6
   4add0:	1bad      	subs	r5, r5, r6
   4add2:	e7df      	b.n	4ad94 <heap_sort+0x22>
		t = *aa;
   4add4:	7819      	ldrb	r1, [r3, #0]
		*aa++ = *bb;
   4add6:	7810      	ldrb	r0, [r2, #0]
   4add8:	f803 0b01 	strb.w	r0, [r3], #1
		*bb++ = t;
   4addc:	f802 1b01 	strb.w	r1, [r2], #1
	for (; size > 0; --size) {
   4ade0:	e7e9      	b.n	4adb6 <heap_sort+0x44>

0004ade2 <qsort>:
	heap_sort(base, nmemb, size, &cmp);
}

void qsort(void *base, size_t nmemb, size_t size,
	   int (*comp2)(const void *a, const void *b))
{
   4ade2:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	struct qsort_comp cmp = {
   4ade4:	2400      	movs	r4, #0
   4ade6:	e9cd 4302 	strd	r4, r3, [sp, #8]
		{
			.comp2 = comp2
		}
	};

	heap_sort(base, nmemb, size, &cmp);
   4adea:	ab01      	add	r3, sp, #4
	struct qsort_comp cmp = {
   4adec:	f88d 4004 	strb.w	r4, [sp, #4]
	heap_sort(base, nmemb, size, &cmp);
   4adf0:	f7ff ffbf 	bl	4ad72 <heap_sort>
}
   4adf4:	b004      	add	sp, #16
   4adf6:	bd10      	pop	{r4, pc}

0004adf8 <strcpy>:

char *strcpy(char *ZRESTRICT d, const char *ZRESTRICT s)
{
	char *dest = d;

	while (*s != '\0') {
   4adf8:	3901      	subs	r1, #1
   4adfa:	4603      	mov	r3, r0
   4adfc:	f811 2f01 	ldrb.w	r2, [r1, #1]!
   4ae00:	b90a      	cbnz	r2, 4ae06 <strcpy+0xe>
		*d = *s;
		d++;
		s++;
	}

	*d = '\0';
   4ae02:	701a      	strb	r2, [r3, #0]

	return dest;
}
   4ae04:	4770      	bx	lr
		*d = *s;
   4ae06:	f803 2b01 	strb.w	r2, [r3], #1
		s++;
   4ae0a:	e7f7      	b.n	4adfc <strcpy+0x4>

0004ae0c <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
   4ae0c:	4603      	mov	r3, r0
	size_t n = 0;
   4ae0e:	2000      	movs	r0, #0

	while (*s != '\0') {
   4ae10:	5c1a      	ldrb	r2, [r3, r0]
   4ae12:	b902      	cbnz	r2, 4ae16 <strlen+0xa>
		s++;
		n++;
	}

	return n;
}
   4ae14:	4770      	bx	lr
		n++;
   4ae16:	3001      	adds	r0, #1
   4ae18:	e7fa      	b.n	4ae10 <strlen+0x4>

0004ae1a <strcmp>:
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
	while ((*s1 == *s2) && (*s1 != '\0')) {
   4ae1a:	1e43      	subs	r3, r0, #1
   4ae1c:	3901      	subs	r1, #1
   4ae1e:	f813 2f01 	ldrb.w	r2, [r3, #1]!
   4ae22:	f811 0f01 	ldrb.w	r0, [r1, #1]!
   4ae26:	4282      	cmp	r2, r0
   4ae28:	d101      	bne.n	4ae2e <strcmp+0x14>
   4ae2a:	2a00      	cmp	r2, #0
   4ae2c:	d1f7      	bne.n	4ae1e <strcmp+0x4>
		s1++;
		s2++;
	}

	return *s1 - *s2;
}
   4ae2e:	1a10      	subs	r0, r2, r0
   4ae30:	4770      	bx	lr

0004ae32 <strncmp>:
 *
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strncmp(const char *s1, const char *s2, size_t n)
{
   4ae32:	b570      	push	{r4, r5, r6, lr}
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
   4ae34:	460b      	mov	r3, r1
   4ae36:	4605      	mov	r5, r0
   4ae38:	b16a      	cbz	r2, 4ae56 <strncmp+0x24>
   4ae3a:	f810 6b01 	ldrb.w	r6, [r0], #1
   4ae3e:	781c      	ldrb	r4, [r3, #0]
   4ae40:	42b4      	cmp	r4, r6
   4ae42:	f101 0101 	add.w	r1, r1, #1
   4ae46:	d100      	bne.n	4ae4a <strncmp+0x18>
   4ae48:	b91c      	cbnz	r4, 4ae52 <strncmp+0x20>
		s1++;
		s2++;
		n--;
	}

	return (n == 0) ? 0 : (*s1 - *s2);
   4ae4a:	782a      	ldrb	r2, [r5, #0]
   4ae4c:	781b      	ldrb	r3, [r3, #0]
   4ae4e:	1ad0      	subs	r0, r2, r3
   4ae50:	e002      	b.n	4ae58 <strncmp+0x26>
		n--;
   4ae52:	3a01      	subs	r2, #1
   4ae54:	e7ee      	b.n	4ae34 <strncmp+0x2>
	return (n == 0) ? 0 : (*s1 - *s2);
   4ae56:	4610      	mov	r0, r2
}
   4ae58:	bd70      	pop	{r4, r5, r6, pc}

0004ae5a <memcmp>:
 * @brief Compare two memory areas
 *
 * @return negative # if <m1> < <m2>, 0 if <m1> == <m2>, else positive #
 */
int memcmp(const void *m1, const void *m2, size_t n)
{
   4ae5a:	b510      	push	{r4, lr}
	const char *c1 = m1;
	const char *c2 = m2;

	if (!n) {
   4ae5c:	b15a      	cbz	r2, 4ae76 <memcmp+0x1c>
   4ae5e:	3901      	subs	r1, #1
   4ae60:	1884      	adds	r4, r0, r2
		return 0;
	}

	while ((--n > 0) && (*c1 == *c2)) {
   4ae62:	f810 2b01 	ldrb.w	r2, [r0], #1
   4ae66:	f811 3f01 	ldrb.w	r3, [r1, #1]!
   4ae6a:	42a0      	cmp	r0, r4
   4ae6c:	d001      	beq.n	4ae72 <memcmp+0x18>
   4ae6e:	429a      	cmp	r2, r3
   4ae70:	d0f7      	beq.n	4ae62 <memcmp+0x8>
		c1++;
		c2++;
	}

	return *c1 - *c2;
   4ae72:	1ad0      	subs	r0, r2, r3
}
   4ae74:	bd10      	pop	{r4, pc}
		return 0;
   4ae76:	4610      	mov	r0, r2
   4ae78:	e7fc      	b.n	4ae74 <memcmp+0x1a>

0004ae7a <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *ZRESTRICT d, const void *ZRESTRICT s, size_t n)
{
   4ae7a:	b510      	push	{r4, lr}
   4ae7c:	1e43      	subs	r3, r0, #1
   4ae7e:	440a      	add	r2, r1
	}
#endif

	/* do byte-sized copying until finished */

	while (n > 0) {
   4ae80:	4291      	cmp	r1, r2
   4ae82:	d100      	bne.n	4ae86 <memcpy+0xc>
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
   4ae84:	bd10      	pop	{r4, pc}
		*(d_byte++) = *(s_byte++);
   4ae86:	f811 4b01 	ldrb.w	r4, [r1], #1
   4ae8a:	f803 4f01 	strb.w	r4, [r3, #1]!
		n--;
   4ae8e:	e7f7      	b.n	4ae80 <memcpy+0x6>

0004ae90 <memset>:
void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
   4ae90:	b2c9      	uxtb	r1, r1
	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;
#endif

	while (n > 0) {
   4ae92:	4402      	add	r2, r0
	unsigned char *d_byte = (unsigned char *)buf;
   4ae94:	4603      	mov	r3, r0
	while (n > 0) {
   4ae96:	4293      	cmp	r3, r2
   4ae98:	d100      	bne.n	4ae9c <memset+0xc>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
   4ae9a:	4770      	bx	lr
		*(d_byte++) = c_byte;
   4ae9c:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
   4aea0:	e7f9      	b.n	4ae96 <memset+0x6>

0004aea2 <sprintf_out>:
	if (p->len > 1) { /* need to reserve a byte for EOS */
   4aea2:	684b      	ldr	r3, [r1, #4]
   4aea4:	2b01      	cmp	r3, #1
   4aea6:	dd07      	ble.n	4aeb8 <sprintf_out+0x16>
		*(p->ptr) = c;
   4aea8:	680b      	ldr	r3, [r1, #0]
   4aeaa:	7018      	strb	r0, [r3, #0]
		p->ptr += 1;
   4aeac:	680b      	ldr	r3, [r1, #0]
   4aeae:	3301      	adds	r3, #1
   4aeb0:	600b      	str	r3, [r1, #0]
		p->len -= 1;
   4aeb2:	684b      	ldr	r3, [r1, #4]
   4aeb4:	3b01      	subs	r3, #1
   4aeb6:	604b      	str	r3, [r1, #4]
}
   4aeb8:	2000      	movs	r0, #0
   4aeba:	4770      	bx	lr

0004aebc <pm_state_set>:
/* Invoke Low Power/System Off specific Tasks */
__weak void pm_state_set(enum pm_state state, uint8_t substate_id)
{
	ARG_UNUSED(substate_id);

	switch (state) {
   4aebc:	2806      	cmp	r0, #6
   4aebe:	d108      	bne.n	4aed2 <pm_state_set+0x16>
    p_reg->SYSTEMOFF = POWER_SYSTEMOFF_SYSTEMOFF_Enter;
   4aec0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   4aec4:	2201      	movs	r2, #1
   4aec6:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
  __ASM volatile ("dsb 0xF":::"memory");
   4aeca:	f3bf 8f4f 	dsb	sy
        __WFE();
   4aece:	bf20      	wfe
    while (true)
   4aed0:	e7fd      	b.n	4aece <pm_state_set+0x12>
		break;
	default:
		LOG_DBG("Unsupported power state %u", state);
		break;
	}
}
   4aed2:	4770      	bx	lr

0004aed4 <pm_state_exit_post_ops>:
   4aed4:	2300      	movs	r3, #0
   4aed6:	f383 8811 	msr	BASEPRI, r3
   4aeda:	f3bf 8f6f 	isb	sy
	/*
	 * System is now in active mode. Reenable interrupts which were disabled
	 * when OS started idling code.
	 */
	irq_unlock(0);
}
   4aede:	4770      	bx	lr

0004aee0 <bt_rpa_irk_matches>:
	return 0;
}

#if defined(CONFIG_BT_SMP) || defined(CONFIG_BT_CTLR_PRIVACY)
bool bt_rpa_irk_matches(const uint8_t irk[16], const bt_addr_t *addr)
{
   4aee0:	b530      	push	{r4, r5, lr}
	memcpy(res, r, 3);
   4aee2:	2203      	movs	r2, #3
{
   4aee4:	b087      	sub	sp, #28
   4aee6:	4605      	mov	r5, r0
   4aee8:	460c      	mov	r4, r1
	memcpy(res, r, 3);
   4aeea:	a802      	add	r0, sp, #8
   4aeec:	4411      	add	r1, r2
   4aeee:	f7ff ffc4 	bl	4ae7a <memcpy>
	(void)memset(res + 3, 0, 13);
   4aef2:	220d      	movs	r2, #13
   4aef4:	2100      	movs	r1, #0
   4aef6:	f10d 000b 	add.w	r0, sp, #11
   4aefa:	f7ff ffc9 	bl	4ae90 <memset>
	return bt_encrypt_le(key, plaintext, enc_data);
   4aefe:	aa02      	add	r2, sp, #8
   4af00:	4611      	mov	r1, r2
   4af02:	4628      	mov	r0, r5
   4af04:	f7ec fa60 	bl	373c8 <bt_encrypt_le>
	if (err) {
   4af08:	b110      	cbz	r0, 4af10 <bt_rpa_irk_matches+0x30>

	BT_DBG("IRK %s bdaddr %s", bt_hex(irk, 16), bt_addr_str(addr));

	err = ah(irk, addr->val + 3, hash);
	if (err) {
		return false;
   4af0a:	2000      	movs	r0, #0
	}

	return !memcmp(addr->val, hash, 3);
}
   4af0c:	b007      	add	sp, #28
   4af0e:	bd30      	pop	{r4, r5, pc}
	memcpy(out, res, 3);
   4af10:	2203      	movs	r2, #3
   4af12:	a902      	add	r1, sp, #8
   4af14:	a801      	add	r0, sp, #4
   4af16:	f7ff ffb0 	bl	4ae7a <memcpy>
	return !memcmp(addr->val, hash, 3);
   4af1a:	2203      	movs	r2, #3
   4af1c:	a901      	add	r1, sp, #4
   4af1e:	4620      	mov	r0, r4
   4af20:	f7ff ff9b 	bl	4ae5a <memcmp>
   4af24:	fab0 f080 	clz	r0, r0
   4af28:	0940      	lsrs	r0, r0, #5
   4af2a:	e7ef      	b.n	4af0c <bt_rpa_irk_matches+0x2c>

0004af2c <send_cmd_status>:
{
   4af2c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	buf = bt_buf_get_evt(BT_HCI_EVT_CMD_STATUS, false, K_FOREVER);
   4af30:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
{
   4af34:	4606      	mov	r6, r0
   4af36:	460d      	mov	r5, r1
	buf = bt_buf_get_evt(BT_HCI_EVT_CMD_STATUS, false, K_FOREVER);
   4af38:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   4af3c:	2100      	movs	r1, #0
   4af3e:	200f      	movs	r0, #15
   4af40:	f7e2 fdac 	bl	2da9c <bt_buf_get_evt>
	((struct bt_buf_data *)net_buf_user_data(buf))->type = type;
   4af44:	2701      	movs	r7, #1
	return net_buf_simple_add(&buf->b, len);
   4af46:	f100 0808 	add.w	r8, r0, #8
   4af4a:	4604      	mov	r4, r0
   4af4c:	7507      	strb	r7, [r0, #20]
   4af4e:	2102      	movs	r1, #2
   4af50:	4640      	mov	r0, r8
   4af52:	f003 ff2f 	bl	4edb4 <net_buf_simple_add>
	hdr->evt = BT_HCI_EVT_CMD_STATUS;
   4af56:	230f      	movs	r3, #15
	hdr->len = sizeof(*evt);
   4af58:	2104      	movs	r1, #4
	hdr->evt = BT_HCI_EVT_CMD_STATUS;
   4af5a:	7003      	strb	r3, [r0, #0]
	hdr->len = sizeof(*evt);
   4af5c:	7041      	strb	r1, [r0, #1]
   4af5e:	4640      	mov	r0, r8
   4af60:	f003 ff28 	bl	4edb4 <net_buf_simple_add>
	evt->ncmd = 1U;
   4af64:	7047      	strb	r7, [r0, #1]
	evt->opcode = sys_cpu_to_le16(opcode);
   4af66:	8046      	strh	r6, [r0, #2]
	evt->status = status;
   4af68:	7005      	strb	r5, [r0, #0]
		bt_recv_prio(buf);
   4af6a:	4620      	mov	r0, r4
}
   4af6c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		bt_recv_prio(buf);
   4af70:	f7e3 bb6a 	b.w	2e648 <bt_recv_prio>

0004af74 <sys_memcpy_swap.constprop.0>:
	for (; length > 0; length--) {
   4af74:	f101 0320 	add.w	r3, r1, #32
   4af78:	3801      	subs	r0, #1
		*pdst++ = *psrc--;
   4af7a:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
   4af7e:	f800 2f01 	strb.w	r2, [r0, #1]!
	for (; length > 0; length--) {
   4af82:	428b      	cmp	r3, r1
   4af84:	d1f9      	bne.n	4af7a <sys_memcpy_swap.constprop.0+0x6>
}
   4af86:	4770      	bx	lr

0004af88 <bt_hci_ecc_supported_commands>:
void bt_hci_ecc_supported_commands(uint8_t *supported_commands)
{
	/* LE Read Local P-256 Public Key */
	supported_commands[34] |= BIT(1);
	/* LE Generate DH Key v1 */
	supported_commands[34] |= BIT(2);
   4af88:	f890 3022 	ldrb.w	r3, [r0, #34]	; 0x22
   4af8c:	f043 0306 	orr.w	r3, r3, #6
   4af90:	f880 3022 	strb.w	r3, [r0, #34]	; 0x22
	/* LE Generate DH Key v2 */
	supported_commands[41] |= BIT(2);
   4af94:	f890 3029 	ldrb.w	r3, [r0, #41]	; 0x29
   4af98:	f043 0304 	orr.w	r3, r3, #4
   4af9c:	f880 3029 	strb.w	r3, [r0, #41]	; 0x29
}
   4afa0:	4770      	bx	lr

0004afa2 <default_CSPRNG>:

int default_CSPRNG(uint8_t *dst, unsigned int len)
{
   4afa2:	b508      	push	{r3, lr}
	return !bt_rand(dst, len);
   4afa4:	f7ec fa0e 	bl	373c4 <bt_rand>
}
   4afa8:	fab0 f080 	clz	r0, r0
   4afac:	0940      	lsrs	r0, r0, #5
   4afae:	bd08      	pop	{r3, pc}

0004afb0 <bt_settings_decode_key>:
{
   4afb0:	b570      	push	{r4, r5, r6, lr}
   4afb2:	460d      	mov	r5, r1
	if (settings_name_next(key, NULL) != 13) {
   4afb4:	2100      	movs	r1, #0
{
   4afb6:	4604      	mov	r4, r0
	if (settings_name_next(key, NULL) != 13) {
   4afb8:	f7fe fbd3 	bl	49762 <settings_name_next>
   4afbc:	280d      	cmp	r0, #13
   4afbe:	d118      	bne.n	4aff2 <bt_settings_decode_key+0x42>
	if (key[12] == '0') {
   4afc0:	7b23      	ldrb	r3, [r4, #12]
   4afc2:	2b30      	cmp	r3, #48	; 0x30
   4afc4:	d013      	beq.n	4afee <bt_settings_decode_key+0x3e>
	} else if (key[12] == '1') {
   4afc6:	2b31      	cmp	r3, #49	; 0x31
   4afc8:	d113      	bne.n	4aff2 <bt_settings_decode_key+0x42>
   4afca:	2301      	movs	r3, #1
		addr->type = BT_ADDR_LE_PUBLIC;
   4afcc:	f805 3b06 	strb.w	r3, [r5], #6
   4afd0:	f104 060c 	add.w	r6, r4, #12
		hex2bin(&key[i * 2], 2, &addr->a.val[5 - i], 1);
   4afd4:	462a      	mov	r2, r5
   4afd6:	4620      	mov	r0, r4
   4afd8:	2301      	movs	r3, #1
   4afda:	2102      	movs	r1, #2
	for (uint8_t i = 0; i < 6; i++) {
   4afdc:	3402      	adds	r4, #2
		hex2bin(&key[i * 2], 2, &addr->a.val[5 - i], 1);
   4afde:	f7fd fcd7 	bl	48990 <hex2bin>
	for (uint8_t i = 0; i < 6; i++) {
   4afe2:	42b4      	cmp	r4, r6
   4afe4:	f105 35ff 	add.w	r5, r5, #4294967295	; 0xffffffff
   4afe8:	d1f4      	bne.n	4afd4 <bt_settings_decode_key+0x24>
	return 0;
   4afea:	2000      	movs	r0, #0
}
   4afec:	bd70      	pop	{r4, r5, r6, pc}
   4afee:	2300      	movs	r3, #0
   4aff0:	e7ec      	b.n	4afcc <bt_settings_decode_key+0x1c>
		return -EINVAL;
   4aff2:	f06f 0015 	mvn.w	r0, #21
   4aff6:	e7f9      	b.n	4afec <bt_settings_decode_key+0x3c>

0004aff8 <bt_settings_init>:
{
	int err;

	BT_DBG("");

	err = settings_subsys_init();
   4aff8:	f7e1 bba4 	b.w	2c744 <settings_subsys_init>

0004affc <bt_uuid_cmp>:
{
   4affc:	b510      	push	{r4, lr}
   4affe:	460c      	mov	r4, r1
	if (u1->type != u2->type) {
   4b000:	7801      	ldrb	r1, [r0, #0]
   4b002:	7822      	ldrb	r2, [r4, #0]
   4b004:	428a      	cmp	r2, r1
{
   4b006:	b08a      	sub	sp, #40	; 0x28
	if (u1->type != u2->type) {
   4b008:	d00f      	beq.n	4b02a <bt_uuid_cmp+0x2e>
	uuid_to_uuid128(u1, &uuid1);
   4b00a:	4669      	mov	r1, sp
   4b00c:	f7e2 fc88 	bl	2d920 <uuid_to_uuid128>
	uuid_to_uuid128(u2, &uuid2);
   4b010:	a905      	add	r1, sp, #20
   4b012:	4620      	mov	r0, r4
   4b014:	f7e2 fc84 	bl	2d920 <uuid_to_uuid128>
	return memcmp(uuid1.val, uuid2.val, 16);
   4b018:	2210      	movs	r2, #16
   4b01a:	f10d 0115 	add.w	r1, sp, #21
   4b01e:	f10d 0001 	add.w	r0, sp, #1
   4b022:	f7ff ff1a 	bl	4ae5a <memcmp>
}
   4b026:	b00a      	add	sp, #40	; 0x28
   4b028:	bd10      	pop	{r4, pc}
	switch (u1->type) {
   4b02a:	2a01      	cmp	r2, #1
   4b02c:	d006      	beq.n	4b03c <bt_uuid_cmp+0x40>
   4b02e:	2a02      	cmp	r2, #2
   4b030:	d007      	beq.n	4b042 <bt_uuid_cmp+0x46>
   4b032:	b972      	cbnz	r2, 4b052 <bt_uuid_cmp+0x56>
		return (int)BT_UUID_16(u1)->val - (int)BT_UUID_16(u2)->val;
   4b034:	8840      	ldrh	r0, [r0, #2]
   4b036:	8863      	ldrh	r3, [r4, #2]
		return (int)BT_UUID_32(u1)->val - (int)BT_UUID_32(u2)->val;
   4b038:	1ac0      	subs	r0, r0, r3
   4b03a:	e7f4      	b.n	4b026 <bt_uuid_cmp+0x2a>
   4b03c:	6840      	ldr	r0, [r0, #4]
   4b03e:	6863      	ldr	r3, [r4, #4]
   4b040:	e7fa      	b.n	4b038 <bt_uuid_cmp+0x3c>
		return memcmp(BT_UUID_128(u1)->val, BT_UUID_128(u2)->val, 16);
   4b042:	2210      	movs	r2, #16
   4b044:	1c61      	adds	r1, r4, #1
   4b046:	3001      	adds	r0, #1
}
   4b048:	b00a      	add	sp, #40	; 0x28
   4b04a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		return memcmp(BT_UUID_128(u1)->val, BT_UUID_128(u2)->val, 16);
   4b04e:	f7ff bf04 	b.w	4ae5a <memcmp>
	switch (u1->type) {
   4b052:	f06f 0015 	mvn.w	r0, #21
   4b056:	e7e6      	b.n	4b026 <bt_uuid_cmp+0x2a>

0004b058 <bt_uuid_create>:
	switch (data_len) {
   4b058:	2a04      	cmp	r2, #4
{
   4b05a:	b510      	push	{r4, lr}
	switch (data_len) {
   4b05c:	d00a      	beq.n	4b074 <bt_uuid_create+0x1c>
   4b05e:	2a10      	cmp	r2, #16
   4b060:	d00d      	beq.n	4b07e <bt_uuid_create+0x26>
   4b062:	2a02      	cmp	r2, #2
   4b064:	f04f 0300 	mov.w	r3, #0
   4b068:	d10f      	bne.n	4b08a <bt_uuid_create+0x32>
		uuid->type = BT_UUID_TYPE_16;
   4b06a:	7003      	strb	r3, [r0, #0]
		BT_UUID_16(uuid)->val = sys_get_le16(data);
   4b06c:	880b      	ldrh	r3, [r1, #0]
   4b06e:	8043      	strh	r3, [r0, #2]
	return true;
   4b070:	2001      	movs	r0, #1
}
   4b072:	bd10      	pop	{r4, pc}
		uuid->type = BT_UUID_TYPE_32;
   4b074:	2301      	movs	r3, #1
   4b076:	7003      	strb	r3, [r0, #0]
	return ((uint32_t)sys_get_le16(&src[2]) << 16) | sys_get_le16(&src[0]);
   4b078:	680b      	ldr	r3, [r1, #0]
		BT_UUID_32(uuid)->val = sys_get_le32(data);
   4b07a:	6043      	str	r3, [r0, #4]
		break;
   4b07c:	e7f8      	b.n	4b070 <bt_uuid_create+0x18>
		uuid->type = BT_UUID_TYPE_128;
   4b07e:	2302      	movs	r3, #2
   4b080:	f800 3b01 	strb.w	r3, [r0], #1
		memcpy(&BT_UUID_128(uuid)->val, data, 16);
   4b084:	f7ff fef9 	bl	4ae7a <memcpy>
		break;
   4b088:	e7f2      	b.n	4b070 <bt_uuid_create+0x18>
	switch (data_len) {
   4b08a:	4618      	mov	r0, r3
   4b08c:	e7f1      	b.n	4b072 <bt_uuid_create+0x1a>

0004b08e <bt_addr_le_create_static>:
#include <zephyr/bluetooth/addr.h>
#include <zephyr/bluetooth/crypto.h>

static inline int create_random_addr(bt_addr_le_t *addr)
{
	addr->type = BT_ADDR_LE_RANDOM;
   4b08e:	2301      	movs	r3, #1

	return 0;
}

int bt_addr_le_create_static(bt_addr_le_t *addr)
{
   4b090:	b510      	push	{r4, lr}
	return bt_rand(addr->a.val, 6);
   4b092:	2106      	movs	r1, #6
{
   4b094:	4604      	mov	r4, r0
	addr->type = BT_ADDR_LE_RANDOM;
   4b096:	f800 3b01 	strb.w	r3, [r0], #1
	return bt_rand(addr->a.val, 6);
   4b09a:	f7ec f993 	bl	373c4 <bt_rand>
	int err;

	err = create_random_addr(addr);
	if (err) {
   4b09e:	b918      	cbnz	r0, 4b0a8 <bt_addr_le_create_static+0x1a>
		return err;
	}

	BT_ADDR_SET_STATIC(&addr->a);
   4b0a0:	79a3      	ldrb	r3, [r4, #6]
   4b0a2:	f063 033f 	orn	r3, r3, #63	; 0x3f
   4b0a6:	71a3      	strb	r3, [r4, #6]

	return 0;
}
   4b0a8:	bd10      	pop	{r4, pc}

0004b0aa <bt_hci_evt_get_flags>:
 *
 * @return HCI event flags for the specified event.
 */
static inline uint8_t bt_hci_evt_get_flags(uint8_t evt)
{
	switch (evt) {
   4b0aa:	280f      	cmp	r0, #15
   4b0ac:	d807      	bhi.n	4b0be <bt_hci_evt_get_flags+0x14>
   4b0ae:	280d      	cmp	r0, #13
   4b0b0:	d80b      	bhi.n	4b0ca <bt_hci_evt_get_flags+0x20>
#endif /* CONFIG_BT_CONN ||  CONFIG_BT_ISO */
	case BT_HCI_EVT_CMD_COMPLETE:
	case BT_HCI_EVT_CMD_STATUS:
		return BT_HCI_EVT_FLAG_RECV_PRIO;
	default:
		return BT_HCI_EVT_FLAG_RECV;
   4b0b2:	2805      	cmp	r0, #5
   4b0b4:	bf08      	it	eq
   4b0b6:	2003      	moveq	r0, #3
   4b0b8:	bf18      	it	ne
   4b0ba:	2002      	movne	r0, #2
   4b0bc:	4770      	bx	lr
	switch (evt) {
   4b0be:	2813      	cmp	r0, #19
   4b0c0:	d003      	beq.n	4b0ca <bt_hci_evt_get_flags+0x20>
		return BT_HCI_EVT_FLAG_RECV;
   4b0c2:	281a      	cmp	r0, #26
   4b0c4:	bf08      	it	eq
   4b0c6:	2001      	moveq	r0, #1
   4b0c8:	e7f6      	b.n	4b0b8 <bt_hci_evt_get_flags+0xe>
	switch (evt) {
   4b0ca:	2001      	movs	r0, #1
	}
}
   4b0cc:	4770      	bx	lr

0004b0ce <hci_data_buf_overflow>:
}
   4b0ce:	4770      	bx	lr

0004b0d0 <update_sec_level>:
	if (conn->le.keys && (conn->le.keys->flags & BT_KEYS_AUTHENTICATED)) {
   4b0d0:	f8d0 30b4 	ldr.w	r3, [r0, #180]	; 0xb4
   4b0d4:	b183      	cbz	r3, 4b0f8 <update_sec_level+0x28>
   4b0d6:	7b5a      	ldrb	r2, [r3, #13]
   4b0d8:	07d1      	lsls	r1, r2, #31
   4b0da:	d50d      	bpl.n	4b0f8 <update_sec_level+0x28>
		if (conn->le.keys->flags & BT_KEYS_SC &&
   4b0dc:	06d2      	lsls	r2, r2, #27
   4b0de:	d50d      	bpl.n	4b0fc <update_sec_level+0x2c>
   4b0e0:	7b1b      	ldrb	r3, [r3, #12]
   4b0e2:	2b10      	cmp	r3, #16
   4b0e4:	bf14      	ite	ne
   4b0e6:	2303      	movne	r3, #3
   4b0e8:	2304      	moveq	r3, #4
			conn->sec_level = BT_SECURITY_L3;
   4b0ea:	7243      	strb	r3, [r0, #9]
	return !(conn->required_sec_level > conn->sec_level);
   4b0ec:	7a80      	ldrb	r0, [r0, #10]
}
   4b0ee:	4298      	cmp	r0, r3
   4b0f0:	bf8c      	ite	hi
   4b0f2:	2000      	movhi	r0, #0
   4b0f4:	2001      	movls	r0, #1
   4b0f6:	4770      	bx	lr
   4b0f8:	2302      	movs	r3, #2
   4b0fa:	e7f6      	b.n	4b0ea <update_sec_level+0x1a>
   4b0fc:	2303      	movs	r3, #3
   4b0fe:	e7f4      	b.n	4b0ea <update_sec_level+0x1a>

0004b100 <bt_addr_le_copy>:
	memcpy(dst, src, sizeof(*dst));
   4b100:	2207      	movs	r2, #7
   4b102:	f7ff beba 	b.w	4ae7a <memcpy>

0004b106 <atomic_or>:
{
   4b106:	b510      	push	{r4, lr}
   4b108:	4603      	mov	r3, r0
}
   4b10a:	f3bf 8f5b 	dmb	ish
   4b10e:	e853 0f00 	ldrex	r0, [r3]
   4b112:	ea40 0201 	orr.w	r2, r0, r1
   4b116:	e843 2400 	strex	r4, r2, [r3]
   4b11a:	2c00      	cmp	r4, #0
   4b11c:	d1f7      	bne.n	4b10e <atomic_or+0x8>
   4b11e:	f3bf 8f5b 	dmb	ish
   4b122:	bd10      	pop	{r4, pc}

0004b124 <unpair_remote>:
{
   4b124:	460b      	mov	r3, r1
	unpair(*id, &info->addr);
   4b126:	4601      	mov	r1, r0
   4b128:	7818      	ldrb	r0, [r3, #0]
   4b12a:	f7e2 bce3 	b.w	2daf4 <unpair>

0004b12e <hci_disconn_complete>:
{
   4b12e:	b570      	push	{r4, r5, r6, lr}
	struct bt_hci_evt_disconn_complete *evt = (void *)buf->data;
   4b130:	6886      	ldr	r6, [r0, #8]
	if (evt->status) {
   4b132:	7835      	ldrb	r5, [r6, #0]
	uint16_t handle = sys_le16_to_cpu(evt->handle);
   4b134:	f8b6 0001 	ldrh.w	r0, [r6, #1]
	if (evt->status) {
   4b138:	b9fd      	cbnz	r5, 4b17a <hci_disconn_complete+0x4c>
	conn = bt_conn_lookup_handle(handle);
   4b13a:	f7e4 fe03 	bl	2fd44 <bt_conn_lookup_handle>
	if (!conn) {
   4b13e:	4604      	mov	r4, r0
   4b140:	b1d8      	cbz	r0, 4b17a <hci_disconn_complete+0x4c>
	conn->err = evt->reason;
   4b142:	78f3      	ldrb	r3, [r6, #3]
   4b144:	7303      	strb	r3, [r0, #12]
	bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
   4b146:	4629      	mov	r1, r5
   4b148:	f7e4 fe04 	bl	2fd54 <bt_conn_set_state>
	if (conn->type != BT_CONN_TYPE_LE) {
   4b14c:	78a3      	ldrb	r3, [r4, #2]
   4b14e:	2b01      	cmp	r3, #1
   4b150:	d004      	beq.n	4b15c <hci_disconn_complete+0x2e>
	bt_conn_unref(conn);
   4b152:	4620      	mov	r0, r4
}
   4b154:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	bt_conn_unref(conn);
   4b158:	f000 be35 	b.w	4bdc6 <bt_conn_unref>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   4b15c:	f3bf 8f5b 	dmb	ish
   4b160:	6863      	ldr	r3, [r4, #4]
   4b162:	f3bf 8f5b 	dmb	ish
	if (atomic_test_bit(conn->flags, BT_CONN_AUTO_CONNECT)) {
   4b166:	07db      	lsls	r3, r3, #31
   4b168:	d5f3      	bpl.n	4b152 <hci_disconn_complete+0x24>
		bt_conn_set_state(conn, BT_CONN_CONNECTING_SCAN);
   4b16a:	4620      	mov	r0, r4
   4b16c:	2102      	movs	r1, #2
   4b16e:	f7e4 fdf1 	bl	2fd54 <bt_conn_set_state>
		bt_le_scan_update(false);
   4b172:	4628      	mov	r0, r5
   4b174:	f7e4 f964 	bl	2f440 <bt_le_scan_update>
   4b178:	e7eb      	b.n	4b152 <hci_disconn_complete+0x24>
}
   4b17a:	bd70      	pop	{r4, r5, r6, pc}

0004b17c <le_data_len_change>:
{
   4b17c:	b508      	push	{r3, lr}
	uint16_t handle = sys_le16_to_cpu(evt->handle);
   4b17e:	6883      	ldr	r3, [r0, #8]
	conn = bt_conn_lookup_handle(handle);
   4b180:	8818      	ldrh	r0, [r3, #0]
   4b182:	f7e4 fddf 	bl	2fd44 <bt_conn_lookup_handle>
	if (!conn) {
   4b186:	b118      	cbz	r0, 4b190 <le_data_len_change+0x14>
}
   4b188:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	bt_conn_unref(conn);
   4b18c:	f000 be1b 	b.w	4bdc6 <bt_conn_unref>
}
   4b190:	bd08      	pop	{r3, pc}

0004b192 <hci_hardware_error>:
	return net_buf_simple_pull_mem(&buf->b, len);
   4b192:	2101      	movs	r1, #1
   4b194:	3008      	adds	r0, #8
   4b196:	f003 be3e 	b.w	4ee16 <net_buf_simple_pull_mem>

0004b19a <le_conn_update_complete>:
{
   4b19a:	b537      	push	{r0, r1, r2, r4, r5, lr}
	struct bt_hci_evt_le_conn_update_complete *evt = (void *)buf->data;
   4b19c:	6885      	ldr	r5, [r0, #8]
	conn = bt_conn_lookup_handle(handle);
   4b19e:	f8b5 0001 	ldrh.w	r0, [r5, #1]
   4b1a2:	f7e4 fdcf 	bl	2fd44 <bt_conn_lookup_handle>
	if (!conn) {
   4b1a6:	4604      	mov	r4, r0
   4b1a8:	b360      	cbz	r0, 4b204 <le_conn_update_complete+0x6a>
	if (!evt->status) {
   4b1aa:	782b      	ldrb	r3, [r5, #0]
   4b1ac:	b99b      	cbnz	r3, 4b1d6 <le_conn_update_complete+0x3c>
		conn->le.interval = sys_le16_to_cpu(evt->interval);
   4b1ae:	f8b5 3003 	ldrh.w	r3, [r5, #3]
   4b1b2:	f8a0 309e 	strh.w	r3, [r0, #158]	; 0x9e
		conn->le.latency = sys_le16_to_cpu(evt->latency);
   4b1b6:	f8b5 3005 	ldrh.w	r3, [r5, #5]
   4b1ba:	f8a0 30a4 	strh.w	r3, [r0, #164]	; 0xa4
		conn->le.timeout = sys_le16_to_cpu(evt->supv_timeout);
   4b1be:	f8b5 3007 	ldrh.w	r3, [r5, #7]
   4b1c2:	f8a0 30a6 	strh.w	r3, [r0, #166]	; 0xa6
		notify_le_param_updated(conn);
   4b1c6:	f7e4 febb 	bl	2ff40 <notify_le_param_updated>
	bt_conn_unref(conn);
   4b1ca:	4620      	mov	r0, r4
}
   4b1cc:	b003      	add	sp, #12
   4b1ce:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	bt_conn_unref(conn);
   4b1d2:	f000 bdf8 	b.w	4bdc6 <bt_conn_unref>
	} else if (evt->status == BT_HCI_ERR_UNSUPP_REMOTE_FEATURE &&
   4b1d6:	2b1a      	cmp	r3, #26
   4b1d8:	d1f7      	bne.n	4b1ca <le_conn_update_complete+0x30>
   4b1da:	78c3      	ldrb	r3, [r0, #3]
   4b1dc:	2b01      	cmp	r3, #1
   4b1de:	d1f4      	bne.n	4b1ca <le_conn_update_complete+0x30>
	old = atomic_or(ATOMIC_ELEM(target, bit), mask);
   4b1e0:	f44f 7100 	mov.w	r1, #512	; 0x200
   4b1e4:	3004      	adds	r0, #4
   4b1e6:	f7ff ff8e 	bl	4b106 <atomic_or>
		   conn->role == BT_HCI_ROLE_PERIPHERAL &&
   4b1ea:	0583      	lsls	r3, r0, #22
   4b1ec:	d4ed      	bmi.n	4b1ca <le_conn_update_complete+0x30>
		param.interval_min = conn->le.interval_min;
   4b1ee:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
   4b1f2:	9300      	str	r3, [sp, #0]
		bt_l2cap_update_conn_param(conn, &param);
   4b1f4:	4669      	mov	r1, sp
		param.latency = conn->le.pending_latency;
   4b1f6:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
   4b1fa:	9301      	str	r3, [sp, #4]
		bt_l2cap_update_conn_param(conn, &param);
   4b1fc:	4620      	mov	r0, r4
   4b1fe:	f7e5 fb5f 	bl	308c0 <bt_l2cap_update_conn_param>
   4b202:	e7e2      	b.n	4b1ca <le_conn_update_complete+0x30>
}
   4b204:	b003      	add	sp, #12
   4b206:	bd30      	pop	{r4, r5, pc}

0004b208 <le_remote_feat_complete>:
{
   4b208:	b538      	push	{r3, r4, r5, lr}
	struct bt_hci_evt_le_remote_feat_complete *evt = (void *)buf->data;
   4b20a:	6885      	ldr	r5, [r0, #8]
	conn = bt_conn_lookup_handle(handle);
   4b20c:	f8b5 0001 	ldrh.w	r0, [r5, #1]
   4b210:	f7e4 fd98 	bl	2fd44 <bt_conn_lookup_handle>
	if (!conn) {
   4b214:	4604      	mov	r4, r0
   4b216:	b180      	cbz	r0, 4b23a <le_remote_feat_complete+0x32>
	if (!evt->status) {
   4b218:	782b      	ldrb	r3, [r5, #0]
   4b21a:	b923      	cbnz	r3, 4b226 <le_remote_feat_complete+0x1e>
		memcpy(conn->le.features, evt->features,
   4b21c:	2208      	movs	r2, #8
   4b21e:	1ce9      	adds	r1, r5, #3
   4b220:	30ac      	adds	r0, #172	; 0xac
   4b222:	f7ff fe2a 	bl	4ae7a <memcpy>
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
   4b226:	1d20      	adds	r0, r4, #4
   4b228:	f44f 5180 	mov.w	r1, #4096	; 0x1000
   4b22c:	f7ff ff6b 	bl	4b106 <atomic_or>
	bt_conn_unref(conn);
   4b230:	4620      	mov	r0, r4
}
   4b232:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	bt_conn_unref(conn);
   4b236:	f000 bdc6 	b.w	4bdc6 <bt_conn_unref>
}
   4b23a:	bd38      	pop	{r3, r4, r5, pc}

0004b23c <handle_event_common.isra.0>:
static int handle_event_common(uint8_t event, struct net_buf *buf,
   4b23c:	b430      	push	{r4, r5}
   4b23e:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   4b242:	4604      	mov	r4, r0
   4b244:	4608      	mov	r0, r1
	for (i = 0; i < num_handlers; i++) {
   4b246:	429a      	cmp	r2, r3
   4b248:	d101      	bne.n	4b24e <handle_event_common.isra.0+0x12>
}
   4b24a:	bc30      	pop	{r4, r5}
   4b24c:	4770      	bx	lr
		if (handler->event != event) {
   4b24e:	4611      	mov	r1, r2
   4b250:	f811 5b08 	ldrb.w	r5, [r1], #8
   4b254:	42a5      	cmp	r5, r4
   4b256:	d106      	bne.n	4b266 <handle_event_common.isra.0+0x2a>
		if (buf->len < handler->min_len) {
   4b258:	8981      	ldrh	r1, [r0, #12]
   4b25a:	7853      	ldrb	r3, [r2, #1]
   4b25c:	4299      	cmp	r1, r3
   4b25e:	d3f4      	bcc.n	4b24a <handle_event_common.isra.0+0xe>
}
   4b260:	bc30      	pop	{r4, r5}
		handler->handler(buf);
   4b262:	6853      	ldr	r3, [r2, #4]
   4b264:	4718      	bx	r3
   4b266:	460a      	mov	r2, r1
   4b268:	e7ed      	b.n	4b246 <handle_event_common.isra.0+0xa>

0004b26a <atomic_and.isra.0>:
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   4b26a:	f3bf 8f5b 	dmb	ish
   4b26e:	e850 3f00 	ldrex	r3, [r0]
   4b272:	400b      	ands	r3, r1
   4b274:	e840 3200 	strex	r2, r3, [r0]
   4b278:	2a00      	cmp	r2, #0
   4b27a:	d1f8      	bne.n	4b26e <atomic_and.isra.0+0x4>
   4b27c:	f3bf 8f5b 	dmb	ish
}
   4b280:	4770      	bx	lr

0004b282 <hci_vendor_event>:
static void hci_vendor_event(struct net_buf *buf)
   4b282:	4770      	bx	lr

0004b284 <sys_put_le64>:
	dst[1] = val >> 8;
   4b284:	f3c0 2307 	ubfx	r3, r0, #8, #8
	dst[0] = val;
   4b288:	7010      	strb	r0, [r2, #0]
	dst[1] = val >> 8;
   4b28a:	0e00      	lsrs	r0, r0, #24
   4b28c:	7053      	strb	r3, [r2, #1]
   4b28e:	70d0      	strb	r0, [r2, #3]
	dst[0] = val;
   4b290:	2300      	movs	r3, #0
	dst[1] = val >> 8;
   4b292:	f3c1 2007 	ubfx	r0, r1, #8, #8
   4b296:	0e09      	lsrs	r1, r1, #24
	dst[0] = val;
   4b298:	7093      	strb	r3, [r2, #2]
   4b29a:	7113      	strb	r3, [r2, #4]
	dst[1] = val >> 8;
   4b29c:	7150      	strb	r0, [r2, #5]
	dst[0] = val;
   4b29e:	7193      	strb	r3, [r2, #6]
	dst[1] = val >> 8;
   4b2a0:	71d1      	strb	r1, [r2, #7]
}
   4b2a2:	4770      	bx	lr

0004b2a4 <hci_num_completed_packets>:
{
   4b2a4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	for (i = 0; i < evt->num_handles; i++) {
   4b2a8:	2500      	movs	r5, #0
	struct bt_hci_evt_num_completed_packets *evt = (void *)buf->data;
   4b2aa:	6887      	ldr	r7, [r0, #8]
			tx->pending_no_cb = 0U;
   4b2ac:	46a8      	mov	r8, r5
	for (i = 0; i < evt->num_handles; i++) {
   4b2ae:	783b      	ldrb	r3, [r7, #0]
   4b2b0:	429d      	cmp	r5, r3
   4b2b2:	db01      	blt.n	4b2b8 <hci_num_completed_packets+0x14>
}
   4b2b4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		handle = sys_le16_to_cpu(evt->h[i].handle);
   4b2b8:	eb07 0385 	add.w	r3, r7, r5, lsl #2
		conn = bt_conn_lookup_handle(handle);
   4b2bc:	f8b3 0001 	ldrh.w	r0, [r3, #1]
		count = sys_le16_to_cpu(evt->h[i].count);
   4b2c0:	f8b3 6003 	ldrh.w	r6, [r3, #3]
		conn = bt_conn_lookup_handle(handle);
   4b2c4:	f7e4 fd3e 	bl	2fd44 <bt_conn_lookup_handle>
		if (!conn) {
   4b2c8:	4604      	mov	r4, r0
   4b2ca:	b318      	cbz	r0, 4b314 <hci_num_completed_packets+0x70>
			k_work_submit(&conn->tx_complete_work);
   4b2cc:	f100 0928 	add.w	r9, r0, #40	; 0x28
		while (count--) {
   4b2d0:	b1ee      	cbz	r6, 4b30e <hci_num_completed_packets+0x6a>
	__asm__ volatile(
   4b2d2:	f04f 0320 	mov.w	r3, #32
   4b2d6:	f3ef 8211 	mrs	r2, BASEPRI
   4b2da:	f383 8812 	msr	BASEPRI_MAX, r3
   4b2de:	f3bf 8f6f 	isb	sy
			if (conn->pending_no_cb) {
   4b2e2:	69e3      	ldr	r3, [r4, #28]
   4b2e4:	b16b      	cbz	r3, 4b302 <hci_num_completed_packets+0x5e>
				conn->pending_no_cb--;
   4b2e6:	3b01      	subs	r3, #1
   4b2e8:	61e3      	str	r3, [r4, #28]
	__asm__ volatile(
   4b2ea:	f382 8811 	msr	BASEPRI, r2
   4b2ee:	f3bf 8f6f 	isb	sy
			k_sem_give(bt_conn_get_pkts(conn));
   4b2f2:	4620      	mov	r0, r4
   4b2f4:	f7e4 fc74 	bl	2fbe0 <bt_conn_get_pkts>
	z_impl_k_sem_give(sem);
   4b2f8:	3e01      	subs	r6, #1
   4b2fa:	f7fb ff3d 	bl	47178 <z_impl_k_sem_give>
   4b2fe:	b2b6      	uxth	r6, r6
   4b300:	e7e6      	b.n	4b2d0 <hci_num_completed_packets+0x2c>
	return list->head;
   4b302:	6963      	ldr	r3, [r4, #20]
Z_GENLIST_GET(slist, snode)
   4b304:	b943      	cbnz	r3, 4b318 <hci_num_completed_packets+0x74>
   4b306:	f382 8811 	msr	BASEPRI, r2
   4b30a:	f3bf 8f6f 	isb	sy
		bt_conn_unref(conn);
   4b30e:	4620      	mov	r0, r4
   4b310:	f000 fd59 	bl	4bdc6 <bt_conn_unref>
	for (i = 0; i < evt->num_handles; i++) {
   4b314:	3501      	adds	r5, #1
   4b316:	e7ca      	b.n	4b2ae <hci_num_completed_packets+0xa>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   4b318:	69a1      	ldr	r1, [r4, #24]
	return node->next;
   4b31a:	6818      	ldr	r0, [r3, #0]
	list->head = node;
   4b31c:	6160      	str	r0, [r4, #20]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   4b31e:	428b      	cmp	r3, r1
	list->tail = node;
   4b320:	bf08      	it	eq
   4b322:	61a0      	streq	r0, [r4, #24]
   4b324:	f382 8811 	msr	BASEPRI, r2
   4b328:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
   4b32c:	f04f 0220 	mov.w	r2, #32
   4b330:	f3ef 8111 	mrs	r1, BASEPRI
   4b334:	f382 8812 	msr	BASEPRI_MAX, r2
   4b338:	f3bf 8f6f 	isb	sy
			conn->pending_no_cb = tx->pending_no_cb;
   4b33c:	68da      	ldr	r2, [r3, #12]
   4b33e:	61e2      	str	r2, [r4, #28]
			tx->pending_no_cb = 0U;
   4b340:	f8c3 800c 	str.w	r8, [r3, #12]
	parent->next = child;
   4b344:	f8c3 8000 	str.w	r8, [r3]
	return list->tail;
   4b348:	6a62      	ldr	r2, [r4, #36]	; 0x24
Z_GENLIST_APPEND(slist, snode)
   4b34a:	b94a      	cbnz	r2, 4b360 <hci_num_completed_packets+0xbc>
	list->head = node;
   4b34c:	e9c4 3308 	strd	r3, r3, [r4, #32]
	__asm__ volatile(
   4b350:	f381 8811 	msr	BASEPRI, r1
   4b354:	f3bf 8f6f 	isb	sy
			k_work_submit(&conn->tx_complete_work);
   4b358:	4648      	mov	r0, r9
   4b35a:	f7fc f8ab 	bl	474b4 <k_work_submit>
   4b35e:	e7c8      	b.n	4b2f2 <hci_num_completed_packets+0x4e>
	parent->next = child;
   4b360:	6013      	str	r3, [r2, #0]
	list->tail = node;
   4b362:	6263      	str	r3, [r4, #36]	; 0x24
}
   4b364:	e7f4      	b.n	4b350 <hci_num_completed_packets+0xac>

0004b366 <le_ltk_request>:
{
   4b366:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct bt_hci_evt_le_ltk_request *evt = (void *)buf->data;
   4b368:	6884      	ldr	r4, [r0, #8]
	handle = sys_le16_to_cpu(evt->handle);
   4b36a:	8826      	ldrh	r6, [r4, #0]
{
   4b36c:	b087      	sub	sp, #28
	conn = bt_conn_lookup_handle(handle);
   4b36e:	b2b0      	uxth	r0, r6
   4b370:	f7e4 fce8 	bl	2fd44 <bt_conn_lookup_handle>
	if (!conn) {
   4b374:	4605      	mov	r5, r0
   4b376:	b318      	cbz	r0, 4b3c0 <le_ltk_request+0x5a>
	if (bt_smp_request_ltk(conn, evt->rand, evt->ediv, ltk)) {
   4b378:	af02      	add	r7, sp, #8
   4b37a:	f8d4 2002 	ldr.w	r2, [r4, #2]
   4b37e:	f8d4 3006 	ldr.w	r3, [r4, #6]
   4b382:	9701      	str	r7, [sp, #4]
   4b384:	8961      	ldrh	r1, [r4, #10]
   4b386:	9100      	str	r1, [sp, #0]
   4b388:	f003 f94b 	bl	4e622 <bt_smp_request_ltk>
   4b38c:	b1d0      	cbz	r0, 4b3c4 <le_ltk_request+0x5e>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_LTK_REQ_REPLY,
   4b38e:	2112      	movs	r1, #18
   4b390:	f242 001a 	movw	r0, #8218	; 0x201a
   4b394:	f7e2 fd6a 	bl	2de6c <bt_hci_cmd_create>
	if (!buf) {
   4b398:	4604      	mov	r4, r0
   4b39a:	b170      	cbz	r0, 4b3ba <le_ltk_request+0x54>
	return net_buf_simple_add(&buf->b, len);
   4b39c:	2112      	movs	r1, #18
   4b39e:	3008      	adds	r0, #8
   4b3a0:	f003 fd08 	bl	4edb4 <net_buf_simple_add>
	memcpy(cp->ltk, ltk, sizeof(cp->ltk));
   4b3a4:	4639      	mov	r1, r7
	cp->handle = sys_cpu_to_le16(handle);
   4b3a6:	f820 6b02 	strh.w	r6, [r0], #2
	memcpy(cp->ltk, ltk, sizeof(cp->ltk));
   4b3aa:	2210      	movs	r2, #16
   4b3ac:	f7ff fd65 	bl	4ae7a <memcpy>
	bt_hci_cmd_send(BT_HCI_OP_LE_LTK_REQ_REPLY, buf);
   4b3b0:	4621      	mov	r1, r4
   4b3b2:	f242 001a 	movw	r0, #8218	; 0x201a
	bt_hci_cmd_send(BT_HCI_OP_LE_LTK_REQ_NEG_REPLY, buf);
   4b3b6:	f7e2 fd93 	bl	2dee0 <bt_hci_cmd_send>
	bt_conn_unref(conn);
   4b3ba:	4628      	mov	r0, r5
   4b3bc:	f000 fd03 	bl	4bdc6 <bt_conn_unref>
}
   4b3c0:	b007      	add	sp, #28
   4b3c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_LTK_REQ_NEG_REPLY, sizeof(*cp));
   4b3c4:	2102      	movs	r1, #2
   4b3c6:	f242 001b 	movw	r0, #8219	; 0x201b
   4b3ca:	f7e2 fd4f 	bl	2de6c <bt_hci_cmd_create>
	if (!buf) {
   4b3ce:	4604      	mov	r4, r0
   4b3d0:	2800      	cmp	r0, #0
   4b3d2:	d0f2      	beq.n	4b3ba <le_ltk_request+0x54>
   4b3d4:	2102      	movs	r1, #2
   4b3d6:	3008      	adds	r0, #8
   4b3d8:	f003 fcec 	bl	4edb4 <net_buf_simple_add>
	bt_hci_cmd_send(BT_HCI_OP_LE_LTK_REQ_NEG_REPLY, buf);
   4b3dc:	4621      	mov	r1, r4
	cp->handle = sys_cpu_to_le16(handle);
   4b3de:	8006      	strh	r6, [r0, #0]
	bt_hci_cmd_send(BT_HCI_OP_LE_LTK_REQ_NEG_REPLY, buf);
   4b3e0:	f242 001b 	movw	r0, #8219	; 0x201b
   4b3e4:	e7e7      	b.n	4b3b6 <le_ltk_request+0x50>

0004b3e6 <le_conn_param_neg_reply>:
{
   4b3e6:	b570      	push	{r4, r5, r6, lr}
   4b3e8:	4606      	mov	r6, r0
   4b3ea:	460d      	mov	r5, r1
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_CONN_PARAM_REQ_NEG_REPLY,
   4b3ec:	f242 0021 	movw	r0, #8225	; 0x2021
   4b3f0:	2103      	movs	r1, #3
   4b3f2:	f7e2 fd3b 	bl	2de6c <bt_hci_cmd_create>
	if (!buf) {
   4b3f6:	4604      	mov	r4, r0
   4b3f8:	b160      	cbz	r0, 4b414 <le_conn_param_neg_reply+0x2e>
   4b3fa:	2103      	movs	r1, #3
   4b3fc:	3008      	adds	r0, #8
   4b3fe:	f003 fcd9 	bl	4edb4 <net_buf_simple_add>
	cp->handle = sys_cpu_to_le16(handle);
   4b402:	8006      	strh	r6, [r0, #0]
	cp->reason = sys_cpu_to_le16(reason);
   4b404:	7085      	strb	r5, [r0, #2]
	bt_hci_cmd_send(BT_HCI_OP_LE_CONN_PARAM_REQ_NEG_REPLY, buf);
   4b406:	4621      	mov	r1, r4
   4b408:	f242 0021 	movw	r0, #8225	; 0x2021
}
   4b40c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	bt_hci_cmd_send(BT_HCI_OP_LE_CONN_PARAM_REQ_NEG_REPLY, buf);
   4b410:	f7e2 bd66 	b.w	2dee0 <bt_hci_cmd_send>
}
   4b414:	bd70      	pop	{r4, r5, r6, pc}

0004b416 <le_conn_param_req>:
{
   4b416:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	struct bt_hci_evt_le_conn_param_req *evt = (void *)buf->data;
   4b418:	6883      	ldr	r3, [r0, #8]
	param.interval_min = sys_le16_to_cpu(evt->interval_min);
   4b41a:	78d9      	ldrb	r1, [r3, #3]
   4b41c:	789a      	ldrb	r2, [r3, #2]
	handle = sys_le16_to_cpu(evt->handle);
   4b41e:	881f      	ldrh	r7, [r3, #0]
	param.interval_min = sys_le16_to_cpu(evt->interval_min);
   4b420:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
   4b424:	f8ad 2000 	strh.w	r2, [sp]
	param.interval_max = sys_le16_to_cpu(evt->interval_max);
   4b428:	7959      	ldrb	r1, [r3, #5]
   4b42a:	791a      	ldrb	r2, [r3, #4]
   4b42c:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
   4b430:	f8ad 2002 	strh.w	r2, [sp, #2]
	param.latency = sys_le16_to_cpu(evt->latency);
   4b434:	799a      	ldrb	r2, [r3, #6]
   4b436:	79d9      	ldrb	r1, [r3, #7]
   4b438:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
   4b43c:	f8ad 2004 	strh.w	r2, [sp, #4]
	param.timeout = sys_le16_to_cpu(evt->timeout);
   4b440:	7a1a      	ldrb	r2, [r3, #8]
   4b442:	7a5b      	ldrb	r3, [r3, #9]
	handle = sys_le16_to_cpu(evt->handle);
   4b444:	b2bc      	uxth	r4, r7
	param.timeout = sys_le16_to_cpu(evt->timeout);
   4b446:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
	conn = bt_conn_lookup_handle(handle);
   4b44a:	4620      	mov	r0, r4
	param.timeout = sys_le16_to_cpu(evt->timeout);
   4b44c:	f8ad 3006 	strh.w	r3, [sp, #6]
	conn = bt_conn_lookup_handle(handle);
   4b450:	f7e4 fc78 	bl	2fd44 <bt_conn_lookup_handle>
	if (!conn) {
   4b454:	4606      	mov	r6, r0
   4b456:	b928      	cbnz	r0, 4b464 <le_conn_param_req+0x4e>
		le_conn_param_neg_reply(handle, BT_HCI_ERR_UNKNOWN_CONN_ID);
   4b458:	2102      	movs	r1, #2
   4b45a:	4620      	mov	r0, r4
   4b45c:	f7ff ffc3 	bl	4b3e6 <le_conn_param_neg_reply>
}
   4b460:	b003      	add	sp, #12
   4b462:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (!le_param_req(conn, &param)) {
   4b464:	4669      	mov	r1, sp
   4b466:	f7e4 fdcf 	bl	30008 <le_param_req>
   4b46a:	b938      	cbnz	r0, 4b47c <le_conn_param_req+0x66>
		le_conn_param_neg_reply(handle, BT_HCI_ERR_INVALID_LL_PARAM);
   4b46c:	211e      	movs	r1, #30
   4b46e:	4620      	mov	r0, r4
   4b470:	f7ff ffb9 	bl	4b3e6 <le_conn_param_neg_reply>
	bt_conn_unref(conn);
   4b474:	4630      	mov	r0, r6
   4b476:	f000 fca6 	bl	4bdc6 <bt_conn_unref>
   4b47a:	e7f1      	b.n	4b460 <le_conn_param_req+0x4a>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_CONN_PARAM_REQ_REPLY, sizeof(*cp));
   4b47c:	210e      	movs	r1, #14
   4b47e:	f242 0020 	movw	r0, #8224	; 0x2020
   4b482:	f7e2 fcf3 	bl	2de6c <bt_hci_cmd_create>
	if (!buf) {
   4b486:	4605      	mov	r5, r0
   4b488:	2800      	cmp	r0, #0
   4b48a:	d0f3      	beq.n	4b474 <le_conn_param_req+0x5e>
   4b48c:	210e      	movs	r1, #14
   4b48e:	3008      	adds	r0, #8
   4b490:	f003 fc90 	bl	4edb4 <net_buf_simple_add>
   4b494:	4604      	mov	r4, r0
	(void)memset(cp, 0, sizeof(*cp));
   4b496:	220e      	movs	r2, #14
   4b498:	2100      	movs	r1, #0
   4b49a:	f7ff fcf9 	bl	4ae90 <memset>
	cp->handle = sys_cpu_to_le16(handle);
   4b49e:	8027      	strh	r7, [r4, #0]
	cp->interval_min = sys_cpu_to_le16(param->interval_min);
   4b4a0:	f8bd 3000 	ldrh.w	r3, [sp]
   4b4a4:	8063      	strh	r3, [r4, #2]
	cp->interval_max = sys_cpu_to_le16(param->interval_max);
   4b4a6:	f8bd 3002 	ldrh.w	r3, [sp, #2]
   4b4aa:	80a3      	strh	r3, [r4, #4]
	cp->latency = sys_cpu_to_le16(param->latency);
   4b4ac:	f8bd 3004 	ldrh.w	r3, [sp, #4]
   4b4b0:	80e3      	strh	r3, [r4, #6]
	cp->timeout = sys_cpu_to_le16(param->timeout);
   4b4b2:	f8bd 3006 	ldrh.w	r3, [sp, #6]
   4b4b6:	8123      	strh	r3, [r4, #8]
	return bt_hci_cmd_send(BT_HCI_OP_LE_CONN_PARAM_REQ_REPLY, buf);
   4b4b8:	4629      	mov	r1, r5
   4b4ba:	f242 0020 	movw	r0, #8224	; 0x2020
   4b4be:	f7e2 fd0f 	bl	2dee0 <bt_hci_cmd_send>
   4b4c2:	e7d7      	b.n	4b474 <le_conn_param_req+0x5e>

0004b4c4 <hci_le_read_max_data_len>:
{
   4b4c4:	b573      	push	{r0, r1, r4, r5, r6, lr}
   4b4c6:	4606      	mov	r6, r0
   4b4c8:	460d      	mov	r5, r1
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_MAX_DATA_LEN, NULL, &rsp);
   4b4ca:	aa01      	add	r2, sp, #4
   4b4cc:	2100      	movs	r1, #0
   4b4ce:	f242 002f 	movw	r0, #8239	; 0x202f
   4b4d2:	f7e2 fd27 	bl	2df24 <bt_hci_cmd_send_sync>
	if (err) {
   4b4d6:	4604      	mov	r4, r0
   4b4d8:	b948      	cbnz	r0, 4b4ee <hci_le_read_max_data_len+0x2a>
	rp = (void *)rsp->data;
   4b4da:	9801      	ldr	r0, [sp, #4]
   4b4dc:	6883      	ldr	r3, [r0, #8]
	*tx_octets = sys_le16_to_cpu(rp->max_tx_octets);
   4b4de:	f8b3 2001 	ldrh.w	r2, [r3, #1]
   4b4e2:	8032      	strh	r2, [r6, #0]
	*tx_time = sys_le16_to_cpu(rp->max_tx_time);
   4b4e4:	f8b3 3003 	ldrh.w	r3, [r3, #3]
   4b4e8:	802b      	strh	r3, [r5, #0]
	net_buf_unref(rsp);
   4b4ea:	f7f7 f9ad 	bl	42848 <net_buf_unref>
}
   4b4ee:	4620      	mov	r0, r4
   4b4f0:	b002      	add	sp, #8
   4b4f2:	bd70      	pop	{r4, r5, r6, pc}

0004b4f4 <le_phy_update_complete>:
{
   4b4f4:	b538      	push	{r3, r4, r5, lr}
	struct bt_hci_evt_le_phy_update_complete *evt = (void *)buf->data;
   4b4f6:	6885      	ldr	r5, [r0, #8]
	conn = bt_conn_lookup_handle(handle);
   4b4f8:	f8b5 0001 	ldrh.w	r0, [r5, #1]
   4b4fc:	f7e4 fc22 	bl	2fd44 <bt_conn_lookup_handle>
	if (!conn) {
   4b500:	4604      	mov	r4, r0
   4b502:	b188      	cbz	r0, 4b528 <le_phy_update_complete+0x34>
	conn->le.phy.tx_phy = bt_get_phy(evt->tx_phy);
   4b504:	78e8      	ldrb	r0, [r5, #3]
   4b506:	f7e2 fd9b 	bl	2e040 <bt_get_phy>
   4b50a:	f884 00b8 	strb.w	r0, [r4, #184]	; 0xb8
	conn->le.phy.rx_phy = bt_get_phy(evt->rx_phy);
   4b50e:	7928      	ldrb	r0, [r5, #4]
   4b510:	f7e2 fd96 	bl	2e040 <bt_get_phy>
   4b514:	f884 00b9 	strb.w	r0, [r4, #185]	; 0xb9
	notify_le_phy_updated(conn);
   4b518:	4620      	mov	r0, r4
   4b51a:	f7e4 fd53 	bl	2ffc4 <notify_le_phy_updated>
	bt_conn_unref(conn);
   4b51e:	4620      	mov	r0, r4
}
   4b520:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	bt_conn_unref(conn);
   4b524:	f000 bc4f 	b.w	4bdc6 <bt_conn_unref>
}
   4b528:	bd38      	pop	{r3, r4, r5, pc}

0004b52a <bt_hci_disconnect>:
{
   4b52a:	b570      	push	{r4, r5, r6, lr}
   4b52c:	4606      	mov	r6, r0
   4b52e:	460d      	mov	r5, r1
	buf = bt_hci_cmd_create(BT_HCI_OP_DISCONNECT, sizeof(*disconn));
   4b530:	f240 4006 	movw	r0, #1030	; 0x406
   4b534:	2103      	movs	r1, #3
   4b536:	f7e2 fc99 	bl	2de6c <bt_hci_cmd_create>
	if (!buf) {
   4b53a:	4604      	mov	r4, r0
   4b53c:	b168      	cbz	r0, 4b55a <bt_hci_disconnect+0x30>
   4b53e:	2103      	movs	r1, #3
   4b540:	3008      	adds	r0, #8
   4b542:	f003 fc37 	bl	4edb4 <net_buf_simple_add>
	disconn->handle = sys_cpu_to_le16(handle);
   4b546:	8006      	strh	r6, [r0, #0]
	disconn->reason = reason;
   4b548:	7085      	strb	r5, [r0, #2]
	return bt_hci_cmd_send_sync(BT_HCI_OP_DISCONNECT, buf, NULL);
   4b54a:	4621      	mov	r1, r4
   4b54c:	2200      	movs	r2, #0
}
   4b54e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return bt_hci_cmd_send_sync(BT_HCI_OP_DISCONNECT, buf, NULL);
   4b552:	f240 4006 	movw	r0, #1030	; 0x406
   4b556:	f7e2 bce5 	b.w	2df24 <bt_hci_cmd_send_sync>
}
   4b55a:	f06f 0068 	mvn.w	r0, #104	; 0x68
   4b55e:	bd70      	pop	{r4, r5, r6, pc}

0004b560 <bt_le_set_data_len>:
{
   4b560:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   4b562:	4607      	mov	r7, r0
   4b564:	460e      	mov	r6, r1
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_DATA_LEN, sizeof(*cp));
   4b566:	f242 0022 	movw	r0, #8226	; 0x2022
   4b56a:	2106      	movs	r1, #6
{
   4b56c:	4615      	mov	r5, r2
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_DATA_LEN, sizeof(*cp));
   4b56e:	f7e2 fc7d 	bl	2de6c <bt_hci_cmd_create>
	if (!buf) {
   4b572:	4604      	mov	r4, r0
   4b574:	b178      	cbz	r0, 4b596 <bt_le_set_data_len+0x36>
   4b576:	2106      	movs	r1, #6
   4b578:	3008      	adds	r0, #8
   4b57a:	f003 fc1b 	bl	4edb4 <net_buf_simple_add>
	cp->handle = sys_cpu_to_le16(conn->handle);
   4b57e:	883b      	ldrh	r3, [r7, #0]
   4b580:	8003      	strh	r3, [r0, #0]
	cp->tx_octets = sys_cpu_to_le16(tx_octets);
   4b582:	8046      	strh	r6, [r0, #2]
	cp->tx_time = sys_cpu_to_le16(tx_time);
   4b584:	8085      	strh	r5, [r0, #4]
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_DATA_LEN, buf, NULL);
   4b586:	4621      	mov	r1, r4
   4b588:	2200      	movs	r2, #0
}
   4b58a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_DATA_LEN, buf, NULL);
   4b58e:	f242 0022 	movw	r0, #8226	; 0x2022
   4b592:	f7e2 bcc7 	b.w	2df24 <bt_hci_cmd_send_sync>
}
   4b596:	f06f 0068 	mvn.w	r0, #104	; 0x68
   4b59a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0004b59c <bt_le_set_phy>:
{
   4b59c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   4b5a0:	4681      	mov	r9, r0
   4b5a2:	4688      	mov	r8, r1
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_PHY, sizeof(*cp));
   4b5a4:	f242 0032 	movw	r0, #8242	; 0x2032
   4b5a8:	2107      	movs	r1, #7
{
   4b5aa:	f89d a020 	ldrb.w	sl, [sp, #32]
   4b5ae:	4617      	mov	r7, r2
   4b5b0:	461e      	mov	r6, r3
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_PHY, sizeof(*cp));
   4b5b2:	f7e2 fc5b 	bl	2de6c <bt_hci_cmd_create>
	if (!buf) {
   4b5b6:	4605      	mov	r5, r0
   4b5b8:	b1a0      	cbz	r0, 4b5e4 <bt_le_set_phy+0x48>
   4b5ba:	2107      	movs	r1, #7
   4b5bc:	3008      	adds	r0, #8
   4b5be:	f003 fbf9 	bl	4edb4 <net_buf_simple_add>
	cp->handle = sys_cpu_to_le16(conn->handle);
   4b5c2:	f8b9 3000 	ldrh.w	r3, [r9]
   4b5c6:	8003      	strh	r3, [r0, #0]
	cp->all_phys = all_phys;
   4b5c8:	f880 8002 	strb.w	r8, [r0, #2]
	cp->tx_phys = pref_tx_phy;
   4b5cc:	70c7      	strb	r7, [r0, #3]
	cp->rx_phys = pref_rx_phy;
   4b5ce:	7106      	strb	r6, [r0, #4]
	cp->phy_opts = phy_opts;
   4b5d0:	f8a0 a005 	strh.w	sl, [r0, #5]
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_PHY, buf, NULL);
   4b5d4:	4629      	mov	r1, r5
   4b5d6:	2200      	movs	r2, #0
}
   4b5d8:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_PHY, buf, NULL);
   4b5dc:	f242 0032 	movw	r0, #8242	; 0x2032
   4b5e0:	f7e2 bca0 	b.w	2df24 <bt_hci_cmd_send_sync>
}
   4b5e4:	f06f 0068 	mvn.w	r0, #104	; 0x68
   4b5e8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0004b5ec <le_enh_conn_complete>:
	bt_hci_le_enh_conn_complete(evt);
   4b5ec:	6880      	ldr	r0, [r0, #8]
   4b5ee:	f7e2 bda9 	b.w	2e144 <bt_hci_le_enh_conn_complete>

0004b5f2 <bt_le_conn_params_valid>:
{
   4b5f2:	b510      	push	{r4, lr}
	if (param->interval_min > param->interval_max ||
   4b5f4:	8803      	ldrh	r3, [r0, #0]
   4b5f6:	8842      	ldrh	r2, [r0, #2]
   4b5f8:	4293      	cmp	r3, r2
   4b5fa:	d819      	bhi.n	4b630 <bt_le_conn_params_valid+0x3e>
   4b5fc:	2b05      	cmp	r3, #5
   4b5fe:	d917      	bls.n	4b630 <bt_le_conn_params_valid+0x3e>
	    param->interval_min < 6 || param->interval_max > 3200) {
   4b600:	f5b2 6f48 	cmp.w	r2, #3200	; 0xc80
   4b604:	d814      	bhi.n	4b630 <bt_le_conn_params_valid+0x3e>
	if (param->latency > 499) {
   4b606:	8883      	ldrh	r3, [r0, #4]
   4b608:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
   4b60c:	d210      	bcs.n	4b630 <bt_le_conn_params_valid+0x3e>
	if (param->timeout < 10 || param->timeout > 3200 ||
   4b60e:	88c0      	ldrh	r0, [r0, #6]
   4b610:	f1a0 010a 	sub.w	r1, r0, #10
   4b614:	b289      	uxth	r1, r1
   4b616:	f640 4476 	movw	r4, #3190	; 0xc76
   4b61a:	42a1      	cmp	r1, r4
   4b61c:	d808      	bhi.n	4b630 <bt_le_conn_params_valid+0x3e>
	     ((1U + param->latency) * param->interval_max))) {
   4b61e:	3301      	adds	r3, #1
   4b620:	b29b      	uxth	r3, r3
   4b622:	4353      	muls	r3, r2
	if (param->timeout < 10 || param->timeout > 3200 ||
   4b624:	ebb3 0f80 	cmp.w	r3, r0, lsl #2
   4b628:	bf34      	ite	cc
   4b62a:	2001      	movcc	r0, #1
   4b62c:	2000      	movcs	r0, #0
}
   4b62e:	bd10      	pop	{r4, pc}
		return false;
   4b630:	2000      	movs	r0, #0
   4b632:	e7fc      	b.n	4b62e <bt_le_conn_params_valid+0x3c>

0004b634 <hci_encrypt_key_refresh_complete>:
{
   4b634:	b538      	push	{r3, r4, r5, lr}
	struct bt_hci_evt_encrypt_key_refresh_complete *evt = (void *)buf->data;
   4b636:	6883      	ldr	r3, [r0, #8]
	conn = bt_conn_lookup_handle(handle);
   4b638:	f8b3 0001 	ldrh.w	r0, [r3, #1]
	uint8_t status = evt->status;
   4b63c:	781d      	ldrb	r5, [r3, #0]
	conn = bt_conn_lookup_handle(handle);
   4b63e:	f7e4 fb81 	bl	2fd44 <bt_conn_lookup_handle>
	if (!conn) {
   4b642:	4604      	mov	r4, r0
   4b644:	b320      	cbz	r0, 4b690 <hci_encrypt_key_refresh_complete+0x5c>
	if (status) {
   4b646:	b165      	cbz	r5, 4b662 <hci_encrypt_key_refresh_complete+0x2e>
	bt_conn_security_changed(conn, status, bt_security_err_get(status));
   4b648:	4628      	mov	r0, r5
   4b64a:	f7e2 ff29 	bl	2e4a0 <bt_security_err_get>
   4b64e:	4629      	mov	r1, r5
   4b650:	4602      	mov	r2, r0
   4b652:	4620      	mov	r0, r4
   4b654:	f7e4 fd40 	bl	300d8 <bt_conn_security_changed>
	bt_conn_unref(conn);
   4b658:	4620      	mov	r0, r4
}
   4b65a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	bt_conn_unref(conn);
   4b65e:	f000 bbb2 	b.w	4bdc6 <bt_conn_unref>
	if (conn->type == BT_CONN_TYPE_LE) {
   4b662:	7883      	ldrb	r3, [r0, #2]
   4b664:	2b01      	cmp	r3, #1
   4b666:	d1ef      	bne.n	4b648 <hci_encrypt_key_refresh_complete+0x14>
		bt_smp_update_keys(conn);
   4b668:	f003 fa61 	bl	4eb2e <bt_smp_update_keys>
		if (!update_sec_level(conn)) {
   4b66c:	4620      	mov	r0, r4
   4b66e:	f7ff fd2f 	bl	4b0d0 <update_sec_level>
   4b672:	2800      	cmp	r0, #0
   4b674:	d1e8      	bne.n	4b648 <hci_encrypt_key_refresh_complete+0x14>
	bt_conn_security_changed(conn, status, bt_security_err_get(status));
   4b676:	2005      	movs	r0, #5
   4b678:	f7e2 ff12 	bl	2e4a0 <bt_security_err_get>
   4b67c:	2105      	movs	r1, #5
   4b67e:	4602      	mov	r2, r0
   4b680:	4620      	mov	r0, r4
   4b682:	f7e4 fd29 	bl	300d8 <bt_conn_security_changed>
		bt_conn_disconnect(conn, status);
   4b686:	2105      	movs	r1, #5
   4b688:	4620      	mov	r0, r4
   4b68a:	f000 fc77 	bl	4bf7c <bt_conn_disconnect>
   4b68e:	e7e3      	b.n	4b658 <hci_encrypt_key_refresh_complete+0x24>
}
   4b690:	bd38      	pop	{r3, r4, r5, pc}

0004b692 <hci_encrypt_change>:
{
   4b692:	b570      	push	{r4, r5, r6, lr}
	struct bt_hci_evt_encrypt_change *evt = (void *)buf->data;
   4b694:	6886      	ldr	r6, [r0, #8]
	conn = bt_conn_lookup_handle(handle);
   4b696:	f8b6 0001 	ldrh.w	r0, [r6, #1]
	uint8_t status = evt->status;
   4b69a:	7835      	ldrb	r5, [r6, #0]
	conn = bt_conn_lookup_handle(handle);
   4b69c:	f7e4 fb52 	bl	2fd44 <bt_conn_lookup_handle>
	if (!conn) {
   4b6a0:	4604      	mov	r4, r0
   4b6a2:	b368      	cbz	r0, 4b700 <hci_encrypt_change+0x6e>
	if (status) {
   4b6a4:	b165      	cbz	r5, 4b6c0 <hci_encrypt_change+0x2e>
		bt_conn_security_changed(conn, status,
   4b6a6:	4628      	mov	r0, r5
   4b6a8:	f7e2 fefa 	bl	2e4a0 <bt_security_err_get>
   4b6ac:	4629      	mov	r1, r5
   4b6ae:	4602      	mov	r2, r0
	bt_conn_security_changed(conn, status, bt_security_err_get(status));
   4b6b0:	4620      	mov	r0, r4
   4b6b2:	f7e4 fd11 	bl	300d8 <bt_conn_security_changed>
	bt_conn_unref(conn);
   4b6b6:	4620      	mov	r0, r4
}
   4b6b8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	bt_conn_unref(conn);
   4b6bc:	f000 bb83 	b.w	4bdc6 <bt_conn_unref>
	if (conn->type == BT_CONN_TYPE_LE) {
   4b6c0:	7882      	ldrb	r2, [r0, #2]
	conn->encrypt = evt->encrypt;
   4b6c2:	78f3      	ldrb	r3, [r6, #3]
   4b6c4:	72c3      	strb	r3, [r0, #11]
	if (conn->type == BT_CONN_TYPE_LE) {
   4b6c6:	2a01      	cmp	r2, #1
   4b6c8:	d005      	beq.n	4b6d6 <hci_encrypt_change+0x44>
	bt_conn_security_changed(conn, status, bt_security_err_get(status));
   4b6ca:	2000      	movs	r0, #0
   4b6cc:	f7e2 fee8 	bl	2e4a0 <bt_security_err_get>
   4b6d0:	2100      	movs	r1, #0
   4b6d2:	4602      	mov	r2, r0
   4b6d4:	e7ec      	b.n	4b6b0 <hci_encrypt_change+0x1e>
		if (conn->encrypt) {
   4b6d6:	b10b      	cbz	r3, 4b6dc <hci_encrypt_change+0x4a>
			bt_smp_update_keys(conn);
   4b6d8:	f003 fa29 	bl	4eb2e <bt_smp_update_keys>
		if (!update_sec_level(conn)) {
   4b6dc:	4620      	mov	r0, r4
   4b6de:	f7ff fcf7 	bl	4b0d0 <update_sec_level>
   4b6e2:	2800      	cmp	r0, #0
   4b6e4:	d1f1      	bne.n	4b6ca <hci_encrypt_change+0x38>
	bt_conn_security_changed(conn, status, bt_security_err_get(status));
   4b6e6:	2005      	movs	r0, #5
   4b6e8:	f7e2 feda 	bl	2e4a0 <bt_security_err_get>
   4b6ec:	2105      	movs	r1, #5
   4b6ee:	4602      	mov	r2, r0
   4b6f0:	4620      	mov	r0, r4
   4b6f2:	f7e4 fcf1 	bl	300d8 <bt_conn_security_changed>
		bt_conn_disconnect(conn, status);
   4b6f6:	2105      	movs	r1, #5
   4b6f8:	4620      	mov	r0, r4
   4b6fa:	f000 fc3f 	bl	4bf7c <bt_conn_disconnect>
   4b6fe:	e7da      	b.n	4b6b6 <hci_encrypt_change+0x24>
}
   4b700:	bd70      	pop	{r4, r5, r6, pc}

0004b702 <bt_send>:
		return bt_hci_ecc_send(buf);
   4b702:	f7e1 bfbb 	b.w	2d67c <bt_hci_ecc_send>

0004b706 <bt_get_appearance>:
#if defined(CONFIG_BT_DEVICE_APPEARANCE_DYNAMIC)
	return bt_dev.appearance;
#else
	return CONFIG_BT_DEVICE_APPEARANCE;
#endif
}
   4b706:	f240 30c1 	movw	r0, #961	; 0x3c1
   4b70a:	4770      	bx	lr

0004b70c <bt_addr_le_is_bonded>:
	return 0;
}
#endif

bool bt_addr_le_is_bonded(uint8_t id, const bt_addr_le_t *addr)
{
   4b70c:	b508      	push	{r3, lr}
	if (IS_ENABLED(CONFIG_BT_SMP)) {
		struct bt_keys *keys = bt_keys_find_addr(id, addr);
   4b70e:	f7e8 fe3d 	bl	3438c <bt_keys_find_addr>

		/* if there are any keys stored then device is bonded */
		return keys && keys->keys;
   4b712:	b118      	cbz	r0, 4b71c <bt_addr_le_is_bonded+0x10>
   4b714:	89c0      	ldrh	r0, [r0, #14]
   4b716:	3800      	subs	r0, #0
   4b718:	bf18      	it	ne
   4b71a:	2001      	movne	r0, #1
	} else {
		return false;
	}
}
   4b71c:	bd08      	pop	{r3, pc}

0004b71e <bt_data_parse>:
#endif

void bt_data_parse(struct net_buf_simple *ad,
		   bool (*func)(struct bt_data *data, void *user_data),
		   void *user_data)
{
   4b71e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   4b720:	4604      	mov	r4, r0
   4b722:	460e      	mov	r6, r1
   4b724:	4617      	mov	r7, r2
	while (ad->len > 1) {
   4b726:	88a3      	ldrh	r3, [r4, #4]
   4b728:	2b01      	cmp	r3, #1
   4b72a:	d801      	bhi.n	4b730 <bt_data_parse+0x12>
			return;
		}

		net_buf_simple_pull(ad, len - 1);
	}
}
   4b72c:	b003      	add	sp, #12
   4b72e:	bdf0      	pop	{r4, r5, r6, r7, pc}
		len = net_buf_simple_pull_u8(ad);
   4b730:	4620      	mov	r0, r4
   4b732:	f003 fb78 	bl	4ee26 <net_buf_simple_pull_u8>
		if (len == 0U) {
   4b736:	4605      	mov	r5, r0
   4b738:	2800      	cmp	r0, #0
   4b73a:	d0f7      	beq.n	4b72c <bt_data_parse+0xe>
		if (len > ad->len) {
   4b73c:	88a3      	ldrh	r3, [r4, #4]
   4b73e:	4283      	cmp	r3, r0
   4b740:	d3f4      	bcc.n	4b72c <bt_data_parse+0xe>
		data.type = net_buf_simple_pull_u8(ad);
   4b742:	4620      	mov	r0, r4
   4b744:	f003 fb6f 	bl	4ee26 <net_buf_simple_pull_u8>
		data.data_len = len - 1;
   4b748:	3d01      	subs	r5, #1
		data.data = ad->data;
   4b74a:	6823      	ldr	r3, [r4, #0]
		data.type = net_buf_simple_pull_u8(ad);
   4b74c:	f88d 0000 	strb.w	r0, [sp]
		if (!func(&data, user_data)) {
   4b750:	4639      	mov	r1, r7
   4b752:	4668      	mov	r0, sp
		data.data_len = len - 1;
   4b754:	f88d 5001 	strb.w	r5, [sp, #1]
		data.data = ad->data;
   4b758:	9301      	str	r3, [sp, #4]
		if (!func(&data, user_data)) {
   4b75a:	47b0      	blx	r6
   4b75c:	2800      	cmp	r0, #0
   4b75e:	d0e5      	beq.n	4b72c <bt_data_parse+0xe>
		net_buf_simple_pull(ad, len - 1);
   4b760:	4629      	mov	r1, r5
   4b762:	4620      	mov	r0, r4
   4b764:	f003 fb4f 	bl	4ee06 <net_buf_simple_pull>
   4b768:	e7dd      	b.n	4b726 <bt_data_parse+0x8>

0004b76a <bt_hci_evt_create>:
#include <stdint.h>
#include <zephyr/sys/byteorder.h>
#include <zephyr/drivers/bluetooth/hci_driver.h>

struct net_buf *bt_hci_evt_create(uint8_t evt, uint8_t len)
{
   4b76a:	b570      	push	{r4, r5, r6, lr}
	struct bt_hci_evt_hdr *hdr;
	struct net_buf *buf;

	buf = bt_buf_get_evt(evt, false, K_FOREVER);
   4b76c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
{
   4b770:	460d      	mov	r5, r1
	buf = bt_buf_get_evt(evt, false, K_FOREVER);
   4b772:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   4b776:	2100      	movs	r1, #0
{
   4b778:	4606      	mov	r6, r0
	buf = bt_buf_get_evt(evt, false, K_FOREVER);
   4b77a:	f7e2 f98f 	bl	2da9c <bt_buf_get_evt>
   4b77e:	2102      	movs	r1, #2
   4b780:	4604      	mov	r4, r0
   4b782:	3008      	adds	r0, #8
   4b784:	f003 fb16 	bl	4edb4 <net_buf_simple_add>

	hdr = net_buf_add(buf, sizeof(*hdr));
	hdr->evt = evt;
   4b788:	7006      	strb	r6, [r0, #0]
	hdr->len = len;
   4b78a:	7045      	strb	r5, [r0, #1]

	return buf;
}
   4b78c:	4620      	mov	r0, r4
   4b78e:	bd70      	pop	{r4, r5, r6, pc}

0004b790 <bt_hci_cmd_complete_create>:
struct net_buf *bt_hci_cmd_complete_create(uint16_t op, uint8_t plen)
{
	struct net_buf *buf;
	struct bt_hci_evt_cmd_complete *cc;

	buf = bt_hci_evt_create(BT_HCI_EVT_CMD_COMPLETE, sizeof(*cc) + plen);
   4b790:	3103      	adds	r1, #3
{
   4b792:	b538      	push	{r3, r4, r5, lr}
	buf = bt_hci_evt_create(BT_HCI_EVT_CMD_COMPLETE, sizeof(*cc) + plen);
   4b794:	b2c9      	uxtb	r1, r1
{
   4b796:	4605      	mov	r5, r0
	buf = bt_hci_evt_create(BT_HCI_EVT_CMD_COMPLETE, sizeof(*cc) + plen);
   4b798:	200e      	movs	r0, #14
   4b79a:	f7ff ffe6 	bl	4b76a <bt_hci_evt_create>
   4b79e:	2103      	movs	r1, #3
   4b7a0:	4604      	mov	r4, r0
   4b7a2:	3008      	adds	r0, #8
   4b7a4:	f003 fb06 	bl	4edb4 <net_buf_simple_add>

	cc = net_buf_add(buf, sizeof(*cc));
	cc->ncmd = 1U;
   4b7a8:	2301      	movs	r3, #1
   4b7aa:	7003      	strb	r3, [r0, #0]
	cc->opcode = sys_cpu_to_le16(op);
   4b7ac:	f8a0 5001 	strh.w	r5, [r0, #1]

	return buf;
}
   4b7b0:	4620      	mov	r0, r4
   4b7b2:	bd38      	pop	{r3, r4, r5, pc}

0004b7b4 <bt_hci_cmd_status_create>:

struct net_buf *bt_hci_cmd_status_create(uint16_t op, uint8_t status)
{
   4b7b4:	b570      	push	{r4, r5, r6, lr}
   4b7b6:	4605      	mov	r5, r0
   4b7b8:	460e      	mov	r6, r1
	struct net_buf *buf;
	struct bt_hci_evt_cmd_status *cs;

	buf = bt_hci_evt_create(BT_HCI_EVT_CMD_STATUS, sizeof(*cs));
   4b7ba:	200f      	movs	r0, #15
   4b7bc:	2104      	movs	r1, #4
   4b7be:	f7ff ffd4 	bl	4b76a <bt_hci_evt_create>
   4b7c2:	2104      	movs	r1, #4
   4b7c4:	4604      	mov	r4, r0
   4b7c6:	3008      	adds	r0, #8
   4b7c8:	f003 faf4 	bl	4edb4 <net_buf_simple_add>

	cs = net_buf_add(buf, sizeof(*cs));
	cs->status = status;
	cs->ncmd = 1U;
   4b7cc:	2201      	movs	r2, #1
	cs->status = status;
   4b7ce:	7006      	strb	r6, [r0, #0]
	cs->ncmd = 1U;
   4b7d0:	7042      	strb	r2, [r0, #1]
	cs->opcode = sys_cpu_to_le16(op);
   4b7d2:	8045      	strh	r5, [r0, #2]

	return buf;
}
   4b7d4:	4620      	mov	r0, r4
   4b7d6:	bd70      	pop	{r4, r5, r6, pc}

0004b7d8 <bt_addr_le_copy>:
   4b7d8:	2207      	movs	r2, #7
   4b7da:	f7ff bb4e 	b.w	4ae7a <memcpy>

0004b7de <atomic_get>:
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   4b7de:	f3bf 8f5b 	dmb	ish
   4b7e2:	6800      	ldr	r0, [r0, #0]
   4b7e4:	f3bf 8f5b 	dmb	ish
}
   4b7e8:	4770      	bx	lr

0004b7ea <hci_id_add>:
{
   4b7ea:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4b7ee:	4688      	mov	r8, r1
   4b7f0:	4617      	mov	r7, r2
	if (id >= CONFIG_BT_ID_MAX) {
   4b7f2:	4605      	mov	r5, r0
   4b7f4:	bb08      	cbnz	r0, 4b83a <hci_id_add+0x50>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_ADD_DEV_TO_RL, sizeof(*cp));
   4b7f6:	2127      	movs	r1, #39	; 0x27
   4b7f8:	f242 0027 	movw	r0, #8231	; 0x2027
   4b7fc:	f7e2 fb36 	bl	2de6c <bt_hci_cmd_create>
	if (!buf) {
   4b800:	4604      	mov	r4, r0
   4b802:	b1f0      	cbz	r0, 4b842 <hci_id_add+0x58>
   4b804:	2127      	movs	r1, #39	; 0x27
   4b806:	3008      	adds	r0, #8
   4b808:	f003 fad4 	bl	4edb4 <net_buf_simple_add>
	bt_addr_le_copy(&cp->peer_id_addr, addr);
   4b80c:	4641      	mov	r1, r8
   4b80e:	4606      	mov	r6, r0
   4b810:	f7ff ffe2 	bl	4b7d8 <bt_addr_le_copy>
	memcpy(cp->peer_irk, peer_irk, 16);
   4b814:	4639      	mov	r1, r7
   4b816:	2210      	movs	r2, #16
   4b818:	1df0      	adds	r0, r6, #7
   4b81a:	f7ff fb2e 	bl	4ae7a <memcpy>
	(void)memset(cp->local_irk, 0, 16);
   4b81e:	4629      	mov	r1, r5
   4b820:	2210      	movs	r2, #16
   4b822:	f106 0017 	add.w	r0, r6, #23
   4b826:	f7ff fb33 	bl	4ae90 <memset>
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_ADD_DEV_TO_RL, buf, NULL);
   4b82a:	462a      	mov	r2, r5
   4b82c:	4621      	mov	r1, r4
   4b82e:	f242 0027 	movw	r0, #8231	; 0x2027
}
   4b832:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_ADD_DEV_TO_RL, buf, NULL);
   4b836:	f7e2 bb75 	b.w	2df24 <bt_hci_cmd_send_sync>
		return -EINVAL;
   4b83a:	f06f 0015 	mvn.w	r0, #21
}
   4b83e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return -ENOBUFS;
   4b842:	f06f 0068 	mvn.w	r0, #104	; 0x68
   4b846:	e7fa      	b.n	4b83e <hci_id_add+0x54>

0004b848 <adv_unpause_enabled>:
{
   4b848:	b410      	push	{r4}
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   4b84a:	f100 0310 	add.w	r3, r0, #16
   4b84e:	f3bf 8f5b 	dmb	ish
   4b852:	e853 2f00 	ldrex	r2, [r3]
   4b856:	f422 4180 	bic.w	r1, r2, #16384	; 0x4000
   4b85a:	e843 1400 	strex	r4, r1, [r3]
   4b85e:	2c00      	cmp	r4, #0
   4b860:	d1f7      	bne.n	4b852 <adv_unpause_enabled+0xa>
   4b862:	f3bf 8f5b 	dmb	ish
	if (atomic_test_and_clear_bit(adv->flags, BT_ADV_PAUSED)) {
   4b866:	0453      	lsls	r3, r2, #17
   4b868:	d503      	bpl.n	4b872 <adv_unpause_enabled+0x2a>
}
   4b86a:	bc10      	pop	{r4}
		bt_le_adv_set_enable(adv, true);
   4b86c:	2101      	movs	r1, #1
   4b86e:	f000 b9bc 	b.w	4bbea <bt_le_adv_set_enable>
}
   4b872:	bc10      	pop	{r4}
   4b874:	4770      	bx	lr

0004b876 <keys_add_id>:
	if (keys->state & BT_KEYS_ID_ADDED) {
   4b876:	7a03      	ldrb	r3, [r0, #8]
   4b878:	075b      	lsls	r3, r3, #29
{
   4b87a:	4602      	mov	r2, r0
	if (keys->state & BT_KEYS_ID_ADDED) {
   4b87c:	d505      	bpl.n	4b88a <keys_add_id+0x14>
		hci_id_add(keys->id, &keys->addr, keys->irk.val);
   4b87e:	4601      	mov	r1, r0
   4b880:	322a      	adds	r2, #42	; 0x2a
   4b882:	f811 0b01 	ldrb.w	r0, [r1], #1
   4b886:	f7ff bfb0 	b.w	4b7ea <hci_id_add>
}
   4b88a:	4770      	bx	lr

0004b88c <addr_res_enable>:
{
   4b88c:	b538      	push	{r3, r4, r5, lr}
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_ADDR_RES_ENABLE, 1);
   4b88e:	2101      	movs	r1, #1
{
   4b890:	4605      	mov	r5, r0
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_ADDR_RES_ENABLE, 1);
   4b892:	f242 002d 	movw	r0, #8237	; 0x202d
   4b896:	f7e2 fae9 	bl	2de6c <bt_hci_cmd_create>
	if (!buf) {
   4b89a:	4604      	mov	r4, r0
   4b89c:	b158      	cbz	r0, 4b8b6 <addr_res_enable+0x2a>
	return net_buf_simple_add_u8(&buf->b, val);
   4b89e:	4629      	mov	r1, r5
   4b8a0:	3008      	adds	r0, #8
   4b8a2:	f003 fa96 	bl	4edd2 <net_buf_simple_add_u8>
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_ADDR_RES_ENABLE,
   4b8a6:	4621      	mov	r1, r4
   4b8a8:	2200      	movs	r2, #0
}
   4b8aa:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_ADDR_RES_ENABLE,
   4b8ae:	f242 002d 	movw	r0, #8237	; 0x202d
   4b8b2:	f7e2 bb37 	b.w	2df24 <bt_hci_cmd_send_sync>
}
   4b8b6:	f06f 0068 	mvn.w	r0, #104	; 0x68
   4b8ba:	bd38      	pop	{r3, r4, r5, pc}

0004b8bc <adv_pause_enabled>:
	if (atomic_test_bit(adv->flags, BT_ADV_ENABLED)) {
   4b8bc:	f100 0210 	add.w	r2, r0, #16
{
   4b8c0:	b508      	push	{r3, lr}
   4b8c2:	4603      	mov	r3, r0
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
   4b8c4:	4610      	mov	r0, r2
   4b8c6:	f7ff ff8a 	bl	4b7de <atomic_get>
	if (atomic_test_bit(adv->flags, BT_ADV_ENABLED)) {
   4b8ca:	0641      	lsls	r1, r0, #25
   4b8cc:	d511      	bpl.n	4b8f2 <adv_pause_enabled+0x36>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   4b8ce:	f3bf 8f5b 	dmb	ish
   4b8d2:	e852 0f00 	ldrex	r0, [r2]
   4b8d6:	f440 4080 	orr.w	r0, r0, #16384	; 0x4000
   4b8da:	e842 0100 	strex	r1, r0, [r2]
   4b8de:	2900      	cmp	r1, #0
   4b8e0:	d1f7      	bne.n	4b8d2 <adv_pause_enabled+0x16>
   4b8e2:	f3bf 8f5b 	dmb	ish
		bt_le_adv_set_enable(adv, false);
   4b8e6:	4618      	mov	r0, r3
   4b8e8:	2100      	movs	r1, #0
}
   4b8ea:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		bt_le_adv_set_enable(adv, false);
   4b8ee:	f000 b97c 	b.w	4bbea <bt_le_adv_set_enable>
}
   4b8f2:	bd08      	pop	{r3, pc}

0004b8f4 <bt_lookup_id_addr>:
{
   4b8f4:	b510      	push	{r4, lr}
   4b8f6:	460c      	mov	r4, r1
		keys = bt_keys_find_irk(id, addr);
   4b8f8:	f7e8 fcf6 	bl	342e8 <bt_keys_find_irk>
		if (keys) {
   4b8fc:	b100      	cbz	r0, 4b900 <bt_lookup_id_addr+0xc>
			return &keys->addr;
   4b8fe:	1c44      	adds	r4, r0, #1
}
   4b900:	4620      	mov	r0, r4
   4b902:	bd10      	pop	{r4, pc}

0004b904 <bt_id_set_adv_private_addr>:
{
   4b904:	b507      	push	{r0, r1, r2, lr}
	err = bt_rand(nrpa.val, sizeof(nrpa.val));
   4b906:	2106      	movs	r1, #6
   4b908:	4668      	mov	r0, sp
   4b90a:	f7eb fd5b 	bl	373c4 <bt_rand>
	if (err) {
   4b90e:	b940      	cbnz	r0, 4b922 <bt_id_set_adv_private_addr+0x1e>
	BT_ADDR_SET_NRPA(&nrpa);
   4b910:	f89d 3005 	ldrb.w	r3, [sp, #5]
		return set_random_address(addr);
   4b914:	4668      	mov	r0, sp
	BT_ADDR_SET_NRPA(&nrpa);
   4b916:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   4b91a:	f88d 3005 	strb.w	r3, [sp, #5]
		return set_random_address(addr);
   4b91e:	f7e2 ff65 	bl	2e7ec <set_random_address>
}
   4b922:	b003      	add	sp, #12
   4b924:	f85d fb04 	ldr.w	pc, [sp], #4

0004b928 <bt_id_scan_random_addr_check>:
{
   4b928:	b508      	push	{r3, lr}
	adv = bt_le_adv_lookup_legacy();
   4b92a:	f7e3 fb15 	bl	2ef58 <bt_le_adv_lookup_legacy>
	if (!adv) {
   4b92e:	b110      	cbz	r0, 4b936 <bt_id_scan_random_addr_check+0xe>
   4b930:	3010      	adds	r0, #16
   4b932:	f7ff ff54 	bl	4b7de <atomic_get>
}
   4b936:	2001      	movs	r0, #1
   4b938:	bd08      	pop	{r3, pc}

0004b93a <pending_id_update>:
	if (keys->state & BT_KEYS_ID_PENDING_ADD) {
   4b93a:	7a03      	ldrb	r3, [r0, #8]
   4b93c:	07d9      	lsls	r1, r3, #31
   4b93e:	d504      	bpl.n	4b94a <pending_id_update+0x10>
		keys->state &= ~BT_KEYS_ID_PENDING_ADD;
   4b940:	f023 0301 	bic.w	r3, r3, #1
   4b944:	7203      	strb	r3, [r0, #8]
		bt_id_add(keys);
   4b946:	f7e2 bfff 	b.w	2e948 <bt_id_add>
	if (keys->state & BT_KEYS_ID_PENDING_DEL) {
   4b94a:	0799      	lsls	r1, r3, #30
   4b94c:	d504      	bpl.n	4b958 <pending_id_update+0x1e>
		keys->state &= ~BT_KEYS_ID_PENDING_DEL;
   4b94e:	f023 0302 	bic.w	r3, r3, #2
   4b952:	7203      	strb	r3, [r0, #8]
		bt_id_del(keys);
   4b954:	f7e3 b89e 	b.w	2ea94 <bt_id_del>
}
   4b958:	4770      	bx	lr

0004b95a <bt_id_init>:
#if defined(CONFIG_BT_PRIVACY)
	k_work_init_delayable(&bt_dev.rpa_update, rpa_timeout);
#endif

	return 0;
}
   4b95a:	2000      	movs	r0, #0
   4b95c:	4770      	bx	lr

0004b95e <get_adv_channel_map>:
{
   4b95e:	4603      	mov	r3, r0
		channel_map &= ~0x01;
   4b960:	f410 4f00 	tst.w	r0, #32768	; 0x8000
   4b964:	bf0c      	ite	eq
   4b966:	2007      	moveq	r0, #7
   4b968:	2006      	movne	r0, #6
	if (options & BT_LE_ADV_OPT_DISABLE_CHAN_38) {
   4b96a:	03da      	lsls	r2, r3, #15
		channel_map &= ~0x02;
   4b96c:	bf48      	it	mi
   4b96e:	f000 0005 	andmi.w	r0, r0, #5
	if (options & BT_LE_ADV_OPT_DISABLE_CHAN_39) {
   4b972:	039b      	lsls	r3, r3, #14
		channel_map &= ~0x04;
   4b974:	bf48      	it	mi
   4b976:	f000 00fb 	andmi.w	r0, r0, #251	; 0xfb
}
   4b97a:	4770      	bx	lr

0004b97c <atomic_get>:
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   4b97c:	f3bf 8f5b 	dmb	ish
   4b980:	6800      	ldr	r0, [r0, #0]
   4b982:	f3bf 8f5b 	dmb	ish
}
   4b986:	4770      	bx	lr

0004b988 <atomic_and>:
{
   4b988:	b510      	push	{r4, lr}
   4b98a:	4603      	mov	r3, r0
}
   4b98c:	f3bf 8f5b 	dmb	ish
   4b990:	e853 0f00 	ldrex	r0, [r3]
   4b994:	ea00 0201 	and.w	r2, r0, r1
   4b998:	e843 2400 	strex	r4, r2, [r3]
   4b99c:	2c00      	cmp	r4, #0
   4b99e:	d1f7      	bne.n	4b990 <atomic_and+0x8>
   4b9a0:	f3bf 8f5b 	dmb	ish
   4b9a4:	bd10      	pop	{r4, pc}

0004b9a6 <hci_set_ad>:
{
   4b9a6:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4b9aa:	460c      	mov	r4, r1
	buf = bt_hci_cmd_create(hci_op, sizeof(*set_data));
   4b9ac:	2120      	movs	r1, #32
{
   4b9ae:	9000      	str	r0, [sp, #0]
   4b9b0:	4692      	mov	sl, r2
	buf = bt_hci_cmd_create(hci_op, sizeof(*set_data));
   4b9b2:	f7e2 fa5b 	bl	2de6c <bt_hci_cmd_create>
	if (!buf) {
   4b9b6:	4605      	mov	r5, r0
   4b9b8:	2800      	cmp	r0, #0
   4b9ba:	d050      	beq.n	4ba5e <hci_set_ad+0xb8>
	return net_buf_simple_add(&buf->b, len);
   4b9bc:	2120      	movs	r1, #32
   4b9be:	3008      	adds	r0, #8
   4b9c0:	f003 f9f8 	bl	4edb4 <net_buf_simple_add>
	(void)memset(set_data, 0, sizeof(*set_data));
   4b9c4:	2220      	movs	r2, #32
   4b9c6:	2100      	movs	r1, #0
   4b9c8:	4681      	mov	r9, r0
   4b9ca:	f7ff fa61 	bl	4ae90 <memset>
	err = set_data_add_complete(set_data->data, BT_GAP_ADV_MAX_ADV_DATA_LEN,
   4b9ce:	f109 0b01 	add.w	fp, r9, #1
	for (size_t i = 0; i < ad_len; i++) {
   4b9d2:	eb04 0aca 	add.w	sl, r4, sl, lsl #3
	uint8_t set_data_len = 0;
   4b9d6:	2600      	movs	r6, #0
		for (size_t j = 0; j < ad[i].len; j++) {
   4b9d8:	f8d4 8000 	ldr.w	r8, [r4]
   4b9dc:	2300      	movs	r3, #0
   4b9de:	6862      	ldr	r2, [r4, #4]
   4b9e0:	4293      	cmp	r3, r2
   4b9e2:	d30c      	bcc.n	4b9fe <hci_set_ad+0x58>
	for (size_t i = 0; i < ad_len; i++) {
   4b9e4:	3408      	adds	r4, #8
   4b9e6:	45a2      	cmp	sl, r4
   4b9e8:	d1f6      	bne.n	4b9d8 <hci_set_ad+0x32>
	return bt_hci_cmd_send_sync(hci_op, buf, NULL);
   4b9ea:	9800      	ldr	r0, [sp, #0]
	*data_len = set_data_len;
   4b9ec:	f889 6000 	strb.w	r6, [r9]
	return bt_hci_cmd_send_sync(hci_op, buf, NULL);
   4b9f0:	2200      	movs	r2, #0
   4b9f2:	4629      	mov	r1, r5
}
   4b9f4:	b003      	add	sp, #12
   4b9f6:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	return bt_hci_cmd_send_sync(hci_op, buf, NULL);
   4b9fa:	f7e2 ba93 	b.w	2df24 <bt_hci_cmd_send_sync>
			size_t len = data[j].data_len;
   4b9fe:	f898 2001 	ldrb.w	r2, [r8, #1]
			uint8_t type = data[j].type;
   4ba02:	f898 c000 	ldrb.w	ip, [r8]
			if ((set_data_len + len + 2) > set_data_len_max) {
   4ba06:	1cb0      	adds	r0, r6, #2
   4ba08:	1811      	adds	r1, r2, r0
   4ba0a:	291f      	cmp	r1, #31
   4ba0c:	d908      	bls.n	4ba20 <hci_set_ad+0x7a>
				if (!(type == BT_DATA_NAME_COMPLETE &&
   4ba0e:	f1bc 0f09 	cmp.w	ip, #9
				ssize_t shortened_len = set_data_len_max -
   4ba12:	f1c0 021f 	rsb	r2, r0, #31
				if (!(type == BT_DATA_NAME_COMPLETE &&
   4ba16:	d11a      	bne.n	4ba4e <hci_set_ad+0xa8>
   4ba18:	2a00      	cmp	r2, #0
   4ba1a:	dd18      	ble.n	4ba4e <hci_set_ad+0xa8>
				type = BT_DATA_NAME_SHORTENED;
   4ba1c:	f04f 0c08 	mov.w	ip, #8
			set_data[set_data_len++] = len + 1;
   4ba20:	b2d7      	uxtb	r7, r2
   4ba22:	1c79      	adds	r1, r7, #1
   4ba24:	f80b 1006 	strb.w	r1, [fp, r6]
   4ba28:	1c71      	adds	r1, r6, #1
			set_data[set_data_len++] = type;
   4ba2a:	b2c9      	uxtb	r1, r1
			memcpy(&set_data[set_data_len], data[j].data, len);
   4ba2c:	fa5b f080 	uxtab	r0, fp, r0
			set_data[set_data_len++] = type;
   4ba30:	f80b c001 	strb.w	ip, [fp, r1]
			memcpy(&set_data[set_data_len], data[j].data, len);
   4ba34:	f8d8 1004 	ldr.w	r1, [r8, #4]
   4ba38:	9301      	str	r3, [sp, #4]
			set_data_len += len;
   4ba3a:	3702      	adds	r7, #2
			memcpy(&set_data[set_data_len], data[j].data, len);
   4ba3c:	f7ff fa1d 	bl	4ae7a <memcpy>
		for (size_t j = 0; j < ad[i].len; j++) {
   4ba40:	9b01      	ldr	r3, [sp, #4]
			set_data_len += len;
   4ba42:	4437      	add	r7, r6
   4ba44:	b2fe      	uxtb	r6, r7
		for (size_t j = 0; j < ad[i].len; j++) {
   4ba46:	3301      	adds	r3, #1
   4ba48:	f108 0808 	add.w	r8, r8, #8
   4ba4c:	e7c7      	b.n	4b9de <hci_set_ad+0x38>
		net_buf_unref(buf);
   4ba4e:	4628      	mov	r0, r5
   4ba50:	f7f6 fefa 	bl	42848 <net_buf_unref>
		return err;
   4ba54:	f06f 0015 	mvn.w	r0, #21
}
   4ba58:	b003      	add	sp, #12
   4ba5a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return -ENOBUFS;
   4ba5e:	f06f 0068 	mvn.w	r0, #104	; 0x68
   4ba62:	e7f9      	b.n	4ba58 <hci_set_ad+0xb2>

0004ba64 <atomic_set_bit_to>:
	atomic_val_t mask = ATOMIC_MASK(bit);
   4ba64:	2301      	movs	r3, #1
{
   4ba66:	b410      	push	{r4}
	atomic_val_t mask = ATOMIC_MASK(bit);
   4ba68:	fa03 f101 	lsl.w	r1, r3, r1
{
   4ba6c:	4604      	mov	r4, r0
	if (val) {
   4ba6e:	b162      	cbz	r2, 4ba8a <atomic_set_bit_to+0x26>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   4ba70:	f3bf 8f5b 	dmb	ish
   4ba74:	e854 3f00 	ldrex	r3, [r4]
   4ba78:	430b      	orrs	r3, r1
   4ba7a:	e844 3200 	strex	r2, r3, [r4]
   4ba7e:	2a00      	cmp	r2, #0
   4ba80:	d1f8      	bne.n	4ba74 <atomic_set_bit_to+0x10>
   4ba82:	f3bf 8f5b 	dmb	ish
	}
}
   4ba86:	bc10      	pop	{r4}
   4ba88:	4770      	bx	lr
   4ba8a:	bc10      	pop	{r4}
		(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   4ba8c:	43c9      	mvns	r1, r1
   4ba8e:	f7ff bf7b 	b.w	4b988 <atomic_and>

0004ba92 <le_adv_update.constprop.0>:
static int le_adv_update(struct bt_le_ext_adv *adv,
   4ba92:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4ba96:	b087      	sub	sp, #28
   4ba98:	4605      	mov	r5, r0
   4ba9a:	f89d 6048 	ldrb.w	r6, [sp, #72]	; 0x48
   4ba9e:	f8dd 9040 	ldr.w	r9, [sp, #64]	; 0x40
   4baa2:	f89d a044 	ldrb.w	sl, [sp, #68]	; 0x44
   4baa6:	460c      	mov	r4, r1
   4baa8:	4690      	mov	r8, r2
	struct bt_ad d[2] = {};
   4baaa:	2100      	movs	r1, #0
   4baac:	2210      	movs	r2, #16
   4baae:	a802      	add	r0, sp, #8
static int le_adv_update(struct bt_le_ext_adv *adv,
   4bab0:	461f      	mov	r7, r3
	struct bt_ad d[2] = {};
   4bab2:	f7ff f9ed 	bl	4ae90 <memset>
	if (name_type != ADV_NAME_TYPE_NONE) {
   4bab6:	b9ee      	cbnz	r6, 4baf4 <le_adv_update.constprop.0+0x62>
		d[0].len = ad_len;
   4bab8:	e9cd 4802 	strd	r4, r8, [sp, #8]
		d_len = 1;
   4babc:	2201      	movs	r2, #1
	return hci_set_ad(BT_HCI_OP_LE_SET_ADV_DATA, ad, ad_len);
   4babe:	a902      	add	r1, sp, #8
   4bac0:	f242 0008 	movw	r0, #8200	; 0x2008
   4bac4:	f7ff ff6f 	bl	4b9a6 <hci_set_ad>
		if (err) {
   4bac8:	4604      	mov	r4, r0
   4baca:	b978      	cbnz	r0, 4baec <le_adv_update.constprop.0+0x5a>
	if (scannable) {
   4bacc:	f1ba 0f00 	cmp.w	sl, #0
   4bad0:	d13e      	bne.n	4bb50 <le_adv_update.constprop.0+0xbe>
   4bad2:	3510      	adds	r5, #16
   4bad4:	f3bf 8f5b 	dmb	ish
   4bad8:	e855 3f00 	ldrex	r3, [r5]
   4badc:	f043 0304 	orr.w	r3, r3, #4
   4bae0:	e845 3200 	strex	r2, r3, [r5]
   4bae4:	2a00      	cmp	r2, #0
   4bae6:	d1f7      	bne.n	4bad8 <le_adv_update.constprop.0+0x46>
   4bae8:	f3bf 8f5b 	dmb	ish
}
   4baec:	4620      	mov	r0, r4
   4baee:	b007      	add	sp, #28
   4baf0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		const char *name = bt_get_name();
   4baf4:	f7e2 fe5c 	bl	2e7b0 <bt_get_name>
   4baf8:	4683      	mov	fp, r0
		if ((ad && ad_has_name(ad, ad_len)) ||
   4bafa:	b9e4      	cbnz	r4, 4bb36 <le_adv_update.constprop.0+0xa4>
   4bafc:	bb37      	cbnz	r7, 4bb4c <le_adv_update.constprop.0+0xba>
		data = (struct bt_data)BT_DATA(
   4bafe:	4658      	mov	r0, fp
   4bb00:	f7ff f984 	bl	4ae0c <strlen>
   4bb04:	2309      	movs	r3, #9
		if (name_type == ADV_NAME_TYPE_AD) {
   4bb06:	2e01      	cmp	r6, #1
		d[0].data = ad;
   4bb08:	e9cd b401 	strd	fp, r4, [sp, #4]
		data = (struct bt_data)BT_DATA(
   4bb0c:	f88d 3000 	strb.w	r3, [sp]
   4bb10:	f88d 0001 	strb.w	r0, [sp, #1]
		d[0].len = ad_len;
   4bb14:	f8cd 800c 	str.w	r8, [sp, #12]
		if (name_type == ADV_NAME_TYPE_AD) {
   4bb18:	d1d0      	bne.n	4babc <le_adv_update.constprop.0+0x2a>
			d[1].data = &data;
   4bb1a:	f8cd d010 	str.w	sp, [sp, #16]
			d[1].len = 1;
   4bb1e:	9605      	str	r6, [sp, #20]
			d_len = 2;
   4bb20:	2202      	movs	r2, #2
   4bb22:	e7cc      	b.n	4babe <le_adv_update.constprop.0+0x2c>
		if (ad[i].type == BT_DATA_NAME_COMPLETE ||
   4bb24:	f814 2033 	ldrb.w	r2, [r4, r3, lsl #3]
   4bb28:	3a08      	subs	r2, #8
   4bb2a:	2a01      	cmp	r2, #1
   4bb2c:	d925      	bls.n	4bb7a <le_adv_update.constprop.0+0xe8>
	for (i = 0; i < ad_len; i++) {
   4bb2e:	3301      	adds	r3, #1
   4bb30:	4598      	cmp	r8, r3
   4bb32:	d1f7      	bne.n	4bb24 <le_adv_update.constprop.0+0x92>
   4bb34:	e7e2      	b.n	4bafc <le_adv_update.constprop.0+0x6a>
   4bb36:	2300      	movs	r3, #0
   4bb38:	e7fa      	b.n	4bb30 <le_adv_update.constprop.0+0x9e>
		if (ad[i].type == BT_DATA_NAME_COMPLETE ||
   4bb3a:	f817 2033 	ldrb.w	r2, [r7, r3, lsl #3]
   4bb3e:	3a08      	subs	r2, #8
   4bb40:	2a01      	cmp	r2, #1
   4bb42:	d91a      	bls.n	4bb7a <le_adv_update.constprop.0+0xe8>
	for (i = 0; i < ad_len; i++) {
   4bb44:	3301      	adds	r3, #1
   4bb46:	4599      	cmp	r9, r3
   4bb48:	d1f7      	bne.n	4bb3a <le_adv_update.constprop.0+0xa8>
   4bb4a:	e7d8      	b.n	4bafe <le_adv_update.constprop.0+0x6c>
   4bb4c:	2300      	movs	r3, #0
   4bb4e:	e7fa      	b.n	4bb46 <le_adv_update.constprop.0+0xb4>
		if (name_type == ADV_NAME_TYPE_SD) {
   4bb50:	2e02      	cmp	r6, #2
   4bb52:	f04f 0201 	mov.w	r2, #1
			d[1].len = 1;
   4bb56:	bf08      	it	eq
   4bb58:	9205      	streq	r2, [sp, #20]
	return hci_set_ad(BT_HCI_OP_LE_SET_SCAN_RSP_DATA, sd, sd_len);
   4bb5a:	a902      	add	r1, sp, #8
			d_len = 2;
   4bb5c:	bf08      	it	eq
   4bb5e:	4632      	moveq	r2, r6
	return hci_set_ad(BT_HCI_OP_LE_SET_SCAN_RSP_DATA, sd, sd_len);
   4bb60:	f242 0009 	movw	r0, #8201	; 0x2009
			d[1].data = &data;
   4bb64:	bf08      	it	eq
   4bb66:	f8cd d010 	streq.w	sp, [sp, #16]
		d[0].len = sd_len;
   4bb6a:	e9cd 7902 	strd	r7, r9, [sp, #8]
	return hci_set_ad(BT_HCI_OP_LE_SET_SCAN_RSP_DATA, sd, sd_len);
   4bb6e:	f7ff ff1a 	bl	4b9a6 <hci_set_ad>
		if (err) {
   4bb72:	2800      	cmp	r0, #0
   4bb74:	d0ad      	beq.n	4bad2 <le_adv_update.constprop.0+0x40>
   4bb76:	4604      	mov	r4, r0
   4bb78:	e7b8      	b.n	4baec <le_adv_update.constprop.0+0x5a>
			return -EINVAL;
   4bb7a:	f06f 0415 	mvn.w	r4, #21
   4bb7e:	e7b5      	b.n	4baec <le_adv_update.constprop.0+0x5a>

0004bb80 <get_adv_name_type_param>:
	if (param->options & BT_LE_ADV_OPT_USE_NAME) {
   4bb80:	6843      	ldr	r3, [r0, #4]
   4bb82:	f013 0008 	ands.w	r0, r3, #8
   4bb86:	d00a      	beq.n	4bb9e <get_adv_name_type_param+0x1e>
		if (param->options & BT_LE_ADV_OPT_FORCE_NAME_IN_AD) {
   4bb88:	035a      	lsls	r2, r3, #13
   4bb8a:	d407      	bmi.n	4bb9c <get_adv_name_type_param+0x1c>
		if ((param->options & BT_LE_ADV_OPT_EXT_ADV) &&
   4bb8c:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
			return ADV_NAME_TYPE_AD;
   4bb90:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
   4bb94:	bf14      	ite	ne
   4bb96:	2002      	movne	r0, #2
   4bb98:	2001      	moveq	r0, #1
   4bb9a:	4770      	bx	lr
   4bb9c:	2001      	movs	r0, #1
}
   4bb9e:	4770      	bx	lr

0004bba0 <bt_le_adv_set_enable_legacy>:
{
   4bba0:	b570      	push	{r4, r5, r6, lr}
   4bba2:	4606      	mov	r6, r0
   4bba4:	b086      	sub	sp, #24
   4bba6:	460d      	mov	r5, r1
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_ADV_ENABLE, 1);
   4bba8:	f242 000a 	movw	r0, #8202	; 0x200a
   4bbac:	2101      	movs	r1, #1
   4bbae:	f7e2 f95d 	bl	2de6c <bt_hci_cmd_create>
	if (!buf) {
   4bbb2:	4604      	mov	r4, r0
   4bbb4:	b1b0      	cbz	r0, 4bbe4 <bt_le_adv_set_enable_legacy+0x44>
	return net_buf_simple_add_u8(&buf->b, val);
   4bbb6:	3008      	adds	r0, #8
	if (enable) {
   4bbb8:	b195      	cbz	r5, 4bbe0 <bt_le_adv_set_enable_legacy+0x40>
   4bbba:	2101      	movs	r1, #1
   4bbbc:	f003 f909 	bl	4edd2 <net_buf_simple_add_u8>
	bt_hci_cmd_state_set_init(buf, &state, adv->flags, BT_ADV_ENABLED, enable);
   4bbc0:	f106 0210 	add.w	r2, r6, #16
   4bbc4:	a903      	add	r1, sp, #12
   4bbc6:	4620      	mov	r0, r4
   4bbc8:	9500      	str	r5, [sp, #0]
   4bbca:	2306      	movs	r3, #6
   4bbcc:	f7e2 f93c 	bl	2de48 <bt_hci_cmd_state_set_init>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_ADV_ENABLE, buf, NULL);
   4bbd0:	2200      	movs	r2, #0
   4bbd2:	4621      	mov	r1, r4
   4bbd4:	f242 000a 	movw	r0, #8202	; 0x200a
   4bbd8:	f7e2 f9a4 	bl	2df24 <bt_hci_cmd_send_sync>
}
   4bbdc:	b006      	add	sp, #24
   4bbde:	bd70      	pop	{r4, r5, r6, pc}
   4bbe0:	4629      	mov	r1, r5
   4bbe2:	e7eb      	b.n	4bbbc <bt_le_adv_set_enable_legacy+0x1c>
		return -ENOBUFS;
   4bbe4:	f06f 0068 	mvn.w	r0, #104	; 0x68
   4bbe8:	e7f8      	b.n	4bbdc <bt_le_adv_set_enable_legacy+0x3c>

0004bbea <bt_le_adv_set_enable>:
	return bt_le_adv_set_enable_legacy(adv, enable);
   4bbea:	f7ff bfd9 	b.w	4bba0 <bt_le_adv_set_enable_legacy>

0004bbee <bt_le_lim_adv_cancel_timeout>:
	return k_work_cancel_delayable(&adv->lim_adv_timeout_work);
   4bbee:	3018      	adds	r0, #24
   4bbf0:	f004 ba16 	b.w	50020 <k_work_cancel_delayable>

0004bbf4 <adv_timeout>:
		err = bt_le_adv_stop();
	} else {
		err = bt_le_ext_adv_stop(adv);
	}
#else
	err = bt_le_adv_stop();
   4bbf4:	f7e3 bb12 	b.w	2f21c <bt_le_adv_stop>

0004bbf8 <atomic_and>:
{
   4bbf8:	b510      	push	{r4, lr}
   4bbfa:	4603      	mov	r3, r0
}
   4bbfc:	f3bf 8f5b 	dmb	ish
   4bc00:	e853 0f00 	ldrex	r0, [r3]
   4bc04:	ea00 0201 	and.w	r2, r0, r1
   4bc08:	e843 2400 	strex	r4, r2, [r3]
   4bc0c:	2c00      	cmp	r4, #0
   4bc0e:	d1f7      	bne.n	4bc00 <atomic_and+0x8>
   4bc10:	f3bf 8f5b 	dmb	ish
   4bc14:	bd10      	pop	{r4, pc}

0004bc16 <bt_le_scan_set_enable>:
	return bt_le_scan_set_enable_legacy(enable);
   4bc16:	f7e3 bb87 	b.w	2f328 <bt_le_scan_set_enable_legacy>

0004bc1a <sys_slist_find_and_remove>:
	return list->head;
   4bc1a:	6803      	ldr	r3, [r0, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   4bc1c:	2200      	movs	r2, #0
   4bc1e:	b90b      	cbnz	r3, 4bc24 <sys_slist_find_and_remove+0xa>
   4bc20:	4618      	mov	r0, r3
   4bc22:	4770      	bx	lr
   4bc24:	428b      	cmp	r3, r1
   4bc26:	d110      	bne.n	4bc4a <sys_slist_find_and_remove+0x30>
	return node->next;
   4bc28:	680b      	ldr	r3, [r1, #0]
Z_GENLIST_REMOVE(slist, snode)
   4bc2a:	b942      	cbnz	r2, 4bc3e <sys_slist_find_and_remove+0x24>
   4bc2c:	6842      	ldr	r2, [r0, #4]
	list->head = node;
   4bc2e:	6003      	str	r3, [r0, #0]
Z_GENLIST_REMOVE(slist, snode)
   4bc30:	4291      	cmp	r1, r2
   4bc32:	d100      	bne.n	4bc36 <sys_slist_find_and_remove+0x1c>
	list->tail = node;
   4bc34:	6043      	str	r3, [r0, #4]
	parent->next = child;
   4bc36:	2300      	movs	r3, #0
   4bc38:	600b      	str	r3, [r1, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   4bc3a:	2001      	movs	r0, #1
Z_GENLIST_REMOVE(slist, snode)
   4bc3c:	4770      	bx	lr
	parent->next = child;
   4bc3e:	6013      	str	r3, [r2, #0]
Z_GENLIST_REMOVE(slist, snode)
   4bc40:	6843      	ldr	r3, [r0, #4]
   4bc42:	4299      	cmp	r1, r3
	list->tail = node;
   4bc44:	bf08      	it	eq
   4bc46:	6042      	streq	r2, [r0, #4]
}
   4bc48:	e7f5      	b.n	4bc36 <sys_slist_find_and_remove+0x1c>
	return node->next;
   4bc4a:	461a      	mov	r2, r3
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   4bc4c:	681b      	ldr	r3, [r3, #0]
   4bc4e:	e7e6      	b.n	4bc1e <sys_slist_find_and_remove+0x4>

0004bc50 <atomic_and>:
{
   4bc50:	b510      	push	{r4, lr}
   4bc52:	4603      	mov	r3, r0
}
   4bc54:	f3bf 8f5b 	dmb	ish
   4bc58:	e853 0f00 	ldrex	r0, [r3]
   4bc5c:	ea00 0201 	and.w	r2, r0, r1
   4bc60:	e843 2400 	strex	r4, r2, [r3]
   4bc64:	2c00      	cmp	r4, #0
   4bc66:	d1f7      	bne.n	4bc58 <atomic_and+0x8>
   4bc68:	f3bf 8f5b 	dmb	ish
   4bc6c:	bd10      	pop	{r4, pc}

0004bc6e <atomic_get>:
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   4bc6e:	f3bf 8f5b 	dmb	ish
   4bc72:	6800      	ldr	r0, [r0, #0]
   4bc74:	f3bf 8f5b 	dmb	ish
}
   4bc78:	4770      	bx	lr

0004bc7a <atomic_or>:
{
   4bc7a:	b510      	push	{r4, lr}
   4bc7c:	4603      	mov	r3, r0
}
   4bc7e:	f3bf 8f5b 	dmb	ish
   4bc82:	e853 0f00 	ldrex	r0, [r3]
   4bc86:	ea40 0201 	orr.w	r2, r0, r1
   4bc8a:	e843 2400 	strex	r4, r2, [r3]
   4bc8e:	2c00      	cmp	r4, #0
   4bc90:	d1f7      	bne.n	4bc82 <atomic_or+0x8>
   4bc92:	f3bf 8f5b 	dmb	ish
   4bc96:	bd10      	pop	{r4, pc}

0004bc98 <tx_complete_work>:
	tx_notify(conn);
   4bc98:	3828      	subs	r0, #40	; 0x28
   4bc9a:	f7e3 bed3 	b.w	2fa44 <tx_notify>

0004bc9e <bt_conn_reset_rx_state>:
{
   4bc9e:	b510      	push	{r4, lr}
   4bca0:	4604      	mov	r4, r0
	if (!conn->rx) {
   4bca2:	6900      	ldr	r0, [r0, #16]
   4bca4:	b118      	cbz	r0, 4bcae <bt_conn_reset_rx_state+0x10>
	net_buf_unref(conn->rx);
   4bca6:	f7f6 fdcf 	bl	42848 <net_buf_unref>
	conn->rx = NULL;
   4bcaa:	2300      	movs	r3, #0
   4bcac:	6123      	str	r3, [r4, #16]
}
   4bcae:	bd10      	pop	{r4, pc}

0004bcb0 <conn_cleanup>:
{
   4bcb0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4bcb4:	4604      	mov	r4, r0
		tx_data(buf)->tx = NULL;
   4bcb6:	2700      	movs	r7, #0
	while ((buf = net_buf_get(&conn->tx_queue, K_NO_WAIT))) {
   4bcb8:	f104 0638 	add.w	r6, r4, #56	; 0x38
   4bcbc:	2300      	movs	r3, #0
   4bcbe:	2200      	movs	r2, #0
   4bcc0:	4630      	mov	r0, r6
   4bcc2:	f003 f814 	bl	4ecee <net_buf_get>
   4bcc6:	4603      	mov	r3, r0
   4bcc8:	b950      	cbnz	r0, 4bce0 <conn_cleanup+0x30>
	bt_conn_reset_rx_state(conn);
   4bcca:	4620      	mov	r0, r4
   4bccc:	f7ff ffe7 	bl	4bc9e <bt_conn_reset_rx_state>
	k_work_reschedule(&conn->deferred_work, K_NO_WAIT);
   4bcd0:	f104 0058 	add.w	r0, r4, #88	; 0x58
   4bcd4:	2200      	movs	r2, #0
}
   4bcd6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	k_work_reschedule(&conn->deferred_work, K_NO_WAIT);
   4bcda:	2300      	movs	r3, #0
   4bcdc:	f7fb bc86 	b.w	475ec <k_work_reschedule>
		struct bt_conn_tx *tx = tx_data(buf)->tx;
   4bce0:	695d      	ldr	r5, [r3, #20]
		tx_data(buf)->tx = NULL;
   4bce2:	615f      	str	r7, [r3, #20]
		net_buf_unref(buf);
   4bce4:	f7f6 fdb0 	bl	42848 <net_buf_unref>
		if (tx) {
   4bce8:	2d00      	cmp	r5, #0
   4bcea:	d0e7      	beq.n	4bcbc <conn_cleanup+0xc>
			conn_tx_destroy(conn, tx);
   4bcec:	4629      	mov	r1, r5
   4bcee:	4620      	mov	r0, r4
   4bcf0:	f7e3 fed8 	bl	2faa4 <conn_tx_destroy>
   4bcf4:	e7e0      	b.n	4bcb8 <conn_cleanup+0x8>

0004bcf6 <bt_conn_recv>:
{
   4bcf6:	b570      	push	{r4, r5, r6, lr}
   4bcf8:	4616      	mov	r6, r2
   4bcfa:	4604      	mov	r4, r0
   4bcfc:	460d      	mov	r5, r1
	tx_notify(conn);
   4bcfe:	f7e3 fea1 	bl	2fa44 <tx_notify>
	switch (flags) {
   4bd02:	2e01      	cmp	r6, #1
   4bd04:	d017      	beq.n	4bd36 <bt_conn_recv+0x40>
   4bd06:	2e02      	cmp	r6, #2
   4bd08:	d117      	bne.n	4bd3a <bt_conn_recv+0x44>
		if (conn->rx) {
   4bd0a:	6923      	ldr	r3, [r4, #16]
   4bd0c:	b113      	cbz	r3, 4bd14 <bt_conn_recv+0x1e>
			bt_conn_reset_rx_state(conn);
   4bd0e:	4620      	mov	r0, r4
   4bd10:	f7ff ffc5 	bl	4bc9e <bt_conn_reset_rx_state>
		conn->rx = buf;
   4bd14:	6125      	str	r5, [r4, #16]
	if (conn->rx->len < sizeof(uint16_t)) {
   4bd16:	6921      	ldr	r1, [r4, #16]
   4bd18:	898a      	ldrh	r2, [r1, #12]
   4bd1a:	2a01      	cmp	r2, #1
   4bd1c:	d937      	bls.n	4bd8e <bt_conn_recv+0x98>
	acl_total_len = sys_get_le16(conn->rx->data) + sizeof(struct bt_l2cap_hdr);
   4bd1e:	688b      	ldr	r3, [r1, #8]
   4bd20:	881b      	ldrh	r3, [r3, #0]
   4bd22:	3304      	adds	r3, #4
   4bd24:	b29b      	uxth	r3, r3
	if (conn->rx->len < acl_total_len) {
   4bd26:	429a      	cmp	r2, r3
   4bd28:	d331      	bcc.n	4bd8e <bt_conn_recv+0x98>
	if (conn->rx->len > acl_total_len) {
   4bd2a:	d928      	bls.n	4bd7e <bt_conn_recv+0x88>
		bt_conn_reset_rx_state(conn);
   4bd2c:	4620      	mov	r0, r4
}
   4bd2e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		bt_conn_reset_rx_state(conn);
   4bd32:	f7ff bfb4 	b.w	4bc9e <bt_conn_reset_rx_state>
		if (!conn->rx) {
   4bd36:	6920      	ldr	r0, [r4, #16]
   4bd38:	b918      	cbnz	r0, 4bd42 <bt_conn_recv+0x4c>
		bt_conn_reset_rx_state(conn);
   4bd3a:	4620      	mov	r0, r4
   4bd3c:	f7ff ffaf 	bl	4bc9e <bt_conn_reset_rx_state>
		net_buf_unref(buf);
   4bd40:	e001      	b.n	4bd46 <bt_conn_recv+0x50>
		if (!buf->len) {
   4bd42:	89ae      	ldrh	r6, [r5, #12]
   4bd44:	b926      	cbnz	r6, 4bd50 <bt_conn_recv+0x5a>
			net_buf_unref(buf);
   4bd46:	4628      	mov	r0, r5
}
   4bd48:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			net_buf_unref(buf);
   4bd4c:	f7f6 bd7c 	b.w	42848 <net_buf_unref>
	return net_buf_simple_tailroom(&buf->b);
   4bd50:	3008      	adds	r0, #8
   4bd52:	f003 f87c 	bl	4ee4e <net_buf_simple_tailroom>
		if (buf->len > net_buf_tailroom(conn->rx)) {
   4bd56:	4286      	cmp	r6, r0
   4bd58:	d907      	bls.n	4bd6a <bt_conn_recv+0x74>
			bt_l2cap_recv(conn, conn->rx, false);
   4bd5a:	6921      	ldr	r1, [r4, #16]
   4bd5c:	2200      	movs	r2, #0
   4bd5e:	4620      	mov	r0, r4
   4bd60:	f000 fa6f 	bl	4c242 <bt_l2cap_recv>
			conn->rx = NULL;
   4bd64:	2300      	movs	r3, #0
   4bd66:	6123      	str	r3, [r4, #16]
   4bd68:	e7ed      	b.n	4bd46 <bt_conn_recv+0x50>
	return net_buf_simple_add_mem(&buf->b, mem, len);
   4bd6a:	6920      	ldr	r0, [r4, #16]
   4bd6c:	89aa      	ldrh	r2, [r5, #12]
   4bd6e:	68a9      	ldr	r1, [r5, #8]
   4bd70:	3008      	adds	r0, #8
   4bd72:	f003 f825 	bl	4edc0 <net_buf_simple_add_mem>
		net_buf_unref(buf);
   4bd76:	4628      	mov	r0, r5
   4bd78:	f7f6 fd66 	bl	42848 <net_buf_unref>
		break;
   4bd7c:	e7cb      	b.n	4bd16 <bt_conn_recv+0x20>
	conn->rx = NULL;
   4bd7e:	2300      	movs	r3, #0
   4bd80:	6123      	str	r3, [r4, #16]
	bt_l2cap_recv(conn, buf, true);
   4bd82:	4620      	mov	r0, r4
   4bd84:	2201      	movs	r2, #1
}
   4bd86:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	bt_l2cap_recv(conn, buf, true);
   4bd8a:	f000 ba5a 	b.w	4c242 <bt_l2cap_recv>
}
   4bd8e:	bd70      	pop	{r4, r5, r6, pc}

0004bd90 <bt_conn_ref>:
{
   4bd90:	b510      	push	{r4, lr}
   4bd92:	4603      	mov	r3, r0
		old = atomic_get(&conn->ref);
   4bd94:	f100 02bc 	add.w	r2, r0, #188	; 0xbc
   4bd98:	4610      	mov	r0, r2
   4bd9a:	f7ff ff68 	bl	4bc6e <atomic_get>
		if (!old) {
   4bd9e:	b180      	cbz	r0, 4bdc2 <bt_conn_ref+0x32>
	return __atomic_compare_exchange_n(target, &old_value, new_value,
   4bda0:	f3bf 8f5b 	dmb	ish
	} while (!atomic_cas(&conn->ref, old, old + 1));
   4bda4:	1c41      	adds	r1, r0, #1
   4bda6:	e852 4f00 	ldrex	r4, [r2]
   4bdaa:	4284      	cmp	r4, r0
   4bdac:	d104      	bne.n	4bdb8 <bt_conn_ref+0x28>
   4bdae:	e842 1c00 	strex	ip, r1, [r2]
   4bdb2:	f1bc 0f00 	cmp.w	ip, #0
   4bdb6:	d1f6      	bne.n	4bda6 <bt_conn_ref+0x16>
   4bdb8:	f3bf 8f5b 	dmb	ish
   4bdbc:	d1ec      	bne.n	4bd98 <bt_conn_ref+0x8>
}
   4bdbe:	4618      	mov	r0, r3
   4bdc0:	bd10      	pop	{r4, pc}
			return NULL;
   4bdc2:	4603      	mov	r3, r0
   4bdc4:	e7fb      	b.n	4bdbe <bt_conn_ref+0x2e>

0004bdc6 <bt_conn_unref>:
{
   4bdc6:	b508      	push	{r3, lr}
   4bdc8:	4603      	mov	r3, r0
	old = atomic_dec(&conn->ref);
   4bdca:	30bc      	adds	r0, #188	; 0xbc
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
   4bdcc:	f3bf 8f5b 	dmb	ish
   4bdd0:	e850 2f00 	ldrex	r2, [r0]
   4bdd4:	3a01      	subs	r2, #1
   4bdd6:	e840 2100 	strex	r1, r2, [r0]
   4bdda:	2900      	cmp	r1, #0
   4bddc:	d1f8      	bne.n	4bdd0 <bt_conn_unref+0xa>
   4bdde:	f3bf 8f5b 	dmb	ish
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn->type == BT_CONN_TYPE_LE &&
   4bde2:	789b      	ldrb	r3, [r3, #2]
   4bde4:	2b01      	cmp	r3, #1
   4bde6:	d106      	bne.n	4bdf6 <bt_conn_unref+0x30>
	    atomic_get(&conn->ref) == 0) {
   4bde8:	f7ff ff41 	bl	4bc6e <atomic_get>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn->type == BT_CONN_TYPE_LE &&
   4bdec:	b918      	cbnz	r0, 4bdf6 <bt_conn_unref+0x30>
}
   4bdee:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		bt_le_adv_resume();
   4bdf2:	f7e3 ba55 	b.w	2f2a0 <bt_le_adv_resume>
}
   4bdf6:	bd08      	pop	{r3, pc}

0004bdf8 <conn_lookup_handle>:
{
   4bdf8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   4bdfc:	4607      	mov	r7, r0
   4bdfe:	460e      	mov	r6, r1
   4be00:	4690      	mov	r8, r2
	for (i = 0; i < size; i++) {
   4be02:	2400      	movs	r4, #0
		struct bt_conn *conn = bt_conn_ref(&conns[i]);
   4be04:	f04f 09c0 	mov.w	r9, #192	; 0xc0
	for (i = 0; i < size; i++) {
   4be08:	42b4      	cmp	r4, r6
   4be0a:	d103      	bne.n	4be14 <conn_lookup_handle+0x1c>
	return NULL;
   4be0c:	2300      	movs	r3, #0
}
   4be0e:	4618      	mov	r0, r3
   4be10:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		struct bt_conn *conn = bt_conn_ref(&conns[i]);
   4be14:	fb09 7004 	mla	r0, r9, r4, r7
   4be18:	f7ff ffba 	bl	4bd90 <bt_conn_ref>
   4be1c:	4603      	mov	r3, r0
		if (!conn) {
   4be1e:	b158      	cbz	r0, 4be38 <conn_lookup_handle+0x40>
		if (!bt_conn_is_handle_valid(conn)) {
   4be20:	7b45      	ldrb	r5, [r0, #13]
/* Look up an existing connection */
struct bt_conn *bt_conn_lookup_handle(uint16_t handle);

static inline bool bt_conn_is_handle_valid(struct bt_conn *conn)
{
	switch (conn->state) {
   4be22:	2d01      	cmp	r5, #1
   4be24:	d002      	beq.n	4be2c <conn_lookup_handle+0x34>
   4be26:	3d07      	subs	r5, #7
   4be28:	2d01      	cmp	r5, #1
   4be2a:	d803      	bhi.n	4be34 <conn_lookup_handle+0x3c>
		if (conn->handle != handle) {
   4be2c:	881a      	ldrh	r2, [r3, #0]
   4be2e:	4542      	cmp	r2, r8
   4be30:	d0ed      	beq.n	4be0e <conn_lookup_handle+0x16>
			bt_conn_unref(conn);
   4be32:	4618      	mov	r0, r3
   4be34:	f7ff ffc7 	bl	4bdc6 <bt_conn_unref>
	for (i = 0; i < size; i++) {
   4be38:	3401      	adds	r4, #1
   4be3a:	e7e5      	b.n	4be08 <conn_lookup_handle+0x10>

0004be3c <bt_conn_connected>:
{
   4be3c:	b510      	push	{r4, lr}
   4be3e:	4604      	mov	r4, r0
	bt_l2cap_connected(conn);
   4be40:	f7e4 fcf0 	bl	30824 <bt_l2cap_connected>
	notify_connected(conn);
   4be44:	4620      	mov	r0, r4
}
   4be46:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	notify_connected(conn);
   4be4a:	f7e3 bddd 	b.w	2fa08 <notify_connected>

0004be4e <bt_conn_le_start_encryption>:
{
   4be4e:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   4be52:	4682      	mov	sl, r0
   4be54:	4689      	mov	r9, r1
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_START_ENCRYPTION, sizeof(*cp));
   4be56:	f242 0019 	movw	r0, #8217	; 0x2019
   4be5a:	211c      	movs	r1, #28
{
   4be5c:	9e08      	ldr	r6, [sp, #32]
   4be5e:	4690      	mov	r8, r2
   4be60:	461f      	mov	r7, r3
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_START_ENCRYPTION, sizeof(*cp));
   4be62:	f7e2 f803 	bl	2de6c <bt_hci_cmd_create>
	if (!buf) {
   4be66:	4605      	mov	r5, r0
   4be68:	b340      	cbz	r0, 4bebc <bt_conn_le_start_encryption+0x6e>
	return net_buf_simple_add(&buf->b, len);
   4be6a:	211c      	movs	r1, #28
   4be6c:	3008      	adds	r0, #8
   4be6e:	f002 ffa1 	bl	4edb4 <net_buf_simple_add>
	cp->handle = sys_cpu_to_le16(conn->handle);
   4be72:	f8ba 3000 	ldrh.w	r3, [sl]
   4be76:	4604      	mov	r4, r0
	memcpy(&cp->rand, rand, sizeof(cp->rand));
   4be78:	2208      	movs	r2, #8
	cp->handle = sys_cpu_to_le16(conn->handle);
   4be7a:	f820 3b02 	strh.w	r3, [r0], #2
	memcpy(&cp->rand, rand, sizeof(cp->rand));
   4be7e:	4649      	mov	r1, r9
   4be80:	f7fe fffb 	bl	4ae7a <memcpy>
	memcpy(&cp->ediv, ediv, sizeof(cp->ediv));
   4be84:	2202      	movs	r2, #2
   4be86:	4641      	mov	r1, r8
   4be88:	f104 000a 	add.w	r0, r4, #10
	memcpy(cp->ltk, ltk, len);
   4be8c:	340c      	adds	r4, #12
	memcpy(&cp->ediv, ediv, sizeof(cp->ediv));
   4be8e:	f7fe fff4 	bl	4ae7a <memcpy>
	memcpy(cp->ltk, ltk, len);
   4be92:	4632      	mov	r2, r6
   4be94:	4639      	mov	r1, r7
   4be96:	4620      	mov	r0, r4
   4be98:	f7fe ffef 	bl	4ae7a <memcpy>
	if (len < sizeof(cp->ltk)) {
   4be9c:	2e0f      	cmp	r6, #15
   4be9e:	d805      	bhi.n	4beac <bt_conn_le_start_encryption+0x5e>
		(void)memset(cp->ltk + len, 0, sizeof(cp->ltk) - len);
   4bea0:	f1c6 0210 	rsb	r2, r6, #16
   4bea4:	2100      	movs	r1, #0
   4bea6:	19a0      	adds	r0, r4, r6
   4bea8:	f7fe fff2 	bl	4ae90 <memset>
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_START_ENCRYPTION, buf, NULL);
   4beac:	4629      	mov	r1, r5
   4beae:	2200      	movs	r2, #0
}
   4beb0:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_START_ENCRYPTION, buf, NULL);
   4beb4:	f242 0019 	movw	r0, #8217	; 0x2019
   4beb8:	f7e2 b834 	b.w	2df24 <bt_hci_cmd_send_sync>
}
   4bebc:	f06f 0068 	mvn.w	r0, #104	; 0x68
   4bec0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0004bec4 <bt_conn_enc_key_size>:
{
   4bec4:	4603      	mov	r3, r0
	if (!conn->encrypt) {
   4bec6:	7ac0      	ldrb	r0, [r0, #11]
   4bec8:	b118      	cbz	r0, 4bed2 <bt_conn_enc_key_size+0xe>
   4beca:	f8d3 00b4 	ldr.w	r0, [r3, #180]	; 0xb4
		return conn->le.keys ? conn->le.keys->enc_size : 0;
   4bece:	b100      	cbz	r0, 4bed2 <bt_conn_enc_key_size+0xe>
   4bed0:	7b00      	ldrb	r0, [r0, #12]
}
   4bed2:	4770      	bx	lr

0004bed4 <bt_conn_set_security>:
{
   4bed4:	b538      	push	{r3, r4, r5, lr}
	if (conn->state != BT_CONN_CONNECTED) {
   4bed6:	7b43      	ldrb	r3, [r0, #13]
   4bed8:	2b07      	cmp	r3, #7
{
   4beda:	4604      	mov	r4, r0
   4bedc:	460d      	mov	r5, r1
	if (conn->state != BT_CONN_CONNECTED) {
   4bede:	d11e      	bne.n	4bf1e <bt_conn_set_security+0x4a>
	if (conn->sec_level >= sec || conn->required_sec_level >= sec) {
   4bee0:	7a43      	ldrb	r3, [r0, #9]
   4bee2:	428b      	cmp	r3, r1
   4bee4:	d211      	bcs.n	4bf0a <bt_conn_set_security+0x36>
   4bee6:	7a83      	ldrb	r3, [r0, #10]
   4bee8:	428b      	cmp	r3, r1
   4beea:	d20e      	bcs.n	4bf0a <bt_conn_set_security+0x36>
	if (val) {
   4beec:	060b      	lsls	r3, r1, #24
	atomic_set_bit_to(conn->flags, BT_CONN_FORCE_PAIR,
   4beee:	f100 0004 	add.w	r0, r0, #4
   4bef2:	d50c      	bpl.n	4bf0e <bt_conn_set_security+0x3a>
		(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
   4bef4:	f44f 6180 	mov.w	r1, #1024	; 0x400
   4bef8:	f7ff febf 	bl	4bc7a <atomic_or>
	conn->required_sec_level = sec & ~BT_SECURITY_FORCE_PAIR;
   4befc:	f005 057f 	and.w	r5, r5, #127	; 0x7f
   4bf00:	72a5      	strb	r5, [r4, #10]
		return bt_smp_start_security(conn);
   4bf02:	4620      	mov	r0, r4
   4bf04:	f002 fc02 	bl	4e70c <bt_smp_start_security>
	if (err) {
   4bf08:	b930      	cbnz	r0, 4bf18 <bt_conn_set_security+0x44>
		return -ENOTCONN;
   4bf0a:	2000      	movs	r0, #0
}
   4bf0c:	bd38      	pop	{r3, r4, r5, pc}
		(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   4bf0e:	f46f 6180 	mvn.w	r1, #1024	; 0x400
   4bf12:	f7ff fe9d 	bl	4bc50 <atomic_and>
   4bf16:	e7f1      	b.n	4befc <bt_conn_set_security+0x28>
		conn->required_sec_level = conn->sec_level;
   4bf18:	7a63      	ldrb	r3, [r4, #9]
   4bf1a:	72a3      	strb	r3, [r4, #10]
   4bf1c:	e7f6      	b.n	4bf0c <bt_conn_set_security+0x38>
		return -ENOTCONN;
   4bf1e:	f06f 007f 	mvn.w	r0, #127	; 0x7f
   4bf22:	e7f3      	b.n	4bf0c <bt_conn_set_security+0x38>

0004bf24 <bt_conn_get_security>:
}
   4bf24:	7a40      	ldrb	r0, [r0, #9]
   4bf26:	4770      	bx	lr

0004bf28 <bt_conn_is_peer_addr_le>:
{
   4bf28:	b538      	push	{r3, r4, r5, lr}
	if (id != conn->id) {
   4bf2a:	7a03      	ldrb	r3, [r0, #8]
   4bf2c:	428b      	cmp	r3, r1
{
   4bf2e:	4604      	mov	r4, r0
   4bf30:	4615      	mov	r5, r2
	if (id != conn->id) {
   4bf32:	d115      	bne.n	4bf60 <bt_conn_is_peer_addr_le+0x38>
	return memcmp(a, b, sizeof(*a));
   4bf34:	f100 0188 	add.w	r1, r0, #136	; 0x88
   4bf38:	2207      	movs	r2, #7
   4bf3a:	4628      	mov	r0, r5
   4bf3c:	f7fe ff8d 	bl	4ae5a <memcmp>
	if (!bt_addr_le_cmp(peer, &conn->le.dst)) {
   4bf40:	b180      	cbz	r0, 4bf64 <bt_conn_is_peer_addr_le+0x3c>
	if (conn->role == BT_HCI_ROLE_CENTRAL) {
   4bf42:	78e3      	ldrb	r3, [r4, #3]
   4bf44:	2207      	movs	r2, #7
   4bf46:	b943      	cbnz	r3, 4bf5a <bt_conn_is_peer_addr_le+0x32>
   4bf48:	f104 0196 	add.w	r1, r4, #150	; 0x96
   4bf4c:	4628      	mov	r0, r5
   4bf4e:	f7fe ff84 	bl	4ae5a <memcmp>
	return bt_addr_le_cmp(peer, &conn->le.init_addr) == 0;
   4bf52:	fab0 f080 	clz	r0, r0
   4bf56:	0940      	lsrs	r0, r0, #5
}
   4bf58:	bd38      	pop	{r3, r4, r5, pc}
   4bf5a:	f104 018f 	add.w	r1, r4, #143	; 0x8f
   4bf5e:	e7f5      	b.n	4bf4c <bt_conn_is_peer_addr_le+0x24>
		return false;
   4bf60:	2000      	movs	r0, #0
   4bf62:	e7f9      	b.n	4bf58 <bt_conn_is_peer_addr_le+0x30>
		return true;
   4bf64:	2001      	movs	r0, #1
   4bf66:	e7f7      	b.n	4bf58 <bt_conn_is_peer_addr_le+0x30>

0004bf68 <bt_conn_exists_le>:
{
   4bf68:	b508      	push	{r3, lr}
	struct bt_conn *conn = bt_conn_lookup_addr_le(id, peer);
   4bf6a:	f7e4 f8ff 	bl	3016c <bt_conn_lookup_addr_le>
	if (conn) {
   4bf6e:	b110      	cbz	r0, 4bf76 <bt_conn_exists_le+0xe>
		bt_conn_unref(conn);
   4bf70:	f7ff ff29 	bl	4bdc6 <bt_conn_unref>
		return true;
   4bf74:	2001      	movs	r0, #1
}
   4bf76:	bd08      	pop	{r3, pc}

0004bf78 <bt_conn_get_dst>:
}
   4bf78:	3088      	adds	r0, #136	; 0x88
   4bf7a:	4770      	bx	lr

0004bf7c <bt_conn_disconnect>:
{
   4bf7c:	b538      	push	{r3, r4, r5, lr}
	if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
   4bf7e:	7883      	ldrb	r3, [r0, #2]
   4bf80:	2b01      	cmp	r3, #1
{
   4bf82:	4604      	mov	r4, r0
   4bf84:	460d      	mov	r5, r1
	if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
   4bf86:	d103      	bne.n	4bf90 <bt_conn_disconnect+0x14>
		bt_le_set_auto_conn(&conn->le.dst, NULL);
   4bf88:	2100      	movs	r1, #0
   4bf8a:	3088      	adds	r0, #136	; 0x88
   4bf8c:	f7e4 fa32 	bl	303f4 <bt_le_set_auto_conn>
	switch (conn->state) {
   4bf90:	7b63      	ldrb	r3, [r4, #13]
   4bf92:	3b02      	subs	r3, #2
   4bf94:	2b06      	cmp	r3, #6
   4bf96:	d825      	bhi.n	4bfe4 <bt_conn_disconnect+0x68>
   4bf98:	e8df f003 	tbb	[pc, r3]
   4bf9c:	24242404 	.word	0x24242404
   4bfa0:	160e      	.short	0x160e
   4bfa2:	0c          	.byte	0x0c
   4bfa3:	00          	.byte	0x00
		bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
   4bfa4:	4620      	mov	r0, r4
		conn->err = reason;
   4bfa6:	7325      	strb	r5, [r4, #12]
		bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
   4bfa8:	2100      	movs	r1, #0
   4bfaa:	f7e3 fed3 	bl	2fd54 <bt_conn_set_state>
			bt_le_scan_update(false);
   4bfae:	2000      	movs	r0, #0
   4bfb0:	f7e3 fa46 	bl	2f440 <bt_le_scan_update>
{
   4bfb4:	2000      	movs	r0, #0
}
   4bfb6:	bd38      	pop	{r3, r4, r5, pc}
			k_work_cancel_delayable(&conn->deferred_work);
   4bfb8:	f104 0058 	add.w	r0, r4, #88	; 0x58
   4bfbc:	f004 f830 	bl	50020 <k_work_cancel_delayable>
}
   4bfc0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			return bt_le_create_conn_cancel();
   4bfc4:	f7e2 b8a4 	b.w	2e110 <bt_le_create_conn_cancel>
	err = bt_hci_disconnect(conn->handle, reason);
   4bfc8:	8820      	ldrh	r0, [r4, #0]
   4bfca:	4629      	mov	r1, r5
   4bfcc:	f7ff faad 	bl	4b52a <bt_hci_disconnect>
	if (err) {
   4bfd0:	2800      	cmp	r0, #0
   4bfd2:	d1f0      	bne.n	4bfb6 <bt_conn_disconnect+0x3a>
	if (conn->state == BT_CONN_CONNECTED) {
   4bfd4:	7b63      	ldrb	r3, [r4, #13]
   4bfd6:	2b07      	cmp	r3, #7
   4bfd8:	d1ec      	bne.n	4bfb4 <bt_conn_disconnect+0x38>
		bt_conn_set_state(conn, BT_CONN_DISCONNECTING);
   4bfda:	2108      	movs	r1, #8
   4bfdc:	4620      	mov	r0, r4
   4bfde:	f7e3 feb9 	bl	2fd54 <bt_conn_set_state>
   4bfe2:	e7e7      	b.n	4bfb4 <bt_conn_disconnect+0x38>
		return -ENOTCONN;
   4bfe4:	f06f 007f 	mvn.w	r0, #127	; 0x7f
   4bfe8:	e7e5      	b.n	4bfb6 <bt_conn_disconnect+0x3a>

0004bfea <bt_conn_le_conn_update>:
{
   4bfea:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   4bfec:	4607      	mov	r7, r0
   4bfee:	460d      	mov	r5, r1
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_CONN_UPDATE,
   4bff0:	f242 0013 	movw	r0, #8211	; 0x2013
   4bff4:	210e      	movs	r1, #14
   4bff6:	f7e1 ff39 	bl	2de6c <bt_hci_cmd_create>
	if (!buf) {
   4bffa:	4606      	mov	r6, r0
   4bffc:	b1d0      	cbz	r0, 4c034 <bt_conn_le_conn_update+0x4a>
   4bffe:	210e      	movs	r1, #14
   4c000:	3008      	adds	r0, #8
   4c002:	f002 fed7 	bl	4edb4 <net_buf_simple_add>
	(void)memset(conn_update, 0, sizeof(*conn_update));
   4c006:	220e      	movs	r2, #14
   4c008:	4604      	mov	r4, r0
   4c00a:	2100      	movs	r1, #0
   4c00c:	f7fe ff40 	bl	4ae90 <memset>
	conn_update->handle = sys_cpu_to_le16(conn->handle);
   4c010:	883b      	ldrh	r3, [r7, #0]
   4c012:	8023      	strh	r3, [r4, #0]
	conn_update->conn_interval_min = sys_cpu_to_le16(param->interval_min);
   4c014:	882b      	ldrh	r3, [r5, #0]
   4c016:	8063      	strh	r3, [r4, #2]
	conn_update->conn_interval_max = sys_cpu_to_le16(param->interval_max);
   4c018:	886b      	ldrh	r3, [r5, #2]
   4c01a:	80a3      	strh	r3, [r4, #4]
	conn_update->conn_latency = sys_cpu_to_le16(param->latency);
   4c01c:	88ab      	ldrh	r3, [r5, #4]
   4c01e:	80e3      	strh	r3, [r4, #6]
	conn_update->supervision_timeout = sys_cpu_to_le16(param->timeout);
   4c020:	88eb      	ldrh	r3, [r5, #6]
   4c022:	8123      	strh	r3, [r4, #8]
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_CONN_UPDATE, buf, NULL);
   4c024:	4631      	mov	r1, r6
   4c026:	2200      	movs	r2, #0
}
   4c028:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_CONN_UPDATE, buf, NULL);
   4c02c:	f242 0013 	movw	r0, #8211	; 0x2013
   4c030:	f7e1 bf78 	b.w	2df24 <bt_hci_cmd_send_sync>
}
   4c034:	f06f 0068 	mvn.w	r0, #104	; 0x68
   4c038:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0004c03a <l2cap_connected>:
}
   4c03a:	4770      	bx	lr

0004c03c <l2cap_create_le_sig_pdu.constprop.0>:
static struct net_buf *l2cap_create_le_sig_pdu(struct net_buf *buf,
   4c03c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   4c03e:	4607      	mov	r7, r0
   4c040:	460e      	mov	r6, r1
   4c042:	4615      	mov	r5, r2
	return bt_conn_create_pdu_timeout(pool,
   4c044:	2300      	movs	r3, #0
   4c046:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   4c04a:	2104      	movs	r1, #4
   4c04c:	2000      	movs	r0, #0
   4c04e:	f7e3 ff65 	bl	2ff1c <bt_conn_create_pdu_timeout>
	if (!buf) {
   4c052:	4604      	mov	r4, r0
   4c054:	b130      	cbz	r0, 4c064 <l2cap_create_le_sig_pdu.constprop.0+0x28>
   4c056:	2104      	movs	r1, #4
   4c058:	3008      	adds	r0, #8
   4c05a:	f002 feab 	bl	4edb4 <net_buf_simple_add>
	hdr->code = code;
   4c05e:	7007      	strb	r7, [r0, #0]
	hdr->ident = ident;
   4c060:	7046      	strb	r6, [r0, #1]
	hdr->len = sys_cpu_to_le16(len);
   4c062:	8045      	strh	r5, [r0, #2]
}
   4c064:	4620      	mov	r0, r4
   4c066:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0004c068 <l2cap_disconnected>:
static void l2cap_disconnected(struct bt_l2cap_chan *chan)
   4c068:	4770      	bx	lr

0004c06a <bt_l2cap_chan_del>:
{
   4c06a:	b570      	push	{r4, r5, r6, lr}
	if (!chan->conn) {
   4c06c:	e9d0 3500 	ldrd	r3, r5, [r0]
{
   4c070:	4604      	mov	r4, r0
	if (!chan->conn) {
   4c072:	b123      	cbz	r3, 4c07e <bt_l2cap_chan_del+0x14>
	if (ops->disconnected) {
   4c074:	686b      	ldr	r3, [r5, #4]
   4c076:	b103      	cbz	r3, 4c07a <bt_l2cap_chan_del+0x10>
		ops->disconnected(chan);
   4c078:	4798      	blx	r3
	chan->conn = NULL;
   4c07a:	2300      	movs	r3, #0
   4c07c:	6023      	str	r3, [r4, #0]
	if (chan->destroy) {
   4c07e:	68e3      	ldr	r3, [r4, #12]
   4c080:	b10b      	cbz	r3, 4c086 <bt_l2cap_chan_del+0x1c>
		chan->destroy(chan);
   4c082:	4620      	mov	r0, r4
   4c084:	4798      	blx	r3
	if (ops->released) {
   4c086:	6a2b      	ldr	r3, [r5, #32]
   4c088:	b11b      	cbz	r3, 4c092 <bt_l2cap_chan_del+0x28>
		ops->released(chan);
   4c08a:	4620      	mov	r0, r4
}
   4c08c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		ops->released(chan);
   4c090:	4718      	bx	r3
}
   4c092:	bd70      	pop	{r4, r5, r6, pc}

0004c094 <bt_l2cap_disconnected>:
{
   4c094:	b538      	push	{r3, r4, r5, lr}
	return list->head;
   4c096:	6d00      	ldr	r0, [r0, #80]	; 0x50
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn->channels, chan, next, node) {
   4c098:	b130      	cbz	r0, 4c0a8 <bt_l2cap_disconnected+0x14>
	return node->next;
   4c09a:	f850 4908 	ldr.w	r4, [r0], #-8
   4c09e:	b104      	cbz	r4, 4c0a2 <bt_l2cap_disconnected+0xe>
   4c0a0:	3c08      	subs	r4, #8
		bt_l2cap_chan_del(chan);
   4c0a2:	f7ff ffe2 	bl	4c06a <bt_l2cap_chan_del>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn->channels, chan, next, node) {
   4c0a6:	b904      	cbnz	r4, 4c0aa <bt_l2cap_disconnected+0x16>
}
   4c0a8:	bd38      	pop	{r3, r4, r5, pc}
   4c0aa:	68a5      	ldr	r5, [r4, #8]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn->channels, chan, next, node) {
   4c0ac:	b12d      	cbz	r5, 4c0ba <bt_l2cap_disconnected+0x26>
		bt_l2cap_chan_del(chan);
   4c0ae:	4620      	mov	r0, r4
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn->channels, chan, next, node) {
   4c0b0:	3d08      	subs	r5, #8
		bt_l2cap_chan_del(chan);
   4c0b2:	f7ff ffda 	bl	4c06a <bt_l2cap_chan_del>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn->channels, chan, next, node) {
   4c0b6:	462c      	mov	r4, r5
   4c0b8:	e7f7      	b.n	4c0aa <bt_l2cap_disconnected+0x16>
		bt_l2cap_chan_del(chan);
   4c0ba:	4620      	mov	r0, r4
}
   4c0bc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		bt_l2cap_chan_del(chan);
   4c0c0:	f7ff bfd3 	b.w	4c06a <bt_l2cap_chan_del>

0004c0c4 <bt_l2cap_security_changed>:
{
   4c0c4:	b538      	push	{r3, r4, r5, lr}
	return list->head;
   4c0c6:	6d03      	ldr	r3, [r0, #80]	; 0x50
   4c0c8:	460d      	mov	r5, r1
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn->channels, chan, next, node) {
   4c0ca:	b1bb      	cbz	r3, 4c0fc <bt_l2cap_security_changed+0x38>
   4c0cc:	4618      	mov	r0, r3
	return node->next;
   4c0ce:	f850 4908 	ldr.w	r4, [r0], #-8
   4c0d2:	b104      	cbz	r4, 4c0d6 <bt_l2cap_security_changed+0x12>
   4c0d4:	3c08      	subs	r4, #8
		if (chan->ops->encrypt_change) {
   4c0d6:	f853 3c04 	ldr.w	r3, [r3, #-4]
   4c0da:	689b      	ldr	r3, [r3, #8]
   4c0dc:	b10b      	cbz	r3, 4c0e2 <bt_l2cap_security_changed+0x1e>
			chan->ops->encrypt_change(chan, hci_status);
   4c0de:	4629      	mov	r1, r5
   4c0e0:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn->channels, chan, next, node) {
   4c0e2:	b15c      	cbz	r4, 4c0fc <bt_l2cap_security_changed+0x38>
   4c0e4:	4620      	mov	r0, r4
   4c0e6:	68a4      	ldr	r4, [r4, #8]
   4c0e8:	6843      	ldr	r3, [r0, #4]
   4c0ea:	b124      	cbz	r4, 4c0f6 <bt_l2cap_security_changed+0x32>
		if (chan->ops->encrypt_change) {
   4c0ec:	689b      	ldr	r3, [r3, #8]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn->channels, chan, next, node) {
   4c0ee:	3c08      	subs	r4, #8
		if (chan->ops->encrypt_change) {
   4c0f0:	2b00      	cmp	r3, #0
   4c0f2:	d1f4      	bne.n	4c0de <bt_l2cap_security_changed+0x1a>
   4c0f4:	e7f6      	b.n	4c0e4 <bt_l2cap_security_changed+0x20>
   4c0f6:	689b      	ldr	r3, [r3, #8]
   4c0f8:	2b00      	cmp	r3, #0
   4c0fa:	d1f0      	bne.n	4c0de <bt_l2cap_security_changed+0x1a>
}
   4c0fc:	bd38      	pop	{r3, r4, r5, pc}

0004c0fe <bt_l2cap_create_pdu_timeout>:
	return bt_conn_create_pdu_timeout(pool,
   4c0fe:	3104      	adds	r1, #4
   4c100:	f7e3 bf0c 	b.w	2ff1c <bt_conn_create_pdu_timeout>

0004c104 <bt_l2cap_send_cb>:
{
   4c104:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4c108:	4614      	mov	r4, r2
   4c10a:	4605      	mov	r5, r0
   4c10c:	460f      	mov	r7, r1
	return net_buf_simple_push(&buf->b, len);
   4c10e:	f102 0008 	add.w	r0, r2, #8
   4c112:	2104      	movs	r1, #4
   4c114:	461e      	mov	r6, r3
   4c116:	f8dd 8018 	ldr.w	r8, [sp, #24]
   4c11a:	f002 fe6c 	bl	4edf6 <net_buf_simple_push>
	hdr->len = sys_cpu_to_le16(buf->len - sizeof(*hdr));
   4c11e:	89a2      	ldrh	r2, [r4, #12]
	hdr->cid = sys_cpu_to_le16(cid);
   4c120:	8047      	strh	r7, [r0, #2]
	hdr->len = sys_cpu_to_le16(buf->len - sizeof(*hdr));
   4c122:	3a04      	subs	r2, #4
   4c124:	8002      	strh	r2, [r0, #0]
	return bt_conn_send_cb(conn, buf, cb, user_data);
   4c126:	4643      	mov	r3, r8
   4c128:	4632      	mov	r2, r6
   4c12a:	4621      	mov	r1, r4
   4c12c:	4628      	mov	r0, r5
}
   4c12e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	return bt_conn_send_cb(conn, buf, cb, user_data);
   4c132:	f7e3 bd8b 	b.w	2fc4c <bt_conn_send_cb>

0004c136 <l2cap_send_reject.constprop.0>:
static void l2cap_send_reject(struct bt_conn *conn, uint8_t ident,
   4c136:	b537      	push	{r0, r1, r2, r4, r5, lr}
   4c138:	4605      	mov	r5, r0
	buf = l2cap_create_le_sig_pdu(NULL, BT_L2CAP_CMD_REJECT, ident,
   4c13a:	2202      	movs	r2, #2
   4c13c:	2001      	movs	r0, #1
   4c13e:	f7ff ff7d 	bl	4c03c <l2cap_create_le_sig_pdu.constprop.0>
	if (!buf) {
   4c142:	4604      	mov	r4, r0
   4c144:	b198      	cbz	r0, 4c16e <l2cap_send_reject.constprop.0+0x38>
	return net_buf_simple_add(&buf->b, len);
   4c146:	2102      	movs	r1, #2
   4c148:	3008      	adds	r0, #8
   4c14a:	f002 fe33 	bl	4edb4 <net_buf_simple_add>
	rej->reason = sys_cpu_to_le16(reason);
   4c14e:	2300      	movs	r3, #0
   4c150:	7003      	strb	r3, [r0, #0]
   4c152:	7043      	strb	r3, [r0, #1]
   4c154:	4622      	mov	r2, r4
   4c156:	9300      	str	r3, [sp, #0]
   4c158:	2105      	movs	r1, #5
   4c15a:	4628      	mov	r0, r5
   4c15c:	f7ff ffd2 	bl	4c104 <bt_l2cap_send_cb>
	if (bt_l2cap_send(conn, cid, buf)) {
   4c160:	b128      	cbz	r0, 4c16e <l2cap_send_reject.constprop.0+0x38>
		net_buf_unref(buf);
   4c162:	4620      	mov	r0, r4
}
   4c164:	b003      	add	sp, #12
   4c166:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		net_buf_unref(buf);
   4c16a:	f7f6 bb6d 	b.w	42848 <net_buf_unref>
}
   4c16e:	b003      	add	sp, #12
   4c170:	bd30      	pop	{r4, r5, pc}

0004c172 <l2cap_recv>:
{
   4c172:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (buf->len < sizeof(*hdr)) {
   4c174:	898b      	ldrh	r3, [r1, #12]
   4c176:	2b03      	cmp	r3, #3
{
   4c178:	b085      	sub	sp, #20
   4c17a:	4604      	mov	r4, r0
   4c17c:	460d      	mov	r5, r1
	if (buf->len < sizeof(*hdr)) {
   4c17e:	d911      	bls.n	4c1a4 <l2cap_recv+0x32>
	return net_buf_simple_pull_mem(&buf->b, len);
   4c180:	2104      	movs	r1, #4
   4c182:	f105 0008 	add.w	r0, r5, #8
   4c186:	f002 fe46 	bl	4ee16 <net_buf_simple_pull_mem>
	if (buf->len != len) {
   4c18a:	89ab      	ldrh	r3, [r5, #12]
   4c18c:	8846      	ldrh	r6, [r0, #2]
   4c18e:	429e      	cmp	r6, r3
   4c190:	d108      	bne.n	4c1a4 <l2cap_recv+0x32>
	if (!hdr->ident) {
   4c192:	7841      	ldrb	r1, [r0, #1]
   4c194:	b131      	cbz	r1, 4c1a4 <l2cap_recv+0x32>
	switch (hdr->code) {
   4c196:	7803      	ldrb	r3, [r0, #0]
   4c198:	2b12      	cmp	r3, #18
   4c19a:	d006      	beq.n	4c1aa <l2cap_recv+0x38>
   4c19c:	2b13      	cmp	r3, #19
   4c19e:	d001      	beq.n	4c1a4 <l2cap_recv+0x32>
   4c1a0:	2b01      	cmp	r3, #1
   4c1a2:	d142      	bne.n	4c22a <l2cap_recv+0xb8>
}
   4c1a4:	2000      	movs	r0, #0
   4c1a6:	b005      	add	sp, #20
   4c1a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (buf->len < sizeof(*req)) {
   4c1aa:	2e07      	cmp	r6, #7
   4c1ac:	6824      	ldr	r4, [r4, #0]
	struct bt_l2cap_conn_param_req *req = (void *)buf->data;
   4c1ae:	68aa      	ldr	r2, [r5, #8]
	if (buf->len < sizeof(*req)) {
   4c1b0:	d9f8      	bls.n	4c1a4 <l2cap_recv+0x32>
	if (conn->state != BT_CONN_CONNECTED) {
   4c1b2:	7b63      	ldrb	r3, [r4, #13]
   4c1b4:	2b07      	cmp	r3, #7
   4c1b6:	d1f5      	bne.n	4c1a4 <l2cap_recv+0x32>
	if (conn->role != BT_HCI_ROLE_CENTRAL) {
   4c1b8:	78e7      	ldrb	r7, [r4, #3]
   4c1ba:	b11f      	cbz	r7, 4c1c4 <l2cap_recv+0x52>
		l2cap_send_reject(conn, ident, BT_L2CAP_REJ_NOT_UNDERSTOOD,
   4c1bc:	4620      	mov	r0, r4
		l2cap_send_reject(chan->conn, hdr->ident,
   4c1be:	f7ff ffba 	bl	4c136 <l2cap_send_reject.constprop.0>
		break;
   4c1c2:	e7ef      	b.n	4c1a4 <l2cap_recv+0x32>
	param.interval_min = sys_le16_to_cpu(req->min_interval);
   4c1c4:	8813      	ldrh	r3, [r2, #0]
   4c1c6:	f8ad 3008 	strh.w	r3, [sp, #8]
	param.interval_max = sys_le16_to_cpu(req->max_interval);
   4c1ca:	8853      	ldrh	r3, [r2, #2]
   4c1cc:	f8ad 300a 	strh.w	r3, [sp, #10]
	param.latency = sys_le16_to_cpu(req->latency);
   4c1d0:	8893      	ldrh	r3, [r2, #4]
   4c1d2:	f8ad 300c 	strh.w	r3, [sp, #12]
	param.timeout = sys_le16_to_cpu(req->timeout);
   4c1d6:	88d3      	ldrh	r3, [r2, #6]
   4c1d8:	f8ad 300e 	strh.w	r3, [sp, #14]
	buf = l2cap_create_le_sig_pdu(buf, BT_L2CAP_CONN_PARAM_RSP, ident,
   4c1dc:	2202      	movs	r2, #2
   4c1de:	2013      	movs	r0, #19
   4c1e0:	f7ff ff2c 	bl	4c03c <l2cap_create_le_sig_pdu.constprop.0>
	if (!buf) {
   4c1e4:	4605      	mov	r5, r0
   4c1e6:	2800      	cmp	r0, #0
   4c1e8:	d0dc      	beq.n	4c1a4 <l2cap_recv+0x32>
	accepted = le_param_req(conn, &param);
   4c1ea:	a902      	add	r1, sp, #8
   4c1ec:	4620      	mov	r0, r4
   4c1ee:	f7e3 ff0b 	bl	30008 <le_param_req>
	return net_buf_simple_add(&buf->b, len);
   4c1f2:	2102      	movs	r1, #2
   4c1f4:	4606      	mov	r6, r0
   4c1f6:	f105 0008 	add.w	r0, r5, #8
   4c1fa:	f002 fddb 	bl	4edb4 <net_buf_simple_add>
	if (accepted) {
   4c1fe:	f086 0301 	eor.w	r3, r6, #1
   4c202:	b2db      	uxtb	r3, r3
   4c204:	8003      	strh	r3, [r0, #0]
   4c206:	462a      	mov	r2, r5
   4c208:	9700      	str	r7, [sp, #0]
   4c20a:	463b      	mov	r3, r7
   4c20c:	2105      	movs	r1, #5
   4c20e:	4620      	mov	r0, r4
   4c210:	f7ff ff78 	bl	4c104 <bt_l2cap_send_cb>
	if (bt_l2cap_send(conn, cid, buf)) {
   4c214:	b110      	cbz	r0, 4c21c <l2cap_recv+0xaa>
		net_buf_unref(buf);
   4c216:	4628      	mov	r0, r5
   4c218:	f7f6 fb16 	bl	42848 <net_buf_unref>
	if (accepted) {
   4c21c:	2e00      	cmp	r6, #0
   4c21e:	d0c1      	beq.n	4c1a4 <l2cap_recv+0x32>
		bt_conn_le_conn_update(conn, &param);
   4c220:	a902      	add	r1, sp, #8
   4c222:	4620      	mov	r0, r4
   4c224:	f7ff fee1 	bl	4bfea <bt_conn_le_conn_update>
   4c228:	e7bc      	b.n	4c1a4 <l2cap_recv+0x32>
		l2cap_send_reject(chan->conn, hdr->ident,
   4c22a:	6820      	ldr	r0, [r4, #0]
   4c22c:	e7c7      	b.n	4c1be <l2cap_recv+0x4c>

0004c22e <bt_l2cap_le_lookup_rx_cid>:
	return list->head;
   4c22e:	6d00      	ldr	r0, [r0, #80]	; 0x50
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
   4c230:	b130      	cbz	r0, 4c240 <bt_l2cap_le_lookup_rx_cid+0x12>
		if (BT_L2CAP_LE_CHAN(chan)->rx.cid == cid) {
   4c232:	8983      	ldrh	r3, [r0, #12]
   4c234:	428b      	cmp	r3, r1
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
   4c236:	f1a0 0008 	sub.w	r0, r0, #8
		if (BT_L2CAP_LE_CHAN(chan)->rx.cid == cid) {
   4c23a:	d001      	beq.n	4c240 <bt_l2cap_le_lookup_rx_cid+0x12>
	return node->next;
   4c23c:	6880      	ldr	r0, [r0, #8]
   4c23e:	e7f7      	b.n	4c230 <bt_l2cap_le_lookup_rx_cid+0x2>
}
   4c240:	4770      	bx	lr

0004c242 <bt_l2cap_recv>:
{
   4c242:	b538      	push	{r3, r4, r5, lr}
	if (buf->len < sizeof(*hdr)) {
   4c244:	898b      	ldrh	r3, [r1, #12]
   4c246:	2b03      	cmp	r3, #3
{
   4c248:	4605      	mov	r5, r0
   4c24a:	460c      	mov	r4, r1
	if (buf->len < sizeof(*hdr)) {
   4c24c:	d804      	bhi.n	4c258 <bt_l2cap_recv+0x16>
	net_buf_unref(buf);
   4c24e:	4620      	mov	r0, r4
}
   4c250:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	net_buf_unref(buf);
   4c254:	f7f6 baf8 	b.w	42848 <net_buf_unref>
	return net_buf_simple_pull_mem(&buf->b, len);
   4c258:	2104      	movs	r1, #4
   4c25a:	f104 0008 	add.w	r0, r4, #8
   4c25e:	f002 fdda 	bl	4ee16 <net_buf_simple_pull_mem>
	chan = bt_l2cap_le_lookup_rx_cid(conn, cid);
   4c262:	8841      	ldrh	r1, [r0, #2]
   4c264:	4628      	mov	r0, r5
   4c266:	f7ff ffe2 	bl	4c22e <bt_l2cap_le_lookup_rx_cid>
	if (!chan) {
   4c26a:	2800      	cmp	r0, #0
   4c26c:	d0ef      	beq.n	4c24e <bt_l2cap_recv+0xc>
	chan->ops->recv(chan, buf);
   4c26e:	6843      	ldr	r3, [r0, #4]
   4c270:	4621      	mov	r1, r4
   4c272:	695b      	ldr	r3, [r3, #20]
   4c274:	4798      	blx	r3
   4c276:	e7ea      	b.n	4c24e <bt_l2cap_recv+0xc>

0004c278 <bt_l2cap_init>:
#if defined(CONFIG_BT_L2CAP_DYNAMIC_CHANNEL)
	for (size_t i = 0; i < ARRAY_SIZE(l2cap_tx_meta_data_storage); i++) {
		k_fifo_put(&free_l2cap_tx_meta_data, &l2cap_tx_meta_data_storage[i]);
	}
#endif /* CONFIG_BT_L2CAP_DYNAMIC_CHANNEL */
}
   4c278:	4770      	bx	lr

0004c27a <sys_slist_get>:
Z_GENLIST_GET(slist, snode)
   4c27a:	4603      	mov	r3, r0
	return list->head;
   4c27c:	6800      	ldr	r0, [r0, #0]
Z_GENLIST_GET(slist, snode)
   4c27e:	b128      	cbz	r0, 4c28c <sys_slist_get+0x12>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   4c280:	6859      	ldr	r1, [r3, #4]
	return node->next;
   4c282:	6802      	ldr	r2, [r0, #0]
	list->head = node;
   4c284:	601a      	str	r2, [r3, #0]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   4c286:	4288      	cmp	r0, r1
	list->tail = node;
   4c288:	bf08      	it	eq
   4c28a:	605a      	streq	r2, [r3, #4]
Z_GENLIST_GET(slist, snode)
   4c28c:	4770      	bx	lr

0004c28e <net_buf_frags_len>:
 * @param buf Buffer to start off with.
 *
 * @return Number of bytes in the buffer and its fragments.
 */
static inline size_t net_buf_frags_len(struct net_buf *buf)
{
   4c28e:	4603      	mov	r3, r0
	size_t bytes = 0;
   4c290:	2000      	movs	r0, #0

	while (buf) {
   4c292:	b903      	cbnz	r3, 4c296 <net_buf_frags_len+0x8>
		bytes += buf->len;
		buf = buf->frags;
	}

	return bytes;
}
   4c294:	4770      	bx	lr
		bytes += buf->len;
   4c296:	899a      	ldrh	r2, [r3, #12]
		buf = buf->frags;
   4c298:	681b      	ldr	r3, [r3, #0]
		bytes += buf->len;
   4c29a:	4410      	add	r0, r2
		buf = buf->frags;
   4c29c:	e7f9      	b.n	4c292 <net_buf_frags_len+0x4>

0004c29e <attr_read_type_cb>:
{
   4c29e:	b510      	push	{r4, lr}
	if (!data->rsp->len) {
   4c2a0:	68d4      	ldr	r4, [r2, #12]
   4c2a2:	7823      	ldrb	r3, [r4, #0]
   4c2a4:	3102      	adds	r1, #2
   4c2a6:	b913      	cbnz	r3, 4c2ae <attr_read_type_cb+0x10>
		data->rsp->len = read + sizeof(*data->item);
   4c2a8:	7021      	strb	r1, [r4, #0]
	return true;
   4c2aa:	2001      	movs	r0, #1
}
   4c2ac:	bd10      	pop	{r4, pc}
	} else if (data->rsp->len != read + sizeof(*data->item)) {
   4c2ae:	428b      	cmp	r3, r1
   4c2b0:	d0fb      	beq.n	4c2aa <attr_read_type_cb+0xc>
		frag->len -= sizeof(*data->item);
   4c2b2:	8983      	ldrh	r3, [r0, #12]
   4c2b4:	3b02      	subs	r3, #2
   4c2b6:	8183      	strh	r3, [r0, #12]
		data->item = NULL;
   4c2b8:	2000      	movs	r0, #0
   4c2ba:	6110      	str	r0, [r2, #16]
		return false;
   4c2bc:	e7f6      	b.n	4c2ac <attr_read_type_cb+0xe>

0004c2be <att_prepare_write_req>:
}
   4c2be:	2006      	movs	r0, #6
   4c2c0:	4770      	bx	lr

0004c2c2 <att_get>:
{
   4c2c2:	b508      	push	{r3, lr}
	if (conn->state != BT_CONN_CONNECTED) {
   4c2c4:	7b43      	ldrb	r3, [r0, #13]
   4c2c6:	2b07      	cmp	r3, #7
   4c2c8:	d001      	beq.n	4c2ce <att_get+0xc>
		return NULL;
   4c2ca:	2000      	movs	r0, #0
}
   4c2cc:	bd08      	pop	{r3, pc}
	chan = bt_l2cap_le_lookup_rx_cid(conn, BT_L2CAP_CID_ATT);
   4c2ce:	2104      	movs	r1, #4
   4c2d0:	f7ff ffad 	bl	4c22e <bt_l2cap_le_lookup_rx_cid>
	if (!chan) {
   4c2d4:	2800      	cmp	r0, #0
   4c2d6:	d0f8      	beq.n	4c2ca <att_get+0x8>
	return att_chan->att;
   4c2d8:	f850 0c04 	ldr.w	r0, [r0, #-4]
   4c2dc:	e7f6      	b.n	4c2cc <att_get+0xa>

0004c2de <atomic_test_bit>:
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   4c2de:	f3bf 8f5b 	dmb	ish
   4c2e2:	6800      	ldr	r0, [r0, #0]
   4c2e4:	f3bf 8f5b 	dmb	ish
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
   4c2e8:	4108      	asrs	r0, r1
}
   4c2ea:	f000 0001 	and.w	r0, r0, #1
   4c2ee:	4770      	bx	lr

0004c2f0 <chan_req_send>:
{
   4c2f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   4c2f2:	4605      	mov	r5, r0
	if (chan->chan.tx.mtu < net_buf_frags_len(req->buf)) {
   4c2f4:	6888      	ldr	r0, [r1, #8]
   4c2f6:	f7ff ffca 	bl	4c28e <net_buf_frags_len>
   4c2fa:	8d6b      	ldrh	r3, [r5, #42]	; 0x2a
   4c2fc:	4283      	cmp	r3, r0
{
   4c2fe:	460c      	mov	r4, r1
	if (chan->chan.tx.mtu < net_buf_frags_len(req->buf)) {
   4c300:	d30d      	bcc.n	4c31e <chan_req_send+0x2e>
	chan->req = req;
   4c302:	f8c5 1094 	str.w	r1, [r5, #148]	; 0x94
	buf = req->buf;
   4c306:	688f      	ldr	r7, [r1, #8]
	req->buf = NULL;
   4c308:	2600      	movs	r6, #0
   4c30a:	608e      	str	r6, [r1, #8]
	return chan_send(chan, buf);
   4c30c:	4628      	mov	r0, r5
   4c30e:	4639      	mov	r1, r7
   4c310:	f7e4 fb5c 	bl	309cc <chan_send>
	if (err) {
   4c314:	b110      	cbz	r0, 4c31c <chan_req_send+0x2c>
		req->buf = buf;
   4c316:	60a7      	str	r7, [r4, #8]
		chan->req = NULL;
   4c318:	f8c5 6094 	str.w	r6, [r5, #148]	; 0x94
}
   4c31c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return -EMSGSIZE;
   4c31e:	f06f 0079 	mvn.w	r0, #121	; 0x79
   4c322:	e7fb      	b.n	4c31c <chan_req_send+0x2c>

0004c324 <att_notify_mult>:
{
   4c324:	b508      	push	{r3, lr}
	bt_gatt_mult_notification(chan->att->conn, buf->data, buf->len);
   4c326:	6803      	ldr	r3, [r0, #0]
   4c328:	898a      	ldrh	r2, [r1, #12]
   4c32a:	6818      	ldr	r0, [r3, #0]
   4c32c:	6889      	ldr	r1, [r1, #8]
   4c32e:	f001 fcea 	bl	4dd06 <bt_gatt_mult_notification>
}
   4c332:	2000      	movs	r0, #0
   4c334:	bd08      	pop	{r3, pc}

0004c336 <att_notify>:
{
   4c336:	b538      	push	{r3, r4, r5, lr}
   4c338:	4605      	mov	r5, r0
	return net_buf_simple_pull_le16(&buf->b);
   4c33a:	f101 0008 	add.w	r0, r1, #8
   4c33e:	460c      	mov	r4, r1
   4c340:	f002 fd79 	bl	4ee36 <net_buf_simple_pull_le16>
	bt_gatt_notification(chan->att->conn, handle, buf->data, buf->len);
   4c344:	682d      	ldr	r5, [r5, #0]
   4c346:	89a3      	ldrh	r3, [r4, #12]
   4c348:	68a2      	ldr	r2, [r4, #8]
   4c34a:	4601      	mov	r1, r0
   4c34c:	6828      	ldr	r0, [r5, #0]
   4c34e:	f001 fca7 	bl	4dca0 <bt_gatt_notification>
}
   4c352:	2000      	movs	r0, #0
   4c354:	bd38      	pop	{r3, r4, r5, pc}

0004c356 <bt_att_chan_send_rsp>:
{
   4c356:	b538      	push	{r3, r4, r5, lr}
   4c358:	4604      	mov	r4, r0
   4c35a:	460d      	mov	r5, r1
	err = chan_send(chan, buf);
   4c35c:	f7e4 fb36 	bl	309cc <chan_send>
	if (err) {
   4c360:	b130      	cbz	r0, 4c370 <bt_att_chan_send_rsp+0x1a>
		net_buf_put(&chan->tx_queue, buf);
   4c362:	4629      	mov	r1, r5
   4c364:	f104 0098 	add.w	r0, r4, #152	; 0x98
}
   4c368:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		net_buf_put(&chan->tx_queue, buf);
   4c36c:	f002 bce3 	b.w	4ed36 <net_buf_put>
}
   4c370:	bd38      	pop	{r3, r4, r5, pc}

0004c372 <att_chan_mtu_updated>:
{
   4c372:	b470      	push	{r4, r5, r6}
	struct bt_att *att = updated_chan->att;
   4c374:	6805      	ldr	r5, [r0, #0]
	return list->head;
   4c376:	6a6a      	ldr	r2, [r5, #36]	; 0x24
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   4c378:	b352      	cbz	r2, 4c3d0 <att_chan_mtu_updated+0x5e>
	return node->next;
   4c37a:	6813      	ldr	r3, [r2, #0]
   4c37c:	b103      	cbz	r3, 4c380 <att_chan_mtu_updated+0xe>
   4c37e:	3be0      	subs	r3, #224	; 0xe0
   4c380:	f1a2 04e0 	sub.w	r4, r2, #224	; 0xe0
   4c384:	2200      	movs	r2, #0
   4c386:	4611      	mov	r1, r2
   4c388:	e000      	b.n	4c38c <att_chan_mtu_updated+0x1a>
   4c38a:	3be0      	subs	r3, #224	; 0xe0
		if (chan == updated_chan) {
   4c38c:	4284      	cmp	r4, r0
   4c38e:	d007      	beq.n	4c3a0 <att_chan_mtu_updated+0x2e>
		max_tx = MAX(max_tx, chan->chan.tx.mtu);
   4c390:	8d66      	ldrh	r6, [r4, #42]	; 0x2a
		max_rx = MAX(max_rx, chan->chan.rx.mtu);
   4c392:	8b64      	ldrh	r4, [r4, #26]
		max_tx = MAX(max_tx, chan->chan.tx.mtu);
   4c394:	42b1      	cmp	r1, r6
   4c396:	bf38      	it	cc
   4c398:	4631      	movcc	r1, r6
		max_rx = MAX(max_rx, chan->chan.rx.mtu);
   4c39a:	42a2      	cmp	r2, r4
   4c39c:	bf38      	it	cc
   4c39e:	4622      	movcc	r2, r4
   4c3a0:	461c      	mov	r4, r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   4c3a2:	b12b      	cbz	r3, 4c3b0 <att_chan_mtu_updated+0x3e>
   4c3a4:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
   4c3a8:	2b00      	cmp	r3, #0
   4c3aa:	d1ee      	bne.n	4c38a <att_chan_mtu_updated+0x18>
		if (chan == updated_chan) {
   4c3ac:	4284      	cmp	r4, r0
   4c3ae:	d1ef      	bne.n	4c390 <att_chan_mtu_updated+0x1e>
	if ((updated_chan->chan.tx.mtu > max_tx) ||
   4c3b0:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
	    (updated_chan->chan.rx.mtu > max_rx)) {
   4c3b2:	8b40      	ldrh	r0, [r0, #26]
	if ((updated_chan->chan.tx.mtu > max_tx) ||
   4c3b4:	428b      	cmp	r3, r1
   4c3b6:	d801      	bhi.n	4c3bc <att_chan_mtu_updated+0x4a>
   4c3b8:	4290      	cmp	r0, r2
   4c3ba:	d90b      	bls.n	4c3d4 <att_chan_mtu_updated+0x62>
		bt_gatt_att_max_mtu_changed(att->conn, max_tx, max_rx);
   4c3bc:	4282      	cmp	r2, r0
   4c3be:	bf38      	it	cc
   4c3c0:	4602      	movcc	r2, r0
   4c3c2:	4299      	cmp	r1, r3
   4c3c4:	6828      	ldr	r0, [r5, #0]
   4c3c6:	bf38      	it	cc
   4c3c8:	4619      	movcc	r1, r3
}
   4c3ca:	bc70      	pop	{r4, r5, r6}
		bt_gatt_att_max_mtu_changed(att->conn, max_tx, max_rx);
   4c3cc:	f7e6 bcf4 	b.w	32db8 <bt_gatt_att_max_mtu_changed>
   4c3d0:	4611      	mov	r1, r2
   4c3d2:	e7ed      	b.n	4c3b0 <att_chan_mtu_updated+0x3e>
}
   4c3d4:	bc70      	pop	{r4, r5, r6}
   4c3d6:	4770      	bx	lr

0004c3d8 <write_cb>:
{
   4c3d8:	b573      	push	{r0, r1, r4, r5, r6, lr}
   4c3da:	4614      	mov	r4, r2
	data->err = bt_gatt_check_perm(data->conn, attr,
   4c3dc:	4601      	mov	r1, r0
{
   4c3de:	4605      	mov	r5, r0
	data->err = bt_gatt_check_perm(data->conn, attr,
   4c3e0:	f44f 7295 	mov.w	r2, #298	; 0x12a
   4c3e4:	6820      	ldr	r0, [r4, #0]
   4c3e6:	f001 f909 	bl	4d5fc <bt_gatt_check_perm>
   4c3ea:	7520      	strb	r0, [r4, #20]
	if (data->err) {
   4c3ec:	bb00      	cbnz	r0, 4c430 <write_cb+0x58>
	if (!data->req) {
   4c3ee:	7a23      	ldrb	r3, [r4, #8]
   4c3f0:	b1b3      	cbz	r3, 4c420 <write_cb+0x48>
	} else if (data->req == BT_ATT_OP_EXEC_WRITE_REQ) {
   4c3f2:	f1a3 0218 	sub.w	r2, r3, #24
   4c3f6:	4253      	negs	r3, r2
   4c3f8:	4153      	adcs	r3, r2
   4c3fa:	009b      	lsls	r3, r3, #2
	write = attr->write(data->conn, attr, data->value, data->len,
   4c3fc:	9301      	str	r3, [sp, #4]
   4c3fe:	8a63      	ldrh	r3, [r4, #18]
   4c400:	9300      	str	r3, [sp, #0]
   4c402:	68ae      	ldr	r6, [r5, #8]
   4c404:	8a23      	ldrh	r3, [r4, #16]
   4c406:	68e2      	ldr	r2, [r4, #12]
   4c408:	6820      	ldr	r0, [r4, #0]
   4c40a:	4629      	mov	r1, r5
   4c40c:	47b0      	blx	r6
	if (write < 0 || write != data->len) {
   4c40e:	2800      	cmp	r0, #0
   4c410:	db08      	blt.n	4c424 <write_cb+0x4c>
   4c412:	8a23      	ldrh	r3, [r4, #16]
   4c414:	4298      	cmp	r0, r3
   4c416:	d10e      	bne.n	4c436 <write_cb+0x5e>
	data->err = 0U;
   4c418:	2300      	movs	r3, #0
   4c41a:	7523      	strb	r3, [r4, #20]
	return BT_GATT_ITER_CONTINUE;
   4c41c:	2001      	movs	r0, #1
   4c41e:	e008      	b.n	4c432 <write_cb+0x5a>
		flags |= BT_GATT_WRITE_FLAG_CMD;
   4c420:	2302      	movs	r3, #2
   4c422:	e7eb      	b.n	4c3fc <write_cb+0x24>
	if (err < 0 && err >= -0xff) {
   4c424:	f110 0fff 	cmn.w	r0, #255	; 0xff
   4c428:	d305      	bcc.n	4c436 <write_cb+0x5e>
		return -err;
   4c42a:	4240      	negs	r0, r0
   4c42c:	b2c0      	uxtb	r0, r0
		data->err = err_to_att(write);
   4c42e:	7520      	strb	r0, [r4, #20]
		return BT_GATT_ITER_STOP;
   4c430:	2000      	movs	r0, #0
}
   4c432:	b002      	add	sp, #8
   4c434:	bd70      	pop	{r4, r5, r6, pc}
	return BT_ATT_ERR_UNLIKELY;
   4c436:	200e      	movs	r0, #14
   4c438:	e7f9      	b.n	4c42e <write_cb+0x56>

0004c43a <bt_gatt_foreach_attr>:
{
   4c43a:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	bt_gatt_foreach_attr_type(start_handle, end_handle, NULL, NULL, 0, func,
   4c43c:	e9cd 2301 	strd	r2, r3, [sp, #4]
   4c440:	2300      	movs	r3, #0
   4c442:	9300      	str	r3, [sp, #0]
   4c444:	461a      	mov	r2, r3
   4c446:	f7e5 fd63 	bl	31f10 <bt_gatt_foreach_attr_type>
}
   4c44a:	b005      	add	sp, #20
   4c44c:	f85d fb04 	ldr.w	pc, [sp], #4

0004c450 <find_type_cb>:
{
   4c450:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4c454:	b091      	sub	sp, #68	; 0x44
	struct bt_att_chan *chan = data->chan;
   4c456:	f8d2 9000 	ldr.w	r9, [r2]
{
   4c45a:	4607      	mov	r7, r0
   4c45c:	460e      	mov	r6, r1
	if (!bt_uuid_cmp(attr->uuid, BT_UUID_GATT_SECONDARY)) {
   4c45e:	2500      	movs	r5, #0
   4c460:	f642 0301 	movw	r3, #10241	; 0x2801
   4c464:	6800      	ldr	r0, [r0, #0]
	struct bt_conn *conn = chan->chan.chan.conn;
   4c466:	f8d9 8004 	ldr.w	r8, [r9, #4]
	if (!bt_uuid_cmp(attr->uuid, BT_UUID_GATT_SECONDARY)) {
   4c46a:	f88d 502c 	strb.w	r5, [sp, #44]	; 0x2c
   4c46e:	a90b      	add	r1, sp, #44	; 0x2c
{
   4c470:	4614      	mov	r4, r2
	if (!bt_uuid_cmp(attr->uuid, BT_UUID_GATT_SECONDARY)) {
   4c472:	f8ad 302e 	strh.w	r3, [sp, #46]	; 0x2e
   4c476:	f7fe fdc1 	bl	4affc <bt_uuid_cmp>
   4c47a:	2800      	cmp	r0, #0
   4c47c:	d079      	beq.n	4c572 <find_type_cb+0x122>
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY)) {
   4c47e:	f44f 5320 	mov.w	r3, #10240	; 0x2800
   4c482:	6838      	ldr	r0, [r7, #0]
   4c484:	f88d 502c 	strb.w	r5, [sp, #44]	; 0x2c
   4c488:	a90b      	add	r1, sp, #44	; 0x2c
   4c48a:	f8ad 302e 	strh.w	r3, [sp, #46]	; 0x2e
   4c48e:	f7fe fdb5 	bl	4affc <bt_uuid_cmp>
   4c492:	b138      	cbz	r0, 4c4a4 <find_type_cb+0x54>
		if (data->group &&
   4c494:	68a3      	ldr	r3, [r4, #8]
   4c496:	b11b      	cbz	r3, 4c4a0 <find_type_cb+0x50>
   4c498:	885a      	ldrh	r2, [r3, #2]
   4c49a:	42b2      	cmp	r2, r6
   4c49c:	d200      	bcs.n	4c4a0 <find_type_cb+0x50>
	data->group->end_handle = sys_cpu_to_le16(handle);
   4c49e:	805e      	strh	r6, [r3, #2]
		return BT_GATT_ITER_CONTINUE;
   4c4a0:	2001      	movs	r0, #1
   4c4a2:	e009      	b.n	4c4b8 <find_type_cb+0x68>
	if (chan->chan.tx.mtu - net_buf_frags_len(data->buf) <
   4c4a4:	6861      	ldr	r1, [r4, #4]
   4c4a6:	4608      	mov	r0, r1
   4c4a8:	f7ff fef1 	bl	4c28e <net_buf_frags_len>
   4c4ac:	f8b9 302a 	ldrh.w	r3, [r9, #42]	; 0x2a
   4c4b0:	1a1b      	subs	r3, r3, r0
   4c4b2:	2b03      	cmp	r3, #3
   4c4b4:	d803      	bhi.n	4c4be <find_type_cb+0x6e>
		return BT_GATT_ITER_STOP;
   4c4b6:	2000      	movs	r0, #0
}
   4c4b8:	b011      	add	sp, #68	; 0x44
   4c4ba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	frag = net_buf_frag_last(data->buf);
   4c4be:	4608      	mov	r0, r1
   4c4c0:	f002 fc4a 	bl	4ed58 <net_buf_frag_last>
   4c4c4:	4605      	mov	r5, r0
	len = MIN(chan->chan.tx.mtu - net_buf_frags_len(data->buf),
   4c4c6:	6860      	ldr	r0, [r4, #4]
   4c4c8:	f7ff fee1 	bl	4c28e <net_buf_frags_len>
   4c4cc:	f8b9 a02a 	ldrh.w	sl, [r9, #42]	; 0x2a
	return net_buf_simple_tailroom(&buf->b);
   4c4d0:	f105 0b08 	add.w	fp, r5, #8
   4c4d4:	ebaa 0a00 	sub.w	sl, sl, r0
   4c4d8:	4658      	mov	r0, fp
   4c4da:	f002 fcb8 	bl	4ee4e <net_buf_simple_tailroom>
   4c4de:	4582      	cmp	sl, r0
   4c4e0:	d23f      	bcs.n	4c562 <find_type_cb+0x112>
   4c4e2:	6860      	ldr	r0, [r4, #4]
   4c4e4:	f7ff fed3 	bl	4c28e <net_buf_frags_len>
   4c4e8:	f8b9 302a 	ldrh.w	r3, [r9, #42]	; 0x2a
   4c4ec:	1a18      	subs	r0, r3, r0
	if (!len) {
   4c4ee:	b970      	cbnz	r0, 4c50e <find_type_cb+0xbe>
		frag = net_buf_alloc(net_buf_pool_get(data->buf->pool_id),
   4c4f0:	6863      	ldr	r3, [r4, #4]
   4c4f2:	7998      	ldrb	r0, [r3, #6]
   4c4f4:	f7f6 f8e6 	bl	426c4 <net_buf_pool_get>
	return net_buf_alloc_fixed(pool, timeout);
   4c4f8:	2200      	movs	r2, #0
   4c4fa:	2300      	movs	r3, #0
   4c4fc:	f002 fbf2 	bl	4ece4 <net_buf_alloc_fixed>
		if (!frag) {
   4c500:	4605      	mov	r5, r0
   4c502:	2800      	cmp	r0, #0
   4c504:	d0d7      	beq.n	4c4b6 <find_type_cb+0x66>
		net_buf_frag_add(data->buf, frag);
   4c506:	4601      	mov	r1, r0
   4c508:	6860      	ldr	r0, [r4, #4]
   4c50a:	f002 fc36 	bl	4ed7a <net_buf_frag_add>
	read = attr->read(conn, attr, uuid, sizeof(uuid), 0);
   4c50e:	2300      	movs	r3, #0
   4c510:	9300      	str	r3, [sp, #0]
   4c512:	f8d7 9004 	ldr.w	r9, [r7, #4]
   4c516:	4639      	mov	r1, r7
   4c518:	2310      	movs	r3, #16
   4c51a:	aa02      	add	r2, sp, #8
   4c51c:	4640      	mov	r0, r8
   4c51e:	47c8      	blx	r9
	if (read < 0) {
   4c520:	1e07      	subs	r7, r0, #0
   4c522:	db26      	blt.n	4c572 <find_type_cb+0x122>
	if (read != data->value_len) {
   4c524:	7c22      	ldrb	r2, [r4, #16]
		if (!bt_uuid_create(&recvd_uuid.uuid, data->value, data->value_len)) {
   4c526:	68e0      	ldr	r0, [r4, #12]
	if (read != data->value_len) {
   4c528:	42ba      	cmp	r2, r7
   4c52a:	d01e      	beq.n	4c56a <find_type_cb+0x11a>
		if (!bt_uuid_create(&recvd_uuid.uuid, data->value, data->value_len)) {
   4c52c:	4601      	mov	r1, r0
   4c52e:	a80b      	add	r0, sp, #44	; 0x2c
   4c530:	f7fe fd92 	bl	4b058 <bt_uuid_create>
   4c534:	b1e8      	cbz	r0, 4c572 <find_type_cb+0x122>
		if (!bt_uuid_create(&ref_uuid.uuid, uuid, read)) {
   4c536:	b2fa      	uxtb	r2, r7
   4c538:	a902      	add	r1, sp, #8
   4c53a:	a806      	add	r0, sp, #24
   4c53c:	f7fe fd8c 	bl	4b058 <bt_uuid_create>
   4c540:	b1b8      	cbz	r0, 4c572 <find_type_cb+0x122>
		if (bt_uuid_cmp(&recvd_uuid.uuid, &ref_uuid.uuid)) {
   4c542:	a906      	add	r1, sp, #24
   4c544:	a80b      	add	r0, sp, #44	; 0x2c
   4c546:	f7fe fd59 	bl	4affc <bt_uuid_cmp>
	} else if (memcmp(data->value, uuid, read)) {
   4c54a:	b990      	cbnz	r0, 4c572 <find_type_cb+0x122>
	data->err = 0x00;
   4c54c:	2300      	movs	r3, #0
   4c54e:	7463      	strb	r3, [r4, #17]
	return net_buf_simple_add(&buf->b, len);
   4c550:	2104      	movs	r1, #4
   4c552:	f105 0008 	add.w	r0, r5, #8
   4c556:	f002 fc2d 	bl	4edb4 <net_buf_simple_add>
	data->group = net_buf_add(frag, sizeof(*data->group));
   4c55a:	60a0      	str	r0, [r4, #8]
	data->group->start_handle = sys_cpu_to_le16(handle);
   4c55c:	8006      	strh	r6, [r0, #0]
	data->group->end_handle = sys_cpu_to_le16(handle);
   4c55e:	68a3      	ldr	r3, [r4, #8]
   4c560:	e79d      	b.n	4c49e <find_type_cb+0x4e>
	return net_buf_simple_tailroom(&buf->b);
   4c562:	4658      	mov	r0, fp
   4c564:	f002 fc73 	bl	4ee4e <net_buf_simple_tailroom>
   4c568:	e7c1      	b.n	4c4ee <find_type_cb+0x9e>
	} else if (memcmp(data->value, uuid, read)) {
   4c56a:	a902      	add	r1, sp, #8
   4c56c:	f7fe fc75 	bl	4ae5a <memcmp>
   4c570:	e7eb      	b.n	4c54a <find_type_cb+0xfa>
	data->group = NULL;
   4c572:	2300      	movs	r3, #0
   4c574:	60a3      	str	r3, [r4, #8]
	return BT_GATT_ITER_CONTINUE;
   4c576:	e793      	b.n	4c4a0 <find_type_cb+0x50>

0004c578 <find_info_cb>:
{
   4c578:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (!data->rsp) {
   4c57a:	6893      	ldr	r3, [r2, #8]
	struct bt_att_chan *chan = data->chan;
   4c57c:	6817      	ldr	r7, [r2, #0]
{
   4c57e:	4605      	mov	r5, r0
   4c580:	460e      	mov	r6, r1
   4c582:	4614      	mov	r4, r2
	if (!data->rsp) {
   4c584:	b963      	cbnz	r3, 4c5a0 <find_info_cb+0x28>
	return net_buf_simple_add(&buf->b, len);
   4c586:	6850      	ldr	r0, [r2, #4]
   4c588:	2101      	movs	r1, #1
   4c58a:	3008      	adds	r0, #8
   4c58c:	f002 fc12 	bl	4edb4 <net_buf_simple_add>
		data->rsp = net_buf_add(data->buf, sizeof(*data->rsp));
   4c590:	60a0      	str	r0, [r4, #8]
		data->rsp->format = (attr->uuid->type == BT_UUID_TYPE_16) ?
   4c592:	682b      	ldr	r3, [r5, #0]
   4c594:	781b      	ldrb	r3, [r3, #0]
   4c596:	2b00      	cmp	r3, #0
   4c598:	bf14      	ite	ne
   4c59a:	2302      	movne	r3, #2
   4c59c:	2301      	moveq	r3, #1
   4c59e:	7003      	strb	r3, [r0, #0]
	switch (data->rsp->format) {
   4c5a0:	68a3      	ldr	r3, [r4, #8]
   4c5a2:	781b      	ldrb	r3, [r3, #0]
   4c5a4:	2b01      	cmp	r3, #1
   4c5a6:	d003      	beq.n	4c5b0 <find_info_cb+0x38>
   4c5a8:	2b02      	cmp	r3, #2
   4c5aa:	d019      	beq.n	4c5e0 <find_info_cb+0x68>
   4c5ac:	2000      	movs	r0, #0
   4c5ae:	e016      	b.n	4c5de <find_info_cb+0x66>
		if (attr->uuid->type != BT_UUID_TYPE_16) {
   4c5b0:	682b      	ldr	r3, [r5, #0]
   4c5b2:	781b      	ldrb	r3, [r3, #0]
   4c5b4:	2b00      	cmp	r3, #0
   4c5b6:	d1f9      	bne.n	4c5ac <find_info_cb+0x34>
   4c5b8:	6860      	ldr	r0, [r4, #4]
   4c5ba:	2104      	movs	r1, #4
   4c5bc:	3008      	adds	r0, #8
   4c5be:	f002 fbf9 	bl	4edb4 <net_buf_simple_add>
		data->info16 = net_buf_add(data->buf, sizeof(*data->info16));
   4c5c2:	60e0      	str	r0, [r4, #12]
		data->info16->handle = sys_cpu_to_le16(handle);
   4c5c4:	8006      	strh	r6, [r0, #0]
		data->info16->uuid = sys_cpu_to_le16(BT_UUID_16(attr->uuid)->val);
   4c5c6:	682a      	ldr	r2, [r5, #0]
   4c5c8:	68e3      	ldr	r3, [r4, #12]
   4c5ca:	8852      	ldrh	r2, [r2, #2]
   4c5cc:	805a      	strh	r2, [r3, #2]
		if (chan->chan.tx.mtu - data->buf->len >
   4c5ce:	6863      	ldr	r3, [r4, #4]
   4c5d0:	8d78      	ldrh	r0, [r7, #42]	; 0x2a
   4c5d2:	899b      	ldrh	r3, [r3, #12]
   4c5d4:	1ac0      	subs	r0, r0, r3
   4c5d6:	2804      	cmp	r0, #4
		if (chan->chan.tx.mtu - data->buf->len >
   4c5d8:	bf94      	ite	ls
   4c5da:	2000      	movls	r0, #0
   4c5dc:	2001      	movhi	r0, #1
}
   4c5de:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (attr->uuid->type != BT_UUID_TYPE_128) {
   4c5e0:	682b      	ldr	r3, [r5, #0]
   4c5e2:	781b      	ldrb	r3, [r3, #0]
   4c5e4:	2b02      	cmp	r3, #2
   4c5e6:	d1e1      	bne.n	4c5ac <find_info_cb+0x34>
   4c5e8:	6860      	ldr	r0, [r4, #4]
   4c5ea:	2112      	movs	r1, #18
   4c5ec:	3008      	adds	r0, #8
   4c5ee:	f002 fbe1 	bl	4edb4 <net_buf_simple_add>
		data->info128 = net_buf_add(data->buf, sizeof(*data->info128));
   4c5f2:	60e0      	str	r0, [r4, #12]
		data->info128->handle = sys_cpu_to_le16(handle);
   4c5f4:	8006      	strh	r6, [r0, #0]
		memcpy(data->info128->uuid, BT_UUID_128(attr->uuid)->val,
   4c5f6:	6829      	ldr	r1, [r5, #0]
   4c5f8:	68e0      	ldr	r0, [r4, #12]
   4c5fa:	2210      	movs	r2, #16
   4c5fc:	3101      	adds	r1, #1
   4c5fe:	3002      	adds	r0, #2
   4c600:	f7fe fc3b 	bl	4ae7a <memcpy>
		if (chan->chan.tx.mtu - data->buf->len >
   4c604:	6863      	ldr	r3, [r4, #4]
   4c606:	8d78      	ldrh	r0, [r7, #42]	; 0x2a
   4c608:	899b      	ldrh	r3, [r3, #12]
   4c60a:	1ac0      	subs	r0, r0, r3
   4c60c:	2812      	cmp	r0, #18
   4c60e:	e7e3      	b.n	4c5d8 <find_info_cb+0x60>

0004c610 <attr_read_group_cb>:
	if (!data->rsp->len) {
   4c610:	68d0      	ldr	r0, [r2, #12]
   4c612:	7803      	ldrb	r3, [r0, #0]
   4c614:	3104      	adds	r1, #4
   4c616:	b913      	cbnz	r3, 4c61e <attr_read_group_cb+0xe>
		data->rsp->len = read + sizeof(*data->group);
   4c618:	7001      	strb	r1, [r0, #0]
	return true;
   4c61a:	2001      	movs	r0, #1
   4c61c:	4770      	bx	lr
	} else if (data->rsp->len != read + sizeof(*data->group)) {
   4c61e:	428b      	cmp	r3, r1
   4c620:	d0fb      	beq.n	4c61a <attr_read_group_cb+0xa>
		data->buf->len -= sizeof(*data->group);
   4c622:	6891      	ldr	r1, [r2, #8]
   4c624:	898b      	ldrh	r3, [r1, #12]
		data->group = NULL;
   4c626:	2000      	movs	r0, #0
		data->buf->len -= sizeof(*data->group);
   4c628:	3b04      	subs	r3, #4
   4c62a:	818b      	strh	r3, [r1, #12]
		data->group = NULL;
   4c62c:	6110      	str	r0, [r2, #16]
}
   4c62e:	4770      	bx	lr

0004c630 <process_queue>:
{
   4c630:	b570      	push	{r4, r5, r6, lr}
		return net_buf_get(fifo, K_NO_WAIT);
   4c632:	2200      	movs	r2, #0
{
   4c634:	4604      	mov	r4, r0
		return net_buf_get(fifo, K_NO_WAIT);
   4c636:	2300      	movs	r3, #0
   4c638:	4608      	mov	r0, r1
{
   4c63a:	460e      	mov	r6, r1
		return net_buf_get(fifo, K_NO_WAIT);
   4c63c:	f002 fb57 	bl	4ecee <net_buf_get>
	if (buf) {
   4c640:	4605      	mov	r5, r0
   4c642:	b158      	cbz	r0, 4c65c <process_queue+0x2c>
	return chan_send(chan, buf);
   4c644:	4601      	mov	r1, r0
   4c646:	4620      	mov	r0, r4
   4c648:	f7e4 f9c0 	bl	309cc <chan_send>
		if (err) {
   4c64c:	4604      	mov	r4, r0
   4c64e:	b118      	cbz	r0, 4c658 <process_queue+0x28>
			k_queue_prepend(&queue->_queue, buf);
   4c650:	4629      	mov	r1, r5
   4c652:	4630      	mov	r0, r6
   4c654:	f003 fbc7 	bl	4fde6 <k_queue_prepend>
}
   4c658:	4620      	mov	r0, r4
   4c65a:	bd70      	pop	{r4, r5, r6, pc}
	return -ENOENT;
   4c65c:	f06f 0401 	mvn.w	r4, #1
   4c660:	e7fa      	b.n	4c658 <process_queue+0x28>

0004c662 <att_chan_read>:
{
   4c662:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4c666:	4680      	mov	r8, r0
   4c668:	b085      	sub	sp, #20
	if (chan->chan.tx.mtu <= net_buf_frags_len(buf)) {
   4c66a:	4610      	mov	r0, r2
{
   4c66c:	4699      	mov	r9, r3
   4c66e:	4616      	mov	r6, r2
	if (chan->chan.tx.mtu <= net_buf_frags_len(buf)) {
   4c670:	f7ff fe0d 	bl	4c28e <net_buf_frags_len>
   4c674:	f8b8 302a 	ldrh.w	r3, [r8, #42]	; 0x2a
   4c678:	4283      	cmp	r3, r0
{
   4c67a:	468b      	mov	fp, r1
	if (chan->chan.tx.mtu <= net_buf_frags_len(buf)) {
   4c67c:	d97a      	bls.n	4c774 <att_chan_read+0x112>
	struct bt_conn *conn = chan->chan.chan.conn;
   4c67e:	f8d8 3004 	ldr.w	r3, [r8, #4]
   4c682:	9303      	str	r3, [sp, #12]
	frag = net_buf_frag_last(buf);
   4c684:	4630      	mov	r0, r6
   4c686:	f002 fb67 	bl	4ed58 <net_buf_frag_last>
	size_t len, total = 0;
   4c68a:	f04f 0a00 	mov.w	sl, #0
	frag = net_buf_frag_last(buf);
   4c68e:	4605      	mov	r5, r0
		len = MIN(chan->chan.tx.mtu - net_buf_frags_len(buf),
   4c690:	4630      	mov	r0, r6
   4c692:	f7ff fdfc 	bl	4c28e <net_buf_frags_len>
   4c696:	f8b8 402a 	ldrh.w	r4, [r8, #42]	; 0x2a
	return net_buf_simple_tailroom(&buf->b);
   4c69a:	f105 0708 	add.w	r7, r5, #8
   4c69e:	1a24      	subs	r4, r4, r0
   4c6a0:	4638      	mov	r0, r7
   4c6a2:	f002 fbd4 	bl	4ee4e <net_buf_simple_tailroom>
   4c6a6:	4284      	cmp	r4, r0
   4c6a8:	d211      	bcs.n	4c6ce <att_chan_read+0x6c>
   4c6aa:	4630      	mov	r0, r6
   4c6ac:	f7ff fdef 	bl	4c28e <net_buf_frags_len>
   4c6b0:	f8b8 402a 	ldrh.w	r4, [r8, #42]	; 0x2a
   4c6b4:	1a24      	subs	r4, r4, r0
		if (!len) {
   4c6b6:	bb34      	cbnz	r4, 4c706 <att_chan_read+0xa4>
			frag = net_buf_alloc(net_buf_pool_get(buf->pool_id),
   4c6b8:	79b0      	ldrb	r0, [r6, #6]
   4c6ba:	f7f6 f803 	bl	426c4 <net_buf_pool_get>
	return net_buf_alloc_fixed(pool, timeout);
   4c6be:	2200      	movs	r2, #0
   4c6c0:	2300      	movs	r3, #0
   4c6c2:	f002 fb0f 	bl	4ece4 <net_buf_alloc_fixed>
			if (!frag) {
   4c6c6:	4605      	mov	r5, r0
   4c6c8:	b930      	cbnz	r0, 4c6d8 <att_chan_read+0x76>
	return total;
   4c6ca:	4657      	mov	r7, sl
   4c6cc:	e02c      	b.n	4c728 <att_chan_read+0xc6>
	return net_buf_simple_tailroom(&buf->b);
   4c6ce:	4638      	mov	r0, r7
   4c6d0:	f002 fbbd 	bl	4ee4e <net_buf_simple_tailroom>
   4c6d4:	4604      	mov	r4, r0
   4c6d6:	e7ee      	b.n	4c6b6 <att_chan_read+0x54>
			net_buf_frag_add(buf, frag);
   4c6d8:	4601      	mov	r1, r0
   4c6da:	4630      	mov	r0, r6
   4c6dc:	f002 fb4d 	bl	4ed7a <net_buf_frag_add>
			len = MIN(chan->chan.tx.mtu - net_buf_frags_len(buf),
   4c6e0:	4630      	mov	r0, r6
   4c6e2:	f7ff fdd4 	bl	4c28e <net_buf_frags_len>
   4c6e6:	f8b8 402a 	ldrh.w	r4, [r8, #42]	; 0x2a
   4c6ea:	f105 0708 	add.w	r7, r5, #8
   4c6ee:	1a24      	subs	r4, r4, r0
   4c6f0:	4638      	mov	r0, r7
   4c6f2:	f002 fbac 	bl	4ee4e <net_buf_simple_tailroom>
   4c6f6:	4284      	cmp	r4, r0
   4c6f8:	d21a      	bcs.n	4c730 <att_chan_read+0xce>
   4c6fa:	4630      	mov	r0, r6
   4c6fc:	f7ff fdc7 	bl	4c28e <net_buf_frags_len>
   4c700:	f8b8 402a 	ldrh.w	r4, [r8, #42]	; 0x2a
   4c704:	1a24      	subs	r4, r4, r0
		read = attr->read(conn, attr, frag->data + frag->len, len,
   4c706:	68a9      	ldr	r1, [r5, #8]
   4c708:	89aa      	ldrh	r2, [r5, #12]
   4c70a:	f8cd 9000 	str.w	r9, [sp]
   4c70e:	f8db 7004 	ldr.w	r7, [fp, #4]
   4c712:	9803      	ldr	r0, [sp, #12]
   4c714:	440a      	add	r2, r1
   4c716:	b2a3      	uxth	r3, r4
   4c718:	4659      	mov	r1, fp
   4c71a:	47b8      	blx	r7
		if (read < 0) {
   4c71c:	1e07      	subs	r7, r0, #0
   4c71e:	da0c      	bge.n	4c73a <att_chan_read+0xd8>
				return total;
   4c720:	f1ba 0f00 	cmp.w	sl, #0
   4c724:	bf18      	it	ne
   4c726:	4657      	movne	r7, sl
}
   4c728:	4638      	mov	r0, r7
   4c72a:	b005      	add	sp, #20
   4c72c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   4c730:	4638      	mov	r0, r7
   4c732:	f002 fb8c 	bl	4ee4e <net_buf_simple_tailroom>
   4c736:	4604      	mov	r4, r0
   4c738:	e7e5      	b.n	4c706 <att_chan_read+0xa4>
		if (cb && !cb(frag, read, user_data)) {
   4c73a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   4c73c:	b993      	cbnz	r3, 4c764 <att_chan_read+0x102>
	return net_buf_simple_add(&buf->b, len);
   4c73e:	4639      	mov	r1, r7
   4c740:	f105 0008 	add.w	r0, r5, #8
   4c744:	f002 fb36 	bl	4edb4 <net_buf_simple_add>
	} while (chan->chan.tx.mtu > net_buf_frags_len(buf) && read == len);
   4c748:	4630      	mov	r0, r6
   4c74a:	f7ff fda0 	bl	4c28e <net_buf_frags_len>
   4c74e:	f8b8 302a 	ldrh.w	r3, [r8, #42]	; 0x2a
		offset += read;
   4c752:	44b9      	add	r9, r7
	} while (chan->chan.tx.mtu > net_buf_frags_len(buf) && read == len);
   4c754:	4283      	cmp	r3, r0
		total += read;
   4c756:	44ba      	add	sl, r7
		offset += read;
   4c758:	fa1f f989 	uxth.w	r9, r9
	} while (chan->chan.tx.mtu > net_buf_frags_len(buf) && read == len);
   4c75c:	d9b5      	bls.n	4c6ca <att_chan_read+0x68>
   4c75e:	42a7      	cmp	r7, r4
   4c760:	d096      	beq.n	4c690 <att_chan_read+0x2e>
   4c762:	e7b2      	b.n	4c6ca <att_chan_read+0x68>
		if (cb && !cb(frag, read, user_data)) {
   4c764:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   4c766:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   4c768:	4639      	mov	r1, r7
   4c76a:	4628      	mov	r0, r5
   4c76c:	4798      	blx	r3
   4c76e:	2800      	cmp	r0, #0
   4c770:	d1e5      	bne.n	4c73e <att_chan_read+0xdc>
   4c772:	e7aa      	b.n	4c6ca <att_chan_read+0x68>
		return 0;
   4c774:	2700      	movs	r7, #0
   4c776:	e7d7      	b.n	4c728 <att_chan_read+0xc6>

0004c778 <sys_slist_find_and_remove.isra.0>:
	return list->head;
   4c778:	6803      	ldr	r3, [r0, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   4c77a:	2200      	movs	r2, #0
   4c77c:	b903      	cbnz	r3, 4c780 <sys_slist_find_and_remove.isra.0+0x8>
   4c77e:	4770      	bx	lr
   4c780:	428b      	cmp	r3, r1
   4c782:	d10f      	bne.n	4c7a4 <sys_slist_find_and_remove.isra.0+0x2c>
	return node->next;
   4c784:	680b      	ldr	r3, [r1, #0]
Z_GENLIST_REMOVE(slist, snode)
   4c786:	b93a      	cbnz	r2, 4c798 <sys_slist_find_and_remove.isra.0+0x20>
   4c788:	6842      	ldr	r2, [r0, #4]
	list->head = node;
   4c78a:	6003      	str	r3, [r0, #0]
Z_GENLIST_REMOVE(slist, snode)
   4c78c:	4291      	cmp	r1, r2
   4c78e:	d100      	bne.n	4c792 <sys_slist_find_and_remove.isra.0+0x1a>
	list->tail = node;
   4c790:	6043      	str	r3, [r0, #4]
	parent->next = child;
   4c792:	2300      	movs	r3, #0
   4c794:	600b      	str	r3, [r1, #0]
Z_GENLIST_REMOVE(slist, snode)
   4c796:	4770      	bx	lr
	parent->next = child;
   4c798:	6013      	str	r3, [r2, #0]
Z_GENLIST_REMOVE(slist, snode)
   4c79a:	6843      	ldr	r3, [r0, #4]
   4c79c:	4299      	cmp	r1, r3
	list->tail = node;
   4c79e:	bf08      	it	eq
   4c7a0:	6042      	streq	r2, [r0, #4]
}
   4c7a2:	e7f6      	b.n	4c792 <sys_slist_find_and_remove.isra.0+0x1a>
	return node->next;
   4c7a4:	461a      	mov	r2, r3
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   4c7a6:	681b      	ldr	r3, [r3, #0]
   4c7a8:	e7e8      	b.n	4c77c <sys_slist_find_and_remove.isra.0+0x4>

0004c7aa <att_exec_write_req>:
static uint8_t att_exec_write_req(struct bt_att_chan *chan, struct net_buf *buf)
   4c7aa:	2006      	movs	r0, #6
   4c7ac:	4770      	bx	lr

0004c7ae <read_cb>:
{
   4c7ae:	b573      	push	{r0, r1, r4, r5, r6, lr}
	struct bt_att_chan *chan = data->chan;
   4c7b0:	6816      	ldr	r6, [r2, #0]
{
   4c7b2:	4605      	mov	r5, r0
	data->err = 0x00;
   4c7b4:	2300      	movs	r3, #0
	struct bt_conn *conn = chan->chan.chan.conn;
   4c7b6:	6870      	ldr	r0, [r6, #4]
	data->err = 0x00;
   4c7b8:	7313      	strb	r3, [r2, #12]
{
   4c7ba:	4614      	mov	r4, r2
	data->err = bt_gatt_check_perm(conn, attr, BT_GATT_PERM_READ_MASK);
   4c7bc:	4629      	mov	r1, r5
   4c7be:	2295      	movs	r2, #149	; 0x95
   4c7c0:	f000 ff1c 	bl	4d5fc <bt_gatt_check_perm>
   4c7c4:	7320      	strb	r0, [r4, #12]
	if (data->err) {
   4c7c6:	b980      	cbnz	r0, 4c7ea <read_cb+0x3c>
	ret = att_chan_read(chan, attr, data->buf, data->offset, NULL, NULL);
   4c7c8:	e9cd 0000 	strd	r0, r0, [sp]
   4c7cc:	4629      	mov	r1, r5
   4c7ce:	88a3      	ldrh	r3, [r4, #4]
   4c7d0:	68a2      	ldr	r2, [r4, #8]
   4c7d2:	4630      	mov	r0, r6
   4c7d4:	f7ff ff45 	bl	4c662 <att_chan_read>
	if (ret < 0) {
   4c7d8:	2800      	cmp	r0, #0
   4c7da:	da09      	bge.n	4c7f0 <read_cb+0x42>
	if (err < 0 && err >= -0xff) {
   4c7dc:	f110 0fff 	cmn.w	r0, #255	; 0xff
		return -err;
   4c7e0:	bf26      	itte	cs
   4c7e2:	4240      	negcs	r0, r0
   4c7e4:	b2c0      	uxtbcs	r0, r0
	return BT_ATT_ERR_UNLIKELY;
   4c7e6:	200e      	movcc	r0, #14
		data->err = err_to_att(ret);
   4c7e8:	7320      	strb	r0, [r4, #12]
		return BT_GATT_ITER_STOP;
   4c7ea:	2000      	movs	r0, #0
}
   4c7ec:	b002      	add	sp, #8
   4c7ee:	bd70      	pop	{r4, r5, r6, pc}
	return BT_GATT_ITER_CONTINUE;
   4c7f0:	2001      	movs	r0, #1
   4c7f2:	e7fb      	b.n	4c7ec <read_cb+0x3e>

0004c7f4 <read_vl_cb>:
{
   4c7f4:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	struct bt_att_chan *chan = data->chan;
   4c7f8:	f8d2 8000 	ldr.w	r8, [r2]
{
   4c7fc:	4606      	mov	r6, r0
	data->err = 0x00;
   4c7fe:	2300      	movs	r3, #0
	struct bt_conn *conn = chan->chan.chan.conn;
   4c800:	f8d8 0004 	ldr.w	r0, [r8, #4]
	data->err = 0x00;
   4c804:	7313      	strb	r3, [r2, #12]
{
   4c806:	4614      	mov	r4, r2
	data->err = bt_gatt_check_perm(conn, attr, BT_GATT_PERM_READ_MASK);
   4c808:	4631      	mov	r1, r6
   4c80a:	2295      	movs	r2, #149	; 0x95
   4c80c:	f000 fef6 	bl	4d5fc <bt_gatt_check_perm>
   4c810:	4605      	mov	r5, r0
   4c812:	7320      	strb	r0, [r4, #12]
	if (data->err) {
   4c814:	b9e0      	cbnz	r0, 4c850 <read_vl_cb+0x5c>
	if (chan->chan.tx.mtu - data->buf->len < 2) {
   4c816:	68a0      	ldr	r0, [r4, #8]
   4c818:	f8b8 302a 	ldrh.w	r3, [r8, #42]	; 0x2a
   4c81c:	8982      	ldrh	r2, [r0, #12]
   4c81e:	1a9b      	subs	r3, r3, r2
   4c820:	2b01      	cmp	r3, #1
   4c822:	dd15      	ble.n	4c850 <read_vl_cb+0x5c>
   4c824:	2102      	movs	r1, #2
   4c826:	3008      	adds	r0, #8
   4c828:	f002 fac4 	bl	4edb4 <net_buf_simple_add>
	read = att_chan_read(chan, attr, data->buf, data->offset, NULL, NULL);
   4c82c:	e9cd 5500 	strd	r5, r5, [sp]
   4c830:	4607      	mov	r7, r0
   4c832:	88a3      	ldrh	r3, [r4, #4]
   4c834:	68a2      	ldr	r2, [r4, #8]
   4c836:	4631      	mov	r1, r6
   4c838:	4640      	mov	r0, r8
   4c83a:	f7ff ff12 	bl	4c662 <att_chan_read>
	if (read < 0) {
   4c83e:	1e03      	subs	r3, r0, #0
   4c840:	da0a      	bge.n	4c858 <read_vl_cb+0x64>
	if (err < 0 && err >= -0xff) {
   4c842:	f113 0fff 	cmn.w	r3, #255	; 0xff
		return -err;
   4c846:	bf26      	itte	cs
   4c848:	425b      	negcs	r3, r3
   4c84a:	b2db      	uxtbcs	r3, r3
	return BT_ATT_ERR_UNLIKELY;
   4c84c:	230e      	movcc	r3, #14
		data->err = err_to_att(read);
   4c84e:	7323      	strb	r3, [r4, #12]
		return BT_GATT_ITER_STOP;
   4c850:	2000      	movs	r0, #0
}
   4c852:	b002      	add	sp, #8
   4c854:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	rsp->len = read;
   4c858:	803b      	strh	r3, [r7, #0]
	return BT_GATT_ITER_CONTINUE;
   4c85a:	2001      	movs	r0, #1
   4c85c:	e7f9      	b.n	4c852 <read_vl_cb+0x5e>

0004c85e <bt_att_sent>:
{
   4c85e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   4c860:	4605      	mov	r5, r0
	struct bt_att_chan *chan = ATT_CHAN(ch);
   4c862:	1f07      	subs	r7, r0, #4
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   4c864:	f100 038c 	add.w	r3, r0, #140	; 0x8c
	struct bt_att *att = chan->att;
   4c868:	f850 4c04 	ldr.w	r4, [r0, #-4]
   4c86c:	f3bf 8f5b 	dmb	ish
   4c870:	e853 1f00 	ldrex	r1, [r3]
   4c874:	f021 0110 	bic.w	r1, r1, #16
   4c878:	e843 1200 	strex	r2, r1, [r3]
   4c87c:	2a00      	cmp	r2, #0
   4c87e:	d1f7      	bne.n	4c870 <bt_att_sent+0x12>
   4c880:	f3bf 8f5b 	dmb	ish
	if (!att) {
   4c884:	b30c      	cbz	r4, 4c8ca <bt_att_sent+0x6c>
	if (!chan->req && !sys_slist_is_empty(&att->reqs)) {
   4c886:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
   4c88a:	b98b      	cbnz	r3, 4c8b0 <bt_att_sent+0x52>
   4c88c:	6863      	ldr	r3, [r4, #4]
   4c88e:	b17b      	cbz	r3, 4c8b0 <bt_att_sent+0x52>
		sys_snode_t *node = sys_slist_get(&att->reqs);
   4c890:	1d20      	adds	r0, r4, #4
   4c892:	f7ff fcf2 	bl	4c27a <sys_slist_get>
		if (chan_req_send(chan, ATT_REQ(node)) >= 0) {
   4c896:	4601      	mov	r1, r0
		sys_snode_t *node = sys_slist_get(&att->reqs);
   4c898:	4606      	mov	r6, r0
		if (chan_req_send(chan, ATT_REQ(node)) >= 0) {
   4c89a:	4638      	mov	r0, r7
   4c89c:	f7ff fd28 	bl	4c2f0 <chan_req_send>
   4c8a0:	2800      	cmp	r0, #0
   4c8a2:	da12      	bge.n	4c8ca <bt_att_sent+0x6c>
	return list->head;
   4c8a4:	6863      	ldr	r3, [r4, #4]
	parent->next = child;
   4c8a6:	6033      	str	r3, [r6, #0]
Z_GENLIST_PREPEND(slist, snode)
   4c8a8:	68a3      	ldr	r3, [r4, #8]
	list->head = node;
   4c8aa:	6066      	str	r6, [r4, #4]
Z_GENLIST_PREPEND(slist, snode)
   4c8ac:	b903      	cbnz	r3, 4c8b0 <bt_att_sent+0x52>
	list->tail = node;
   4c8ae:	60a6      	str	r6, [r4, #8]
	err = process_queue(chan, &chan->tx_queue);
   4c8b0:	f105 0194 	add.w	r1, r5, #148	; 0x94
   4c8b4:	4638      	mov	r0, r7
   4c8b6:	f7ff febb 	bl	4c630 <process_queue>
	if (!err) {
   4c8ba:	b130      	cbz	r0, 4c8ca <bt_att_sent+0x6c>
	(void)process_queue(chan, &att->tx_queue);
   4c8bc:	f104 010c 	add.w	r1, r4, #12
   4c8c0:	4638      	mov	r0, r7
}
   4c8c2:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	(void)process_queue(chan, &att->tx_queue);
   4c8c6:	f7ff beb3 	b.w	4c630 <process_queue>
}
   4c8ca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0004c8cc <att_req_send_process>:
{
   4c8cc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	return list->head;
   4c8d0:	6a44      	ldr	r4, [r0, #36]	; 0x24
   4c8d2:	4680      	mov	r8, r0
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   4c8d4:	2c00      	cmp	r4, #0
   4c8d6:	d03b      	beq.n	4c950 <att_req_send_process+0x84>
	return node->next;
   4c8d8:	f854 69e0 	ldr.w	r6, [r4], #-224
   4c8dc:	b106      	cbz	r6, 4c8e0 <att_req_send_process+0x14>
   4c8de:	3ee0      	subs	r6, #224	; 0xe0
{
   4c8e0:	2300      	movs	r3, #0
   4c8e2:	461d      	mov	r5, r3
		req = get_first_req_matching_chan(&att->reqs, chan);
   4c8e4:	f108 0704 	add.w	r7, r8, #4
   4c8e8:	e013      	b.n	4c912 <att_req_send_process+0x46>
		if (!req && prev &&
   4c8ea:	b1c3      	cbz	r3, 4c91e <att_req_send_process+0x52>
		    (atomic_test_bit(chan->flags, ATT_ENHANCED) ==
   4c8ec:	2103      	movs	r1, #3
   4c8ee:	f104 0090 	add.w	r0, r4, #144	; 0x90
   4c8f2:	f7ff fcf4 	bl	4c2de <atomic_test_bit>
   4c8f6:	4602      	mov	r2, r0
		     atomic_test_bit(prev->flags, ATT_ENHANCED))) {
   4c8f8:	f103 0090 	add.w	r0, r3, #144	; 0x90
   4c8fc:	f7ff fcef 	bl	4c2de <atomic_test_bit>
		if (!req && prev &&
   4c900:	4282      	cmp	r2, r0
   4c902:	d10c      	bne.n	4c91e <att_req_send_process+0x52>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   4c904:	b326      	cbz	r6, 4c950 <att_req_send_process+0x84>
   4c906:	f8d6 20e0 	ldr.w	r2, [r6, #224]	; 0xe0
   4c90a:	b102      	cbz	r2, 4c90e <att_req_send_process+0x42>
   4c90c:	3ae0      	subs	r2, #224	; 0xe0
{
   4c90e:	4634      	mov	r4, r6
   4c910:	4616      	mov	r6, r2
		if (chan->req) {
   4c912:	f8d4 2094 	ldr.w	r2, [r4, #148]	; 0x94
   4c916:	2a00      	cmp	r2, #0
   4c918:	d1f4      	bne.n	4c904 <att_req_send_process+0x38>
		if (!req && prev &&
   4c91a:	2d00      	cmp	r5, #0
   4c91c:	d0e5      	beq.n	4c8ea <att_req_send_process+0x1e>
	sys_snode_t *node = sys_slist_get(reqs);
   4c91e:	4638      	mov	r0, r7
   4c920:	f7ff fcab 	bl	4c27a <sys_slist_get>
	if (node) {
   4c924:	4605      	mov	r5, r0
   4c926:	b908      	cbnz	r0, 4c92c <att_req_send_process+0x60>
   4c928:	4623      	mov	r3, r4
   4c92a:	e7eb      	b.n	4c904 <att_req_send_process+0x38>
	return chan_req_send(chan, req);
   4c92c:	4601      	mov	r1, r0
   4c92e:	4620      	mov	r0, r4
   4c930:	f7ff fcde 	bl	4c2f0 <chan_req_send>
		if (bt_att_chan_req_send(chan, req) >= 0) {
   4c934:	2800      	cmp	r0, #0
   4c936:	da0b      	bge.n	4c950 <att_req_send_process+0x84>
	return list->head;
   4c938:	f8d8 3004 	ldr.w	r3, [r8, #4]
	parent->next = child;
   4c93c:	602b      	str	r3, [r5, #0]
Z_GENLIST_PREPEND(slist, snode)
   4c93e:	f8d8 3008 	ldr.w	r3, [r8, #8]
	list->head = node;
   4c942:	f8c8 5004 	str.w	r5, [r8, #4]
Z_GENLIST_PREPEND(slist, snode)
   4c946:	2b00      	cmp	r3, #0
   4c948:	d1ee      	bne.n	4c928 <att_req_send_process+0x5c>
	list->tail = node;
   4c94a:	f8c8 5008 	str.w	r5, [r8, #8]
}
   4c94e:	e7eb      	b.n	4c928 <att_req_send_process+0x5c>
}
   4c950:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0004c954 <bt_att_status>:
{
   4c954:	b538      	push	{r3, r4, r5, lr}
   4c956:	4605      	mov	r5, r0
   4c958:	4608      	mov	r0, r1
	if (!atomic_test_bit(status, BT_L2CAP_STATUS_OUT)) {
   4c95a:	2100      	movs	r1, #0
   4c95c:	f7ff fcbf 	bl	4c2de <atomic_test_bit>
   4c960:	b1c0      	cbz	r0, 4c994 <bt_att_status+0x40>
	if (!chan->att) {
   4c962:	f855 0c04 	ldr.w	r0, [r5, #-4]
   4c966:	b1a8      	cbz	r0, 4c994 <bt_att_status+0x40>
	if (chan->req) {
   4c968:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
   4c96c:	b993      	cbnz	r3, 4c994 <bt_att_status+0x40>
	node = sys_slist_get(&chan->att->reqs);
   4c96e:	3004      	adds	r0, #4
   4c970:	f7ff fc83 	bl	4c27a <sys_slist_get>
	if (!node) {
   4c974:	4604      	mov	r4, r0
   4c976:	b168      	cbz	r0, 4c994 <bt_att_status+0x40>
	return chan_req_send(chan, req);
   4c978:	4601      	mov	r1, r0
   4c97a:	1f28      	subs	r0, r5, #4
   4c97c:	f7ff fcb8 	bl	4c2f0 <chan_req_send>
	if (bt_att_chan_req_send(chan, ATT_REQ(node)) >= 0) {
   4c980:	2800      	cmp	r0, #0
   4c982:	da07      	bge.n	4c994 <bt_att_status+0x40>
	sys_slist_prepend(&chan->att->reqs, node);
   4c984:	f855 3c04 	ldr.w	r3, [r5, #-4]
	return list->head;
   4c988:	685a      	ldr	r2, [r3, #4]
	parent->next = child;
   4c98a:	6022      	str	r2, [r4, #0]
Z_GENLIST_PREPEND(slist, snode)
   4c98c:	689a      	ldr	r2, [r3, #8]
	list->head = node;
   4c98e:	605c      	str	r4, [r3, #4]
Z_GENLIST_PREPEND(slist, snode)
   4c990:	b902      	cbnz	r2, 4c994 <bt_att_status+0x40>
	list->tail = node;
   4c992:	609c      	str	r4, [r3, #8]
}
   4c994:	bd38      	pop	{r3, r4, r5, pc}

0004c996 <atomic_test_and_set_bit>:
{
   4c996:	b510      	push	{r4, lr}
	atomic_val_t mask = ATOMIC_MASK(bit);
   4c998:	2301      	movs	r3, #1
   4c99a:	fa03 f101 	lsl.w	r1, r3, r1
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   4c99e:	f3bf 8f5b 	dmb	ish
   4c9a2:	e850 3f00 	ldrex	r3, [r0]
   4c9a6:	ea43 0201 	orr.w	r2, r3, r1
   4c9aa:	e840 2400 	strex	r4, r2, [r0]
   4c9ae:	2c00      	cmp	r4, #0
   4c9b0:	d1f7      	bne.n	4c9a2 <atomic_test_and_set_bit+0xc>
   4c9b2:	f3bf 8f5b 	dmb	ish
	return (old & mask) != 0;
   4c9b6:	4219      	tst	r1, r3
}
   4c9b8:	bf14      	ite	ne
   4c9ba:	2001      	movne	r0, #1
   4c9bc:	2000      	moveq	r0, #0
   4c9be:	bd10      	pop	{r4, pc}

0004c9c0 <att_sent>:
	struct bt_att_chan *att_chan = data->att_chan;
   4c9c0:	6808      	ldr	r0, [r1, #0]
	if (chan->ops->sent) {
   4c9c2:	6883      	ldr	r3, [r0, #8]
   4c9c4:	699b      	ldr	r3, [r3, #24]
   4c9c6:	b10b      	cbz	r3, 4c9cc <att_sent+0xc>
		chan->ops->sent(chan);
   4c9c8:	3004      	adds	r0, #4
   4c9ca:	4718      	bx	r3
}
   4c9cc:	4770      	bx	lr

0004c9ce <att_unknown>:
{
   4c9ce:	b510      	push	{r4, lr}
   4c9d0:	460c      	mov	r4, r1
	if (!err) {
   4c9d2:	b90a      	cbnz	r2, 4c9d8 <att_unknown+0xa>
		att_sent(conn, user_data);
   4c9d4:	f7ff fff4 	bl	4c9c0 <att_sent>
	tx_meta_data_free(user_data);
   4c9d8:	4620      	mov	r0, r4
}
   4c9da:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	tx_meta_data_free(user_data);
   4c9de:	f7e3 bfe7 	b.w	309b0 <tx_meta_data_free>

0004c9e2 <att_tx_complete>:
{
   4c9e2:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   4c9e6:	4606      	mov	r6, r0
   4c9e8:	460d      	mov	r5, r1
	if (!err) {
   4c9ea:	4614      	mov	r4, r2
   4c9ec:	b122      	cbz	r2, 4c9f8 <att_tx_complete+0x16>
}
   4c9ee:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	tx_meta_data_free(data);
   4c9f2:	4608      	mov	r0, r1
   4c9f4:	f7e3 bfdc 	b.w	309b0 <tx_meta_data_free>
		att_sent(conn, user_data);
   4c9f8:	f7ff ffe2 	bl	4c9c0 <att_sent>
	bt_gatt_complete_func_t func = data->func;
   4c9fc:	68af      	ldr	r7, [r5, #8]
	uint16_t attr_count = data->attr_count;
   4c9fe:	f8b5 8004 	ldrh.w	r8, [r5, #4]
	void *ud = data->user_data;
   4ca02:	f8d5 900c 	ldr.w	r9, [r5, #12]
	tx_meta_data_free(data);
   4ca06:	4628      	mov	r0, r5
   4ca08:	f7e3 ffd2 	bl	309b0 <tx_meta_data_free>
	if (!err && func) {
   4ca0c:	b92f      	cbnz	r7, 4ca1a <att_tx_complete+0x38>
}
   4ca0e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			func(conn, ud);
   4ca12:	4649      	mov	r1, r9
   4ca14:	4630      	mov	r0, r6
   4ca16:	47b8      	blx	r7
		for (uint16_t i = 0; i < attr_count; i++) {
   4ca18:	3401      	adds	r4, #1
   4ca1a:	b2a3      	uxth	r3, r4
   4ca1c:	4543      	cmp	r3, r8
   4ca1e:	d3f8      	bcc.n	4ca12 <att_tx_complete+0x30>
   4ca20:	e7f5      	b.n	4ca0e <att_tx_complete+0x2c>

0004ca22 <att_req_sent>:
{
   4ca22:	b510      	push	{r4, lr}
   4ca24:	460c      	mov	r4, r1
	if (!err) {
   4ca26:	b90a      	cbnz	r2, 4ca2c <att_req_sent+0xa>
		att_sent(conn, user_data);
   4ca28:	f7ff ffca 	bl	4c9c0 <att_sent>
	struct bt_att_chan *chan = data->att_chan;
   4ca2c:	6820      	ldr	r0, [r4, #0]
	if (chan->req) {
   4ca2e:	f8d0 3094 	ldr.w	r3, [r0, #148]	; 0x94
   4ca32:	b12b      	cbz	r3, 4ca40 <att_req_sent+0x1e>
		k_work_reschedule(&chan->timeout_work, BT_ATT_TIMEOUT);
   4ca34:	f44f 2270 	mov.w	r2, #983040	; 0xf0000
   4ca38:	2300      	movs	r3, #0
   4ca3a:	30b0      	adds	r0, #176	; 0xb0
   4ca3c:	f7fa fdd6 	bl	475ec <k_work_reschedule>
	tx_meta_data_free(user_data);
   4ca40:	4620      	mov	r0, r4
}
   4ca42:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	tx_meta_data_free(user_data);
   4ca46:	f7e3 bfb3 	b.w	309b0 <tx_meta_data_free>

0004ca4a <att_cfm_sent>:
{
   4ca4a:	b510      	push	{r4, lr}
   4ca4c:	460c      	mov	r4, r1
	if (!err) {
   4ca4e:	b90a      	cbnz	r2, 4ca54 <att_cfm_sent+0xa>
		att_sent(conn, user_data);
   4ca50:	f7ff ffb6 	bl	4c9c0 <att_sent>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   4ca54:	6823      	ldr	r3, [r4, #0]
   4ca56:	f3bf 8f5b 	dmb	ish
   4ca5a:	3390      	adds	r3, #144	; 0x90
   4ca5c:	e853 1f00 	ldrex	r1, [r3]
   4ca60:	f021 0102 	bic.w	r1, r1, #2
   4ca64:	e843 1200 	strex	r2, r1, [r3]
   4ca68:	2a00      	cmp	r2, #0
   4ca6a:	d1f7      	bne.n	4ca5c <att_cfm_sent+0x12>
   4ca6c:	f3bf 8f5b 	dmb	ish
	tx_meta_data_free(data);
   4ca70:	4620      	mov	r0, r4
}
   4ca72:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	tx_meta_data_free(data);
   4ca76:	f7e3 bf9b 	b.w	309b0 <tx_meta_data_free>

0004ca7a <att_rsp_sent>:
{
   4ca7a:	b510      	push	{r4, lr}
   4ca7c:	460c      	mov	r4, r1
	if (!err) {
   4ca7e:	b90a      	cbnz	r2, 4ca84 <att_rsp_sent+0xa>
		att_sent(conn, user_data);
   4ca80:	f7ff ff9e 	bl	4c9c0 <att_sent>
   4ca84:	6823      	ldr	r3, [r4, #0]
   4ca86:	f3bf 8f5b 	dmb	ish
   4ca8a:	3390      	adds	r3, #144	; 0x90
   4ca8c:	e853 1f00 	ldrex	r1, [r3]
   4ca90:	f021 0101 	bic.w	r1, r1, #1
   4ca94:	e843 1200 	strex	r2, r1, [r3]
   4ca98:	2a00      	cmp	r2, #0
   4ca9a:	d1f7      	bne.n	4ca8c <att_rsp_sent+0x12>
   4ca9c:	f3bf 8f5b 	dmb	ish
	tx_meta_data_free(data);
   4caa0:	4620      	mov	r0, r4
}
   4caa2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	tx_meta_data_free(data);
   4caa6:	f7e3 bf83 	b.w	309b0 <tx_meta_data_free>

0004caaa <att_indicate>:
{
   4caaa:	b570      	push	{r4, r5, r6, lr}
   4caac:	4604      	mov	r4, r0
	return net_buf_simple_pull_le16(&buf->b);
   4caae:	f101 0008 	add.w	r0, r1, #8
   4cab2:	460d      	mov	r5, r1
   4cab4:	f002 f9bf 	bl	4ee36 <net_buf_simple_pull_le16>
	bt_gatt_notification(chan->att->conn, handle, buf->data, buf->len);
   4cab8:	6826      	ldr	r6, [r4, #0]
   4caba:	89ab      	ldrh	r3, [r5, #12]
   4cabc:	68aa      	ldr	r2, [r5, #8]
   4cabe:	4601      	mov	r1, r0
   4cac0:	6830      	ldr	r0, [r6, #0]
   4cac2:	f001 f8ed 	bl	4dca0 <bt_gatt_notification>
	buf = bt_att_chan_create_pdu(chan, BT_ATT_OP_CONFIRM, 0);
   4cac6:	211e      	movs	r1, #30
   4cac8:	2200      	movs	r2, #0
   4caca:	4620      	mov	r0, r4
   4cacc:	f7e4 f8f4 	bl	30cb8 <bt_att_chan_create_pdu>
	if (!buf) {
   4cad0:	4601      	mov	r1, r0
   4cad2:	b110      	cbz	r0, 4cada <att_indicate+0x30>
	bt_att_chan_send_rsp(chan, buf);
   4cad4:	4620      	mov	r0, r4
   4cad6:	f7ff fc3e 	bl	4c356 <bt_att_chan_send_rsp>
}
   4cada:	2000      	movs	r0, #0
   4cadc:	bd70      	pop	{r4, r5, r6, pc}

0004cade <send_err_rsp.part.0>:
static void send_err_rsp(struct bt_att_chan *chan, uint8_t req, uint16_t handle,
   4cade:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4cae2:	4688      	mov	r8, r1
   4cae4:	4617      	mov	r7, r2
	buf = bt_att_chan_create_pdu(chan, BT_ATT_OP_ERROR_RSP, sizeof(*rsp));
   4cae6:	2101      	movs	r1, #1
   4cae8:	2204      	movs	r2, #4
static void send_err_rsp(struct bt_att_chan *chan, uint8_t req, uint16_t handle,
   4caea:	4605      	mov	r5, r0
   4caec:	461e      	mov	r6, r3
	buf = bt_att_chan_create_pdu(chan, BT_ATT_OP_ERROR_RSP, sizeof(*rsp));
   4caee:	f7e4 f8e3 	bl	30cb8 <bt_att_chan_create_pdu>
	if (!buf) {
   4caf2:	4604      	mov	r4, r0
   4caf4:	b170      	cbz	r0, 4cb14 <send_err_rsp.part.0+0x36>
	return net_buf_simple_add(&buf->b, len);
   4caf6:	2104      	movs	r1, #4
   4caf8:	3008      	adds	r0, #8
   4cafa:	f002 f95b 	bl	4edb4 <net_buf_simple_add>
	rsp->request = req;
   4cafe:	f880 8000 	strb.w	r8, [r0]
	rsp->handle = sys_cpu_to_le16(handle);
   4cb02:	f8a0 7001 	strh.w	r7, [r0, #1]
	rsp->error = err;
   4cb06:	70c6      	strb	r6, [r0, #3]
	bt_att_chan_send_rsp(chan, buf);
   4cb08:	4621      	mov	r1, r4
   4cb0a:	4628      	mov	r0, r5
}
   4cb0c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	bt_att_chan_send_rsp(chan, buf);
   4cb10:	f7ff bc21 	b.w	4c356 <bt_att_chan_send_rsp>
}
   4cb14:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0004cb18 <att_write_req>:
{
   4cb18:	b537      	push	{r0, r1, r2, r4, r5, lr}
   4cb1a:	460c      	mov	r4, r1
   4cb1c:	4605      	mov	r5, r0
	return net_buf_simple_pull_le16(&buf->b);
   4cb1e:	f101 0008 	add.w	r0, r1, #8
   4cb22:	f002 f988 	bl	4ee36 <net_buf_simple_pull_le16>
	return att_write_rsp(chan, BT_ATT_OP_WRITE_REQ, BT_ATT_OP_WRITE_RSP,
   4cb26:	89a2      	ldrh	r2, [r4, #12]
   4cb28:	9201      	str	r2, [sp, #4]
   4cb2a:	68a2      	ldr	r2, [r4, #8]
   4cb2c:	9200      	str	r2, [sp, #0]
   4cb2e:	4603      	mov	r3, r0
   4cb30:	2213      	movs	r2, #19
   4cb32:	2112      	movs	r1, #18
   4cb34:	4628      	mov	r0, r5
   4cb36:	f7e4 f95f 	bl	30df8 <att_write_rsp.constprop.0>
}
   4cb3a:	b003      	add	sp, #12
   4cb3c:	bd30      	pop	{r4, r5, pc}

0004cb3e <att_write_cmd>:
{
   4cb3e:	b537      	push	{r0, r1, r2, r4, r5, lr}
   4cb40:	460c      	mov	r4, r1
   4cb42:	4605      	mov	r5, r0
   4cb44:	f101 0008 	add.w	r0, r1, #8
   4cb48:	f002 f975 	bl	4ee36 <net_buf_simple_pull_le16>
	return att_write_rsp(chan, 0, 0, handle, 0, buf->data, buf->len);
   4cb4c:	89a2      	ldrh	r2, [r4, #12]
   4cb4e:	9201      	str	r2, [sp, #4]
   4cb50:	68a2      	ldr	r2, [r4, #8]
   4cb52:	9200      	str	r2, [sp, #0]
   4cb54:	2200      	movs	r2, #0
   4cb56:	4603      	mov	r3, r0
   4cb58:	4611      	mov	r1, r2
   4cb5a:	4628      	mov	r0, r5
   4cb5c:	f7e4 f94c 	bl	30df8 <att_write_rsp.constprop.0>
}
   4cb60:	b003      	add	sp, #12
   4cb62:	bd30      	pop	{r4, r5, pc}

0004cb64 <bt_att_create_pdu>:
{
   4cb64:	b538      	push	{r3, r4, r5, lr}
   4cb66:	460d      	mov	r5, r1
   4cb68:	4614      	mov	r4, r2
	att = att_get(conn);
   4cb6a:	f7ff fbaa 	bl	4c2c2 <att_get>
	if (!att) {
   4cb6e:	b158      	cbz	r0, 4cb88 <bt_att_create_pdu+0x24>
	return list->head;
   4cb70:	6a43      	ldr	r3, [r0, #36]	; 0x24
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   4cb72:	b14b      	cbz	r3, 4cb88 <bt_att_create_pdu+0x24>
   4cb74:	4618      	mov	r0, r3
	return node->next;
   4cb76:	f850 39e0 	ldr.w	r3, [r0], #-224
   4cb7a:	b103      	cbz	r3, 4cb7e <bt_att_create_pdu+0x1a>
   4cb7c:	3be0      	subs	r3, #224	; 0xe0
		if (len + sizeof(op) > chan->chan.tx.mtu) {
   4cb7e:	1c62      	adds	r2, r4, #1
   4cb80:	8d41      	ldrh	r1, [r0, #42]	; 0x2a
   4cb82:	428a      	cmp	r2, r1
   4cb84:	d90c      	bls.n	4cba0 <bt_att_create_pdu+0x3c>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   4cb86:	b90b      	cbnz	r3, 4cb8c <bt_att_create_pdu+0x28>
}
   4cb88:	2000      	movs	r0, #0
   4cb8a:	bd38      	pop	{r3, r4, r5, pc}
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   4cb8c:	4618      	mov	r0, r3
   4cb8e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
   4cb92:	2b00      	cmp	r3, #0
   4cb94:	d0f4      	beq.n	4cb80 <bt_att_create_pdu+0x1c>
		if (len + sizeof(op) > chan->chan.tx.mtu) {
   4cb96:	8d41      	ldrh	r1, [r0, #42]	; 0x2a
   4cb98:	428a      	cmp	r2, r1
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   4cb9a:	f1a3 03e0 	sub.w	r3, r3, #224	; 0xe0
		if (len + sizeof(op) > chan->chan.tx.mtu) {
   4cb9e:	d8f5      	bhi.n	4cb8c <bt_att_create_pdu+0x28>
		return bt_att_chan_create_pdu(chan, op, len);
   4cba0:	4622      	mov	r2, r4
   4cba2:	4629      	mov	r1, r5
}
   4cba4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		return bt_att_chan_create_pdu(chan, op, len);
   4cba8:	f7e4 b886 	b.w	30cb8 <bt_att_chan_create_pdu>

0004cbac <att_read_blob_req>:
{
   4cbac:	b507      	push	{r0, r1, r2, lr}
	req = (void *)buf->data;
   4cbae:	688a      	ldr	r2, [r1, #8]
	return att_read_rsp(chan, BT_ATT_OP_READ_BLOB_REQ,
   4cbb0:	8813      	ldrh	r3, [r2, #0]
   4cbb2:	8852      	ldrh	r2, [r2, #2]
   4cbb4:	9200      	str	r2, [sp, #0]
   4cbb6:	210c      	movs	r1, #12
   4cbb8:	220d      	movs	r2, #13
   4cbba:	f7e4 faa7 	bl	3110c <att_read_rsp>
}
   4cbbe:	b003      	add	sp, #12
   4cbc0:	f85d fb04 	ldr.w	pc, [sp], #4

0004cbc4 <att_read_req>:
{
   4cbc4:	b507      	push	{r0, r1, r2, lr}
	handle = sys_le16_to_cpu(req->handle);
   4cbc6:	688b      	ldr	r3, [r1, #8]
	return att_read_rsp(chan, BT_ATT_OP_READ_REQ, BT_ATT_OP_READ_RSP,
   4cbc8:	2200      	movs	r2, #0
   4cbca:	881b      	ldrh	r3, [r3, #0]
   4cbcc:	9200      	str	r2, [sp, #0]
   4cbce:	210a      	movs	r1, #10
   4cbd0:	220b      	movs	r2, #11
   4cbd2:	f7e4 fa9b 	bl	3110c <att_read_rsp>
}
   4cbd6:	b003      	add	sp, #12
   4cbd8:	f85d fb04 	ldr.w	pc, [sp], #4

0004cbdc <att_mtu_req>:
{
   4cbdc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4cbe0:	4605      	mov	r5, r0
	struct bt_conn *conn = chan->att->conn;
   4cbe2:	f850 2b90 	ldr.w	r2, [r0], #144
{
   4cbe6:	460b      	mov	r3, r1
	if (atomic_test_bit(chan->flags, ATT_ENHANCED)) {
   4cbe8:	2103      	movs	r1, #3
	struct bt_conn *conn = chan->att->conn;
   4cbea:	6816      	ldr	r6, [r2, #0]
	if (atomic_test_bit(chan->flags, ATT_ENHANCED)) {
   4cbec:	f7ff fb77 	bl	4c2de <atomic_test_bit>
   4cbf0:	4604      	mov	r4, r0
   4cbf2:	bb60      	cbnz	r0, 4cc4e <att_mtu_req+0x72>
	mtu_client = sys_le16_to_cpu(req->mtu);
   4cbf4:	689b      	ldr	r3, [r3, #8]
   4cbf6:	881f      	ldrh	r7, [r3, #0]
	if (mtu_client < BT_ATT_DEFAULT_LE_MTU) {
   4cbf8:	2f16      	cmp	r7, #22
   4cbfa:	d92a      	bls.n	4cc52 <att_mtu_req+0x76>
	pdu = bt_att_create_pdu(conn, BT_ATT_OP_MTU_RSP, sizeof(*rsp));
   4cbfc:	2202      	movs	r2, #2
   4cbfe:	4630      	mov	r0, r6
   4cc00:	f7ff ffb0 	bl	4cb64 <bt_att_create_pdu>
	if (!pdu) {
   4cc04:	4680      	mov	r8, r0
   4cc06:	b330      	cbz	r0, 4cc56 <att_mtu_req+0x7a>
	return net_buf_simple_add(&buf->b, len);
   4cc08:	2102      	movs	r1, #2
   4cc0a:	3008      	adds	r0, #8
   4cc0c:	f002 f8d2 	bl	4edb4 <net_buf_simple_add>
	rsp->mtu = sys_cpu_to_le16(mtu_server);
   4cc10:	2341      	movs	r3, #65	; 0x41
   4cc12:	7003      	strb	r3, [r0, #0]
   4cc14:	7044      	strb	r4, [r0, #1]
	bt_att_chan_send_rsp(chan, pdu);
   4cc16:	4641      	mov	r1, r8
   4cc18:	4628      	mov	r0, r5
   4cc1a:	f7ff fb9c 	bl	4c356 <bt_att_chan_send_rsp>
	chan->chan.rx.mtu = MIN(mtu_client, mtu_server);
   4cc1e:	2f41      	cmp	r7, #65	; 0x41
   4cc20:	bf28      	it	cs
   4cc22:	2741      	movcs	r7, #65	; 0x41
   4cc24:	836f      	strh	r7, [r5, #26]
	chan->chan.tx.mtu = chan->chan.rx.mtu;
   4cc26:	856f      	strh	r7, [r5, #42]	; 0x2a
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   4cc28:	3604      	adds	r6, #4
   4cc2a:	f3bf 8f5b 	dmb	ish
   4cc2e:	e856 3f00 	ldrex	r3, [r6]
   4cc32:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
   4cc36:	e846 3200 	strex	r2, r3, [r6]
   4cc3a:	2a00      	cmp	r2, #0
   4cc3c:	d1f7      	bne.n	4cc2e <att_mtu_req+0x52>
   4cc3e:	f3bf 8f5b 	dmb	ish
	att_chan_mtu_updated(chan);
   4cc42:	4628      	mov	r0, r5
   4cc44:	f7ff fb95 	bl	4c372 <att_chan_mtu_updated>
	return 0;
   4cc48:	4620      	mov	r0, r4
}
   4cc4a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return BT_ATT_ERR_NOT_SUPPORTED;
   4cc4e:	2006      	movs	r0, #6
   4cc50:	e7fb      	b.n	4cc4a <att_mtu_req+0x6e>
		return BT_ATT_ERR_INVALID_PDU;
   4cc52:	2004      	movs	r0, #4
   4cc54:	e7f9      	b.n	4cc4a <att_mtu_req+0x6e>
		return BT_ATT_ERR_UNLIKELY;
   4cc56:	200e      	movs	r0, #14
   4cc58:	e7f7      	b.n	4cc4a <att_mtu_req+0x6e>

0004cc5a <att_handle_find_info_rsp>:
	return att_handle_rsp(chan, buf->data, buf->len, 0);
   4cc5a:	898a      	ldrh	r2, [r1, #12]
   4cc5c:	6889      	ldr	r1, [r1, #8]
   4cc5e:	2300      	movs	r3, #0
   4cc60:	f7e4 bbfe 	b.w	31460 <att_handle_rsp>

0004cc64 <att_handle_find_type_rsp>:
static uint8_t att_handle_find_type_rsp(struct bt_att_chan *chan,
   4cc64:	f7ff bff9 	b.w	4cc5a <att_handle_find_info_rsp>

0004cc68 <att_handle_read_type_rsp>:
static uint8_t att_handle_read_type_rsp(struct bt_att_chan *chan,
   4cc68:	f7ff bff7 	b.w	4cc5a <att_handle_find_info_rsp>

0004cc6c <att_handle_read_rsp>:
static uint8_t att_handle_read_rsp(struct bt_att_chan *chan,
   4cc6c:	f7ff bff5 	b.w	4cc5a <att_handle_find_info_rsp>

0004cc70 <att_handle_read_blob_rsp>:
static uint8_t att_handle_read_blob_rsp(struct bt_att_chan *chan,
   4cc70:	f7ff bff3 	b.w	4cc5a <att_handle_find_info_rsp>

0004cc74 <att_handle_read_mult_rsp>:
static uint8_t att_handle_read_mult_rsp(struct bt_att_chan *chan,
   4cc74:	f7ff bff1 	b.w	4cc5a <att_handle_find_info_rsp>

0004cc78 <att_handle_read_mult_vl_rsp>:
static uint8_t att_handle_read_mult_vl_rsp(struct bt_att_chan *chan,
   4cc78:	f7ff bfef 	b.w	4cc5a <att_handle_find_info_rsp>

0004cc7c <att_handle_read_group_rsp>:
static uint8_t att_handle_read_group_rsp(struct bt_att_chan *chan,
   4cc7c:	f7ff bfed 	b.w	4cc5a <att_handle_find_info_rsp>

0004cc80 <att_handle_write_rsp>:
static uint8_t att_handle_write_rsp(struct bt_att_chan *chan,
   4cc80:	f7ff bfeb 	b.w	4cc5a <att_handle_find_info_rsp>

0004cc84 <att_handle_prepare_write_rsp>:
static uint8_t att_handle_prepare_write_rsp(struct bt_att_chan *chan,
   4cc84:	f7ff bfe9 	b.w	4cc5a <att_handle_find_info_rsp>

0004cc88 <att_handle_exec_write_rsp>:
static uint8_t att_handle_exec_write_rsp(struct bt_att_chan *chan,
   4cc88:	f7ff bfe7 	b.w	4cc5a <att_handle_find_info_rsp>

0004cc8c <att_confirm>:
static uint8_t att_confirm(struct bt_att_chan *chan, struct net_buf *buf)
   4cc8c:	f7ff bfe5 	b.w	4cc5a <att_handle_find_info_rsp>

0004cc90 <att_mtu_rsp>:
{
   4cc90:	b570      	push	{r4, r5, r6, lr}
	rsp = (void *)buf->data;
   4cc92:	688e      	ldr	r6, [r1, #8]
	mtu = sys_le16_to_cpu(rsp->mtu);
   4cc94:	8833      	ldrh	r3, [r6, #0]
	if (mtu < BT_ATT_DEFAULT_LE_MTU) {
   4cc96:	2b16      	cmp	r3, #22
{
   4cc98:	4604      	mov	r4, r0
   4cc9a:	460d      	mov	r5, r1
	if (mtu < BT_ATT_DEFAULT_LE_MTU) {
   4cc9c:	d806      	bhi.n	4ccac <att_mtu_rsp+0x1c>
		return att_handle_rsp(chan, NULL, 0, BT_ATT_ERR_INVALID_PDU);
   4cc9e:	2200      	movs	r2, #0
   4cca0:	2304      	movs	r3, #4
   4cca2:	4611      	mov	r1, r2
}
   4cca4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return att_handle_rsp(chan, rsp, buf->len, 0);
   4cca8:	f7e4 bbda 	b.w	31460 <att_handle_rsp>
	chan->chan.rx.mtu = MIN(mtu, BT_ATT_MTU);
   4ccac:	2b41      	cmp	r3, #65	; 0x41
   4ccae:	bf28      	it	cs
   4ccb0:	2341      	movcs	r3, #65	; 0x41
   4ccb2:	8343      	strh	r3, [r0, #26]
	chan->chan.tx.mtu = chan->chan.rx.mtu;
   4ccb4:	8543      	strh	r3, [r0, #42]	; 0x2a
	att_chan_mtu_updated(chan);
   4ccb6:	f7ff fb5c 	bl	4c372 <att_chan_mtu_updated>
	return att_handle_rsp(chan, rsp, buf->len, 0);
   4ccba:	89aa      	ldrh	r2, [r5, #12]
   4ccbc:	2300      	movs	r3, #0
   4ccbe:	4631      	mov	r1, r6
   4ccc0:	4620      	mov	r0, r4
   4ccc2:	e7ef      	b.n	4cca4 <att_mtu_rsp+0x14>

0004ccc4 <bt_att_encrypt_change>:
{
   4ccc4:	b570      	push	{r4, r5, r6, lr}
	struct bt_att_chan *att_chan = ATT_CHAN(chan);
   4ccc6:	4606      	mov	r6, r0
	if (!att_chan->att) {
   4ccc8:	f850 3c04 	ldr.w	r3, [r0, #-4]
	struct bt_conn *conn = le_chan->chan.conn;
   4cccc:	f856 5904 	ldr.w	r5, [r6], #-4
{
   4ccd0:	4604      	mov	r4, r0
	if (!att_chan->att) {
   4ccd2:	2b00      	cmp	r3, #0
   4ccd4:	d038      	beq.n	4cd48 <bt_att_encrypt_change+0x84>
	if (hci_status) {
   4ccd6:	b141      	cbz	r1, 4ccea <bt_att_encrypt_change+0x26>
		if (att_chan->req && att_chan->req->retrying) {
   4ccd8:	f8d0 3090 	ldr.w	r3, [r0, #144]	; 0x90
   4ccdc:	2b00      	cmp	r3, #0
   4ccde:	d033      	beq.n	4cd48 <bt_att_encrypt_change+0x84>
   4cce0:	7c1b      	ldrb	r3, [r3, #16]
   4cce2:	07da      	lsls	r2, r3, #31
   4cce4:	d530      	bpl.n	4cd48 <bt_att_encrypt_change+0x84>
		return BT_ATT_ERR_AUTHENTICATION;
   4cce6:	2305      	movs	r3, #5
   4cce8:	e021      	b.n	4cd2e <bt_att_encrypt_change+0x6a>
	bt_gatt_encrypt_change(conn);
   4ccea:	4628      	mov	r0, r5
   4ccec:	f7e6 f878 	bl	32de0 <bt_gatt_encrypt_change>
	if (conn->sec_level == BT_SECURITY_L1) {
   4ccf0:	7a6b      	ldrb	r3, [r5, #9]
   4ccf2:	2b01      	cmp	r3, #1
   4ccf4:	d028      	beq.n	4cd48 <bt_att_encrypt_change+0x84>
	if (!(att_chan->req && att_chan->req->retrying)) {
   4ccf6:	f8d4 5090 	ldr.w	r5, [r4, #144]	; 0x90
   4ccfa:	b32d      	cbz	r5, 4cd48 <bt_att_encrypt_change+0x84>
   4ccfc:	7c2b      	ldrb	r3, [r5, #16]
   4ccfe:	07db      	lsls	r3, r3, #31
   4cd00:	d522      	bpl.n	4cd48 <bt_att_encrypt_change+0x84>
	if (!req->encode) {
   4cd02:	68eb      	ldr	r3, [r5, #12]
   4cd04:	2b00      	cmp	r3, #0
   4cd06:	d0ee      	beq.n	4cce6 <bt_att_encrypt_change+0x22>
	buf = bt_att_chan_create_pdu(att_chan, req->att_op, req->len);
   4cd08:	696a      	ldr	r2, [r5, #20]
   4cd0a:	7c69      	ldrb	r1, [r5, #17]
   4cd0c:	4630      	mov	r0, r6
   4cd0e:	f7e3 ffd3 	bl	30cb8 <bt_att_chan_create_pdu>
	if (!buf) {
   4cd12:	4604      	mov	r4, r0
   4cd14:	b150      	cbz	r0, 4cd2c <bt_att_encrypt_change+0x68>
	if (req->encode(buf, req->len, req->user_data)) {
   4cd16:	e9d5 1205 	ldrd	r1, r2, [r5, #20]
   4cd1a:	68eb      	ldr	r3, [r5, #12]
   4cd1c:	4798      	blx	r3
   4cd1e:	b168      	cbz	r0, 4cd3c <bt_att_encrypt_change+0x78>
		tx_meta_data_free(bt_att_tx_meta_data(buf));
   4cd20:	6960      	ldr	r0, [r4, #20]
   4cd22:	f7e3 fe45 	bl	309b0 <tx_meta_data_free>
		net_buf_unref(buf);
   4cd26:	4620      	mov	r0, r4
   4cd28:	f7f5 fd8e 	bl	42848 <net_buf_unref>
		return BT_ATT_ERR_UNLIKELY;
   4cd2c:	230e      	movs	r3, #14
		att_handle_rsp(att_chan, NULL, 0, err);
   4cd2e:	2200      	movs	r2, #0
   4cd30:	4630      	mov	r0, r6
   4cd32:	4611      	mov	r1, r2
}
   4cd34:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		att_handle_rsp(att_chan, NULL, 0, err);
   4cd38:	f7e4 bb92 	b.w	31460 <att_handle_rsp>
	if (chan_send(att_chan, buf)) {
   4cd3c:	4621      	mov	r1, r4
   4cd3e:	4630      	mov	r0, r6
   4cd40:	f7e3 fe44 	bl	309cc <chan_send>
   4cd44:	2800      	cmp	r0, #0
   4cd46:	d1eb      	bne.n	4cd20 <bt_att_encrypt_change+0x5c>
}
   4cd48:	bd70      	pop	{r4, r5, r6, pc}

0004cd4a <att_timeout>:
	bt_att_disconnected(&chan->chan.chan);
   4cd4a:	38ac      	subs	r0, #172	; 0xac
   4cd4c:	f7e4 bbf4 	b.w	31538 <bt_att_disconnected>

0004cd50 <bt_att_send>:
{
   4cd50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   4cd52:	460d      	mov	r5, r1
	att = att_get(conn);
   4cd54:	f7ff fab5 	bl	4c2c2 <att_get>
	if (!att) {
   4cd58:	4604      	mov	r4, r0
   4cd5a:	b940      	cbnz	r0, 4cd6e <bt_att_send+0x1e>
		tx_meta_data_free(bt_att_tx_meta_data(buf));
   4cd5c:	6968      	ldr	r0, [r5, #20]
   4cd5e:	f7e3 fe27 	bl	309b0 <tx_meta_data_free>
		net_buf_unref(buf);
   4cd62:	4628      	mov	r0, r5
   4cd64:	f7f5 fd70 	bl	42848 <net_buf_unref>
		return -ENOTCONN;
   4cd68:	f06f 007f 	mvn.w	r0, #127	; 0x7f
}
   4cd6c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	net_buf_put(&att->tx_queue, buf);
   4cd6e:	f100 060c 	add.w	r6, r0, #12
   4cd72:	4629      	mov	r1, r5
   4cd74:	4630      	mov	r0, r6
   4cd76:	f001 ffde 	bl	4ed36 <net_buf_put>
	return list->head;
   4cd7a:	6a65      	ldr	r5, [r4, #36]	; 0x24
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   4cd7c:	b14d      	cbz	r5, 4cd92 <bt_att_send+0x42>
	return node->next;
   4cd7e:	f855 49e0 	ldr.w	r4, [r5], #-224
   4cd82:	b104      	cbz	r4, 4cd86 <bt_att_send+0x36>
   4cd84:	3ce0      	subs	r4, #224	; 0xe0
		err = process_queue(chan, &att->tx_queue);
   4cd86:	4631      	mov	r1, r6
   4cd88:	4628      	mov	r0, r5
   4cd8a:	f7ff fc51 	bl	4c630 <process_queue>
		if (!err) {
   4cd8e:	4603      	mov	r3, r0
   4cd90:	b980      	cbnz	r0, 4cdb4 <bt_att_send+0x64>
	return 0;
   4cd92:	2000      	movs	r0, #0
   4cd94:	e7ea      	b.n	4cd6c <bt_att_send+0x1c>
		    (atomic_test_bit(chan->flags, ATT_ENHANCED) ==
   4cd96:	2103      	movs	r1, #3
   4cd98:	f104 0090 	add.w	r0, r4, #144	; 0x90
   4cd9c:	f7ff fa9f 	bl	4c2de <atomic_test_bit>
   4cda0:	4607      	mov	r7, r0
		     atomic_test_bit(prev->flags, ATT_ENHANCED))) {
   4cda2:	f105 0090 	add.w	r0, r5, #144	; 0x90
   4cda6:	f7ff fa9a 	bl	4c2de <atomic_test_bit>
		if (err == -ENOENT && prev &&
   4cdaa:	4287      	cmp	r7, r0
   4cdac:	f06f 0301 	mvn.w	r3, #1
   4cdb0:	d107      	bne.n	4cdc2 <bt_att_send+0x72>
   4cdb2:	4614      	mov	r4, r2
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   4cdb4:	2c00      	cmp	r4, #0
   4cdb6:	d0ec      	beq.n	4cd92 <bt_att_send+0x42>
   4cdb8:	f8d4 20e0 	ldr.w	r2, [r4, #224]	; 0xe0
   4cdbc:	b922      	cbnz	r2, 4cdc8 <bt_att_send+0x78>
		if (err == -ENOENT && prev &&
   4cdbe:	3302      	adds	r3, #2
   4cdc0:	d0e9      	beq.n	4cd96 <bt_att_send+0x46>
{
   4cdc2:	4625      	mov	r5, r4
   4cdc4:	4614      	mov	r4, r2
   4cdc6:	e7de      	b.n	4cd86 <bt_att_send+0x36>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   4cdc8:	3ae0      	subs	r2, #224	; 0xe0
   4cdca:	e7f8      	b.n	4cdbe <bt_att_send+0x6e>

0004cdcc <bt_att_req_send>:
{
   4cdcc:	b510      	push	{r4, lr}
   4cdce:	460c      	mov	r4, r1
	att = att_get(conn);
   4cdd0:	f7ff fa77 	bl	4c2c2 <att_get>
	if (!att) {
   4cdd4:	b160      	cbz	r0, 4cdf0 <bt_att_req_send+0x24>
	parent->next = child;
   4cdd6:	2300      	movs	r3, #0
   4cdd8:	6023      	str	r3, [r4, #0]
	return list->tail;
   4cdda:	6883      	ldr	r3, [r0, #8]
Z_GENLIST_APPEND(slist, snode)
   4cddc:	b92b      	cbnz	r3, 4cdea <bt_att_req_send+0x1e>
	list->head = node;
   4cdde:	e9c0 4401 	strd	r4, r4, [r0, #4]
	att_req_send_process(att);
   4cde2:	f7ff fd73 	bl	4c8cc <att_req_send_process>
	return 0;
   4cde6:	2000      	movs	r0, #0
}
   4cde8:	bd10      	pop	{r4, pc}
	parent->next = child;
   4cdea:	601c      	str	r4, [r3, #0]
	list->tail = node;
   4cdec:	6084      	str	r4, [r0, #8]
}
   4cdee:	e7f8      	b.n	4cde2 <bt_att_req_send+0x16>
		return -ENOTCONN;
   4cdf0:	f06f 007f 	mvn.w	r0, #127	; 0x7f
   4cdf4:	e7f8      	b.n	4cde8 <bt_att_req_send+0x1c>

0004cdf6 <bt_att_find_req_by_user_data>:

struct bt_att_req *bt_att_find_req_by_user_data(struct bt_conn *conn, const void *user_data)
{
   4cdf6:	b510      	push	{r4, lr}
   4cdf8:	460c      	mov	r4, r1
	struct bt_att *att;
	struct bt_att_chan *chan;
	struct bt_att_req *req;

	att = att_get(conn);
   4cdfa:	f7ff fa62 	bl	4c2c2 <att_get>
	if (!att) {
   4cdfe:	b198      	cbz	r0, 4ce28 <bt_att_find_req_by_user_data+0x32>
	return list->head;
   4ce00:	6a43      	ldr	r3, [r0, #36]	; 0x24
		return NULL;
	}

	SYS_SLIST_FOR_EACH_CONTAINER(&att->chans, chan, node) {
   4ce02:	b14b      	cbz	r3, 4ce18 <bt_att_find_req_by_user_data+0x22>
		if (chan->req->user_data == user_data) {
   4ce04:	f853 2c4c 	ldr.w	r2, [r3, #-76]
   4ce08:	6991      	ldr	r1, [r2, #24]
   4ce0a:	42a1      	cmp	r1, r4
	SYS_SLIST_FOR_EACH_CONTAINER(&att->chans, chan, node) {
   4ce0c:	f1a3 03e0 	sub.w	r3, r3, #224	; 0xe0
		if (chan->req->user_data == user_data) {
   4ce10:	d009      	beq.n	4ce26 <bt_att_find_req_by_user_data+0x30>
	return node->next;
   4ce12:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
   4ce16:	e7f4      	b.n	4ce02 <bt_att_find_req_by_user_data+0xc>
	return list->head;
   4ce18:	6840      	ldr	r0, [r0, #4]
			return chan->req;
		}
	}

	SYS_SLIST_FOR_EACH_CONTAINER(&att->reqs, req, node) {
   4ce1a:	b128      	cbz	r0, 4ce28 <bt_att_find_req_by_user_data+0x32>
		if (req->user_data == user_data) {
   4ce1c:	6983      	ldr	r3, [r0, #24]
   4ce1e:	42a3      	cmp	r3, r4
   4ce20:	d002      	beq.n	4ce28 <bt_att_find_req_by_user_data+0x32>
	return node->next;
   4ce22:	6800      	ldr	r0, [r0, #0]
   4ce24:	e7f9      	b.n	4ce1a <bt_att_find_req_by_user_data+0x24>
		if (chan->req->user_data == user_data) {
   4ce26:	4610      	mov	r0, r2
			return req;
		}
	}

	return NULL;
}
   4ce28:	bd10      	pop	{r4, pc}

0004ce2a <bt_att_fixed_chan_only>:
#if defined(CONFIG_BT_EATT)
	return bt_eatt_count(conn) == 0;
#else
	return true;
#endif /* CONFIG_BT_EATT */
}
   4ce2a:	2001      	movs	r0, #1
   4ce2c:	4770      	bx	lr

0004ce2e <bt_att_clear_out_of_sync_sent>:

void bt_att_clear_out_of_sync_sent(struct bt_conn *conn)
{
   4ce2e:	b508      	push	{r3, lr}
	struct bt_att *att = att_get(conn);
   4ce30:	f7ff fa47 	bl	4c2c2 <att_get>
	struct bt_att_chan *chan;

	if (!att) {
   4ce34:	b198      	cbz	r0, 4ce5e <bt_att_clear_out_of_sync_sent+0x30>
	return list->head;
   4ce36:	6a43      	ldr	r3, [r0, #36]	; 0x24
		return;
	}

	SYS_SLIST_FOR_EACH_CONTAINER(&att->chans, chan, node) {
   4ce38:	b18b      	cbz	r3, 4ce5e <bt_att_clear_out_of_sync_sent+0x30>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   4ce3a:	f3bf 8f5b 	dmb	ish
   4ce3e:	3be0      	subs	r3, #224	; 0xe0
   4ce40:	f103 0290 	add.w	r2, r3, #144	; 0x90
   4ce44:	e852 0f00 	ldrex	r0, [r2]
   4ce48:	f020 0020 	bic.w	r0, r0, #32
   4ce4c:	e842 0100 	strex	r1, r0, [r2]
   4ce50:	2900      	cmp	r1, #0
   4ce52:	d1f7      	bne.n	4ce44 <bt_att_clear_out_of_sync_sent+0x16>
   4ce54:	f3bf 8f5b 	dmb	ish
	return node->next;
   4ce58:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
   4ce5c:	e7ec      	b.n	4ce38 <bt_att_clear_out_of_sync_sent+0xa>
		atomic_clear_bit(chan->flags, ATT_OUT_OF_SYNC_SENT);
	}
}
   4ce5e:	bd08      	pop	{r3, pc}

0004ce60 <bt_att_out_of_sync_sent_on_fixed>:

bool bt_att_out_of_sync_sent_on_fixed(struct bt_conn *conn)
{
   4ce60:	b508      	push	{r3, lr}
	struct bt_l2cap_chan *l2cap_chan;
	struct bt_att_chan *att_chan;

	l2cap_chan = bt_l2cap_le_lookup_rx_cid(conn, BT_L2CAP_CID_ATT);
   4ce62:	2104      	movs	r1, #4
   4ce64:	f7ff f9e3 	bl	4c22e <bt_l2cap_le_lookup_rx_cid>
	if (!l2cap_chan) {
   4ce68:	b128      	cbz	r0, 4ce76 <bt_att_out_of_sync_sent_on_fixed+0x16>
		return false;
	}

	att_chan = ATT_CHAN(l2cap_chan);
	return atomic_test_bit(att_chan->flags, ATT_OUT_OF_SYNC_SENT);
}
   4ce6a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	return atomic_test_bit(att_chan->flags, ATT_OUT_OF_SYNC_SENT);
   4ce6e:	2105      	movs	r1, #5
   4ce70:	308c      	adds	r0, #140	; 0x8c
   4ce72:	f7ff ba34 	b.w	4c2de <atomic_test_bit>
}
   4ce76:	bd08      	pop	{r3, pc}

0004ce78 <bt_att_set_tx_meta_data>:

void bt_att_set_tx_meta_data(struct net_buf *buf, bt_gatt_complete_func_t func, void *user_data,
			     enum bt_att_chan_opt chan_opt)
{
	struct bt_att_tx_meta_data *data = bt_att_tx_meta_data(buf);
   4ce78:	6940      	ldr	r0, [r0, #20]

	data->func = func;
	data->user_data = user_data;
   4ce7a:	e9c0 1202 	strd	r1, r2, [r0, #8]
	data->attr_count = 1;
   4ce7e:	2201      	movs	r2, #1
   4ce80:	8082      	strh	r2, [r0, #4]
	data->chan_opt = chan_opt;
   4ce82:	7403      	strb	r3, [r0, #16]
}
   4ce84:	4770      	bx	lr

0004ce86 <find_next>:
	*next = (struct bt_gatt_attr *)attr;
   4ce86:	6010      	str	r0, [r2, #0]
}
   4ce88:	2000      	movs	r0, #0
   4ce8a:	4770      	bx	lr

0004ce8c <gatt_ccc_changed>:
{
   4ce8c:	b430      	push	{r4, r5}
   4ce8e:	460b      	mov	r3, r1
   4ce90:	460a      	mov	r2, r1
   4ce92:	f101 043c 	add.w	r4, r1, #60	; 0x3c
	uint16_t value = 0x0000;
   4ce96:	2100      	movs	r1, #0
		if (ccc->cfg[i].value > value) {
   4ce98:	8915      	ldrh	r5, [r2, #8]
	for (i = 0; i < ARRAY_SIZE(ccc->cfg); i++) {
   4ce9a:	320a      	adds	r2, #10
   4ce9c:	42a9      	cmp	r1, r5
   4ce9e:	bf38      	it	cc
   4cea0:	4629      	movcc	r1, r5
   4cea2:	42a2      	cmp	r2, r4
   4cea4:	d1f8      	bne.n	4ce98 <gatt_ccc_changed+0xc>
	if (value != ccc->value) {
   4cea6:	8f9a      	ldrh	r2, [r3, #60]	; 0x3c
   4cea8:	428a      	cmp	r2, r1
   4ceaa:	d004      	beq.n	4ceb6 <gatt_ccc_changed+0x2a>
		ccc->value = value;
   4ceac:	8799      	strh	r1, [r3, #60]	; 0x3c
		if (ccc->cfg_changed) {
   4ceae:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   4ceb0:	b10b      	cbz	r3, 4ceb6 <gatt_ccc_changed+0x2a>
}
   4ceb2:	bc30      	pop	{r4, r5}
			ccc->cfg_changed(attr, value);
   4ceb4:	4718      	bx	r3
}
   4ceb6:	bc30      	pop	{r4, r5}
   4ceb8:	4770      	bx	lr

0004ceba <gatt_indicate_rsp>:
{
   4ceba:	b510      	push	{r4, lr}
   4cebc:	9c02      	ldr	r4, [sp, #8]
	if (params->func) {
   4cebe:	68a3      	ldr	r3, [r4, #8]
{
   4cec0:	460a      	mov	r2, r1
	if (params->func) {
   4cec2:	b10b      	cbz	r3, 4cec8 <gatt_indicate_rsp+0xe>
		params->func(conn, params, err);
   4cec4:	4621      	mov	r1, r4
   4cec6:	4798      	blx	r3
	params->_ref--;
   4cec8:	7da3      	ldrb	r3, [r4, #22]
	if (params->destroy && (params->_ref == 0)) {
   4ceca:	68e2      	ldr	r2, [r4, #12]
	params->_ref--;
   4cecc:	3b01      	subs	r3, #1
   4cece:	b2db      	uxtb	r3, r3
   4ced0:	75a3      	strb	r3, [r4, #22]
	if (params->destroy && (params->_ref == 0)) {
   4ced2:	b122      	cbz	r2, 4cede <gatt_indicate_rsp+0x24>
   4ced4:	b91b      	cbnz	r3, 4cede <gatt_indicate_rsp+0x24>
		params->destroy(params);
   4ced6:	4620      	mov	r0, r4
}
   4ced8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		params->destroy(params);
   4cedc:	4710      	bx	r2
}
   4cede:	bd10      	pop	{r4, pc}

0004cee0 <match_uuid>:
	data->attr = attr;
   4cee0:	6010      	str	r0, [r2, #0]
	data->handle = handle;
   4cee2:	8091      	strh	r1, [r2, #4]
}
   4cee4:	2000      	movs	r0, #0
   4cee6:	4770      	bx	lr

0004cee8 <ccc_set_cb>:
}
   4cee8:	2000      	movs	r0, #0
   4ceea:	4770      	bx	lr

0004ceec <gen_hash_m>:
{
   4ceec:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (attr->uuid->type != BT_UUID_TYPE_16)
   4ceee:	6807      	ldr	r7, [r0, #0]
   4cef0:	783d      	ldrb	r5, [r7, #0]
{
   4cef2:	b089      	sub	sp, #36	; 0x24
   4cef4:	4606      	mov	r6, r0
   4cef6:	4614      	mov	r4, r2
	if (attr->uuid->type != BT_UUID_TYPE_16)
   4cef8:	b9dd      	cbnz	r5, 4cf32 <gen_hash_m+0x46>
	switch (u16->val) {
   4cefa:	887b      	ldrh	r3, [r7, #2]
   4cefc:	f5b3 5f24 	cmp.w	r3, #10496	; 0x2900
   4cf00:	d004      	beq.n	4cf0c <gen_hash_m+0x20>
   4cf02:	d810      	bhi.n	4cf26 <gen_hash_m+0x3a>
   4cf04:	f5a3 5320 	sub.w	r3, r3, #10240	; 0x2800
   4cf08:	2b03      	cmp	r3, #3
   4cf0a:	d812      	bhi.n	4cf32 <gen_hash_m+0x46>
		value = sys_cpu_to_le16(handle);
   4cf0c:	f8ad 100a 	strh.w	r1, [sp, #10]
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
   4cf10:	2202      	movs	r2, #2
   4cf12:	f10d 010a 	add.w	r1, sp, #10
   4cf16:	4620      	mov	r0, r4
   4cf18:	f7fd fd93 	bl	4aa42 <tc_cmac_update>
   4cf1c:	b968      	cbnz	r0, 4cf3a <gen_hash_m+0x4e>
			return BT_GATT_ITER_STOP;
   4cf1e:	f06f 0215 	mvn.w	r2, #21
			state->err = -EINVAL;
   4cf22:	65a2      	str	r2, [r4, #88]	; 0x58
   4cf24:	e006      	b.n	4cf34 <gen_hash_m+0x48>
	switch (u16->val) {
   4cf26:	f503 4356 	add.w	r3, r3, #54784	; 0xd600
   4cf2a:	33ff      	adds	r3, #255	; 0xff
   4cf2c:	b29b      	uxth	r3, r3
   4cf2e:	2b04      	cmp	r3, #4
   4cf30:	d91e      	bls.n	4cf70 <gen_hash_m+0x84>
			return BT_GATT_ITER_STOP;
   4cf32:	2501      	movs	r5, #1
}
   4cf34:	4628      	mov	r0, r5
   4cf36:	b009      	add	sp, #36	; 0x24
   4cf38:	bdf0      	pop	{r4, r5, r6, r7, pc}
		value = sys_cpu_to_le16(u16->val);
   4cf3a:	887b      	ldrh	r3, [r7, #2]
   4cf3c:	f8ad 300a 	strh.w	r3, [sp, #10]
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
   4cf40:	2202      	movs	r2, #2
   4cf42:	f10d 010a 	add.w	r1, sp, #10
   4cf46:	4620      	mov	r0, r4
   4cf48:	f7fd fd7b 	bl	4aa42 <tc_cmac_update>
   4cf4c:	2800      	cmp	r0, #0
   4cf4e:	d0e6      	beq.n	4cf1e <gen_hash_m+0x32>
		len = attr->read(NULL, attr, data, sizeof(data), 0);
   4cf50:	2000      	movs	r0, #0
   4cf52:	9000      	str	r0, [sp, #0]
   4cf54:	aa03      	add	r2, sp, #12
   4cf56:	6877      	ldr	r7, [r6, #4]
   4cf58:	2313      	movs	r3, #19
   4cf5a:	4631      	mov	r1, r6
   4cf5c:	47b8      	blx	r7
		if (len < 0) {
   4cf5e:	1e02      	subs	r2, r0, #0
   4cf60:	dbdf      	blt.n	4cf22 <gen_hash_m+0x36>
		if (tc_cmac_update(&state->state, data, len) ==
   4cf62:	a903      	add	r1, sp, #12
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
   4cf64:	4620      	mov	r0, r4
   4cf66:	f7fd fd6c 	bl	4aa42 <tc_cmac_update>
   4cf6a:	2800      	cmp	r0, #0
   4cf6c:	d1e1      	bne.n	4cf32 <gen_hash_m+0x46>
   4cf6e:	e7d6      	b.n	4cf1e <gen_hash_m+0x32>
		value = sys_cpu_to_le16(handle);
   4cf70:	f8ad 100a 	strh.w	r1, [sp, #10]
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
   4cf74:	2202      	movs	r2, #2
   4cf76:	f10d 010a 	add.w	r1, sp, #10
   4cf7a:	4620      	mov	r0, r4
   4cf7c:	f7fd fd61 	bl	4aa42 <tc_cmac_update>
   4cf80:	2800      	cmp	r0, #0
   4cf82:	d0cc      	beq.n	4cf1e <gen_hash_m+0x32>
		value = sys_cpu_to_le16(u16->val);
   4cf84:	887b      	ldrh	r3, [r7, #2]
   4cf86:	f8ad 300a 	strh.w	r3, [sp, #10]
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
   4cf8a:	2202      	movs	r2, #2
   4cf8c:	f10d 010a 	add.w	r1, sp, #10
   4cf90:	e7e8      	b.n	4cf64 <gen_hash_m+0x78>

0004cf92 <bt_addr_le_cmp>:
   4cf92:	2207      	movs	r2, #7
   4cf94:	f7fd bf61 	b.w	4ae5a <memcmp>

0004cf98 <ccc_find_cfg>:
{
   4cf98:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4cf9c:	4604      	mov	r4, r0
   4cf9e:	460f      	mov	r7, r1
   4cfa0:	4690      	mov	r8, r2
   4cfa2:	1c46      	adds	r6, r0, #1
   4cfa4:	2500      	movs	r5, #0
		if (id == ccc->cfg[i].id &&
   4cfa6:	f816 3c01 	ldrb.w	r3, [r6, #-1]
   4cfaa:	4543      	cmp	r3, r8
   4cfac:	d107      	bne.n	4cfbe <ccc_find_cfg+0x26>
		    !bt_addr_le_cmp(&ccc->cfg[i].peer, addr)) {
   4cfae:	4639      	mov	r1, r7
   4cfb0:	4630      	mov	r0, r6
   4cfb2:	f7ff ffee 	bl	4cf92 <bt_addr_le_cmp>
		if (id == ccc->cfg[i].id &&
   4cfb6:	b910      	cbnz	r0, 4cfbe <ccc_find_cfg+0x26>
			return &ccc->cfg[i];
   4cfb8:	1960      	adds	r0, r4, r5
}
   4cfba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	for (size_t i = 0; i < ARRAY_SIZE(ccc->cfg); i++) {
   4cfbe:	350a      	adds	r5, #10
   4cfc0:	2d3c      	cmp	r5, #60	; 0x3c
   4cfc2:	f106 060a 	add.w	r6, r6, #10
   4cfc6:	d1ee      	bne.n	4cfa6 <ccc_find_cfg+0xe>
	return NULL;
   4cfc8:	2000      	movs	r0, #0
   4cfca:	e7f6      	b.n	4cfba <ccc_find_cfg+0x22>

0004cfcc <atomic_get>:
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   4cfcc:	f3bf 8f5b 	dmb	ish
   4cfd0:	6800      	ldr	r0, [r0, #0]
   4cfd2:	f3bf 8f5b 	dmb	ish
}
   4cfd6:	4770      	bx	lr

0004cfd8 <atomic_or>:
{
   4cfd8:	b510      	push	{r4, lr}
   4cfda:	4603      	mov	r3, r0
}
   4cfdc:	f3bf 8f5b 	dmb	ish
   4cfe0:	e853 0f00 	ldrex	r0, [r3]
   4cfe4:	ea40 0201 	orr.w	r2, r0, r1
   4cfe8:	e843 2400 	strex	r4, r2, [r3]
   4cfec:	2c00      	cmp	r4, #0
   4cfee:	d1f7      	bne.n	4cfe0 <atomic_or+0x8>
   4cff0:	f3bf 8f5b 	dmb	ish
   4cff4:	bd10      	pop	{r4, pc}

0004cff6 <bt_addr_le_copy>:
	memcpy(dst, src, sizeof(*dst));
   4cff6:	2207      	movs	r2, #7
   4cff8:	f7fd bf3f 	b.w	4ae7a <memcpy>

0004cffc <cf_write>:
{
   4cffc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4d000:	461f      	mov	r7, r3
   4d002:	f8bd 3018 	ldrh.w	r3, [sp, #24]
	if (offset > sizeof(cfg->data)) {
   4d006:	2b01      	cmp	r3, #1
{
   4d008:	4606      	mov	r6, r0
   4d00a:	4690      	mov	r8, r2
	if (offset > sizeof(cfg->data)) {
   4d00c:	d82e      	bhi.n	4d06c <cf_write+0x70>
	if (offset + len > sizeof(cfg->data)) {
   4d00e:	443b      	add	r3, r7
   4d010:	2b01      	cmp	r3, #1
   4d012:	463d      	mov	r5, r7
   4d014:	dc2d      	bgt.n	4d072 <cf_write+0x76>
	cfg = find_cf_cfg(conn);
   4d016:	f7e4 fb2d 	bl	31674 <find_cf_cfg>
	if (!cfg) {
   4d01a:	4604      	mov	r4, r0
   4d01c:	b918      	cbnz	r0, 4d026 <cf_write+0x2a>
		cfg = find_cf_cfg(NULL);
   4d01e:	f7e4 fb29 	bl	31674 <find_cf_cfg>
	if (!cfg) {
   4d022:	4604      	mov	r4, r0
   4d024:	b340      	cbz	r0, 4d078 <cf_write+0x7c>
	for (i = 0U; i <= CF_BIT_LAST && (i / 8) < len; i++) {
   4d026:	b197      	cbz	r7, 4d04e <cf_write+0x52>
		if ((cfg->data[i / 8] & BIT(i % 8)) &&
   4d028:	7a21      	ldrb	r1, [r4, #8]
		    !(value[i / 8] & BIT(i % 8))) {
   4d02a:	f898 2000 	ldrb.w	r2, [r8]
   4d02e:	2300      	movs	r3, #0
		if ((cfg->data[i / 8] & BIT(i % 8)) &&
   4d030:	fa21 f003 	lsr.w	r0, r1, r3
   4d034:	07c7      	lsls	r7, r0, #31
   4d036:	d503      	bpl.n	4d040 <cf_write+0x44>
		    !(value[i / 8] & BIT(i % 8))) {
   4d038:	fa22 f003 	lsr.w	r0, r2, r3
		if ((cfg->data[i / 8] & BIT(i % 8)) &&
   4d03c:	07c0      	lsls	r0, r0, #31
   4d03e:	d51e      	bpl.n	4d07e <cf_write+0x82>
	for (i = 0U; i <= CF_BIT_LAST && (i / 8) < len; i++) {
   4d040:	3301      	adds	r3, #1
   4d042:	2b03      	cmp	r3, #3
   4d044:	d1f4      	bne.n	4d030 <cf_write+0x34>
			cfg->data[i] |= value[i] & BIT_MASK(CF_NUM_BITS % 8);
   4d046:	f002 0207 	and.w	r2, r2, #7
   4d04a:	4311      	orrs	r1, r2
   4d04c:	7221      	strb	r1, [r4, #8]
	bt_addr_le_copy(&cfg->peer, &conn->le.dst);
   4d04e:	f106 0188 	add.w	r1, r6, #136	; 0x88
   4d052:	1c60      	adds	r0, r4, #1
   4d054:	f7ff ffcf 	bl	4cff6 <bt_addr_le_copy>
	cfg->id = conn->id;
   4d058:	4620      	mov	r0, r4
   4d05a:	7a33      	ldrb	r3, [r6, #8]
   4d05c:	f800 3b0c 	strb.w	r3, [r0], #12
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
   4d060:	2101      	movs	r1, #1
   4d062:	f7ff ffb9 	bl	4cfd8 <atomic_or>
}
   4d066:	4628      	mov	r0, r5
   4d068:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   4d06c:	f06f 0506 	mvn.w	r5, #6
   4d070:	e7f9      	b.n	4d066 <cf_write+0x6a>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
   4d072:	f06f 050c 	mvn.w	r5, #12
   4d076:	e7f6      	b.n	4d066 <cf_write+0x6a>
		return BT_GATT_ERR(BT_ATT_ERR_INSUFFICIENT_RESOURCES);
   4d078:	f06f 0510 	mvn.w	r5, #16
   4d07c:	e7f3      	b.n	4d066 <cf_write+0x6a>
		return BT_GATT_ERR(BT_ATT_ERR_VALUE_NOT_ALLOWED);
   4d07e:	f06f 0512 	mvn.w	r5, #18
   4d082:	e7f0      	b.n	4d066 <cf_write+0x6a>

0004d084 <atomic_and>:
{
   4d084:	b510      	push	{r4, lr}
   4d086:	4603      	mov	r3, r0
}
   4d088:	f3bf 8f5b 	dmb	ish
   4d08c:	e853 0f00 	ldrex	r0, [r3]
   4d090:	ea00 0201 	and.w	r2, r0, r1
   4d094:	e843 2400 	strex	r4, r2, [r3]
   4d098:	2c00      	cmp	r4, #0
   4d09a:	d1f7      	bne.n	4d08c <atomic_and+0x8>
   4d09c:	f3bf 8f5b 	dmb	ish
   4d0a0:	bd10      	pop	{r4, pc}

0004d0a2 <gatt_write_ccc_rsp>:
{
   4d0a2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4d0a6:	9c06      	ldr	r4, [sp, #24]
   4d0a8:	460e      	mov	r6, r1
   4d0aa:	4605      	mov	r5, r0
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   4d0ac:	f06f 0104 	mvn.w	r1, #4
   4d0b0:	f104 001c 	add.w	r0, r4, #28
   4d0b4:	f7ff ffe6 	bl	4d084 <atomic_and>
	if (err) {
   4d0b8:	b1fe      	cbz	r6, 4d0fa <gatt_write_ccc_rsp+0x58>
		sub = gatt_sub_find(conn);
   4d0ba:	4628      	mov	r0, r5
   4d0bc:	f7e4 fb38 	bl	31730 <gatt_sub_find>
		if (!sub) {
   4d0c0:	4601      	mov	r1, r0
   4d0c2:	b358      	cbz	r0, 4d11c <gatt_write_ccc_rsp+0x7a>
	return list->head;
   4d0c4:	6883      	ldr	r3, [r0, #8]
Z_GENLIST_PEEK_NEXT(slist, snode)
   4d0c6:	b14b      	cbz	r3, 4d0dc <gatt_write_ccc_rsp+0x3a>
	return node->next;
   4d0c8:	681a      	ldr	r2, [r3, #0]
			if (node == &params->node) {
   4d0ca:	f104 0720 	add.w	r7, r4, #32
		SYS_SLIST_FOR_EACH_NODE_SAFE(&sub->list, node, tmp) {
   4d0ce:	b12b      	cbz	r3, 4d0dc <gatt_write_ccc_rsp+0x3a>
			if (node == &params->node) {
   4d0d0:	42bb      	cmp	r3, r7
   4d0d2:	d10b      	bne.n	4d0ec <gatt_write_ccc_rsp+0x4a>
				gatt_sub_remove(conn, sub, tmp, params);
   4d0d4:	4623      	mov	r3, r4
   4d0d6:	4628      	mov	r0, r5
   4d0d8:	f7e4 fb6a 	bl	317b0 <gatt_sub_remove>
	if (params->subscribe) {
   4d0dc:	6863      	ldr	r3, [r4, #4]
   4d0de:	b1b3      	cbz	r3, 4d10e <gatt_write_ccc_rsp+0x6c>
		params->subscribe(conn, err, params);
   4d0e0:	4622      	mov	r2, r4
   4d0e2:	4631      	mov	r1, r6
   4d0e4:	4628      	mov	r0, r5
}
   4d0e6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		params->write(conn, err, NULL);
   4d0ea:	4718      	bx	r3
Z_GENLIST_PEEK_NEXT(slist, snode)
   4d0ec:	b11a      	cbz	r2, 4d0f6 <gatt_write_ccc_rsp+0x54>
	return node->next;
   4d0ee:	6810      	ldr	r0, [r2, #0]
Z_GENLIST_PEEK_NEXT(slist, snode)
   4d0f0:	4613      	mov	r3, r2
   4d0f2:	4602      	mov	r2, r0
   4d0f4:	e7eb      	b.n	4d0ce <gatt_write_ccc_rsp+0x2c>
   4d0f6:	4610      	mov	r0, r2
   4d0f8:	e7fa      	b.n	4d0f0 <gatt_write_ccc_rsp+0x4e>
	} else if (!params->value) {
   4d0fa:	8b23      	ldrh	r3, [r4, #24]
   4d0fc:	2b00      	cmp	r3, #0
   4d0fe:	d1ed      	bne.n	4d0dc <gatt_write_ccc_rsp+0x3a>
		params->notify(conn, params, NULL, 0);
   4d100:	6827      	ldr	r7, [r4, #0]
   4d102:	4633      	mov	r3, r6
   4d104:	4632      	mov	r2, r6
   4d106:	4621      	mov	r1, r4
   4d108:	4628      	mov	r0, r5
   4d10a:	47b8      	blx	r7
   4d10c:	e7e6      	b.n	4d0dc <gatt_write_ccc_rsp+0x3a>
	} else if (params->write) {
   4d10e:	68a4      	ldr	r4, [r4, #8]
   4d110:	b124      	cbz	r4, 4d11c <gatt_write_ccc_rsp+0x7a>
		params->write(conn, err, NULL);
   4d112:	461a      	mov	r2, r3
   4d114:	4631      	mov	r1, r6
   4d116:	4628      	mov	r0, r5
   4d118:	4623      	mov	r3, r4
   4d11a:	e7e4      	b.n	4d0e6 <gatt_write_ccc_rsp+0x44>
}
   4d11c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0004d120 <read_included_uuid_encode>:
{
   4d120:	b510      	push	{r4, lr}
   4d122:	2102      	movs	r1, #2
   4d124:	3008      	adds	r0, #8
   4d126:	4614      	mov	r4, r2
   4d128:	f001 fe44 	bl	4edb4 <net_buf_simple_add>
	req->handle = sys_cpu_to_le16(params->_included.start_handle);
   4d12c:	8963      	ldrh	r3, [r4, #10]
   4d12e:	8003      	strh	r3, [r0, #0]
}
   4d130:	2000      	movs	r0, #0
   4d132:	bd10      	pop	{r4, pc}

0004d134 <gatt_find_info_encode>:
{
   4d134:	b510      	push	{r4, lr}
   4d136:	2104      	movs	r1, #4
   4d138:	3008      	adds	r0, #8
   4d13a:	4614      	mov	r4, r2
   4d13c:	f001 fe3a 	bl	4edb4 <net_buf_simple_add>
	req->start_handle = sys_cpu_to_le16(params->start_handle);
   4d140:	8923      	ldrh	r3, [r4, #8]
   4d142:	8003      	strh	r3, [r0, #0]
	req->end_handle = sys_cpu_to_le16(params->end_handle);
   4d144:	89e3      	ldrh	r3, [r4, #14]
   4d146:	8043      	strh	r3, [r0, #2]
}
   4d148:	2000      	movs	r0, #0
   4d14a:	bd10      	pop	{r4, pc}

0004d14c <gatt_read_group_encode>:
{
   4d14c:	b538      	push	{r3, r4, r5, lr}
   4d14e:	f100 0408 	add.w	r4, r0, #8
   4d152:	2104      	movs	r1, #4
   4d154:	4620      	mov	r0, r4
   4d156:	4615      	mov	r5, r2
   4d158:	f001 fe2c 	bl	4edb4 <net_buf_simple_add>
	req->start_handle = sys_cpu_to_le16(params->start_handle);
   4d15c:	892b      	ldrh	r3, [r5, #8]
   4d15e:	8003      	strh	r3, [r0, #0]
	req->end_handle = sys_cpu_to_le16(params->end_handle);
   4d160:	89eb      	ldrh	r3, [r5, #14]
   4d162:	8043      	strh	r3, [r0, #2]
	if (params->type == BT_GATT_DISCOVER_PRIMARY) {
   4d164:	7c2b      	ldrb	r3, [r5, #16]
   4d166:	b933      	cbnz	r3, 4d176 <gatt_read_group_encode+0x2a>
	net_buf_simple_add_le16(&buf->b, val);
   4d168:	f44f 5120 	mov.w	r1, #10240	; 0x2800
   4d16c:	4620      	mov	r0, r4
   4d16e:	f001 fe38 	bl	4ede2 <net_buf_simple_add_le16>
}
   4d172:	2000      	movs	r0, #0
   4d174:	bd38      	pop	{r3, r4, r5, pc}
   4d176:	f642 0101 	movw	r1, #10241	; 0x2801
   4d17a:	e7f7      	b.n	4d16c <gatt_read_group_encode+0x20>

0004d17c <gatt_read_type_encode>:
{
   4d17c:	b538      	push	{r3, r4, r5, lr}
	return net_buf_simple_add(&buf->b, len);
   4d17e:	f100 0408 	add.w	r4, r0, #8
   4d182:	2104      	movs	r1, #4
   4d184:	4620      	mov	r0, r4
   4d186:	4615      	mov	r5, r2
   4d188:	f001 fe14 	bl	4edb4 <net_buf_simple_add>
	req->start_handle = sys_cpu_to_le16(params->start_handle);
   4d18c:	892b      	ldrh	r3, [r5, #8]
   4d18e:	8003      	strh	r3, [r0, #0]
	req->end_handle = sys_cpu_to_le16(params->end_handle);
   4d190:	89eb      	ldrh	r3, [r5, #14]
   4d192:	8043      	strh	r3, [r0, #2]
	switch (params->type) {
   4d194:	7c2b      	ldrb	r3, [r5, #16]
   4d196:	2b02      	cmp	r3, #2
   4d198:	d004      	beq.n	4d1a4 <gatt_read_type_encode+0x28>
   4d19a:	2b03      	cmp	r3, #3
   4d19c:	d009      	beq.n	4d1b2 <gatt_read_type_encode+0x36>
		net_buf_add_le16(buf, BT_UUID_16(params->uuid)->val);
   4d19e:	682b      	ldr	r3, [r5, #0]
	net_buf_simple_add_le16(&buf->b, val);
   4d1a0:	8859      	ldrh	r1, [r3, #2]
   4d1a2:	e001      	b.n	4d1a8 <gatt_read_type_encode+0x2c>
   4d1a4:	f642 0102 	movw	r1, #10242	; 0x2802
   4d1a8:	4620      	mov	r0, r4
   4d1aa:	f001 fe1a 	bl	4ede2 <net_buf_simple_add_le16>
}
   4d1ae:	2000      	movs	r0, #0
   4d1b0:	bd38      	pop	{r3, r4, r5, pc}
   4d1b2:	f642 0103 	movw	r1, #10243	; 0x2803
   4d1b6:	e7f7      	b.n	4d1a8 <gatt_read_type_encode+0x2c>

0004d1b8 <cf_set>:
{
   4d1b8:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
   4d1bc:	4688      	mov	r8, r1
   4d1be:	4616      	mov	r6, r2
   4d1c0:	461f      	mov	r7, r3
	if (!name) {
   4d1c2:	4605      	mov	r5, r0
   4d1c4:	b928      	cbnz	r0, 4d1d2 <cf_set+0x1a>
		return -EINVAL;
   4d1c6:	f06f 0415 	mvn.w	r4, #21
}
   4d1ca:	4620      	mov	r0, r4
   4d1cc:	b004      	add	sp, #16
   4d1ce:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	err = bt_settings_decode_key(name, &addr);
   4d1d2:	a902      	add	r1, sp, #8
   4d1d4:	f7fd feec 	bl	4afb0 <bt_settings_decode_key>
	if (err) {
   4d1d8:	4604      	mov	r4, r0
   4d1da:	2800      	cmp	r0, #0
   4d1dc:	d1f3      	bne.n	4d1c6 <cf_set+0xe>
	settings_name_next(name, &next);
   4d1de:	a901      	add	r1, sp, #4
   4d1e0:	4628      	mov	r0, r5
   4d1e2:	f7fc fabe 	bl	49762 <settings_name_next>
	if (!next) {
   4d1e6:	9801      	ldr	r0, [sp, #4]
   4d1e8:	b9d0      	cbnz	r0, 4d220 <cf_set+0x68>
	cfg = find_cf_cfg_by_addr(id, &addr);
   4d1ea:	a902      	add	r1, sp, #8
   4d1ec:	2000      	movs	r0, #0
   4d1ee:	f7e4 fac3 	bl	31778 <find_cf_cfg_by_addr>
	if (!cfg) {
   4d1f2:	4605      	mov	r5, r0
   4d1f4:	b948      	cbnz	r0, 4d20a <cf_set+0x52>
		cfg = find_cf_cfg(NULL);
   4d1f6:	f7e4 fa3d 	bl	31674 <find_cf_cfg>
		if (!cfg) {
   4d1fa:	4605      	mov	r5, r0
   4d1fc:	b1d8      	cbz	r0, 4d236 <cf_set+0x7e>
		cfg->id = id;
   4d1fe:	2300      	movs	r3, #0
   4d200:	f800 3b01 	strb.w	r3, [r0], #1
		bt_addr_le_copy(&cfg->peer, &addr);
   4d204:	a902      	add	r1, sp, #8
   4d206:	f7ff fef6 	bl	4cff6 <bt_addr_le_copy>
	if (len_rd) {
   4d20a:	f1b8 0f00 	cmp.w	r8, #0
   4d20e:	d00e      	beq.n	4d22e <cf_set+0x76>
		len = read_cb(cb_arg, cfg->data, sizeof(cfg->data));
   4d210:	2201      	movs	r2, #1
   4d212:	f105 0108 	add.w	r1, r5, #8
   4d216:	4638      	mov	r0, r7
   4d218:	47b0      	blx	r6
		if (len < 0) {
   4d21a:	ea00 74e0 	and.w	r4, r0, r0, asr #31
   4d21e:	e7d4      	b.n	4d1ca <cf_set+0x12>
		unsigned long next_id = strtoul(next, NULL, 10);
   4d220:	220a      	movs	r2, #10
   4d222:	4621      	mov	r1, r4
   4d224:	f7fd fce0 	bl	4abe8 <strtoul>
		if (next_id >= CONFIG_BT_ID_MAX) {
   4d228:	2800      	cmp	r0, #0
   4d22a:	d0de      	beq.n	4d1ea <cf_set+0x32>
   4d22c:	e7cb      	b.n	4d1c6 <cf_set+0xe>
		clear_cf_cfg(cfg);
   4d22e:	4628      	mov	r0, r5
   4d230:	f7e4 fbd4 	bl	319dc <clear_cf_cfg>
   4d234:	e7c9      	b.n	4d1ca <cf_set+0x12>
			return -ENOMEM;
   4d236:	f06f 040b 	mvn.w	r4, #11
   4d23a:	e7c6      	b.n	4d1ca <cf_set+0x12>

0004d23c <gatt_find_type_encode>:
{
   4d23c:	b538      	push	{r3, r4, r5, lr}
	return net_buf_simple_add(&buf->b, len);
   4d23e:	f100 0508 	add.w	r5, r0, #8
   4d242:	2106      	movs	r1, #6
   4d244:	4628      	mov	r0, r5
   4d246:	4614      	mov	r4, r2
   4d248:	f001 fdb4 	bl	4edb4 <net_buf_simple_add>
	req->start_handle = sys_cpu_to_le16(params->start_handle);
   4d24c:	8923      	ldrh	r3, [r4, #8]
   4d24e:	8003      	strh	r3, [r0, #0]
	req->end_handle = sys_cpu_to_le16(params->end_handle);
   4d250:	89e3      	ldrh	r3, [r4, #14]
   4d252:	8043      	strh	r3, [r0, #2]
	if (params->type == BT_GATT_DISCOVER_PRIMARY) {
   4d254:	7c23      	ldrb	r3, [r4, #16]
		uuid_val = BT_UUID_GATT_PRIMARY_VAL;
   4d256:	2b00      	cmp	r3, #0
   4d258:	f642 0301 	movw	r3, #10241	; 0x2801
   4d25c:	bf08      	it	eq
   4d25e:	f44f 5320 	moveq.w	r3, #10240	; 0x2800
	req->type = sys_cpu_to_le16(uuid_val);
   4d262:	8083      	strh	r3, [r0, #4]
	switch (params->uuid->type) {
   4d264:	6821      	ldr	r1, [r4, #0]
   4d266:	780b      	ldrb	r3, [r1, #0]
   4d268:	b11b      	cbz	r3, 4d272 <gatt_find_type_encode+0x36>
   4d26a:	2b02      	cmp	r3, #2
   4d26c:	d006      	beq.n	4d27c <gatt_find_type_encode+0x40>
}
   4d26e:	2000      	movs	r0, #0
   4d270:	bd38      	pop	{r3, r4, r5, pc}
	net_buf_simple_add_le16(&buf->b, val);
   4d272:	8849      	ldrh	r1, [r1, #2]
   4d274:	4628      	mov	r0, r5
   4d276:	f001 fdb4 	bl	4ede2 <net_buf_simple_add_le16>
}
   4d27a:	e7f8      	b.n	4d26e <gatt_find_type_encode+0x32>
	return net_buf_simple_add_mem(&buf->b, mem, len);
   4d27c:	2210      	movs	r2, #16
   4d27e:	3101      	adds	r1, #1
   4d280:	4628      	mov	r0, r5
   4d282:	f001 fd9d 	bl	4edc0 <net_buf_simple_add_mem>
   4d286:	e7f2      	b.n	4d26e <gatt_find_type_encode+0x32>

0004d288 <sc_clear>:
{
   4d288:	b570      	push	{r4, r5, r6, lr}
	if (bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
   4d28a:	f100 0688 	add.w	r6, r0, #136	; 0x88
{
   4d28e:	4604      	mov	r4, r0
	if (bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
   4d290:	4631      	mov	r1, r6
   4d292:	7a00      	ldrb	r0, [r0, #8]
   4d294:	f7fe fa3a 	bl	4b70c <bt_addr_le_is_bonded>
   4d298:	4605      	mov	r5, r0
		err = bt_gatt_clear_sc(conn->id, &conn->le.dst);
   4d29a:	4631      	mov	r1, r6
   4d29c:	7a20      	ldrb	r0, [r4, #8]
	if (bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
   4d29e:	b11d      	cbz	r5, 4d2a8 <sc_clear+0x20>
}
   4d2a0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		err = bt_gatt_clear_sc(conn->id, &conn->le.dst);
   4d2a4:	f7e4 bc30 	b.w	31b08 <bt_gatt_clear_sc>
		cfg = find_sc_cfg(conn->id, &conn->le.dst);
   4d2a8:	f7e4 fa08 	bl	316bc <find_sc_cfg>
		if (cfg) {
   4d2ac:	b128      	cbz	r0, 4d2ba <sc_clear+0x32>
	memset(cfg, 0, sizeof(*cfg));
   4d2ae:	4629      	mov	r1, r5
   4d2b0:	220c      	movs	r2, #12
}
   4d2b2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	memset(cfg, 0, sizeof(*cfg));
   4d2b6:	f7fd bdeb 	b.w	4ae90 <memset>
}
   4d2ba:	bd70      	pop	{r4, r5, r6, pc}

0004d2bc <sc_ccc_cfg_write>:
	if (value == BT_GATT_CCC_INDICATE) {
   4d2bc:	2a02      	cmp	r2, #2
{
   4d2be:	b510      	push	{r4, lr}
	if (value == BT_GATT_CCC_INDICATE) {
   4d2c0:	d108      	bne.n	4d2d4 <sc_ccc_cfg_write+0x18>
		sc_save(conn->id, &conn->le.dst, 0, 0);
   4d2c2:	2300      	movs	r3, #0
   4d2c4:	f100 0188 	add.w	r1, r0, #136	; 0x88
   4d2c8:	461a      	mov	r2, r3
   4d2ca:	7a00      	ldrb	r0, [r0, #8]
   4d2cc:	f7e4 fafa 	bl	318c4 <sc_save>
}
   4d2d0:	2002      	movs	r0, #2
   4d2d2:	bd10      	pop	{r4, pc}
		sc_clear(conn);
   4d2d4:	f7ff ffd8 	bl	4d288 <sc_clear>
   4d2d8:	e7fa      	b.n	4d2d0 <sc_ccc_cfg_write+0x14>

0004d2da <read_appearance>:
{
   4d2da:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   4d2dc:	4615      	mov	r5, r2
   4d2de:	f8bd 6020 	ldrh.w	r6, [sp, #32]
   4d2e2:	461f      	mov	r7, r3
	uint16_t appearance = sys_cpu_to_le16(bt_get_appearance());
   4d2e4:	f7fe fa0f 	bl	4b706 <bt_get_appearance>
	if (offset > value_len) {
   4d2e8:	2e02      	cmp	r6, #2
	uint16_t appearance = sys_cpu_to_le16(bt_get_appearance());
   4d2ea:	f8ad 0006 	strh.w	r0, [sp, #6]
	if (offset > value_len) {
   4d2ee:	d80e      	bhi.n	4d30e <read_appearance+0x34>
	len = MIN(buf_len, value_len - offset);
   4d2f0:	f1c6 0402 	rsb	r4, r6, #2
   4d2f4:	42bc      	cmp	r4, r7
   4d2f6:	bfa8      	it	ge
   4d2f8:	463c      	movge	r4, r7
	memcpy(buf, (uint8_t *)value + offset, len);
   4d2fa:	f10d 0306 	add.w	r3, sp, #6
   4d2fe:	4622      	mov	r2, r4
   4d300:	1999      	adds	r1, r3, r6
   4d302:	4628      	mov	r0, r5
   4d304:	f7fd fdb9 	bl	4ae7a <memcpy>
}
   4d308:	4620      	mov	r0, r4
   4d30a:	b003      	add	sp, #12
   4d30c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   4d30e:	f06f 0406 	mvn.w	r4, #6
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &appearance,
   4d312:	e7f9      	b.n	4d308 <read_appearance+0x2e>

0004d314 <read_name>:
{
   4d314:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4d318:	4698      	mov	r8, r3
   4d31a:	f8bd 6018 	ldrh.w	r6, [sp, #24]
   4d31e:	4615      	mov	r5, r2
	const char *name = bt_get_name();
   4d320:	f7e1 fa46 	bl	2e7b0 <bt_get_name>
   4d324:	4607      	mov	r7, r0
				 strlen(name));
   4d326:	f7fd fd71 	bl	4ae0c <strlen>
	if (offset > value_len) {
   4d32a:	b283      	uxth	r3, r0
   4d32c:	42b3      	cmp	r3, r6
   4d32e:	d30c      	bcc.n	4d34a <read_name+0x36>
	len = MIN(buf_len, value_len - offset);
   4d330:	1b9c      	subs	r4, r3, r6
   4d332:	4544      	cmp	r4, r8
   4d334:	bfa8      	it	ge
   4d336:	4644      	movge	r4, r8
   4d338:	b2a4      	uxth	r4, r4
	memcpy(buf, (uint8_t *)value + offset, len);
   4d33a:	4622      	mov	r2, r4
   4d33c:	19b9      	adds	r1, r7, r6
   4d33e:	4628      	mov	r0, r5
   4d340:	f7fd fd9b 	bl	4ae7a <memcpy>
}
   4d344:	4620      	mov	r0, r4
   4d346:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   4d34a:	f06f 0406 	mvn.w	r4, #6
	return bt_gatt_attr_read(conn, attr, buf, len, offset, name,
   4d34e:	e7f9      	b.n	4d344 <read_name+0x30>

0004d350 <cf_read>:
{
   4d350:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   4d352:	461f      	mov	r7, r3
	uint8_t data[1] = {};
   4d354:	2300      	movs	r3, #0
{
   4d356:	f8bd 6020 	ldrh.w	r6, [sp, #32]
	uint8_t data[1] = {};
   4d35a:	f88d 3004 	strb.w	r3, [sp, #4]
{
   4d35e:	4615      	mov	r5, r2
	cfg = find_cf_cfg(conn);
   4d360:	f7e4 f988 	bl	31674 <find_cf_cfg>
	if (cfg) {
   4d364:	b128      	cbz	r0, 4d372 <cf_read+0x22>
		memcpy(data, cfg->data, sizeof(data));
   4d366:	f100 0108 	add.w	r1, r0, #8
   4d36a:	2201      	movs	r2, #1
   4d36c:	a801      	add	r0, sp, #4
   4d36e:	f7fd fd84 	bl	4ae7a <memcpy>
	if (offset > value_len) {
   4d372:	2e01      	cmp	r6, #1
   4d374:	d80d      	bhi.n	4d392 <cf_read+0x42>
	len = MIN(buf_len, value_len - offset);
   4d376:	f1c6 0401 	rsb	r4, r6, #1
   4d37a:	42bc      	cmp	r4, r7
   4d37c:	bfa8      	it	ge
   4d37e:	463c      	movge	r4, r7
	memcpy(buf, (uint8_t *)value + offset, len);
   4d380:	ab01      	add	r3, sp, #4
   4d382:	4622      	mov	r2, r4
   4d384:	1999      	adds	r1, r3, r6
   4d386:	4628      	mov	r0, r5
   4d388:	f7fd fd77 	bl	4ae7a <memcpy>
}
   4d38c:	4620      	mov	r0, r4
   4d38e:	b003      	add	sp, #12
   4d390:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   4d392:	f06f 0406 	mvn.w	r4, #6
	return bt_gatt_attr_read(conn, attr, buf, len, offset, data,
   4d396:	e7f9      	b.n	4d38c <cf_read+0x3c>

0004d398 <bt_gatt_attr_read_service>:
{
   4d398:	b513      	push	{r0, r1, r4, lr}
	struct bt_uuid *uuid = attr->user_data;
   4d39a:	68c9      	ldr	r1, [r1, #12]
{
   4d39c:	4610      	mov	r0, r2
	if (uuid->type == BT_UUID_TYPE_16) {
   4d39e:	780a      	ldrb	r2, [r1, #0]
{
   4d3a0:	461c      	mov	r4, r3
   4d3a2:	f8bd 3010 	ldrh.w	r3, [sp, #16]
	if (uuid->type == BT_UUID_TYPE_16) {
   4d3a6:	b992      	cbnz	r2, 4d3ce <bt_gatt_attr_read_service+0x36>
		uint16_t uuid16 = sys_cpu_to_le16(BT_UUID_16(uuid)->val);
   4d3a8:	884a      	ldrh	r2, [r1, #2]
   4d3aa:	f8ad 2006 	strh.w	r2, [sp, #6]
	if (offset > value_len) {
   4d3ae:	2b02      	cmp	r3, #2
   4d3b0:	d818      	bhi.n	4d3e4 <bt_gatt_attr_read_service+0x4c>
	len = MIN(buf_len, value_len - offset);
   4d3b2:	f1c3 0202 	rsb	r2, r3, #2
   4d3b6:	4294      	cmp	r4, r2
   4d3b8:	bfa8      	it	ge
   4d3ba:	4614      	movge	r4, r2
	memcpy(buf, (uint8_t *)value + offset, len);
   4d3bc:	4622      	mov	r2, r4
   4d3be:	f10d 0106 	add.w	r1, sp, #6
   4d3c2:	4419      	add	r1, r3
   4d3c4:	f7fd fd59 	bl	4ae7a <memcpy>
}
   4d3c8:	4620      	mov	r0, r4
   4d3ca:	b002      	add	sp, #8
   4d3cc:	bd10      	pop	{r4, pc}
	if (offset > value_len) {
   4d3ce:	2b10      	cmp	r3, #16
				 BT_UUID_128(uuid)->val, 16);
   4d3d0:	f101 0101 	add.w	r1, r1, #1
	if (offset > value_len) {
   4d3d4:	d806      	bhi.n	4d3e4 <bt_gatt_attr_read_service+0x4c>
	len = MIN(buf_len, value_len - offset);
   4d3d6:	f1c3 0210 	rsb	r2, r3, #16
   4d3da:	4294      	cmp	r4, r2
   4d3dc:	bfa8      	it	ge
   4d3de:	4614      	movge	r4, r2
	memcpy(buf, (uint8_t *)value + offset, len);
   4d3e0:	4622      	mov	r2, r4
   4d3e2:	e7ee      	b.n	4d3c2 <bt_gatt_attr_read_service+0x2a>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   4d3e4:	f06f 0406 	mvn.w	r4, #6
   4d3e8:	e7ee      	b.n	4d3c8 <bt_gatt_attr_read_service+0x30>

0004d3ea <bt_gatt_attr_read_ccc>:
{
   4d3ea:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	cfg = find_ccc_cfg(conn, ccc);
   4d3ec:	68c9      	ldr	r1, [r1, #12]
{
   4d3ee:	f8bd 6020 	ldrh.w	r6, [sp, #32]
   4d3f2:	4615      	mov	r5, r2
   4d3f4:	461f      	mov	r7, r3
	cfg = find_ccc_cfg(conn, ccc);
   4d3f6:	f7e4 f97d 	bl	316f4 <find_ccc_cfg>
	if (cfg) {
   4d3fa:	b100      	cbz	r0, 4d3fe <bt_gatt_attr_read_ccc+0x14>
		value = sys_cpu_to_le16(cfg->value);
   4d3fc:	8900      	ldrh	r0, [r0, #8]
   4d3fe:	f8ad 0006 	strh.w	r0, [sp, #6]
	if (offset > value_len) {
   4d402:	2e02      	cmp	r6, #2
   4d404:	d80e      	bhi.n	4d424 <bt_gatt_attr_read_ccc+0x3a>
	len = MIN(buf_len, value_len - offset);
   4d406:	f1c6 0402 	rsb	r4, r6, #2
   4d40a:	42bc      	cmp	r4, r7
   4d40c:	bfa8      	it	ge
   4d40e:	463c      	movge	r4, r7
	memcpy(buf, (uint8_t *)value + offset, len);
   4d410:	f10d 0306 	add.w	r3, sp, #6
   4d414:	4622      	mov	r2, r4
   4d416:	1999      	adds	r1, r3, r6
   4d418:	4628      	mov	r0, r5
   4d41a:	f7fd fd2e 	bl	4ae7a <memcpy>
}
   4d41e:	4620      	mov	r0, r4
   4d420:	b003      	add	sp, #12
   4d422:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   4d424:	f06f 0406 	mvn.w	r4, #6
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &value,
   4d428:	e7f9      	b.n	4d41e <bt_gatt_attr_read_ccc+0x34>

0004d42a <gatt_req_send.constprop.0>:
static int gatt_req_send(struct bt_conn *conn, bt_att_func_t func, void *params,
   4d42a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   4d42e:	4606      	mov	r6, r0
   4d430:	460d      	mov	r5, r1
	req = bt_att_req_alloc(BT_ATT_TIMEOUT);
   4d432:	f44f 2070 	mov.w	r0, #983040	; 0xf0000
   4d436:	2100      	movs	r1, #0
static int gatt_req_send(struct bt_conn *conn, bt_att_func_t func, void *params,
   4d438:	f89d a020 	ldrb.w	sl, [sp, #32]
   4d43c:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
   4d440:	4690      	mov	r8, r2
   4d442:	461f      	mov	r7, r3
	req = bt_att_req_alloc(BT_ATT_TIMEOUT);
   4d444:	f7e3 ffd2 	bl	313ec <bt_att_req_alloc>
	if (!req) {
   4d448:	4604      	mov	r4, r0
   4d44a:	b188      	cbz	r0, 4d470 <gatt_req_send.constprop.0+0x46>
	req->func = func;
   4d44c:	6045      	str	r5, [r0, #4]
	req->att_op = op;
   4d44e:	f880 a011 	strb.w	sl, [r0, #17]
	req->len = len;
   4d452:	f8c0 9014 	str.w	r9, [r0, #20]
	req->encode = encode;
   4d456:	60c7      	str	r7, [r0, #12]
	req->user_data = params;
   4d458:	f8c0 8018 	str.w	r8, [r0, #24]
	buf = bt_att_create_pdu(conn, op, len);
   4d45c:	464a      	mov	r2, r9
   4d45e:	4651      	mov	r1, sl
   4d460:	4630      	mov	r0, r6
   4d462:	f7ff fb7f 	bl	4cb64 <bt_att_create_pdu>
   4d466:	4605      	mov	r5, r0
	if (!buf) {
   4d468:	b938      	cbnz	r0, 4d47a <gatt_req_send.constprop.0+0x50>
		bt_att_req_free(req);
   4d46a:	4620      	mov	r0, r4
   4d46c:	f7e3 ffe0 	bl	31430 <bt_att_req_free>
		return -ENOMEM;
   4d470:	f06f 050b 	mvn.w	r5, #11
}
   4d474:	4628      	mov	r0, r5
   4d476:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	bt_att_set_tx_meta_data(buf, NULL, NULL, chan_opt);
   4d47a:	2200      	movs	r2, #0
   4d47c:	4611      	mov	r1, r2
   4d47e:	2301      	movs	r3, #1
   4d480:	f7ff fcfa 	bl	4ce78 <bt_att_set_tx_meta_data>
	req->buf = buf;
   4d484:	60a5      	str	r5, [r4, #8]
	err = encode(buf, len, params);
   4d486:	4628      	mov	r0, r5
   4d488:	4642      	mov	r2, r8
   4d48a:	4649      	mov	r1, r9
   4d48c:	47b8      	blx	r7
	if (err) {
   4d48e:	4605      	mov	r5, r0
   4d490:	b118      	cbz	r0, 4d49a <gatt_req_send.constprop.0+0x70>
		bt_att_req_free(req);
   4d492:	4620      	mov	r0, r4
   4d494:	f7e3 ffcc 	bl	31430 <bt_att_req_free>
   4d498:	e7ec      	b.n	4d474 <gatt_req_send.constprop.0+0x4a>
	err = bt_att_req_send(conn, req);
   4d49a:	4621      	mov	r1, r4
   4d49c:	4630      	mov	r0, r6
   4d49e:	f7ff fc95 	bl	4cdcc <bt_att_req_send>
	if (err) {
   4d4a2:	4605      	mov	r5, r0
   4d4a4:	2800      	cmp	r0, #0
   4d4a6:	d0e5      	beq.n	4d474 <gatt_req_send.constprop.0+0x4a>
   4d4a8:	e7f3      	b.n	4d492 <gatt_req_send.constprop.0+0x68>

0004d4aa <gatt_write_ccc_buf>:
{
   4d4aa:	b538      	push	{r3, r4, r5, lr}
	return net_buf_simple_add(&buf->b, len);
   4d4ac:	f100 0508 	add.w	r5, r0, #8
   4d4b0:	2102      	movs	r1, #2
   4d4b2:	4628      	mov	r0, r5
   4d4b4:	4614      	mov	r4, r2
   4d4b6:	f001 fc7d 	bl	4edb4 <net_buf_simple_add>
	write_req->handle = sys_cpu_to_le16(params->ccc_handle);
   4d4ba:	89e3      	ldrh	r3, [r4, #14]
   4d4bc:	8003      	strh	r3, [r0, #0]
	net_buf_simple_add_le16(&buf->b, val);
   4d4be:	8b21      	ldrh	r1, [r4, #24]
   4d4c0:	4628      	mov	r0, r5
   4d4c2:	f001 fc8e 	bl	4ede2 <net_buf_simple_add_le16>
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
   4d4c6:	2104      	movs	r1, #4
   4d4c8:	f104 001c 	add.w	r0, r4, #28
   4d4cc:	f7ff fd84 	bl	4cfd8 <atomic_or>
}
   4d4d0:	2000      	movs	r0, #0
   4d4d2:	bd38      	pop	{r3, r4, r5, pc}

0004d4d4 <sc_restore_rsp>:
{
   4d4d4:	b538      	push	{r3, r4, r5, lr}
   4d4d6:	4604      	mov	r4, r0
   4d4d8:	4615      	mov	r5, r2
	if (bt_att_fixed_chan_only(conn)) {
   4d4da:	f7ff fca6 	bl	4ce2a <bt_att_fixed_chan_only>
   4d4de:	b150      	cbz	r0, 4d4f6 <sc_restore_rsp+0x22>
		cfg = find_cf_cfg(conn);
   4d4e0:	4620      	mov	r0, r4
   4d4e2:	f7e4 f8c7 	bl	31674 <find_cf_cfg>
		if (cfg && CF_ROBUST_CACHING(cfg)) {
   4d4e6:	b130      	cbz	r0, 4d4f6 <sc_restore_rsp+0x22>
   4d4e8:	7a03      	ldrb	r3, [r0, #8]
   4d4ea:	07db      	lsls	r3, r3, #31
   4d4ec:	d503      	bpl.n	4d4f6 <sc_restore_rsp+0x22>
   4d4ee:	2101      	movs	r1, #1
   4d4f0:	300c      	adds	r0, #12
   4d4f2:	f7ff fd71 	bl	4cfd8 <atomic_or>
	if (!err && IS_ENABLED(CONFIG_BT_GATT_SERVICE_CHANGED)) {
   4d4f6:	b985      	cbnz	r5, 4d51a <sc_restore_rsp+0x46>
		struct gatt_sc_cfg *sc_cfg = find_sc_cfg(conn->id, &conn->le.dst);
   4d4f8:	7a20      	ldrb	r0, [r4, #8]
   4d4fa:	f104 0188 	add.w	r1, r4, #136	; 0x88
   4d4fe:	f7e4 f8dd 	bl	316bc <find_sc_cfg>
		if (sc_cfg) {
   4d502:	4604      	mov	r4, r0
   4d504:	b148      	cbz	r0, 4d51a <sc_restore_rsp+0x46>
	memset(&cfg->data, 0, sizeof(cfg->data));
   4d506:	4629      	mov	r1, r5
   4d508:	2204      	movs	r2, #4
   4d50a:	3008      	adds	r0, #8
   4d50c:	f7fd fcc0 	bl	4ae90 <memset>
		sc_store(cfg);
   4d510:	4620      	mov	r0, r4
}
   4d512:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		sc_store(cfg);
   4d516:	f7e4 b9b5 	b.w	31884 <sc_store>
}
   4d51a:	bd38      	pop	{r3, r4, r5, pc}

0004d51c <bt_gatt_attr_read>:
{
   4d51c:	b510      	push	{r4, lr}
   4d51e:	f8bd 1008 	ldrh.w	r1, [sp, #8]
   4d522:	f8bd 4010 	ldrh.w	r4, [sp, #16]
	if (offset > value_len) {
   4d526:	42a1      	cmp	r1, r4
{
   4d528:	4610      	mov	r0, r2
	if (offset > value_len) {
   4d52a:	d80b      	bhi.n	4d544 <bt_gatt_attr_read+0x28>
	len = MIN(buf_len, value_len - offset);
   4d52c:	1a64      	subs	r4, r4, r1
   4d52e:	429c      	cmp	r4, r3
   4d530:	bfa8      	it	ge
   4d532:	461c      	movge	r4, r3
	memcpy(buf, (uint8_t *)value + offset, len);
   4d534:	9b03      	ldr	r3, [sp, #12]
   4d536:	b2a4      	uxth	r4, r4
   4d538:	4622      	mov	r2, r4
   4d53a:	4419      	add	r1, r3
   4d53c:	f7fd fc9d 	bl	4ae7a <memcpy>
}
   4d540:	4620      	mov	r0, r4
   4d542:	bd10      	pop	{r4, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   4d544:	f06f 0406 	mvn.w	r4, #6
   4d548:	e7fa      	b.n	4d540 <bt_gatt_attr_read+0x24>

0004d54a <bt_gatt_attr_value_handle>:
{
   4d54a:	b513      	push	{r0, r1, r4, lr}
	if (attr != NULL && bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CHRC) == 0) {
   4d54c:	4604      	mov	r4, r0
   4d54e:	b910      	cbnz	r0, 4d556 <bt_gatt_attr_value_handle+0xc>
	uint16_t handle = 0;
   4d550:	2000      	movs	r0, #0
}
   4d552:	b002      	add	sp, #8
   4d554:	bd10      	pop	{r4, pc}
	if (attr != NULL && bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CHRC) == 0) {
   4d556:	2300      	movs	r3, #0
   4d558:	f88d 3004 	strb.w	r3, [sp, #4]
   4d55c:	6800      	ldr	r0, [r0, #0]
   4d55e:	f642 0303 	movw	r3, #10243	; 0x2803
   4d562:	a901      	add	r1, sp, #4
   4d564:	f8ad 3006 	strh.w	r3, [sp, #6]
   4d568:	f7fd fd48 	bl	4affc <bt_uuid_cmp>
   4d56c:	2800      	cmp	r0, #0
   4d56e:	d1ef      	bne.n	4d550 <bt_gatt_attr_value_handle+0x6>
		handle = chrc->value_handle;
   4d570:	68e3      	ldr	r3, [r4, #12]
   4d572:	8898      	ldrh	r0, [r3, #4]
		if (handle == 0) {
   4d574:	2800      	cmp	r0, #0
   4d576:	d1ec      	bne.n	4d552 <bt_gatt_attr_value_handle+0x8>
			handle = bt_gatt_attr_get_handle(attr) + 1U;
   4d578:	4620      	mov	r0, r4
   4d57a:	f7e4 fc99 	bl	31eb0 <bt_gatt_attr_get_handle>
   4d57e:	3001      	adds	r0, #1
   4d580:	b280      	uxth	r0, r0
	return handle;
   4d582:	e7e6      	b.n	4d552 <bt_gatt_attr_value_handle+0x8>

0004d584 <bt_gatt_attr_read_chrc>:
{
   4d584:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct bt_gatt_chrc *chrc = attr->user_data;
   4d586:	68cc      	ldr	r4, [r1, #12]
{
   4d588:	b087      	sub	sp, #28
   4d58a:	4608      	mov	r0, r1
   4d58c:	461f      	mov	r7, r3
	pdu.properties = chrc->properties;
   4d58e:	79a3      	ldrb	r3, [r4, #6]
   4d590:	f88d 3004 	strb.w	r3, [sp, #4]
{
   4d594:	f8bd 6030 	ldrh.w	r6, [sp, #48]	; 0x30
   4d598:	4615      	mov	r5, r2
	pdu.value_handle = sys_cpu_to_le16(bt_gatt_attr_value_handle(attr));
   4d59a:	f7ff ffd6 	bl	4d54a <bt_gatt_attr_value_handle>
   4d59e:	f8ad 0005 	strh.w	r0, [sp, #5]
	if (chrc->uuid->type == BT_UUID_TYPE_16) {
   4d5a2:	6821      	ldr	r1, [r4, #0]
   4d5a4:	780b      	ldrb	r3, [r1, #0]
   4d5a6:	b99b      	cbnz	r3, 4d5d0 <bt_gatt_attr_read_chrc+0x4c>
		pdu.uuid16 = sys_cpu_to_le16(BT_UUID_16(chrc->uuid)->val);
   4d5a8:	884b      	ldrh	r3, [r1, #2]
   4d5aa:	f8ad 3007 	strh.w	r3, [sp, #7]
		value_len += 2U;
   4d5ae:	2405      	movs	r4, #5
	if (offset > value_len) {
   4d5b0:	42b4      	cmp	r4, r6
   4d5b2:	d315      	bcc.n	4d5e0 <bt_gatt_attr_read_chrc+0x5c>
	len = MIN(buf_len, value_len - offset);
   4d5b4:	1ba4      	subs	r4, r4, r6
   4d5b6:	42bc      	cmp	r4, r7
   4d5b8:	bfa8      	it	ge
   4d5ba:	463c      	movge	r4, r7
   4d5bc:	b2a4      	uxth	r4, r4
	memcpy(buf, (uint8_t *)value + offset, len);
   4d5be:	ab01      	add	r3, sp, #4
   4d5c0:	4622      	mov	r2, r4
   4d5c2:	1999      	adds	r1, r3, r6
   4d5c4:	4628      	mov	r0, r5
   4d5c6:	f7fd fc58 	bl	4ae7a <memcpy>
}
   4d5ca:	4620      	mov	r0, r4
   4d5cc:	b007      	add	sp, #28
   4d5ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
		memcpy(pdu.uuid, BT_UUID_128(chrc->uuid)->val, 16);
   4d5d0:	2210      	movs	r2, #16
   4d5d2:	3101      	adds	r1, #1
   4d5d4:	f10d 0007 	add.w	r0, sp, #7
   4d5d8:	f7fd fc4f 	bl	4ae7a <memcpy>
		value_len += 16U;
   4d5dc:	2413      	movs	r4, #19
   4d5de:	e7e7      	b.n	4d5b0 <bt_gatt_attr_read_chrc+0x2c>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   4d5e0:	f06f 0406 	mvn.w	r4, #6
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &pdu, value_len);
   4d5e4:	e7f1      	b.n	4d5ca <bt_gatt_attr_read_chrc+0x46>

0004d5e6 <bt_gatt_foreach_attr>:
{
   4d5e6:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	bt_gatt_foreach_attr_type(start_handle, end_handle, NULL, NULL, 0, func,
   4d5e8:	e9cd 2301 	strd	r2, r3, [sp, #4]
   4d5ec:	2300      	movs	r3, #0
   4d5ee:	9300      	str	r3, [sp, #0]
   4d5f0:	461a      	mov	r2, r3
   4d5f2:	f7e4 fc8d 	bl	31f10 <bt_gatt_foreach_attr_type>
}
   4d5f6:	b005      	add	sp, #20
   4d5f8:	f85d fb04 	ldr.w	pc, [sp], #4

0004d5fc <bt_gatt_check_perm>:
{
   4d5fc:	b538      	push	{r3, r4, r5, lr}
	if ((mask & BT_GATT_PERM_READ) &&
   4d5fe:	07d4      	lsls	r4, r2, #31
	    (!(attr->perm & BT_GATT_PERM_READ_MASK) || !attr->read)) {
   4d600:	8a4b      	ldrh	r3, [r1, #18]
{
   4d602:	4605      	mov	r5, r0
	if ((mask & BT_GATT_PERM_READ) &&
   4d604:	d504      	bpl.n	4d610 <bt_gatt_check_perm+0x14>
   4d606:	f013 0f95 	tst.w	r3, #149	; 0x95
   4d60a:	d027      	beq.n	4d65c <bt_gatt_check_perm+0x60>
	    (!(attr->perm & BT_GATT_PERM_READ_MASK) || !attr->read)) {
   4d60c:	6848      	ldr	r0, [r1, #4]
   4d60e:	b328      	cbz	r0, 4d65c <bt_gatt_check_perm+0x60>
	if ((mask & BT_GATT_PERM_WRITE) &&
   4d610:	0790      	lsls	r0, r2, #30
   4d612:	d504      	bpl.n	4d61e <bt_gatt_check_perm+0x22>
   4d614:	f413 7f95 	tst.w	r3, #298	; 0x12a
   4d618:	d022      	beq.n	4d660 <bt_gatt_check_perm+0x64>
	    (!(attr->perm & BT_GATT_PERM_WRITE_MASK) || !attr->write)) {
   4d61a:	6889      	ldr	r1, [r1, #8]
   4d61c:	b301      	cbz	r1, 4d660 <bt_gatt_check_perm+0x64>
	mask &= attr->perm;
   4d61e:	ea02 0403 	and.w	r4, r2, r3
	if (mask & BT_GATT_PERM_LESC_MASK) {
   4d622:	f414 7fc0 	tst.w	r4, #384	; 0x180
   4d626:	d007      	beq.n	4d638 <bt_gatt_check_perm+0x3c>
		if (!IS_ENABLED(CONFIG_BT_SMP) || !conn->le.keys ||
   4d628:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
   4d62c:	b90b      	cbnz	r3, 4d632 <bt_gatt_check_perm+0x36>
			return BT_ATT_ERR_AUTHENTICATION;
   4d62e:	2005      	movs	r0, #5
}
   4d630:	bd38      	pop	{r3, r4, r5, pc}
		if (!IS_ENABLED(CONFIG_BT_SMP) || !conn->le.keys ||
   4d632:	7b5b      	ldrb	r3, [r3, #13]
   4d634:	06db      	lsls	r3, r3, #27
   4d636:	d5fa      	bpl.n	4d62e <bt_gatt_check_perm+0x32>
	if (mask & BT_GATT_PERM_AUTHEN_MASK) {
   4d638:	f014 0f30 	tst.w	r4, #48	; 0x30
   4d63c:	d108      	bne.n	4d650 <bt_gatt_check_perm+0x54>
	if ((mask & BT_GATT_PERM_ENCRYPT_MASK)) {
   4d63e:	f014 000c 	ands.w	r0, r4, #12
   4d642:	d0f5      	beq.n	4d630 <bt_gatt_check_perm+0x34>
		if (!conn->encrypt) {
   4d644:	7aeb      	ldrb	r3, [r5, #11]
			return BT_ATT_ERR_INSUFFICIENT_ENCRYPTION;
   4d646:	2b00      	cmp	r3, #0
   4d648:	bf14      	ite	ne
   4d64a:	2000      	movne	r0, #0
   4d64c:	200f      	moveq	r0, #15
   4d64e:	e7ef      	b.n	4d630 <bt_gatt_check_perm+0x34>
		if (bt_conn_get_security(conn) < BT_SECURITY_L3) {
   4d650:	4628      	mov	r0, r5
   4d652:	f7fe fc67 	bl	4bf24 <bt_conn_get_security>
   4d656:	2802      	cmp	r0, #2
   4d658:	d8f1      	bhi.n	4d63e <bt_gatt_check_perm+0x42>
   4d65a:	e7e8      	b.n	4d62e <bt_gatt_check_perm+0x32>
		return BT_ATT_ERR_READ_NOT_PERMITTED;
   4d65c:	2002      	movs	r0, #2
   4d65e:	e7e7      	b.n	4d630 <bt_gatt_check_perm+0x34>
		return BT_ATT_ERR_WRITE_NOT_PERMITTED;
   4d660:	2003      	movs	r0, #3
   4d662:	e7e5      	b.n	4d630 <bt_gatt_check_perm+0x34>

0004d664 <bt_gatt_is_subscribed>:
{
   4d664:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	if (conn->state != BT_CONN_CONNECTED) {
   4d668:	7b43      	ldrb	r3, [r0, #13]
   4d66a:	2b07      	cmp	r3, #7
{
   4d66c:	4606      	mov	r6, r0
   4d66e:	460c      	mov	r4, r1
   4d670:	4617      	mov	r7, r2
	if (conn->state != BT_CONN_CONNECTED) {
   4d672:	d110      	bne.n	4d696 <bt_gatt_is_subscribed+0x32>
	if (!bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CHRC)) {
   4d674:	2300      	movs	r3, #0
   4d676:	f88d 300c 	strb.w	r3, [sp, #12]
   4d67a:	6820      	ldr	r0, [r4, #0]
   4d67c:	f642 0303 	movw	r3, #10243	; 0x2803
   4d680:	a903      	add	r1, sp, #12
   4d682:	f8ad 300e 	strh.w	r3, [sp, #14]
   4d686:	f7fd fcb9 	bl	4affc <bt_uuid_cmp>
   4d68a:	b960      	cbnz	r0, 4d6a6 <bt_gatt_is_subscribed+0x42>
		if (!(chrc->properties &
   4d68c:	68e3      	ldr	r3, [r4, #12]
   4d68e:	799b      	ldrb	r3, [r3, #6]
   4d690:	f013 0f30 	tst.w	r3, #48	; 0x30
   4d694:	d103      	bne.n	4d69e <bt_gatt_is_subscribed+0x3a>
		return false;
   4d696:	2000      	movs	r0, #0
}
   4d698:	b004      	add	sp, #16
   4d69a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		attr = bt_gatt_attr_next(attr);
   4d69e:	4620      	mov	r0, r4
   4d6a0:	f7e4 fdb4 	bl	3220c <bt_gatt_attr_next>
   4d6a4:	4604      	mov	r4, r0
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CCC) != 0) {
   4d6a6:	2300      	movs	r3, #0
   4d6a8:	6820      	ldr	r0, [r4, #0]
   4d6aa:	f88d 300c 	strb.w	r3, [sp, #12]
   4d6ae:	a903      	add	r1, sp, #12
   4d6b0:	f642 1302 	movw	r3, #10498	; 0x2902
   4d6b4:	f8ad 300e 	strh.w	r3, [sp, #14]
   4d6b8:	f7fd fca0 	bl	4affc <bt_uuid_cmp>
   4d6bc:	b118      	cbz	r0, 4d6c6 <bt_gatt_is_subscribed+0x62>
		attr = bt_gatt_attr_next(attr);
   4d6be:	4620      	mov	r0, r4
   4d6c0:	f7e4 fda4 	bl	3220c <bt_gatt_attr_next>
   4d6c4:	4604      	mov	r4, r0
	while (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CCC) &&
   4d6c6:	2500      	movs	r5, #0
   4d6c8:	f642 1802 	movw	r8, #10498	; 0x2902
   4d6cc:	6820      	ldr	r0, [r4, #0]
   4d6ce:	f88d 5000 	strb.w	r5, [sp]
   4d6d2:	4669      	mov	r1, sp
   4d6d4:	f8ad 8002 	strh.w	r8, [sp, #2]
   4d6d8:	f7fd fc90 	bl	4affc <bt_uuid_cmp>
	       bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY) &&
   4d6dc:	b9f0      	cbnz	r0, 4d71c <bt_gatt_is_subscribed+0xb8>
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CCC) != 0) {
   4d6de:	2300      	movs	r3, #0
   4d6e0:	6820      	ldr	r0, [r4, #0]
   4d6e2:	f88d 300c 	strb.w	r3, [sp, #12]
   4d6e6:	a903      	add	r1, sp, #12
   4d6e8:	f642 1302 	movw	r3, #10498	; 0x2902
   4d6ec:	f8ad 300e 	strh.w	r3, [sp, #14]
   4d6f0:	f7fd fc84 	bl	4affc <bt_uuid_cmp>
   4d6f4:	2800      	cmp	r0, #0
   4d6f6:	d1ce      	bne.n	4d696 <bt_gatt_is_subscribed+0x32>
	ccc = attr->user_data;
   4d6f8:	68e5      	ldr	r5, [r4, #12]
	for (size_t i = 0; i < BT_GATT_CCC_MAX; i++) {
   4d6fa:	1c6c      	adds	r4, r5, #1
   4d6fc:	353d      	adds	r5, #61	; 0x3d
		if (bt_conn_is_peer_addr_le(conn, cfg->id, &cfg->peer) &&
   4d6fe:	f814 1c01 	ldrb.w	r1, [r4, #-1]
   4d702:	4622      	mov	r2, r4
   4d704:	4630      	mov	r0, r6
   4d706:	f7fe fc0f 	bl	4bf28 <bt_conn_is_peer_addr_le>
   4d70a:	b118      	cbz	r0, 4d714 <bt_gatt_is_subscribed+0xb0>
   4d70c:	f8b4 3007 	ldrh.w	r3, [r4, #7]
   4d710:	421f      	tst	r7, r3
   4d712:	d1c1      	bne.n	4d698 <bt_gatt_is_subscribed+0x34>
	for (size_t i = 0; i < BT_GATT_CCC_MAX; i++) {
   4d714:	340a      	adds	r4, #10
   4d716:	42ac      	cmp	r4, r5
   4d718:	d1f1      	bne.n	4d6fe <bt_gatt_is_subscribed+0x9a>
   4d71a:	e7bc      	b.n	4d696 <bt_gatt_is_subscribed+0x32>
	       bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CHRC) &&
   4d71c:	6820      	ldr	r0, [r4, #0]
   4d71e:	f88d 5004 	strb.w	r5, [sp, #4]
   4d722:	f642 0303 	movw	r3, #10243	; 0x2803
   4d726:	a901      	add	r1, sp, #4
   4d728:	f8ad 3006 	strh.w	r3, [sp, #6]
   4d72c:	f7fd fc66 	bl	4affc <bt_uuid_cmp>
	while (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CCC) &&
   4d730:	2800      	cmp	r0, #0
   4d732:	d0d4      	beq.n	4d6de <bt_gatt_is_subscribed+0x7a>
	       bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY) &&
   4d734:	6820      	ldr	r0, [r4, #0]
   4d736:	f88d 5008 	strb.w	r5, [sp, #8]
   4d73a:	f44f 5320 	mov.w	r3, #10240	; 0x2800
   4d73e:	a902      	add	r1, sp, #8
   4d740:	f8ad 300a 	strh.w	r3, [sp, #10]
   4d744:	f7fd fc5a 	bl	4affc <bt_uuid_cmp>
	       bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CHRC) &&
   4d748:	2800      	cmp	r0, #0
   4d74a:	d0c8      	beq.n	4d6de <bt_gatt_is_subscribed+0x7a>
	       bt_uuid_cmp(attr->uuid, BT_UUID_GATT_SECONDARY)) {
   4d74c:	6820      	ldr	r0, [r4, #0]
   4d74e:	f88d 500c 	strb.w	r5, [sp, #12]
   4d752:	f642 0301 	movw	r3, #10241	; 0x2801
   4d756:	a903      	add	r1, sp, #12
   4d758:	f8ad 300e 	strh.w	r3, [sp, #14]
   4d75c:	f7fd fc4e 	bl	4affc <bt_uuid_cmp>
	       bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY) &&
   4d760:	2800      	cmp	r0, #0
   4d762:	d0bc      	beq.n	4d6de <bt_gatt_is_subscribed+0x7a>
		attr = bt_gatt_attr_next(attr);
   4d764:	4620      	mov	r0, r4
   4d766:	f7e4 fd51 	bl	3220c <bt_gatt_attr_next>
		if (!attr) {
   4d76a:	4604      	mov	r4, r0
   4d76c:	2800      	cmp	r0, #0
   4d76e:	d1ad      	bne.n	4d6cc <bt_gatt_is_subscribed+0x68>
   4d770:	e791      	b.n	4d696 <bt_gatt_is_subscribed+0x32>

0004d772 <gatt_notify>:
{
   4d772:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   4d776:	4614      	mov	r4, r2
   4d778:	4688      	mov	r8, r1
	if (bt_gatt_check_perm(conn, params->attr, BT_GATT_PERM_READ_ENCRYPT_MASK)) {
   4d77a:	2294      	movs	r2, #148	; 0x94
   4d77c:	6861      	ldr	r1, [r4, #4]
{
   4d77e:	4606      	mov	r6, r0
	if (bt_gatt_check_perm(conn, params->attr, BT_GATT_PERM_READ_ENCRYPT_MASK)) {
   4d780:	f7ff ff3c 	bl	4d5fc <bt_gatt_check_perm>
   4d784:	bb58      	cbnz	r0, 4d7de <gatt_notify+0x6c>
		if (!bt_gatt_is_subscribed(conn, params->attr, BT_GATT_CCC_NOTIFY)) {
   4d786:	6861      	ldr	r1, [r4, #4]
   4d788:	2201      	movs	r2, #1
   4d78a:	4630      	mov	r0, r6
   4d78c:	f7ff ff6a 	bl	4d664 <bt_gatt_is_subscribed>
   4d790:	b348      	cbz	r0, 4d7e6 <gatt_notify+0x74>
				sizeof(*nfy) + params->len);
   4d792:	89a2      	ldrh	r2, [r4, #12]
	buf = bt_att_create_pdu(conn, BT_ATT_OP_NOTIFY,
   4d794:	211b      	movs	r1, #27
   4d796:	3202      	adds	r2, #2
   4d798:	4630      	mov	r0, r6
   4d79a:	f7ff f9e3 	bl	4cb64 <bt_att_create_pdu>
	if (!buf) {
   4d79e:	4605      	mov	r5, r0
   4d7a0:	b320      	cbz	r0, 4d7ec <gatt_notify+0x7a>
	return net_buf_simple_add(&buf->b, len);
   4d7a2:	f100 0908 	add.w	r9, r0, #8
   4d7a6:	2102      	movs	r1, #2
   4d7a8:	4648      	mov	r0, r9
   4d7aa:	f001 fb03 	bl	4edb4 <net_buf_simple_add>
	nfy->handle = sys_cpu_to_le16(handle);
   4d7ae:	4607      	mov	r7, r0
   4d7b0:	4648      	mov	r0, r9
   4d7b2:	f827 8b02 	strh.w	r8, [r7], #2
   4d7b6:	89a1      	ldrh	r1, [r4, #12]
   4d7b8:	f001 fafc 	bl	4edb4 <net_buf_simple_add>
	memcpy(nfy->value, params->data, params->len);
   4d7bc:	89a2      	ldrh	r2, [r4, #12]
   4d7be:	68a1      	ldr	r1, [r4, #8]
   4d7c0:	4638      	mov	r0, r7
   4d7c2:	f7fd fb5a 	bl	4ae7a <memcpy>
	bt_att_set_tx_meta_data(buf, params->func, params->user_data, BT_ATT_CHAN_OPT(params));
   4d7c6:	e9d4 1204 	ldrd	r1, r2, [r4, #16]
   4d7ca:	4628      	mov	r0, r5
   4d7cc:	2301      	movs	r3, #1
   4d7ce:	f7ff fb53 	bl	4ce78 <bt_att_set_tx_meta_data>
	return bt_att_send(conn, buf);
   4d7d2:	4629      	mov	r1, r5
   4d7d4:	4630      	mov	r0, r6
}
   4d7d6:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	return bt_att_send(conn, buf);
   4d7da:	f7ff bab9 	b.w	4cd50 <bt_att_send>
		return -EPERM;
   4d7de:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
   4d7e2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			return -EINVAL;
   4d7e6:	f06f 0015 	mvn.w	r0, #21
   4d7ea:	e7fa      	b.n	4d7e2 <gatt_notify+0x70>
		return -ENOMEM;
   4d7ec:	f06f 000b 	mvn.w	r0, #11
   4d7f0:	e7f7      	b.n	4d7e2 <gatt_notify+0x70>

0004d7f2 <gatt_discover_next>:
{
   4d7f2:	b570      	push	{r4, r5, r6, lr}
	if (!last_handle)
   4d7f4:	460b      	mov	r3, r1
{
   4d7f6:	4605      	mov	r5, r0
   4d7f8:	4614      	mov	r4, r2
	if (!last_handle)
   4d7fa:	b929      	cbnz	r1, 4d808 <gatt_discover_next+0x16>
	if (!bt_gatt_discover(conn, params)) {
   4d7fc:	4621      	mov	r1, r4
   4d7fe:	4628      	mov	r0, r5
   4d800:	f7e4 ff8e 	bl	32720 <bt_gatt_discover>
   4d804:	b928      	cbnz	r0, 4d812 <gatt_discover_next+0x20>
}
   4d806:	bd70      	pop	{r4, r5, r6, pc}
	if (params->start_handle < UINT16_MAX) {
   4d808:	f64f 72ff 	movw	r2, #65535	; 0xffff
   4d80c:	4291      	cmp	r1, r2
   4d80e:	d107      	bne.n	4d820 <gatt_discover_next+0x2e>
	params->start_handle = last_handle;
   4d810:	8121      	strh	r1, [r4, #8]
	params->func(conn, NULL, params);
   4d812:	6863      	ldr	r3, [r4, #4]
   4d814:	4622      	mov	r2, r4
   4d816:	4628      	mov	r0, r5
   4d818:	2100      	movs	r1, #0
}
   4d81a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	params->func(conn, NULL, params);
   4d81e:	4718      	bx	r3
	if (params->start_handle > params->end_handle) {
   4d820:	89e2      	ldrh	r2, [r4, #14]
		params->start_handle++;
   4d822:	3301      	adds	r3, #1
   4d824:	b29b      	uxth	r3, r3
	if (params->start_handle > params->end_handle) {
   4d826:	429a      	cmp	r2, r3
		params->start_handle++;
   4d828:	8123      	strh	r3, [r4, #8]
	if (params->start_handle > params->end_handle) {
   4d82a:	d2e7      	bcs.n	4d7fc <gatt_discover_next+0xa>
   4d82c:	e7f1      	b.n	4d812 <gatt_discover_next+0x20>

0004d82e <gatt_find_type_rsp>:
{
   4d82e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4d832:	b089      	sub	sp, #36	; 0x24
   4d834:	4606      	mov	r6, r0
   4d836:	9f12      	ldr	r7, [sp, #72]	; 0x48
   4d838:	4614      	mov	r4, r2
	if (err || (length % sizeof(struct bt_att_handle_group) != 0)) {
   4d83a:	b911      	cbnz	r1, 4d842 <gatt_find_type_rsp+0x14>
   4d83c:	f013 0803 	ands.w	r8, r3, #3
   4d840:	d007      	beq.n	4d852 <gatt_find_type_rsp+0x24>
	params->func(conn, NULL, params);
   4d842:	687b      	ldr	r3, [r7, #4]
   4d844:	463a      	mov	r2, r7
   4d846:	2100      	movs	r1, #0
   4d848:	4630      	mov	r0, r6
}
   4d84a:	b009      	add	sp, #36	; 0x24
   4d84c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	params->func(conn, NULL, params);
   4d850:	4718      	bx	r3
	for (uint8_t i = 0U; i < count; i++) {
   4d852:	f3c3 0387 	ubfx	r3, r3, #2, #8
   4d856:	eb02 0583 	add.w	r5, r2, r3, lsl #2
		uuid_svc.uuid.type = BT_UUID_TYPE_16;
   4d85a:	46c1      	mov	r9, r8
			uuid_svc.val = BT_UUID_GATT_PRIMARY_VAL;
   4d85c:	f642 0a01 	movw	sl, #10241	; 0x2801
	for (uint8_t i = 0U; i < count; i++) {
   4d860:	42ac      	cmp	r4, r5
   4d862:	d107      	bne.n	4d874 <gatt_find_type_rsp+0x46>
	gatt_discover_next(conn, end_handle, params);
   4d864:	463a      	mov	r2, r7
   4d866:	4641      	mov	r1, r8
   4d868:	4630      	mov	r0, r6
}
   4d86a:	b009      	add	sp, #36	; 0x24
   4d86c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	gatt_discover_next(conn, end_handle, params);
   4d870:	f7ff bfbf 	b.w	4d7f2 <gatt_discover_next>
		if (params->type == BT_GATT_DISCOVER_PRIMARY) {
   4d874:	7c3a      	ldrb	r2, [r7, #16]
		end_handle = sys_le16_to_cpu(rsp[i].end_handle);
   4d876:	8863      	ldrh	r3, [r4, #2]
		value.end_handle = end_handle;
   4d878:	f8ad 3008 	strh.w	r3, [sp, #8]
			uuid_svc.val = BT_UUID_GATT_PRIMARY_VAL;
   4d87c:	2a00      	cmp	r2, #0
   4d87e:	bf14      	ite	ne
   4d880:	4652      	movne	r2, sl
   4d882:	f44f 5220 	moveq.w	r2, #10240	; 0x2800
   4d886:	f8ad 2002 	strh.w	r2, [sp, #2]
		attr = (struct bt_gatt_attr) {
   4d88a:	2210      	movs	r2, #16
   4d88c:	2100      	movs	r1, #0
   4d88e:	eb0d 0002 	add.w	r0, sp, r2
		end_handle = sys_le16_to_cpu(rsp[i].end_handle);
   4d892:	fa1f f883 	uxth.w	r8, r3
		value.uuid = params->uuid;
   4d896:	683b      	ldr	r3, [r7, #0]
		start_handle = sys_le16_to_cpu(rsp[i].start_handle);
   4d898:	f8b4 b000 	ldrh.w	fp, [r4]
		value.uuid = params->uuid;
   4d89c:	9301      	str	r3, [sp, #4]
		uuid_svc.uuid.type = BT_UUID_TYPE_16;
   4d89e:	f88d 9000 	strb.w	r9, [sp]
		attr = (struct bt_gatt_attr) {
   4d8a2:	f7fd faf5 	bl	4ae90 <memset>
   4d8a6:	ab01      	add	r3, sp, #4
   4d8a8:	9306      	str	r3, [sp, #24]
   4d8aa:	f8cd d00c 	str.w	sp, [sp, #12]
		if (params->func(conn, &attr, params) == BT_GATT_ITER_STOP) {
   4d8ae:	687b      	ldr	r3, [r7, #4]
		attr = (struct bt_gatt_attr) {
   4d8b0:	f8ad b01c 	strh.w	fp, [sp, #28]
		if (params->func(conn, &attr, params) == BT_GATT_ITER_STOP) {
   4d8b4:	463a      	mov	r2, r7
   4d8b6:	a903      	add	r1, sp, #12
   4d8b8:	4630      	mov	r0, r6
   4d8ba:	4798      	blx	r3
   4d8bc:	3404      	adds	r4, #4
   4d8be:	2800      	cmp	r0, #0
   4d8c0:	d1ce      	bne.n	4d860 <gatt_find_type_rsp+0x32>
}
   4d8c2:	b009      	add	sp, #36	; 0x24
   4d8c4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0004d8c8 <gatt_read_group_rsp>:
{
   4d8c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4d8cc:	b08f      	sub	sp, #60	; 0x3c
   4d8ce:	4681      	mov	r9, r0
   4d8d0:	9d18      	ldr	r5, [sp, #96]	; 0x60
   4d8d2:	4617      	mov	r7, r2
	if (err) {
   4d8d4:	b131      	cbz	r1, 4d8e4 <gatt_read_group_rsp+0x1c>
		params->func(conn, NULL, params);
   4d8d6:	686b      	ldr	r3, [r5, #4]
   4d8d8:	462a      	mov	r2, r5
   4d8da:	2100      	movs	r1, #0
}
   4d8dc:	b00f      	add	sp, #60	; 0x3c
   4d8de:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		params->func(conn, NULL, params);
   4d8e2:	4718      	bx	r3
	switch (rsp->len) {
   4d8e4:	7812      	ldrb	r2, [r2, #0]
   4d8e6:	2a06      	cmp	r2, #6
   4d8e8:	d002      	beq.n	4d8f0 <gatt_read_group_rsp+0x28>
   4d8ea:	2a14      	cmp	r2, #20
   4d8ec:	d10d      	bne.n	4d90a <gatt_read_group_rsp+0x42>
   4d8ee:	2102      	movs	r1, #2
	for (length--, pdu = rsp->data; length >= rsp->len;
   4d8f0:	3b01      	subs	r3, #1
		u.uuid.type = BT_UUID_TYPE_16;
   4d8f2:	f88d 1010 	strb.w	r1, [sp, #16]
	for (length--, pdu = rsp->data; length >= rsp->len;
   4d8f6:	b29c      	uxth	r4, r3
   4d8f8:	f107 0801 	add.w	r8, r7, #1
	uint16_t start_handle, end_handle = 0U;
   4d8fc:	2600      	movs	r6, #0
	for (length--, pdu = rsp->data; length >= rsp->len;
   4d8fe:	783b      	ldrb	r3, [r7, #0]
   4d900:	42a3      	cmp	r3, r4
   4d902:	d90a      	bls.n	4d91a <gatt_read_group_rsp+0x52>
	if (length == 0U && end_handle) {
   4d904:	b90c      	cbnz	r4, 4d90a <gatt_read_group_rsp+0x42>
   4d906:	2e00      	cmp	r6, #0
   4d908:	d150      	bne.n	4d9ac <gatt_read_group_rsp+0xe4>
	params->func(conn, NULL, params);
   4d90a:	686b      	ldr	r3, [r5, #4]
   4d90c:	462a      	mov	r2, r5
   4d90e:	2100      	movs	r1, #0
   4d910:	4648      	mov	r0, r9
   4d912:	4798      	blx	r3
}
   4d914:	b00f      	add	sp, #60	; 0x3c
   4d916:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		struct bt_gatt_attr attr = {};
   4d91a:	2214      	movs	r2, #20
   4d91c:	2100      	movs	r1, #0
   4d91e:	a809      	add	r0, sp, #36	; 0x24
   4d920:	f7fd fab6 	bl	4ae90 <memset>
		start_handle = sys_le16_to_cpu(data->start_handle);
   4d924:	f8b8 a000 	ldrh.w	sl, [r8]
   4d928:	fa1f f38a 	uxth.w	r3, sl
		if (!start_handle) {
   4d92c:	2b00      	cmp	r3, #0
   4d92e:	d0ec      	beq.n	4d90a <gatt_read_group_rsp+0x42>
		end_handle = sys_le16_to_cpu(data->end_handle);
   4d930:	f8b8 b002 	ldrh.w	fp, [r8, #2]
   4d934:	fa1f f68b 	uxth.w	r6, fp
		if (!end_handle || end_handle < start_handle) {
   4d938:	2e00      	cmp	r6, #0
   4d93a:	d0e6      	beq.n	4d90a <gatt_read_group_rsp+0x42>
   4d93c:	42b3      	cmp	r3, r6
   4d93e:	d8e4      	bhi.n	4d90a <gatt_read_group_rsp+0x42>
		switch (u.uuid.type) {
   4d940:	f89d 3010 	ldrb.w	r3, [sp, #16]
   4d944:	b323      	cbz	r3, 4d990 <gatt_read_group_rsp+0xc8>
   4d946:	2b02      	cmp	r3, #2
   4d948:	d02a      	beq.n	4d9a0 <gatt_read_group_rsp+0xd8>
		uuid_svc.uuid.type = BT_UUID_TYPE_16;
   4d94a:	f04f 0300 	mov.w	r3, #0
   4d94e:	f88d 3004 	strb.w	r3, [sp, #4]
		if (params->type == BT_GATT_DISCOVER_PRIMARY) {
   4d952:	7c2b      	ldrb	r3, [r5, #16]
		value.end_handle = end_handle;
   4d954:	f8ad b00c 	strh.w	fp, [sp, #12]
			uuid_svc.val = BT_UUID_GATT_PRIMARY_VAL;
   4d958:	2b00      	cmp	r3, #0
   4d95a:	f642 0301 	movw	r3, #10241	; 0x2801
   4d95e:	bf08      	it	eq
   4d960:	f44f 5320 	moveq.w	r3, #10240	; 0x2800
   4d964:	f8ad 3006 	strh.w	r3, [sp, #6]
		value.uuid = &u.uuid;
   4d968:	ab04      	add	r3, sp, #16
   4d96a:	9302      	str	r3, [sp, #8]
		attr.uuid = &uuid_svc.uuid;
   4d96c:	ab01      	add	r3, sp, #4
   4d96e:	9309      	str	r3, [sp, #36]	; 0x24
		attr.user_data = &value;
   4d970:	ab02      	add	r3, sp, #8
   4d972:	930c      	str	r3, [sp, #48]	; 0x30
		attr.handle = start_handle;
   4d974:	f8ad a034 	strh.w	sl, [sp, #52]	; 0x34
		if (params->func(conn, &attr, params) == BT_GATT_ITER_STOP) {
   4d978:	686b      	ldr	r3, [r5, #4]
   4d97a:	462a      	mov	r2, r5
   4d97c:	a909      	add	r1, sp, #36	; 0x24
   4d97e:	4648      	mov	r0, r9
   4d980:	4798      	blx	r3
   4d982:	2800      	cmp	r0, #0
   4d984:	d0c6      	beq.n	4d914 <gatt_read_group_rsp+0x4c>
	     length -= rsp->len, pdu = (const uint8_t *)pdu + rsp->len) {
   4d986:	783b      	ldrb	r3, [r7, #0]
   4d988:	1ae4      	subs	r4, r4, r3
   4d98a:	b2a4      	uxth	r4, r4
   4d98c:	4498      	add	r8, r3
   4d98e:	e7b6      	b.n	4d8fe <gatt_read_group_rsp+0x36>
			memcpy(&u.u16.val, data->value, sizeof(u.u16.val));
   4d990:	2202      	movs	r2, #2
   4d992:	f108 0104 	add.w	r1, r8, #4
   4d996:	f10d 0012 	add.w	r0, sp, #18
			memcpy(u.u128.val, data->value, sizeof(u.u128.val));
   4d99a:	f7fd fa6e 	bl	4ae7a <memcpy>
			break;
   4d99e:	e7d4      	b.n	4d94a <gatt_read_group_rsp+0x82>
			memcpy(u.u128.val, data->value, sizeof(u.u128.val));
   4d9a0:	2210      	movs	r2, #16
   4d9a2:	f108 0104 	add.w	r1, r8, #4
   4d9a6:	f10d 0011 	add.w	r0, sp, #17
   4d9aa:	e7f6      	b.n	4d99a <gatt_read_group_rsp+0xd2>
	gatt_discover_next(conn, handle, params);
   4d9ac:	462a      	mov	r2, r5
   4d9ae:	4631      	mov	r1, r6
   4d9b0:	4648      	mov	r0, r9
}
   4d9b2:	b00f      	add	sp, #60	; 0x3c
   4d9b4:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	gatt_discover_next(conn, handle, params);
   4d9b8:	f7ff bf1b 	b.w	4d7f2 <gatt_discover_next>

0004d9bc <read_included_uuid_cb>:
{
   4d9bc:	b5f0      	push	{r4, r5, r6, r7, lr}
   4d9be:	b08f      	sub	sp, #60	; 0x3c
	if (length != 16U) {
   4d9c0:	2b10      	cmp	r3, #16
{
   4d9c2:	4611      	mov	r1, r2
   4d9c4:	9c14      	ldr	r4, [sp, #80]	; 0x50
   4d9c6:	4605      	mov	r5, r0
   4d9c8:	461a      	mov	r2, r3
	if (length != 16U) {
   4d9ca:	d006      	beq.n	4d9da <read_included_uuid_cb+0x1e>
		params->func(conn, NULL, params);
   4d9cc:	6863      	ldr	r3, [r4, #4]
   4d9ce:	4622      	mov	r2, r4
   4d9d0:	2100      	movs	r1, #0
}
   4d9d2:	b00f      	add	sp, #60	; 0x3c
   4d9d4:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		params->func(conn, NULL, params);
   4d9d8:	4718      	bx	r3
	value.start_handle = params->_included.start_handle;
   4d9da:	8963      	ldrh	r3, [r4, #10]
   4d9dc:	f8ad 300c 	strh.w	r3, [sp, #12]
	value.end_handle = params->_included.end_handle;
   4d9e0:	89a3      	ldrh	r3, [r4, #12]
   4d9e2:	f8ad 300e 	strh.w	r3, [sp, #14]
	value.uuid = &u.uuid;
   4d9e6:	ae04      	add	r6, sp, #16
	u.uuid.type = BT_UUID_TYPE_128;
   4d9e8:	2302      	movs	r3, #2
	memcpy(u.u128.val, pdu, length);
   4d9ea:	f10d 0011 	add.w	r0, sp, #17
	handle = params->_included.attr_handle;
   4d9ee:	8927      	ldrh	r7, [r4, #8]
	value.uuid = &u.uuid;
   4d9f0:	9602      	str	r6, [sp, #8]
	u.uuid.type = BT_UUID_TYPE_128;
   4d9f2:	f88d 3010 	strb.w	r3, [sp, #16]
	memcpy(u.u128.val, pdu, length);
   4d9f6:	f7fd fa40 	bl	4ae7a <memcpy>
	if (params->uuid && bt_uuid_cmp(&u.uuid, params->uuid)) {
   4d9fa:	6821      	ldr	r1, [r4, #0]
   4d9fc:	b9c1      	cbnz	r1, 4da30 <read_included_uuid_cb+0x74>
		.uuid = BT_UUID_GATT_INCLUDE,
   4d9fe:	2100      	movs	r1, #0
   4da00:	f642 0302 	movw	r3, #10242	; 0x2802
	attr = (struct bt_gatt_attr) {
   4da04:	2210      	movs	r2, #16
   4da06:	a80a      	add	r0, sp, #40	; 0x28
		.uuid = BT_UUID_GATT_INCLUDE,
   4da08:	f88d 1004 	strb.w	r1, [sp, #4]
   4da0c:	f8ad 3006 	strh.w	r3, [sp, #6]
	attr = (struct bt_gatt_attr) {
   4da10:	f7fd fa3e 	bl	4ae90 <memset>
   4da14:	ab01      	add	r3, sp, #4
   4da16:	9309      	str	r3, [sp, #36]	; 0x24
   4da18:	ab02      	add	r3, sp, #8
   4da1a:	930c      	str	r3, [sp, #48]	; 0x30
   4da1c:	f8ad 7034 	strh.w	r7, [sp, #52]	; 0x34
	if (params->func(conn, &attr, params) == BT_GATT_ITER_STOP) {
   4da20:	6863      	ldr	r3, [r4, #4]
   4da22:	4622      	mov	r2, r4
   4da24:	a909      	add	r1, sp, #36	; 0x24
   4da26:	4628      	mov	r0, r5
   4da28:	4798      	blx	r3
   4da2a:	b930      	cbnz	r0, 4da3a <read_included_uuid_cb+0x7e>
}
   4da2c:	b00f      	add	sp, #60	; 0x3c
   4da2e:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (params->uuid && bt_uuid_cmp(&u.uuid, params->uuid)) {
   4da30:	4630      	mov	r0, r6
   4da32:	f7fd fae3 	bl	4affc <bt_uuid_cmp>
   4da36:	2800      	cmp	r0, #0
   4da38:	d0e1      	beq.n	4d9fe <read_included_uuid_cb+0x42>
	gatt_discover_next(conn, params->start_handle, params);
   4da3a:	8921      	ldrh	r1, [r4, #8]
   4da3c:	4622      	mov	r2, r4
   4da3e:	4628      	mov	r0, r5
   4da40:	f7ff fed7 	bl	4d7f2 <gatt_discover_next>
	return;
   4da44:	e7f2      	b.n	4da2c <read_included_uuid_cb+0x70>

0004da46 <gatt_find_info_rsp>:
{
   4da46:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4da4a:	b08f      	sub	sp, #60	; 0x3c
   4da4c:	4680      	mov	r8, r0
   4da4e:	9e18      	ldr	r6, [sp, #96]	; 0x60
	if (err) {
   4da50:	2900      	cmp	r1, #0
   4da52:	f040 8091 	bne.w	4db78 <gatt_find_info_rsp+0x132>
	switch (rsp->format) {
   4da56:	7810      	ldrb	r0, [r2, #0]
   4da58:	2801      	cmp	r0, #1
   4da5a:	d01c      	beq.n	4da96 <gatt_find_info_rsp+0x50>
   4da5c:	2802      	cmp	r0, #2
   4da5e:	f040 808b 	bne.w	4db78 <gatt_find_info_rsp+0x132>
   4da62:	4601      	mov	r1, r0
		len = sizeof(*info.i128);
   4da64:	f04f 0a12 	mov.w	sl, #18
	length--;
   4da68:	1e5c      	subs	r4, r3, #1
   4da6a:	b2a4      	uxth	r4, r4
	if (length < len) {
   4da6c:	4554      	cmp	r4, sl
		u.uuid.type = BT_UUID_TYPE_16;
   4da6e:	f88d 1010 	strb.w	r1, [sp, #16]
	if (length < len) {
   4da72:	f0c0 8081 	bcc.w	4db78 <gatt_find_info_rsp+0x132>
	for (i = length / len, pdu = rsp->info; i != 0;
   4da76:	fbb4 f4fa 	udiv	r4, r4, sl
	bool skip = false;
   4da7a:	f04f 0900 	mov.w	r9, #0
	for (i = length / len, pdu = rsp->info; i != 0;
   4da7e:	1c55      	adds	r5, r2, #1
	uint16_t handle = 0U;
   4da80:	f8cd 9000 	str.w	r9, [sp]
			skip = false;
   4da84:	46cb      	mov	fp, r9
   4da86:	af04      	add	r7, sp, #16
	for (i = length / len, pdu = rsp->info; i != 0;
   4da88:	b944      	cbnz	r4, 4da9c <gatt_find_info_rsp+0x56>
	gatt_discover_next(conn, handle, params);
   4da8a:	9900      	ldr	r1, [sp, #0]
   4da8c:	4632      	mov	r2, r6
   4da8e:	4640      	mov	r0, r8
   4da90:	f7ff feaf 	bl	4d7f2 <gatt_discover_next>
	return;
   4da94:	e06d      	b.n	4db72 <gatt_find_info_rsp+0x12c>
	switch (rsp->format) {
   4da96:	f04f 0a04 	mov.w	sl, #4
   4da9a:	e7e5      	b.n	4da68 <gatt_find_info_rsp+0x22>
		handle = sys_le16_to_cpu(info.i16->handle);
   4da9c:	882b      	ldrh	r3, [r5, #0]
   4da9e:	9301      	str	r3, [sp, #4]
   4daa0:	f8bd 3004 	ldrh.w	r3, [sp, #4]
   4daa4:	9300      	str	r3, [sp, #0]
		if (skip) {
   4daa6:	f1b9 0f00 	cmp.w	r9, #0
   4daaa:	d14c      	bne.n	4db46 <gatt_find_info_rsp+0x100>
		switch (u.uuid.type) {
   4daac:	f89d 3010 	ldrb.w	r3, [sp, #16]
   4dab0:	b3b3      	cbz	r3, 4db20 <gatt_find_info_rsp+0xda>
   4dab2:	2b02      	cmp	r3, #2
   4dab4:	d03b      	beq.n	4db2e <gatt_find_info_rsp+0xe8>
		if (params->uuid && bt_uuid_cmp(&u.uuid, params->uuid)) {
   4dab6:	6831      	ldr	r1, [r6, #0]
   4dab8:	2900      	cmp	r1, #0
   4daba:	d13f      	bne.n	4db3c <gatt_find_info_rsp+0xf6>
		if (params->type == BT_GATT_DISCOVER_DESCRIPTOR) {
   4dabc:	7c33      	ldrb	r3, [r6, #16]
   4dabe:	2b04      	cmp	r3, #4
   4dac0:	d146      	bne.n	4db50 <gatt_find_info_rsp+0x10a>
			if (!bt_uuid_cmp(&u.uuid, BT_UUID_GATT_PRIMARY) ||
   4dac2:	f44f 5320 	mov.w	r3, #10240	; 0x2800
   4dac6:	a902      	add	r1, sp, #8
   4dac8:	4638      	mov	r0, r7
   4daca:	f88d b008 	strb.w	fp, [sp, #8]
   4dace:	f8ad 300a 	strh.w	r3, [sp, #10]
   4dad2:	f7fd fa93 	bl	4affc <bt_uuid_cmp>
   4dad6:	b3b0      	cbz	r0, 4db46 <gatt_find_info_rsp+0x100>
			    !bt_uuid_cmp(&u.uuid, BT_UUID_GATT_SECONDARY) ||
   4dad8:	f642 0301 	movw	r3, #10241	; 0x2801
   4dadc:	a903      	add	r1, sp, #12
   4dade:	4638      	mov	r0, r7
   4dae0:	f88d b00c 	strb.w	fp, [sp, #12]
   4dae4:	f8ad 300e 	strh.w	r3, [sp, #14]
   4dae8:	f7fd fa88 	bl	4affc <bt_uuid_cmp>
			if (!bt_uuid_cmp(&u.uuid, BT_UUID_GATT_PRIMARY) ||
   4daec:	b358      	cbz	r0, 4db46 <gatt_find_info_rsp+0x100>
			    !bt_uuid_cmp(&u.uuid, BT_UUID_GATT_INCLUDE)) {
   4daee:	f642 0302 	movw	r3, #10242	; 0x2802
   4daf2:	a909      	add	r1, sp, #36	; 0x24
   4daf4:	4638      	mov	r0, r7
   4daf6:	f88d b024 	strb.w	fp, [sp, #36]	; 0x24
   4dafa:	f8ad 3026 	strh.w	r3, [sp, #38]	; 0x26
   4dafe:	f7fd fa7d 	bl	4affc <bt_uuid_cmp>
			    !bt_uuid_cmp(&u.uuid, BT_UUID_GATT_SECONDARY) ||
   4db02:	b300      	cbz	r0, 4db46 <gatt_find_info_rsp+0x100>
			if (!bt_uuid_cmp(&u.uuid, BT_UUID_GATT_CHRC)) {
   4db04:	f642 0303 	movw	r3, #10243	; 0x2803
   4db08:	a909      	add	r1, sp, #36	; 0x24
   4db0a:	4638      	mov	r0, r7
   4db0c:	f88d b024 	strb.w	fp, [sp, #36]	; 0x24
   4db10:	f8ad 3026 	strh.w	r3, [sp, #38]	; 0x26
   4db14:	f7fd fa72 	bl	4affc <bt_uuid_cmp>
   4db18:	b9d0      	cbnz	r0, 4db50 <gatt_find_info_rsp+0x10a>
				skip = true;
   4db1a:	f04f 0901 	mov.w	r9, #1
   4db1e:	e014      	b.n	4db4a <gatt_find_info_rsp+0x104>
			u.u16.val = sys_le16_to_cpu(info.i16->uuid);
   4db20:	78ab      	ldrb	r3, [r5, #2]
   4db22:	78ea      	ldrb	r2, [r5, #3]
   4db24:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   4db28:	f8ad 3012 	strh.w	r3, [sp, #18]
			break;
   4db2c:	e7c3      	b.n	4dab6 <gatt_find_info_rsp+0x70>
			memcpy(u.u128.val, info.i128->uuid, 16);
   4db2e:	2210      	movs	r2, #16
   4db30:	1ca9      	adds	r1, r5, #2
   4db32:	f10d 0011 	add.w	r0, sp, #17
   4db36:	f7fd f9a0 	bl	4ae7a <memcpy>
			break;
   4db3a:	e7bc      	b.n	4dab6 <gatt_find_info_rsp+0x70>
		if (params->uuid && bt_uuid_cmp(&u.uuid, params->uuid)) {
   4db3c:	4638      	mov	r0, r7
   4db3e:	f7fd fa5d 	bl	4affc <bt_uuid_cmp>
   4db42:	2800      	cmp	r0, #0
   4db44:	d0ba      	beq.n	4dabc <gatt_find_info_rsp+0x76>
			skip = false;
   4db46:	f04f 0900 	mov.w	r9, #0
	     i--, pdu = (const uint8_t *)pdu + len) {
   4db4a:	3c01      	subs	r4, #1
   4db4c:	4455      	add	r5, sl
   4db4e:	e79b      	b.n	4da88 <gatt_find_info_rsp+0x42>
		attr = (struct bt_gatt_attr) {
   4db50:	2210      	movs	r2, #16
   4db52:	2100      	movs	r1, #0
   4db54:	a80a      	add	r0, sp, #40	; 0x28
   4db56:	f7fd f99b 	bl	4ae90 <memset>
   4db5a:	f8bd 3004 	ldrh.w	r3, [sp, #4]
   4db5e:	f8ad 3034 	strh.w	r3, [sp, #52]	; 0x34
   4db62:	9709      	str	r7, [sp, #36]	; 0x24
		if (params->func(conn, &attr, params) == BT_GATT_ITER_STOP) {
   4db64:	6873      	ldr	r3, [r6, #4]
   4db66:	4632      	mov	r2, r6
   4db68:	a909      	add	r1, sp, #36	; 0x24
   4db6a:	4640      	mov	r0, r8
   4db6c:	4798      	blx	r3
   4db6e:	2800      	cmp	r0, #0
   4db70:	d1eb      	bne.n	4db4a <gatt_find_info_rsp+0x104>
}
   4db72:	b00f      	add	sp, #60	; 0x3c
   4db74:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	params->func(conn, NULL, params);
   4db78:	6873      	ldr	r3, [r6, #4]
   4db7a:	4632      	mov	r2, r6
   4db7c:	2100      	movs	r1, #0
   4db7e:	4640      	mov	r0, r8
   4db80:	4798      	blx	r3
   4db82:	e7f6      	b.n	4db72 <gatt_find_info_rsp+0x12c>

0004db84 <bt_gatt_write_without_response_cb>:
{
   4db84:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
   4db88:	4690      	mov	r8, r2
	if (conn->state != BT_CONN_CONNECTED) {
   4db8a:	7b42      	ldrb	r2, [r0, #13]
   4db8c:	2a07      	cmp	r2, #7
{
   4db8e:	461e      	mov	r6, r3
   4db90:	e9dd 9a0d 	ldrd	r9, sl, [sp, #52]	; 0x34
   4db94:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
   4db98:	4605      	mov	r5, r0
   4db9a:	460f      	mov	r7, r1
	if (conn->state != BT_CONN_CONNECTED) {
   4db9c:	d135      	bne.n	4dc0a <bt_gatt_write_without_response_cb+0x86>
	if (conn->encrypt) {
   4db9e:	7ac2      	ldrb	r2, [r0, #11]
   4dba0:	bb12      	cbnz	r2, 4dbe8 <bt_gatt_write_without_response_cb+0x64>
	if (sign) {
   4dba2:	b30b      	cbz	r3, 4dbe8 <bt_gatt_write_without_response_cb+0x64>
		buf = bt_att_create_pdu(conn, BT_ATT_OP_SIGNED_WRITE_CMD,
   4dba4:	f106 020e 	add.w	r2, r6, #14
   4dba8:	21d2      	movs	r1, #210	; 0xd2
		buf = bt_att_create_pdu(conn, BT_ATT_OP_WRITE_CMD,
   4dbaa:	f7fe ffdb 	bl	4cb64 <bt_att_create_pdu>
   4dbae:	4604      	mov	r4, r0
	if (!buf) {
   4dbb0:	b1a8      	cbz	r0, 4dbde <bt_gatt_write_without_response_cb+0x5a>
   4dbb2:	2102      	movs	r1, #2
   4dbb4:	3008      	adds	r0, #8
   4dbb6:	f001 f8fd 	bl	4edb4 <net_buf_simple_add>
	write = net_buf_append_bytes(buf, length, data, K_NO_WAIT, NULL, NULL);
   4dbba:	2200      	movs	r2, #0
	cmd->handle = sys_cpu_to_le16(handle);
   4dbbc:	8007      	strh	r7, [r0, #0]
	write = net_buf_append_bytes(buf, length, data, K_NO_WAIT, NULL, NULL);
   4dbbe:	2300      	movs	r3, #0
   4dbc0:	2700      	movs	r7, #0
   4dbc2:	e9cd 2300 	strd	r2, r3, [sp]
   4dbc6:	e9cd 7702 	strd	r7, r7, [sp, #8]
   4dbca:	4642      	mov	r2, r8
   4dbcc:	4631      	mov	r1, r6
   4dbce:	4620      	mov	r0, r4
   4dbd0:	f7f4 fe6c 	bl	428ac <net_buf_append_bytes>
	if (write != length) {
   4dbd4:	42b0      	cmp	r0, r6
   4dbd6:	d00b      	beq.n	4dbf0 <bt_gatt_write_without_response_cb+0x6c>
		net_buf_unref(buf);
   4dbd8:	4620      	mov	r0, r4
   4dbda:	f7f4 fe35 	bl	42848 <net_buf_unref>
		return -ENOMEM;
   4dbde:	f06f 000b 	mvn.w	r0, #11
}
   4dbe2:	b004      	add	sp, #16
   4dbe4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		buf = bt_att_create_pdu(conn, BT_ATT_OP_WRITE_CMD,
   4dbe8:	1cb2      	adds	r2, r6, #2
   4dbea:	2152      	movs	r1, #82	; 0x52
   4dbec:	4628      	mov	r0, r5
   4dbee:	e7dc      	b.n	4dbaa <bt_gatt_write_without_response_cb+0x26>
	bt_att_set_tx_meta_data(buf, func, user_data, BT_ATT_CHAN_OPT_NONE);
   4dbf0:	4649      	mov	r1, r9
   4dbf2:	4620      	mov	r0, r4
   4dbf4:	463b      	mov	r3, r7
   4dbf6:	4652      	mov	r2, sl
   4dbf8:	f7ff f93e 	bl	4ce78 <bt_att_set_tx_meta_data>
	return bt_att_send(conn, buf);
   4dbfc:	4621      	mov	r1, r4
   4dbfe:	4628      	mov	r0, r5
}
   4dc00:	b004      	add	sp, #16
   4dc02:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return bt_att_send(conn, buf);
   4dc06:	f7ff b8a3 	b.w	4cd50 <bt_att_send>
		return -ENOTCONN;
   4dc0a:	f06f 007f 	mvn.w	r0, #127	; 0x7f
   4dc0e:	e7e8      	b.n	4dbe2 <bt_gatt_write_without_response_cb+0x5e>

0004dc10 <gatt_ccc_discover_cb>:
{
   4dc10:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   4dc12:	4605      	mov	r5, r0
	struct bt_gatt_subscribe_params *sub_params = params->sub_params;
   4dc14:	6954      	ldr	r4, [r2, #20]
{
   4dc16:	4610      	mov	r0, r2
	if (!attr) {
   4dc18:	460e      	mov	r6, r1
   4dc1a:	b951      	cbnz	r1, 4dc32 <gatt_ccc_discover_cb+0x22>
		memset(params, 0, sizeof(*params));
   4dc1c:	2218      	movs	r2, #24
   4dc1e:	f7fd f937 	bl	4ae90 <memset>
		sub_params->notify(conn, sub_params, NULL, 0);
   4dc22:	6827      	ldr	r7, [r4, #0]
   4dc24:	4633      	mov	r3, r6
   4dc26:	4632      	mov	r2, r6
   4dc28:	4621      	mov	r1, r4
   4dc2a:	4628      	mov	r0, r5
   4dc2c:	47b8      	blx	r7
		return BT_GATT_ITER_STOP;
   4dc2e:	2000      	movs	r0, #0
}
   4dc30:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (params->type == BT_GATT_DISCOVER_DESCRIPTOR) {
   4dc32:	7c13      	ldrb	r3, [r2, #16]
   4dc34:	2b04      	cmp	r3, #4
   4dc36:	d112      	bne.n	4dc5e <gatt_ccc_discover_cb+0x4e>
		memset(params, 0, sizeof(*params));
   4dc38:	2100      	movs	r1, #0
   4dc3a:	2218      	movs	r2, #24
   4dc3c:	f7fd f928 	bl	4ae90 <memset>
		sub_params->ccc_handle = attr->handle;
   4dc40:	8a33      	ldrh	r3, [r6, #16]
   4dc42:	81e3      	strh	r3, [r4, #14]
		if (bt_gatt_subscribe(conn, sub_params)) {
   4dc44:	4621      	mov	r1, r4
   4dc46:	4628      	mov	r0, r5
   4dc48:	f7e4 ff74 	bl	32b34 <bt_gatt_subscribe>
   4dc4c:	2800      	cmp	r0, #0
   4dc4e:	d0ee      	beq.n	4dc2e <gatt_ccc_discover_cb+0x1e>
			sub_params->notify(conn, sub_params, NULL, 0);
   4dc50:	2300      	movs	r3, #0
   4dc52:	6826      	ldr	r6, [r4, #0]
   4dc54:	461a      	mov	r2, r3
   4dc56:	4621      	mov	r1, r4
   4dc58:	4628      	mov	r0, r5
   4dc5a:	47b0      	blx	r6
   4dc5c:	e7e7      	b.n	4dc2e <gatt_ccc_discover_cb+0x1e>
	return BT_GATT_ITER_CONTINUE;
   4dc5e:	2001      	movs	r0, #1
   4dc60:	e7e6      	b.n	4dc30 <gatt_ccc_discover_cb+0x20>

0004dc62 <bt_gatt_cancel>:
{
   4dc62:	b573      	push	{r0, r1, r4, r5, r6, lr}
   4dc64:	4604      	mov	r4, r0
   4dc66:	460d      	mov	r5, r1
	k_sched_lock();
   4dc68:	f7f9 fed4 	bl	47a14 <k_sched_lock>
	req = bt_att_find_req_by_user_data(conn, params);
   4dc6c:	4629      	mov	r1, r5
   4dc6e:	4620      	mov	r0, r4
   4dc70:	f7ff f8c1 	bl	4cdf6 <bt_att_find_req_by_user_data>
	if (req) {
   4dc74:	4601      	mov	r1, r0
   4dc76:	b920      	cbnz	r0, 4dc82 <bt_gatt_cancel+0x20>
}
   4dc78:	b002      	add	sp, #8
   4dc7a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	k_sched_unlock();
   4dc7e:	f7f9 bedd 	b.w	47a3c <k_sched_unlock>
		func = req->func;
   4dc82:	6846      	ldr	r6, [r0, #4]
		bt_att_req_cancel(conn, req);
   4dc84:	4620      	mov	r0, r4
   4dc86:	f7e3 fcbb 	bl	31600 <bt_att_req_cancel>
	k_sched_unlock();
   4dc8a:	f7f9 fed7 	bl	47a3c <k_sched_unlock>
	if (func) {
   4dc8e:	b12e      	cbz	r6, 4dc9c <bt_gatt_cancel+0x3a>
		func(conn, BT_ATT_ERR_UNLIKELY, NULL, 0, params);
   4dc90:	2300      	movs	r3, #0
   4dc92:	9500      	str	r5, [sp, #0]
   4dc94:	461a      	mov	r2, r3
   4dc96:	210e      	movs	r1, #14
   4dc98:	4620      	mov	r0, r4
   4dc9a:	47b0      	blx	r6
}
   4dc9c:	b002      	add	sp, #8
   4dc9e:	bd70      	pop	{r4, r5, r6, pc}

0004dca0 <bt_gatt_notification>:
{
   4dca0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   4dca4:	4606      	mov	r6, r0
   4dca6:	4688      	mov	r8, r1
   4dca8:	4691      	mov	r9, r2
   4dcaa:	469a      	mov	sl, r3
	sub = gatt_sub_find(conn);
   4dcac:	f7e3 fd40 	bl	31730 <gatt_sub_find>
	if (!sub) {
   4dcb0:	b320      	cbz	r0, 4dcfc <bt_gatt_notification+0x5c>
	return list->head;
   4dcb2:	6884      	ldr	r4, [r0, #8]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp, node) {
   4dcb4:	b314      	cbz	r4, 4dcfc <bt_gatt_notification+0x5c>
	return node->next;
   4dcb6:	6825      	ldr	r5, [r4, #0]
   4dcb8:	b105      	cbz	r5, 4dcbc <bt_gatt_notification+0x1c>
   4dcba:	3d20      	subs	r5, #32
		if (handle != params->value_handle) {
   4dcbc:	f834 3c14 	ldrh.w	r3, [r4, #-20]
   4dcc0:	4543      	cmp	r3, r8
   4dcc2:	d118      	bne.n	4dcf6 <bt_gatt_notification+0x56>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp, node) {
   4dcc4:	3c20      	subs	r4, #32
   4dcc6:	e007      	b.n	4dcd8 <bt_gatt_notification+0x38>
   4dcc8:	462c      	mov	r4, r5
   4dcca:	6a2d      	ldr	r5, [r5, #32]
   4dccc:	89a3      	ldrh	r3, [r4, #12]
   4dcce:	b1bd      	cbz	r5, 4dd00 <bt_gatt_notification+0x60>
		if (handle != params->value_handle) {
   4dcd0:	4543      	cmp	r3, r8
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp, node) {
   4dcd2:	f1a5 0520 	sub.w	r5, r5, #32
		if (handle != params->value_handle) {
   4dcd6:	d1f7      	bne.n	4dcc8 <bt_gatt_notification+0x28>
		if (check_subscribe_security_level(conn, params)) {
   4dcd8:	7a72      	ldrb	r2, [r6, #9]
   4dcda:	7ea3      	ldrb	r3, [r4, #26]
   4dcdc:	429a      	cmp	r2, r3
   4dcde:	d30a      	bcc.n	4dcf6 <bt_gatt_notification+0x56>
			if (params->notify(conn, params, data, length) ==
   4dce0:	6827      	ldr	r7, [r4, #0]
   4dce2:	4653      	mov	r3, sl
   4dce4:	464a      	mov	r2, r9
   4dce6:	4621      	mov	r1, r4
   4dce8:	4630      	mov	r0, r6
   4dcea:	47b8      	blx	r7
   4dcec:	b918      	cbnz	r0, 4dcf6 <bt_gatt_notification+0x56>
				bt_gatt_unsubscribe(conn, params);
   4dcee:	4621      	mov	r1, r4
   4dcf0:	4630      	mov	r0, r6
   4dcf2:	f7e4 ff9d 	bl	32c30 <bt_gatt_unsubscribe>
   4dcf6:	462c      	mov	r4, r5
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp, node) {
   4dcf8:	2d00      	cmp	r5, #0
   4dcfa:	d1e6      	bne.n	4dcca <bt_gatt_notification+0x2a>
}
   4dcfc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		if (handle != params->value_handle) {
   4dd00:	4543      	cmp	r3, r8
   4dd02:	d0e9      	beq.n	4dcd8 <bt_gatt_notification+0x38>
   4dd04:	e7fa      	b.n	4dcfc <bt_gatt_notification+0x5c>

0004dd06 <bt_gatt_mult_notification>:
{
   4dd06:	e92d 4dff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, sl, fp, lr}
   4dd0a:	4680      	mov	r8, r0
   4dd0c:	460c      	mov	r4, r1
   4dd0e:	4615      	mov	r5, r2
	sub = gatt_sub_find(conn);
   4dd10:	f7e3 fd0e 	bl	31730 <gatt_sub_find>
	if (!sub) {
   4dd14:	4607      	mov	r7, r0
   4dd16:	b140      	cbz	r0, 4dd2a <bt_gatt_mult_notification+0x24>
	net_buf_simple_init_with_data(&buf, (void *)data, length);
   4dd18:	462a      	mov	r2, r5
   4dd1a:	4621      	mov	r1, r4
   4dd1c:	a801      	add	r0, sp, #4
   4dd1e:	f001 f800 	bl	4ed22 <net_buf_simple_init_with_data>
	while (buf.len > sizeof(*nfy)) {
   4dd22:	f8bd 3008 	ldrh.w	r3, [sp, #8]
   4dd26:	2b04      	cmp	r3, #4
   4dd28:	d802      	bhi.n	4dd30 <bt_gatt_mult_notification+0x2a>
}
   4dd2a:	b004      	add	sp, #16
   4dd2c:	e8bd 8df0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, sl, fp, pc}
		nfy = net_buf_simple_pull_mem(&buf, sizeof(*nfy));
   4dd30:	2104      	movs	r1, #4
   4dd32:	eb0d 0001 	add.w	r0, sp, r1
   4dd36:	f001 f86e 	bl	4ee16 <net_buf_simple_pull_mem>
		if (len > buf.len) {
   4dd3a:	f8bd 3008 	ldrh.w	r3, [sp, #8]
		len = sys_cpu_to_le16(nfy->len);
   4dd3e:	f8b0 b002 	ldrh.w	fp, [r0, #2]
		handle = sys_cpu_to_le16(nfy->handle);
   4dd42:	f8b0 a000 	ldrh.w	sl, [r0]
		if (len > buf.len) {
   4dd46:	455b      	cmp	r3, fp
		nfy = net_buf_simple_pull_mem(&buf, sizeof(*nfy));
   4dd48:	4606      	mov	r6, r0
		if (len > buf.len) {
   4dd4a:	d3ee      	bcc.n	4dd2a <bt_gatt_mult_notification+0x24>
	return list->head;
   4dd4c:	68bc      	ldr	r4, [r7, #8]
		SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp,
   4dd4e:	b324      	cbz	r4, 4dd9a <bt_gatt_mult_notification+0x94>
	return node->next;
   4dd50:	6825      	ldr	r5, [r4, #0]
   4dd52:	b105      	cbz	r5, 4dd56 <bt_gatt_mult_notification+0x50>
   4dd54:	3d20      	subs	r5, #32
			if (handle != params->value_handle) {
   4dd56:	f834 3c14 	ldrh.w	r3, [r4, #-20]
   4dd5a:	4553      	cmp	r3, sl
   4dd5c:	d11a      	bne.n	4dd94 <bt_gatt_mult_notification+0x8e>
		SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp,
   4dd5e:	3c20      	subs	r4, #32
   4dd60:	e007      	b.n	4dd72 <bt_gatt_mult_notification+0x6c>
   4dd62:	462c      	mov	r4, r5
   4dd64:	6a2d      	ldr	r5, [r5, #32]
   4dd66:	89a3      	ldrh	r3, [r4, #12]
   4dd68:	b1e5      	cbz	r5, 4dda4 <bt_gatt_mult_notification+0x9e>
			if (handle != params->value_handle) {
   4dd6a:	4553      	cmp	r3, sl
		SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp,
   4dd6c:	f1a5 0520 	sub.w	r5, r5, #32
			if (handle != params->value_handle) {
   4dd70:	d1f7      	bne.n	4dd62 <bt_gatt_mult_notification+0x5c>
			if (check_subscribe_security_level(conn, params)) {
   4dd72:	7ea2      	ldrb	r2, [r4, #26]
   4dd74:	f898 3009 	ldrb.w	r3, [r8, #9]
   4dd78:	429a      	cmp	r2, r3
   4dd7a:	d80b      	bhi.n	4dd94 <bt_gatt_mult_notification+0x8e>
				if (params->notify(conn, params, nfy->value, len) ==
   4dd7c:	f8d4 c000 	ldr.w	ip, [r4]
   4dd80:	465b      	mov	r3, fp
   4dd82:	1d32      	adds	r2, r6, #4
   4dd84:	4621      	mov	r1, r4
   4dd86:	4640      	mov	r0, r8
   4dd88:	47e0      	blx	ip
   4dd8a:	b918      	cbnz	r0, 4dd94 <bt_gatt_mult_notification+0x8e>
					bt_gatt_unsubscribe(conn, params);
   4dd8c:	4621      	mov	r1, r4
   4dd8e:	4640      	mov	r0, r8
   4dd90:	f7e4 ff4e 	bl	32c30 <bt_gatt_unsubscribe>
   4dd94:	462c      	mov	r4, r5
		SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp,
   4dd96:	2d00      	cmp	r5, #0
   4dd98:	d1e4      	bne.n	4dd64 <bt_gatt_mult_notification+0x5e>
		net_buf_simple_pull_mem(&buf, len);
   4dd9a:	4659      	mov	r1, fp
   4dd9c:	a801      	add	r0, sp, #4
   4dd9e:	f001 f83a 	bl	4ee16 <net_buf_simple_pull_mem>
   4dda2:	e7be      	b.n	4dd22 <bt_gatt_mult_notification+0x1c>
			if (handle != params->value_handle) {
   4dda4:	4553      	cmp	r3, sl
   4dda6:	d0e4      	beq.n	4dd72 <bt_gatt_mult_notification+0x6c>
   4dda8:	e7f7      	b.n	4dd9a <bt_gatt_mult_notification+0x94>

0004ddaa <bt_gatt_change_aware>:
{
   4ddaa:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   4ddac:	4605      	mov	r5, r0
   4ddae:	460f      	mov	r7, r1
	cfg = find_cf_cfg(conn);
   4ddb0:	f7e3 fc60 	bl	31674 <find_cf_cfg>
	if (!cfg || !CF_ROBUST_CACHING(cfg)) {
   4ddb4:	b1d0      	cbz	r0, 4ddec <bt_gatt_change_aware+0x42>
   4ddb6:	7a03      	ldrb	r3, [r0, #8]
   4ddb8:	07db      	lsls	r3, r3, #31
   4ddba:	d517      	bpl.n	4ddec <bt_gatt_change_aware+0x42>
	if (atomic_test_bit(cfg->flags, CF_CHANGE_AWARE)) {
   4ddbc:	f100 040c 	add.w	r4, r0, #12
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
   4ddc0:	4620      	mov	r0, r4
   4ddc2:	f7ff f903 	bl	4cfcc <atomic_get>
   4ddc6:	f010 0601 	ands.w	r6, r0, #1
   4ddca:	d10f      	bne.n	4ddec <bt_gatt_change_aware+0x42>
	if (!req) {
   4ddcc:	b17f      	cbz	r7, 4ddee <bt_gatt_change_aware+0x44>
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   4ddce:	f06f 0102 	mvn.w	r1, #2
   4ddd2:	4620      	mov	r0, r4
   4ddd4:	f7ff f956 	bl	4d084 <atomic_and>
	if (atomic_test_and_clear_bit(cfg->flags, CF_DB_HASH_READ)) {
   4ddd8:	f010 0f02 	tst.w	r0, #2
		bt_att_clear_out_of_sync_sent(conn);
   4dddc:	4628      	mov	r0, r5
	if (atomic_test_and_clear_bit(cfg->flags, CF_DB_HASH_READ)) {
   4ddde:	d008      	beq.n	4ddf2 <bt_gatt_change_aware+0x48>
		bt_att_clear_out_of_sync_sent(conn);
   4dde0:	f7ff f825 	bl	4ce2e <bt_att_clear_out_of_sync_sent>
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
   4dde4:	2101      	movs	r1, #1
   4dde6:	4620      	mov	r0, r4
   4dde8:	f7ff f8f6 	bl	4cfd8 <atomic_or>
		return true;
   4ddec:	2601      	movs	r6, #1
}
   4ddee:	4630      	mov	r0, r6
   4ddf0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (bt_att_fixed_chan_only(conn) && bt_att_out_of_sync_sent_on_fixed(conn)) {
   4ddf2:	f7ff f81a 	bl	4ce2a <bt_att_fixed_chan_only>
   4ddf6:	2800      	cmp	r0, #0
   4ddf8:	d0f9      	beq.n	4ddee <bt_gatt_change_aware+0x44>
   4ddfa:	4628      	mov	r0, r5
   4ddfc:	f7ff f830 	bl	4ce60 <bt_att_out_of_sync_sent_on_fixed>
   4de00:	2800      	cmp	r0, #0
   4de02:	d0f4      	beq.n	4ddee <bt_gatt_change_aware+0x44>
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   4de04:	f06f 0102 	mvn.w	r1, #2
   4de08:	4620      	mov	r0, r4
   4de0a:	f7ff f93b 	bl	4d084 <atomic_and>
		bt_att_clear_out_of_sync_sent(conn);
   4de0e:	4628      	mov	r0, r5
   4de10:	e7e6      	b.n	4dde0 <bt_gatt_change_aware+0x36>

0004de12 <ccc_delayed_store>:
{
   4de12:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4de16:	f1a0 061c 	sub.w	r6, r0, #28
   4de1a:	1f04      	subs	r4, r0, #4
			ccc_store->conn_list[i] = NULL;
   4de1c:	f04f 0800 	mov.w	r8, #0
		struct bt_conn *conn = ccc_store->conn_list[i];
   4de20:	f856 5f04 	ldr.w	r5, [r6, #4]!
		if (!conn) {
   4de24:	b17d      	cbz	r5, 4de46 <ccc_delayed_store+0x34>
		if (bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
   4de26:	f105 0788 	add.w	r7, r5, #136	; 0x88
   4de2a:	7a28      	ldrb	r0, [r5, #8]
   4de2c:	4639      	mov	r1, r7
   4de2e:	f7fd fc6d 	bl	4b70c <bt_addr_le_is_bonded>
   4de32:	b140      	cbz	r0, 4de46 <ccc_delayed_store+0x34>
			ccc_store->conn_list[i] = NULL;
   4de34:	f8c6 8000 	str.w	r8, [r6]
			bt_gatt_store_ccc(conn->id, &conn->le.dst);
   4de38:	7a28      	ldrb	r0, [r5, #8]
   4de3a:	4639      	mov	r1, r7
   4de3c:	f7e4 ffe0 	bl	32e00 <bt_gatt_store_ccc>
			bt_conn_unref(conn);
   4de40:	4628      	mov	r0, r5
   4de42:	f7fd ffc0 	bl	4bdc6 <bt_conn_unref>
	for (size_t i = 0; i < CONFIG_BT_MAX_CONN; i++) {
   4de46:	42a6      	cmp	r6, r4
   4de48:	d1ea      	bne.n	4de20 <ccc_delayed_store+0xe>
}
   4de4a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0004de4e <sys_memcpy_swap>:
	psrc += length - 1;
   4de4e:	1e53      	subs	r3, r2, #1
   4de50:	4419      	add	r1, r3
	for (; length > 0; length--) {
   4de52:	4402      	add	r2, r0
		*pdst++ = *psrc--;
   4de54:	f811 3901 	ldrb.w	r3, [r1], #-1
   4de58:	f800 3b01 	strb.w	r3, [r0], #1
	for (; length > 0; length--) {
   4de5c:	4290      	cmp	r0, r2
   4de5e:	d1f9      	bne.n	4de54 <sys_memcpy_swap+0x6>
}
   4de60:	4770      	bx	lr

0004de62 <smp_encrypt_info>:
}
   4de62:	2007      	movs	r0, #7
   4de64:	4770      	bx	lr

0004de66 <le_sc_oob_config_set>:
	return ((req->oob_flag & BT_SMP_OOB_DATA_MASK) == BT_SMP_OOB_PRESENT);
   4de66:	7ac2      	ldrb	r2, [r0, #11]
	return ((rsp->oob_flag & BT_SMP_OOB_DATA_MASK) == BT_SMP_OOB_PRESENT);
   4de68:	7c83      	ldrb	r3, [r0, #18]
	    smp->chan.chan.conn->role == BT_HCI_ROLE_CENTRAL) {
   4de6a:	f8d0 00ec 	ldr.w	r0, [r0, #236]	; 0xec
	if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
   4de6e:	78c0      	ldrb	r0, [r0, #3]
	return ((req->oob_flag & BT_SMP_OOB_DATA_MASK) == BT_SMP_OOB_PRESENT);
   4de70:	f002 0201 	and.w	r2, r2, #1
	return ((rsp->oob_flag & BT_SMP_OOB_DATA_MASK) == BT_SMP_OOB_PRESENT);
   4de74:	f003 0301 	and.w	r3, r3, #1
	if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
   4de78:	b940      	cbnz	r0, 4de8c <le_sc_oob_config_set+0x26>
		oob_config = req_oob_present ? BT_CONN_OOB_REMOTE_ONLY :
   4de7a:	b112      	cbz	r2, 4de82 <le_sc_oob_config_set+0x1c>
		if (rsp_oob_present) {
   4de7c:	3301      	adds	r3, #1
	info->lesc.oob_config = oob_config;
   4de7e:	704b      	strb	r3, [r1, #1]
}
   4de80:	4770      	bx	lr
				     BT_CONN_OOB_BOTH_PEERS :
   4de82:	2b00      	cmp	r3, #0
   4de84:	bf0c      	ite	eq
   4de86:	2303      	moveq	r3, #3
   4de88:	2300      	movne	r3, #0
   4de8a:	e7f8      	b.n	4de7e <le_sc_oob_config_set+0x18>
		oob_config = req_oob_present ? BT_CONN_OOB_LOCAL_ONLY :
   4de8c:	b922      	cbnz	r2, 4de98 <le_sc_oob_config_set+0x32>
				     BT_CONN_OOB_BOTH_PEERS :
   4de8e:	2b00      	cmp	r3, #0
   4de90:	bf0c      	ite	eq
   4de92:	2303      	moveq	r3, #3
   4de94:	2301      	movne	r3, #1
   4de96:	e7f2      	b.n	4de7e <le_sc_oob_config_set+0x18>
		if (rsp_oob_present) {
   4de98:	005b      	lsls	r3, r3, #1
   4de9a:	e7f0      	b.n	4de7e <le_sc_oob_config_set+0x18>

0004de9c <smp_chan_get>:
{
   4de9c:	b508      	push	{r3, lr}
	chan = bt_l2cap_le_lookup_rx_cid(conn, BT_L2CAP_CID_SMP);
   4de9e:	2106      	movs	r1, #6
   4dea0:	f7fe f9c5 	bl	4c22e <bt_l2cap_le_lookup_rx_cid>
	if (!chan) {
   4dea4:	b100      	cbz	r0, 4dea8 <smp_chan_get+0xc>
	return CONTAINER_OF(chan, struct bt_smp, chan);
   4dea6:	38ec      	subs	r0, #236	; 0xec
}
   4dea8:	bd08      	pop	{r3, pc}

0004deaa <atomic_test_bit>:
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   4deaa:	f3bf 8f5b 	dmb	ish
   4deae:	6800      	ldr	r0, [r0, #0]
   4deb0:	f3bf 8f5b 	dmb	ish
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
   4deb4:	4108      	asrs	r0, r1
}
   4deb6:	f000 0001 	and.w	r0, r0, #1
   4deba:	4770      	bx	lr

0004debc <smp_keys_check>:
{
   4debc:	b538      	push	{r3, r4, r5, lr}
	if (atomic_test_bit(conn->flags, BT_CONN_FORCE_PAIR)) {
   4debe:	210a      	movs	r1, #10
{
   4dec0:	4604      	mov	r4, r0
	if (atomic_test_bit(conn->flags, BT_CONN_FORCE_PAIR)) {
   4dec2:	3004      	adds	r0, #4
   4dec4:	f7ff fff1 	bl	4deaa <atomic_test_bit>
   4dec8:	b108      	cbz	r0, 4dece <smp_keys_check+0x12>
		return false;
   4deca:	2000      	movs	r0, #0
}
   4decc:	bd38      	pop	{r3, r4, r5, pc}
	if (!conn->le.keys) {
   4dece:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
   4ded2:	b983      	cbnz	r3, 4def6 <smp_keys_check+0x3a>
						     conn->id, &conn->le.dst);
   4ded4:	f104 0588 	add.w	r5, r4, #136	; 0x88
		conn->le.keys = bt_keys_find(BT_KEYS_LTK_P256,
   4ded8:	7a21      	ldrb	r1, [r4, #8]
   4deda:	462a      	mov	r2, r5
   4dedc:	2020      	movs	r0, #32
   4dede:	f7e6 f9dd 	bl	3429c <bt_keys_find>
   4dee2:	f8c4 00b4 	str.w	r0, [r4, #180]	; 0xb4
		if (!conn->le.keys) {
   4dee6:	b930      	cbnz	r0, 4def6 <smp_keys_check+0x3a>
			conn->le.keys = bt_keys_find(BT_KEYS_LTK,
   4dee8:	7a21      	ldrb	r1, [r4, #8]
   4deea:	462a      	mov	r2, r5
   4deec:	2004      	movs	r0, #4
   4deee:	f7e6 f9d5 	bl	3429c <bt_keys_find>
   4def2:	f8c4 00b4 	str.w	r0, [r4, #180]	; 0xb4
	if (!conn->le.keys ||
   4def6:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
   4defa:	2b00      	cmp	r3, #0
   4defc:	d0e5      	beq.n	4deca <smp_keys_check+0xe>
	    !(conn->le.keys->keys & (BT_KEYS_LTK | BT_KEYS_LTK_P256))) {
   4defe:	89da      	ldrh	r2, [r3, #14]
	if (!conn->le.keys ||
   4df00:	f012 0f24 	tst.w	r2, #36	; 0x24
   4df04:	d0e1      	beq.n	4deca <smp_keys_check+0xe>
	if (conn->required_sec_level >= BT_SECURITY_L3 &&
   4df06:	7aa1      	ldrb	r1, [r4, #10]
   4df08:	2902      	cmp	r1, #2
   4df0a:	d90c      	bls.n	4df26 <smp_keys_check+0x6a>
   4df0c:	7b58      	ldrb	r0, [r3, #13]
   4df0e:	07c0      	lsls	r0, r0, #31
   4df10:	d5db      	bpl.n	4deca <smp_keys_check+0xe>
	if (conn->required_sec_level >= BT_SECURITY_L4 &&
   4df12:	2903      	cmp	r1, #3
   4df14:	d007      	beq.n	4df26 <smp_keys_check+0x6a>
	    !((conn->le.keys->flags & BT_KEYS_AUTHENTICATED) &&
   4df16:	0692      	lsls	r2, r2, #26
   4df18:	d5d7      	bpl.n	4deca <smp_keys_check+0xe>
   4df1a:	7b18      	ldrb	r0, [r3, #12]
   4df1c:	f1a0 0310 	sub.w	r3, r0, #16
   4df20:	4258      	negs	r0, r3
   4df22:	4158      	adcs	r0, r3
   4df24:	e7d2      	b.n	4decc <smp_keys_check+0x10>
	return true;
   4df26:	2001      	movs	r0, #1
   4df28:	e7d0      	b.n	4decc <smp_keys_check+0x10>

0004df2a <update_keys_check>:
{
   4df2a:	b510      	push	{r4, lr}
   4df2c:	4603      	mov	r3, r0
	if (!keys ||
   4df2e:	b1d9      	cbz	r1, 4df68 <update_keys_check+0x3e>
	    !(keys->keys & (BT_KEYS_LTK_P256 | BT_KEYS_LTK))) {
   4df30:	89c8      	ldrh	r0, [r1, #14]
	if (!keys ||
   4df32:	f010 0f24 	tst.w	r0, #36	; 0x24
   4df36:	d017      	beq.n	4df68 <update_keys_check+0x3e>
	return MIN(req->max_key_size, rsp->max_key_size);
   4df38:	7d1a      	ldrb	r2, [r3, #20]
   4df3a:	7b5c      	ldrb	r4, [r3, #13]
	if (keys->enc_size > get_encryption_key_size(smp)) {
   4df3c:	7b09      	ldrb	r1, [r1, #12]
   4df3e:	42a2      	cmp	r2, r4
   4df40:	bf28      	it	cs
   4df42:	4622      	movcs	r2, r4
   4df44:	4291      	cmp	r1, r2
   4df46:	d901      	bls.n	4df4c <update_keys_check+0x22>
		return false;
   4df48:	2000      	movs	r0, #0
}
   4df4a:	bd10      	pop	{r4, pc}
	if ((keys->keys & BT_KEYS_LTK_P256) &&
   4df4c:	0682      	lsls	r2, r0, #26
   4df4e:	d404      	bmi.n	4df5a <update_keys_check+0x30>
	if ((keys->flags & BT_KEYS_AUTHENTICATED) &&
   4df50:	7a18      	ldrb	r0, [r3, #8]
   4df52:	3800      	subs	r0, #0
   4df54:	bf18      	it	ne
   4df56:	2001      	movne	r0, #1
   4df58:	e7f7      	b.n	4df4a <update_keys_check+0x20>
	    !atomic_test_bit(smp->flags, SMP_FLAG_SC)) {
   4df5a:	2105      	movs	r1, #5
   4df5c:	1d18      	adds	r0, r3, #4
   4df5e:	f7ff ffa4 	bl	4deaa <atomic_test_bit>
	if ((keys->keys & BT_KEYS_LTK_P256) &&
   4df62:	2800      	cmp	r0, #0
   4df64:	d1f4      	bne.n	4df50 <update_keys_check+0x26>
   4df66:	e7ef      	b.n	4df48 <update_keys_check+0x1e>
	return true;
   4df68:	2001      	movs	r0, #1
   4df6a:	e7ee      	b.n	4df4a <update_keys_check+0x20>

0004df6c <remote_sec_level_reachable>:
{
   4df6c:	b508      	push	{r3, lr}
	bt_security_t sec = smp->chan.chan.conn->required_sec_level;
   4df6e:	f8d0 20ec 	ldr.w	r2, [r0, #236]	; 0xec
   4df72:	7a92      	ldrb	r2, [r2, #10]
	switch (sec) {
   4df74:	2a03      	cmp	r2, #3
{
   4df76:	4603      	mov	r3, r0
	switch (sec) {
   4df78:	d015      	beq.n	4dfa6 <remote_sec_level_reachable+0x3a>
   4df7a:	d804      	bhi.n	4df86 <remote_sec_level_reachable+0x1a>
   4df7c:	3a01      	subs	r2, #1
   4df7e:	2a01      	cmp	r2, #1
   4df80:	d914      	bls.n	4dfac <remote_sec_level_reachable+0x40>
		return BT_SMP_ERR_UNSPECIFIED;
   4df82:	2008      	movs	r0, #8
   4df84:	e00e      	b.n	4dfa4 <remote_sec_level_reachable+0x38>
	switch (sec) {
   4df86:	2a04      	cmp	r2, #4
   4df88:	d1fb      	bne.n	4df82 <remote_sec_level_reachable+0x16>
	return MIN(req->max_key_size, rsp->max_key_size);
   4df8a:	7d02      	ldrb	r2, [r0, #20]
   4df8c:	7b41      	ldrb	r1, [r0, #13]
		if (get_encryption_key_size(smp) != BT_SMP_MAX_ENC_KEY_SIZE) {
   4df8e:	428a      	cmp	r2, r1
   4df90:	bf28      	it	cs
   4df92:	460a      	movcs	r2, r1
   4df94:	2a10      	cmp	r2, #16
   4df96:	d10b      	bne.n	4dfb0 <remote_sec_level_reachable+0x44>
		if (!atomic_test_bit(smp->flags, SMP_FLAG_SC)) {
   4df98:	2105      	movs	r1, #5
   4df9a:	3004      	adds	r0, #4
   4df9c:	f7ff ff85 	bl	4deaa <atomic_test_bit>
   4dfa0:	b908      	cbnz	r0, 4dfa6 <remote_sec_level_reachable+0x3a>
			return BT_SMP_ERR_AUTH_REQUIREMENTS;
   4dfa2:	2003      	movs	r0, #3
}
   4dfa4:	bd08      	pop	{r3, pc}
		if (smp->method == JUST_WORKS) {
   4dfa6:	7a1b      	ldrb	r3, [r3, #8]
   4dfa8:	2b00      	cmp	r3, #0
   4dfaa:	d0fa      	beq.n	4dfa2 <remote_sec_level_reachable+0x36>
		return 0;
   4dfac:	2000      	movs	r0, #0
   4dfae:	e7f9      	b.n	4dfa4 <remote_sec_level_reachable+0x38>
			return BT_SMP_ERR_ENC_KEY_SIZE;
   4dfb0:	2006      	movs	r0, #6
   4dfb2:	e7f7      	b.n	4dfa4 <remote_sec_level_reachable+0x38>

0004dfb4 <atomic_clear_bit>:
	atomic_val_t mask = ATOMIC_MASK(bit);
   4dfb4:	2301      	movs	r3, #1
   4dfb6:	408b      	lsls	r3, r1
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   4dfb8:	43db      	mvns	r3, r3
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   4dfba:	f3bf 8f5b 	dmb	ish
   4dfbe:	e850 2f00 	ldrex	r2, [r0]
   4dfc2:	401a      	ands	r2, r3
   4dfc4:	e840 2100 	strex	r1, r2, [r0]
   4dfc8:	2900      	cmp	r1, #0
   4dfca:	d1f8      	bne.n	4dfbe <atomic_clear_bit+0xa>
   4dfcc:	f3bf 8f5b 	dmb	ish
}
   4dfd0:	4770      	bx	lr

0004dfd2 <bt_smp_aes_cmac>:
{
   4dfd2:	b570      	push	{r4, r5, r6, lr}
   4dfd4:	b0c2      	sub	sp, #264	; 0x108
   4dfd6:	460d      	mov	r5, r1
   4dfd8:	4616      	mov	r6, r2
	if (tc_cmac_setup(&state, key, &sched) == TC_CRYPTO_FAIL) {
   4dfda:	4601      	mov	r1, r0
   4dfdc:	aa16      	add	r2, sp, #88	; 0x58
   4dfde:	4668      	mov	r0, sp
{
   4dfe0:	461c      	mov	r4, r3
	if (tc_cmac_setup(&state, key, &sched) == TC_CRYPTO_FAIL) {
   4dfe2:	f7fc fd03 	bl	4a9ec <tc_cmac_setup>
   4dfe6:	b918      	cbnz	r0, 4dff0 <bt_smp_aes_cmac+0x1e>
		return -EIO;
   4dfe8:	f06f 0004 	mvn.w	r0, #4
}
   4dfec:	b042      	add	sp, #264	; 0x108
   4dfee:	bd70      	pop	{r4, r5, r6, pc}
	if (tc_cmac_update(&state, in, len) == TC_CRYPTO_FAIL) {
   4dff0:	4632      	mov	r2, r6
   4dff2:	4629      	mov	r1, r5
   4dff4:	4668      	mov	r0, sp
   4dff6:	f7fc fd24 	bl	4aa42 <tc_cmac_update>
   4dffa:	2800      	cmp	r0, #0
   4dffc:	d0f4      	beq.n	4dfe8 <bt_smp_aes_cmac+0x16>
	if (tc_cmac_final(out, &state) == TC_CRYPTO_FAIL) {
   4dffe:	4669      	mov	r1, sp
   4e000:	4620      	mov	r0, r4
   4e002:	f7fc fd88 	bl	4ab16 <tc_cmac_final>
   4e006:	2800      	cmp	r0, #0
   4e008:	d0ee      	beq.n	4dfe8 <bt_smp_aes_cmac+0x16>
	return 0;
   4e00a:	2000      	movs	r0, #0
   4e00c:	e7ee      	b.n	4dfec <bt_smp_aes_cmac+0x1a>

0004e00e <smp_signing_info>:
static uint8_t smp_signing_info(struct bt_smp *smp, struct net_buf *buf)
   4e00e:	2007      	movs	r0, #7
   4e010:	4770      	bx	lr

0004e012 <smp_send.constprop.0>:
static void smp_send(struct bt_smp *smp, struct net_buf *buf,
   4e012:	b537      	push	{r0, r1, r2, r4, r5, lr}
	if (bt_l2cap_send_cb(smp->chan.chan.conn, BT_L2CAP_CID_SMP, buf, cb, NULL)) {
   4e014:	2300      	movs	r3, #0
   4e016:	9300      	str	r3, [sp, #0]
static void smp_send(struct bt_smp *smp, struct net_buf *buf,
   4e018:	4604      	mov	r4, r0
   4e01a:	460d      	mov	r5, r1
	if (bt_l2cap_send_cb(smp->chan.chan.conn, BT_L2CAP_CID_SMP, buf, cb, NULL)) {
   4e01c:	460a      	mov	r2, r1
   4e01e:	f8d0 00ec 	ldr.w	r0, [r0, #236]	; 0xec
   4e022:	2106      	movs	r1, #6
   4e024:	f7fe f86e 	bl	4c104 <bt_l2cap_send_cb>
   4e028:	b128      	cbz	r0, 4e036 <smp_send.constprop.0+0x24>
		net_buf_unref(buf);
   4e02a:	4628      	mov	r0, r5
}
   4e02c:	b003      	add	sp, #12
   4e02e:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		net_buf_unref(buf);
   4e032:	f7f4 bc09 	b.w	42848 <net_buf_unref>
	k_work_reschedule(&smp->work, SMP_TIMEOUT);
   4e036:	f44f 2270 	mov.w	r2, #983040	; 0xf0000
   4e03a:	2300      	movs	r3, #0
   4e03c:	f504 70bc 	add.w	r0, r4, #376	; 0x178
}
   4e040:	b003      	add	sp, #12
   4e042:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	k_work_reschedule(&smp->work, SMP_TIMEOUT);
   4e046:	f7f9 bad1 	b.w	475ec <k_work_reschedule>

0004e04a <sys_mem_swap.constprop.0>:
static inline void sys_mem_swap(void *buf, size_t length)
   4e04a:	b510      	push	{r4, lr}
   4e04c:	1e43      	subs	r3, r0, #1
   4e04e:	f100 0210 	add.w	r2, r0, #16
   4e052:	3007      	adds	r0, #7
		uint8_t tmp = ((uint8_t *)buf)[i];
   4e054:	f813 1f01 	ldrb.w	r1, [r3, #1]!
		((uint8_t *)buf)[i] = ((uint8_t *)buf)[length - 1 - i];
   4e058:	f812 4d01 	ldrb.w	r4, [r2, #-1]!
   4e05c:	701c      	strb	r4, [r3, #0]
	for (i = 0; i < (length/2); i++) {
   4e05e:	4283      	cmp	r3, r0
		((uint8_t *)buf)[length - 1 - i] = tmp;
   4e060:	7011      	strb	r1, [r2, #0]
	for (i = 0; i < (length/2); i++) {
   4e062:	d1f7      	bne.n	4e054 <sys_mem_swap.constprop.0+0xa>
	}
}
   4e064:	bd10      	pop	{r4, pc}

0004e066 <smp_f6>:
{
   4e066:	b5f0      	push	{r4, r5, r6, r7, lr}
   4e068:	b097      	sub	sp, #92	; 0x5c
   4e06a:	4605      	mov	r5, r0
   4e06c:	4616      	mov	r6, r2
	sys_memcpy_swap(m, n1, 16);
   4e06e:	a805      	add	r0, sp, #20
   4e070:	2210      	movs	r2, #16
{
   4e072:	461c      	mov	r4, r3
   4e074:	9f1f      	ldr	r7, [sp, #124]	; 0x7c
	sys_memcpy_swap(m, n1, 16);
   4e076:	f7ff feea 	bl	4de4e <sys_memcpy_swap>
	sys_memcpy_swap(m + 16, n2, 16);
   4e07a:	2210      	movs	r2, #16
   4e07c:	4631      	mov	r1, r6
   4e07e:	a809      	add	r0, sp, #36	; 0x24
   4e080:	f7ff fee5 	bl	4de4e <sys_memcpy_swap>
	sys_memcpy_swap(m + 32, r, 16);
   4e084:	4621      	mov	r1, r4
   4e086:	2210      	movs	r2, #16
   4e088:	a80d      	add	r0, sp, #52	; 0x34
   4e08a:	f7ff fee0 	bl	4de4e <sys_memcpy_swap>
	sys_memcpy_swap(m + 48, iocap, 3);
   4e08e:	991c      	ldr	r1, [sp, #112]	; 0x70
   4e090:	2203      	movs	r2, #3
   4e092:	a811      	add	r0, sp, #68	; 0x44
   4e094:	f7ff fedb 	bl	4de4e <sys_memcpy_swap>
	m[51] = a1->type;
   4e098:	9c1d      	ldr	r4, [sp, #116]	; 0x74
   4e09a:	f814 3b01 	ldrb.w	r3, [r4], #1
   4e09e:	f88d 3047 	strb.w	r3, [sp, #71]	; 0x47
	memcpy(m + 52, a1->a.val, 6);
   4e0a2:	4621      	mov	r1, r4
   4e0a4:	2206      	movs	r2, #6
   4e0a6:	a812      	add	r0, sp, #72	; 0x48
   4e0a8:	f7fc fee7 	bl	4ae7a <memcpy>
	sys_memcpy_swap(m + 52, a1->a.val, 6);
   4e0ac:	4621      	mov	r1, r4
   4e0ae:	2206      	movs	r2, #6
   4e0b0:	a812      	add	r0, sp, #72	; 0x48
   4e0b2:	f7ff fecc 	bl	4de4e <sys_memcpy_swap>
	m[58] = a2->type;
   4e0b6:	9c1e      	ldr	r4, [sp, #120]	; 0x78
   4e0b8:	f814 3b01 	ldrb.w	r3, [r4], #1
   4e0bc:	f88d 304e 	strb.w	r3, [sp, #78]	; 0x4e
	memcpy(m + 59, a2->a.val, 6);
   4e0c0:	4621      	mov	r1, r4
   4e0c2:	2206      	movs	r2, #6
   4e0c4:	f10d 004f 	add.w	r0, sp, #79	; 0x4f
   4e0c8:	f7fc fed7 	bl	4ae7a <memcpy>
	sys_memcpy_swap(m + 59, a2->a.val, 6);
   4e0cc:	4621      	mov	r1, r4
   4e0ce:	2206      	movs	r2, #6
   4e0d0:	f10d 004f 	add.w	r0, sp, #79	; 0x4f
   4e0d4:	f7ff febb 	bl	4de4e <sys_memcpy_swap>
	sys_memcpy_swap(ws, w, 16);
   4e0d8:	2210      	movs	r2, #16
   4e0da:	4629      	mov	r1, r5
   4e0dc:	a801      	add	r0, sp, #4
   4e0de:	f7ff feb6 	bl	4de4e <sys_memcpy_swap>
	err = bt_smp_aes_cmac(ws, m, sizeof(m), check);
   4e0e2:	463b      	mov	r3, r7
   4e0e4:	2241      	movs	r2, #65	; 0x41
   4e0e6:	a905      	add	r1, sp, #20
   4e0e8:	a801      	add	r0, sp, #4
   4e0ea:	f7ff ff72 	bl	4dfd2 <bt_smp_aes_cmac>
	if (err) {
   4e0ee:	4604      	mov	r4, r0
   4e0f0:	b910      	cbnz	r0, 4e0f8 <smp_f6+0x92>
	sys_mem_swap(check, 16);
   4e0f2:	4638      	mov	r0, r7
   4e0f4:	f7ff ffa9 	bl	4e04a <sys_mem_swap.constprop.0>
}
   4e0f8:	4620      	mov	r0, r4
   4e0fa:	b017      	add	sp, #92	; 0x5c
   4e0fc:	bdf0      	pop	{r4, r5, r6, r7, pc}

0004e0fe <smp_f4>:
{
   4e0fe:	b5f0      	push	{r4, r5, r6, r7, lr}
   4e100:	b097      	sub	sp, #92	; 0x5c
   4e102:	4614      	mov	r4, r2
   4e104:	460e      	mov	r6, r1
	sys_memcpy_swap(m, u, 32);
   4e106:	2220      	movs	r2, #32
   4e108:	4601      	mov	r1, r0
   4e10a:	a805      	add	r0, sp, #20
{
   4e10c:	461d      	mov	r5, r3
   4e10e:	9f1c      	ldr	r7, [sp, #112]	; 0x70
	sys_memcpy_swap(m, u, 32);
   4e110:	f7ff fe9d 	bl	4de4e <sys_memcpy_swap>
	sys_memcpy_swap(m + 32, v, 32);
   4e114:	2220      	movs	r2, #32
   4e116:	4631      	mov	r1, r6
   4e118:	a80d      	add	r0, sp, #52	; 0x34
   4e11a:	f7ff fe98 	bl	4de4e <sys_memcpy_swap>
	sys_memcpy_swap(xs, x, 16);
   4e11e:	4621      	mov	r1, r4
   4e120:	2210      	movs	r2, #16
   4e122:	a801      	add	r0, sp, #4
	m[64] = z;
   4e124:	f88d 5054 	strb.w	r5, [sp, #84]	; 0x54
	sys_memcpy_swap(xs, x, 16);
   4e128:	f7ff fe91 	bl	4de4e <sys_memcpy_swap>
	err = bt_smp_aes_cmac(xs, m, sizeof(m), res);
   4e12c:	463b      	mov	r3, r7
   4e12e:	2241      	movs	r2, #65	; 0x41
   4e130:	a905      	add	r1, sp, #20
   4e132:	a801      	add	r0, sp, #4
   4e134:	f7ff ff4d 	bl	4dfd2 <bt_smp_aes_cmac>
	if (err) {
   4e138:	4604      	mov	r4, r0
   4e13a:	b910      	cbnz	r0, 4e142 <smp_f4+0x44>
	sys_mem_swap(res, 16);
   4e13c:	4638      	mov	r0, r7
   4e13e:	f7ff ff84 	bl	4e04a <sys_mem_swap.constprop.0>
}
   4e142:	4620      	mov	r0, r4
   4e144:	b017      	add	sp, #92	; 0x5c
   4e146:	bdf0      	pop	{r4, r5, r6, r7, pc}

0004e148 <atomic_set_bit>:
	atomic_val_t mask = ATOMIC_MASK(bit);
   4e148:	2301      	movs	r3, #1
   4e14a:	408b      	lsls	r3, r1
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   4e14c:	f3bf 8f5b 	dmb	ish
   4e150:	e850 2f00 	ldrex	r2, [r0]
   4e154:	431a      	orrs	r2, r3
   4e156:	e840 2100 	strex	r1, r2, [r0]
   4e15a:	2900      	cmp	r1, #0
   4e15c:	d1f8      	bne.n	4e150 <atomic_set_bit+0x8>
   4e15e:	f3bf 8f5b 	dmb	ish
}
   4e162:	4770      	bx	lr

0004e164 <smp_keypress_notif>:
{
   4e164:	b508      	push	{r3, lr}
	atomic_set_bit(smp->allowed_cmds, BT_SMP_KEYPRESS_NOTIFICATION);
   4e166:	210e      	movs	r1, #14
   4e168:	f7ff ffee 	bl	4e148 <atomic_set_bit>
}
   4e16c:	2000      	movs	r0, #0
   4e16e:	bd08      	pop	{r3, pc}

0004e170 <generate_dhkey>:
{
   4e170:	b510      	push	{r4, lr}
	atomic_set_bit(smp->flags, SMP_FLAG_DHKEY_PENDING);
   4e172:	2107      	movs	r1, #7
{
   4e174:	4604      	mov	r4, r0
	atomic_set_bit(smp->flags, SMP_FLAG_DHKEY_PENDING);
   4e176:	3004      	adds	r0, #4
   4e178:	f7ff ffe6 	bl	4e148 <atomic_set_bit>
	if (!smp_find(SMP_FLAG_DHKEY_GEN)) {
   4e17c:	2008      	movs	r0, #8
   4e17e:	f7e4 ffcf 	bl	33120 <smp_find>
   4e182:	b920      	cbnz	r0, 4e18e <generate_dhkey+0x1e>
		return smp_dhkey_generate(smp);
   4e184:	4620      	mov	r0, r4
}
   4e186:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		return smp_dhkey_generate(smp);
   4e18a:	f7e5 b9a9 	b.w	334e0 <smp_dhkey_generate>
}
   4e18e:	2000      	movs	r0, #0
   4e190:	bd10      	pop	{r4, pc}

0004e192 <smp_ident_info>:
{
   4e192:	b538      	push	{r3, r4, r5, lr}
   4e194:	4604      	mov	r4, r0
   4e196:	460b      	mov	r3, r1
	if (atomic_test_bit(smp->flags, SMP_FLAG_BOND)) {
   4e198:	3004      	adds	r0, #4
   4e19a:	210d      	movs	r1, #13
   4e19c:	f7ff fe85 	bl	4deaa <atomic_test_bit>
   4e1a0:	b170      	cbz	r0, 4e1c0 <smp_ident_info+0x2e>
		struct bt_smp_ident_info *req = (void *)buf->data;
   4e1a2:	689d      	ldr	r5, [r3, #8]
		struct bt_conn *conn = smp->chan.chan.conn;
   4e1a4:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
		keys = bt_keys_get_type(BT_KEYS_IRK, conn->id, &conn->le.dst);
   4e1a8:	2002      	movs	r0, #2
   4e1aa:	7a19      	ldrb	r1, [r3, #8]
   4e1ac:	f103 0288 	add.w	r2, r3, #136	; 0x88
   4e1b0:	f000 fd42 	bl	4ec38 <bt_keys_get_type>
		if (!keys) {
   4e1b4:	b150      	cbz	r0, 4e1cc <smp_ident_info+0x3a>
		memcpy(keys->irk.val, req->irk, 16);
   4e1b6:	2210      	movs	r2, #16
   4e1b8:	4629      	mov	r1, r5
   4e1ba:	302a      	adds	r0, #42	; 0x2a
   4e1bc:	f7fc fe5d 	bl	4ae7a <memcpy>
	atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_IDENT_ADDR_INFO);
   4e1c0:	4620      	mov	r0, r4
   4e1c2:	2109      	movs	r1, #9
   4e1c4:	f7ff ffc0 	bl	4e148 <atomic_set_bit>
	return 0;
   4e1c8:	2000      	movs	r0, #0
}
   4e1ca:	bd38      	pop	{r3, r4, r5, pc}
			return BT_SMP_ERR_UNSPECIFIED;
   4e1cc:	2008      	movs	r0, #8
   4e1ce:	e7fc      	b.n	4e1ca <smp_ident_info+0x38>

0004e1d0 <smp_create_pdu.constprop.0>:
static struct net_buf *smp_create_pdu(struct bt_smp *smp, uint8_t op, size_t len)
   4e1d0:	b570      	push	{r4, r5, r6, lr}
	if (atomic_test_bit(smp->flags, SMP_FLAG_TIMEOUT)) {
   4e1d2:	1d05      	adds	r5, r0, #4
static struct net_buf *smp_create_pdu(struct bt_smp *smp, uint8_t op, size_t len)
   4e1d4:	460e      	mov	r6, r1
	if (atomic_test_bit(smp->flags, SMP_FLAG_TIMEOUT)) {
   4e1d6:	4628      	mov	r0, r5
   4e1d8:	2104      	movs	r1, #4
   4e1da:	f7ff fe66 	bl	4deaa <atomic_test_bit>
   4e1de:	b168      	cbz	r0, 4e1fc <smp_create_pdu.constprop.0+0x2c>
		timeout = K_NO_WAIT;
   4e1e0:	2200      	movs	r2, #0
	buf = bt_l2cap_create_pdu_timeout(NULL, 0, timeout);
   4e1e2:	2100      	movs	r1, #0
		timeout = SMP_TIMEOUT;
   4e1e4:	2300      	movs	r3, #0
	buf = bt_l2cap_create_pdu_timeout(NULL, 0, timeout);
   4e1e6:	4608      	mov	r0, r1
   4e1e8:	f7fd ff89 	bl	4c0fe <bt_l2cap_create_pdu_timeout>
	if (!buf) {
   4e1ec:	4604      	mov	r4, r0
   4e1ee:	b940      	cbnz	r0, 4e202 <smp_create_pdu.constprop.0+0x32>
		atomic_set_bit(smp->flags, SMP_FLAG_TIMEOUT);
   4e1f0:	2104      	movs	r1, #4
   4e1f2:	4628      	mov	r0, r5
   4e1f4:	f7ff ffa8 	bl	4e148 <atomic_set_bit>
}
   4e1f8:	4620      	mov	r0, r4
   4e1fa:	bd70      	pop	{r4, r5, r6, pc}
		timeout = SMP_TIMEOUT;
   4e1fc:	f44f 2270 	mov.w	r2, #983040	; 0xf0000
   4e200:	e7ef      	b.n	4e1e2 <smp_create_pdu.constprop.0+0x12>
   4e202:	2101      	movs	r1, #1
   4e204:	3008      	adds	r0, #8
   4e206:	f000 fdd5 	bl	4edb4 <net_buf_simple_add>
	hdr->code = op;
   4e20a:	7006      	strb	r6, [r0, #0]
	return buf;
   4e20c:	e7f4      	b.n	4e1f8 <smp_create_pdu.constprop.0+0x28>

0004e20e <smp_send_pairing_random>:
{
   4e20e:	b538      	push	{r3, r4, r5, lr}
	rsp_buf = smp_create_pdu(smp, BT_SMP_CMD_PAIRING_RANDOM, sizeof(*req));
   4e210:	2104      	movs	r1, #4
{
   4e212:	4605      	mov	r5, r0
	rsp_buf = smp_create_pdu(smp, BT_SMP_CMD_PAIRING_RANDOM, sizeof(*req));
   4e214:	f7ff ffdc 	bl	4e1d0 <smp_create_pdu.constprop.0>
	if (!rsp_buf) {
   4e218:	4604      	mov	r4, r0
   4e21a:	b170      	cbz	r0, 4e23a <smp_send_pairing_random+0x2c>
   4e21c:	2110      	movs	r1, #16
   4e21e:	3008      	adds	r0, #8
   4e220:	f000 fdc8 	bl	4edb4 <net_buf_simple_add>
	memcpy(req->val, smp->prnd, sizeof(req->val));
   4e224:	2210      	movs	r2, #16
   4e226:	f105 0127 	add.w	r1, r5, #39	; 0x27
   4e22a:	f7fc fe26 	bl	4ae7a <memcpy>
	smp_send(smp, rsp_buf, NULL, NULL);
   4e22e:	4628      	mov	r0, r5
   4e230:	4621      	mov	r1, r4
   4e232:	f7ff feee 	bl	4e012 <smp_send.constprop.0>
	return 0;
   4e236:	2000      	movs	r0, #0
}
   4e238:	bd38      	pop	{r3, r4, r5, pc}
		return BT_SMP_ERR_UNSPECIFIED;
   4e23a:	2008      	movs	r0, #8
   4e23c:	e7fc      	b.n	4e238 <smp_send_pairing_random+0x2a>

0004e23e <sc_smp_send_dhkey_check>:
{
   4e23e:	b570      	push	{r4, r5, r6, lr}
   4e240:	460e      	mov	r6, r1
	buf = smp_create_pdu(smp, BT_SMP_DHKEY_CHECK, sizeof(*req));
   4e242:	210d      	movs	r1, #13
{
   4e244:	4605      	mov	r5, r0
	buf = smp_create_pdu(smp, BT_SMP_DHKEY_CHECK, sizeof(*req));
   4e246:	f7ff ffc3 	bl	4e1d0 <smp_create_pdu.constprop.0>
	if (!buf) {
   4e24a:	4604      	mov	r4, r0
   4e24c:	b168      	cbz	r0, 4e26a <sc_smp_send_dhkey_check+0x2c>
   4e24e:	2110      	movs	r1, #16
   4e250:	3008      	adds	r0, #8
   4e252:	f000 fdaf 	bl	4edb4 <net_buf_simple_add>
	memcpy(req->e, e, sizeof(req->e));
   4e256:	2210      	movs	r2, #16
   4e258:	4631      	mov	r1, r6
   4e25a:	f7fc fe0e 	bl	4ae7a <memcpy>
	smp_send(smp, buf, NULL, NULL);
   4e25e:	4628      	mov	r0, r5
   4e260:	4621      	mov	r1, r4
   4e262:	f7ff fed6 	bl	4e012 <smp_send.constprop.0>
	return 0;
   4e266:	2000      	movs	r0, #0
}
   4e268:	bd70      	pop	{r4, r5, r6, pc}
		return BT_SMP_ERR_UNSPECIFIED;
   4e26a:	2008      	movs	r0, #8
   4e26c:	e7fc      	b.n	4e268 <sc_smp_send_dhkey_check+0x2a>

0004e26e <compute_and_send_central_dhcheck>:
{
   4e26e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4e272:	4604      	mov	r4, r0
   4e274:	b08c      	sub	sp, #48	; 0x30
	(void)memset(r, 0, sizeof(r));
   4e276:	2210      	movs	r2, #16
   4e278:	2100      	movs	r1, #0
   4e27a:	a808      	add	r0, sp, #32
   4e27c:	f7fc fe08 	bl	4ae90 <memset>
	switch (smp->method) {
   4e280:	7a23      	ldrb	r3, [r4, #8]
   4e282:	2b05      	cmp	r3, #5
   4e284:	d821      	bhi.n	4e2ca <compute_and_send_central_dhcheck+0x5c>
   4e286:	e8df f003 	tbb	[pc, r3]
   4e28a:	0309      	.short	0x0309
   4e28c:	24200903 	.word	0x24200903
		memcpy(r, &smp->passkey, sizeof(smp->passkey));
   4e290:	2204      	movs	r2, #4
   4e292:	f104 01d8 	add.w	r1, r4, #216	; 0xd8
			memcpy(r, smp->oobd_remote->r, sizeof(r));
   4e296:	a808      	add	r0, sp, #32
   4e298:	f7fc fdef 	bl	4ae7a <memcpy>
		   &smp->chan.chan.conn->le.init_addr,
   4e29c:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
		   smp->tk)) {
   4e2a0:	f104 0247 	add.w	r2, r4, #71	; 0x47
		   &smp->chan.chan.conn->le.resp_addr, smp->mackey,
   4e2a4:	f104 06c7 	add.w	r6, r4, #199	; 0xc7
	if (smp_f5(smp->dhkey, smp->prnd, smp->rrnd,
   4e2a8:	e9cd 6201 	strd	r6, r2, [sp, #4]
   4e2ac:	f104 0727 	add.w	r7, r4, #39	; 0x27
		   &smp->chan.chan.conn->le.resp_addr, smp->mackey,
   4e2b0:	f103 0296 	add.w	r2, r3, #150	; 0x96
	if (smp_f5(smp->dhkey, smp->prnd, smp->rrnd,
   4e2b4:	f104 0837 	add.w	r8, r4, #55	; 0x37
   4e2b8:	9200      	str	r2, [sp, #0]
   4e2ba:	338f      	adds	r3, #143	; 0x8f
   4e2bc:	4642      	mov	r2, r8
   4e2be:	4639      	mov	r1, r7
   4e2c0:	f104 0097 	add.w	r0, r4, #151	; 0x97
   4e2c4:	f7e5 f82a 	bl	3331c <smp_f5>
   4e2c8:	b148      	cbz	r0, 4e2de <compute_and_send_central_dhcheck+0x70>
		return BT_SMP_ERR_UNSPECIFIED;
   4e2ca:	2008      	movs	r0, #8
}
   4e2cc:	b00c      	add	sp, #48	; 0x30
   4e2ce:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (smp->oobd_remote) {
   4e2d2:	f8d4 10e4 	ldr.w	r1, [r4, #228]	; 0xe4
   4e2d6:	2900      	cmp	r1, #0
   4e2d8:	d0e0      	beq.n	4e29c <compute_and_send_central_dhcheck+0x2e>
			memcpy(r, smp->oobd_remote->r, sizeof(r));
   4e2da:	2210      	movs	r2, #16
   4e2dc:	e7db      	b.n	4e296 <compute_and_send_central_dhcheck+0x28>
		   &smp->chan.chan.conn->le.init_addr,
   4e2de:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
		   &smp->chan.chan.conn->le.resp_addr, e)) {
   4e2e2:	f103 0296 	add.w	r2, r3, #150	; 0x96
		   &smp->chan.chan.conn->le.init_addr,
   4e2e6:	338f      	adds	r3, #143	; 0x8f
	if (smp_f6(smp->mackey, smp->prnd, smp->rrnd, r, &smp->preq[1],
   4e2e8:	ad04      	add	r5, sp, #16
   4e2ea:	9301      	str	r3, [sp, #4]
   4e2ec:	f104 030a 	add.w	r3, r4, #10
   4e2f0:	9202      	str	r2, [sp, #8]
   4e2f2:	9300      	str	r3, [sp, #0]
   4e2f4:	9503      	str	r5, [sp, #12]
   4e2f6:	ab08      	add	r3, sp, #32
   4e2f8:	4642      	mov	r2, r8
   4e2fa:	4639      	mov	r1, r7
   4e2fc:	4630      	mov	r0, r6
   4e2fe:	f7ff feb2 	bl	4e066 <smp_f6>
   4e302:	2800      	cmp	r0, #0
   4e304:	d1e1      	bne.n	4e2ca <compute_and_send_central_dhcheck+0x5c>
	atomic_set_bit(smp->allowed_cmds, BT_SMP_DHKEY_CHECK);
   4e306:	210d      	movs	r1, #13
   4e308:	4620      	mov	r0, r4
   4e30a:	f7ff ff1d 	bl	4e148 <atomic_set_bit>
	return sc_smp_send_dhkey_check(smp, e);
   4e30e:	4629      	mov	r1, r5
   4e310:	f7ff ff95 	bl	4e23e <sc_smp_send_dhkey_check>
   4e314:	e7da      	b.n	4e2cc <compute_and_send_central_dhcheck+0x5e>

0004e316 <compute_and_check_and_send_periph_dhcheck>:
{
   4e316:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   4e31a:	4604      	mov	r4, r0
   4e31c:	b091      	sub	sp, #68	; 0x44
	(void)memset(r, 0, sizeof(r));
   4e31e:	2210      	movs	r2, #16
   4e320:	2100      	movs	r1, #0
   4e322:	a80c      	add	r0, sp, #48	; 0x30
   4e324:	f7fc fdb4 	bl	4ae90 <memset>
	switch (smp->method) {
   4e328:	7a23      	ldrb	r3, [r4, #8]
   4e32a:	2b05      	cmp	r3, #5
   4e32c:	d821      	bhi.n	4e372 <compute_and_check_and_send_periph_dhcheck+0x5c>
   4e32e:	e8df f003 	tbb	[pc, r3]
   4e332:	0309      	.short	0x0309
   4e334:	25200903 	.word	0x25200903
		memcpy(r, &smp->passkey, sizeof(smp->passkey));
   4e338:	2204      	movs	r2, #4
   4e33a:	f104 01d8 	add.w	r1, r4, #216	; 0xd8
			memcpy(r, smp->oobd_remote->r, sizeof(r));
   4e33e:	a80c      	add	r0, sp, #48	; 0x30
   4e340:	f7fc fd9b 	bl	4ae7a <memcpy>
		   &smp->chan.chan.conn->le.init_addr,
   4e344:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
		   smp->tk)) {
   4e348:	f104 0247 	add.w	r2, r4, #71	; 0x47
		   &smp->chan.chan.conn->le.resp_addr, smp->mackey,
   4e34c:	f104 05c7 	add.w	r5, r4, #199	; 0xc7
	if (smp_f5(smp->dhkey, smp->rrnd, smp->prnd,
   4e350:	e9cd 5201 	strd	r5, r2, [sp, #4]
   4e354:	f104 0637 	add.w	r6, r4, #55	; 0x37
		   &smp->chan.chan.conn->le.resp_addr, smp->mackey,
   4e358:	f103 0296 	add.w	r2, r3, #150	; 0x96
	if (smp_f5(smp->dhkey, smp->rrnd, smp->prnd,
   4e35c:	f104 0727 	add.w	r7, r4, #39	; 0x27
   4e360:	9200      	str	r2, [sp, #0]
   4e362:	338f      	adds	r3, #143	; 0x8f
   4e364:	463a      	mov	r2, r7
   4e366:	4631      	mov	r1, r6
   4e368:	f104 0097 	add.w	r0, r4, #151	; 0x97
   4e36c:	f7e4 ffd6 	bl	3331c <smp_f5>
   4e370:	b150      	cbz	r0, 4e388 <compute_and_check_and_send_periph_dhcheck+0x72>
		return BT_SMP_ERR_UNSPECIFIED;
   4e372:	2508      	movs	r5, #8
}
   4e374:	4628      	mov	r0, r5
   4e376:	b011      	add	sp, #68	; 0x44
   4e378:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		if (smp->oobd_remote) {
   4e37c:	f8d4 10e4 	ldr.w	r1, [r4, #228]	; 0xe4
   4e380:	2900      	cmp	r1, #0
   4e382:	d0df      	beq.n	4e344 <compute_and_check_and_send_periph_dhcheck+0x2e>
			memcpy(r, smp->oobd_remote->r, sizeof(r));
   4e384:	2210      	movs	r2, #16
   4e386:	e7da      	b.n	4e33e <compute_and_check_and_send_periph_dhcheck+0x28>
		   &smp->chan.chan.conn->le.resp_addr,
   4e388:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
		   &smp->chan.chan.conn->le.init_addr, e)) {
   4e38c:	f103 028f 	add.w	r2, r3, #143	; 0x8f
		   &smp->chan.chan.conn->le.resp_addr,
   4e390:	3396      	adds	r3, #150	; 0x96
	if (smp_f6(smp->mackey, smp->prnd, smp->rrnd, r, &smp->prsp[1],
   4e392:	f10d 0820 	add.w	r8, sp, #32
   4e396:	9301      	str	r3, [sp, #4]
   4e398:	f104 0311 	add.w	r3, r4, #17
   4e39c:	9202      	str	r2, [sp, #8]
   4e39e:	9300      	str	r3, [sp, #0]
   4e3a0:	f8cd 800c 	str.w	r8, [sp, #12]
   4e3a4:	ab0c      	add	r3, sp, #48	; 0x30
   4e3a6:	4632      	mov	r2, r6
   4e3a8:	4639      	mov	r1, r7
   4e3aa:	4628      	mov	r0, r5
   4e3ac:	f7ff fe5b 	bl	4e066 <smp_f6>
   4e3b0:	2800      	cmp	r0, #0
   4e3b2:	d1de      	bne.n	4e372 <compute_and_check_and_send_periph_dhcheck+0x5c>
	if (smp->method == LE_SC_OOB) {
   4e3b4:	7a23      	ldrb	r3, [r4, #8]
   4e3b6:	2b05      	cmp	r3, #5
   4e3b8:	d106      	bne.n	4e3c8 <compute_and_check_and_send_periph_dhcheck+0xb2>
		if (smp->oobd_local) {
   4e3ba:	f8d4 10e0 	ldr.w	r1, [r4, #224]	; 0xe0
			memcpy(r, smp->oobd_local->r, sizeof(r));
   4e3be:	2210      	movs	r2, #16
   4e3c0:	a80c      	add	r0, sp, #48	; 0x30
		if (smp->oobd_local) {
   4e3c2:	b351      	cbz	r1, 4e41a <compute_and_check_and_send_periph_dhcheck+0x104>
			memcpy(r, smp->oobd_local->r, sizeof(r));
   4e3c4:	f7fc fd59 	bl	4ae7a <memcpy>
		   &smp->chan.chan.conn->le.init_addr,
   4e3c8:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
		   &smp->chan.chan.conn->le.resp_addr, re)) {
   4e3cc:	f103 0296 	add.w	r2, r3, #150	; 0x96
		   &smp->chan.chan.conn->le.init_addr,
   4e3d0:	338f      	adds	r3, #143	; 0x8f
	if (smp_f6(smp->mackey, smp->rrnd, smp->prnd, r, &smp->preq[1],
   4e3d2:	f10d 0910 	add.w	r9, sp, #16
   4e3d6:	9301      	str	r3, [sp, #4]
   4e3d8:	f104 030a 	add.w	r3, r4, #10
   4e3dc:	9202      	str	r2, [sp, #8]
   4e3de:	9300      	str	r3, [sp, #0]
   4e3e0:	f8cd 900c 	str.w	r9, [sp, #12]
   4e3e4:	ab0c      	add	r3, sp, #48	; 0x30
   4e3e6:	463a      	mov	r2, r7
   4e3e8:	4631      	mov	r1, r6
   4e3ea:	4628      	mov	r0, r5
   4e3ec:	f7ff fe3b 	bl	4e066 <smp_f6>
   4e3f0:	2800      	cmp	r0, #0
   4e3f2:	d1be      	bne.n	4e372 <compute_and_check_and_send_periph_dhcheck+0x5c>
	if (memcmp(smp->e, re, 16)) {
   4e3f4:	2210      	movs	r2, #16
   4e3f6:	4649      	mov	r1, r9
   4e3f8:	f104 00b7 	add.w	r0, r4, #183	; 0xb7
   4e3fc:	f7fc fd2d 	bl	4ae5a <memcmp>
   4e400:	b970      	cbnz	r0, 4e420 <compute_and_check_and_send_periph_dhcheck+0x10a>
	err = sc_smp_send_dhkey_check(smp, e);
   4e402:	4641      	mov	r1, r8
   4e404:	4620      	mov	r0, r4
   4e406:	f7ff ff1a 	bl	4e23e <sc_smp_send_dhkey_check>
	if (err) {
   4e40a:	4605      	mov	r5, r0
   4e40c:	2800      	cmp	r0, #0
   4e40e:	d1b1      	bne.n	4e374 <compute_and_check_and_send_periph_dhcheck+0x5e>
	atomic_set_bit(smp->flags, SMP_FLAG_ENC_PENDING);
   4e410:	2101      	movs	r1, #1
   4e412:	1d20      	adds	r0, r4, #4
   4e414:	f7ff fe98 	bl	4e148 <atomic_set_bit>
	return 0;
   4e418:	e7ac      	b.n	4e374 <compute_and_check_and_send_periph_dhcheck+0x5e>
			memset(r, 0, sizeof(r));
   4e41a:	f7fc fd39 	bl	4ae90 <memset>
   4e41e:	e7d3      	b.n	4e3c8 <compute_and_check_and_send_periph_dhcheck+0xb2>
		return BT_SMP_ERR_DHKEY_CHECK_FAILED;
   4e420:	250b      	movs	r5, #11
   4e422:	e7a7      	b.n	4e374 <compute_and_check_and_send_periph_dhcheck+0x5e>

0004e424 <smp_dhkey_check>:
{
   4e424:	b5f0      	push	{r4, r5, r6, r7, lr}
	    smp->chan.chan.conn->role == BT_HCI_ROLE_CENTRAL) {
   4e426:	f8d0 30ec 	ldr.w	r3, [r0, #236]	; 0xec
	struct bt_smp_dhkey_check *req = (void *)buf->data;
   4e42a:	688e      	ldr	r6, [r1, #8]
	    smp->chan.chan.conn->role == BT_HCI_ROLE_CENTRAL) {
   4e42c:	78dd      	ldrb	r5, [r3, #3]
{
   4e42e:	b091      	sub	sp, #68	; 0x44
   4e430:	4604      	mov	r4, r0
	if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
   4e432:	2d00      	cmp	r5, #0
   4e434:	d15b      	bne.n	4e4ee <smp_dhkey_check+0xca>
		(void)memset(r, 0, sizeof(r));
   4e436:	2210      	movs	r2, #16
   4e438:	4629      	mov	r1, r5
   4e43a:	a80c      	add	r0, sp, #48	; 0x30
   4e43c:	f7fc fd28 	bl	4ae90 <memset>
		switch (smp->method) {
   4e440:	7a23      	ldrb	r3, [r4, #8]
   4e442:	2b05      	cmp	r3, #5
   4e444:	d820      	bhi.n	4e488 <smp_dhkey_check+0x64>
   4e446:	e8df f003 	tbb	[pc, r3]
   4e44a:	0309      	.short	0x0309
   4e44c:	231f0903 	.word	0x231f0903
			memcpy(r, &smp->passkey, sizeof(smp->passkey));
   4e450:	2204      	movs	r2, #4
   4e452:	f104 01d8 	add.w	r1, r4, #216	; 0xd8
				memcpy(r, smp->oobd_local->r, sizeof(r));
   4e456:	a80c      	add	r0, sp, #48	; 0x30
   4e458:	f7fc fd0f 	bl	4ae7a <memcpy>
			   &smp->chan.chan.conn->le.resp_addr,
   4e45c:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
			   &smp->chan.chan.conn->le.init_addr, e)) {
   4e460:	f103 028f 	add.w	r2, r3, #143	; 0x8f
			   &smp->chan.chan.conn->le.resp_addr,
   4e464:	3396      	adds	r3, #150	; 0x96
		if (smp_f6(smp->mackey, smp->rrnd, smp->prnd, r, &smp->prsp[1],
   4e466:	af08      	add	r7, sp, #32
   4e468:	9301      	str	r3, [sp, #4]
   4e46a:	f104 0311 	add.w	r3, r4, #17
   4e46e:	9202      	str	r2, [sp, #8]
   4e470:	9300      	str	r3, [sp, #0]
   4e472:	9703      	str	r7, [sp, #12]
   4e474:	ab0c      	add	r3, sp, #48	; 0x30
   4e476:	f104 0227 	add.w	r2, r4, #39	; 0x27
   4e47a:	f104 0137 	add.w	r1, r4, #55	; 0x37
   4e47e:	f104 00c7 	add.w	r0, r4, #199	; 0xc7
   4e482:	f7ff fdf0 	bl	4e066 <smp_f6>
   4e486:	b148      	cbz	r0, 4e49c <smp_dhkey_check+0x78>
			return BT_SMP_ERR_UNSPECIFIED;
   4e488:	2508      	movs	r5, #8
}
   4e48a:	4628      	mov	r0, r5
   4e48c:	b011      	add	sp, #68	; 0x44
   4e48e:	bdf0      	pop	{r4, r5, r6, r7, pc}
			if (smp->oobd_local) {
   4e490:	f8d4 10e0 	ldr.w	r1, [r4, #224]	; 0xe0
   4e494:	2900      	cmp	r1, #0
   4e496:	d0e1      	beq.n	4e45c <smp_dhkey_check+0x38>
				memcpy(r, smp->oobd_local->r, sizeof(r));
   4e498:	2210      	movs	r2, #16
   4e49a:	e7dc      	b.n	4e456 <smp_dhkey_check+0x32>
		if (memcmp(e, req->e, 16)) {
   4e49c:	4631      	mov	r1, r6
   4e49e:	2210      	movs	r2, #16
   4e4a0:	4638      	mov	r0, r7
   4e4a2:	f7fc fcda 	bl	4ae5a <memcmp>
   4e4a6:	4606      	mov	r6, r0
   4e4a8:	b9f8      	cbnz	r0, 4e4ea <smp_dhkey_check+0xc6>
	return MIN(req->max_key_size, rsp->max_key_size);
   4e4aa:	7d23      	ldrb	r3, [r4, #20]
   4e4ac:	7b67      	ldrb	r7, [r4, #13]
		(void)memset(ediv, 0, sizeof(ediv));
   4e4ae:	4601      	mov	r1, r0
	return MIN(req->max_key_size, rsp->max_key_size);
   4e4b0:	429f      	cmp	r7, r3
		(void)memset(ediv, 0, sizeof(ediv));
   4e4b2:	f04f 0202 	mov.w	r2, #2
   4e4b6:	a805      	add	r0, sp, #20
	return MIN(req->max_key_size, rsp->max_key_size);
   4e4b8:	bf28      	it	cs
   4e4ba:	461f      	movcs	r7, r3
		(void)memset(ediv, 0, sizeof(ediv));
   4e4bc:	f7fc fce8 	bl	4ae90 <memset>
		(void)memset(rand, 0, sizeof(rand));
   4e4c0:	2208      	movs	r2, #8
   4e4c2:	4631      	mov	r1, r6
   4e4c4:	a806      	add	r0, sp, #24
   4e4c6:	f7fc fce3 	bl	4ae90 <memset>
		if (bt_conn_le_start_encryption(smp->chan.chan.conn, rand, ediv,
   4e4ca:	9700      	str	r7, [sp, #0]
   4e4cc:	f8d4 00ec 	ldr.w	r0, [r4, #236]	; 0xec
   4e4d0:	f104 0347 	add.w	r3, r4, #71	; 0x47
   4e4d4:	aa05      	add	r2, sp, #20
   4e4d6:	a906      	add	r1, sp, #24
   4e4d8:	f7fd fcb9 	bl	4be4e <bt_conn_le_start_encryption>
   4e4dc:	2800      	cmp	r0, #0
   4e4de:	dbd3      	blt.n	4e488 <smp_dhkey_check+0x64>
		atomic_set_bit(smp->flags, SMP_FLAG_ENC_PENDING);
   4e4e0:	2101      	movs	r1, #1
   4e4e2:	1d20      	adds	r0, r4, #4
   4e4e4:	f7ff fe30 	bl	4e148 <atomic_set_bit>
		return 0;
   4e4e8:	e7cf      	b.n	4e48a <smp_dhkey_check+0x66>
			return BT_SMP_ERR_DHKEY_CHECK_FAILED;
   4e4ea:	250b      	movs	r5, #11
   4e4ec:	e7cd      	b.n	4e48a <smp_dhkey_check+0x66>
	if (smp->chan.chan.conn->role == BT_HCI_ROLE_PERIPHERAL) {
   4e4ee:	2d01      	cmp	r5, #1
   4e4f0:	d113      	bne.n	4e51a <smp_dhkey_check+0xf6>
		atomic_clear_bit(smp->flags, SMP_FLAG_DHCHECK_WAIT);
   4e4f2:	1d05      	adds	r5, r0, #4
   4e4f4:	2110      	movs	r1, #16
   4e4f6:	4628      	mov	r0, r5
   4e4f8:	f7ff fd5c 	bl	4dfb4 <atomic_clear_bit>
		memcpy(smp->e, req->e, sizeof(smp->e));
   4e4fc:	4631      	mov	r1, r6
   4e4fe:	2210      	movs	r2, #16
   4e500:	f104 00b7 	add.w	r0, r4, #183	; 0xb7
   4e504:	f7fc fcb9 	bl	4ae7a <memcpy>
		if (atomic_test_bit(smp->flags, SMP_FLAG_DHKEY_PENDING)) {
   4e508:	2107      	movs	r1, #7
   4e50a:	4628      	mov	r0, r5
   4e50c:	f7ff fccd 	bl	4deaa <atomic_test_bit>
   4e510:	b128      	cbz	r0, 4e51e <smp_dhkey_check+0xfa>
			atomic_set_bit(smp->flags, SMP_FLAG_DHKEY_SEND);
   4e512:	2109      	movs	r1, #9
   4e514:	4628      	mov	r0, r5
   4e516:	f7ff fe17 	bl	4e148 <atomic_set_bit>
			return 0;
   4e51a:	2500      	movs	r5, #0
   4e51c:	e7b5      	b.n	4e48a <smp_dhkey_check+0x66>
		if (atomic_test_bit(smp->flags, SMP_FLAG_USER)) {
   4e51e:	210a      	movs	r1, #10
   4e520:	4628      	mov	r0, r5
   4e522:	f7ff fcc2 	bl	4deaa <atomic_test_bit>
   4e526:	2800      	cmp	r0, #0
   4e528:	d1f3      	bne.n	4e512 <smp_dhkey_check+0xee>
		return compute_and_check_and_send_periph_dhcheck(smp);
   4e52a:	4620      	mov	r0, r4
}
   4e52c:	b011      	add	sp, #68	; 0x44
   4e52e:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		return compute_and_check_and_send_periph_dhcheck(smp);
   4e532:	f7ff bef0 	b.w	4e316 <compute_and_check_and_send_periph_dhcheck>

0004e536 <smp_pairing_confirm>:
{
   4e536:	b570      	push	{r4, r5, r6, lr}
	atomic_clear_bit(smp->flags, SMP_FLAG_DISPLAY);
   4e538:	1d05      	adds	r5, r0, #4
	struct bt_smp_pairing_confirm *req = (void *)buf->data;
   4e53a:	688e      	ldr	r6, [r1, #8]
{
   4e53c:	4604      	mov	r4, r0
	atomic_clear_bit(smp->flags, SMP_FLAG_DISPLAY);
   4e53e:	210b      	movs	r1, #11
   4e540:	4628      	mov	r0, r5
   4e542:	f7ff fd37 	bl	4dfb4 <atomic_clear_bit>
	memcpy(smp->pcnf, req->val, sizeof(smp->pcnf));
   4e546:	2210      	movs	r2, #16
   4e548:	4631      	mov	r1, r6
   4e54a:	f104 0017 	add.w	r0, r4, #23
   4e54e:	f7fc fc94 	bl	4ae7a <memcpy>
	    smp->chan.chan.conn->role == BT_HCI_ROLE_CENTRAL) {
   4e552:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
	if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
   4e556:	78db      	ldrb	r3, [r3, #3]
   4e558:	b93b      	cbnz	r3, 4e56a <smp_pairing_confirm+0x34>
		atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_PAIRING_RANDOM);
   4e55a:	4620      	mov	r0, r4
   4e55c:	2104      	movs	r1, #4
   4e55e:	f7ff fdf3 	bl	4e148 <atomic_set_bit>
}
   4e562:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return smp_send_pairing_random(smp);
   4e566:	f7ff be52 	b.w	4e20e <smp_send_pairing_random>
	switch (smp->method) {
   4e56a:	7a23      	ldrb	r3, [r4, #8]
   4e56c:	2b01      	cmp	r3, #1
   4e56e:	d009      	beq.n	4e584 <smp_pairing_confirm+0x4e>
   4e570:	2b02      	cmp	r3, #2
   4e572:	d113      	bne.n	4e59c <smp_pairing_confirm+0x66>
		atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_PAIRING_RANDOM);
   4e574:	4620      	mov	r0, r4
   4e576:	2104      	movs	r1, #4
   4e578:	f7ff fde6 	bl	4e148 <atomic_set_bit>
}
   4e57c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return smp_send_pairing_confirm(smp);
   4e580:	f7e5 b8d6 	b.w	33730 <smp_send_pairing_confirm>
		if (atomic_test_bit(smp->flags, SMP_FLAG_USER)) {
   4e584:	210a      	movs	r1, #10
   4e586:	4628      	mov	r0, r5
   4e588:	f7ff fc8f 	bl	4deaa <atomic_test_bit>
   4e58c:	2800      	cmp	r0, #0
   4e58e:	d0f1      	beq.n	4e574 <smp_pairing_confirm+0x3e>
			atomic_set_bit(smp->flags, SMP_FLAG_CFM_DELAYED);
   4e590:	4628      	mov	r0, r5
   4e592:	2100      	movs	r1, #0
   4e594:	f7ff fdd8 	bl	4e148 <atomic_set_bit>
			return 0;
   4e598:	2000      	movs	r0, #0
}
   4e59a:	bd70      	pop	{r4, r5, r6, pc}
	switch (smp->method) {
   4e59c:	2008      	movs	r0, #8
   4e59e:	e7fc      	b.n	4e59a <smp_pairing_confirm+0x64>

0004e5a0 <smp_central_ident>:
static uint8_t smp_central_ident(struct bt_smp *smp, struct net_buf *buf)
   4e5a0:	2007      	movs	r0, #7
   4e5a2:	4770      	bx	lr

0004e5a4 <atomic_test_and_clear_bit>:
{
   4e5a4:	b530      	push	{r4, r5, lr}
	atomic_val_t mask = ATOMIC_MASK(bit);
   4e5a6:	2301      	movs	r3, #1
   4e5a8:	fa03 f101 	lsl.w	r1, r3, r1
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   4e5ac:	43ca      	mvns	r2, r1
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   4e5ae:	f3bf 8f5b 	dmb	ish
   4e5b2:	e850 3f00 	ldrex	r3, [r0]
   4e5b6:	ea03 0402 	and.w	r4, r3, r2
   4e5ba:	e840 4500 	strex	r5, r4, [r0]
   4e5be:	2d00      	cmp	r5, #0
   4e5c0:	d1f7      	bne.n	4e5b2 <atomic_test_and_clear_bit+0xe>
   4e5c2:	f3bf 8f5b 	dmb	ish
	return (old & mask) != 0;
   4e5c6:	4219      	tst	r1, r3
}
   4e5c8:	bf14      	ite	ne
   4e5ca:	2001      	movne	r0, #1
   4e5cc:	2000      	moveq	r0, #0
   4e5ce:	bd30      	pop	{r4, r5, pc}

0004e5d0 <smp_reset>:
{
   4e5d0:	b570      	push	{r4, r5, r6, lr}
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   4e5d2:	1d03      	adds	r3, r0, #4
   4e5d4:	4604      	mov	r4, r0
   4e5d6:	2500      	movs	r5, #0
	struct bt_conn *conn = smp->chan.chan.conn;
   4e5d8:	f8d0 60ec 	ldr.w	r6, [r0, #236]	; 0xec
   4e5dc:	f3bf 8f5b 	dmb	ish
   4e5e0:	e853 2f00 	ldrex	r2, [r3]
   4e5e4:	e843 5100 	strex	r1, r5, [r3]
   4e5e8:	2900      	cmp	r1, #0
   4e5ea:	d1f9      	bne.n	4e5e0 <smp_reset+0x10>
   4e5ec:	f3bf 8f5b 	dmb	ish
	(void)k_work_cancel_delayable(&smp->work);
   4e5f0:	f504 70bc 	add.w	r0, r4, #376	; 0x178
   4e5f4:	f001 fd14 	bl	50020 <k_work_cancel_delayable>
	smp->method = JUST_WORKS;
   4e5f8:	7225      	strb	r5, [r4, #8]
   4e5fa:	f3bf 8f5b 	dmb	ish
   4e5fe:	e854 3f00 	ldrex	r3, [r4]
   4e602:	e844 5200 	strex	r2, r5, [r4]
   4e606:	2a00      	cmp	r2, #0
   4e608:	d1f9      	bne.n	4e5fe <smp_reset+0x2e>
   4e60a:	f3bf 8f5b 	dmb	ish
	if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
   4e60e:	78f3      	ldrb	r3, [r6, #3]
   4e610:	b92b      	cbnz	r3, 4e61e <smp_reset+0x4e>
		atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_SECURITY_REQUEST);
   4e612:	210b      	movs	r1, #11
		atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_PAIRING_REQ);
   4e614:	4620      	mov	r0, r4
}
   4e616:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_PAIRING_REQ);
   4e61a:	f7ff bd95 	b.w	4e148 <atomic_set_bit>
   4e61e:	2101      	movs	r1, #1
   4e620:	e7f8      	b.n	4e614 <smp_reset+0x44>

0004e622 <bt_smp_request_ltk>:
{
   4e622:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4e626:	f8dd 802c 	ldr.w	r8, [sp, #44]	; 0x2c
   4e62a:	f8bd 9028 	ldrh.w	r9, [sp, #40]	; 0x28
   4e62e:	4604      	mov	r4, r0
   4e630:	4692      	mov	sl, r2
   4e632:	461f      	mov	r7, r3
	smp = smp_chan_get(conn);
   4e634:	f7ff fc32 	bl	4de9c <smp_chan_get>
	if (!smp) {
   4e638:	4605      	mov	r5, r0
   4e63a:	2800      	cmp	r0, #0
   4e63c:	d05a      	beq.n	4e6f4 <bt_smp_request_ltk+0xd2>
	    atomic_test_bit(smp->flags, SMP_FLAG_PAIRING) &&
   4e63e:	1d06      	adds	r6, r0, #4
	if (ediv == 0U && rand == 0U &&
   4e640:	f1b9 0f00 	cmp.w	r9, #0
   4e644:	d127      	bne.n	4e696 <bt_smp_request_ltk+0x74>
   4e646:	ea5a 0307 	orrs.w	r3, sl, r7
   4e64a:	d124      	bne.n	4e696 <bt_smp_request_ltk+0x74>
	    atomic_test_bit(smp->flags, SMP_FLAG_PAIRING) &&
   4e64c:	2103      	movs	r1, #3
   4e64e:	4630      	mov	r0, r6
   4e650:	f7ff fc2b 	bl	4deaa <atomic_test_bit>
	if (ediv == 0U && rand == 0U &&
   4e654:	b3d0      	cbz	r0, 4e6cc <bt_smp_request_ltk+0xaa>
	    atomic_test_bit(smp->flags, SMP_FLAG_ENC_PENDING)) {
   4e656:	2101      	movs	r1, #1
   4e658:	4630      	mov	r0, r6
   4e65a:	f7ff fc26 	bl	4deaa <atomic_test_bit>
	    atomic_test_bit(smp->flags, SMP_FLAG_PAIRING) &&
   4e65e:	b3a8      	cbz	r0, 4e6cc <bt_smp_request_ltk+0xaa>
	return MIN(req->max_key_size, rsp->max_key_size);
   4e660:	7d2c      	ldrb	r4, [r5, #20]
   4e662:	7b6b      	ldrb	r3, [r5, #13]
   4e664:	429c      	cmp	r4, r3
   4e666:	bf28      	it	cs
   4e668:	461c      	movcs	r4, r3
		memcpy(ltk, smp->tk, enc_size);
   4e66a:	4622      	mov	r2, r4
   4e66c:	f105 0147 	add.w	r1, r5, #71	; 0x47
		memcpy(ltk, conn->le.keys->ltk.val, enc_size);
   4e670:	4640      	mov	r0, r8
   4e672:	f7fc fc02 	bl	4ae7a <memcpy>
		if (enc_size < BT_SMP_MAX_ENC_KEY_SIZE) {
   4e676:	2c0f      	cmp	r4, #15
   4e678:	d806      	bhi.n	4e688 <bt_smp_request_ltk+0x66>
			(void)memset(ltk + enc_size, 0,
   4e67a:	f1c4 0210 	rsb	r2, r4, #16
   4e67e:	2100      	movs	r1, #0
   4e680:	eb08 0004 	add.w	r0, r8, r4
   4e684:	f7fc fc04 	bl	4ae90 <memset>
		atomic_set_bit(smp->flags, SMP_FLAG_ENC_PENDING);
   4e688:	4630      	mov	r0, r6
   4e68a:	2101      	movs	r1, #1
   4e68c:	f7ff fd5c 	bl	4e148 <atomic_set_bit>
		return true;
   4e690:	2001      	movs	r0, #1
}
   4e692:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (!conn->le.keys) {
   4e696:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
   4e69a:	b9f3      	cbnz	r3, 4e6da <bt_smp_request_ltk+0xb8>
					     &conn->le.dst);
   4e69c:	f104 0b88 	add.w	fp, r4, #136	; 0x88
		conn->le.keys = bt_keys_find(BT_KEYS_LTK_P256, conn->id,
   4e6a0:	7a21      	ldrb	r1, [r4, #8]
   4e6a2:	465a      	mov	r2, fp
   4e6a4:	2020      	movs	r0, #32
   4e6a6:	f7e5 fdf9 	bl	3429c <bt_keys_find>
   4e6aa:	f8c4 00b4 	str.w	r0, [r4, #180]	; 0xb4
		if (!conn->le.keys) {
   4e6ae:	b930      	cbnz	r0, 4e6be <bt_smp_request_ltk+0x9c>
			conn->le.keys = bt_keys_find(BT_KEYS_PERIPH_LTK,
   4e6b0:	7a21      	ldrb	r1, [r4, #8]
   4e6b2:	465a      	mov	r2, fp
   4e6b4:	2001      	movs	r0, #1
   4e6b6:	f7e5 fdf1 	bl	3429c <bt_keys_find>
   4e6ba:	f8c4 00b4 	str.w	r0, [r4, #180]	; 0xb4
	if (ediv == 0U && rand == 0U &&
   4e6be:	f1b9 0f00 	cmp.w	r9, #0
   4e6c2:	d10a      	bne.n	4e6da <bt_smp_request_ltk+0xb8>
   4e6c4:	ea5a 0707 	orrs.w	r7, sl, r7
   4e6c8:	d004      	beq.n	4e6d4 <bt_smp_request_ltk+0xb2>
   4e6ca:	e006      	b.n	4e6da <bt_smp_request_ltk+0xb8>
	if (!conn->le.keys) {
   4e6cc:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
   4e6d0:	2b00      	cmp	r3, #0
   4e6d2:	d0e3      	beq.n	4e69c <bt_smp_request_ltk+0x7a>
	    conn->le.keys && (conn->le.keys->keys & BT_KEYS_LTK_P256)) {
   4e6d4:	f8d4 10b4 	ldr.w	r1, [r4, #180]	; 0xb4
	if (ediv == 0U && rand == 0U &&
   4e6d8:	b971      	cbnz	r1, 4e6f8 <bt_smp_request_ltk+0xd6>
	if (atomic_test_bit(smp->flags, SMP_FLAG_SEC_REQ)) {
   4e6da:	210f      	movs	r1, #15
   4e6dc:	4630      	mov	r0, r6
   4e6de:	f7ff fbe4 	bl	4deaa <atomic_test_bit>
   4e6e2:	b120      	cbz	r0, 4e6ee <bt_smp_request_ltk+0xcc>
		bt_conn_security_changed(conn, BT_HCI_ERR_PIN_OR_KEY_MISSING,
   4e6e4:	2202      	movs	r2, #2
   4e6e6:	2106      	movs	r1, #6
   4e6e8:	4620      	mov	r0, r4
   4e6ea:	f7e1 fcf5 	bl	300d8 <bt_conn_security_changed>
	smp_reset(smp);
   4e6ee:	4628      	mov	r0, r5
   4e6f0:	f7ff ff6e 	bl	4e5d0 <smp_reset>
		return false;
   4e6f4:	2000      	movs	r0, #0
   4e6f6:	e7cc      	b.n	4e692 <bt_smp_request_ltk+0x70>
	    conn->le.keys && (conn->le.keys->keys & BT_KEYS_LTK_P256)) {
   4e6f8:	89cb      	ldrh	r3, [r1, #14]
   4e6fa:	069b      	lsls	r3, r3, #26
   4e6fc:	d5ed      	bpl.n	4e6da <bt_smp_request_ltk+0xb8>
		enc_size = conn->le.keys->enc_size;
   4e6fe:	7b0c      	ldrb	r4, [r1, #12]
		memcpy(ltk, conn->le.keys->ltk.val, enc_size);
   4e700:	311a      	adds	r1, #26
   4e702:	4622      	mov	r2, r4
   4e704:	e7b4      	b.n	4e670 <bt_smp_request_ltk+0x4e>

0004e706 <bt_smp_sign>:
int bt_smp_sign(struct bt_conn *conn, struct net_buf *buf)
   4e706:	f06f 0085 	mvn.w	r0, #133	; 0x85
   4e70a:	4770      	bx	lr

0004e70c <bt_smp_start_security>:
{
   4e70c:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
	switch (conn->role) {
   4e710:	78c6      	ldrb	r6, [r0, #3]
{
   4e712:	4604      	mov	r4, r0
	switch (conn->role) {
   4e714:	b13e      	cbz	r6, 4e726 <bt_smp_start_security+0x1a>
   4e716:	2e01      	cmp	r6, #1
   4e718:	d03e      	beq.n	4e798 <bt_smp_start_security+0x8c>
		return -EIO;
   4e71a:	f06f 0415 	mvn.w	r4, #21
}
   4e71e:	4620      	mov	r0, r4
   4e720:	b003      	add	sp, #12
   4e722:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		smp = smp_chan_get(conn);
   4e726:	f7ff fbb9 	bl	4de9c <smp_chan_get>
		if (!smp) {
   4e72a:	4605      	mov	r5, r0
   4e72c:	b910      	cbnz	r0, 4e734 <bt_smp_start_security+0x28>
			return -ENOTCONN;
   4e72e:	f06f 047f 	mvn.w	r4, #127	; 0x7f
   4e732:	e7f4      	b.n	4e71e <bt_smp_start_security+0x12>
		if (atomic_test_bit(smp->flags, SMP_FLAG_PAIRING)) {
   4e734:	1d06      	adds	r6, r0, #4
   4e736:	2103      	movs	r1, #3
   4e738:	4630      	mov	r0, r6
   4e73a:	f7ff fbb6 	bl	4deaa <atomic_test_bit>
   4e73e:	b110      	cbz	r0, 4e746 <bt_smp_start_security+0x3a>
			return -EBUSY;
   4e740:	f06f 040f 	mvn.w	r4, #15
   4e744:	e7eb      	b.n	4e71e <bt_smp_start_security+0x12>
		if (atomic_test_bit(smp->flags, SMP_FLAG_ENC_PENDING)) {
   4e746:	2101      	movs	r1, #1
   4e748:	4630      	mov	r0, r6
   4e74a:	f7ff fbae 	bl	4deaa <atomic_test_bit>
   4e74e:	2800      	cmp	r0, #0
   4e750:	d1f6      	bne.n	4e740 <bt_smp_start_security+0x34>
		if (!smp_keys_check(conn)) {
   4e752:	4620      	mov	r0, r4
   4e754:	f7ff fbb2 	bl	4debc <smp_keys_check>
   4e758:	b928      	cbnz	r0, 4e766 <bt_smp_start_security+0x5a>
			return smp_send_pairing_req(conn);
   4e75a:	4620      	mov	r0, r4
}
   4e75c:	b003      	add	sp, #12
   4e75e:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
			return smp_send_pairing_req(conn);
   4e762:	f7e4 bed3 	b.w	3350c <smp_send_pairing_req>
						  conn->le.keys->ltk.rand,
   4e766:	f8d4 10b4 	ldr.w	r1, [r4, #180]	; 0xb4
		err = bt_conn_le_start_encryption(conn,
   4e76a:	7b0b      	ldrb	r3, [r1, #12]
   4e76c:	9300      	str	r3, [sp, #0]
   4e76e:	f101 0218 	add.w	r2, r1, #24
   4e772:	f101 031a 	add.w	r3, r1, #26
   4e776:	4620      	mov	r0, r4
   4e778:	3110      	adds	r1, #16
   4e77a:	f7fd fb68 	bl	4be4e <bt_conn_le_start_encryption>
		if (err) {
   4e77e:	4604      	mov	r4, r0
   4e780:	2800      	cmp	r0, #0
   4e782:	d1cc      	bne.n	4e71e <bt_smp_start_security+0x12>
		atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_SECURITY_REQUEST);
   4e784:	210b      	movs	r1, #11
   4e786:	4628      	mov	r0, r5
   4e788:	f7ff fcde 	bl	4e148 <atomic_set_bit>
		atomic_set_bit(smp->flags, SMP_FLAG_ENC_PENDING);
   4e78c:	2101      	movs	r1, #1
   4e78e:	4630      	mov	r0, r6
	atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_PAIRING_REQ);
   4e790:	f7ff fcda 	bl	4e148 <atomic_set_bit>
	return 0;
   4e794:	2400      	movs	r4, #0
   4e796:	e7c2      	b.n	4e71e <bt_smp_start_security+0x12>
	smp = smp_chan_get(conn);
   4e798:	f7ff fb80 	bl	4de9c <smp_chan_get>
	if (!smp) {
   4e79c:	4605      	mov	r5, r0
   4e79e:	2800      	cmp	r0, #0
   4e7a0:	d0c5      	beq.n	4e72e <bt_smp_start_security+0x22>
	if (atomic_test_bit(smp->flags, SMP_FLAG_TIMEOUT)) {
   4e7a2:	f100 0804 	add.w	r8, r0, #4
   4e7a6:	2104      	movs	r1, #4
   4e7a8:	4640      	mov	r0, r8
   4e7aa:	f7ff fb7e 	bl	4deaa <atomic_test_bit>
   4e7ae:	2800      	cmp	r0, #0
   4e7b0:	d151      	bne.n	4e856 <bt_smp_start_security+0x14a>
	if (atomic_test_bit(smp->flags, SMP_FLAG_PAIRING)) {
   4e7b2:	2103      	movs	r1, #3
   4e7b4:	4640      	mov	r0, r8
   4e7b6:	f7ff fb78 	bl	4deaa <atomic_test_bit>
   4e7ba:	2800      	cmp	r0, #0
   4e7bc:	d1c0      	bne.n	4e740 <bt_smp_start_security+0x34>
	if (atomic_test_bit(smp->flags, SMP_FLAG_ENC_PENDING)) {
   4e7be:	4631      	mov	r1, r6
   4e7c0:	4640      	mov	r0, r8
   4e7c2:	f7ff fb72 	bl	4deaa <atomic_test_bit>
   4e7c6:	2800      	cmp	r0, #0
   4e7c8:	d1ba      	bne.n	4e740 <bt_smp_start_security+0x34>
	if (!(sec_level_reachable(smp) || smp_keys_check(conn))) {
   4e7ca:	4628      	mov	r0, r5
   4e7cc:	f7e4 fd40 	bl	33250 <sec_level_reachable>
   4e7d0:	b168      	cbz	r0, 4e7ee <bt_smp_start_security+0xe2>
	if (!conn->le.keys) {
   4e7d2:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
   4e7d6:	b983      	cbnz	r3, 4e7fa <bt_smp_start_security+0xee>
		conn->le.keys = bt_keys_get_addr(conn->id, &conn->le.dst);
   4e7d8:	7a20      	ldrb	r0, [r4, #8]
   4e7da:	f104 0188 	add.w	r1, r4, #136	; 0x88
   4e7de:	f7e5 fcdd 	bl	3419c <bt_keys_get_addr>
   4e7e2:	f8c4 00b4 	str.w	r0, [r4, #180]	; 0xb4
		if (!conn->le.keys) {
   4e7e6:	b940      	cbnz	r0, 4e7fa <bt_smp_start_security+0xee>
			return -ENOMEM;
   4e7e8:	f06f 040b 	mvn.w	r4, #11
   4e7ec:	e797      	b.n	4e71e <bt_smp_start_security+0x12>
	if (!(sec_level_reachable(smp) || smp_keys_check(conn))) {
   4e7ee:	4620      	mov	r0, r4
   4e7f0:	f7ff fb64 	bl	4debc <smp_keys_check>
   4e7f4:	2800      	cmp	r0, #0
   4e7f6:	d1ec      	bne.n	4e7d2 <bt_smp_start_security+0xc6>
   4e7f8:	e78f      	b.n	4e71a <bt_smp_start_security+0xe>
	if (smp_init(smp) != 0) {
   4e7fa:	4628      	mov	r0, r5
   4e7fc:	f7e4 fe54 	bl	334a8 <smp_init>
   4e800:	4607      	mov	r7, r0
   4e802:	b110      	cbz	r0, 4e80a <bt_smp_start_security+0xfe>
		return -ENOBUFS;
   4e804:	f06f 0468 	mvn.w	r4, #104	; 0x68
   4e808:	e789      	b.n	4e71e <bt_smp_start_security+0x12>
	req_buf = smp_create_pdu(smp, BT_SMP_CMD_SECURITY_REQUEST,
   4e80a:	210b      	movs	r1, #11
   4e80c:	4628      	mov	r0, r5
   4e80e:	f7ff fcdf 	bl	4e1d0 <smp_create_pdu.constprop.0>
	if (!req_buf) {
   4e812:	4606      	mov	r6, r0
   4e814:	2800      	cmp	r0, #0
   4e816:	d0f5      	beq.n	4e804 <bt_smp_start_security+0xf8>
   4e818:	2101      	movs	r1, #1
   4e81a:	3008      	adds	r0, #8
   4e81c:	f000 faca 	bl	4edb4 <net_buf_simple_add>
	req->auth_req = get_auth(smp, BT_SMP_AUTH_DEFAULT);
   4e820:	2109      	movs	r1, #9
   4e822:	4681      	mov	r9, r0
   4e824:	4628      	mov	r0, r5
   4e826:	f7e4 fcd3 	bl	331d0 <get_auth>
   4e82a:	463b      	mov	r3, r7
   4e82c:	f889 0000 	strb.w	r0, [r9]
   4e830:	4632      	mov	r2, r6
   4e832:	4620      	mov	r0, r4
   4e834:	9700      	str	r7, [sp, #0]
   4e836:	2106      	movs	r1, #6
   4e838:	f7fd fc64 	bl	4c104 <bt_l2cap_send_cb>
	if (err) {
   4e83c:	4604      	mov	r4, r0
   4e83e:	b118      	cbz	r0, 4e848 <bt_smp_start_security+0x13c>
		net_buf_unref(req_buf);
   4e840:	4630      	mov	r0, r6
   4e842:	f7f4 f801 	bl	42848 <net_buf_unref>
		return err;
   4e846:	e76a      	b.n	4e71e <bt_smp_start_security+0x12>
	atomic_set_bit(smp->flags, SMP_FLAG_SEC_REQ);
   4e848:	210f      	movs	r1, #15
   4e84a:	4640      	mov	r0, r8
   4e84c:	f7ff fc7c 	bl	4e148 <atomic_set_bit>
	atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_PAIRING_REQ);
   4e850:	2101      	movs	r1, #1
   4e852:	4628      	mov	r0, r5
   4e854:	e79c      	b.n	4e790 <bt_smp_start_security+0x84>
		return -EIO;
   4e856:	f06f 0404 	mvn.w	r4, #4
   4e85a:	e760      	b.n	4e71e <bt_smp_start_security+0x12>

0004e85c <smp_error>:
	if (atomic_test_bit(smp->flags, SMP_FLAG_PAIRING) ||
   4e85c:	1d03      	adds	r3, r0, #4
{
   4e85e:	b573      	push	{r0, r1, r4, r5, r6, lr}
   4e860:	4605      	mov	r5, r0
   4e862:	460e      	mov	r6, r1
	if (atomic_test_bit(smp->flags, SMP_FLAG_PAIRING) ||
   4e864:	4618      	mov	r0, r3
   4e866:	2103      	movs	r1, #3
   4e868:	f7ff fb1f 	bl	4deaa <atomic_test_bit>
   4e86c:	b1d0      	cbz	r0, 4e8a4 <smp_error+0x48>
		smp_pairing_complete(smp, reason);
   4e86e:	4631      	mov	r1, r6
   4e870:	4628      	mov	r0, r5
   4e872:	f7e5 fb07 	bl	33e84 <smp_pairing_complete>
	buf = smp_create_pdu(smp, BT_SMP_CMD_PAIRING_FAIL, sizeof(*rsp));
   4e876:	2105      	movs	r1, #5
   4e878:	4628      	mov	r0, r5
   4e87a:	f7ff fca9 	bl	4e1d0 <smp_create_pdu.constprop.0>
	if (!buf) {
   4e87e:	4604      	mov	r4, r0
   4e880:	b308      	cbz	r0, 4e8c6 <smp_error+0x6a>
   4e882:	2101      	movs	r1, #1
   4e884:	3008      	adds	r0, #8
   4e886:	f000 fa95 	bl	4edb4 <net_buf_simple_add>
   4e88a:	2300      	movs	r3, #0
	rsp->reason = reason;
   4e88c:	7006      	strb	r6, [r0, #0]
   4e88e:	9300      	str	r3, [sp, #0]
   4e890:	f8d5 00ec 	ldr.w	r0, [r5, #236]	; 0xec
   4e894:	4622      	mov	r2, r4
   4e896:	2106      	movs	r1, #6
   4e898:	f7fd fc34 	bl	4c104 <bt_l2cap_send_cb>
	if (bt_l2cap_send(smp->chan.chan.conn, BT_L2CAP_CID_SMP, buf)) {
   4e89c:	b978      	cbnz	r0, 4e8be <smp_error+0x62>
	return 0;
   4e89e:	2000      	movs	r0, #0
}
   4e8a0:	b002      	add	sp, #8
   4e8a2:	bd70      	pop	{r4, r5, r6, pc}
	    atomic_test_bit(smp->flags, SMP_FLAG_ENC_PENDING) ||
   4e8a4:	2101      	movs	r1, #1
   4e8a6:	4618      	mov	r0, r3
   4e8a8:	f7ff faff 	bl	4deaa <atomic_test_bit>
	if (atomic_test_bit(smp->flags, SMP_FLAG_PAIRING) ||
   4e8ac:	2800      	cmp	r0, #0
   4e8ae:	d1de      	bne.n	4e86e <smp_error+0x12>
	    atomic_test_bit(smp->flags, SMP_FLAG_SEC_REQ)) {
   4e8b0:	210f      	movs	r1, #15
   4e8b2:	4618      	mov	r0, r3
   4e8b4:	f7ff faf9 	bl	4deaa <atomic_test_bit>
	    atomic_test_bit(smp->flags, SMP_FLAG_ENC_PENDING) ||
   4e8b8:	2800      	cmp	r0, #0
   4e8ba:	d1d8      	bne.n	4e86e <smp_error+0x12>
   4e8bc:	e7db      	b.n	4e876 <smp_error+0x1a>
		net_buf_unref(buf);
   4e8be:	4620      	mov	r0, r4
   4e8c0:	f7f3 ffc2 	bl	42848 <net_buf_unref>
   4e8c4:	e7eb      	b.n	4e89e <smp_error+0x42>
		return -ENOBUFS;
   4e8c6:	f06f 0068 	mvn.w	r0, #104	; 0x68
   4e8ca:	e7e9      	b.n	4e8a0 <smp_error+0x44>

0004e8cc <bt_smp_dhkey_ready>:
{
   4e8cc:	b570      	push	{r4, r5, r6, lr}
   4e8ce:	4606      	mov	r6, r0
	struct bt_smp *smp = smp_find(SMP_FLAG_DHKEY_GEN);
   4e8d0:	2008      	movs	r0, #8
   4e8d2:	f7e4 fc25 	bl	33120 <smp_find>
	if (smp) {
   4e8d6:	4604      	mov	r4, r0
   4e8d8:	b1b8      	cbz	r0, 4e90a <bt_smp_dhkey_ready+0x3e>
		atomic_clear_bit(smp->flags, SMP_FLAG_DHKEY_GEN);
   4e8da:	1d05      	adds	r5, r0, #4
   4e8dc:	2108      	movs	r1, #8
   4e8de:	4628      	mov	r0, r5
   4e8e0:	f7ff fb68 	bl	4dfb4 <atomic_clear_bit>
	if (!dhkey) {
   4e8e4:	b3c6      	cbz	r6, 4e958 <bt_smp_dhkey_ready+0x8c>
	atomic_clear_bit(smp->flags, SMP_FLAG_DHKEY_PENDING);
   4e8e6:	2107      	movs	r1, #7
   4e8e8:	f7ff fb64 	bl	4dfb4 <atomic_clear_bit>
	memcpy(smp->dhkey, dhkey, BT_DH_KEY_LEN);
   4e8ec:	4631      	mov	r1, r6
   4e8ee:	2220      	movs	r2, #32
   4e8f0:	f104 0097 	add.w	r0, r4, #151	; 0x97
   4e8f4:	f7fc fac1 	bl	4ae7a <memcpy>
	if (atomic_test_bit(smp->flags, SMP_FLAG_USER)) {
   4e8f8:	210a      	movs	r1, #10
   4e8fa:	4628      	mov	r0, r5
   4e8fc:	f7ff fad5 	bl	4deaa <atomic_test_bit>
   4e900:	b168      	cbz	r0, 4e91e <bt_smp_dhkey_ready+0x52>
		atomic_set_bit(smp->flags, SMP_FLAG_DHKEY_SEND);
   4e902:	2109      	movs	r1, #9
		atomic_set_bit(smp->flags, SMP_FLAG_DHKEY_SEND);
   4e904:	4628      	mov	r0, r5
   4e906:	f7ff fc1f 	bl	4e148 <atomic_set_bit>
		smp = smp_find(SMP_FLAG_DHKEY_PENDING);
   4e90a:	2007      	movs	r0, #7
   4e90c:	f7e4 fc08 	bl	33120 <smp_find>
		if (smp) {
   4e910:	4604      	mov	r4, r0
   4e912:	b118      	cbz	r0, 4e91c <bt_smp_dhkey_ready+0x50>
			err = smp_dhkey_generate(smp);
   4e914:	f7e4 fde4 	bl	334e0 <smp_dhkey_generate>
			if (err) {
   4e918:	4601      	mov	r1, r0
   4e91a:	b9b0      	cbnz	r0, 4e94a <bt_smp_dhkey_ready+0x7e>
}
   4e91c:	bd70      	pop	{r4, r5, r6, pc}
	if (atomic_test_bit(smp->flags, SMP_FLAG_DHCHECK_WAIT)) {
   4e91e:	2110      	movs	r1, #16
   4e920:	4628      	mov	r0, r5
   4e922:	f7ff fac2 	bl	4deaa <atomic_test_bit>
		atomic_set_bit(smp->flags, SMP_FLAG_DHKEY_SEND);
   4e926:	2109      	movs	r1, #9
	if (atomic_test_bit(smp->flags, SMP_FLAG_DHCHECK_WAIT)) {
   4e928:	2800      	cmp	r0, #0
   4e92a:	d1eb      	bne.n	4e904 <bt_smp_dhkey_ready+0x38>
	if (atomic_test_bit(smp->flags, SMP_FLAG_DHKEY_SEND)) {
   4e92c:	4628      	mov	r0, r5
   4e92e:	f7ff fabc 	bl	4deaa <atomic_test_bit>
   4e932:	2800      	cmp	r0, #0
   4e934:	d0e9      	beq.n	4e90a <bt_smp_dhkey_ready+0x3e>
		if (smp->chan.chan.conn->role == BT_HCI_ROLE_CENTRAL) {
   4e936:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
   4e93a:	78db      	ldrb	r3, [r3, #3]
			return compute_and_send_central_dhcheck(smp);
   4e93c:	4620      	mov	r0, r4
		if (smp->chan.chan.conn->role == BT_HCI_ROLE_CENTRAL) {
   4e93e:	b943      	cbnz	r3, 4e952 <bt_smp_dhkey_ready+0x86>
			return compute_and_send_central_dhcheck(smp);
   4e940:	f7ff fc95 	bl	4e26e <compute_and_send_central_dhcheck>
		return  compute_and_check_and_send_periph_dhcheck(smp);
   4e944:	4601      	mov	r1, r0
		if (err) {
   4e946:	2800      	cmp	r0, #0
   4e948:	d0df      	beq.n	4e90a <bt_smp_dhkey_ready+0x3e>
			smp_error(smp, err);
   4e94a:	4620      	mov	r0, r4
   4e94c:	f7ff ff86 	bl	4e85c <smp_error>
   4e950:	e7db      	b.n	4e90a <bt_smp_dhkey_ready+0x3e>
		return  compute_and_check_and_send_periph_dhcheck(smp);
   4e952:	f7ff fce0 	bl	4e316 <compute_and_check_and_send_periph_dhcheck>
   4e956:	e7f5      	b.n	4e944 <bt_smp_dhkey_ready+0x78>
		return BT_SMP_ERR_DHKEY_CHECK_FAILED;
   4e958:	210b      	movs	r1, #11
   4e95a:	e7f6      	b.n	4e94a <bt_smp_dhkey_ready+0x7e>

0004e95c <smp_ident_addr_info>:
{
   4e95c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct bt_smp_ident_addr_info *req = (void *)buf->data;
   4e960:	688f      	ldr	r7, [r1, #8]
	if (addr->type == BT_ADDR_LE_PUBLIC) {
   4e962:	783b      	ldrb	r3, [r7, #0]
{
   4e964:	4604      	mov	r4, r0
   4e966:	b123      	cbz	r3, 4e972 <smp_ident_addr_info+0x16>
	if (!bt_addr_le_is_identity(&req->addr)) {
   4e968:	79bb      	ldrb	r3, [r7, #6]
   4e96a:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   4e96e:	2bc0      	cmp	r3, #192	; 0xc0
   4e970:	d176      	bne.n	4ea60 <smp_ident_addr_info+0x104>
	struct bt_conn *conn = smp->chan.chan.conn;
   4e972:	f8d4 50ec 	ldr.w	r5, [r4, #236]	; 0xec
	if (bt_addr_le_cmp(&conn->le.dst, &req->addr) != 0) {
   4e976:	f105 0888 	add.w	r8, r5, #136	; 0x88
	return memcmp(a, b, sizeof(*a));
   4e97a:	2207      	movs	r2, #7
   4e97c:	4639      	mov	r1, r7
   4e97e:	4640      	mov	r0, r8
   4e980:	f7fc fa6b 	bl	4ae5a <memcmp>
   4e984:	b180      	cbz	r0, 4e9a8 <smp_ident_addr_info+0x4c>
		struct bt_keys *keys = bt_keys_find_addr(conn->id, &req->addr);
   4e986:	7a28      	ldrb	r0, [r5, #8]
   4e988:	4639      	mov	r1, r7
   4e98a:	f7e5 fcff 	bl	3438c <bt_keys_find_addr>
		if (keys) {
   4e98e:	4606      	mov	r6, r0
   4e990:	b150      	cbz	r0, 4e9a8 <smp_ident_addr_info+0x4c>
			if (!update_keys_check(smp, keys)) {
   4e992:	4601      	mov	r1, r0
   4e994:	4620      	mov	r0, r4
   4e996:	f7ff fac8 	bl	4df2a <update_keys_check>
   4e99a:	b910      	cbnz	r0, 4e9a2 <smp_ident_addr_info+0x46>
				return BT_SMP_ERR_UNSPECIFIED;
   4e99c:	2008      	movs	r0, #8
}
   4e99e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			bt_keys_clear(keys);
   4e9a2:	4630      	mov	r0, r6
   4e9a4:	f7e5 fd10 	bl	343c8 <bt_keys_clear>
	if (atomic_test_bit(smp->flags, SMP_FLAG_BOND)) {
   4e9a8:	210d      	movs	r1, #13
   4e9aa:	1d20      	adds	r0, r4, #4
   4e9ac:	f7ff fa7d 	bl	4deaa <atomic_test_bit>
   4e9b0:	b398      	cbz	r0, 4ea1a <smp_ident_addr_info+0xbe>
		keys = bt_keys_get_type(BT_KEYS_IRK, conn->id, &conn->le.dst);
   4e9b2:	7a29      	ldrb	r1, [r5, #8]
   4e9b4:	4642      	mov	r2, r8
   4e9b6:	2002      	movs	r0, #2
   4e9b8:	f000 f93e 	bl	4ec38 <bt_keys_get_type>
		if (!keys) {
   4e9bc:	4606      	mov	r6, r0
   4e9be:	2800      	cmp	r0, #0
   4e9c0:	d0ec      	beq.n	4e99c <smp_ident_addr_info+0x40>
		if (conn->role == BT_HCI_ROLE_CENTRAL) {
   4e9c2:	78eb      	ldrb	r3, [r5, #3]
   4e9c4:	2b00      	cmp	r3, #0
   4e9c6:	d144      	bne.n	4ea52 <smp_ident_addr_info+0xf6>
			dst = &conn->le.resp_addr;
   4e9c8:	f105 0196 	add.w	r1, r5, #150	; 0x96
	if (addr->type != BT_ADDR_LE_RANDOM) {
   4e9cc:	780b      	ldrb	r3, [r1, #0]
   4e9ce:	2b01      	cmp	r3, #1
   4e9d0:	d120      	bne.n	4ea14 <smp_ident_addr_info+0xb8>
		if (bt_addr_le_is_rpa(dst)) {
   4e9d2:	798b      	ldrb	r3, [r1, #6]
   4e9d4:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   4e9d8:	2b40      	cmp	r3, #64	; 0x40
   4e9da:	d11b      	bne.n	4ea14 <smp_ident_addr_info+0xb8>
	memcpy(dst, src, sizeof(*dst));
   4e9dc:	2206      	movs	r2, #6
   4e9de:	3101      	adds	r1, #1
   4e9e0:	f106 003a 	add.w	r0, r6, #58	; 0x3a
   4e9e4:	f7fc fa49 	bl	4ae7a <memcpy>
	if (addr->type == BT_ADDR_LE_PUBLIC) {
   4e9e8:	f895 3088 	ldrb.w	r3, [r5, #136]	; 0x88
   4e9ec:	b193      	cbz	r3, 4ea14 <smp_ident_addr_info+0xb8>
			if (!bt_addr_le_is_identity(&conn->le.dst)) {
   4e9ee:	f895 308e 	ldrb.w	r3, [r5, #142]	; 0x8e
   4e9f2:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   4e9f6:	2bc0      	cmp	r3, #192	; 0xc0
   4e9f8:	d00c      	beq.n	4ea14 <smp_ident_addr_info+0xb8>
	memcpy(dst, src, sizeof(*dst));
   4e9fa:	2207      	movs	r2, #7
   4e9fc:	4639      	mov	r1, r7
   4e9fe:	1c70      	adds	r0, r6, #1
   4ea00:	f7fc fa3b 	bl	4ae7a <memcpy>
   4ea04:	2207      	movs	r2, #7
   4ea06:	4639      	mov	r1, r7
   4ea08:	4640      	mov	r0, r8
   4ea0a:	f7fc fa36 	bl	4ae7a <memcpy>
				bt_conn_identity_resolved(conn);
   4ea0e:	4628      	mov	r0, r5
   4ea10:	f7e1 fb34 	bl	3007c <bt_conn_identity_resolved>
		bt_id_add(keys);
   4ea14:	4630      	mov	r0, r6
   4ea16:	f7df ff97 	bl	2e948 <bt_id_add>
	smp->remote_dist &= ~BT_SMP_DIST_ID_KEY;
   4ea1a:	f894 30e9 	ldrb.w	r3, [r4, #233]	; 0xe9
   4ea1e:	f023 0202 	bic.w	r2, r3, #2
	if (smp->remote_dist & BT_SMP_DIST_SIGN) {
   4ea22:	075b      	lsls	r3, r3, #29
	smp->remote_dist &= ~BT_SMP_DIST_ID_KEY;
   4ea24:	f884 20e9 	strb.w	r2, [r4, #233]	; 0xe9
	if (smp->remote_dist & BT_SMP_DIST_SIGN) {
   4ea28:	d503      	bpl.n	4ea32 <smp_ident_addr_info+0xd6>
		atomic_set_bit(smp->allowed_cmds, BT_SMP_CMD_SIGNING_INFO);
   4ea2a:	210a      	movs	r1, #10
   4ea2c:	4620      	mov	r0, r4
   4ea2e:	f7ff fb8b 	bl	4e148 <atomic_set_bit>
	if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
   4ea32:	78eb      	ldrb	r3, [r5, #3]
   4ea34:	b943      	cbnz	r3, 4ea48 <smp_ident_addr_info+0xec>
	    conn->role == BT_HCI_ROLE_CENTRAL && !smp->remote_dist) {
   4ea36:	f894 30e9 	ldrb.w	r3, [r4, #233]	; 0xe9
   4ea3a:	b92b      	cbnz	r3, 4ea48 <smp_ident_addr_info+0xec>
	struct bt_keys *keys = conn->le.keys;
   4ea3c:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
	if (!keys) {
   4ea40:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
   4ea44:	2b00      	cmp	r3, #0
   4ea46:	d0a9      	beq.n	4e99c <smp_ident_addr_info+0x40>
	if (!smp->local_dist && !smp->remote_dist) {
   4ea48:	f8b4 10e8 	ldrh.w	r1, [r4, #232]	; 0xe8
   4ea4c:	b121      	cbz	r1, 4ea58 <smp_ident_addr_info+0xfc>
	return 0;
   4ea4e:	2000      	movs	r0, #0
   4ea50:	e7a5      	b.n	4e99e <smp_ident_addr_info+0x42>
			dst = &conn->le.init_addr;
   4ea52:	f105 018f 	add.w	r1, r5, #143	; 0x8f
   4ea56:	e7b9      	b.n	4e9cc <smp_ident_addr_info+0x70>
		smp_pairing_complete(smp, 0);
   4ea58:	4620      	mov	r0, r4
   4ea5a:	f7e5 fa13 	bl	33e84 <smp_pairing_complete>
   4ea5e:	e7f6      	b.n	4ea4e <smp_ident_addr_info+0xf2>
		return BT_SMP_ERR_INVALID_PARAMS;
   4ea60:	200a      	movs	r0, #10
   4ea62:	e79c      	b.n	4e99e <smp_ident_addr_info+0x42>

0004ea64 <smp_pairing_failed>:
{
   4ea64:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4ea68:	460e      	mov	r6, r1
   4ea6a:	4604      	mov	r4, r0
	struct bt_conn *conn = smp->chan.chan.conn;
   4ea6c:	f8d0 80ec 	ldr.w	r8, [r0, #236]	; 0xec
	const struct bt_conn_auth_cb *smp_auth_cb = latch_auth_cb(smp);
   4ea70:	f7e4 fb6a 	bl	33148 <latch_auth_cb>
	struct bt_smp_pairing_fail *req = (void *)buf->data;
   4ea74:	68b7      	ldr	r7, [r6, #8]
	if (atomic_test_and_clear_bit(smp->flags, SMP_FLAG_USER) ||
   4ea76:	1d26      	adds	r6, r4, #4
	const struct bt_conn_auth_cb *smp_auth_cb = latch_auth_cb(smp);
   4ea78:	4605      	mov	r5, r0
	if (atomic_test_and_clear_bit(smp->flags, SMP_FLAG_USER) ||
   4ea7a:	210a      	movs	r1, #10
   4ea7c:	4630      	mov	r0, r6
   4ea7e:	f7ff fd91 	bl	4e5a4 <atomic_test_and_clear_bit>
   4ea82:	b138      	cbz	r0, 4ea94 <smp_pairing_failed+0x30>
		if (smp_auth_cb && smp_auth_cb->cancel) {
   4ea84:	b96d      	cbnz	r5, 4eaa2 <smp_pairing_failed+0x3e>
	smp_pairing_complete(smp, req->reason);
   4ea86:	4620      	mov	r0, r4
   4ea88:	7839      	ldrb	r1, [r7, #0]
   4ea8a:	f7e5 f9fb 	bl	33e84 <smp_pairing_complete>
}
   4ea8e:	2000      	movs	r0, #0
   4ea90:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	    atomic_test_and_clear_bit(smp->flags, SMP_FLAG_DISPLAY)) {
   4ea94:	210b      	movs	r1, #11
   4ea96:	4630      	mov	r0, r6
   4ea98:	f7ff fd84 	bl	4e5a4 <atomic_test_and_clear_bit>
	if (atomic_test_and_clear_bit(smp->flags, SMP_FLAG_USER) ||
   4ea9c:	2800      	cmp	r0, #0
   4ea9e:	d1f1      	bne.n	4ea84 <smp_pairing_failed+0x20>
   4eaa0:	e7f1      	b.n	4ea86 <smp_pairing_failed+0x22>
		if (smp_auth_cb && smp_auth_cb->cancel) {
   4eaa2:	696b      	ldr	r3, [r5, #20]
   4eaa4:	2b00      	cmp	r3, #0
   4eaa6:	d0ee      	beq.n	4ea86 <smp_pairing_failed+0x22>
			smp_auth_cb->cancel(conn);
   4eaa8:	4640      	mov	r0, r8
   4eaaa:	4798      	blx	r3
   4eaac:	e7eb      	b.n	4ea86 <smp_pairing_failed+0x22>

0004eaae <bt_smp_disconnected>:
{
   4eaae:	b570      	push	{r4, r5, r6, lr}
   4eab0:	4604      	mov	r4, r0
	struct bt_smp *smp = CONTAINER_OF(chan, struct bt_smp, chan);
   4eab2:	f1a0 06ec 	sub.w	r6, r0, #236	; 0xec
	struct bt_keys *keys = chan->conn->le.keys;
   4eab6:	f850 3b8c 	ldr.w	r3, [r0], #140
	if (atomic_test_bit(smp->flags, SMP_FLAG_PAIRING) ||
   4eaba:	3ce8      	subs	r4, #232	; 0xe8
	struct bt_keys *keys = chan->conn->le.keys;
   4eabc:	f8d3 50b4 	ldr.w	r5, [r3, #180]	; 0xb4
	(void)k_work_cancel_delayable(&smp->work);
   4eac0:	f001 faae 	bl	50020 <k_work_cancel_delayable>
	if (atomic_test_bit(smp->flags, SMP_FLAG_PAIRING) ||
   4eac4:	2103      	movs	r1, #3
   4eac6:	4620      	mov	r0, r4
   4eac8:	f7ff f9ef 	bl	4deaa <atomic_test_bit>
   4eacc:	b1a0      	cbz	r0, 4eaf8 <bt_smp_disconnected+0x4a>
		smp_pairing_complete(smp, BT_SMP_ERR_UNSPECIFIED);
   4eace:	2108      	movs	r1, #8
   4ead0:	4630      	mov	r0, r6
   4ead2:	f7e5 f9d7 	bl	33e84 <smp_pairing_complete>
	if (keys) {
   4ead6:	b13d      	cbz	r5, 4eae8 <bt_smp_disconnected+0x3a>
		if (!keys->keys || (!IS_ENABLED(CONFIG_BT_STORE_DEBUG_KEYS) &&
   4ead8:	89eb      	ldrh	r3, [r5, #14]
   4eada:	b113      	cbz	r3, 4eae2 <bt_smp_disconnected+0x34>
   4eadc:	7b6b      	ldrb	r3, [r5, #13]
   4eade:	079b      	lsls	r3, r3, #30
   4eae0:	d502      	bpl.n	4eae8 <bt_smp_disconnected+0x3a>
			bt_keys_clear(keys);
   4eae2:	4628      	mov	r0, r5
   4eae4:	f7e5 fc70 	bl	343c8 <bt_keys_clear>
	(void)memset(smp, 0, sizeof(*smp));
   4eae8:	4630      	mov	r0, r6
   4eaea:	f44f 72d8 	mov.w	r2, #432	; 0x1b0
}
   4eaee:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	(void)memset(smp, 0, sizeof(*smp));
   4eaf2:	2100      	movs	r1, #0
   4eaf4:	f7fc b9cc 	b.w	4ae90 <memset>
	    atomic_test_bit(smp->flags, SMP_FLAG_ENC_PENDING) ||
   4eaf8:	2101      	movs	r1, #1
   4eafa:	4620      	mov	r0, r4
   4eafc:	f7ff f9d5 	bl	4deaa <atomic_test_bit>
	if (atomic_test_bit(smp->flags, SMP_FLAG_PAIRING) ||
   4eb00:	2800      	cmp	r0, #0
   4eb02:	d1e4      	bne.n	4eace <bt_smp_disconnected+0x20>
	    atomic_test_bit(smp->flags, SMP_FLAG_SEC_REQ)) {
   4eb04:	210f      	movs	r1, #15
   4eb06:	4620      	mov	r0, r4
   4eb08:	f7ff f9cf 	bl	4deaa <atomic_test_bit>
	    atomic_test_bit(smp->flags, SMP_FLAG_ENC_PENDING) ||
   4eb0c:	2800      	cmp	r0, #0
   4eb0e:	d1de      	bne.n	4eace <bt_smp_disconnected+0x20>
   4eb10:	e7e1      	b.n	4ead6 <bt_smp_disconnected+0x28>

0004eb12 <smp_timeout>:
{
   4eb12:	b510      	push	{r4, lr}
	smp_pairing_complete(smp, BT_SMP_ERR_UNSPECIFIED);
   4eb14:	2108      	movs	r1, #8
{
   4eb16:	4604      	mov	r4, r0
	smp_pairing_complete(smp, BT_SMP_ERR_UNSPECIFIED);
   4eb18:	f5a0 70bc 	sub.w	r0, r0, #376	; 0x178
   4eb1c:	f7e5 f9b2 	bl	33e84 <smp_pairing_complete>
	atomic_set_bit(smp->flags, SMP_FLAG_TIMEOUT);
   4eb20:	f5a4 70ba 	sub.w	r0, r4, #372	; 0x174
   4eb24:	2104      	movs	r1, #4
}
   4eb26:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	atomic_set_bit(smp->flags, SMP_FLAG_TIMEOUT);
   4eb2a:	f7ff bb0d 	b.w	4e148 <atomic_set_bit>

0004eb2e <bt_smp_update_keys>:
{
   4eb2e:	b570      	push	{r4, r5, r6, lr}
   4eb30:	4604      	mov	r4, r0
	smp = smp_chan_get(conn);
   4eb32:	f7ff f9b3 	bl	4de9c <smp_chan_get>
	if (!smp) {
   4eb36:	4605      	mov	r5, r0
   4eb38:	2800      	cmp	r0, #0
   4eb3a:	d07a      	beq.n	4ec32 <bt_smp_update_keys+0x104>
	if (!atomic_test_bit(smp->flags, SMP_FLAG_PAIRING)) {
   4eb3c:	1d06      	adds	r6, r0, #4
   4eb3e:	2103      	movs	r1, #3
   4eb40:	4630      	mov	r0, r6
   4eb42:	f7ff f9b2 	bl	4deaa <atomic_test_bit>
   4eb46:	2800      	cmp	r0, #0
   4eb48:	d073      	beq.n	4ec32 <bt_smp_update_keys+0x104>
	if (conn->le.keys) {
   4eb4a:	f8d4 00b4 	ldr.w	r0, [r4, #180]	; 0xb4
   4eb4e:	b108      	cbz	r0, 4eb54 <bt_smp_update_keys+0x26>
		bt_keys_clear(conn->le.keys);
   4eb50:	f7e5 fc3a 	bl	343c8 <bt_keys_clear>
	conn->le.keys = bt_keys_get_addr(conn->id, &conn->le.dst);
   4eb54:	7a20      	ldrb	r0, [r4, #8]
   4eb56:	f104 0188 	add.w	r1, r4, #136	; 0x88
   4eb5a:	f7e5 fb1f 	bl	3419c <bt_keys_get_addr>
   4eb5e:	f8c4 00b4 	str.w	r0, [r4, #180]	; 0xb4
	if (!conn->le.keys) {
   4eb62:	b928      	cbnz	r0, 4eb70 <bt_smp_update_keys+0x42>
		smp_error(smp, BT_SMP_ERR_UNSPECIFIED);
   4eb64:	4628      	mov	r0, r5
   4eb66:	2108      	movs	r1, #8
}
   4eb68:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		smp_error(smp, BT_SMP_ERR_UNSPECIFIED);
   4eb6c:	f7ff be76 	b.w	4e85c <smp_error>
	if (atomic_test_bit(smp->flags, SMP_FLAG_SC_DEBUG_KEY)) {
   4eb70:	210e      	movs	r1, #14
   4eb72:	4630      	mov	r0, r6
   4eb74:	f7ff f999 	bl	4deaa <atomic_test_bit>
   4eb78:	b128      	cbz	r0, 4eb86 <bt_smp_update_keys+0x58>
		conn->le.keys->flags |= BT_KEYS_DEBUG;
   4eb7a:	f8d4 20b4 	ldr.w	r2, [r4, #180]	; 0xb4
   4eb7e:	7b53      	ldrb	r3, [r2, #13]
   4eb80:	f043 0302 	orr.w	r3, r3, #2
   4eb84:	7353      	strb	r3, [r2, #13]
	switch (smp->method) {
   4eb86:	7a2a      	ldrb	r2, [r5, #8]
		conn->le.keys->flags |= BT_KEYS_OOB;
   4eb88:	f8d4 10b4 	ldr.w	r1, [r4, #180]	; 0xb4
	switch (smp->method) {
   4eb8c:	2a03      	cmp	r2, #3
		conn->le.keys->flags |= BT_KEYS_OOB;
   4eb8e:	7b4b      	ldrb	r3, [r1, #13]
	switch (smp->method) {
   4eb90:	d83c      	bhi.n	4ec0c <bt_smp_update_keys+0xde>
   4eb92:	2a00      	cmp	r2, #0
   4eb94:	d041      	beq.n	4ec1a <bt_smp_update_keys+0xec>
		conn->le.keys->flags |= BT_KEYS_AUTHENTICATED;
   4eb96:	f8d4 20b4 	ldr.w	r2, [r4, #180]	; 0xb4
   4eb9a:	7b53      	ldrb	r3, [r2, #13]
   4eb9c:	f043 0301 	orr.w	r3, r3, #1
		conn->le.keys->flags &= ~BT_KEYS_AUTHENTICATED;
   4eba0:	7353      	strb	r3, [r2, #13]
	return MIN(req->max_key_size, rsp->max_key_size);
   4eba2:	7b6b      	ldrb	r3, [r5, #13]
   4eba4:	7d29      	ldrb	r1, [r5, #20]
	conn->le.keys->enc_size = get_encryption_key_size(smp);
   4eba6:	f8d4 20b4 	ldr.w	r2, [r4, #180]	; 0xb4
	return MIN(req->max_key_size, rsp->max_key_size);
   4ebaa:	428b      	cmp	r3, r1
   4ebac:	bf28      	it	cs
   4ebae:	460b      	movcs	r3, r1
	conn->le.keys->enc_size = get_encryption_key_size(smp);
   4ebb0:	7313      	strb	r3, [r2, #12]
	if (atomic_test_bit(smp->flags, SMP_FLAG_SC)) {
   4ebb2:	2105      	movs	r1, #5
   4ebb4:	4630      	mov	r0, r6
   4ebb6:	f7ff f978 	bl	4deaa <atomic_test_bit>
   4ebba:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
		conn->le.keys->flags |= BT_KEYS_SC;
   4ebbe:	7b5a      	ldrb	r2, [r3, #13]
	if (atomic_test_bit(smp->flags, SMP_FLAG_SC)) {
   4ebc0:	b3a0      	cbz	r0, 4ec2c <bt_smp_update_keys+0xfe>
		conn->le.keys->flags |= BT_KEYS_SC;
   4ebc2:	f042 0210 	orr.w	r2, r2, #16
   4ebc6:	735a      	strb	r2, [r3, #13]
		if (atomic_test_bit(smp->flags, SMP_FLAG_BOND)) {
   4ebc8:	210d      	movs	r1, #13
   4ebca:	4630      	mov	r0, r6
   4ebcc:	f7ff f96d 	bl	4deaa <atomic_test_bit>
   4ebd0:	b378      	cbz	r0, 4ec32 <bt_smp_update_keys+0x104>
			bt_keys_add_type(conn->le.keys, BT_KEYS_LTK_P256);
   4ebd2:	f8d4 00b4 	ldr.w	r0, [r4, #180]	; 0xb4
   4ebd6:	2120      	movs	r1, #32
   4ebd8:	f000 f83e 	bl	4ec58 <bt_keys_add_type>
			memcpy(conn->le.keys->ltk.val, smp->tk,
   4ebdc:	f8d4 00b4 	ldr.w	r0, [r4, #180]	; 0xb4
   4ebe0:	f105 0147 	add.w	r1, r5, #71	; 0x47
   4ebe4:	2210      	movs	r2, #16
   4ebe6:	301a      	adds	r0, #26
   4ebe8:	f7fc f947 	bl	4ae7a <memcpy>
			(void)memset(conn->le.keys->ltk.rand, 0,
   4ebec:	f8d4 00b4 	ldr.w	r0, [r4, #180]	; 0xb4
   4ebf0:	2208      	movs	r2, #8
   4ebf2:	2100      	movs	r1, #0
   4ebf4:	3010      	adds	r0, #16
   4ebf6:	f7fc f94b 	bl	4ae90 <memset>
			(void)memset(conn->le.keys->ltk.ediv, 0,
   4ebfa:	f8d4 00b4 	ldr.w	r0, [r4, #180]	; 0xb4
   4ebfe:	2202      	movs	r2, #2
}
   4ec00:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			(void)memset(conn->le.keys->ltk.ediv, 0,
   4ec04:	2100      	movs	r1, #0
   4ec06:	3018      	adds	r0, #24
   4ec08:	f7fc b942 	b.w	4ae90 <memset>
	switch (smp->method) {
   4ec0c:	3a05      	subs	r2, #5
   4ec0e:	2a01      	cmp	r2, #1
   4ec10:	d803      	bhi.n	4ec1a <bt_smp_update_keys+0xec>
		conn->le.keys->flags |= BT_KEYS_OOB;
   4ec12:	f043 0320 	orr.w	r3, r3, #32
   4ec16:	734b      	strb	r3, [r1, #13]
   4ec18:	e7bd      	b.n	4eb96 <bt_smp_update_keys+0x68>
		conn->le.keys->flags &= ~BT_KEYS_OOB;
   4ec1a:	f023 0320 	bic.w	r3, r3, #32
   4ec1e:	734b      	strb	r3, [r1, #13]
		conn->le.keys->flags &= ~BT_KEYS_AUTHENTICATED;
   4ec20:	f8d4 20b4 	ldr.w	r2, [r4, #180]	; 0xb4
   4ec24:	7b53      	ldrb	r3, [r2, #13]
   4ec26:	f023 0301 	bic.w	r3, r3, #1
   4ec2a:	e7b9      	b.n	4eba0 <bt_smp_update_keys+0x72>
		conn->le.keys->flags &= ~BT_KEYS_SC;
   4ec2c:	f022 0210 	bic.w	r2, r2, #16
   4ec30:	735a      	strb	r2, [r3, #13]
}
   4ec32:	bd70      	pop	{r4, r5, r6, pc}

0004ec34 <id_add>:
	bt_id_add(keys);
   4ec34:	f7df be88 	b.w	2e948 <bt_id_add>

0004ec38 <bt_keys_get_type>:
{
   4ec38:	b570      	push	{r4, r5, r6, lr}
   4ec3a:	4604      	mov	r4, r0
   4ec3c:	460d      	mov	r5, r1
   4ec3e:	4616      	mov	r6, r2
	keys = bt_keys_find(type, id, addr);
   4ec40:	f7e5 fb2c 	bl	3429c <bt_keys_find>
	if (keys) {
   4ec44:	b938      	cbnz	r0, 4ec56 <bt_keys_get_type+0x1e>
	keys = bt_keys_get_addr(id, addr);
   4ec46:	4631      	mov	r1, r6
   4ec48:	4628      	mov	r0, r5
   4ec4a:	f7e5 faa7 	bl	3419c <bt_keys_get_addr>
	if (!keys) {
   4ec4e:	b110      	cbz	r0, 4ec56 <bt_keys_get_type+0x1e>
	keys->keys |= type;
   4ec50:	89c3      	ldrh	r3, [r0, #14]
   4ec52:	431c      	orrs	r4, r3
   4ec54:	81c4      	strh	r4, [r0, #14]
}
   4ec56:	bd70      	pop	{r4, r5, r6, pc}

0004ec58 <bt_keys_add_type>:
	keys->keys |= type;
   4ec58:	89c3      	ldrh	r3, [r0, #14]
   4ec5a:	4319      	orrs	r1, r3
   4ec5c:	81c1      	strh	r1, [r0, #14]
}
   4ec5e:	4770      	bx	lr

0004ec60 <keys_set>:
{
   4ec60:	b570      	push	{r4, r5, r6, lr}
   4ec62:	4606      	mov	r6, r0
   4ec64:	b090      	sub	sp, #64	; 0x40
   4ec66:	4614      	mov	r4, r2
   4ec68:	4618      	mov	r0, r3
	if (!name) {
   4ec6a:	b326      	cbz	r6, 4ecb6 <keys_set+0x56>
	len = read_cb(cb_arg, val, sizeof(val));
   4ec6c:	2234      	movs	r2, #52	; 0x34
   4ec6e:	a903      	add	r1, sp, #12
   4ec70:	47a0      	blx	r4
	if (len < 0) {
   4ec72:	1e04      	subs	r4, r0, #0
   4ec74:	db1f      	blt.n	4ecb6 <keys_set+0x56>
	err = bt_settings_decode_key(name, &addr);
   4ec76:	a901      	add	r1, sp, #4
   4ec78:	4630      	mov	r0, r6
   4ec7a:	f7fc f999 	bl	4afb0 <bt_settings_decode_key>
	if (err) {
   4ec7e:	4605      	mov	r5, r0
   4ec80:	b9c8      	cbnz	r0, 4ecb6 <keys_set+0x56>
	settings_name_next(name, &next);
   4ec82:	4669      	mov	r1, sp
   4ec84:	4630      	mov	r0, r6
   4ec86:	f7fa fd6c 	bl	49762 <settings_name_next>
	if (!next) {
   4ec8a:	9800      	ldr	r0, [sp, #0]
   4ec8c:	b968      	cbnz	r0, 4ecaa <keys_set+0x4a>
	if (!len) {
   4ec8e:	b9ac      	cbnz	r4, 4ecbc <keys_set+0x5c>
		keys = bt_keys_find(BT_KEYS_ALL, id, &addr);
   4ec90:	aa01      	add	r2, sp, #4
   4ec92:	4621      	mov	r1, r4
   4ec94:	203f      	movs	r0, #63	; 0x3f
   4ec96:	f7e5 fb01 	bl	3429c <bt_keys_find>
		if (keys) {
   4ec9a:	b118      	cbz	r0, 4eca4 <keys_set+0x44>
			(void)memset(keys, 0, sizeof(*keys));
   4ec9c:	2240      	movs	r2, #64	; 0x40
   4ec9e:	4621      	mov	r1, r4
   4eca0:	f7fc f8f6 	bl	4ae90 <memset>
}
   4eca4:	4628      	mov	r0, r5
   4eca6:	b010      	add	sp, #64	; 0x40
   4eca8:	bd70      	pop	{r4, r5, r6, pc}
		unsigned long next_id = strtoul(next, NULL, 10);
   4ecaa:	220a      	movs	r2, #10
   4ecac:	4629      	mov	r1, r5
   4ecae:	f7fb ff9b 	bl	4abe8 <strtoul>
		if (next_id >= CONFIG_BT_ID_MAX) {
   4ecb2:	2800      	cmp	r0, #0
   4ecb4:	d0eb      	beq.n	4ec8e <keys_set+0x2e>
		return -EINVAL;
   4ecb6:	f06f 0515 	mvn.w	r5, #21
   4ecba:	e7f3      	b.n	4eca4 <keys_set+0x44>
	keys = bt_keys_get_addr(id, &addr);
   4ecbc:	a901      	add	r1, sp, #4
   4ecbe:	2000      	movs	r0, #0
   4ecc0:	f7e5 fa6c 	bl	3419c <bt_keys_get_addr>
	if (!keys) {
   4ecc4:	b150      	cbz	r0, 4ecdc <keys_set+0x7c>
	if (len != BT_KEYS_STORAGE_LEN) {
   4ecc6:	2c34      	cmp	r4, #52	; 0x34
   4ecc8:	d002      	beq.n	4ecd0 <keys_set+0x70>
			bt_keys_clear(keys);
   4ecca:	f7e5 fb7d 	bl	343c8 <bt_keys_clear>
			return -EINVAL;
   4ecce:	e7f2      	b.n	4ecb6 <keys_set+0x56>
		memcpy(keys->storage_start, val, len);
   4ecd0:	4622      	mov	r2, r4
   4ecd2:	a903      	add	r1, sp, #12
   4ecd4:	300c      	adds	r0, #12
   4ecd6:	f7fc f8d0 	bl	4ae7a <memcpy>
	return 0;
   4ecda:	e7e3      	b.n	4eca4 <keys_set+0x44>
		return -ENOMEM;
   4ecdc:	f06f 050b 	mvn.w	r5, #11
   4ece0:	e7e0      	b.n	4eca4 <keys_set+0x44>

0004ece2 <fixed_data_unref>:
}
   4ece2:	4770      	bx	lr

0004ece4 <net_buf_alloc_fixed>:
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
   4ece4:	6a41      	ldr	r1, [r0, #36]	; 0x24
	return net_buf_alloc_len(pool, fixed->data_size, timeout);
   4ece6:	6849      	ldr	r1, [r1, #4]
   4ece8:	6809      	ldr	r1, [r1, #0]
   4ecea:	f7f3 bd1b 	b.w	42724 <net_buf_alloc_len>

0004ecee <net_buf_get>:
{
   4ecee:	b570      	push	{r4, r5, r6, lr}
   4ecf0:	4606      	mov	r6, r0
	return z_impl_k_queue_get(queue, timeout);
   4ecf2:	f7f8 fa0d 	bl	47110 <z_impl_k_queue_get>
	if (!buf) {
   4ecf6:	4605      	mov	r5, r0
   4ecf8:	b128      	cbz	r0, 4ed06 <net_buf_get+0x18>
   4ecfa:	4604      	mov	r4, r0
	for (frag = buf; (frag->flags & NET_BUF_FRAGS); frag = frag->frags) {
   4ecfc:	7963      	ldrb	r3, [r4, #5]
   4ecfe:	f013 0301 	ands.w	r3, r3, #1
   4ed02:	d102      	bne.n	4ed0a <net_buf_get+0x1c>
	frag->frags = NULL;
   4ed04:	6023      	str	r3, [r4, #0]
}
   4ed06:	4628      	mov	r0, r5
   4ed08:	bd70      	pop	{r4, r5, r6, pc}
   4ed0a:	2300      	movs	r3, #0
   4ed0c:	2200      	movs	r2, #0
   4ed0e:	4630      	mov	r0, r6
   4ed10:	f7f8 f9fe 	bl	47110 <z_impl_k_queue_get>
		frag->flags &= ~NET_BUF_FRAGS;
   4ed14:	7963      	ldrb	r3, [r4, #5]
		frag->frags = k_fifo_get(fifo, K_NO_WAIT);
   4ed16:	6020      	str	r0, [r4, #0]
		frag->flags &= ~NET_BUF_FRAGS;
   4ed18:	f023 0301 	bic.w	r3, r3, #1
   4ed1c:	7163      	strb	r3, [r4, #5]
	for (frag = buf; (frag->flags & NET_BUF_FRAGS); frag = frag->frags) {
   4ed1e:	4604      	mov	r4, r0
   4ed20:	e7ec      	b.n	4ecfc <net_buf_get+0xe>

0004ed22 <net_buf_simple_init_with_data>:
	buf->size  = size;
   4ed22:	b292      	uxth	r2, r2
	buf->__buf = data;
   4ed24:	6081      	str	r1, [r0, #8]
	buf->data  = data;
   4ed26:	6001      	str	r1, [r0, #0]
	buf->size  = size;
   4ed28:	80c2      	strh	r2, [r0, #6]
	buf->len   = size;
   4ed2a:	8082      	strh	r2, [r0, #4]
}
   4ed2c:	4770      	bx	lr

0004ed2e <net_buf_simple_reserve>:
	buf->data = buf->__buf + reserve;
   4ed2e:	6883      	ldr	r3, [r0, #8]
   4ed30:	440b      	add	r3, r1
   4ed32:	6003      	str	r3, [r0, #0]
}
   4ed34:	4770      	bx	lr

0004ed36 <net_buf_put>:
{
   4ed36:	b410      	push	{r4}
	for (tail = buf; tail->frags; tail = tail->frags) {
   4ed38:	460a      	mov	r2, r1
   4ed3a:	6814      	ldr	r4, [r2, #0]
   4ed3c:	b914      	cbnz	r4, 4ed44 <net_buf_put+0xe>
}
   4ed3e:	bc10      	pop	{r4}
	k_fifo_put_list(fifo, buf, tail);
   4ed40:	f001 b85b 	b.w	4fdfa <k_queue_append_list>
		tail->flags |= NET_BUF_FRAGS;
   4ed44:	7953      	ldrb	r3, [r2, #5]
   4ed46:	f043 0301 	orr.w	r3, r3, #1
   4ed4a:	7153      	strb	r3, [r2, #5]
   4ed4c:	4622      	mov	r2, r4
   4ed4e:	e7f4      	b.n	4ed3a <net_buf_put+0x4>

0004ed50 <net_buf_ref>:
	buf->ref++;
   4ed50:	7902      	ldrb	r2, [r0, #4]
   4ed52:	3201      	adds	r2, #1
   4ed54:	7102      	strb	r2, [r0, #4]
}
   4ed56:	4770      	bx	lr

0004ed58 <net_buf_frag_last>:
{
   4ed58:	4603      	mov	r3, r0
	while (buf->frags) {
   4ed5a:	4618      	mov	r0, r3
   4ed5c:	681b      	ldr	r3, [r3, #0]
   4ed5e:	2b00      	cmp	r3, #0
   4ed60:	d1fb      	bne.n	4ed5a <net_buf_frag_last+0x2>
}
   4ed62:	4770      	bx	lr

0004ed64 <net_buf_frag_insert>:
	if (parent->frags) {
   4ed64:	6802      	ldr	r2, [r0, #0]
{
   4ed66:	b510      	push	{r4, lr}
	if (parent->frags) {
   4ed68:	b12a      	cbz	r2, 4ed76 <net_buf_frag_insert+0x12>
   4ed6a:	460b      	mov	r3, r1
	while (buf->frags) {
   4ed6c:	461c      	mov	r4, r3
   4ed6e:	681b      	ldr	r3, [r3, #0]
   4ed70:	2b00      	cmp	r3, #0
   4ed72:	d1fb      	bne.n	4ed6c <net_buf_frag_insert+0x8>
		net_buf_frag_last(frag)->frags = parent->frags;
   4ed74:	6022      	str	r2, [r4, #0]
	parent->frags = frag;
   4ed76:	6001      	str	r1, [r0, #0]
}
   4ed78:	bd10      	pop	{r4, pc}

0004ed7a <net_buf_frag_add>:
{
   4ed7a:	b510      	push	{r4, lr}
	if (!head) {
   4ed7c:	4604      	mov	r4, r0
   4ed7e:	b920      	cbnz	r0, 4ed8a <net_buf_frag_add+0x10>
	buf->ref++;
   4ed80:	790b      	ldrb	r3, [r1, #4]
   4ed82:	3301      	adds	r3, #1
   4ed84:	710b      	strb	r3, [r1, #4]
		return net_buf_ref(frag);
   4ed86:	4608      	mov	r0, r1
}
   4ed88:	bd10      	pop	{r4, pc}
   4ed8a:	4603      	mov	r3, r0
	while (buf->frags) {
   4ed8c:	4618      	mov	r0, r3
   4ed8e:	681b      	ldr	r3, [r3, #0]
   4ed90:	2b00      	cmp	r3, #0
   4ed92:	d1fb      	bne.n	4ed8c <net_buf_frag_add+0x12>
	net_buf_frag_insert(net_buf_frag_last(head), frag);
   4ed94:	f7ff ffe6 	bl	4ed64 <net_buf_frag_insert>
   4ed98:	4620      	mov	r0, r4
   4ed9a:	e7f5      	b.n	4ed88 <net_buf_frag_add+0xe>

0004ed9c <net_buf_frag_del>:
{
   4ed9c:	b510      	push	{r4, lr}
	if (parent) {
   4ed9e:	b108      	cbz	r0, 4eda4 <net_buf_frag_del+0x8>
		parent->frags = frag->frags;
   4eda0:	680b      	ldr	r3, [r1, #0]
   4eda2:	6003      	str	r3, [r0, #0]
	next_frag = frag->frags;
   4eda4:	680c      	ldr	r4, [r1, #0]
	frag->frags = NULL;
   4eda6:	2300      	movs	r3, #0
	net_buf_unref(frag);
   4eda8:	4608      	mov	r0, r1
	frag->frags = NULL;
   4edaa:	600b      	str	r3, [r1, #0]
	net_buf_unref(frag);
   4edac:	f7f3 fd4c 	bl	42848 <net_buf_unref>
}
   4edb0:	4620      	mov	r0, r4
   4edb2:	bd10      	pop	{r4, pc}

0004edb4 <net_buf_simple_add>:
	return buf->data + buf->len;
   4edb4:	8883      	ldrh	r3, [r0, #4]
   4edb6:	6802      	ldr	r2, [r0, #0]

	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(net_buf_simple_tailroom(buf) >= len);

	buf->len += len;
   4edb8:	4419      	add	r1, r3
   4edba:	8081      	strh	r1, [r0, #4]
	return tail;
}
   4edbc:	18d0      	adds	r0, r2, r3
   4edbe:	4770      	bx	lr

0004edc0 <net_buf_simple_add_mem>:

void *net_buf_simple_add_mem(struct net_buf_simple *buf, const void *mem,
			     size_t len)
{
   4edc0:	b430      	push	{r4, r5}
   4edc2:	8884      	ldrh	r4, [r0, #4]
   4edc4:	6805      	ldr	r5, [r0, #0]
	buf->len += len;
   4edc6:	18a3      	adds	r3, r4, r2
   4edc8:	8083      	strh	r3, [r0, #4]
	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	return memcpy(net_buf_simple_add(buf, len), mem, len);
   4edca:	1928      	adds	r0, r5, r4
}
   4edcc:	bc30      	pop	{r4, r5}
	return memcpy(net_buf_simple_add(buf, len), mem, len);
   4edce:	f7fc b854 	b.w	4ae7a <memcpy>

0004edd2 <net_buf_simple_add_u8>:

uint8_t *net_buf_simple_add_u8(struct net_buf_simple *buf, uint8_t val)
{
   4edd2:	b510      	push	{r4, lr}
   4edd4:	8883      	ldrh	r3, [r0, #4]
   4edd6:	6802      	ldr	r2, [r0, #0]
	buf->len += len;
   4edd8:	1c5c      	adds	r4, r3, #1
   4edda:	8084      	strh	r4, [r0, #4]
	uint8_t *u8;

	NET_BUF_SIMPLE_DBG("buf %p val 0x%02x", buf, val);

	u8 = net_buf_simple_add(buf, 1);
	*u8 = val;
   4eddc:	54d1      	strb	r1, [r2, r3]

	return u8;
}
   4edde:	18d0      	adds	r0, r2, r3
   4ede0:	bd10      	pop	{r4, pc}

0004ede2 <net_buf_simple_add_le16>:
   4ede2:	8883      	ldrh	r3, [r0, #4]
   4ede4:	6802      	ldr	r2, [r0, #0]

void net_buf_simple_add_le16(struct net_buf_simple *buf, uint16_t val)
{
   4ede6:	b530      	push	{r4, r5, lr}
   4ede8:	18d4      	adds	r4, r2, r3
	buf->len += len;
   4edea:	1c9d      	adds	r5, r3, #2
   4edec:	8085      	strh	r5, [r0, #4]
	dst[0] = val;
   4edee:	54d1      	strb	r1, [r2, r3]
	dst[1] = val >> 8;
   4edf0:	0a09      	lsrs	r1, r1, #8
   4edf2:	7061      	strb	r1, [r4, #1]
	NET_BUF_SIMPLE_DBG("buf %p val %u", buf, val);

	sys_put_le16(val, net_buf_simple_add(buf, sizeof(val)));
}
   4edf4:	bd30      	pop	{r4, r5, pc}

0004edf6 <net_buf_simple_push>:

	return sys_be64_to_cpu(val);
}

void *net_buf_simple_push(struct net_buf_simple *buf, size_t len)
{
   4edf6:	4603      	mov	r3, r0
	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(net_buf_simple_headroom(buf) >= len);

	buf->data -= len;
   4edf8:	6800      	ldr	r0, [r0, #0]
	buf->len += len;
   4edfa:	889a      	ldrh	r2, [r3, #4]
	buf->data -= len;
   4edfc:	1a40      	subs	r0, r0, r1
	buf->len += len;
   4edfe:	4411      	add	r1, r2
	buf->data -= len;
   4ee00:	6018      	str	r0, [r3, #0]
	buf->len += len;
   4ee02:	8099      	strh	r1, [r3, #4]
	return buf->data;
}
   4ee04:	4770      	bx	lr

0004ee06 <net_buf_simple_pull>:
{
	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(buf->len >= len);

	buf->len -= len;
   4ee06:	8882      	ldrh	r2, [r0, #4]
   4ee08:	1a52      	subs	r2, r2, r1
{
   4ee0a:	4603      	mov	r3, r0
	buf->len -= len;
   4ee0c:	8082      	strh	r2, [r0, #4]
	return buf->data += len;
   4ee0e:	6800      	ldr	r0, [r0, #0]
   4ee10:	4408      	add	r0, r1
   4ee12:	6018      	str	r0, [r3, #0]
}
   4ee14:	4770      	bx	lr

0004ee16 <net_buf_simple_pull_mem>:

void *net_buf_simple_pull_mem(struct net_buf_simple *buf, size_t len)
{
   4ee16:	4603      	mov	r3, r0
	void *data = buf->data;
   4ee18:	6800      	ldr	r0, [r0, #0]

	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(buf->len >= len);

	buf->len -= len;
   4ee1a:	889a      	ldrh	r2, [r3, #4]
   4ee1c:	1a52      	subs	r2, r2, r1
	buf->data += len;
   4ee1e:	4401      	add	r1, r0
	buf->len -= len;
   4ee20:	809a      	strh	r2, [r3, #4]
	buf->data += len;
   4ee22:	6019      	str	r1, [r3, #0]

	return data;
}
   4ee24:	4770      	bx	lr

0004ee26 <net_buf_simple_pull_u8>:

uint8_t net_buf_simple_pull_u8(struct net_buf_simple *buf)
{
   4ee26:	b510      	push	{r4, lr}
	uint8_t val;

	val = buf->data[0];
   4ee28:	6803      	ldr	r3, [r0, #0]
   4ee2a:	781c      	ldrb	r4, [r3, #0]
	net_buf_simple_pull(buf, 1);
   4ee2c:	2101      	movs	r1, #1
   4ee2e:	f7ff ffea 	bl	4ee06 <net_buf_simple_pull>

	return val;
}
   4ee32:	4620      	mov	r0, r4
   4ee34:	bd10      	pop	{r4, pc}

0004ee36 <net_buf_simple_pull_le16>:

uint16_t net_buf_simple_pull_le16(struct net_buf_simple *buf)
{
   4ee36:	b510      	push	{r4, lr}
	uint16_t val;

	val = UNALIGNED_GET((uint16_t *)buf->data);
   4ee38:	6803      	ldr	r3, [r0, #0]
   4ee3a:	881c      	ldrh	r4, [r3, #0]
	net_buf_simple_pull(buf, sizeof(val));
   4ee3c:	2102      	movs	r1, #2
   4ee3e:	f7ff ffe2 	bl	4ee06 <net_buf_simple_pull>

	return sys_le16_to_cpu(val);
}
   4ee42:	4620      	mov	r0, r4
   4ee44:	bd10      	pop	{r4, pc}

0004ee46 <net_buf_simple_headroom>:
	return sys_be64_to_cpu(val);
}

size_t net_buf_simple_headroom(struct net_buf_simple *buf)
{
	return buf->data - buf->__buf;
   4ee46:	6802      	ldr	r2, [r0, #0]
   4ee48:	6880      	ldr	r0, [r0, #8]
}
   4ee4a:	1a10      	subs	r0, r2, r0
   4ee4c:	4770      	bx	lr

0004ee4e <net_buf_simple_tailroom>:

size_t net_buf_simple_tailroom(struct net_buf_simple *buf)
{
	return buf->size - net_buf_simple_headroom(buf) - buf->len;
   4ee4e:	8883      	ldrh	r3, [r0, #4]
   4ee50:	88c2      	ldrh	r2, [r0, #6]
	return buf->data - buf->__buf;
   4ee52:	6881      	ldr	r1, [r0, #8]
	return buf->size - net_buf_simple_headroom(buf) - buf->len;
   4ee54:	1ad2      	subs	r2, r2, r3
	return buf->data - buf->__buf;
   4ee56:	6803      	ldr	r3, [r0, #0]
   4ee58:	1a5b      	subs	r3, r3, r1
}
   4ee5a:	1ad0      	subs	r0, r2, r3
   4ee5c:	4770      	bx	lr

0004ee5e <hid_interface_config>:
	desc->if0.bInterfaceNumber = bInterfaceNumber;
   4ee5e:	7081      	strb	r1, [r0, #2]
}
   4ee60:	4770      	bx	lr

0004ee62 <usb_hid_device_init>:
static int usb_hid_device_init(const struct device *dev)
{
	LOG_DBG("Init HID Device: dev %p (%s)", dev, dev->name);

	return 0;
}
   4ee62:	2000      	movs	r0, #0
   4ee64:	4770      	bx	lr

0004ee66 <usb_hid_init>:
	usb_set_hid_report_size(cfg, dev_data->report_size);
   4ee66:	6903      	ldr	r3, [r0, #16]
   4ee68:	6842      	ldr	r2, [r0, #4]
   4ee6a:	685b      	ldr	r3, [r3, #4]
   4ee6c:	6852      	ldr	r2, [r2, #4]
	dst[0] = val;
   4ee6e:	7413      	strb	r3, [r2, #16]
	dst[1] = val >> 8;
   4ee70:	f3c3 2307 	ubfx	r3, r3, #8, #8
   4ee74:	7453      	strb	r3, [r2, #17]
}
   4ee76:	2000      	movs	r0, #0
   4ee78:	4770      	bx	lr

0004ee7a <hid_int_ep_write>:
{
   4ee7a:	b430      	push	{r4, r5}
	const struct usb_cfg_data *cfg = dev->config;
   4ee7c:	6844      	ldr	r4, [r0, #4]
	struct hid_device_info *hid_dev_data = dev->data;
   4ee7e:	6900      	ldr	r0, [r0, #16]
	if (hid_dev_data->configured && !hid_dev_data->suspended) {
   4ee80:	7b05      	ldrb	r5, [r0, #12]
   4ee82:	b135      	cbz	r5, 4ee92 <hid_int_ep_write+0x18>
   4ee84:	7b40      	ldrb	r0, [r0, #13]
   4ee86:	b920      	cbnz	r0, 4ee92 <hid_int_ep_write+0x18>
		return usb_write(cfg->endpoint[HID_INT_IN_EP_IDX].ep_addr, data,
   4ee88:	6a20      	ldr	r0, [r4, #32]
}
   4ee8a:	bc30      	pop	{r4, r5}
		return usb_write(cfg->endpoint[HID_INT_IN_EP_IDX].ep_addr, data,
   4ee8c:	7900      	ldrb	r0, [r0, #4]
   4ee8e:	f7fa bbd5 	b.w	4963c <usb_write>
}
   4ee92:	f06f 000a 	mvn.w	r0, #10
   4ee96:	bc30      	pop	{r4, r5}
   4ee98:	4770      	bx	lr

0004ee9a <ep_ctx_reset>:
{
   4ee9a:	b510      	push	{r4, lr}
	ep_ctx->buf.data = ep_ctx->buf.block.data;
   4ee9c:	6903      	ldr	r3, [r0, #16]
	ep_ctx->buf.curr = ep_ctx->buf.data;
   4ee9e:	e9c0 3305 	strd	r3, r3, [r0, #20]
	ep_ctx->buf.len  = 0U;
   4eea2:	2300      	movs	r3, #0
   4eea4:	60c3      	str	r3, [r0, #12]
	if (ep_ctx->write_in_progress) {
   4eea6:	7f83      	ldrb	r3, [r0, #30]
{
   4eea8:	4604      	mov	r4, r0
	if (ep_ctx->write_in_progress) {
   4eeaa:	b113      	cbz	r3, 4eeb2 <ep_ctx_reset+0x18>
		nrfx_usbd_ep_abort(ep_addr_to_nrfx(ep_ctx->cfg.addr));
   4eeac:	7a40      	ldrb	r0, [r0, #9]
   4eeae:	f000 fb57 	bl	4f560 <nrfx_usbd_ep_abort>
	ep_ctx->read_complete = true;
   4eeb2:	2301      	movs	r3, #1
   4eeb4:	7723      	strb	r3, [r4, #28]
	ep_ctx->read_pending = false;
   4eeb6:	2300      	movs	r3, #0
   4eeb8:	7763      	strb	r3, [r4, #29]
	ep_ctx->trans_zlp = false;
   4eeba:	77e3      	strb	r3, [r4, #31]
	ep_ctx->write_in_progress = false;
   4eebc:	77a3      	strb	r3, [r4, #30]
}
   4eebe:	bd10      	pop	{r4, pc}

0004eec0 <k_mutex_lock.constprop.0.isra.0>:
	return z_impl_k_mutex_lock(mutex, timeout);
   4eec0:	f7f8 b870 	b.w	46fa4 <z_impl_k_mutex_lock>

0004eec4 <k_mutex_unlock.isra.0>:
	return z_impl_k_mutex_unlock(mutex);
   4eec4:	f7f8 b8e8 	b.w	47098 <z_impl_k_mutex_unlock>

0004eec8 <usb_dc_ep_check_cap>:
	uint8_t ep_idx = NRF_USBD_EP_NR_GET(ep_cfg->ep_addr);
   4eec8:	7803      	ldrb	r3, [r0, #0]
	if ((ep_cfg->ep_type == USB_DC_EP_CONTROL) && ep_idx) {
   4eeca:	7901      	ldrb	r1, [r0, #4]
	uint8_t ep_idx = NRF_USBD_EP_NR_GET(ep_cfg->ep_addr);
   4eecc:	f003 020f 	and.w	r2, r3, #15
	if ((ep_cfg->ep_type == USB_DC_EP_CONTROL) && ep_idx) {
   4eed0:	b921      	cbnz	r1, 4eedc <usb_dc_ep_check_cap+0x14>
   4eed2:	3a00      	subs	r2, #0
   4eed4:	bf18      	it	ne
   4eed6:	2201      	movne	r2, #1
   4eed8:	4250      	negs	r0, r2
   4eeda:	4770      	bx	lr
	if (!NRF_USBD_EP_VALIDATE(ep_cfg->ep_addr)) {
   4eedc:	2a08      	cmp	r2, #8
   4eede:	d806      	bhi.n	4eeee <usb_dc_ep_check_cap+0x26>
	if ((ep_cfg->ep_type == USB_DC_EP_ISOCHRONOUS) &&
   4eee0:	2901      	cmp	r1, #1
   4eee2:	d107      	bne.n	4eef4 <usb_dc_ep_check_cap+0x2c>
   4eee4:	f083 0008 	eor.w	r0, r3, #8
   4eee8:	f340 00c0 	sbfx	r0, r0, #3, #1
   4eeec:	4770      	bx	lr
		return -1;
   4eeee:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   4eef2:	4770      	bx	lr
	return 0;
   4eef4:	2000      	movs	r0, #0
}
   4eef6:	4770      	bx	lr

0004eef8 <usb_dc_ep_read>:
{
   4eef8:	b570      	push	{r4, r5, r6, lr}
   4eefa:	4604      	mov	r4, r0
   4eefc:	460e      	mov	r6, r1
   4eefe:	4615      	mov	r5, r2
	ret = usb_dc_ep_read_wait(ep, data, max_data_len, read_bytes);
   4ef00:	f7f4 fada 	bl	434b8 <usb_dc_ep_read_wait>
	if (ret) {
   4ef04:	b930      	cbnz	r0, 4ef14 <usb_dc_ep_read+0x1c>
	if (!data && !max_data_len) {
   4ef06:	b906      	cbnz	r6, 4ef0a <usb_dc_ep_read+0x12>
   4ef08:	b125      	cbz	r5, 4ef14 <usb_dc_ep_read+0x1c>
	ret = usb_dc_ep_read_continue(ep);
   4ef0a:	4620      	mov	r0, r4
}
   4ef0c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	ret = usb_dc_ep_read_continue(ep);
   4ef10:	f7f4 bb1a 	b.w	43548 <usb_dc_ep_read_continue>
}
   4ef14:	bd70      	pop	{r4, r5, r6, pc}

0004ef16 <usb_dc_wakeup_request>:
{
   4ef16:	b508      	push	{r3, lr}
	bool res = nrfx_usbd_wakeup_req();
   4ef18:	f7f6 ff5e 	bl	45dd8 <nrfx_usbd_wakeup_req>
	return 0;
   4ef1c:	2800      	cmp	r0, #0
}
   4ef1e:	bf0c      	ite	eq
   4ef20:	f06f 000a 	mvneq.w	r0, #10
   4ef24:	2000      	movne	r0, #0
   4ef26:	bd08      	pop	{r3, pc}

0004ef28 <adc_context_on_timer_expired>:
{
   4ef28:	b410      	push	{r4}
   4ef2a:	4603      	mov	r3, r0
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   4ef2c:	3808      	subs	r0, #8
   4ef2e:	f3bf 8f5b 	dmb	ish
   4ef32:	e850 2f00 	ldrex	r2, [r0]
   4ef36:	1c51      	adds	r1, r2, #1
   4ef38:	e840 1400 	strex	r4, r1, [r0]
   4ef3c:	2c00      	cmp	r4, #0
   4ef3e:	d1f8      	bne.n	4ef32 <adc_context_on_timer_expired+0xa>
   4ef40:	f3bf 8f5b 	dmb	ish
	if (atomic_inc(&ctx->sampling_requested) == 0) {
   4ef44:	b912      	cbnz	r2, 4ef4c <adc_context_on_timer_expired+0x24>
}
   4ef46:	bc10      	pop	{r4}
		adc_context_start_sampling(ctx);
   4ef48:	f7f4 bb82 	b.w	43650 <adc_context_start_sampling>
		ctx->status = -EBUSY;
   4ef4c:	f06f 020f 	mvn.w	r2, #15
}
   4ef50:	bc10      	pop	{r4}
		ctx->status = -EBUSY;
   4ef52:	669a      	str	r2, [r3, #104]	; 0x68
}
   4ef54:	4770      	bx	lr

0004ef56 <get_status>:
	return GET_STATUS(get_sub_data(dev, type)->flags);
   4ef56:	6903      	ldr	r3, [r0, #16]
   4ef58:	b2c9      	uxtb	r1, r1
   4ef5a:	220c      	movs	r2, #12
   4ef5c:	fb01 3302 	mla	r3, r1, r2, r3
   4ef60:	6c18      	ldr	r0, [r3, #64]	; 0x40
}
   4ef62:	f000 0007 	and.w	r0, r0, #7
   4ef66:	4770      	bx	lr

0004ef68 <set_on_state>:
	__asm__ volatile(
   4ef68:	f04f 0320 	mov.w	r3, #32
   4ef6c:	f3ef 8211 	mrs	r2, BASEPRI
   4ef70:	f383 8812 	msr	BASEPRI_MAX, r3
   4ef74:	f3bf 8f6f 	isb	sy
	*flags = CLOCK_CONTROL_STATUS_ON | GET_CTX(*flags);
   4ef78:	6803      	ldr	r3, [r0, #0]
   4ef7a:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   4ef7e:	f043 0302 	orr.w	r3, r3, #2
   4ef82:	6003      	str	r3, [r0, #0]
	__asm__ volatile(
   4ef84:	f382 8811 	msr	BASEPRI, r2
   4ef88:	f3bf 8f6f 	isb	sy
}
   4ef8c:	4770      	bx	lr

0004ef8e <stop>:
{
   4ef8e:	b570      	push	{r4, r5, r6, lr}
   4ef90:	b2c9      	uxtb	r1, r1
	struct nrf_clock_control_data *data = dev->data;
   4ef92:	6903      	ldr	r3, [r0, #16]
	__asm__ volatile(
   4ef94:	f04f 0420 	mov.w	r4, #32
   4ef98:	f3ef 8511 	mrs	r5, BASEPRI
   4ef9c:	f384 8812 	msr	BASEPRI_MAX, r4
   4efa0:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
   4efa4:	260c      	movs	r6, #12
   4efa6:	fb06 3401 	mla	r4, r6, r1, r3
   4efaa:	6c24      	ldr	r4, [r4, #64]	; 0x40
	if ((current_ctx != 0) && (current_ctx != ctx)) {
   4efac:	f014 04c0 	ands.w	r4, r4, #192	; 0xc0
   4efb0:	d008      	beq.n	4efc4 <stop+0x36>
   4efb2:	42a2      	cmp	r2, r4
   4efb4:	d006      	beq.n	4efc4 <stop+0x36>
	__asm__ volatile(
   4efb6:	f385 8811 	msr	BASEPRI, r5
   4efba:	f3bf 8f6f 	isb	sy
		err = -EPERM;
   4efbe:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
   4efc2:	bd70      	pop	{r4, r5, r6, pc}
		*flags = CLOCK_CONTROL_STATUS_OFF;
   4efc4:	fb06 3301 	mla	r3, r6, r1, r3
   4efc8:	2201      	movs	r2, #1
   4efca:	641a      	str	r2, [r3, #64]	; 0x40
   4efcc:	f385 8811 	msr	BASEPRI, r5
   4efd0:	f3bf 8f6f 	isb	sy
	get_sub_config(dev, type)->stop();
   4efd4:	6843      	ldr	r3, [r0, #4]
   4efd6:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
   4efda:	685b      	ldr	r3, [r3, #4]
   4efdc:	4798      	blx	r3
	return 0;
   4efde:	2000      	movs	r0, #0
   4efe0:	e7ef      	b.n	4efc2 <stop+0x34>

0004efe2 <api_stop>:
	return stop(dev, subsys, CTX_API);
   4efe2:	2280      	movs	r2, #128	; 0x80
   4efe4:	f7ff bfd3 	b.w	4ef8e <stop>

0004efe8 <async_start>:
{
   4efe8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   4efea:	9f06      	ldr	r7, [sp, #24]
	struct nrf_clock_control_data *data = dev->data;
   4efec:	6904      	ldr	r4, [r0, #16]
	return &data->subsys[type];
   4efee:	b2c9      	uxtb	r1, r1
	__asm__ volatile(
   4eff0:	f04f 0520 	mov.w	r5, #32
   4eff4:	f3ef 8611 	mrs	r6, BASEPRI
   4eff8:	f385 8812 	msr	BASEPRI_MAX, r5
   4effc:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
   4f000:	250c      	movs	r5, #12
   4f002:	fb05 4401 	mla	r4, r5, r1, r4
   4f006:	6c25      	ldr	r5, [r4, #64]	; 0x40
	if ((*flags & (STATUS_MASK)) == CLOCK_CONTROL_STATUS_OFF) {
   4f008:	f005 0c07 	and.w	ip, r5, #7
   4f00c:	f1bc 0f01 	cmp.w	ip, #1
   4f010:	d10c      	bne.n	4f02c <async_start+0x44>
		*flags = CLOCK_CONTROL_STATUS_STARTING | ctx;
   4f012:	6427      	str	r7, [r4, #64]	; 0x40
	__asm__ volatile(
   4f014:	f386 8811 	msr	BASEPRI, r6
   4f018:	f3bf 8f6f 	isb	sy
	subdata->user_data = user_data;
   4f01c:	e9c4 230e 	strd	r2, r3, [r4, #56]	; 0x38
	 get_sub_config(dev, type)->start();
   4f020:	6843      	ldr	r3, [r0, #4]
   4f022:	f853 3031 	ldr.w	r3, [r3, r1, lsl #3]
   4f026:	4798      	blx	r3
	return 0;
   4f028:	2000      	movs	r0, #0
}
   4f02a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	uint32_t current_ctx = GET_CTX(*flags);
   4f02c:	f005 05c0 	and.w	r5, r5, #192	; 0xc0
	} else if (current_ctx != ctx) {
   4f030:	42af      	cmp	r7, r5
   4f032:	f386 8811 	msr	BASEPRI, r6
   4f036:	f3bf 8f6f 	isb	sy
		err = -EALREADY;
   4f03a:	bf0c      	ite	eq
   4f03c:	f06f 0077 	mvneq.w	r0, #119	; 0x77
		err = -EPERM;
   4f040:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
   4f044:	e7f1      	b.n	4f02a <async_start+0x42>

0004f046 <api_start>:
{
   4f046:	b513      	push	{r0, r1, r4, lr}
	return async_start(dev, subsys, cb, user_data, CTX_API);
   4f048:	2480      	movs	r4, #128	; 0x80
   4f04a:	9400      	str	r4, [sp, #0]
   4f04c:	f7ff ffcc 	bl	4efe8 <async_start>
}
   4f050:	b002      	add	sp, #8
   4f052:	bd10      	pop	{r4, pc}

0004f054 <onoff_started_callback>:
{
   4f054:	b410      	push	{r4}
	return &data->mgr[type];
   4f056:	6900      	ldr	r0, [r0, #16]
   4f058:	b2cb      	uxtb	r3, r1
	notify(mgr, 0);
   4f05a:	241c      	movs	r4, #28
   4f05c:	fb03 0004 	mla	r0, r3, r4, r0
   4f060:	2100      	movs	r1, #0
}
   4f062:	bc10      	pop	{r4}
	notify(mgr, 0);
   4f064:	4710      	bx	r2

0004f066 <lfclk_start>:
    nrfx_clock_start(NRF_CLOCK_DOMAIN_LFCLK);
   4f066:	2000      	movs	r0, #0
   4f068:	f000 b90e 	b.w	4f288 <nrfx_clock_start>

0004f06c <lfclk_stop>:
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
   4f06c:	2000      	movs	r0, #0
   4f06e:	f000 b947 	b.w	4f300 <nrfx_clock_stop>

0004f072 <blocking_start_callback>:
{
   4f072:	4610      	mov	r0, r2
	z_impl_k_sem_give(sem);
   4f074:	f7f8 b880 	b.w	47178 <z_impl_k_sem_give>

0004f078 <gpio_nrfx_port_get_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   4f078:	6843      	ldr	r3, [r0, #4]
   4f07a:	685b      	ldr	r3, [r3, #4]
    return p_reg->IN;
   4f07c:	f8d3 3510 	ldr.w	r3, [r3, #1296]	; 0x510
	*value = nrf_gpio_port_in_read(reg);
   4f080:	600b      	str	r3, [r1, #0]
}
   4f082:	2000      	movs	r0, #0
   4f084:	4770      	bx	lr

0004f086 <gpio_nrfx_port_set_masked_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   4f086:	6843      	ldr	r3, [r0, #4]
   4f088:	685b      	ldr	r3, [r3, #4]
	const uint32_t set_mask = value & mask;
   4f08a:	ea02 0001 	and.w	r0, r2, r1
	const uint32_t clear_mask = (~set_mask) & mask;
   4f08e:	ea21 0102 	bic.w	r1, r1, r2
    p_reg->OUTSET = set_mask;
   4f092:	f8c3 0508 	str.w	r0, [r3, #1288]	; 0x508
    p_reg->OUTCLR = clr_mask;
   4f096:	f8c3 150c 	str.w	r1, [r3, #1292]	; 0x50c
}
   4f09a:	2000      	movs	r0, #0
   4f09c:	4770      	bx	lr

0004f09e <gpio_nrfx_port_set_bits_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   4f09e:	6843      	ldr	r3, [r0, #4]
   4f0a0:	685b      	ldr	r3, [r3, #4]
}
   4f0a2:	2000      	movs	r0, #0
    p_reg->OUTSET = set_mask;
   4f0a4:	f8c3 1508 	str.w	r1, [r3, #1288]	; 0x508
   4f0a8:	4770      	bx	lr

0004f0aa <gpio_nrfx_port_clear_bits_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   4f0aa:	6843      	ldr	r3, [r0, #4]
   4f0ac:	685b      	ldr	r3, [r3, #4]
}
   4f0ae:	2000      	movs	r0, #0
    p_reg->OUTCLR = clr_mask;
   4f0b0:	f8c3 150c 	str.w	r1, [r3, #1292]	; 0x50c
   4f0b4:	4770      	bx	lr

0004f0b6 <gpio_nrfx_port_toggle_bits>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   4f0b6:	6843      	ldr	r3, [r0, #4]
   4f0b8:	685a      	ldr	r2, [r3, #4]
    return p_reg->OUT;
   4f0ba:	f8d2 3504 	ldr.w	r3, [r2, #1284]	; 0x504
	const uint32_t set_mask = value & mask;
   4f0be:	ea21 0003 	bic.w	r0, r1, r3
	const uint32_t clear_mask = (~value) & mask;
   4f0c2:	400b      	ands	r3, r1
    p_reg->OUTSET = set_mask;
   4f0c4:	f8c2 0508 	str.w	r0, [r2, #1288]	; 0x508
    p_reg->OUTCLR = clr_mask;
   4f0c8:	f8c2 350c 	str.w	r3, [r2, #1292]	; 0x50c
}
   4f0cc:	2000      	movs	r0, #0
   4f0ce:	4770      	bx	lr

0004f0d0 <gpio_nrfx_manage_callback>:
{
   4f0d0:	b510      	push	{r4, lr}
	return port->data;
   4f0d2:	6903      	ldr	r3, [r0, #16]
	return list->head;
   4f0d4:	6858      	ldr	r0, [r3, #4]
	if (!sys_slist_is_empty(callbacks)) {
   4f0d6:	b148      	cbz	r0, 4f0ec <gpio_nrfx_manage_callback+0x1c>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   4f0d8:	4288      	cmp	r0, r1
   4f0da:	d113      	bne.n	4f104 <gpio_nrfx_manage_callback+0x34>
Z_GENLIST_REMOVE(slist, snode)
   4f0dc:	689c      	ldr	r4, [r3, #8]
	return node->next;
   4f0de:	6808      	ldr	r0, [r1, #0]
	list->head = node;
   4f0e0:	6058      	str	r0, [r3, #4]
Z_GENLIST_REMOVE(slist, snode)
   4f0e2:	42a1      	cmp	r1, r4
   4f0e4:	d100      	bne.n	4f0e8 <gpio_nrfx_manage_callback+0x18>
	list->tail = node;
   4f0e6:	6098      	str	r0, [r3, #8]
	parent->next = child;
   4f0e8:	2000      	movs	r0, #0
   4f0ea:	6008      	str	r0, [r1, #0]
	if (set) {
   4f0ec:	b97a      	cbnz	r2, 4f10e <gpio_nrfx_manage_callback+0x3e>
	return 0;
   4f0ee:	2000      	movs	r0, #0
}
   4f0f0:	bd10      	pop	{r4, pc}
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   4f0f2:	4281      	cmp	r1, r0
   4f0f4:	d106      	bne.n	4f104 <gpio_nrfx_manage_callback+0x34>
	return node->next;
   4f0f6:	6808      	ldr	r0, [r1, #0]
	parent->next = child;
   4f0f8:	6020      	str	r0, [r4, #0]
Z_GENLIST_REMOVE(slist, snode)
   4f0fa:	6898      	ldr	r0, [r3, #8]
   4f0fc:	4281      	cmp	r1, r0
   4f0fe:	d1f3      	bne.n	4f0e8 <gpio_nrfx_manage_callback+0x18>
	list->tail = node;
   4f100:	609c      	str	r4, [r3, #8]
}
   4f102:	e7f1      	b.n	4f0e8 <gpio_nrfx_manage_callback+0x18>
	return node->next;
   4f104:	4604      	mov	r4, r0
   4f106:	6800      	ldr	r0, [r0, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   4f108:	2800      	cmp	r0, #0
   4f10a:	d1f2      	bne.n	4f0f2 <gpio_nrfx_manage_callback+0x22>
			if (!set) {
   4f10c:	b13a      	cbz	r2, 4f11e <gpio_nrfx_manage_callback+0x4e>
	return list->head;
   4f10e:	685a      	ldr	r2, [r3, #4]
	parent->next = child;
   4f110:	600a      	str	r2, [r1, #0]
Z_GENLIST_PREPEND(slist, snode)
   4f112:	689a      	ldr	r2, [r3, #8]
	list->head = node;
   4f114:	6059      	str	r1, [r3, #4]
Z_GENLIST_PREPEND(slist, snode)
   4f116:	2a00      	cmp	r2, #0
   4f118:	d1e9      	bne.n	4f0ee <gpio_nrfx_manage_callback+0x1e>
	list->tail = node;
   4f11a:	6099      	str	r1, [r3, #8]
}
   4f11c:	e7e7      	b.n	4f0ee <gpio_nrfx_manage_callback+0x1e>
				return -EINVAL;
   4f11e:	f06f 0015 	mvn.w	r0, #21
	return gpio_manage_callback(&get_port_data(port)->callbacks,
   4f122:	e7e5      	b.n	4f0f0 <gpio_nrfx_manage_callback+0x20>

0004f124 <z_impl_hwinfo_get_device_id>:
struct nrf_uid {
	uint32_t id[2];
};

ssize_t z_impl_hwinfo_get_device_id(uint8_t *buffer, size_t length)
{
   4f124:	b513      	push	{r0, r1, r4, lr}
NRF_STATIC_INLINE uint32_t nrf_ficr_deviceid_get(NRF_FICR_Type const * p_reg, uint32_t reg_id)
{
#if defined(FICR_INFO_DEVICEID_DEVICEID_Msk)
    return p_reg->INFO.DEVICEID[reg_id];
#else
    return p_reg->DEVICEID[reg_id];
   4f126:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
	soc_secure_read_deviceid(deviceid);

	dev_id.id[0] = sys_cpu_to_be32(deviceid[1]);
	dev_id.id[1] = sys_cpu_to_be32(deviceid[0]);

	if (length > sizeof(dev_id.id)) {
   4f12a:	2908      	cmp	r1, #8
   4f12c:	6e13      	ldr	r3, [r2, #96]	; 0x60
   4f12e:	6e52      	ldr	r2, [r2, #100]	; 0x64
   4f130:	bf28      	it	cs
   4f132:	2108      	movcs	r1, #8
   4f134:	ba12      	rev	r2, r2
	dev_id.id[0] = sys_cpu_to_be32(deviceid[1]);
   4f136:	9200      	str	r2, [sp, #0]
	dev_id.id[1] = sys_cpu_to_be32(deviceid[0]);
   4f138:	ba1b      	rev	r3, r3
	if (length > sizeof(dev_id.id)) {
   4f13a:	460c      	mov	r4, r1
		length = sizeof(dev_id.id);
	}

	memcpy(buffer, dev_id.id, length);
   4f13c:	460a      	mov	r2, r1
   4f13e:	4669      	mov	r1, sp
	dev_id.id[1] = sys_cpu_to_be32(deviceid[0]);
   4f140:	9301      	str	r3, [sp, #4]
	memcpy(buffer, dev_id.id, length);
   4f142:	f7fb fe9a 	bl	4ae7a <memcpy>

	return length;
}
   4f146:	4620      	mov	r0, r4
   4f148:	b002      	add	sp, #8
   4f14a:	bd10      	pop	{r4, pc}

0004f14c <is_regular_addr_valid>:
{
   4f14c:	b538      	push	{r3, r4, r5, lr}
   4f14e:	4605      	mov	r5, r0
   4f150:	460c      	mov	r4, r1
	return is_within_bounds(addr, len, 0, nrfx_nvmc_flash_size_get());
   4f152:	f000 f92f 	bl	4f3b4 <nrfx_nvmc_flash_size_get>
			(addr < (boundary_start + boundary_size)) &&
   4f156:	2d00      	cmp	r5, #0
   4f158:	db07      	blt.n	4f16a <is_regular_addr_valid+0x1e>
	return (addr >= boundary_start &&
   4f15a:	42a8      	cmp	r0, r5
   4f15c:	d905      	bls.n	4f16a <is_regular_addr_valid+0x1e>
			(len <= (boundary_start + boundary_size - addr)));
   4f15e:	1b40      	subs	r0, r0, r5
			(addr < (boundary_start + boundary_size)) &&
   4f160:	4284      	cmp	r4, r0
   4f162:	bf8c      	ite	hi
   4f164:	2000      	movhi	r0, #0
   4f166:	2001      	movls	r0, #1
}
   4f168:	bd38      	pop	{r3, r4, r5, pc}
			(addr < (boundary_start + boundary_size)) &&
   4f16a:	2000      	movs	r0, #0
   4f16c:	e7fc      	b.n	4f168 <is_regular_addr_valid+0x1c>

0004f16e <flash_nrf_read>:
{
   4f16e:	b570      	push	{r4, r5, r6, lr}
   4f170:	460d      	mov	r5, r1
	if (is_regular_addr_valid(addr, len)) {
   4f172:	4628      	mov	r0, r5
   4f174:	4619      	mov	r1, r3
{
   4f176:	4616      	mov	r6, r2
   4f178:	461c      	mov	r4, r3
	if (is_regular_addr_valid(addr, len)) {
   4f17a:	f7ff ffe7 	bl	4f14c <is_regular_addr_valid>
   4f17e:	b138      	cbz	r0, 4f190 <flash_nrf_read+0x22>
	if (!len) {
   4f180:	b124      	cbz	r4, 4f18c <flash_nrf_read+0x1e>
	memcpy(data, (void *)addr, len);
   4f182:	4622      	mov	r2, r4
   4f184:	4629      	mov	r1, r5
   4f186:	4630      	mov	r0, r6
   4f188:	f7fb fe77 	bl	4ae7a <memcpy>
		return 0;
   4f18c:	2000      	movs	r0, #0
}
   4f18e:	bd70      	pop	{r4, r5, r6, pc}
		return -EINVAL;
   4f190:	f06f 0015 	mvn.w	r0, #21
   4f194:	e7fb      	b.n	4f18e <flash_nrf_read+0x20>

0004f196 <nrf_flash_sync_is_required>:
	return ticker_is_initialized(0);
   4f196:	2000      	movs	r0, #0
   4f198:	f7e6 bb8a 	b.w	358b0 <ticker_is_initialized>

0004f19c <flash_get_page_info>:

#include <zephyr/drivers/flash.h>

static int flash_get_page_info(const struct device *dev, off_t offs,
			       uint32_t index, struct flash_pages_info *info)
{
   4f19c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   4f19e:	461c      	mov	r4, r3
   4f1a0:	4616      	mov	r6, r2
	const struct flash_driver_api *api = dev->api;
	const struct flash_pages_layout *layout;
	size_t layout_size;
	uint32_t index_jmp;

	info->start_offset = 0;
   4f1a2:	2300      	movs	r3, #0
	const struct flash_driver_api *api = dev->api;
   4f1a4:	6882      	ldr	r2, [r0, #8]
	info->start_offset = 0;
   4f1a6:	6023      	str	r3, [r4, #0]
	info->index = 0U;
   4f1a8:	60a3      	str	r3, [r4, #8]

	api->page_layout(dev, &layout, &layout_size);
   4f1aa:	6913      	ldr	r3, [r2, #16]
{
   4f1ac:	460d      	mov	r5, r1
	api->page_layout(dev, &layout, &layout_size);
   4f1ae:	aa01      	add	r2, sp, #4
   4f1b0:	4669      	mov	r1, sp
   4f1b2:	4798      	blx	r3

	while (layout_size--) {
   4f1b4:	9b01      	ldr	r3, [sp, #4]
   4f1b6:	1e5a      	subs	r2, r3, #1
   4f1b8:	9201      	str	r2, [sp, #4]
   4f1ba:	b91b      	cbnz	r3, 4f1c4 <flash_get_page_info+0x28>
		}

		layout++;
	}

	return -EINVAL; /* page at offs or idx doesn't exist */
   4f1bc:	f06f 0015 	mvn.w	r0, #21
}
   4f1c0:	b003      	add	sp, #12
   4f1c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
		info->size = layout->pages_size;
   4f1c4:	9800      	ldr	r0, [sp, #0]
			index_jmp = index - info->index;
   4f1c6:	68a2      	ldr	r2, [r4, #8]
		info->size = layout->pages_size;
   4f1c8:	6847      	ldr	r7, [r0, #4]
			index_jmp = (offs - info->start_offset) / info->size;
   4f1ca:	6821      	ldr	r1, [r4, #0]
		info->size = layout->pages_size;
   4f1cc:	6067      	str	r7, [r4, #4]
		if (offs == 0) {
   4f1ce:	b985      	cbnz	r5, 4f1f2 <flash_get_page_info+0x56>
			index_jmp = index - info->index;
   4f1d0:	1ab3      	subs	r3, r6, r2
		index_jmp = MIN(index_jmp, layout->pages_count);
   4f1d2:	f8d0 c000 	ldr.w	ip, [r0]
   4f1d6:	4563      	cmp	r3, ip
   4f1d8:	bf28      	it	cs
   4f1da:	4663      	movcs	r3, ip
		info->index += index_jmp;
   4f1dc:	441a      	add	r2, r3
		info->start_offset += (index_jmp * info->size);
   4f1de:	fb03 1107 	mla	r1, r3, r7, r1
   4f1e2:	6021      	str	r1, [r4, #0]
		info->index += index_jmp;
   4f1e4:	60a2      	str	r2, [r4, #8]
		if (index_jmp < layout->pages_count) {
   4f1e6:	6802      	ldr	r2, [r0, #0]
   4f1e8:	429a      	cmp	r2, r3
   4f1ea:	d806      	bhi.n	4f1fa <flash_get_page_info+0x5e>
		layout++;
   4f1ec:	3008      	adds	r0, #8
   4f1ee:	9000      	str	r0, [sp, #0]
   4f1f0:	e7e0      	b.n	4f1b4 <flash_get_page_info+0x18>
			index_jmp = (offs - info->start_offset) / info->size;
   4f1f2:	1a6b      	subs	r3, r5, r1
   4f1f4:	fbb3 f3f7 	udiv	r3, r3, r7
   4f1f8:	e7eb      	b.n	4f1d2 <flash_get_page_info+0x36>
			return 0;
   4f1fa:	2000      	movs	r0, #0
   4f1fc:	e7e0      	b.n	4f1c0 <flash_get_page_info+0x24>

0004f1fe <z_impl_flash_get_page_info_by_offs>:

int z_impl_flash_get_page_info_by_offs(const struct device *dev, off_t offs,
				       struct flash_pages_info *info)
{
   4f1fe:	4613      	mov	r3, r2
	return flash_get_page_info(dev, offs, 0U, info);
   4f200:	2200      	movs	r2, #0
   4f202:	f7ff bfcb 	b.w	4f19c <flash_get_page_info>

0004f206 <flash_page_foreach>:
	return count;
}

void flash_page_foreach(const struct device *dev, flash_page_cb cb,
			void *data)
{
   4f206:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	const struct flash_pages_layout *layout;
	struct flash_pages_info page_info;
	size_t block, num_blocks, page = 0, i;
	off_t off = 0;

	api->page_layout(dev, &layout, &num_blocks);
   4f20a:	6883      	ldr	r3, [r0, #8]
{
   4f20c:	b086      	sub	sp, #24
	api->page_layout(dev, &layout, &num_blocks);
   4f20e:	691b      	ldr	r3, [r3, #16]
{
   4f210:	4688      	mov	r8, r1
   4f212:	4691      	mov	r9, r2
	api->page_layout(dev, &layout, &num_blocks);
   4f214:	a901      	add	r1, sp, #4
   4f216:	aa02      	add	r2, sp, #8
   4f218:	4798      	blx	r3
	off_t off = 0;
   4f21a:	2400      	movs	r4, #0
	size_t block, num_blocks, page = 0, i;
   4f21c:	46a2      	mov	sl, r4

	for (block = 0; block < num_blocks; block++) {
   4f21e:	4625      	mov	r5, r4
   4f220:	9b02      	ldr	r3, [sp, #8]
   4f222:	42ab      	cmp	r3, r5
   4f224:	d802      	bhi.n	4f22c <flash_page_foreach+0x26>

			off += page_info.size;
			page++;
		}
	}
}
   4f226:	b006      	add	sp, #24
   4f228:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		const struct flash_pages_layout *l = &layout[block];
   4f22c:	9f01      	ldr	r7, [sp, #4]
   4f22e:	eb07 07c5 	add.w	r7, r7, r5, lsl #3
		for (i = 0; i < l->pages_count; i++) {
   4f232:	2600      	movs	r6, #0
		page_info.size = l->pages_size;
   4f234:	687b      	ldr	r3, [r7, #4]
   4f236:	9304      	str	r3, [sp, #16]
		for (i = 0; i < l->pages_count; i++) {
   4f238:	683a      	ldr	r2, [r7, #0]
   4f23a:	42b2      	cmp	r2, r6
   4f23c:	eb0a 0306 	add.w	r3, sl, r6
   4f240:	d802      	bhi.n	4f248 <flash_page_foreach+0x42>
	for (block = 0; block < num_blocks; block++) {
   4f242:	3501      	adds	r5, #1
   4f244:	469a      	mov	sl, r3
   4f246:	e7eb      	b.n	4f220 <flash_page_foreach+0x1a>
			page_info.start_offset = off;
   4f248:	9403      	str	r4, [sp, #12]
			page_info.index = page;
   4f24a:	9305      	str	r3, [sp, #20]
			if (!cb(&page_info, data)) {
   4f24c:	4649      	mov	r1, r9
   4f24e:	a803      	add	r0, sp, #12
   4f250:	47c0      	blx	r8
   4f252:	2800      	cmp	r0, #0
   4f254:	d0e7      	beq.n	4f226 <flash_page_foreach+0x20>
			off += page_info.size;
   4f256:	9b04      	ldr	r3, [sp, #16]
		for (i = 0; i < l->pages_count; i++) {
   4f258:	3601      	adds	r6, #1
			off += page_info.size;
   4f25a:	441c      	add	r4, r3
		for (i = 0; i < l->pages_count; i++) {
   4f25c:	e7ec      	b.n	4f238 <flash_page_foreach+0x32>

0004f25e <entropy_bt_init>:

static int entropy_bt_init(const struct device *dev)
{
	/* Nothing to do */
	return 0;
}
   4f25e:	2000      	movs	r0, #0
   4f260:	4770      	bx	lr

0004f262 <entropy_bt_get_entropy>:

static int entropy_bt_get_entropy(const struct device *dev,
				  uint8_t *buffer, uint16_t length)
{
   4f262:	b538      	push	{r3, r4, r5, lr}
   4f264:	460c      	mov	r4, r1
   4f266:	4615      	mov	r5, r2
	if (!bt_is_ready()) {
   4f268:	f7df fa96 	bl	2e798 <bt_is_ready>
   4f26c:	b128      	cbz	r0, 4f27a <entropy_bt_get_entropy+0x18>
		return -EAGAIN;
	}

	return bt_hci_le_rand(buffer, length);
   4f26e:	4629      	mov	r1, r5
   4f270:	4620      	mov	r0, r4
}
   4f272:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	return bt_hci_le_rand(buffer, length);
   4f276:	f7de beb7 	b.w	2dfe8 <bt_hci_le_rand>
}
   4f27a:	f06f 000a 	mvn.w	r0, #10
   4f27e:	bd38      	pop	{r3, r4, r5, pc}

0004f280 <sys_clock_idle_exit>:
{
}

void __weak sys_clock_idle_exit(void)
{
}
   4f280:	4770      	bx	lr

0004f282 <nrfx_isr>:
#include <zephyr/kernel.h>
#include <soc/nrfx_coredep.h>

void nrfx_isr(const void *irq_handler)
{
	((nrfx_irq_handler_t)irq_handler)();
   4f282:	4700      	bx	r0

0004f284 <nrfx_busy_wait>:
	z_impl_k_busy_wait(usec_to_wait);
   4f284:	f001 b86e 	b.w	50364 <z_impl_k_busy_wait>

0004f288 <nrfx_clock_start>:
{
   4f288:	b508      	push	{r3, lr}
    switch (domain)
   4f28a:	b110      	cbz	r0, 4f292 <nrfx_clock_start+0xa>
   4f28c:	2801      	cmp	r0, #1
   4f28e:	d02c      	beq.n	4f2ea <nrfx_clock_start+0x62>
}
   4f290:	bd08      	pop	{r3, pc}
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   4f292:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
   4f296:	f8d2 3418 	ldr.w	r3, [r2, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   4f29a:	f8d2 1418 	ldr.w	r1, [r2, #1048]	; 0x418
   4f29e:	03c8      	lsls	r0, r1, #15
   4f2a0:	d40b      	bmi.n	4f2ba <nrfx_clock_start+0x32>
            return ((p_reg->LFCLKRUN & CLOCK_LFCLKRUN_STATUS_Msk)
   4f2a2:	f8d2 3414 	ldr.w	r3, [r2, #1044]	; 0x414
                else if (nrf_clock_start_task_check(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK))
   4f2a6:	07d9      	lsls	r1, r3, #31
   4f2a8:	d50f      	bpl.n	4f2ca <nrfx_clock_start+0x42>
    return (nrf_clock_lfclk_t)((p_reg->LFCLKSRCCOPY & CLOCK_LFCLKSRCCOPY_SRC_Msk)
   4f2aa:	f8d2 341c 	ldr.w	r3, [r2, #1052]	; 0x41c
    is_correct_clk = is_correct_clk || (*p_lfclksrc == NRF_CLOCK_LFCLK_RC);
   4f2ae:	079b      	lsls	r3, r3, #30
   4f2b0:	d408      	bmi.n	4f2c4 <nrfx_clock_start+0x3c>
    p_reg->INTENSET = mask;
   4f2b2:	2302      	movs	r3, #2
   4f2b4:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
                        break;
   4f2b8:	e7ea      	b.n	4f290 <nrfx_clock_start+0x8>
                                        >> CLOCK_LFCLKSTAT_SRC_Pos);
   4f2ba:	f003 0303 	and.w	r3, r3, #3
    is_correct_clk = is_correct_clk || (*p_lfclksrc == NRF_CLOCK_LFCLK_RC);
   4f2be:	2b01      	cmp	r3, #1
   4f2c0:	d004      	beq.n	4f2cc <nrfx_clock_start+0x44>
   4f2c2:	b113      	cbz	r3, 4f2ca <nrfx_clock_start+0x42>
        clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
   4f2c4:	2000      	movs	r0, #0
   4f2c6:	f7f5 fdd1 	bl	44e6c <clock_stop>
        *p_lfclksrc = clock_initial_lfclksrc_get();
   4f2ca:	2300      	movs	r3, #0
    p_reg->LFCLKSRC = (uint32_t)(source);
   4f2cc:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
   4f2d0:	f8c2 3518 	str.w	r3, [r2, #1304]	; 0x518
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   4f2d4:	2300      	movs	r3, #0
   4f2d6:	f8c2 3104 	str.w	r3, [r2, #260]	; 0x104
   4f2da:	f8d2 3104 	ldr.w	r3, [r2, #260]	; 0x104
    p_reg->INTENSET = mask;
   4f2de:	2302      	movs	r3, #2
   4f2e0:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   4f2e4:	2301      	movs	r3, #1
   4f2e6:	6093      	str	r3, [r2, #8]
}
   4f2e8:	e7d2      	b.n	4f290 <nrfx_clock_start+0x8>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   4f2ea:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   4f2ee:	2200      	movs	r2, #0
   4f2f0:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
   4f2f4:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    p_reg->INTENSET = mask;
   4f2f8:	f8c3 0304 	str.w	r0, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   4f2fc:	6018      	str	r0, [r3, #0]
}
   4f2fe:	e7c7      	b.n	4f290 <nrfx_clock_start+0x8>

0004f300 <nrfx_clock_stop>:
    clock_stop(domain);
   4f300:	f7f5 bdb4 	b.w	44e6c <clock_stop>

0004f304 <nrf_gpio_reconfigure>:
{
   4f304:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   4f306:	9001      	str	r0, [sp, #4]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   4f308:	a801      	add	r0, sp, #4
{
   4f30a:	e9dd 4708 	ldrd	r4, r7, [sp, #32]
   4f30e:	4616      	mov	r6, r2
   4f310:	461d      	mov	r5, r3
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   4f312:	f7f5 fe65 	bl	44fe0 <nrf_gpio_pin_port_decode>
    uint32_t cnf = reg->PIN_CNF[pin_number];
   4f316:	9b01      	ldr	r3, [sp, #4]
                         (p_input ? GPIO_PIN_CNF_INPUT_Msk : 0) |
   4f318:	f1b6 0c00 	subs.w	ip, r6, #0
   4f31c:	bf18      	it	ne
   4f31e:	f04f 0c01 	movne.w	ip, #1
   4f322:	eb00 0083 	add.w	r0, r0, r3, lsl #2
    uint32_t to_update = (p_dir   ? GPIO_PIN_CNF_DIR_Msk   : 0) |
   4f326:	1e0b      	subs	r3, r1, #0
   4f328:	bf18      	it	ne
   4f32a:	2301      	movne	r3, #1
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
   4f32c:	2d00      	cmp	r5, #0
    uint32_t to_update = (p_dir   ? GPIO_PIN_CNF_DIR_Msk   : 0) |
   4f32e:	ea43 034c 	orr.w	r3, r3, ip, lsl #1
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
   4f332:	bf14      	ite	ne
   4f334:	f04f 0c0c 	movne.w	ip, #12
   4f338:	f04f 0c00 	moveq.w	ip, #0
                         (p_drive ? GPIO_PIN_CNF_DRIVE_Msk : 0) |
   4f33c:	2c00      	cmp	r4, #0
                         (p_input ? GPIO_PIN_CNF_INPUT_Msk : 0) |
   4f33e:	ea43 030c 	orr.w	r3, r3, ip
                         (p_drive ? GPIO_PIN_CNF_DRIVE_Msk : 0) |
   4f342:	bf14      	ite	ne
   4f344:	f44f 6ce0 	movne.w	ip, #1792	; 0x700
   4f348:	f04f 0c00 	moveq.w	ip, #0
                         (p_sense ? GPIO_PIN_CNF_SENSE_Msk : 0);
   4f34c:	2f00      	cmp	r7, #0
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
   4f34e:	ea43 030c 	orr.w	r3, r3, ip
    uint32_t cnf = reg->PIN_CNF[pin_number];
   4f352:	f8d0 2700 	ldr.w	r2, [r0, #1792]	; 0x700
                         (p_sense ? GPIO_PIN_CNF_SENSE_Msk : 0);
   4f356:	bf14      	ite	ne
   4f358:	f44f 3c40 	movne.w	ip, #196608	; 0x30000
   4f35c:	f04f 0c00 	moveq.w	ip, #0
    uint32_t to_update = (p_dir   ? GPIO_PIN_CNF_DIR_Msk   : 0) |
   4f360:	ea43 030c 	orr.w	r3, r3, ip
    cnf &= ~to_update;
   4f364:	ea22 0303 	bic.w	r3, r2, r3
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
   4f368:	b101      	cbz	r1, 4f36c <nrf_gpio_reconfigure+0x68>
   4f36a:	7809      	ldrb	r1, [r1, #0]
           ((uint32_t)(p_input ? *p_input : 0) << GPIO_PIN_CNF_INPUT_Pos) |
   4f36c:	b10e      	cbz	r6, 4f372 <nrf_gpio_reconfigure+0x6e>
   4f36e:	7836      	ldrb	r6, [r6, #0]
   4f370:	0076      	lsls	r6, r6, #1
   4f372:	4319      	orrs	r1, r3
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)  |
   4f374:	b10d      	cbz	r5, 4f37a <nrf_gpio_reconfigure+0x76>
   4f376:	782d      	ldrb	r5, [r5, #0]
   4f378:	00ad      	lsls	r5, r5, #2
   4f37a:	4331      	orrs	r1, r6
           ((uint32_t)(p_drive ? *p_drive : 0) << GPIO_PIN_CNF_DRIVE_Pos) |
   4f37c:	b10c      	cbz	r4, 4f382 <nrf_gpio_reconfigure+0x7e>
   4f37e:	7824      	ldrb	r4, [r4, #0]
   4f380:	0224      	lsls	r4, r4, #8
   4f382:	4329      	orrs	r1, r5
           ((uint32_t)(p_sense ? *p_sense : 0)<< GPIO_PIN_CNF_SENSE_Pos);
   4f384:	b10f      	cbz	r7, 4f38a <nrf_gpio_reconfigure+0x86>
   4f386:	783f      	ldrb	r7, [r7, #0]
   4f388:	043f      	lsls	r7, r7, #16
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
   4f38a:	430c      	orrs	r4, r1
   4f38c:	433c      	orrs	r4, r7
    reg->PIN_CNF[pin_number] = cnf;
   4f38e:	f8c0 4700 	str.w	r4, [r0, #1792]	; 0x700
}
   4f392:	b003      	add	sp, #12
   4f394:	bdf0      	pop	{r4, r5, r6, r7, pc}

0004f396 <nrf_gpio_cfg_sense_set>:
{
   4f396:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    nrf_gpio_reconfigure(pin_number, NULL, NULL, NULL, NULL, &sense_config);
   4f398:	f10d 030f 	add.w	r3, sp, #15
   4f39c:	9301      	str	r3, [sp, #4]
   4f39e:	2300      	movs	r3, #0
{
   4f3a0:	f88d 100f 	strb.w	r1, [sp, #15]
    nrf_gpio_reconfigure(pin_number, NULL, NULL, NULL, NULL, &sense_config);
   4f3a4:	9300      	str	r3, [sp, #0]
   4f3a6:	461a      	mov	r2, r3
   4f3a8:	4619      	mov	r1, r3
   4f3aa:	f7ff ffab 	bl	4f304 <nrf_gpio_reconfigure>
}
   4f3ae:	b005      	add	sp, #20
   4f3b0:	f85d fb04 	ldr.w	pc, [sp], #4

0004f3b4 <nrfx_nvmc_flash_size_get>:
    return p_reg->CODEPAGESIZE;
   4f3b4:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   4f3b8:	691a      	ldr	r2, [r3, #16]
    return p_reg->CODESIZE;
   4f3ba:	6958      	ldr	r0, [r3, #20]
}

uint32_t nrfx_nvmc_flash_size_get(void)
{
    return flash_total_size_get();
}
   4f3bc:	4350      	muls	r0, r2
   4f3be:	4770      	bx	lr

0004f3c0 <nrfx_nvmc_flash_page_size_get>:
    return p_reg->CODEPAGESIZE;
   4f3c0:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   4f3c4:	6918      	ldr	r0, [r3, #16]

uint32_t nrfx_nvmc_flash_page_size_get(void)
{
    return flash_page_size_get();
}
   4f3c6:	4770      	bx	lr

0004f3c8 <nrfx_nvmc_flash_page_count_get>:
    return p_reg->CODESIZE;
   4f3c8:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   4f3cc:	6958      	ldr	r0, [r3, #20]

uint32_t nrfx_nvmc_flash_page_count_get(void)
{
    return flash_page_count_get();
}
   4f3ce:	4770      	bx	lr

0004f3d0 <nrf_power_event_get_and_clear.constprop.0>:
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   4f3d0:	f100 4380 	add.w	r3, r0, #1073741824	; 0x40000000
   4f3d4:	681a      	ldr	r2, [r3, #0]
   4f3d6:	2a00      	cmp	r2, #0
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   4f3d8:	bf1f      	itttt	ne
   4f3da:	2200      	movne	r2, #0
   4f3dc:	601a      	strne	r2, [r3, #0]
   4f3de:	681b      	ldrne	r3, [r3, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   4f3e0:	2001      	movne	r0, #1
   4f3e2:	bf08      	it	eq
   4f3e4:	2000      	moveq	r0, #0
}
   4f3e6:	4770      	bx	lr

0004f3e8 <nrfx_power_usbevt_enable>:
    p_reg->INTENSET = mask;
   4f3e8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   4f3ec:	f44f 7260 	mov.w	r2, #896	; 0x380
   4f3f0:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
   4f3f4:	4770      	bx	lr

0004f3f6 <nrfx_power_usbevt_disable>:
    p_reg->INTENCLR = mask;
   4f3f6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   4f3fa:	f44f 7260 	mov.w	r2, #896	; 0x380
   4f3fe:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
}
   4f402:	4770      	bx	lr

0004f404 <nrfx_power_clock_irq_handler>:
 * a library with nrfx is created. In such case, forcing a linker to use this
 * function instead of another one defined as weak will require additional
 * actions, and might be even impossible.
 */
void nrfx_power_clock_irq_handler(void)
{
   4f404:	b508      	push	{r3, lr}
    nrfx_power_irq_handler();
   4f406:	f7f6 f9dd 	bl	457c4 <nrfx_power_irq_handler>
    nrfx_clock_irq_handler();
}
   4f40a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    nrfx_clock_irq_handler();
   4f40e:	f7f5 bdb3 	b.w	44f78 <nrfx_clock_irq_handler>

0004f412 <nrfx_usbd_consumer>:
{
   4f412:	b530      	push	{r4, r5, lr}
    size_t size = p_transfer->size;
   4f414:	684c      	ldr	r4, [r1, #4]
    if (size < data_size)
   4f416:	429c      	cmp	r4, r3
   4f418:	d209      	bcs.n	4f42e <nrfx_usbd_consumer+0x1c>
        p_next->size = 0;
   4f41a:	2500      	movs	r5, #0
   4f41c:	6045      	str	r5, [r0, #4]
        p_next->p_data = p_transfer->p_data;
   4f41e:	6809      	ldr	r1, [r1, #0]
   4f420:	6001      	str	r1, [r0, #0]
    return (ep_size == data_size) && (size != 0);
   4f422:	429a      	cmp	r2, r3
   4f424:	d10c      	bne.n	4f440 <nrfx_usbd_consumer+0x2e>
   4f426:	1e20      	subs	r0, r4, #0
   4f428:	bf18      	it	ne
   4f42a:	2001      	movne	r0, #1
}
   4f42c:	bd30      	pop	{r4, r5, pc}
        p_next->size = data_size;
   4f42e:	6043      	str	r3, [r0, #4]
        p_next->p_data = p_transfer->p_data;
   4f430:	680d      	ldr	r5, [r1, #0]
   4f432:	6005      	str	r5, [r0, #0]
        p_transfer->p_data.addr += data_size;
   4f434:	6808      	ldr	r0, [r1, #0]
        size -= data_size;
   4f436:	1ae4      	subs	r4, r4, r3
        p_transfer->p_data.addr += data_size;
   4f438:	4418      	add	r0, r3
        p_transfer->size = size;
   4f43a:	604c      	str	r4, [r1, #4]
        p_transfer->p_data.addr += data_size;
   4f43c:	6008      	str	r0, [r1, #0]
   4f43e:	e7f0      	b.n	4f422 <nrfx_usbd_consumer+0x10>
    return (ep_size == data_size) && (size != 0);
   4f440:	2000      	movs	r0, #0
   4f442:	e7f3      	b.n	4f42c <nrfx_usbd_consumer+0x1a>

0004f444 <nrfx_usbd_feeder_ram>:
    if (tx_size > ep_size)
   4f444:	684b      	ldr	r3, [r1, #4]
   4f446:	429a      	cmp	r2, r3
   4f448:	bf28      	it	cs
   4f44a:	461a      	movcs	r2, r3
    p_next->p_data = p_transfer->p_data;
   4f44c:	680b      	ldr	r3, [r1, #0]
    p_next->size = tx_size;
   4f44e:	e9c0 3200 	strd	r3, r2, [r0]
    p_transfer->size -= tx_size;
   4f452:	6848      	ldr	r0, [r1, #4]
    p_transfer->p_data.addr += tx_size;
   4f454:	680b      	ldr	r3, [r1, #0]
    p_transfer->size -= tx_size;
   4f456:	1a80      	subs	r0, r0, r2
   4f458:	6048      	str	r0, [r1, #4]
    p_transfer->p_data.addr += tx_size;
   4f45a:	4413      	add	r3, r2
}
   4f45c:	3800      	subs	r0, #0
    p_transfer->p_data.addr += tx_size;
   4f45e:	600b      	str	r3, [r1, #0]
}
   4f460:	bf18      	it	ne
   4f462:	2001      	movne	r0, #1
   4f464:	4770      	bx	lr

0004f466 <nrfx_usbd_feeder_ram_zlp>:
    if (tx_size > ep_size)
   4f466:	684b      	ldr	r3, [r1, #4]
   4f468:	429a      	cmp	r2, r3
   4f46a:	bf28      	it	cs
   4f46c:	461a      	movcs	r2, r3
    p_next->p_data.tx = (tx_size == 0) ? NULL : p_transfer->p_data.tx;
   4f46e:	b162      	cbz	r2, 4f48a <nrfx_usbd_feeder_ram_zlp+0x24>
   4f470:	680b      	ldr	r3, [r1, #0]
    p_next->size = tx_size;
   4f472:	e9c0 3200 	strd	r3, r2, [r0]
    p_transfer->size -= tx_size;
   4f476:	684b      	ldr	r3, [r1, #4]
   4f478:	1a9b      	subs	r3, r3, r2
   4f47a:	604b      	str	r3, [r1, #4]
    p_transfer->p_data.addr += tx_size;
   4f47c:	680b      	ldr	r3, [r1, #0]
}
   4f47e:	1e10      	subs	r0, r2, #0
    p_transfer->p_data.addr += tx_size;
   4f480:	4413      	add	r3, r2
   4f482:	600b      	str	r3, [r1, #0]
}
   4f484:	bf18      	it	ne
   4f486:	2001      	movne	r0, #1
   4f488:	4770      	bx	lr
    p_next->p_data.tx = (tx_size == 0) ? NULL : p_transfer->p_data.tx;
   4f48a:	4613      	mov	r3, r2
   4f48c:	e7f1      	b.n	4f472 <nrfx_usbd_feeder_ram_zlp+0xc>

0004f48e <ep2bit>:
    return NRFX_USBD_EP_BITPOS(ep);
   4f48e:	43c3      	mvns	r3, r0
   4f490:	f3c3 13c0 	ubfx	r3, r3, #7, #1
   4f494:	f000 000f 	and.w	r0, r0, #15
}
   4f498:	eb00 1003 	add.w	r0, r0, r3, lsl #4
   4f49c:	4770      	bx	lr

0004f49e <ev_started_handler>:
}
   4f49e:	4770      	bx	lr

0004f4a0 <nrf_usbd_epin_dma_handler>:
{
   4f4a0:	b508      	push	{r3, lr}
    usbd_dma_pending_clear();
   4f4a2:	f7f6 fafd 	bl	45aa0 <usbd_dma_pending_clear>
{
   4f4a6:	4601      	mov	r1, r0
    usbd_ep_state_t * p_state = ep_state_access(ep);
   4f4a8:	f7f6 f9f0 	bl	4588c <ep_state_access>
    if (NRFX_USBD_EP_ABORTED == p_state->status)
   4f4ac:	7b83      	ldrb	r3, [r0, #14]
   4f4ae:	2b03      	cmp	r3, #3
   4f4b0:	d10a      	bne.n	4f4c8 <nrf_usbd_epin_dma_handler+0x28>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   4f4b2:	4608      	mov	r0, r1
   4f4b4:	f7ff ffeb 	bl	4f48e <ep2bit>
   4f4b8:	2301      	movs	r3, #1
   4f4ba:	fa03 f000 	lsl.w	r0, r3, r0
   4f4be:	43c0      	mvns	r0, r0
}
   4f4c0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   4f4c4:	f7f6 badc 	b.w	45a80 <atomic_and.constprop.0.isra.0>
    else if (p_state->handler.feeder == NULL)
   4f4c8:	6803      	ldr	r3, [r0, #0]
   4f4ca:	2b00      	cmp	r3, #0
   4f4cc:	d0f1      	beq.n	4f4b2 <nrf_usbd_epin_dma_handler+0x12>
}
   4f4ce:	bd08      	pop	{r3, pc}

0004f4d0 <ev_dma_epin7_handler>:
static void ev_dma_epin7_handler(void)  { nrf_usbd_epin_dma_handler(NRFX_USBD_EPIN7 ); }
   4f4d0:	2087      	movs	r0, #135	; 0x87
   4f4d2:	f7ff bfe5 	b.w	4f4a0 <nrf_usbd_epin_dma_handler>

0004f4d6 <ev_dma_epin6_handler>:
static void ev_dma_epin6_handler(void)  { nrf_usbd_epin_dma_handler(NRFX_USBD_EPIN6 ); }
   4f4d6:	2086      	movs	r0, #134	; 0x86
   4f4d8:	f7ff bfe2 	b.w	4f4a0 <nrf_usbd_epin_dma_handler>

0004f4dc <ev_dma_epin5_handler>:
static void ev_dma_epin5_handler(void)  { nrf_usbd_epin_dma_handler(NRFX_USBD_EPIN5 ); }
   4f4dc:	2085      	movs	r0, #133	; 0x85
   4f4de:	f7ff bfdf 	b.w	4f4a0 <nrf_usbd_epin_dma_handler>

0004f4e2 <ev_dma_epin4_handler>:
static void ev_dma_epin4_handler(void)  { nrf_usbd_epin_dma_handler(NRFX_USBD_EPIN4 ); }
   4f4e2:	2084      	movs	r0, #132	; 0x84
   4f4e4:	f7ff bfdc 	b.w	4f4a0 <nrf_usbd_epin_dma_handler>

0004f4e8 <ev_dma_epin3_handler>:
static void ev_dma_epin3_handler(void)  { nrf_usbd_epin_dma_handler(NRFX_USBD_EPIN3 ); }
   4f4e8:	2083      	movs	r0, #131	; 0x83
   4f4ea:	f7ff bfd9 	b.w	4f4a0 <nrf_usbd_epin_dma_handler>

0004f4ee <ev_dma_epin2_handler>:
static void ev_dma_epin2_handler(void)  { nrf_usbd_epin_dma_handler(NRFX_USBD_EPIN2 ); }
   4f4ee:	2082      	movs	r0, #130	; 0x82
   4f4f0:	f7ff bfd6 	b.w	4f4a0 <nrf_usbd_epin_dma_handler>

0004f4f4 <ev_dma_epin1_handler>:
static void ev_dma_epin1_handler(void)  { nrf_usbd_epin_dma_handler(NRFX_USBD_EPIN1 ); }
   4f4f4:	2081      	movs	r0, #129	; 0x81
   4f4f6:	f7ff bfd3 	b.w	4f4a0 <nrf_usbd_epin_dma_handler>

0004f4fa <ev_dma_epin0_handler>:
static void ev_dma_epin0_handler(void)  { nrf_usbd_ep0in_dma_handler(); }
   4f4fa:	f7f6 bae3 	b.w	45ac4 <nrf_usbd_ep0in_dma_handler>

0004f4fe <nrfx_usbd_ep_max_packet_size_set>:
{
   4f4fe:	b508      	push	{r3, lr}
    usbd_ep_state_t * p_state = ep_state_access(ep);
   4f500:	f7f6 f9c4 	bl	4588c <ep_state_access>
    p_state->max_packet_size = size;
   4f504:	8181      	strh	r1, [r0, #12]
}
   4f506:	bd08      	pop	{r3, pc}

0004f508 <nrfx_usbd_ep_status_get>:
{
   4f508:	b508      	push	{r3, lr}
    usbd_ep_state_t const * p_state = ep_state_access(ep);
   4f50a:	f7f6 f9bf 	bl	4588c <ep_state_access>
	__asm__ volatile(
   4f50e:	f04f 0220 	mov.w	r2, #32
   4f512:	f3ef 8311 	mrs	r3, BASEPRI
   4f516:	f382 8812 	msr	BASEPRI_MAX, r2
   4f51a:	f3bf 8f6f 	isb	sy
    *p_size = p_state->transfer_cnt;
   4f51e:	6882      	ldr	r2, [r0, #8]
   4f520:	600a      	str	r2, [r1, #0]
    ret = (p_state->handler.consumer == NULL) ? p_state->status : NRFX_USBD_EP_BUSY;
   4f522:	6802      	ldr	r2, [r0, #0]
   4f524:	b92a      	cbnz	r2, 4f532 <nrfx_usbd_ep_status_get+0x2a>
   4f526:	7b80      	ldrb	r0, [r0, #14]
	__asm__ volatile(
   4f528:	f383 8811 	msr	BASEPRI, r3
   4f52c:	f3bf 8f6f 	isb	sy
}
   4f530:	bd08      	pop	{r3, pc}
    ret = (p_state->handler.consumer == NULL) ? p_state->status : NRFX_USBD_EP_BUSY;
   4f532:	2004      	movs	r0, #4
   4f534:	e7f8      	b.n	4f528 <nrfx_usbd_ep_status_get+0x20>

0004f536 <ev_dma_epout7_handler>:
static void ev_dma_epout7_handler(void) { nrf_usbd_epout_dma_handler(NRFX_USBD_EPOUT7); }
   4f536:	2007      	movs	r0, #7
   4f538:	f7f6 be3e 	b.w	461b8 <nrf_usbd_epout_dma_handler>

0004f53c <ev_dma_epout6_handler>:
static void ev_dma_epout6_handler(void) { nrf_usbd_epout_dma_handler(NRFX_USBD_EPOUT6); }
   4f53c:	2006      	movs	r0, #6
   4f53e:	f7f6 be3b 	b.w	461b8 <nrf_usbd_epout_dma_handler>

0004f542 <ev_dma_epout5_handler>:
static void ev_dma_epout5_handler(void) { nrf_usbd_epout_dma_handler(NRFX_USBD_EPOUT5); }
   4f542:	2005      	movs	r0, #5
   4f544:	f7f6 be38 	b.w	461b8 <nrf_usbd_epout_dma_handler>

0004f548 <ev_dma_epout4_handler>:
static void ev_dma_epout4_handler(void) { nrf_usbd_epout_dma_handler(NRFX_USBD_EPOUT4); }
   4f548:	2004      	movs	r0, #4
   4f54a:	f7f6 be35 	b.w	461b8 <nrf_usbd_epout_dma_handler>

0004f54e <ev_dma_epout3_handler>:
static void ev_dma_epout3_handler(void) { nrf_usbd_epout_dma_handler(NRFX_USBD_EPOUT3); }
   4f54e:	2003      	movs	r0, #3
   4f550:	f7f6 be32 	b.w	461b8 <nrf_usbd_epout_dma_handler>

0004f554 <ev_dma_epout2_handler>:
static void ev_dma_epout2_handler(void) { nrf_usbd_epout_dma_handler(NRFX_USBD_EPOUT2); }
   4f554:	2002      	movs	r0, #2
   4f556:	f7f6 be2f 	b.w	461b8 <nrf_usbd_epout_dma_handler>

0004f55a <ev_dma_epout1_handler>:
static void ev_dma_epout1_handler(void) { nrf_usbd_epout_dma_handler(NRFX_USBD_EPOUT1); }
   4f55a:	2001      	movs	r0, #1
   4f55c:	f7f6 be2c 	b.w	461b8 <nrf_usbd_epout_dma_handler>

0004f560 <nrfx_usbd_ep_abort>:
    usbd_ep_abort(ep);
   4f560:	f7f6 bf20 	b.w	463a4 <usbd_ep_abort>

0004f564 <debounce_update>:
        state->counter -= elapsed_ms;
    }
}

void debounce_update(struct debounce_state *state, const bool active, const int elapsed_ms,
                     const struct debounce_config *config) {
   4f564:	b570      	push	{r4, r5, r6, lr}
    // This uses a variation of the integrator debouncing described at
    // https://www.kennethkuhn.com/electronics/debounce.c
    // Every update where "active" does not match the current state, we increment
    // a counter, otherwise we decrement it. When the counter reaches a
    // threshold, the state flips and we reset the counter.
    state->changed = false;
   4f566:	7804      	ldrb	r4, [r0, #0]
   4f568:	f36f 0441 	bfc	r4, #1, #1
   4f56c:	7004      	strb	r4, [r0, #0]

    if (active == state->pressed) {
   4f56e:	f004 0501 	and.w	r5, r4, #1
    if (state->counter < elapsed_ms) {
   4f572:	8804      	ldrh	r4, [r0, #0]
    if (active == state->pressed) {
   4f574:	428d      	cmp	r5, r1
    if (state->counter < elapsed_ms) {
   4f576:	f3c4 068d 	ubfx	r6, r4, #2, #14
    if (active == state->pressed) {
   4f57a:	d109      	bne.n	4f590 <debounce_update+0x2c>
    if (state->counter < elapsed_ms) {
   4f57c:	42b2      	cmp	r2, r6
   4f57e:	dd03      	ble.n	4f588 <debounce_update+0x24>
        state->counter = 0;
   4f580:	f36f 048f 	bfc	r4, #2, #14
    if (state->counter < flip_threshold) {
        increment_counter(state, elapsed_ms);
        return;
    }

    state->pressed = !state->pressed;
   4f584:	8004      	strh	r4, [r0, #0]
    state->counter = 0;
    state->changed = true;
}
   4f586:	bd70      	pop	{r4, r5, r6, pc}
        state->counter -= elapsed_ms;
   4f588:	1ab6      	subs	r6, r6, r2
        state->counter += elapsed_ms;
   4f58a:	f366 048f 	bfi	r4, r6, #2, #14
   4f58e:	e7f9      	b.n	4f584 <debounce_update+0x20>
    return state->pressed ? config->debounce_release_ms : config->debounce_press_ms;
   4f590:	e9d3 1300 	ldrd	r1, r3, [r3]
   4f594:	f014 0f01 	tst.w	r4, #1
   4f598:	bf18      	it	ne
   4f59a:	4619      	movne	r1, r3
    if (state->counter < flip_threshold) {
   4f59c:	428e      	cmp	r6, r1
   4f59e:	d208      	bcs.n	4f5b2 <debounce_update+0x4e>
    if (state->counter + elapsed_ms > DEBOUNCE_COUNTER_MAX) {
   4f5a0:	4416      	add	r6, r2
   4f5a2:	f5b6 4f80 	cmp.w	r6, #16384	; 0x4000
   4f5a6:	d3f0      	bcc.n	4f58a <debounce_update+0x26>
        state->counter = DEBOUNCE_COUNTER_MAX;
   4f5a8:	f643 73ff 	movw	r3, #16383	; 0x3fff
   4f5ac:	f363 048f 	bfi	r4, r3, #2, #14
   4f5b0:	e7e8      	b.n	4f584 <debounce_update+0x20>
    state->pressed = !state->pressed;
   4f5b2:	f085 0401 	eor.w	r4, r5, #1
   4f5b6:	f044 0402 	orr.w	r4, r4, #2
   4f5ba:	e7e3      	b.n	4f584 <debounce_update+0x20>

0004f5bc <debounce_is_active>:

bool debounce_is_active(const struct debounce_state *state) {
    return state->pressed || state->counter > 0;
   4f5bc:	8800      	ldrh	r0, [r0, #0]
   4f5be:	f020 0002 	bic.w	r0, r0, #2
   4f5c2:	b280      	uxth	r0, r0
}
   4f5c4:	3800      	subs	r0, #0
   4f5c6:	bf18      	it	ne
   4f5c8:	2001      	movne	r0, #1
   4f5ca:	4770      	bx	lr

0004f5cc <debounce_is_pressed>:

bool debounce_is_pressed(const struct debounce_state *state) { return state->pressed; }
   4f5cc:	7800      	ldrb	r0, [r0, #0]
   4f5ce:	f000 0001 	and.w	r0, r0, #1
   4f5d2:	4770      	bx	lr

0004f5d4 <debounce_get_changed>:

   4f5d4:	7800      	ldrb	r0, [r0, #0]
   4f5d6:	f3c0 0040 	ubfx	r0, r0, #1, #1
   4f5da:	4770      	bx	lr

0004f5dc <kscan_gpio_pin_get>:
}

int kscan_gpio_pin_get(const struct kscan_gpio *gpio, struct kscan_gpio_port_state *state) {
   4f5dc:	b570      	push	{r4, r5, r6, lr}
    if (gpio->spec.port != state->port) {
   4f5de:	680b      	ldr	r3, [r1, #0]
int kscan_gpio_pin_get(const struct kscan_gpio *gpio, struct kscan_gpio_port_state *state) {
   4f5e0:	4605      	mov	r5, r0
    if (gpio->spec.port != state->port) {
   4f5e2:	6800      	ldr	r0, [r0, #0]
   4f5e4:	4298      	cmp	r0, r3
int kscan_gpio_pin_get(const struct kscan_gpio *gpio, struct kscan_gpio_port_state *state) {
   4f5e6:	460c      	mov	r4, r1
    if (gpio->spec.port != state->port) {
   4f5e8:	d00a      	beq.n	4f600 <kscan_gpio_pin_get+0x24>
        state->port = gpio->spec.port;
   4f5ea:	f841 0b04 	str.w	r0, [r1], #4
	const struct gpio_driver_data *const data =
   4f5ee:	6906      	ldr	r6, [r0, #16]
	return api->port_get_raw(port, value);
   4f5f0:	6883      	ldr	r3, [r0, #8]
   4f5f2:	685b      	ldr	r3, [r3, #4]
   4f5f4:	4798      	blx	r3
	if (ret == 0) {
   4f5f6:	b940      	cbnz	r0, 4f60a <kscan_gpio_pin_get+0x2e>
		*value ^= data->invert;
   4f5f8:	6863      	ldr	r3, [r4, #4]
   4f5fa:	6832      	ldr	r2, [r6, #0]
   4f5fc:	4053      	eors	r3, r2
   4f5fe:	6063      	str	r3, [r4, #4]
        if (err) {
            return err;
        }
    }

    return (state->value & BIT(gpio->spec.pin)) != 0;
   4f600:	792b      	ldrb	r3, [r5, #4]
   4f602:	6860      	ldr	r0, [r4, #4]
   4f604:	40d8      	lsrs	r0, r3
   4f606:	f000 0001 	and.w	r0, r0, #1
}
   4f60a:	bd70      	pop	{r4, r5, r6, pc}

0004f60c <gpio_pin_configure_dt>:
{
   4f60c:	b470      	push	{r4, r5, r6}
   4f60e:	4603      	mov	r3, r0
   4f610:	460c      	mov	r4, r1
				  spec->dt_flags | extra_flags);
   4f612:	88da      	ldrh	r2, [r3, #6]
	return gpio_pin_configure(spec->port,
   4f614:	6800      	ldr	r0, [r0, #0]
				  spec->pin,
   4f616:	7919      	ldrb	r1, [r3, #4]
	return gpio_pin_configure(spec->port,
   4f618:	4322      	orrs	r2, r4
	struct gpio_driver_data *data =
   4f61a:	6905      	ldr	r5, [r0, #16]
	const struct gpio_driver_api *api =
   4f61c:	6886      	ldr	r6, [r0, #8]
	if ((flags & GPIO_ACTIVE_LOW) != 0) {
   4f61e:	682b      	ldr	r3, [r5, #0]
		data->invert |= (gpio_port_pins_t)BIT(pin);
   4f620:	2401      	movs	r4, #1
   4f622:	408c      	lsls	r4, r1
	if ((flags & GPIO_ACTIVE_LOW) != 0) {
   4f624:	f012 0f01 	tst.w	r2, #1
		data->invert |= (gpio_port_pins_t)BIT(pin);
   4f628:	bf14      	ite	ne
   4f62a:	4323      	orrne	r3, r4
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
   4f62c:	43a3      	biceq	r3, r4
   4f62e:	602b      	str	r3, [r5, #0]
	return api->pin_configure(port, pin, flags);
   4f630:	6833      	ldr	r3, [r6, #0]
}
   4f632:	bc70      	pop	{r4, r5, r6}
	return api->pin_configure(port, pin, flags);
   4f634:	4718      	bx	r3

0004f636 <gpio_pin_set_dt>:
{
   4f636:	4603      	mov	r3, r0
   4f638:	460a      	mov	r2, r1
	return gpio_pin_set(spec->port, spec->pin, value);
   4f63a:	6800      	ldr	r0, [r0, #0]
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   4f63c:	7919      	ldrb	r1, [r3, #4]
   4f63e:	2301      	movs	r3, #1
   4f640:	fa03 f101 	lsl.w	r1, r3, r1
   4f644:	6903      	ldr	r3, [r0, #16]
   4f646:	681b      	ldr	r3, [r3, #0]
   4f648:	4219      	tst	r1, r3
		value = (value != 0) ? 0 : 1;
   4f64a:	bf18      	it	ne
   4f64c:	f082 0201 	eorne.w	r2, r2, #1
	if (value != 0)	{
   4f650:	b112      	cbz	r2, 4f658 <gpio_pin_set_dt+0x22>
	return api->port_set_bits_raw(port, pins);
   4f652:	6883      	ldr	r3, [r0, #8]
   4f654:	68db      	ldr	r3, [r3, #12]
	return api->port_clear_bits_raw(port, pins);
   4f656:	4718      	bx	r3
   4f658:	6883      	ldr	r3, [r0, #8]
   4f65a:	691b      	ldr	r3, [r3, #16]
   4f65c:	e7fb      	b.n	4f656 <gpio_pin_set_dt+0x20>

0004f65e <kscan_matrix_configure>:
    struct kscan_matrix_data *data = dev->data;
   4f65e:	6903      	ldr	r3, [r0, #16]
    if (!callback) {
   4f660:	b111      	cbz	r1, 4f668 <kscan_matrix_configure+0xa>
    data->callback = callback;
   4f662:	60d9      	str	r1, [r3, #12]
    return 0;
   4f664:	2000      	movs	r0, #0
   4f666:	4770      	bx	lr
        return -EINVAL;
   4f668:	f06f 0015 	mvn.w	r0, #21
}
   4f66c:	4770      	bx	lr

0004f66e <kscan_matrix_interrupt_configure.isra.0>:
static int kscan_matrix_interrupt_configure(const struct device *dev, const gpio_flags_t flags) {
   4f66e:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   4f672:	4606      	mov	r6, r0
   4f674:	460c      	mov	r4, r1
    for (int i = 0; i < data->inputs.len; i++) {
   4f676:	2500      	movs	r5, #0
        const struct gpio_dt_spec *gpio = &data->inputs.gpios[i].spec;
   4f678:	270c      	movs	r7, #12
	if (((flags & GPIO_INT_LEVELS_LOGICAL) != 0) &&
   4f67a:	f401 0800 	and.w	r8, r1, #8388608	; 0x800000
    for (int i = 0; i < data->inputs.len; i++) {
   4f67e:	68b3      	ldr	r3, [r6, #8]
   4f680:	429d      	cmp	r5, r3
   4f682:	d302      	bcc.n	4f68a <kscan_matrix_interrupt_configure.isra.0+0x1c>
    return 0;
   4f684:	2000      	movs	r0, #0
}
   4f686:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        const struct gpio_dt_spec *gpio = &data->inputs.gpios[i].spec;
   4f68a:	6872      	ldr	r2, [r6, #4]
   4f68c:	fb07 f305 	mul.w	r3, r7, r5
   4f690:	18d1      	adds	r1, r2, r3
	return gpio_pin_interrupt_configure(spec->port, spec->pin, flags);
   4f692:	58d0      	ldr	r0, [r2, r3]
   4f694:	7909      	ldrb	r1, [r1, #4]
	const struct gpio_driver_api *api =
   4f696:	f8d0 c008 	ldr.w	ip, [r0, #8]
	const struct gpio_driver_data *const data =
   4f69a:	6902      	ldr	r2, [r0, #16]
	if (((flags & GPIO_INT_LEVELS_LOGICAL) != 0) &&
   4f69c:	f1b8 0f00 	cmp.w	r8, #0
   4f6a0:	d011      	beq.n	4f6c6 <kscan_matrix_interrupt_configure.isra.0+0x58>
	    ((data->invert & (gpio_port_pins_t)BIT(pin)) != 0)) {
   4f6a2:	6812      	ldr	r2, [r2, #0]
   4f6a4:	2301      	movs	r3, #1
   4f6a6:	408b      	lsls	r3, r1
	if (((flags & GPIO_INT_LEVELS_LOGICAL) != 0) &&
   4f6a8:	4213      	tst	r3, r2
   4f6aa:	d00c      	beq.n	4f6c6 <kscan_matrix_interrupt_configure.isra.0+0x58>
		flags ^= (GPIO_INT_LOW_0 | GPIO_INT_HIGH_1);
   4f6ac:	f084 62c0 	eor.w	r2, r4, #100663296	; 0x6000000
	return api->pin_interrupt_configure(port, pin, mode, trig);
   4f6b0:	f002 63c0 	and.w	r3, r2, #100663296	; 0x6000000
   4f6b4:	f8dc 9018 	ldr.w	r9, [ip, #24]
   4f6b8:	f002 72b0 	and.w	r2, r2, #23068672	; 0x1600000
   4f6bc:	47c8      	blx	r9
        if (err) {
   4f6be:	2800      	cmp	r0, #0
   4f6c0:	d1e1      	bne.n	4f686 <kscan_matrix_interrupt_configure.isra.0+0x18>
    for (int i = 0; i < data->inputs.len; i++) {
   4f6c2:	3501      	adds	r5, #1
   4f6c4:	e7db      	b.n	4f67e <kscan_matrix_interrupt_configure.isra.0+0x10>
   4f6c6:	4622      	mov	r2, r4
   4f6c8:	e7f2      	b.n	4f6b0 <kscan_matrix_interrupt_configure.isra.0+0x42>

0004f6ca <kscan_matrix_set_all_outputs.isra.0>:
static int kscan_matrix_set_all_outputs(const struct device *dev, const int value) {
   4f6ca:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   4f6cc:	4605      	mov	r5, r0
   4f6ce:	460e      	mov	r6, r1
    for (int i = 0; i < config->outputs.len; i++) {
   4f6d0:	2400      	movs	r4, #0
        const struct gpio_dt_spec *gpio = &config->outputs.gpios[i].spec;
   4f6d2:	270c      	movs	r7, #12
    for (int i = 0; i < config->outputs.len; i++) {
   4f6d4:	686b      	ldr	r3, [r5, #4]
   4f6d6:	42a3      	cmp	r3, r4
   4f6d8:	d801      	bhi.n	4f6de <kscan_matrix_set_all_outputs.isra.0+0x14>
    return 0;
   4f6da:	2000      	movs	r0, #0
}
   4f6dc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        const struct gpio_dt_spec *gpio = &config->outputs.gpios[i].spec;
   4f6de:	6828      	ldr	r0, [r5, #0]
        int err = gpio_pin_set_dt(gpio, value);
   4f6e0:	4631      	mov	r1, r6
   4f6e2:	fb07 0004 	mla	r0, r7, r4, r0
   4f6e6:	f7ff ffa6 	bl	4f636 <gpio_pin_set_dt>
        if (err) {
   4f6ea:	2800      	cmp	r0, #0
   4f6ec:	d1f6      	bne.n	4f6dc <kscan_matrix_set_all_outputs.isra.0+0x12>
    for (int i = 0; i < config->outputs.len; i++) {
   4f6ee:	3401      	adds	r4, #1
   4f6f0:	e7f0      	b.n	4f6d4 <kscan_matrix_set_all_outputs.isra.0+0xa>

0004f6f2 <kscan_matrix_read>:
static int kscan_matrix_read(const struct device *dev) {
   4f6f2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    struct kscan_matrix_data *data = dev->data;
   4f6f6:	6906      	ldr	r6, [r0, #16]
    const struct kscan_matrix_config *config = dev->config;
   4f6f8:	6844      	ldr	r4, [r0, #4]
static int kscan_matrix_read(const struct device *dev) {
   4f6fa:	b085      	sub	sp, #20
   4f6fc:	4605      	mov	r5, r0
    for (int i = 0; i < config->outputs.len; i++) {
   4f6fe:	f04f 0900 	mov.w	r9, #0
        const struct kscan_gpio *out_gpio = &config->outputs.gpios[i];
   4f702:	f04f 0b0c 	mov.w	fp, #12
    for (int i = 0; i < config->outputs.len; i++) {
   4f706:	6863      	ldr	r3, [r4, #4]
   4f708:	454b      	cmp	r3, r9
   4f70a:	d836      	bhi.n	4f77a <kscan_matrix_read+0x88>
    for (int r = 0; r < config->rows; r++) {
   4f70c:	f04f 0900 	mov.w	r9, #0
    bool continue_scan = false;
   4f710:	464f      	mov	r7, r9
    for (int r = 0; r < config->rows; r++) {
   4f712:	6923      	ldr	r3, [r4, #16]
   4f714:	454b      	cmp	r3, r9
   4f716:	f200 8091 	bhi.w	4f83c <kscan_matrix_read+0x14a>
    struct kscan_matrix_data *data = dev->data;
   4f71a:	6928      	ldr	r0, [r5, #16]
    if (continue_scan) {
   4f71c:	2f00      	cmp	r7, #0
   4f71e:	f000 8095 	beq.w	4f84c <kscan_matrix_read+0x15a>
    data->scan_time += config->debounce_scan_period_ms;
   4f722:	686b      	ldr	r3, [r5, #4]
   4f724:	699a      	ldr	r2, [r3, #24]
   4f726:	e9d0 3112 	ldrd	r3, r1, [r0, #72]	; 0x48
   4f72a:	18d3      	adds	r3, r2, r3
   4f72c:	eb41 71e2 	adc.w	r1, r1, r2, asr #31
   4f730:	e9c0 3112 	strd	r3, r1, [r0, #72]	; 0x48
   4f734:	03c9      	lsls	r1, r1, #15
   4f736:	ea41 4153 	orr.w	r1, r1, r3, lsr #17
   4f73a:	f240 32e7 	movw	r2, #999	; 0x3e7
   4f73e:	03db      	lsls	r3, r3, #15
    k_work_reschedule(&data->work, K_TIMEOUT_ABS_MS(data->scan_time));
   4f740:	f100 0410 	add.w	r4, r0, #16
   4f744:	1898      	adds	r0, r3, r2
   4f746:	f141 0100 	adc.w	r1, r1, #0
   4f74a:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
   4f74e:	f171 0300 	sbcs.w	r3, r1, #0
   4f752:	d376      	bcc.n	4f842 <kscan_matrix_read+0x150>
   4f754:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   4f758:	2300      	movs	r3, #0
   4f75a:	f7d6 fcd1 	bl	26100 <__aeabi_uldivmod>
   4f75e:	f06f 0201 	mvn.w	r2, #1
   4f762:	1a12      	subs	r2, r2, r0
   4f764:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   4f768:	eb63 0301 	sbc.w	r3, r3, r1
   4f76c:	4620      	mov	r0, r4
   4f76e:	f7f7 ff3d 	bl	475ec <k_work_reschedule>
    return 0;
   4f772:	2000      	movs	r0, #0
}
   4f774:	b005      	add	sp, #20
   4f776:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        const struct kscan_gpio *out_gpio = &config->outputs.gpios[i];
   4f77a:	6827      	ldr	r7, [r4, #0]
   4f77c:	fb0b 7709 	mla	r7, fp, r9, r7
        int err = gpio_pin_set_dt(&out_gpio->spec, 1);
   4f780:	2101      	movs	r1, #1
   4f782:	4638      	mov	r0, r7
   4f784:	f7ff ff57 	bl	4f636 <gpio_pin_set_dt>
        if (err) {
   4f788:	2800      	cmp	r0, #0
   4f78a:	d1f3      	bne.n	4f774 <kscan_matrix_read+0x82>
        struct kscan_gpio_port_state state = {0};
   4f78c:	e9cd 0002 	strd	r0, r0, [sp, #8]
            debounce_update(&data->matrix_state[index], active, config->debounce_scan_period_ms,
   4f790:	f104 0308 	add.w	r3, r4, #8
        for (int j = 0; j < data->inputs.len; j++) {
   4f794:	4682      	mov	sl, r0
            debounce_update(&data->matrix_state[index], active, config->debounce_scan_period_ms,
   4f796:	9301      	str	r3, [sp, #4]
        for (int j = 0; j < data->inputs.len; j++) {
   4f798:	68b3      	ldr	r3, [r6, #8]
   4f79a:	4553      	cmp	r3, sl
   4f79c:	d808      	bhi.n	4f7b0 <kscan_matrix_read+0xbe>
        err = gpio_pin_set_dt(&out_gpio->spec, 0);
   4f79e:	2100      	movs	r1, #0
   4f7a0:	4638      	mov	r0, r7
   4f7a2:	f7ff ff48 	bl	4f636 <gpio_pin_set_dt>
        if (err) {
   4f7a6:	2800      	cmp	r0, #0
   4f7a8:	d1e4      	bne.n	4f774 <kscan_matrix_read+0x82>
    for (int i = 0; i < config->outputs.len; i++) {
   4f7aa:	f109 0901 	add.w	r9, r9, #1
   4f7ae:	e7aa      	b.n	4f706 <kscan_matrix_read+0x14>
            const struct kscan_gpio *in_gpio = &data->inputs.gpios[j];
   4f7b0:	6870      	ldr	r0, [r6, #4]
               : state_index_rc(config, input_idx, output_idx);
   4f7b2:	f894 c020 	ldrb.w	ip, [r4, #32]
            const int index = state_index_io(config, in_gpio->index, out_gpio->index);
   4f7b6:	68ba      	ldr	r2, [r7, #8]
    return (col * config->rows) + row;
   4f7b8:	6921      	ldr	r1, [r4, #16]
            const struct kscan_gpio *in_gpio = &data->inputs.gpios[j];
   4f7ba:	fb0b 000a 	mla	r0, fp, sl, r0
            const int index = state_index_io(config, in_gpio->index, out_gpio->index);
   4f7be:	6883      	ldr	r3, [r0, #8]
               : state_index_rc(config, input_idx, output_idx);
   4f7c0:	f1bc 0f00 	cmp.w	ip, #0
   4f7c4:	d113      	bne.n	4f7ee <kscan_matrix_read+0xfc>
    return (col * config->rows) + row;
   4f7c6:	fb01 2803 	mla	r8, r1, r3, r2
            const int active = kscan_gpio_pin_get(in_gpio, &state);
   4f7ca:	a902      	add	r1, sp, #8
   4f7cc:	f7ff ff06 	bl	4f5dc <kscan_gpio_pin_get>
            if (active < 0) {
   4f7d0:	2800      	cmp	r0, #0
   4f7d2:	dbcf      	blt.n	4f774 <kscan_matrix_read+0x82>
            debounce_update(&data->matrix_state[index], active, config->debounce_scan_period_ms,
   4f7d4:	6d30      	ldr	r0, [r6, #80]	; 0x50
   4f7d6:	9b01      	ldr	r3, [sp, #4]
   4f7d8:	69a2      	ldr	r2, [r4, #24]
   4f7da:	bf14      	ite	ne
   4f7dc:	2101      	movne	r1, #1
   4f7de:	2100      	moveq	r1, #0
   4f7e0:	eb00 0048 	add.w	r0, r0, r8, lsl #1
   4f7e4:	f7ff febe 	bl	4f564 <debounce_update>
        for (int j = 0; j < data->inputs.len; j++) {
   4f7e8:	f10a 0a01 	add.w	sl, sl, #1
   4f7ec:	e7d4      	b.n	4f798 <kscan_matrix_read+0xa6>
    return (col * config->rows) + row;
   4f7ee:	fb01 3802 	mla	r8, r1, r2, r3
   4f7f2:	e7ea      	b.n	4f7ca <kscan_matrix_read+0xd8>
            struct debounce_state *state = &data->matrix_state[index];
   4f7f4:	6d32      	ldr	r2, [r6, #80]	; 0x50
    return (col * config->rows) + row;
   4f7f6:	fb0a 9303 	mla	r3, sl, r3, r9
            struct debounce_state *state = &data->matrix_state[index];
   4f7fa:	eb02 0b43 	add.w	fp, r2, r3, lsl #1
            if (debounce_get_changed(state)) {
   4f7fe:	4658      	mov	r0, fp
   4f800:	f7ff fee8 	bl	4f5d4 <debounce_get_changed>
   4f804:	b148      	cbz	r0, 4f81a <kscan_matrix_read+0x128>
                const bool pressed = debounce_is_pressed(state);
   4f806:	4658      	mov	r0, fp
   4f808:	f7ff fee0 	bl	4f5cc <debounce_is_pressed>
                data->callback(dev, r, c, pressed);
   4f80c:	f8d6 c00c 	ldr.w	ip, [r6, #12]
                const bool pressed = debounce_is_pressed(state);
   4f810:	4603      	mov	r3, r0
                data->callback(dev, r, c, pressed);
   4f812:	4652      	mov	r2, sl
   4f814:	4649      	mov	r1, r9
   4f816:	4628      	mov	r0, r5
   4f818:	47e0      	blx	ip
            continue_scan = continue_scan || debounce_is_active(state);
   4f81a:	b96f      	cbnz	r7, 4f838 <kscan_matrix_read+0x146>
   4f81c:	4658      	mov	r0, fp
   4f81e:	f7ff fecd 	bl	4f5bc <debounce_is_active>
   4f822:	f000 0701 	and.w	r7, r0, #1
        for (int c = 0; c < config->cols; c++) {
   4f826:	f10a 0a01 	add.w	sl, sl, #1
   4f82a:	e9d4 3204 	ldrd	r3, r2, [r4, #16]
   4f82e:	4552      	cmp	r2, sl
   4f830:	d8e0      	bhi.n	4f7f4 <kscan_matrix_read+0x102>
    for (int r = 0; r < config->rows; r++) {
   4f832:	f109 0901 	add.w	r9, r9, #1
   4f836:	e76c      	b.n	4f712 <kscan_matrix_read+0x20>
            continue_scan = continue_scan || debounce_is_active(state);
   4f838:	2001      	movs	r0, #1
   4f83a:	e7f2      	b.n	4f822 <kscan_matrix_read+0x130>
        for (int c = 0; c < config->cols; c++) {
   4f83c:	f04f 0a00 	mov.w	sl, #0
   4f840:	e7f3      	b.n	4f82a <kscan_matrix_read+0x138>
    k_work_reschedule(&data->work, K_TIMEOUT_ABS_MS(data->scan_time));
   4f842:	f06f 0201 	mvn.w	r2, #1
   4f846:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   4f84a:	e78f      	b.n	4f76c <kscan_matrix_read+0x7a>
    int err = kscan_matrix_interrupt_configure(dev, GPIO_INT_LEVEL_ACTIVE);
   4f84c:	f04f 6198 	mov.w	r1, #79691776	; 0x4c00000
   4f850:	f7ff ff0d 	bl	4f66e <kscan_matrix_interrupt_configure.isra.0>
    if (err) {
   4f854:	2800      	cmp	r0, #0
   4f856:	d18c      	bne.n	4f772 <kscan_matrix_read+0x80>
    return kscan_matrix_set_all_outputs(dev, 1);
   4f858:	6868      	ldr	r0, [r5, #4]
   4f85a:	2101      	movs	r1, #1
   4f85c:	f7ff ff35 	bl	4f6ca <kscan_matrix_set_all_outputs.isra.0>
   4f860:	e787      	b.n	4f772 <kscan_matrix_read+0x80>

0004f862 <kscan_matrix_work_handler>:
    kscan_matrix_read(data->dev);
   4f862:	f850 0c10 	ldr.w	r0, [r0, #-16]
   4f866:	f7ff bf44 	b.w	4f6f2 <kscan_matrix_read>

0004f86a <kscan_matrix_interrupt_disable>:
static int kscan_matrix_interrupt_disable(const struct device *dev) {
   4f86a:	b510      	push	{r4, lr}
    int err = kscan_matrix_interrupt_configure(dev, GPIO_INT_DISABLE);
   4f86c:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
static int kscan_matrix_interrupt_disable(const struct device *dev) {
   4f870:	4604      	mov	r4, r0
    int err = kscan_matrix_interrupt_configure(dev, GPIO_INT_DISABLE);
   4f872:	6900      	ldr	r0, [r0, #16]
   4f874:	f7ff fefb 	bl	4f66e <kscan_matrix_interrupt_configure.isra.0>
   4f878:	4601      	mov	r1, r0
    if (err) {
   4f87a:	b920      	cbnz	r0, 4f886 <kscan_matrix_interrupt_disable+0x1c>
    return kscan_matrix_set_all_outputs(dev, 0);
   4f87c:	6860      	ldr	r0, [r4, #4]
}
   4f87e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    return kscan_matrix_set_all_outputs(dev, 0);
   4f882:	f7ff bf22 	b.w	4f6ca <kscan_matrix_set_all_outputs.isra.0>
}
   4f886:	bd10      	pop	{r4, pc}

0004f888 <kscan_matrix_irq_callback_handler>:
                                              const gpio_port_pins_t pin) {
   4f888:	b510      	push	{r4, lr}
    struct kscan_matrix_data *data = irq_data->dev->data;
   4f88a:	f851 3c04 	ldr.w	r3, [r1, #-4]
   4f88e:	691c      	ldr	r4, [r3, #16]
    kscan_matrix_interrupt_disable(data->dev);
   4f890:	6820      	ldr	r0, [r4, #0]
   4f892:	f7ff ffea 	bl	4f86a <kscan_matrix_interrupt_disable>
	return z_impl_k_uptime_ticks();
   4f896:	f000 fd63 	bl	50360 <z_impl_k_uptime_ticks>
   4f89a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   4f89e:	fba0 0302 	umull	r0, r3, r0, r2
   4f8a2:	fb02 3101 	mla	r1, r2, r1, r3
   4f8a6:	0bc0      	lsrs	r0, r0, #15
   4f8a8:	ea40 4041 	orr.w	r0, r0, r1, lsl #17
   4f8ac:	0bc9      	lsrs	r1, r1, #15
    data->scan_time = k_uptime_get();
   4f8ae:	e9c4 0112 	strd	r0, r1, [r4, #72]	; 0x48
    k_work_reschedule(&data->work, K_NO_WAIT);
   4f8b2:	2200      	movs	r2, #0
   4f8b4:	f104 0010 	add.w	r0, r4, #16
   4f8b8:	2300      	movs	r3, #0
}
   4f8ba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    k_work_reschedule(&data->work, K_NO_WAIT);
   4f8be:	f7f7 be95 	b.w	475ec <k_work_reschedule>

0004f8c2 <kscan_matrix_disable>:
static int kscan_matrix_disable(const struct device *dev) {
   4f8c2:	b510      	push	{r4, lr}
   4f8c4:	4604      	mov	r4, r0
    k_work_cancel_delayable(&data->work);
   4f8c6:	6900      	ldr	r0, [r0, #16]
   4f8c8:	3010      	adds	r0, #16
   4f8ca:	f000 fba9 	bl	50020 <k_work_cancel_delayable>
    return kscan_matrix_interrupt_disable(dev);
   4f8ce:	4620      	mov	r0, r4
}
   4f8d0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    return kscan_matrix_interrupt_disable(dev);
   4f8d4:	f7ff bfc9 	b.w	4f86a <kscan_matrix_interrupt_disable>

0004f8d8 <kscan_matrix_enable>:
static int kscan_matrix_enable(const struct device *dev) {
   4f8d8:	b570      	push	{r4, r5, r6, lr}
   4f8da:	4604      	mov	r4, r0
    struct kscan_matrix_data *data = dev->data;
   4f8dc:	6906      	ldr	r6, [r0, #16]
   4f8de:	f000 fd3f 	bl	50360 <z_impl_k_uptime_ticks>
   4f8e2:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
   4f8e6:	fba0 3205 	umull	r3, r2, r0, r5
   4f8ea:	fb05 2101 	mla	r1, r5, r1, r2
   4f8ee:	0bdb      	lsrs	r3, r3, #15
   4f8f0:	ea43 4341 	orr.w	r3, r3, r1, lsl #17
   4f8f4:	0bc9      	lsrs	r1, r1, #15
    data->scan_time = k_uptime_get();
   4f8f6:	e9c6 3112 	strd	r3, r1, [r6, #72]	; 0x48
    return kscan_matrix_read(dev);
   4f8fa:	4620      	mov	r0, r4
}
   4f8fc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    return kscan_matrix_read(dev);
   4f900:	f7ff bef7 	b.w	4f6f2 <kscan_matrix_read>

0004f904 <battery_channel_get>:

#include "battery_common.h"

int battery_channel_get(const struct battery_value *value, enum sensor_channel chan,
                        struct sensor_value *val_out) {
    switch (chan) {
   4f904:	2927      	cmp	r1, #39	; 0x27
   4f906:	d004      	beq.n	4f912 <battery_channel_get+0xe>
   4f908:	292c      	cmp	r1, #44	; 0x2c
   4f90a:	d012      	beq.n	4f932 <battery_channel_get+0x2e>
   4f90c:	f06f 0085 	mvn.w	r0, #133	; 0x85
   4f910:	4770      	bx	lr
    case SENSOR_CHAN_GAUGE_VOLTAGE:
        val_out->val1 = value->millivolts / 1000;
   4f912:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   4f916:	8843      	ldrh	r3, [r0, #2]
   4f918:	fbb3 f3f1 	udiv	r3, r3, r1
   4f91c:	6013      	str	r3, [r2, #0]
        val_out->val2 = (value->millivolts % 1000) * 1000U;
   4f91e:	8843      	ldrh	r3, [r0, #2]
   4f920:	fbb3 f0f1 	udiv	r0, r3, r1
   4f924:	fb01 3310 	mls	r3, r1, r0, r3
   4f928:	b29b      	uxth	r3, r3
   4f92a:	434b      	muls	r3, r1
   4f92c:	6053      	str	r3, [r2, #4]

    default:
        return -ENOTSUP;
    }

    return 0;
   4f92e:	2000      	movs	r0, #0
}
   4f930:	4770      	bx	lr
        val_out->val1 = value->state_of_charge;
   4f932:	7903      	ldrb	r3, [r0, #4]
   4f934:	6013      	str	r3, [r2, #0]
        break;
   4f936:	2300      	movs	r3, #0
   4f938:	e7f8      	b.n	4f92c <battery_channel_get+0x28>

0004f93a <lithium_ion_mv_to_pct>:

uint8_t lithium_ion_mv_to_pct(int16_t bat_mv) {
    // Simple linear approximation of a battery based off adafruit's discharge graph:
    // https://learn.adafruit.com/li-ion-and-lipoly-batteries/voltages

    if (bat_mv >= 4200) {
   4f93a:	f241 0367 	movw	r3, #4199	; 0x1067
   4f93e:	4298      	cmp	r0, r3
   4f940:	dc0a      	bgt.n	4f958 <lithium_ion_mv_to_pct+0x1e>
        return 100;
    } else if (bat_mv <= 3450) {
   4f942:	f640 537a 	movw	r3, #3450	; 0xd7a
   4f946:	4298      	cmp	r0, r3
   4f948:	dd08      	ble.n	4f95c <lithium_ion_mv_to_pct+0x22>
        return 0;
    }

    return bat_mv * 2 / 15 - 459;
   4f94a:	230f      	movs	r3, #15
   4f94c:	0040      	lsls	r0, r0, #1
   4f94e:	fbb0 f0f3 	udiv	r0, r0, r3
   4f952:	3035      	adds	r0, #53	; 0x35
   4f954:	b2c0      	uxtb	r0, r0
   4f956:	4770      	bx	lr
        return 100;
   4f958:	2064      	movs	r0, #100	; 0x64
   4f95a:	4770      	bx	lr
        return 0;
   4f95c:	2000      	movs	r0, #0
   4f95e:	4770      	bx	lr

0004f960 <vddh_channel_get>:
    return battery_channel_get(&drv_data->value, chan, val);
   4f960:	6900      	ldr	r0, [r0, #16]
   4f962:	301c      	adds	r0, #28
   4f964:	f7ff bfce 	b.w	4f904 <battery_channel_get>

0004f968 <gpio_pin_get>:
{
   4f968:	b537      	push	{r0, r1, r2, r4, r5, lr}
   4f96a:	460c      	mov	r4, r1
	const struct gpio_driver_data *const data =
   4f96c:	6905      	ldr	r5, [r0, #16]
	return api->port_get_raw(port, value);
   4f96e:	6883      	ldr	r3, [r0, #8]
   4f970:	a901      	add	r1, sp, #4
   4f972:	685b      	ldr	r3, [r3, #4]
   4f974:	4798      	blx	r3
	if (ret == 0) {
   4f976:	b948      	cbnz	r0, 4f98c <gpio_pin_get+0x24>
		*value ^= data->invert;
   4f978:	9b01      	ldr	r3, [sp, #4]
   4f97a:	682a      	ldr	r2, [r5, #0]
   4f97c:	405a      	eors	r2, r3
		ret = (value & (gpio_port_pins_t)BIT(pin)) != 0 ? 1 : 0;
   4f97e:	2301      	movs	r3, #1
   4f980:	fa03 f104 	lsl.w	r1, r3, r4
   4f984:	420a      	tst	r2, r1
   4f986:	bf14      	ite	ne
   4f988:	4618      	movne	r0, r3
   4f98a:	2000      	moveq	r0, #0
}
   4f98c:	b003      	add	sp, #12
   4f98e:	bd30      	pop	{r4, r5, pc}

0004f990 <gpio_pin_configure_dt.constprop.0>:
static inline int gpio_pin_configure_dt(const struct gpio_dt_spec *spec,
   4f990:	b470      	push	{r4, r5, r6}
   4f992:	4603      	mov	r3, r0
	return gpio_pin_configure(spec->port,
   4f994:	6800      	ldr	r0, [r0, #0]
				  spec->pin,
   4f996:	7919      	ldrb	r1, [r3, #4]
				  spec->dt_flags | extra_flags);
   4f998:	88db      	ldrh	r3, [r3, #6]
	return gpio_pin_configure(spec->port,
   4f99a:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
	struct gpio_driver_data *data =
   4f99e:	6905      	ldr	r5, [r0, #16]
	const struct gpio_driver_api *api =
   4f9a0:	6886      	ldr	r6, [r0, #8]
	if ((flags & GPIO_ACTIVE_LOW) != 0) {
   4f9a2:	f013 0f01 	tst.w	r3, #1
		data->invert |= (gpio_port_pins_t)BIT(pin);
   4f9a6:	f04f 0401 	mov.w	r4, #1
   4f9aa:	682b      	ldr	r3, [r5, #0]
   4f9ac:	fa04 f401 	lsl.w	r4, r4, r1
   4f9b0:	bf14      	ite	ne
   4f9b2:	4323      	orrne	r3, r4
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
   4f9b4:	43a3      	biceq	r3, r4
   4f9b6:	602b      	str	r3, [r5, #0]
	return api->pin_configure(port, pin, flags);
   4f9b8:	6833      	ldr	r3, [r6, #0]
}
   4f9ba:	bc70      	pop	{r4, r5, r6}
	return api->pin_configure(port, pin, flags);
   4f9bc:	4718      	bx	r3

0004f9be <ec11_get_ab_state.isra.0>:
static int ec11_get_ab_state(const struct device *dev) {
   4f9be:	b538      	push	{r3, r4, r5, lr}
   4f9c0:	4604      	mov	r4, r0
	return gpio_pin_get(spec->port, spec->pin);
   4f9c2:	7901      	ldrb	r1, [r0, #4]
   4f9c4:	6800      	ldr	r0, [r0, #0]
   4f9c6:	f7ff ffcf 	bl	4f968 <gpio_pin_get>
   4f9ca:	7b21      	ldrb	r1, [r4, #12]
   4f9cc:	4605      	mov	r5, r0
   4f9ce:	68a0      	ldr	r0, [r4, #8]
   4f9d0:	f7ff ffca 	bl	4f968 <gpio_pin_get>
}
   4f9d4:	ea40 0045 	orr.w	r0, r0, r5, lsl #1
   4f9d8:	bd38      	pop	{r3, r4, r5, pc}

0004f9da <ec11_sample_fetch>:
static int ec11_sample_fetch(const struct device *dev, enum sensor_channel chan) {
   4f9da:	b538      	push	{r3, r4, r5, lr}
    const struct ec11_config *drv_cfg = dev->config;
   4f9dc:	6845      	ldr	r5, [r0, #4]
    struct ec11_data *drv_data = dev->data;
   4f9de:	6904      	ldr	r4, [r0, #16]
    val = ec11_get_ab_state(dev);
   4f9e0:	4628      	mov	r0, r5
   4f9e2:	f7ff ffec 	bl	4f9be <ec11_get_ab_state.isra.0>
    switch (val | (drv_data->ab_state << 2)) {
   4f9e6:	7822      	ldrb	r2, [r4, #0]
    val = ec11_get_ab_state(dev);
   4f9e8:	b2c0      	uxtb	r0, r0
    switch (val | (drv_data->ab_state << 2)) {
   4f9ea:	ea40 0282 	orr.w	r2, r0, r2, lsl #2
   4f9ee:	2a0e      	cmp	r2, #14
   4f9f0:	d81f      	bhi.n	4fa32 <ec11_sample_fetch+0x58>
   4f9f2:	2301      	movs	r3, #1
   4f9f4:	4093      	lsls	r3, r2
   4f9f6:	f642 0214 	movw	r2, #10260	; 0x2814
   4f9fa:	4213      	tst	r3, r2
   4f9fc:	d11b      	bne.n	4fa36 <ec11_sample_fetch+0x5c>
   4f9fe:	f244 1282 	movw	r2, #16770	; 0x4182
   4fa02:	4213      	tst	r3, r2
   4fa04:	bf14      	ite	ne
   4fa06:	2201      	movne	r2, #1
   4fa08:	2200      	moveq	r2, #0
    drv_data->pulses += delta;
   4fa0a:	7863      	ldrb	r3, [r4, #1]
    drv_data->ab_state = val;
   4fa0c:	7020      	strb	r0, [r4, #0]
    drv_data->pulses += delta;
   4fa0e:	4413      	add	r3, r2
   4fa10:	b25b      	sxtb	r3, r3
   4fa12:	7063      	strb	r3, [r4, #1]
    if (drv_cfg->steps == 0) {
   4fa14:	8a29      	ldrh	r1, [r5, #16]
   4fa16:	b951      	cbnz	r1, 4fa2e <ec11_sample_fetch+0x54>
        drv_data->ticks = drv_data->pulses / drv_cfg->resolution;
   4fa18:	7ca9      	ldrb	r1, [r5, #18]
        drv_data->delta = delta;
   4fa1a:	70e2      	strb	r2, [r4, #3]
        drv_data->ticks = drv_data->pulses / drv_cfg->resolution;
   4fa1c:	fb93 f1f1 	sdiv	r1, r3, r1
   4fa20:	70a1      	strb	r1, [r4, #2]
        drv_data->pulses %= drv_cfg->resolution;
   4fa22:	7caa      	ldrb	r2, [r5, #18]
   4fa24:	fb93 f1f2 	sdiv	r1, r3, r2
   4fa28:	fb02 3311 	mls	r3, r2, r1, r3
   4fa2c:	7063      	strb	r3, [r4, #1]
}
   4fa2e:	2000      	movs	r0, #0
   4fa30:	bd38      	pop	{r3, r4, r5, pc}
        delta = 0;
   4fa32:	2200      	movs	r2, #0
   4fa34:	e7e9      	b.n	4fa0a <ec11_sample_fetch+0x30>
        delta = -1;
   4fa36:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   4fa3a:	e7e6      	b.n	4fa0a <ec11_sample_fetch+0x30>

0004fa3c <ec11_init>:
#endif
    .sample_fetch = ec11_sample_fetch,
    .channel_get = ec11_channel_get,
};

int ec11_init(const struct device *dev) {
   4fa3c:	b570      	push	{r4, r5, r6, lr}
    struct ec11_data *drv_data = dev->data;
    const struct ec11_config *drv_cfg = dev->config;
   4fa3e:	6844      	ldr	r4, [r0, #4]
    struct ec11_data *drv_data = dev->data;
   4fa40:	6906      	ldr	r6, [r0, #16]
int ec11_init(const struct device *dev) {
   4fa42:	4605      	mov	r5, r0

    LOG_DBG("A: %s %d B: %s %d resolution %d", drv_cfg->a.port->name, drv_cfg->a.pin,
            drv_cfg->b.port->name, drv_cfg->b.pin, drv_cfg->resolution);

    if (!device_is_ready(drv_cfg->a.port)) {
   4fa44:	6820      	ldr	r0, [r4, #0]
   4fa46:	f000 f81e 	bl	4fa86 <z_device_is_ready>
   4fa4a:	b918      	cbnz	r0, 4fa54 <ec11_init+0x18>
        LOG_ERR("A GPIO device is not ready");
        return -EINVAL;
   4fa4c:	f06f 0415 	mvn.w	r4, #21
#endif

    drv_data->ab_state = ec11_get_ab_state(dev);

    return 0;
}
   4fa50:	4620      	mov	r0, r4
   4fa52:	bd70      	pop	{r4, r5, r6, pc}
    if (!device_is_ready(drv_cfg->b.port)) {
   4fa54:	68a0      	ldr	r0, [r4, #8]
   4fa56:	f000 f816 	bl	4fa86 <z_device_is_ready>
   4fa5a:	2800      	cmp	r0, #0
   4fa5c:	d0f6      	beq.n	4fa4c <ec11_init+0x10>
    if (gpio_pin_configure_dt(&drv_cfg->a, GPIO_INPUT)) {
   4fa5e:	4620      	mov	r0, r4
   4fa60:	f7ff ff96 	bl	4f990 <gpio_pin_configure_dt.constprop.0>
   4fa64:	b110      	cbz	r0, 4fa6c <ec11_init+0x30>
        return -EIO;
   4fa66:	f06f 0404 	mvn.w	r4, #4
   4fa6a:	e7f1      	b.n	4fa50 <ec11_init+0x14>
    if (gpio_pin_configure_dt(&drv_cfg->b, GPIO_INPUT)) {
   4fa6c:	f104 0008 	add.w	r0, r4, #8
   4fa70:	f7ff ff8e 	bl	4f990 <gpio_pin_configure_dt.constprop.0>
   4fa74:	4604      	mov	r4, r0
   4fa76:	2800      	cmp	r0, #0
   4fa78:	d1f5      	bne.n	4fa66 <ec11_init+0x2a>
    drv_data->ab_state = ec11_get_ab_state(dev);
   4fa7a:	6868      	ldr	r0, [r5, #4]
   4fa7c:	f7ff ff9f 	bl	4f9be <ec11_get_ab_state.isra.0>
   4fa80:	7030      	strb	r0, [r6, #0]
    return 0;
   4fa82:	e7e5      	b.n	4fa50 <ec11_init+0x14>

0004fa84 <z_device_state_init>:
}
   4fa84:	4770      	bx	lr

0004fa86 <z_device_is_ready>:
{
	/*
	 * if an invalid device pointer is passed as argument, this call
	 * reports the `device` as not ready for usage.
	 */
	if (dev == NULL) {
   4fa86:	b138      	cbz	r0, 4fa98 <z_device_is_ready+0x12>
		return false;
	}

	return dev->state->initialized && (dev->state->init_res == 0U);
   4fa88:	68c3      	ldr	r3, [r0, #12]
   4fa8a:	8818      	ldrh	r0, [r3, #0]
   4fa8c:	f3c0 0008 	ubfx	r0, r0, #0, #9
   4fa90:	f5a0 7380 	sub.w	r3, r0, #256	; 0x100
   4fa94:	4258      	negs	r0, r3
   4fa96:	4158      	adcs	r0, r3
}
   4fa98:	4770      	bx	lr

0004fa9a <arch_system_halt>:
	__asm__ volatile(
   4fa9a:	f04f 0220 	mov.w	r2, #32
   4fa9e:	f3ef 8311 	mrs	r3, BASEPRI
   4faa2:	f382 8812 	msr	BASEPRI_MAX, r2
   4faa6:	f3bf 8f6f 	isb	sy
	/* TODO: What's the best way to totally halt the system if SMP
	 * is enabled?
	 */

	(void)arch_irq_lock();
	for (;;) {
   4faaa:	e7fe      	b.n	4faaa <arch_system_halt+0x10>

0004faac <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
   4faac:	b508      	push	{r3, lr}
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
	arch_system_halt(reason);
   4faae:	f7ff fff4 	bl	4fa9a <arch_system_halt>

0004fab2 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
   4fab2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   4fab4:	4605      	mov	r5, r0
   4fab6:	460e      	mov	r6, r1
   4fab8:	f04f 0320 	mov.w	r3, #32
   4fabc:	f3ef 8711 	mrs	r7, BASEPRI
   4fac0:	f383 8812 	msr	BASEPRI_MAX, r3
   4fac4:	f3bf 8f6f 	isb	sy
	return z_impl_z_current_get();
   4fac8:	f7f8 f87c 	bl	47bc4 <z_impl_z_current_get>

#ifndef CONFIG_XTENSA
	coredump(reason, esf, thread);
#endif

	k_sys_fatal_error_handler(reason, esf);
   4facc:	4631      	mov	r1, r6
   4face:	4604      	mov	r4, r0
   4fad0:	4628      	mov	r0, r5
   4fad2:	f7ff ffeb 	bl	4faac <k_sys_fatal_error_handler>
	__asm__ volatile(
   4fad6:	f387 8811 	msr	BASEPRI, r7
   4fada:	f3bf 8f6f 	isb	sy
	z_impl_k_thread_abort(thread);
   4fade:	4620      	mov	r0, r4
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
   4fae0:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   4fae4:	f7dd bb9e 	b.w	2d224 <z_impl_k_thread_abort>

0004fae8 <z_early_memset>:
	(void) memset(dst, c, n);
   4fae8:	f7fb b9d2 	b.w	4ae90 <memset>

0004faec <z_early_memcpy>:
	(void) memcpy(dst, src, n);
   4faec:	f7fb b9c5 	b.w	4ae7a <memcpy>

0004faf0 <k_heap_init>:
{
   4faf0:	b410      	push	{r4}
	sys_dlist_init(&w->waitq);
   4faf2:	f100 040c 	add.w	r4, r0, #12
	list->tail = (sys_dnode_t *)list;
   4faf6:	e9c0 4403 	strd	r4, r4, [r0, #12]
}
   4fafa:	bc10      	pop	{r4}
	sys_heap_init(&h->heap, mem, bytes);
   4fafc:	f7f9 ba8a 	b.w	49014 <sys_heap_init>

0004fb00 <k_heap_aligned_alloc>:
SYS_INIT_NAMED(statics_init_post, statics_init, POST_KERNEL, 0);
#endif /* CONFIG_DEMAND_PAGING && !CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT */

void *k_heap_aligned_alloc(struct k_heap *h, size_t align, size_t bytes,
			k_timeout_t timeout)
{
   4fb00:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4fb04:	b085      	sub	sp, #20
   4fb06:	e9dd a40e 	ldrd	sl, r4, [sp, #56]	; 0x38
   4fb0a:	4607      	mov	r7, r0
   4fb0c:	4688      	mov	r8, r1
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
   4fb0e:	4650      	mov	r0, sl
   4fb10:	4621      	mov	r1, r4
{
   4fb12:	4691      	mov	r9, r2
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
   4fb14:	f000 fc2a 	bl	5036c <sys_clock_timeout_end_calc>
	void *ret = NULL;

	end = K_TIMEOUT_EQ(timeout, K_FOREVER) ? INT64_MAX : end;
   4fb18:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
   4fb1c:	bf08      	it	eq
   4fb1e:	f1ba 3fff 	cmpeq.w	sl, #4294967295	; 0xffffffff
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
   4fb22:	4605      	mov	r5, r0
   4fb24:	460e      	mov	r6, r1
	end = K_TIMEOUT_EQ(timeout, K_FOREVER) ? INT64_MAX : end;
   4fb26:	bf04      	itt	eq
   4fb28:	f04f 35ff 	moveq.w	r5, #4294967295	; 0xffffffff
   4fb2c:	f06f 4600 	mvneq.w	r6, #2147483648	; 0x80000000

	k_spinlock_key_t key = k_spin_lock(&h->lock);
   4fb30:	f107 0a14 	add.w	sl, r7, #20
	__asm__ volatile(
   4fb34:	f04f 0320 	mov.w	r3, #32
   4fb38:	f3ef 8411 	mrs	r4, BASEPRI
   4fb3c:	f383 8812 	msr	BASEPRI_MAX, r3
   4fb40:	f3bf 8f6f 	isb	sy
			/**
			 * @todo	Trace attempt to avoid empty trace segments
			 */
		}

		(void) z_pend_curr(&h->lock, key, &h->wait_q,
   4fb44:	f107 0b0c 	add.w	fp, r7, #12
		ret = sys_heap_aligned_alloc(&h->heap, align, bytes);
   4fb48:	464a      	mov	r2, r9
   4fb4a:	4641      	mov	r1, r8
   4fb4c:	4638      	mov	r0, r7
   4fb4e:	f7f9 f9fa 	bl	48f46 <sys_heap_aligned_alloc>
   4fb52:	9003      	str	r0, [sp, #12]
		now = sys_clock_tick_get();
   4fb54:	f7f8 f9ee 	bl	47f34 <sys_clock_tick_get>
		if (!IS_ENABLED(CONFIG_MULTITHREADING) ||
   4fb58:	9b03      	ldr	r3, [sp, #12]
   4fb5a:	b13b      	cbz	r3, 4fb6c <k_heap_aligned_alloc+0x6c>
	__asm__ volatile(
   4fb5c:	f384 8811 	msr	BASEPRI, r4
   4fb60:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap, aligned_alloc, h, timeout, ret);

	k_spin_unlock(&h->lock, key);
	return ret;
}
   4fb64:	4618      	mov	r0, r3
   4fb66:	b005      	add	sp, #20
   4fb68:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		    (ret != NULL) || ((end - now) <= 0)) {
   4fb6c:	1a28      	subs	r0, r5, r0
   4fb6e:	eb66 0101 	sbc.w	r1, r6, r1
   4fb72:	2801      	cmp	r0, #1
   4fb74:	f171 0200 	sbcs.w	r2, r1, #0
   4fb78:	dbf0      	blt.n	4fb5c <k_heap_aligned_alloc+0x5c>
		(void) z_pend_curr(&h->lock, key, &h->wait_q,
   4fb7a:	e9cd 0100 	strd	r0, r1, [sp]
   4fb7e:	465a      	mov	r2, fp
   4fb80:	4621      	mov	r1, r4
   4fb82:	4650      	mov	r0, sl
   4fb84:	f7f7 fe8a 	bl	4789c <z_pend_curr>
	__asm__ volatile(
   4fb88:	f04f 0320 	mov.w	r3, #32
   4fb8c:	f3ef 8411 	mrs	r4, BASEPRI
   4fb90:	f383 8812 	msr	BASEPRI_MAX, r3
   4fb94:	f3bf 8f6f 	isb	sy
	return k;
   4fb98:	e7d6      	b.n	4fb48 <k_heap_aligned_alloc+0x48>

0004fb9a <k_heap_free>:

	return ret;
}

void k_heap_free(struct k_heap *h, void *mem)
{
   4fb9a:	b538      	push	{r3, r4, r5, lr}
   4fb9c:	4604      	mov	r4, r0
   4fb9e:	f04f 0320 	mov.w	r3, #32
   4fba2:	f3ef 8511 	mrs	r5, BASEPRI
   4fba6:	f383 8812 	msr	BASEPRI_MAX, r3
   4fbaa:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&h->lock);

	sys_heap_free(&h->heap, mem);
   4fbae:	f7f9 f992 	bl	48ed6 <sys_heap_free>

	SYS_PORT_TRACING_OBJ_FUNC(k_heap, free, h);
	if (IS_ENABLED(CONFIG_MULTITHREADING) && z_unpend_all(&h->wait_q) != 0) {
   4fbb2:	f104 000c 	add.w	r0, r4, #12
   4fbb6:	f000 fb5a 	bl	5026e <z_unpend_all>
   4fbba:	b130      	cbz	r0, 4fbca <k_heap_free+0x30>
		z_reschedule(&h->lock, key);
   4fbbc:	4629      	mov	r1, r5
   4fbbe:	f104 0014 	add.w	r0, r4, #20
	} else {
		k_spin_unlock(&h->lock, key);
	}
}
   4fbc2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		z_reschedule(&h->lock, key);
   4fbc6:	f7f7 bec3 	b.w	47950 <z_reschedule>
	__asm__ volatile(
   4fbca:	f385 8811 	msr	BASEPRI, r5
   4fbce:	f3bf 8f6f 	isb	sy
}
   4fbd2:	bd38      	pop	{r3, r4, r5, pc}

0004fbd4 <create_free_list>:
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
   4fbd4:	e9d0 3203 	ldrd	r3, r2, [r0, #12]
   4fbd8:	4313      	orrs	r3, r2
   4fbda:	f013 0303 	ands.w	r3, r3, #3
   4fbde:	d10c      	bne.n	4fbfa <create_free_list+0x26>
	slab->free_list = NULL;
   4fbe0:	6143      	str	r3, [r0, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   4fbe2:	6881      	ldr	r1, [r0, #8]
   4fbe4:	4299      	cmp	r1, r3
   4fbe6:	d801      	bhi.n	4fbec <create_free_list+0x18>
	return 0;
   4fbe8:	2000      	movs	r0, #0
   4fbea:	4770      	bx	lr
		*(char **)p = slab->free_list;
   4fbec:	6941      	ldr	r1, [r0, #20]
   4fbee:	6011      	str	r1, [r2, #0]
		p += slab->block_size;
   4fbf0:	68c1      	ldr	r1, [r0, #12]
		slab->free_list = p;
   4fbf2:	6142      	str	r2, [r0, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   4fbf4:	3301      	adds	r3, #1
		p += slab->block_size;
   4fbf6:	440a      	add	r2, r1
	for (j = 0U; j < slab->num_blocks; j++) {
   4fbf8:	e7f3      	b.n	4fbe2 <create_free_list+0xe>
		return -EINVAL;
   4fbfa:	f06f 0015 	mvn.w	r0, #21
}
   4fbfe:	4770      	bx	lr

0004fc00 <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
   4fc00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   4fc02:	4604      	mov	r4, r0
   4fc04:	460d      	mov	r5, r1
	__asm__ volatile(
   4fc06:	f04f 0320 	mov.w	r3, #32
   4fc0a:	f3ef 8611 	mrs	r6, BASEPRI
   4fc0e:	f383 8812 	msr	BASEPRI_MAX, r3
   4fc12:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&slab->lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, free, slab);
	if (slab->free_list == NULL && IS_ENABLED(CONFIG_MULTITHREADING)) {
   4fc16:	6947      	ldr	r7, [r0, #20]
   4fc18:	b977      	cbnz	r7, 4fc38 <k_mem_slab_free+0x38>
		struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
   4fc1a:	f000 fae2 	bl	501e2 <z_unpend_first_thread>

		if (pending_thread != NULL) {
   4fc1e:	b158      	cbz	r0, 4fc38 <k_mem_slab_free+0x38>
			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

			z_thread_return_value_set_with_data(pending_thread, 0, *mem);
   4fc20:	682a      	ldr	r2, [r5, #0]
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
   4fc22:	6142      	str	r2, [r0, #20]
   4fc24:	67c7      	str	r7, [r0, #124]	; 0x7c
			z_ready_thread(pending_thread);
   4fc26:	f000 faa5 	bl	50174 <z_ready_thread>
			z_reschedule(&slab->lock, key);
   4fc2a:	4631      	mov	r1, r6
   4fc2c:	f104 0008 	add.w	r0, r4, #8
	slab->num_used--;

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

	k_spin_unlock(&slab->lock, key);
}
   4fc30:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			z_reschedule(&slab->lock, key);
   4fc34:	f7f7 be8c 	b.w	47950 <z_reschedule>
	**(char ***) mem = slab->free_list;
   4fc38:	682b      	ldr	r3, [r5, #0]
   4fc3a:	6962      	ldr	r2, [r4, #20]
   4fc3c:	601a      	str	r2, [r3, #0]
	slab->free_list = *(char **) mem;
   4fc3e:	682b      	ldr	r3, [r5, #0]
   4fc40:	6163      	str	r3, [r4, #20]
	slab->num_used--;
   4fc42:	69a3      	ldr	r3, [r4, #24]
   4fc44:	3b01      	subs	r3, #1
   4fc46:	61a3      	str	r3, [r4, #24]
	__asm__ volatile(
   4fc48:	f386 8811 	msr	BASEPRI, r6
   4fc4c:	f3bf 8f6f 	isb	sy
}
   4fc50:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0004fc52 <k_is_in_isr>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   4fc52:	f3ef 8005 	mrs	r0, IPSR
}
   4fc56:	3800      	subs	r0, #0
   4fc58:	bf18      	it	ne
   4fc5a:	2001      	movne	r0, #1
   4fc5c:	4770      	bx	lr

0004fc5e <z_impl_k_thread_name_set>:
}
   4fc5e:	f06f 0057 	mvn.w	r0, #87	; 0x57
   4fc62:	4770      	bx	lr

0004fc64 <z_impl_k_thread_start>:
	z_sched_start(thread);
   4fc64:	f7f7 be86 	b.w	47974 <z_sched_start>

0004fc68 <z_pm_save_idle_exit>:
{
   4fc68:	b508      	push	{r3, lr}
	pm_system_resume();
   4fc6a:	f7dc fe55 	bl	2c918 <pm_system_resume>
}
   4fc6e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	sys_clock_idle_exit();
   4fc72:	f7ff bb05 	b.w	4f280 <sys_clock_idle_exit>

0004fc76 <adjust_owner_prio.isra.0>:
	if (mutex->owner->base.prio != new_prio) {
   4fc76:	f990 300e 	ldrsb.w	r3, [r0, #14]
   4fc7a:	428b      	cmp	r3, r1
   4fc7c:	d001      	beq.n	4fc82 <adjust_owner_prio.isra.0+0xc>
		return z_set_prio(mutex->owner, new_prio);
   4fc7e:	f7f7 be21 	b.w	478c4 <z_set_prio>
}
   4fc82:	2000      	movs	r0, #0
   4fc84:	4770      	bx	lr

0004fc86 <z_impl_k_mutex_init>:
{
   4fc86:	4603      	mov	r3, r0
	mutex->owner = NULL;
   4fc88:	2000      	movs	r0, #0
	mutex->lock_count = 0U;
   4fc8a:	e9c3 0002 	strd	r0, r0, [r3, #8]
   4fc8e:	e9c3 3300 	strd	r3, r3, [r3]
}
   4fc92:	4770      	bx	lr

0004fc94 <queue_insert>:
{
   4fc94:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   4fc98:	4699      	mov	r9, r3
   4fc9a:	4604      	mov	r4, r0
   4fc9c:	f89d 3020 	ldrb.w	r3, [sp, #32]
   4fca0:	460d      	mov	r5, r1
   4fca2:	4690      	mov	r8, r2
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   4fca4:	f100 0608 	add.w	r6, r0, #8
	__asm__ volatile(
   4fca8:	f04f 0220 	mov.w	r2, #32
   4fcac:	f3ef 8711 	mrs	r7, BASEPRI
   4fcb0:	f382 8812 	msr	BASEPRI_MAX, r2
   4fcb4:	f3bf 8f6f 	isb	sy
	if (is_append) {
   4fcb8:	b103      	cbz	r3, 4fcbc <queue_insert+0x28>
	return list->tail;
   4fcba:	6845      	ldr	r5, [r0, #4]
	first_pending_thread = z_unpend_first_thread(&queue->wait_q);
   4fcbc:	4630      	mov	r0, r6
   4fcbe:	f000 fa90 	bl	501e2 <z_unpend_first_thread>
	if (first_pending_thread != NULL) {
   4fcc2:	b158      	cbz	r0, 4fcdc <queue_insert+0x48>
   4fcc4:	2300      	movs	r3, #0
   4fcc6:	67c3      	str	r3, [r0, #124]	; 0x7c
   4fcc8:	f8c0 8014 	str.w	r8, [r0, #20]
	z_ready_thread(thread);
   4fccc:	f000 fa52 	bl	50174 <z_ready_thread>
	z_reschedule(&queue->lock, key);
   4fcd0:	4630      	mov	r0, r6
   4fcd2:	4639      	mov	r1, r7
   4fcd4:	f7f7 fe3c 	bl	47950 <z_reschedule>
		return 0;
   4fcd8:	2000      	movs	r0, #0
   4fcda:	e00c      	b.n	4fcf6 <queue_insert+0x62>
	if (alloc) {
   4fcdc:	f1b9 0f00 	cmp.w	r9, #0
   4fce0:	d01b      	beq.n	4fd1a <queue_insert+0x86>
	return z_thread_aligned_alloc(0, size);
   4fce2:	2108      	movs	r1, #8
   4fce4:	f7f8 fa88 	bl	481f8 <z_thread_aligned_alloc>
		if (anode == NULL) {
   4fce8:	b938      	cbnz	r0, 4fcfa <queue_insert+0x66>
	__asm__ volatile(
   4fcea:	f387 8811 	msr	BASEPRI, r7
   4fcee:	f3bf 8f6f 	isb	sy
			return -ENOMEM;
   4fcf2:	f06f 000b 	mvn.w	r0, #11
}
   4fcf6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	node->next_and_flags = flags;
   4fcfa:	2201      	movs	r2, #1
		anode->data = data;
   4fcfc:	f8c0 8004 	str.w	r8, [r0, #4]
   4fd00:	6002      	str	r2, [r0, #0]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   4fd02:	6801      	ldr	r1, [r0, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   4fd04:	f001 0103 	and.w	r1, r1, #3
Z_GENLIST_INSERT(sflist, sfnode)
   4fd08:	b95d      	cbnz	r5, 4fd22 <queue_insert+0x8e>
	parent->next_and_flags = cur_flags | (unative_t)child;
   4fd0a:	6822      	ldr	r2, [r4, #0]
   4fd0c:	430a      	orrs	r2, r1
   4fd0e:	6002      	str	r2, [r0, #0]
Z_GENLIST_PREPEND(sflist, sfnode)
   4fd10:	6862      	ldr	r2, [r4, #4]
	list->head = node;
   4fd12:	6020      	str	r0, [r4, #0]
Z_GENLIST_PREPEND(sflist, sfnode)
   4fd14:	b96a      	cbnz	r2, 4fd32 <queue_insert+0x9e>
	list->tail = node;
   4fd16:	6060      	str	r0, [r4, #4]
}
   4fd18:	e00b      	b.n	4fd32 <queue_insert+0x9e>
	node->next_and_flags = flags;
   4fd1a:	f8c8 9000 	str.w	r9, [r8]
}
   4fd1e:	4640      	mov	r0, r8
   4fd20:	e7ef      	b.n	4fd02 <queue_insert+0x6e>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   4fd22:	682a      	ldr	r2, [r5, #0]
Z_GENLIST_INSERT(sflist, sfnode)
   4fd24:	2a03      	cmp	r2, #3
   4fd26:	d810      	bhi.n	4fd4a <queue_insert+0xb6>
	parent->next_and_flags = cur_flags | (unative_t)child;
   4fd28:	6001      	str	r1, [r0, #0]
	return list->tail;
   4fd2a:	6861      	ldr	r1, [r4, #4]
Z_GENLIST_APPEND(sflist, sfnode)
   4fd2c:	b939      	cbnz	r1, 4fd3e <queue_insert+0xaa>
	list->head = node;
   4fd2e:	e9c4 0000 	strd	r0, r0, [r4]
	z_handle_obj_poll_events(&queue->poll_events, state);
   4fd32:	2104      	movs	r1, #4
   4fd34:	f104 0010 	add.w	r0, r4, #16
   4fd38:	f000 fc97 	bl	5066a <z_handle_obj_poll_events>
   4fd3c:	e7c8      	b.n	4fcd0 <queue_insert+0x3c>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   4fd3e:	680a      	ldr	r2, [r1, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   4fd40:	f002 0203 	and.w	r2, r2, #3
   4fd44:	4302      	orrs	r2, r0
   4fd46:	600a      	str	r2, [r1, #0]
   4fd48:	e7e5      	b.n	4fd16 <queue_insert+0x82>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   4fd4a:	f022 0203 	bic.w	r2, r2, #3
	parent->next_and_flags = cur_flags | (unative_t)child;
   4fd4e:	430a      	orrs	r2, r1
   4fd50:	6002      	str	r2, [r0, #0]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   4fd52:	682a      	ldr	r2, [r5, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   4fd54:	f002 0203 	and.w	r2, r2, #3
   4fd58:	ea40 0302 	orr.w	r3, r0, r2
   4fd5c:	602b      	str	r3, [r5, #0]
}
   4fd5e:	e7e8      	b.n	4fd32 <queue_insert+0x9e>

0004fd60 <z_queue_node_peek>:
{
   4fd60:	b510      	push	{r4, lr}
	if ((node != NULL) && (sys_sfnode_flags_get(node) != (uint8_t)0)) {
   4fd62:	4604      	mov	r4, r0
   4fd64:	b130      	cbz	r0, 4fd74 <z_queue_node_peek+0x14>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   4fd66:	6802      	ldr	r2, [r0, #0]
   4fd68:	0793      	lsls	r3, r2, #30
   4fd6a:	d003      	beq.n	4fd74 <z_queue_node_peek+0x14>
		ret = anode->data;
   4fd6c:	6844      	ldr	r4, [r0, #4]
		if (needs_free) {
   4fd6e:	b109      	cbz	r1, 4fd74 <z_queue_node_peek+0x14>
			k_free(anode);
   4fd70:	f000 fca1 	bl	506b6 <k_free>
}
   4fd74:	4620      	mov	r0, r4
   4fd76:	bd10      	pop	{r4, pc}

0004fd78 <z_impl_k_queue_init>:
	list->head = NULL;
   4fd78:	2300      	movs	r3, #0
	list->tail = NULL;
   4fd7a:	e9c0 3300 	strd	r3, r3, [r0]
   4fd7e:	f100 0308 	add.w	r3, r0, #8
   4fd82:	e9c0 3302 	strd	r3, r3, [r0, #8]
	sys_dlist_init(&queue->poll_events);
   4fd86:	f100 0310 	add.w	r3, r0, #16
   4fd8a:	e9c0 3304 	strd	r3, r3, [r0, #16]
}
   4fd8e:	4770      	bx	lr

0004fd90 <z_impl_k_queue_cancel_wait>:
{
   4fd90:	b570      	push	{r4, r5, r6, lr}
   4fd92:	4604      	mov	r4, r0
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   4fd94:	f100 0508 	add.w	r5, r0, #8
	__asm__ volatile(
   4fd98:	f04f 0320 	mov.w	r3, #32
   4fd9c:	f3ef 8611 	mrs	r6, BASEPRI
   4fda0:	f383 8812 	msr	BASEPRI_MAX, r3
   4fda4:	f3bf 8f6f 	isb	sy
	first_pending_thread = z_unpend_first_thread(&queue->wait_q);
   4fda8:	4628      	mov	r0, r5
   4fdaa:	f000 fa1a 	bl	501e2 <z_unpend_first_thread>
	if (first_pending_thread != NULL) {
   4fdae:	b120      	cbz	r0, 4fdba <z_impl_k_queue_cancel_wait+0x2a>
   4fdb0:	2200      	movs	r2, #0
   4fdb2:	67c2      	str	r2, [r0, #124]	; 0x7c
	thread->base.swap_data = data;
   4fdb4:	6142      	str	r2, [r0, #20]
	z_ready_thread(thread);
   4fdb6:	f000 f9dd 	bl	50174 <z_ready_thread>
	z_handle_obj_poll_events(&queue->poll_events, state);
   4fdba:	f104 0010 	add.w	r0, r4, #16
   4fdbe:	2108      	movs	r1, #8
   4fdc0:	f000 fc53 	bl	5066a <z_handle_obj_poll_events>
	z_reschedule(&queue->lock, key);
   4fdc4:	4631      	mov	r1, r6
   4fdc6:	4628      	mov	r0, r5
}
   4fdc8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_reschedule(&queue->lock, key);
   4fdcc:	f7f7 bdc0 	b.w	47950 <z_reschedule>

0004fdd0 <k_queue_append>:
{
   4fdd0:	b507      	push	{r0, r1, r2, lr}
	(void)queue_insert(queue, NULL, data, false, true);
   4fdd2:	2301      	movs	r3, #1
   4fdd4:	9300      	str	r3, [sp, #0]
   4fdd6:	2300      	movs	r3, #0
{
   4fdd8:	460a      	mov	r2, r1
	(void)queue_insert(queue, NULL, data, false, true);
   4fdda:	4619      	mov	r1, r3
   4fddc:	f7ff ff5a 	bl	4fc94 <queue_insert>
}
   4fde0:	b003      	add	sp, #12
   4fde2:	f85d fb04 	ldr.w	pc, [sp], #4

0004fde6 <k_queue_prepend>:
{
   4fde6:	b507      	push	{r0, r1, r2, lr}
	(void)queue_insert(queue, NULL, data, false, false);
   4fde8:	2300      	movs	r3, #0
{
   4fdea:	460a      	mov	r2, r1
	(void)queue_insert(queue, NULL, data, false, false);
   4fdec:	9300      	str	r3, [sp, #0]
   4fdee:	4619      	mov	r1, r3
   4fdf0:	f7ff ff50 	bl	4fc94 <queue_insert>
}
   4fdf4:	b003      	add	sp, #12
   4fdf6:	f85d fb04 	ldr.w	pc, [sp], #4

0004fdfa <k_queue_append_list>:
{
   4fdfa:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   4fdfe:	4680      	mov	r8, r0
   4fe00:	4615      	mov	r5, r2
	CHECKIF(head == NULL || tail == NULL) {
   4fe02:	460c      	mov	r4, r1
   4fe04:	b3a9      	cbz	r1, 4fe72 <k_queue_append_list+0x78>
   4fe06:	b3a2      	cbz	r2, 4fe72 <k_queue_append_list+0x78>
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   4fe08:	f100 0608 	add.w	r6, r0, #8
   4fe0c:	f04f 0320 	mov.w	r3, #32
   4fe10:	f3ef 8711 	mrs	r7, BASEPRI
   4fe14:	f383 8812 	msr	BASEPRI_MAX, r3
   4fe18:	f3bf 8f6f 	isb	sy
		thread = z_unpend_first_thread(&queue->wait_q);
   4fe1c:	4630      	mov	r0, r6
   4fe1e:	f000 f9e0 	bl	501e2 <z_unpend_first_thread>
	while ((head != NULL) && (thread != NULL)) {
   4fe22:	b168      	cbz	r0, 4fe40 <k_queue_append_list+0x46>
   4fe24:	f04f 0900 	mov.w	r9, #0
   4fe28:	6144      	str	r4, [r0, #20]
   4fe2a:	f8c0 907c 	str.w	r9, [r0, #124]	; 0x7c
	z_ready_thread(thread);
   4fe2e:	f000 f9a1 	bl	50174 <z_ready_thread>
		head = *(void **)head;
   4fe32:	6824      	ldr	r4, [r4, #0]
		thread = z_unpend_first_thread(&queue->wait_q);
   4fe34:	4630      	mov	r0, r6
   4fe36:	f000 f9d4 	bl	501e2 <z_unpend_first_thread>
	while ((head != NULL) && (thread != NULL)) {
   4fe3a:	b144      	cbz	r4, 4fe4e <k_queue_append_list+0x54>
   4fe3c:	2800      	cmp	r0, #0
   4fe3e:	d1f3      	bne.n	4fe28 <k_queue_append_list+0x2e>
	return list->tail;
   4fe40:	f8d8 3004 	ldr.w	r3, [r8, #4]
Z_GENLIST_APPEND_LIST(sflist, sfnode)
   4fe44:	b97b      	cbnz	r3, 4fe66 <k_queue_append_list+0x6c>
	list->head = node;
   4fe46:	f8c8 4000 	str.w	r4, [r8]
	list->tail = node;
   4fe4a:	f8c8 5004 	str.w	r5, [r8, #4]
	z_handle_obj_poll_events(&queue->poll_events, state);
   4fe4e:	2104      	movs	r1, #4
   4fe50:	f108 0010 	add.w	r0, r8, #16
   4fe54:	f000 fc09 	bl	5066a <z_handle_obj_poll_events>
	z_reschedule(&queue->lock, key);
   4fe58:	4630      	mov	r0, r6
   4fe5a:	4639      	mov	r1, r7
   4fe5c:	f7f7 fd78 	bl	47950 <z_reschedule>
	return 0;
   4fe60:	2000      	movs	r0, #0
}
   4fe62:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   4fe66:	681a      	ldr	r2, [r3, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   4fe68:	f002 0203 	and.w	r2, r2, #3
   4fe6c:	4314      	orrs	r4, r2
   4fe6e:	601c      	str	r4, [r3, #0]
}
   4fe70:	e7eb      	b.n	4fe4a <k_queue_append_list+0x50>
		return -EINVAL;
   4fe72:	f06f 0015 	mvn.w	r0, #21
   4fe76:	e7f4      	b.n	4fe62 <k_queue_append_list+0x68>

0004fe78 <z_impl_k_sem_init>:
	CHECKIF(limit == 0U || limit > K_SEM_MAX_LIMIT || initial_count > limit) {
   4fe78:	b15a      	cbz	r2, 4fe92 <z_impl_k_sem_init+0x1a>
   4fe7a:	428a      	cmp	r2, r1
   4fe7c:	d309      	bcc.n	4fe92 <z_impl_k_sem_init+0x1a>
	sys_dlist_init(&sem->poll_events);
   4fe7e:	f100 0310 	add.w	r3, r0, #16
	sem->limit = limit;
   4fe82:	e9c0 1202 	strd	r1, r2, [r0, #8]
   4fe86:	e9c0 0000 	strd	r0, r0, [r0]
   4fe8a:	e9c0 3304 	strd	r3, r3, [r0, #16]
	return 0;
   4fe8e:	2000      	movs	r0, #0
   4fe90:	4770      	bx	lr
		return -EINVAL;
   4fe92:	f06f 0015 	mvn.w	r0, #21
}
   4fe96:	4770      	bx	lr

0004fe98 <flag_test_and_clear>:
	return (*flagp & BIT(bit)) != 0U;
   4fe98:	6802      	ldr	r2, [r0, #0]
	*flagp &= ~BIT(bit);
   4fe9a:	2301      	movs	r3, #1
   4fe9c:	408b      	lsls	r3, r1
   4fe9e:	ea22 0303 	bic.w	r3, r2, r3
   4fea2:	6003      	str	r3, [r0, #0]
	return (*flagp & BIT(bit)) != 0U;
   4fea4:	fa22 f001 	lsr.w	r0, r2, r1
}
   4fea8:	f000 0001 	and.w	r0, r0, #1
   4feac:	4770      	bx	lr

0004feae <unschedule_locked>:
{
   4feae:	b538      	push	{r3, r4, r5, lr}
	if (flag_test_and_clear(&work->flags, K_WORK_DELAYED_BIT)) {
   4feb0:	2103      	movs	r1, #3
{
   4feb2:	4605      	mov	r5, r0
	if (flag_test_and_clear(&work->flags, K_WORK_DELAYED_BIT)) {
   4feb4:	300c      	adds	r0, #12
   4feb6:	f7ff ffef 	bl	4fe98 <flag_test_and_clear>
   4feba:	4604      	mov	r4, r0
   4febc:	b118      	cbz	r0, 4fec6 <unschedule_locked+0x18>
		z_abort_timeout(&dwork->timeout);
   4febe:	f105 0010 	add.w	r0, r5, #16
   4fec2:	f000 fa07 	bl	502d4 <z_abort_timeout>
}
   4fec6:	4620      	mov	r0, r4
   4fec8:	bd38      	pop	{r3, r4, r5, pc}

0004feca <notify_queue_locked.isra.0>:
	if (queue != NULL) {
   4feca:	b120      	cbz	r0, 4fed6 <notify_queue_locked.isra.0+0xc>
		rv = z_sched_wake(&queue->notifyq, 0, NULL);
   4fecc:	2200      	movs	r2, #0
   4fece:	4611      	mov	r1, r2
   4fed0:	3088      	adds	r0, #136	; 0x88
   4fed2:	f000 b9dc 	b.w	5028e <z_sched_wake>
}
   4fed6:	4770      	bx	lr

0004fed8 <cancel_async_locked>:
{
   4fed8:	b570      	push	{r4, r5, r6, lr}
	return (*flagp & BIT(bit)) != 0U;
   4feda:	68c3      	ldr	r3, [r0, #12]
	if (!flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
   4fedc:	f3c3 0640 	ubfx	r6, r3, #1, #1
   4fee0:	079b      	lsls	r3, r3, #30
{
   4fee2:	4604      	mov	r4, r0
	if (!flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
   4fee4:	d416      	bmi.n	4ff14 <cancel_async_locked+0x3c>
		queue_remove_locked(work->queue, work);
   4fee6:	6885      	ldr	r5, [r0, #8]
	if (flag_test_and_clear(&work->flags, K_WORK_QUEUED_BIT)) {
   4fee8:	2102      	movs	r1, #2
   4feea:	300c      	adds	r0, #12
   4feec:	f7ff ffd4 	bl	4fe98 <flag_test_and_clear>
   4fef0:	b180      	cbz	r0, 4ff14 <cancel_async_locked+0x3c>
	return list->head;
   4fef2:	f8d5 2080 	ldr.w	r2, [r5, #128]	; 0x80
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   4fef6:	b16a      	cbz	r2, 4ff14 <cancel_async_locked+0x3c>
   4fef8:	4294      	cmp	r4, r2
   4fefa:	d11d      	bne.n	4ff38 <cancel_async_locked+0x60>
	return node->next;
   4fefc:	6822      	ldr	r2, [r4, #0]
Z_GENLIST_REMOVE(slist, snode)
   4fefe:	b99e      	cbnz	r6, 4ff28 <cancel_async_locked+0x50>
   4ff00:	f8d5 3084 	ldr.w	r3, [r5, #132]	; 0x84
	list->head = node;
   4ff04:	f8c5 2080 	str.w	r2, [r5, #128]	; 0x80
Z_GENLIST_REMOVE(slist, snode)
   4ff08:	429c      	cmp	r4, r3
   4ff0a:	d101      	bne.n	4ff10 <cancel_async_locked+0x38>
	list->tail = node;
   4ff0c:	f8c5 2084 	str.w	r2, [r5, #132]	; 0x84
	parent->next = child;
   4ff10:	2300      	movs	r3, #0
   4ff12:	6023      	str	r3, [r4, #0]
	return *flagp;
   4ff14:	68e3      	ldr	r3, [r4, #12]
	if (ret != 0) {
   4ff16:	f013 000f 	ands.w	r0, r3, #15
	*flagp |= BIT(bit);
   4ff1a:	bf1e      	ittt	ne
   4ff1c:	f043 0302 	orrne.w	r3, r3, #2
   4ff20:	60e3      	strne	r3, [r4, #12]
	return flags_get(&work->flags) & K_WORK_MASK;
   4ff22:	f040 0002 	orrne.w	r0, r0, #2
}
   4ff26:	bd70      	pop	{r4, r5, r6, pc}
   4ff28:	6032      	str	r2, [r6, #0]
Z_GENLIST_REMOVE(slist, snode)
   4ff2a:	f8d5 2084 	ldr.w	r2, [r5, #132]	; 0x84
   4ff2e:	4294      	cmp	r4, r2
	list->tail = node;
   4ff30:	bf08      	it	eq
   4ff32:	f8c5 6084 	streq.w	r6, [r5, #132]	; 0x84
}
   4ff36:	e7eb      	b.n	4ff10 <cancel_async_locked+0x38>
	return node->next;
   4ff38:	4616      	mov	r6, r2
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   4ff3a:	6812      	ldr	r2, [r2, #0]
   4ff3c:	e7db      	b.n	4fef6 <cancel_async_locked+0x1e>

0004ff3e <work_timeout>:
{
   4ff3e:	b573      	push	{r0, r1, r4, r5, r6, lr}
   4ff40:	4604      	mov	r4, r0
   4ff42:	f04f 0320 	mov.w	r3, #32
   4ff46:	f3ef 8511 	mrs	r5, BASEPRI
   4ff4a:	f383 8812 	msr	BASEPRI_MAX, r3
   4ff4e:	f3bf 8f6f 	isb	sy
	struct k_work_q *queue = NULL;
   4ff52:	2300      	movs	r3, #0
	if (flag_test_and_clear(&wp->flags, K_WORK_DELAYED_BIT)) {
   4ff54:	f1a0 0610 	sub.w	r6, r0, #16
   4ff58:	2103      	movs	r1, #3
   4ff5a:	3804      	subs	r0, #4
	struct k_work_q *queue = NULL;
   4ff5c:	9301      	str	r3, [sp, #4]
	if (flag_test_and_clear(&wp->flags, K_WORK_DELAYED_BIT)) {
   4ff5e:	f7ff ff9b 	bl	4fe98 <flag_test_and_clear>
   4ff62:	b128      	cbz	r0, 4ff70 <work_timeout+0x32>
		queue = dw->queue;
   4ff64:	69a3      	ldr	r3, [r4, #24]
   4ff66:	9301      	str	r3, [sp, #4]
		(void)submit_to_queue_locked(wp, &queue);
   4ff68:	a901      	add	r1, sp, #4
   4ff6a:	4630      	mov	r0, r6
   4ff6c:	f7f7 fa48 	bl	47400 <submit_to_queue_locked>
	__asm__ volatile(
   4ff70:	f385 8811 	msr	BASEPRI, r5
   4ff74:	f3bf 8f6f 	isb	sy
}
   4ff78:	b002      	add	sp, #8
   4ff7a:	bd70      	pop	{r4, r5, r6, pc}

0004ff7c <k_work_init>:
{
   4ff7c:	b538      	push	{r3, r4, r5, lr}
   4ff7e:	4604      	mov	r4, r0
   4ff80:	460d      	mov	r5, r1
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
   4ff82:	2210      	movs	r2, #16
   4ff84:	2100      	movs	r1, #0
   4ff86:	f7fa ff83 	bl	4ae90 <memset>
   4ff8a:	6065      	str	r5, [r4, #4]
}
   4ff8c:	bd38      	pop	{r3, r4, r5, pc}

0004ff8e <k_work_busy_get>:
	__asm__ volatile(
   4ff8e:	f04f 0220 	mov.w	r2, #32
   4ff92:	f3ef 8311 	mrs	r3, BASEPRI
   4ff96:	f382 8812 	msr	BASEPRI_MAX, r2
   4ff9a:	f3bf 8f6f 	isb	sy
	return flags_get(&work->flags) & K_WORK_MASK;
   4ff9e:	68c0      	ldr	r0, [r0, #12]
   4ffa0:	f000 000f 	and.w	r0, r0, #15
	__asm__ volatile(
   4ffa4:	f383 8811 	msr	BASEPRI, r3
   4ffa8:	f3bf 8f6f 	isb	sy
}
   4ffac:	4770      	bx	lr

0004ffae <z_work_submit_to_queue>:
{
   4ffae:	b513      	push	{r0, r1, r4, lr}
   4ffb0:	9001      	str	r0, [sp, #4]
   4ffb2:	4608      	mov	r0, r1
	__asm__ volatile(
   4ffb4:	f04f 0320 	mov.w	r3, #32
   4ffb8:	f3ef 8411 	mrs	r4, BASEPRI
   4ffbc:	f383 8812 	msr	BASEPRI_MAX, r3
   4ffc0:	f3bf 8f6f 	isb	sy
	int ret = submit_to_queue_locked(work, &queue);
   4ffc4:	a901      	add	r1, sp, #4
   4ffc6:	f7f7 fa1b 	bl	47400 <submit_to_queue_locked>
	__asm__ volatile(
   4ffca:	f384 8811 	msr	BASEPRI, r4
   4ffce:	f3bf 8f6f 	isb	sy
}
   4ffd2:	b002      	add	sp, #8
   4ffd4:	bd10      	pop	{r4, pc}

0004ffd6 <k_work_submit_to_queue>:
{
   4ffd6:	b510      	push	{r4, lr}
	int ret = z_work_submit_to_queue(queue, work);
   4ffd8:	f7ff ffe9 	bl	4ffae <z_work_submit_to_queue>
	if (ret > 0) {
   4ffdc:	1e04      	subs	r4, r0, #0
   4ffde:	dd09      	ble.n	4fff4 <k_work_submit_to_queue+0x1e>
	__asm__ volatile(
   4ffe0:	f04f 0320 	mov.w	r3, #32
   4ffe4:	f3ef 8011 	mrs	r0, BASEPRI
   4ffe8:	f383 8812 	msr	BASEPRI_MAX, r3
   4ffec:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
   4fff0:	f000 f927 	bl	50242 <z_reschedule_irqlock>
}
   4fff4:	4620      	mov	r0, r4
   4fff6:	bd10      	pop	{r4, pc}

0004fff8 <k_work_queue_init>:
{
   4fff8:	b508      	push	{r3, lr}
	*queue = (struct k_work_q) {
   4fffa:	22a0      	movs	r2, #160	; 0xa0
   4fffc:	2100      	movs	r1, #0
   4fffe:	f7fa ff47 	bl	4ae90 <memset>
}
   50002:	bd08      	pop	{r3, pc}

00050004 <k_work_init_delayable>:
{
   50004:	b538      	push	{r3, r4, r5, lr}
	*dwork = (struct k_work_delayable){
   50006:	2230      	movs	r2, #48	; 0x30
{
   50008:	4604      	mov	r4, r0
   5000a:	460d      	mov	r5, r1
	*dwork = (struct k_work_delayable){
   5000c:	2100      	movs	r1, #0
   5000e:	f7fa ff3f 	bl	4ae90 <memset>
   50012:	f44f 7380 	mov.w	r3, #256	; 0x100
   50016:	6065      	str	r5, [r4, #4]
   50018:	60e3      	str	r3, [r4, #12]
}
   5001a:	bd38      	pop	{r3, r4, r5, pc}

0005001c <k_work_delayable_busy_get>:
int k_work_delayable_busy_get(const struct k_work_delayable *dwork)
   5001c:	f7ff bfb7 	b.w	4ff8e <k_work_busy_get>

00050020 <k_work_cancel_delayable>:

	return ret;
}

int k_work_cancel_delayable(struct k_work_delayable *dwork)
{
   50020:	b538      	push	{r3, r4, r5, lr}
   50022:	4604      	mov	r4, r0
   50024:	f04f 0320 	mov.w	r3, #32
   50028:	f3ef 8511 	mrs	r5, BASEPRI
   5002c:	f383 8812 	msr	BASEPRI_MAX, r3
   50030:	f3bf 8f6f 	isb	sy
	(void)unschedule_locked(dwork);
   50034:	f7ff ff3b 	bl	4feae <unschedule_locked>
	return cancel_async_locked(&dwork->work);
   50038:	4620      	mov	r0, r4
   5003a:	f7ff ff4d 	bl	4fed8 <cancel_async_locked>
	__asm__ volatile(
   5003e:	f385 8811 	msr	BASEPRI, r5
   50042:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&lock, key);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, cancel_delayable, dwork, ret);

	return ret;
}
   50046:	bd38      	pop	{r3, r4, r5, pc}

00050048 <k_work_cancel_delayable_sync>:

bool k_work_cancel_delayable_sync(struct k_work_delayable *dwork,
				  struct k_work_sync *sync)
{
   50048:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   5004a:	4604      	mov	r4, r0
   5004c:	460d      	mov	r5, r1
	__asm__ volatile(
   5004e:	f04f 0320 	mov.w	r3, #32
   50052:	f3ef 8611 	mrs	r6, BASEPRI
   50056:	f383 8812 	msr	BASEPRI_MAX, r3
   5005a:	f3bf 8f6f 	isb	sy
	return *flagp;
   5005e:	68c3      	ldr	r3, [r0, #12]
   50060:	f003 030f 	and.w	r3, r3, #15

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work, cancel_delayable_sync, dwork, sync);

	struct z_work_canceller *canceller = &sync->canceller;
	k_spinlock_key_t key = k_spin_lock(&lock);
	bool pending = (work_delayable_busy_get_locked(dwork) != 0U);
   50064:	2b00      	cmp	r3, #0
   50066:	bf14      	ite	ne
   50068:	2701      	movne	r7, #1
   5006a:	2700      	moveq	r7, #0
	bool need_wait = false;

	if (pending) {
   5006c:	d105      	bne.n	5007a <k_work_cancel_delayable_sync+0x32>
	__asm__ volatile(
   5006e:	f386 8811 	msr	BASEPRI, r6
   50072:	f3bf 8f6f 	isb	sy
		k_sem_take(&canceller->sem, K_FOREVER);
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, cancel_delayable_sync, dwork, sync, pending);
	return pending;
}
   50076:	4638      	mov	r0, r7
   50078:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	(void)unschedule_locked(dwork);
   5007a:	f7ff ff18 	bl	4feae <unschedule_locked>
	return cancel_async_locked(&dwork->work);
   5007e:	4620      	mov	r0, r4
   50080:	f7ff ff2a 	bl	4fed8 <cancel_async_locked>
		need_wait = cancel_sync_locked(&dwork->work, canceller);
   50084:	4629      	mov	r1, r5
   50086:	4620      	mov	r0, r4
   50088:	f7f7 f99c 	bl	473c4 <cancel_sync_locked>
   5008c:	f386 8811 	msr	BASEPRI, r6
   50090:	f3bf 8f6f 	isb	sy
	if (need_wait) {
   50094:	2800      	cmp	r0, #0
   50096:	d0ee      	beq.n	50076 <k_work_cancel_delayable_sync+0x2e>
	return z_impl_k_sem_take(sem, timeout);
   50098:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   5009c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   500a0:	f105 0008 	add.w	r0, r5, #8
   500a4:	f7f7 f88e 	bl	471c4 <z_impl_k_sem_take>
   500a8:	e7e5      	b.n	50076 <k_work_cancel_delayable_sync+0x2e>

000500aa <sys_dlist_remove>:
	sys_dnode_t *const next = node->next;
   500aa:	e9d0 3200 	ldrd	r3, r2, [r0]
	prev->next = next;
   500ae:	6013      	str	r3, [r2, #0]
	next->prev = prev;
   500b0:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   500b2:	2300      	movs	r3, #0
	node->prev = NULL;
   500b4:	e9c0 3300 	strd	r3, r3, [r0]
}
   500b8:	4770      	bx	lr

000500ba <unpend_thread_no_timeout>:
{
   500ba:	b508      	push	{r3, lr}
	sys_dlist_remove(&thread->base.qnode_dlist);
   500bc:	f7ff fff5 	bl	500aa <sys_dlist_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   500c0:	7b43      	ldrb	r3, [r0, #13]
   500c2:	f023 0302 	bic.w	r3, r3, #2
   500c6:	7343      	strb	r3, [r0, #13]
	thread->base.pended_on = NULL;
   500c8:	2300      	movs	r3, #0
   500ca:	6083      	str	r3, [r0, #8]
}
   500cc:	bd08      	pop	{r3, pc}

000500ce <z_sched_prio_cmp>:
	int32_t b1 = thread_1->base.prio;
   500ce:	f990 300e 	ldrsb.w	r3, [r0, #14]
	int32_t b2 = thread_2->base.prio;
   500d2:	f991 000e 	ldrsb.w	r0, [r1, #14]
	if (b1 != b2) {
   500d6:	4283      	cmp	r3, r0
		return b2 - b1;
   500d8:	bf14      	ite	ne
   500da:	1ac0      	subne	r0, r0, r3
	return 0;
   500dc:	2000      	moveq	r0, #0
}
   500de:	4770      	bx	lr

000500e0 <z_thread_timeout>:
{
   500e0:	b510      	push	{r4, lr}
   500e2:	4601      	mov	r1, r0
	__asm__ volatile(
   500e4:	f04f 0320 	mov.w	r3, #32
   500e8:	f3ef 8411 	mrs	r4, BASEPRI
   500ec:	f383 8812 	msr	BASEPRI_MAX, r3
   500f0:	f3bf 8f6f 	isb	sy
		if (!killed) {
   500f4:	f810 3c0b 	ldrb.w	r3, [r0, #-11]
   500f8:	f013 0f28 	tst.w	r3, #40	; 0x28
   500fc:	d10d      	bne.n	5011a <z_thread_timeout+0x3a>
			if (thread->base.pended_on != NULL) {
   500fe:	f851 3c10 	ldr.w	r3, [r1, #-16]
	struct k_thread *thread = CONTAINER_OF(timeout,
   50102:	3818      	subs	r0, #24
			if (thread->base.pended_on != NULL) {
   50104:	b10b      	cbz	r3, 5010a <z_thread_timeout+0x2a>
				unpend_thread_no_timeout(thread);
   50106:	f7ff ffd8 	bl	500ba <unpend_thread_no_timeout>
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
   5010a:	f811 3c0b 	ldrb.w	r3, [r1, #-11]
   5010e:	f023 0314 	bic.w	r3, r3, #20
   50112:	f801 3c0b 	strb.w	r3, [r1, #-11]
			ready_thread(thread);
   50116:	f7f7 fadb 	bl	476d0 <ready_thread>
	__asm__ volatile(
   5011a:	f384 8811 	msr	BASEPRI, r4
   5011e:	f3bf 8f6f 	isb	sy
}
   50122:	bd10      	pop	{r4, pc}

00050124 <add_to_waitq_locked>:
{
   50124:	b538      	push	{r3, r4, r5, lr}
   50126:	4604      	mov	r4, r0
   50128:	460d      	mov	r5, r1
	unready_thread(thread);
   5012a:	f7f7 fb05 	bl	47738 <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
   5012e:	7b63      	ldrb	r3, [r4, #13]
   50130:	f043 0302 	orr.w	r3, r3, #2
   50134:	7363      	strb	r3, [r4, #13]
	if (wait_q != NULL) {
   50136:	b1e5      	cbz	r5, 50172 <add_to_waitq_locked+0x4e>
		thread->base.pended_on = wait_q;
   50138:	60a5      	str	r5, [r4, #8]
	return list->head == list;
   5013a:	682b      	ldr	r3, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   5013c:	429d      	cmp	r5, r3
   5013e:	d109      	bne.n	50154 <add_to_waitq_locked+0x30>
	sys_dnode_t *const tail = list->tail;
   50140:	686b      	ldr	r3, [r5, #4]
	node->prev = tail;
   50142:	e9c4 5300 	strd	r5, r3, [r4]
	tail->next = node;
   50146:	601c      	str	r4, [r3, #0]
	list->tail = node;
   50148:	606c      	str	r4, [r5, #4]
}
   5014a:	e012      	b.n	50172 <add_to_waitq_locked+0x4e>
	return (node == list->tail) ? NULL : node->next;
   5014c:	686a      	ldr	r2, [r5, #4]
   5014e:	4293      	cmp	r3, r2
   50150:	d0f6      	beq.n	50140 <add_to_waitq_locked+0x1c>
   50152:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   50154:	2b00      	cmp	r3, #0
   50156:	d0f3      	beq.n	50140 <add_to_waitq_locked+0x1c>
	int32_t b1 = thread_1->base.prio;
   50158:	f994 200e 	ldrsb.w	r2, [r4, #14]
	int32_t b2 = thread_2->base.prio;
   5015c:	f993 100e 	ldrsb.w	r1, [r3, #14]
	if (b1 != b2) {
   50160:	428a      	cmp	r2, r1
   50162:	d0f3      	beq.n	5014c <add_to_waitq_locked+0x28>
		if (z_sched_prio_cmp(thread, t) > 0) {
   50164:	4291      	cmp	r1, r2
   50166:	ddf1      	ble.n	5014c <add_to_waitq_locked+0x28>
	sys_dnode_t *const prev = successor->prev;
   50168:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   5016a:	e9c4 3200 	strd	r3, r2, [r4]
	prev->next = node;
   5016e:	6014      	str	r4, [r2, #0]
	successor->prev = node;
   50170:	605c      	str	r4, [r3, #4]
}
   50172:	bd38      	pop	{r3, r4, r5, pc}

00050174 <z_ready_thread>:
{
   50174:	b510      	push	{r4, lr}
	__asm__ volatile(
   50176:	f04f 0320 	mov.w	r3, #32
   5017a:	f3ef 8411 	mrs	r4, BASEPRI
   5017e:	f383 8812 	msr	BASEPRI_MAX, r3
   50182:	f3bf 8f6f 	isb	sy
			ready_thread(thread);
   50186:	f7f7 faa3 	bl	476d0 <ready_thread>
	__asm__ volatile(
   5018a:	f384 8811 	msr	BASEPRI, r4
   5018e:	f3bf 8f6f 	isb	sy
}
   50192:	bd10      	pop	{r4, pc}

00050194 <z_unpend_thread_no_timeout>:
{
   50194:	b508      	push	{r3, lr}
	__asm__ volatile(
   50196:	f04f 0320 	mov.w	r3, #32
   5019a:	f3ef 8111 	mrs	r1, BASEPRI
   5019e:	f383 8812 	msr	BASEPRI_MAX, r3
   501a2:	f3bf 8f6f 	isb	sy
		unpend_thread_no_timeout(thread);
   501a6:	f7ff ff88 	bl	500ba <unpend_thread_no_timeout>
	__asm__ volatile(
   501aa:	f381 8811 	msr	BASEPRI, r1
   501ae:	f3bf 8f6f 	isb	sy
}
   501b2:	bd08      	pop	{r3, pc}

000501b4 <z_unpend1_no_timeout>:
{
   501b4:	b508      	push	{r3, lr}
   501b6:	4603      	mov	r3, r0
	__asm__ volatile(
   501b8:	f04f 0220 	mov.w	r2, #32
   501bc:	f3ef 8111 	mrs	r1, BASEPRI
   501c0:	f382 8812 	msr	BASEPRI_MAX, r2
   501c4:	f3bf 8f6f 	isb	sy
	return list->head == list;
   501c8:	6800      	ldr	r0, [r0, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   501ca:	4283      	cmp	r3, r0
   501cc:	d007      	beq.n	501de <z_unpend1_no_timeout+0x2a>
		if (thread != NULL) {
   501ce:	b108      	cbz	r0, 501d4 <z_unpend1_no_timeout+0x20>
			unpend_thread_no_timeout(thread);
   501d0:	f7ff ff73 	bl	500ba <unpend_thread_no_timeout>
	__asm__ volatile(
   501d4:	f381 8811 	msr	BASEPRI, r1
   501d8:	f3bf 8f6f 	isb	sy
}
   501dc:	bd08      	pop	{r3, pc}
   501de:	2000      	movs	r0, #0
   501e0:	e7f8      	b.n	501d4 <z_unpend1_no_timeout+0x20>

000501e2 <z_unpend_first_thread>:
{
   501e2:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   501e4:	f04f 0320 	mov.w	r3, #32
   501e8:	f3ef 8511 	mrs	r5, BASEPRI
   501ec:	f383 8812 	msr	BASEPRI_MAX, r3
   501f0:	f3bf 8f6f 	isb	sy
	return list->head == list;
   501f4:	6804      	ldr	r4, [r0, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   501f6:	42a0      	cmp	r0, r4
   501f8:	d00d      	beq.n	50216 <z_unpend_first_thread+0x34>
		if (thread != NULL) {
   501fa:	b134      	cbz	r4, 5020a <z_unpend_first_thread+0x28>
			unpend_thread_no_timeout(thread);
   501fc:	4620      	mov	r0, r4
   501fe:	f7ff ff5c 	bl	500ba <unpend_thread_no_timeout>
   50202:	f104 0018 	add.w	r0, r4, #24
   50206:	f000 f865 	bl	502d4 <z_abort_timeout>
	__asm__ volatile(
   5020a:	f385 8811 	msr	BASEPRI, r5
   5020e:	f3bf 8f6f 	isb	sy
}
   50212:	4620      	mov	r0, r4
   50214:	bd38      	pop	{r3, r4, r5, pc}
   50216:	2400      	movs	r4, #0
   50218:	e7f7      	b.n	5020a <z_unpend_first_thread+0x28>

0005021a <z_unpend_thread>:
{
   5021a:	b510      	push	{r4, lr}
	__asm__ volatile(
   5021c:	f04f 0320 	mov.w	r3, #32
   50220:	f3ef 8411 	mrs	r4, BASEPRI
   50224:	f383 8812 	msr	BASEPRI_MAX, r3
   50228:	f3bf 8f6f 	isb	sy
		unpend_thread_no_timeout(thread);
   5022c:	f7ff ff45 	bl	500ba <unpend_thread_no_timeout>
	__asm__ volatile(
   50230:	f384 8811 	msr	BASEPRI, r4
   50234:	f3bf 8f6f 	isb	sy
}
   50238:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   5023c:	3018      	adds	r0, #24
   5023e:	f000 b849 	b.w	502d4 <z_abort_timeout>

00050242 <z_reschedule_irqlock>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
   50242:	4603      	mov	r3, r0
   50244:	b920      	cbnz	r0, 50250 <z_reschedule_irqlock+0xe>
   50246:	f3ef 8205 	mrs	r2, IPSR
   5024a:	b90a      	cbnz	r2, 50250 <z_reschedule_irqlock+0xe>
	ret = arch_swap(key);
   5024c:	f7dc be30 	b.w	2ceb0 <arch_swap>
   50250:	f383 8811 	msr	BASEPRI, r3
   50254:	f3bf 8f6f 	isb	sy
}
   50258:	4770      	bx	lr

0005025a <z_reschedule_unlocked>:
	__asm__ volatile(
   5025a:	f04f 0320 	mov.w	r3, #32
   5025e:	f3ef 8011 	mrs	r0, BASEPRI
   50262:	f383 8812 	msr	BASEPRI_MAX, r3
   50266:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
   5026a:	f7ff bfea 	b.w	50242 <z_reschedule_irqlock>

0005026e <z_unpend_all>:
{
   5026e:	b538      	push	{r3, r4, r5, lr}
   50270:	4605      	mov	r5, r0
	int need_sched = 0;
   50272:	2000      	movs	r0, #0
	return list->head == list;
   50274:	682c      	ldr	r4, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   50276:	42a5      	cmp	r5, r4
   50278:	d000      	beq.n	5027c <z_unpend_all+0xe>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
   5027a:	b904      	cbnz	r4, 5027e <z_unpend_all+0x10>
}
   5027c:	bd38      	pop	{r3, r4, r5, pc}
		z_unpend_thread(thread);
   5027e:	4620      	mov	r0, r4
   50280:	f7ff ffcb 	bl	5021a <z_unpend_thread>
		z_ready_thread(thread);
   50284:	4620      	mov	r0, r4
   50286:	f7ff ff75 	bl	50174 <z_ready_thread>
		need_sched = 1;
   5028a:	2001      	movs	r0, #1
   5028c:	e7f2      	b.n	50274 <z_unpend_all+0x6>

0005028e <z_sched_wake>:
{
   5028e:	b538      	push	{r3, r4, r5, lr}
   50290:	f04f 0320 	mov.w	r3, #32
   50294:	f3ef 8511 	mrs	r5, BASEPRI
   50298:	f383 8812 	msr	BASEPRI_MAX, r3
   5029c:	f3bf 8f6f 	isb	sy
	return list->head == list;
   502a0:	6804      	ldr	r4, [r0, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   502a2:	42a0      	cmp	r0, r4
   502a4:	d012      	beq.n	502cc <z_sched_wake+0x3e>
		if (thread != NULL) {
   502a6:	b19c      	cbz	r4, 502d0 <z_sched_wake+0x42>
   502a8:	67e1      	str	r1, [r4, #124]	; 0x7c
   502aa:	6162      	str	r2, [r4, #20]
			unpend_thread_no_timeout(thread);
   502ac:	4620      	mov	r0, r4
   502ae:	f7ff ff04 	bl	500ba <unpend_thread_no_timeout>
   502b2:	f104 0018 	add.w	r0, r4, #24
   502b6:	f000 f80d 	bl	502d4 <z_abort_timeout>
			ready_thread(thread);
   502ba:	4620      	mov	r0, r4
   502bc:	f7f7 fa08 	bl	476d0 <ready_thread>
			ret = true;
   502c0:	2001      	movs	r0, #1
	__asm__ volatile(
   502c2:	f385 8811 	msr	BASEPRI, r5
   502c6:	f3bf 8f6f 	isb	sy
}
   502ca:	bd38      	pop	{r3, r4, r5, pc}
	bool ret = false;
   502cc:	2000      	movs	r0, #0
   502ce:	e7f8      	b.n	502c2 <z_sched_wake+0x34>
   502d0:	4620      	mov	r0, r4
   502d2:	e7f6      	b.n	502c2 <z_sched_wake+0x34>

000502d4 <z_abort_timeout>:
{
   502d4:	b510      	push	{r4, lr}
	__asm__ volatile(
   502d6:	f04f 0220 	mov.w	r2, #32
   502da:	f3ef 8411 	mrs	r4, BASEPRI
   502de:	f382 8812 	msr	BASEPRI_MAX, r2
   502e2:	f3bf 8f6f 	isb	sy
		if (sys_dnode_is_linked(&to->node)) {
   502e6:	6803      	ldr	r3, [r0, #0]
   502e8:	b13b      	cbz	r3, 502fa <z_abort_timeout+0x26>
			remove_timeout(to);
   502ea:	f7f7 fd2f 	bl	47d4c <remove_timeout>
			ret = 0;
   502ee:	2000      	movs	r0, #0
	__asm__ volatile(
   502f0:	f384 8811 	msr	BASEPRI, r4
   502f4:	f3bf 8f6f 	isb	sy
}
   502f8:	bd10      	pop	{r4, pc}
	int ret = -EINVAL;
   502fa:	f06f 0015 	mvn.w	r0, #21
   502fe:	e7f7      	b.n	502f0 <z_abort_timeout+0x1c>

00050300 <z_get_next_timeout_expiry>:
{
   50300:	b510      	push	{r4, lr}
	__asm__ volatile(
   50302:	f04f 0320 	mov.w	r3, #32
   50306:	f3ef 8411 	mrs	r4, BASEPRI
   5030a:	f383 8812 	msr	BASEPRI_MAX, r3
   5030e:	f3bf 8f6f 	isb	sy
		ret = next_timeout();
   50312:	f7f7 fcf3 	bl	47cfc <next_timeout>
	__asm__ volatile(
   50316:	f384 8811 	msr	BASEPRI, r4
   5031a:	f3bf 8f6f 	isb	sy
}
   5031e:	bd10      	pop	{r4, pc}

00050320 <z_set_timeout_expiry>:
{
   50320:	b570      	push	{r4, r5, r6, lr}
   50322:	4604      	mov	r4, r0
   50324:	460d      	mov	r5, r1
	__asm__ volatile(
   50326:	f04f 0320 	mov.w	r3, #32
   5032a:	f3ef 8611 	mrs	r6, BASEPRI
   5032e:	f383 8812 	msr	BASEPRI_MAX, r3
   50332:	f3bf 8f6f 	isb	sy
		int next_to = next_timeout();
   50336:	f7f7 fce1 	bl	47cfc <next_timeout>
			      || (ticks <= next_to);
   5033a:	2801      	cmp	r0, #1
   5033c:	dd07      	ble.n	5034e <z_set_timeout_expiry+0x2e>
   5033e:	42a0      	cmp	r0, r4
   50340:	db05      	blt.n	5034e <z_set_timeout_expiry+0x2e>
			sys_clock_set_timeout(MIN(ticks, next_to), is_idle);
   50342:	42a0      	cmp	r0, r4
   50344:	4629      	mov	r1, r5
   50346:	bfa8      	it	ge
   50348:	4620      	movge	r0, r4
   5034a:	f7f4 fc15 	bl	44b78 <sys_clock_set_timeout>
	__asm__ volatile(
   5034e:	f386 8811 	msr	BASEPRI, r6
   50352:	f3bf 8f6f 	isb	sy
}
   50356:	bd70      	pop	{r4, r5, r6, pc}

00050358 <sys_clock_tick_get_32>:

uint32_t sys_clock_tick_get_32(void)
{
   50358:	b508      	push	{r3, lr}
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)sys_clock_tick_get();
   5035a:	f7f7 fdeb 	bl	47f34 <sys_clock_tick_get>
#else
	return (uint32_t)curr_tick;
#endif
}
   5035e:	bd08      	pop	{r3, pc}

00050360 <z_impl_k_uptime_ticks>:

int64_t z_impl_k_uptime_ticks(void)
{
	return sys_clock_tick_get();
   50360:	f7f7 bde8 	b.w	47f34 <sys_clock_tick_get>

00050364 <z_impl_k_busy_wait>:
#endif

void z_impl_k_busy_wait(uint32_t usec_to_wait)
{
	SYS_PORT_TRACING_FUNC_ENTER(k_thread, busy_wait, usec_to_wait);
	if (usec_to_wait == 0U) {
   50364:	b108      	cbz	r0, 5036a <z_impl_k_busy_wait+0x6>
		if ((current_cycles - start_cycles) >= cycles_to_wait) {
			break;
		}
	}
#else
	arch_busy_wait(usec_to_wait);
   50366:	f7dd b875 	b.w	2d454 <arch_busy_wait>
#endif /* CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT */
	SYS_PORT_TRACING_FUNC_EXIT(k_thread, busy_wait, usec_to_wait);
}
   5036a:	4770      	bx	lr

0005036c <sys_clock_timeout_end_calc>:
 */
uint64_t sys_clock_timeout_end_calc(k_timeout_t timeout)
{
	k_ticks_t dt;

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   5036c:	f1b1 3fff 	cmp.w	r1, #4294967295	; 0xffffffff
   50370:	bf08      	it	eq
   50372:	f1b0 3fff 	cmpeq.w	r0, #4294967295	; 0xffffffff
{
   50376:	b538      	push	{r3, r4, r5, lr}
   50378:	460c      	mov	r4, r1
   5037a:	4605      	mov	r5, r0
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   5037c:	d014      	beq.n	503a8 <sys_clock_timeout_end_calc+0x3c>
		return UINT64_MAX;
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   5037e:	4308      	orrs	r0, r1
   50380:	d103      	bne.n	5038a <sys_clock_timeout_end_calc+0x1e>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
			return Z_TICK_ABS(dt);
		}
		return sys_clock_tick_get() + MAX(1, dt);
	}
}
   50382:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		return sys_clock_tick_get();
   50386:	f7f7 bdd5 	b.w	47f34 <sys_clock_tick_get>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
   5038a:	f06f 0001 	mvn.w	r0, #1
   5038e:	1b40      	subs	r0, r0, r5
   50390:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   50394:	eb63 0101 	sbc.w	r1, r3, r1
   50398:	2900      	cmp	r1, #0
   5039a:	da04      	bge.n	503a6 <sys_clock_timeout_end_calc+0x3a>
		return sys_clock_tick_get() + MAX(1, dt);
   5039c:	f7f7 fdca 	bl	47f34 <sys_clock_tick_get>
   503a0:	1940      	adds	r0, r0, r5
   503a2:	eb41 0104 	adc.w	r1, r1, r4
}
   503a6:	bd38      	pop	{r3, r4, r5, pc}
		return UINT64_MAX;
   503a8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   503ac:	4601      	mov	r1, r0
   503ae:	e7fa      	b.n	503a6 <sys_clock_timeout_end_calc+0x3a>

000503b0 <z_impl_k_timer_stop>:
}
#include <syscalls/k_timer_start_mrsh.c>
#endif

void z_impl_k_timer_stop(struct k_timer *timer)
{
   503b0:	b510      	push	{r4, lr}
   503b2:	4604      	mov	r4, r0
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, stop, timer);

	bool inactive = (z_abort_timeout(&timer->timeout) != 0);
   503b4:	f7ff ff8e 	bl	502d4 <z_abort_timeout>

	if (inactive) {
   503b8:	b9b0      	cbnz	r0, 503e8 <z_impl_k_timer_stop+0x38>
		return;
	}

	if (timer->stop_fn != NULL) {
   503ba:	6a63      	ldr	r3, [r4, #36]	; 0x24
   503bc:	b10b      	cbz	r3, 503c2 <z_impl_k_timer_stop+0x12>
		timer->stop_fn(timer);
   503be:	4620      	mov	r0, r4
   503c0:	4798      	blx	r3
	}

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		struct k_thread *pending_thread = z_unpend1_no_timeout(&timer->wait_q);
   503c2:	f104 0018 	add.w	r0, r4, #24
   503c6:	f7ff fef5 	bl	501b4 <z_unpend1_no_timeout>

		if (pending_thread != NULL) {
   503ca:	b168      	cbz	r0, 503e8 <z_impl_k_timer_stop+0x38>
			z_ready_thread(pending_thread);
   503cc:	f7ff fed2 	bl	50174 <z_ready_thread>
	__asm__ volatile(
   503d0:	f04f 0320 	mov.w	r3, #32
   503d4:	f3ef 8011 	mrs	r0, BASEPRI
   503d8:	f383 8812 	msr	BASEPRI_MAX, r3
   503dc:	f3bf 8f6f 	isb	sy
			z_reschedule_unlocked();
		}
	}
}
   503e0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   503e4:	f7ff bf2d 	b.w	50242 <z_reschedule_irqlock>
   503e8:	bd10      	pop	{r4, pc}

000503ea <add_event>:
{
   503ea:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   503ec:	460d      	mov	r5, r1
	return sys_dlist_is_empty(list) ? NULL : list->tail;
   503ee:	e9d0 1300 	ldrd	r1, r3, [r0]
   503f2:	4288      	cmp	r0, r1
   503f4:	4604      	mov	r4, r0
   503f6:	d105      	bne.n	50404 <add_event+0x1a>
	sys_dnode_t *const tail = list->tail;
   503f8:	6863      	ldr	r3, [r4, #4]
	node->prev = tail;
   503fa:	e9c5 4300 	strd	r4, r3, [r5]
	tail->next = node;
   503fe:	601d      	str	r5, [r3, #0]
	list->tail = node;
   50400:	6065      	str	r5, [r4, #4]
   50402:	e01d      	b.n	50440 <add_event+0x56>
	if ((pending == NULL) ||
   50404:	2b00      	cmp	r3, #0
   50406:	d0f7      	beq.n	503f8 <add_event+0xe>
		(z_sched_prio_cmp(poller_thread(pending->poller),
   50408:	6898      	ldr	r0, [r3, #8]
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
   5040a:	b100      	cbz	r0, 5040e <add_event+0x24>
   5040c:	3860      	subs	r0, #96	; 0x60
   5040e:	f1a2 0760 	sub.w	r7, r2, #96	; 0x60
		(z_sched_prio_cmp(poller_thread(pending->poller),
   50412:	4639      	mov	r1, r7
   50414:	f7ff fe5b 	bl	500ce <z_sched_prio_cmp>
	if ((pending == NULL) ||
   50418:	2800      	cmp	r0, #0
   5041a:	dced      	bgt.n	503f8 <add_event+0xe>
	return list->head == list;
   5041c:	6826      	ldr	r6, [r4, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   5041e:	42b4      	cmp	r4, r6
   50420:	d0ea      	beq.n	503f8 <add_event+0xe>
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
   50422:	2e00      	cmp	r6, #0
   50424:	d0e8      	beq.n	503f8 <add_event+0xe>
		if (z_sched_prio_cmp(poller_thread(poller),
   50426:	68b1      	ldr	r1, [r6, #8]
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
   50428:	b101      	cbz	r1, 5042c <add_event+0x42>
   5042a:	3960      	subs	r1, #96	; 0x60
		if (z_sched_prio_cmp(poller_thread(poller),
   5042c:	4638      	mov	r0, r7
   5042e:	f7ff fe4e 	bl	500ce <z_sched_prio_cmp>
   50432:	2800      	cmp	r0, #0
   50434:	dd05      	ble.n	50442 <add_event+0x58>
	sys_dnode_t *const prev = successor->prev;
   50436:	6873      	ldr	r3, [r6, #4]
	node->next = successor;
   50438:	e9c5 6300 	strd	r6, r3, [r5]
	prev->next = node;
   5043c:	601d      	str	r5, [r3, #0]
	successor->prev = node;
   5043e:	6075      	str	r5, [r6, #4]
}
   50440:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (node == list->tail) ? NULL : node->next;
   50442:	6863      	ldr	r3, [r4, #4]
   50444:	429e      	cmp	r6, r3
   50446:	d0d7      	beq.n	503f8 <add_event+0xe>
   50448:	6836      	ldr	r6, [r6, #0]
   5044a:	e7ea      	b.n	50422 <add_event+0x38>

0005044c <register_events>:
{
   5044c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	for (int ii = 0; ii < num_events; ii++) {
   50450:	2500      	movs	r5, #0
{
   50452:	468b      	mov	fp, r1
   50454:	4614      	mov	r4, r2
   50456:	461f      	mov	r7, r3
   50458:	4682      	mov	sl, r0
	int events_registered = 0;
   5045a:	462e      	mov	r6, r5
	event->poller = NULL;
   5045c:	46a8      	mov	r8, r5
	for (int ii = 0; ii < num_events; ii++) {
   5045e:	455d      	cmp	r5, fp
   50460:	db02      	blt.n	50468 <register_events+0x1c>
}
   50462:	4630      	mov	r0, r6
   50464:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   50468:	f04f 0320 	mov.w	r3, #32
   5046c:	f3ef 8911 	mrs	r9, BASEPRI
   50470:	f383 8812 	msr	BASEPRI_MAX, r3
   50474:	f3bf 8f6f 	isb	sy
	switch (event->type) {
   50478:	f89a 300d 	ldrb.w	r3, [sl, #13]
   5047c:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   50480:	3b01      	subs	r3, #1
   50482:	2b07      	cmp	r3, #7
   50484:	d80f      	bhi.n	504a6 <register_events+0x5a>
   50486:	e8df f003 	tbb	[pc, r3]
   5048a:	041e      	.short	0x041e
   5048c:	0e0e0a0e 	.word	0x0e0e0a0e
   50490:	250e      	.short	0x250e
		if (k_sem_count_get(event->sem) > 0U) {
   50492:	f8da 3010 	ldr.w	r3, [sl, #16]
   50496:	689b      	ldr	r3, [r3, #8]
   50498:	b12b      	cbz	r3, 504a6 <register_events+0x5a>
			*state = K_POLL_STATE_SEM_AVAILABLE;
   5049a:	2302      	movs	r3, #2
   5049c:	e020      	b.n	504e0 <register_events+0x94>
		if (!k_queue_is_empty(event->queue)) {
   5049e:	f8da 3010 	ldr.w	r3, [sl, #16]
   504a2:	681b      	ldr	r3, [r3, #0]
   504a4:	bb8b      	cbnz	r3, 5050a <register_events+0xbe>
		} else if (!just_check && poller->is_polling) {
   504a6:	bb47      	cbnz	r7, 504fa <register_events+0xae>
   504a8:	7823      	ldrb	r3, [r4, #0]
   504aa:	b333      	cbz	r3, 504fa <register_events+0xae>
	switch (event->type) {
   504ac:	f89a 300d 	ldrb.w	r3, [sl, #13]
   504b0:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   504b4:	3b01      	subs	r3, #1
   504b6:	2b07      	cmp	r3, #7
   504b8:	d830      	bhi.n	5051c <register_events+0xd0>
   504ba:	e8df f003 	tbb	[pc, r3]
   504be:	2833      	.short	0x2833
   504c0:	2f2f282f 	.word	0x2f2f282f
   504c4:	382f      	.short	0x382f
		if (event->signal->signaled != 0U) {
   504c6:	f8da 3010 	ldr.w	r3, [sl, #16]
   504ca:	689b      	ldr	r3, [r3, #8]
   504cc:	2b00      	cmp	r3, #0
   504ce:	d0ea      	beq.n	504a6 <register_events+0x5a>
			*state = K_POLL_STATE_SIGNALED;
   504d0:	2301      	movs	r3, #1
   504d2:	e005      	b.n	504e0 <register_events+0x94>
		if (event->msgq->used_msgs > 0) {
   504d4:	f8da 3010 	ldr.w	r3, [sl, #16]
   504d8:	6a1b      	ldr	r3, [r3, #32]
   504da:	2b00      	cmp	r3, #0
   504dc:	d0e3      	beq.n	504a6 <register_events+0x5a>
			*state = K_POLL_STATE_MSGQ_DATA_AVAILABLE;
   504de:	2310      	movs	r3, #16
	event->state |= state;
   504e0:	f8da 200c 	ldr.w	r2, [sl, #12]
	event->poller = NULL;
   504e4:	f8ca 8008 	str.w	r8, [sl, #8]
	event->state |= state;
   504e8:	f3c2 3186 	ubfx	r1, r2, #14, #7
   504ec:	430b      	orrs	r3, r1
   504ee:	f363 3294 	bfi	r2, r3, #14, #7
   504f2:	f8ca 200c 	str.w	r2, [sl, #12]
			poller->is_polling = false;
   504f6:	f884 8000 	strb.w	r8, [r4]
	__asm__ volatile(
   504fa:	f389 8811 	msr	BASEPRI, r9
   504fe:	f3bf 8f6f 	isb	sy
	for (int ii = 0; ii < num_events; ii++) {
   50502:	3501      	adds	r5, #1
   50504:	f10a 0a14 	add.w	sl, sl, #20
   50508:	e7a9      	b.n	5045e <register_events+0x12>
			*state = K_POLL_STATE_FIFO_DATA_AVAILABLE;
   5050a:	2304      	movs	r3, #4
   5050c:	e7e8      	b.n	504e0 <register_events+0x94>
		add_event(&event->queue->poll_events, event, poller);
   5050e:	f8da 0010 	ldr.w	r0, [sl, #16]
   50512:	4622      	mov	r2, r4
   50514:	4651      	mov	r1, sl
   50516:	3010      	adds	r0, #16
		add_event(&event->msgq->poll_events, event, poller);
   50518:	f7ff ff67 	bl	503ea <add_event>
	event->poller = poller;
   5051c:	f8ca 4008 	str.w	r4, [sl, #8]
			events_registered += 1;
   50520:	3601      	adds	r6, #1
   50522:	e7ea      	b.n	504fa <register_events+0xae>
		add_event(&event->signal->poll_events, event, poller);
   50524:	f8da 0010 	ldr.w	r0, [sl, #16]
   50528:	4622      	mov	r2, r4
   5052a:	4651      	mov	r1, sl
   5052c:	e7f4      	b.n	50518 <register_events+0xcc>
		add_event(&event->msgq->poll_events, event, poller);
   5052e:	f8da 0010 	ldr.w	r0, [sl, #16]
   50532:	4622      	mov	r2, r4
   50534:	4651      	mov	r1, sl
   50536:	3024      	adds	r0, #36	; 0x24
   50538:	e7ee      	b.n	50518 <register_events+0xcc>

0005053a <signal_poll_event>:
{
   5053a:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	struct z_poller *poller = event->poller;
   5053e:	6884      	ldr	r4, [r0, #8]
{
   50540:	4605      	mov	r5, r0
   50542:	460e      	mov	r6, r1
	if (poller != NULL) {
   50544:	b144      	cbz	r4, 50558 <signal_poll_event+0x1e>
		if (poller->mode == MODE_POLL) {
   50546:	7863      	ldrb	r3, [r4, #1]
   50548:	2b01      	cmp	r3, #1
   5054a:	d12e      	bne.n	505aa <signal_poll_event+0x70>
	if (!z_is_thread_pending(thread)) {
   5054c:	f814 3c53 	ldrb.w	r3, [r4, #-83]
   50550:	f013 0302 	ands.w	r3, r3, #2
   50554:	d10a      	bne.n	5056c <signal_poll_event+0x32>
		poller->is_polling = false;
   50556:	7023      	strb	r3, [r4, #0]
	event->state |= state;
   50558:	68eb      	ldr	r3, [r5, #12]
   5055a:	f3c3 3286 	ubfx	r2, r3, #14, #7
   5055e:	4316      	orrs	r6, r2
	event->poller = NULL;
   50560:	2000      	movs	r0, #0
	event->state |= state;
   50562:	f366 3394 	bfi	r3, r6, #14, #7
	event->poller = NULL;
   50566:	60a8      	str	r0, [r5, #8]
	event->state |= state;
   50568:	60eb      	str	r3, [r5, #12]
	return retcode;
   5056a:	e03e      	b.n	505ea <signal_poll_event+0xb0>
	if (z_is_thread_timeout_expired(thread)) {
   5056c:	e954 230e 	ldrd	r2, r3, [r4, #-56]	; 0x38
   50570:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   50574:	bf08      	it	eq
   50576:	f112 0f02 	cmneq.w	r2, #2
   5057a:	d032      	beq.n	505e2 <signal_poll_event+0xa8>
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
   5057c:	f1a4 0860 	sub.w	r8, r4, #96	; 0x60
	z_unpend_thread(thread);
   50580:	4640      	mov	r0, r8
   50582:	f7ff fe4a 	bl	5021a <z_unpend_thread>
	arch_thread_return_value_set(thread,
   50586:	2e08      	cmp	r6, #8
   50588:	bf0c      	ite	eq
   5058a:	f06f 0303 	mvneq.w	r3, #3
   5058e:	2300      	movne	r3, #0
   50590:	61e3      	str	r3, [r4, #28]
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   50592:	f814 3c53 	ldrb.w	r3, [r4, #-83]
   50596:	06db      	lsls	r3, r3, #27
   50598:	d109      	bne.n	505ae <signal_poll_event+0x74>
   5059a:	f854 7c48 	ldr.w	r7, [r4, #-72]
   5059e:	b937      	cbnz	r7, 505ae <signal_poll_event+0x74>
	z_ready_thread(thread);
   505a0:	4640      	mov	r0, r8
   505a2:	f7ff fde7 	bl	50174 <z_ready_thread>
		poller->is_polling = false;
   505a6:	7027      	strb	r7, [r4, #0]
		if (retcode < 0) {
   505a8:	e7d6      	b.n	50558 <signal_poll_event+0x1e>
		} else if (poller->mode == MODE_TRIGGERED) {
   505aa:	2b02      	cmp	r3, #2
   505ac:	d001      	beq.n	505b2 <signal_poll_event+0x78>
		poller->is_polling = false;
   505ae:	2300      	movs	r3, #0
   505b0:	e7d1      	b.n	50556 <signal_poll_event+0x1c>
{
	struct z_poller *poller = event->poller;
	struct k_work_poll *twork =
		CONTAINER_OF(poller, struct k_work_poll, poller);

	if (poller->is_polling && twork->workq != NULL) {
   505b2:	7823      	ldrb	r3, [r4, #0]
   505b4:	2b00      	cmp	r3, #0
   505b6:	d0cf      	beq.n	50558 <signal_poll_event+0x1e>
   505b8:	f854 7c04 	ldr.w	r7, [r4, #-4]
   505bc:	2f00      	cmp	r7, #0
   505be:	d0f2      	beq.n	505a6 <signal_poll_event+0x6c>
		struct k_work_q *work_q = twork->workq;

		z_abort_timeout(&twork->timeout);
		twork->poll_result = 0;
   505c0:	f04f 0800 	mov.w	r8, #0
		z_abort_timeout(&twork->timeout);
   505c4:	f1a4 0914 	sub.w	r9, r4, #20
   505c8:	f104 0014 	add.w	r0, r4, #20
   505cc:	f7ff fe82 	bl	502d4 <z_abort_timeout>
		twork->poll_result = 0;
   505d0:	f8c4 802c 	str.w	r8, [r4, #44]	; 0x2c
		z_work_submit_to_queue(work_q, &twork->work);
   505d4:	4649      	mov	r1, r9
   505d6:	4638      	mov	r0, r7
   505d8:	f7ff fce9 	bl	4ffae <z_work_submit_to_queue>
		poller->is_polling = false;
   505dc:	f884 8000 	strb.w	r8, [r4]
		if (retcode < 0) {
   505e0:	e7ba      	b.n	50558 <signal_poll_event+0x1e>
		poller->is_polling = false;
   505e2:	2300      	movs	r3, #0
   505e4:	7023      	strb	r3, [r4, #0]
		return -EAGAIN;
   505e6:	f06f 000a 	mvn.w	r0, #10
}
   505ea:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

000505ee <clear_event_registrations>:
	while (num_events--) {
   505ee:	2314      	movs	r3, #20
{
   505f0:	b5f0      	push	{r4, r5, r6, r7, lr}
   505f2:	fb03 0001 	mla	r0, r3, r1, r0
	event->poller = NULL;
   505f6:	2400      	movs	r4, #0
	switch (event->type) {
   505f8:	f44f 768b 	mov.w	r6, #278	; 0x116
	while (num_events--) {
   505fc:	b901      	cbnz	r1, 50600 <clear_event_registrations+0x12>
}
   505fe:	bdf0      	pop	{r4, r5, r6, r7, pc}
	switch (event->type) {
   50600:	f810 3c07 	ldrb.w	r3, [r0, #-7]
	event->poller = NULL;
   50604:	f840 4c0c 	str.w	r4, [r0, #-12]
	switch (event->type) {
   50608:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   5060c:	2b08      	cmp	r3, #8
   5060e:	f1a0 0714 	sub.w	r7, r0, #20
   50612:	d80c      	bhi.n	5062e <clear_event_registrations+0x40>
   50614:	fa26 f303 	lsr.w	r3, r6, r3
   50618:	07db      	lsls	r3, r3, #31
   5061a:	d508      	bpl.n	5062e <clear_event_registrations+0x40>
	return node->next != NULL;
   5061c:	f850 3c14 	ldr.w	r3, [r0, #-20]
	if (remove_event && sys_dnode_is_linked(&event->_node)) {
   50620:	b12b      	cbz	r3, 5062e <clear_event_registrations+0x40>
	sys_dnode_t *const prev = node->prev;
   50622:	f850 5c10 	ldr.w	r5, [r0, #-16]
	prev->next = next;
   50626:	602b      	str	r3, [r5, #0]
	next->prev = prev;
   50628:	605d      	str	r5, [r3, #4]
	node->prev = NULL;
   5062a:	e940 4405 	strd	r4, r4, [r0, #-20]
   5062e:	f382 8811 	msr	BASEPRI, r2
   50632:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
   50636:	f04f 0320 	mov.w	r3, #32
   5063a:	f3ef 8211 	mrs	r2, BASEPRI
   5063e:	f383 8812 	msr	BASEPRI_MAX, r3
   50642:	f3bf 8f6f 	isb	sy
   50646:	3901      	subs	r1, #1
   50648:	4638      	mov	r0, r7
   5064a:	e7d7      	b.n	505fc <clear_event_registrations+0xe>

0005064c <k_poll_event_init>:
{
   5064c:	b510      	push	{r4, lr}
	event->type = type;
   5064e:	0552      	lsls	r2, r2, #21
   50650:	0209      	lsls	r1, r1, #8
   50652:	f401 517c 	and.w	r1, r1, #16128	; 0x3f00
   50656:	f402 1200 	and.w	r2, r2, #2097152	; 0x200000
   5065a:	430a      	orrs	r2, r1
   5065c:	7b01      	ldrb	r1, [r0, #12]
	event->poller = NULL;
   5065e:	2400      	movs	r4, #0
	event->type = type;
   50660:	430a      	orrs	r2, r1
	event->obj = obj;
   50662:	e9c0 2303 	strd	r2, r3, [r0, #12]
	event->poller = NULL;
   50666:	6084      	str	r4, [r0, #8]
}
   50668:	bd10      	pop	{r4, pc}

0005066a <z_handle_obj_poll_events>:
{
   5066a:	4603      	mov	r3, r0
	return list->head == list;
   5066c:	6800      	ldr	r0, [r0, #0]
	if (!sys_dlist_is_empty(list)) {
   5066e:	4283      	cmp	r3, r0
   50670:	d008      	beq.n	50684 <z_handle_obj_poll_events+0x1a>
	sys_dnode_t *const next = node->next;
   50672:	e9d0 3200 	ldrd	r3, r2, [r0]
	prev->next = next;
   50676:	6013      	str	r3, [r2, #0]
	next->prev = prev;
   50678:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   5067a:	2300      	movs	r3, #0
	node->prev = NULL;
   5067c:	e9c0 3300 	strd	r3, r3, [r0]
		(void) signal_poll_event(poll_event, state);
   50680:	f7ff bf5b 	b.w	5053a <signal_poll_event>
}
   50684:	4770      	bx	lr

00050686 <z_impl_k_poll_signal_init>:
	sig->signaled = 0U;
   50686:	2300      	movs	r3, #0
	list->tail = (sys_dnode_t *)list;
   50688:	e9c0 0000 	strd	r0, r0, [r0]
   5068c:	6083      	str	r3, [r0, #8]
}
   5068e:	4770      	bx	lr

00050690 <z_heap_aligned_alloc>:
	return __builtin_add_overflow(a, b, result);
}

static inline bool size_add_overflow(size_t a, size_t b, size_t *result)
{
	return __builtin_add_overflow(a, b, result);
   50690:	3204      	adds	r2, #4
{
   50692:	b5d3      	push	{r0, r1, r4, r6, r7, lr}
   50694:	4604      	mov	r4, r0
   50696:	d208      	bcs.n	506aa <z_heap_aligned_alloc+0x1a>
	mem = k_heap_aligned_alloc(heap, __align, size, K_NO_WAIT);
   50698:	2600      	movs	r6, #0
   5069a:	2700      	movs	r7, #0
   5069c:	e9cd 6700 	strd	r6, r7, [sp]
   506a0:	f041 0104 	orr.w	r1, r1, #4
   506a4:	f7ff fa2c 	bl	4fb00 <k_heap_aligned_alloc>
	if (mem == NULL) {
   506a8:	b910      	cbnz	r0, 506b0 <z_heap_aligned_alloc+0x20>
		return NULL;
   506aa:	2000      	movs	r0, #0
}
   506ac:	b002      	add	sp, #8
   506ae:	bdd0      	pop	{r4, r6, r7, pc}
	*heap_ref = heap;
   506b0:	f840 4b04 	str.w	r4, [r0], #4
	return mem;
   506b4:	e7fa      	b.n	506ac <z_heap_aligned_alloc+0x1c>

000506b6 <k_free>:
	if (ptr != NULL) {
   506b6:	b120      	cbz	r0, 506c2 <k_free+0xc>
		k_heap_free(*heap_ref, ptr);
   506b8:	1f01      	subs	r1, r0, #4
   506ba:	f850 0c04 	ldr.w	r0, [r0, #-4]
   506be:	f7ff ba6c 	b.w	4fb9a <k_heap_free>
}
   506c2:	4770      	bx	lr

000506c4 <k_malloc>:
{
   506c4:	4601      	mov	r1, r0
	void *ret = k_aligned_alloc(sizeof(void *), size);
   506c6:	2004      	movs	r0, #4
   506c8:	f7f7 bd88 	b.w	481dc <k_aligned_alloc>
